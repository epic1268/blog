<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go并发编程实战课 on Docs</title>
    <link>https://politcloud.org/tags/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/</link>
    <description>Recent content in Go并发编程实战课 on Docs</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 10 Jan 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://politcloud.org/tags/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>01__Mutex：如何解决资源并发访问问题？</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/01__mutex%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B5%84%E6%BA%90%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/01__mutex%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B5%84%E6%BA%90%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;今天是我们 Go 并发编程实战课的第一讲，我们就直接从解决并发访问这个棘手问题入手。&lt;/p&gt;&#xA;&lt;p&gt;说起并发访问问题，真是太常见了，比如多个 goroutine 并发更新同一个资源，像计数器；同时更新用户的账户信息；秒杀系统；往同一个 buffer 中并发写入数据等等。如果没有互斥控制，就会出现一些异常情况，比如计数器的计数不准确、用户的账户可能出现透支、秒杀系统出现超卖、buffer 中的数据混乱，等等，后果都很严重。&lt;/p&gt;</description>
    </item>
    <item>
      <title>02__Mutex：庖丁解牛看实现</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/02__mutex%E5%BA%96%E4%B8%81%E8%A7%A3%E7%89%9B%E7%9C%8B%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/02__mutex%E5%BA%96%E4%B8%81%E8%A7%A3%E7%89%9B%E7%9C%8B%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;上一讲我们一起体验了 Mutex 的使用，竟是那么简单，只有简简单单两个方法，Lock 和 Unlock，进入临界区之前调用 Lock 方法，退出临界区的时候调用 Unlock 方法。这个时候，你一定会有一丝好奇：“它的实现是不是也很简单呢？”&lt;/p&gt;</description>
    </item>
    <item>
      <title>03｜Mutex：4种易错场景大盘点</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/03mutex4%E7%A7%8D%E6%98%93%E9%94%99%E5%9C%BA%E6%99%AF%E5%A4%A7%E7%9B%98%E7%82%B9/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/03mutex4%E7%A7%8D%E6%98%93%E9%94%99%E5%9C%BA%E6%99%AF%E5%A4%A7%E7%9B%98%E7%82%B9/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;上一讲，我带你一起领略了 Mutex 的架构演进之美，现在我们已经清楚 Mutex 的实现细节了。当前 Mutex 的实现貌似非常复杂，其实主要还是针对饥饿模式和公平性问题，做了一些额外处理。但是，我们在第一讲中已经体验过了，Mutex 使用起来还是非常简单的，毕竟，它只有 Lock 和 Unlock 两个方法，使用起来还能复杂到哪里去？&lt;/p&gt;</description>
    </item>
    <item>
      <title>04｜_Mutex：骇客编程，如何拓展额外功能？</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/04_mutex%E9%AA%87%E5%AE%A2%E7%BC%96%E7%A8%8B%E5%A6%82%E4%BD%95%E6%8B%93%E5%B1%95%E9%A2%9D%E5%A4%96%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/04_mutex%E9%AA%87%E5%AE%A2%E7%BC%96%E7%A8%8B%E5%A6%82%E4%BD%95%E6%8B%93%E5%B1%95%E9%A2%9D%E5%A4%96%E5%8A%9F%E8%83%BD/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;前面三讲，我们学习了互斥锁 Mutex 的基本用法、实现原理以及易错场景，可以说是涵盖了互斥锁的方方面面。如果你能熟练掌握这些内容，那么，在大多数的开发场景中，你都可以得心应手。&lt;/p&gt;</description>
    </item>
    <item>
      <title>05｜_RWMutex：读写锁的实现原理及避坑指南</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/05_rwmutex%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/05_rwmutex%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;在前面的四节课中，我们学习了第一个同步原语，即 Mutex，我们使用它来保证读写共享资源的安全性。不管是读还是写，我们都通过 Mutex 来保证只有一个 goroutine 访问共享资源，这在某些情况下有点“浪费”。比如说，在写少读多的情况下，即使一段时间内没有写操作，大量并发的读访问也不得不在 Mutex 的保护下变成了串行访问，这个时候，使用 Mutex，对性能的影响就比较大。&lt;/p&gt;</description>
    </item>
    <item>
      <title>06__WaitGroup：协同等待，任务编排利器</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/06__waitgroup%E5%8D%8F%E5%90%8C%E7%AD%89%E5%BE%85%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92%E5%88%A9%E5%99%A8/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/06__waitgroup%E5%8D%8F%E5%90%8C%E7%AD%89%E5%BE%85%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92%E5%88%A9%E5%99%A8/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;WaitGroup，我们以前都多多少少学习过，或者是使用过。其实，WaitGroup 很简单，就是 package sync 用来做任务编排的一个并发原语。它要解决的就是并发 - 等待的问题：现在有一个 goroutine A 在检查点（checkpoint）等待一组 goroutine 全部完成，如果在执行任务的这些 goroutine 还没全部完成，那么 goroutine A 就会阻塞在检查点，直到所有 goroutine 都完成后才能继续执行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>07__Cond：条件变量的实现机制及避坑指南</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/07__cond%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%8F%8A%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/07__cond%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%8F%8A%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;在写 Go 程序之前，我曾经写了 10 多年的 Java 程序，也面试过不少 Java 程序员。在 Java 面试中，经常被问到的一个知识点就是等待 / 通知（wait/notify）机制。面试官经常会这样考察候选人：请实现一个限定容量的队列（queue），当队列满或者空的时候，利用等待 / 通知机制实现阻塞或者唤醒。&lt;/p&gt;</description>
    </item>
    <item>
      <title>08__Once：一个简约而不简单的并发原语</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/08__once%E4%B8%80%E4%B8%AA%E7%AE%80%E7%BA%A6%E8%80%8C%E4%B8%8D%E7%AE%80%E5%8D%95%E7%9A%84%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/08__once%E4%B8%80%E4%B8%AA%E7%AE%80%E7%BA%A6%E8%80%8C%E4%B8%8D%E7%AE%80%E5%8D%95%E7%9A%84%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;这一讲我来讲一个简单的并发原语：Once。为什么要学习 Once 呢？我先给你答案：&lt;strong&gt;Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>09__map：如何实现线程安全的map类型？</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/09__map%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84map%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/09__map%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84map%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;哈希表（Hash Table）这个数据结构，我们已经非常熟悉了。它实现的就是 key-value 之间的映射关系，主要提供的方法包括 Add、Lookup、Delete 等。因为这种数据结构是一个基础的数据结构，每个 key 都会有一个唯一的索引值，通过索引可以很快地找到对应的值，所以使用哈希表进行数据的插入和读取都是很快的。Go 语言本身就内建了这样一个数据结构，也就是 &lt;strong&gt;map 数据类型&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>10__Pool：性能提升大杀器</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/10__pool%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E5%A4%A7%E6%9D%80%E5%99%A8/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/10__pool%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E5%A4%A7%E6%9D%80%E5%99%A8/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;Go 是一个自动垃圾回收的编程语言，采用三色并发标记算法标记对象并回收。和其它没有自动垃圾回收的编程语言不同，使用 Go 语言创建对象的时候，我们没有回收 / 释放的心理负担，想用就用，想创建就创建。&lt;/p&gt;</description>
    </item>
    <item>
      <title>11__Context：信息穿透上下文</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/11__context%E4%BF%A1%E6%81%AF%E7%A9%BF%E9%80%8F%E4%B8%8A%E4%B8%8B%E6%96%87/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/11__context%E4%BF%A1%E6%81%AF%E7%A9%BF%E9%80%8F%E4%B8%8A%E4%B8%8B%E6%96%87/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;在这节课正式开始之前，我想先带你看一个工作中的场景。&lt;/p&gt;&#xA;&lt;p&gt;假设有一天你进入办公室，突然同事们都围住你，然后大喊“小王小王你最帅”，此时你可能一头雾水，只能尴尬地笑笑。为啥呢？因为你缺少上下文的信息，不知道之前发生了什么。&lt;/p&gt;</description>
    </item>
    <item>
      <title>12__atomic：要保证原子操作，一定要使用这几种方法</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/12__atomic%E8%A6%81%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%80%E5%AE%9A%E8%A6%81%E4%BD%BF%E7%94%A8%E8%BF%99%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/12__atomic%E8%A6%81%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%80%E5%AE%9A%E8%A6%81%E4%BD%BF%E7%94%A8%E8%BF%99%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;前面我们在学习 Mutex、RWMutex 等并发原语的实现时，你可以看到，最底层是通过 atomic 包中的一些原子操作来实现的。当时，为了让你的注意力集中在这些原语的功能实现上，我并没有展开介绍这些原子操作是干什么用的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>13__Channel：另辟蹊径，解决并发问题</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/13__channel%E5%8F%A6%E8%BE%9F%E8%B9%8A%E5%BE%84%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/13__channel%E5%8F%A6%E8%BE%9F%E8%B9%8A%E5%BE%84%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;Channel 是 Go 语言内建的 first-class 类型，也是 Go 语言与众不同的特性之一。Go 语言的 Channel 设计精巧简单，以至于也有人用其它语言编写了类似 Go 风格的 Channel 库，比如docker/libchan、tylertreat/chan，但是并不像 Go 语言一样把 Channel 内置到了语言规范中。从这一点，你也可以看出来，Channel 的地位在编程语言中的地位之高，比较罕见。&lt;/p&gt;</description>
    </item>
    <item>
      <title>14__Channel：透过代码看典型的应用模式</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/14__channel%E9%80%8F%E8%BF%87%E4%BB%A3%E7%A0%81%E7%9C%8B%E5%85%B8%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/14__channel%E9%80%8F%E8%BF%87%E4%BB%A3%E7%A0%81%E7%9C%8B%E5%85%B8%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;前一讲，我介绍了 Channel 的基础知识，并且总结了几种应用场景。这一讲，我将通过实例的方式，带你逐个学习 Channel 解决这些问题的方法，帮你巩固和完全掌握它的用法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>15__内存模型：Go如何保证并发读写的顺序？</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/15__%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bgo%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99%E7%9A%84%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/15__%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bgo%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99%E7%9A%84%E9%A1%BA%E5%BA%8F/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;Go 官方文档里专门介绍了 Go 的内存模型，你不要误解这里的内存模型的含义，它并不是指 Go 对象的内存分配、内存回收和内存整理的规范，它描述的是并发环境中多 goroutine 读相同变量的时候，变量的可见性条件。具体点说，就是指，在什么条件下，goroutine 在读取一个变量的值的时候，能够看到其它 goroutine 对这个变量进行的写的结果。&lt;/p&gt;</description>
    </item>
    <item>
      <title>159-Go_并发编程实战课</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/159-go_%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/159-go_%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/</guid>
      <description></description>
    </item>
    <item>
      <title>16__Semaphore：一篇文章搞懂信号量</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/16__semaphore%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E4%BF%A1%E5%8F%B7%E9%87%8F/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/16__semaphore%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;在前面的课程里，我们学习了标准库的并发原语、原子操作和 Channel，掌握了这些，你就可以解决 80% 的并发编程问题了。但是，如果你要想进一步提升你的并发编程能力，就需要学习一些第三方库。&lt;/p&gt;</description>
    </item>
    <item>
      <title>17__SingleFlight_和_CyclicBarrier：请求合并和循环栅栏该怎么用？</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/17__singleflight_%E5%92%8C_cyclicbarrier%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6%E5%92%8C%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F%E8%AF%A5%E6%80%8E%E4%B9%88%E7%94%A8/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/17__singleflight_%E5%92%8C_cyclicbarrier%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6%E5%92%8C%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F%E8%AF%A5%E6%80%8E%E4%B9%88%E7%94%A8/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;这节课，我来给你介绍两个非常重要的扩展并发原语：SingleFlight 和 CyclicBarrier。SingleFlight 的作用是将并发请求合并成一个请求，以减少对下层服务的压力；而 CyclicBarrier 是一个可重用的栅栏并发原语，用来控制一组请求同时执行的数据结构。&lt;/p&gt;</description>
    </item>
    <item>
      <title>18__分组操作：处理一组子任务，该用什么并发原语？</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/18__%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C%E5%A4%84%E7%90%86%E4%B8%80%E7%BB%84%E5%AD%90%E4%BB%BB%E5%8A%A1%E8%AF%A5%E7%94%A8%E4%BB%80%E4%B9%88%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/18__%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C%E5%A4%84%E7%90%86%E4%B8%80%E7%BB%84%E5%AD%90%E4%BB%BB%E5%8A%A1%E8%AF%A5%E7%94%A8%E4%BB%80%E4%B9%88%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;共享资源保护、任务编排和消息传递是 Go 并发编程中常见的场景，而&lt;strong&gt;分组执行一批相同的或类似的任务则是任务编排中一类情形&lt;/strong&gt;，所以，这节课，我专门来介绍一下分组编排的一些常用场景和并发原语，包括 ErrGroup、gollback、Hunch 和 schedgroup。&lt;/p&gt;</description>
    </item>
    <item>
      <title>19__在分布式环境中，Leader选举、互斥锁和读写锁该如何实现？</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/19__%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%ADleader%E9%80%89%E4%B8%BE%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/19__%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%ADleader%E9%80%89%E4%B8%BE%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;在前面的课程里，我们学习的并发原语都是在进程内使用的，也就是我们常见的一个运行程序为了控制共享资源、实现任务编排和进行消息传递而提供的控制类型。在接下来的这两节课里，我要讲的是几个分布式的并发原语，它们控制的资源或编排的任务分布在不同进程、不同机器上。&lt;/p&gt;</description>
    </item>
    <item>
      <title>20__在分布式环境中，队列、栅栏和STM该如何实现？</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/20__%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%98%9F%E5%88%97%E6%A0%85%E6%A0%8F%E5%92%8Cstm%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/20__%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%98%9F%E5%88%97%E6%A0%85%E6%A0%8F%E5%92%8Cstm%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。&lt;/p&gt;&#xA;&lt;p&gt;上一讲，我已经带你认识了基于 etcd 实现的 Leader 选举、互斥锁和读写锁，今天，我们来学习下基于 etcd 的分布式队列、栅栏和 STM。&lt;/p&gt;&#xA;&lt;p&gt;只要你学过计算机算法和数据结构相关的知识，队列这种数据结构你一定不陌生，它是一种先进先出的类型，有出队（dequeue）和入队（enqueue）两种操作。在第 12 讲中，我专门讲到了一种叫做 lock-free 的队列。队列在单机的应用程序中常常使用，但是在分布式环境中，多节点如何并发地执行入队和出队的操作呢？这一讲，我会带你认识一下基于 etcd 实现的分布式队列。&lt;/p&gt;</description>
    </item>
    <item>
      <title>结束语__再聊Go并发编程的价值和精进之路</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/%E7%BB%93%E6%9D%9F%E8%AF%AD__%E5%86%8D%E8%81%8Ago%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BB%B7%E5%80%BC%E5%92%8C%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/%E7%BB%93%E6%9D%9F%E8%AF%AD__%E5%86%8D%E8%81%8Ago%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BB%B7%E5%80%BC%E5%92%8C%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/</guid>
      <description>&lt;p&gt;你好，我是鸟窝。很高兴和你一起度过了一个多月的时间，到了和你说再见的时候了。&lt;/p&gt;&#xA;&lt;p&gt;在过去的这些年里，我一直在研究 Go 并发编程，时间越久，越觉得，掌握 Go 并发原语是一件很有意思的事情。&lt;/p&gt;</description>
    </item>
    <item>
      <title>开篇词__想吃透Go并发编程，你得这样学！</title>
      <link>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/%E5%BC%80%E7%AF%87%E8%AF%8D__%E6%83%B3%E5%90%83%E9%80%8Fgo%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BD%A0%E5%BE%97%E8%BF%99%E6%A0%B7%E5%AD%A6/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/%E5%BC%80%E7%AF%87%E8%AF%8D__%E6%83%B3%E5%90%83%E9%80%8Fgo%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BD%A0%E5%BE%97%E8%BF%99%E6%A0%B7%E5%AD%A6/</guid>
      <description>&lt;p&gt;你好，我是晁岳攀，网名鸟窝。之前我在微博研发平台架构中心担任资深架构师，同时也是微服务框架 rpcx 的作者，欢迎来到“Go 并发编程实战课”。&lt;/p&gt;&#xA;&lt;h2 id=&#34;并发编程为什么选-go&#34;&gt;并发编程，为什么选 Go？&lt;/h2&gt;&#xA;&lt;p&gt;为什么要学 Go 并发呢？我想先和你聊聊我和 Go 结缘的经历。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
