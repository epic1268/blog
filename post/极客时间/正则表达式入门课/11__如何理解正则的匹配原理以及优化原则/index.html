<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>11__如何理解正则的匹配原理以及优化原则？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是伟忠，这一节课我们一起来学习正则匹配原理相关的内容，以及在书写正则时的一些优化方法。
这节课我主要给你讲解一下正则匹配过程，回顾一下之前讲的回溯，以及 DFA 和 NFA 引擎的工作方式，方便你明白正则是如何进行匹配的。这些原理性的知识，能够帮助我们快速理解为什么有些正则表达式不符合预期，也可以避免一些常见的错误。只有了解正则引擎的工作原理，我们才可以更轻松地写出正确的，性能更好的正则表达式。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/11__%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%AD%A3%E5%88%99%E7%9A%84%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/11__%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%AD%A3%E5%88%99%E7%9A%84%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="11__如何理解正则的匹配原理以及优化原则？">
  <meta property="og:description" content="你好，我是伟忠，这一节课我们一起来学习正则匹配原理相关的内容，以及在书写正则时的一些优化方法。
这节课我主要给你讲解一下正则匹配过程，回顾一下之前讲的回溯，以及 DFA 和 NFA 引擎的工作方式，方便你明白正则是如何进行匹配的。这些原理性的知识，能够帮助我们快速理解为什么有些正则表达式不符合预期，也可以避免一些常见的错误。只有了解正则引擎的工作原理，我们才可以更轻松地写出正确的，性能更好的正则表达式。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="正则表达式入门课">

  <meta itemprop="name" content="11__如何理解正则的匹配原理以及优化原则？">
  <meta itemprop="description" content="你好，我是伟忠，这一节课我们一起来学习正则匹配原理相关的内容，以及在书写正则时的一些优化方法。
这节课我主要给你讲解一下正则匹配过程，回顾一下之前讲的回溯，以及 DFA 和 NFA 引擎的工作方式，方便你明白正则是如何进行匹配的。这些原理性的知识，能够帮助我们快速理解为什么有些正则表达式不符合预期，也可以避免一些常见的错误。只有了解正则引擎的工作原理，我们才可以更轻松地写出正确的，性能更好的正则表达式。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4882">
  <meta itemprop="keywords" content="正则表达式入门课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="11__如何理解正则的匹配原理以及优化原则？">
  <meta name="twitter:description" content="你好，我是伟忠，这一节课我们一起来学习正则匹配原理相关的内容，以及在书写正则时的一些优化方法。
这节课我主要给你讲解一下正则匹配过程，回顾一下之前讲的回溯，以及 DFA 和 NFA 引擎的工作方式，方便你明白正则是如何进行匹配的。这些原理性的知识，能够帮助我们快速理解为什么有些正则表达式不符合预期，也可以避免一些常见的错误。只有了解正则引擎的工作原理，我们才可以更轻松地写出正确的，性能更好的正则表达式。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">11__如何理解正则的匹配原理以及优化原则？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4882 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#有穷状态自动机">有穷状态自动机</a></li>
        <li><a href="#正则的匹配过程">正则的匹配过程</a>
          <ul>
            <li><a href="#dfa-nfa-工作机制">DFA&amp; NFA 工作机制</a></li>
            <li><a href="#posix-nfa-与-传统-nfa-区别">POSIX NFA 与 传统 NFA 区别</a></li>
          </ul>
        </li>
        <li><a href="#回溯">回溯</a></li>
        <li><a href="#优化建议">优化建议</a>
          <ul>
            <li><a href="#1-测试性能的方法">1. 测试性能的方法</a></li>
            <li><a href="#2-提前编译好正则">2. 提前编译好正则</a></li>
            <li><a href="#3-尽量准确表示匹配范围">3. 尽量准确表示匹配范围</a></li>
            <li><a href="#4-提取出公共部分">4. 提取出公共部分</a></li>
            <li><a href="#5-出现可能性大的放左边">5. 出现可能性大的放左边</a></li>
            <li><a href="#6-只在必要时才使用子组">6. 只在必要时才使用子组</a></li>
            <li><a href="#7-警惕嵌套的子组重复">7. 警惕嵌套的子组重复</a></li>
            <li><a href="#8-避免不同分支重复匹配">8. 避免不同分支重复匹配</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#课后思考">课后思考</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是伟忠，这一节课我们一起来学习正则匹配原理相关的内容，以及在书写正则时的一些优化方法。</p>
<p>这节课我主要给你讲解一下正则匹配过程，回顾一下之前讲的回溯，以及 DFA 和 NFA 引擎的工作方式，方便你明白正则是如何进行匹配的。这些原理性的知识，能够帮助我们快速理解为什么有些正则表达式不符合预期，也可以避免一些常见的错误。只有了解正则引擎的工作原理，我们才可以更轻松地写出正确的，性能更好的正则表达式。</p>
<h2 id="有穷状态自动机">有穷状态自动机</h2>
<p>正则之所以能够处理复杂文本，就是因为采用了<strong>有穷状态自动机（</strong> **finite automaton）。**那什么是有穷自动机呢？有穷状态是指一个系统具有有穷个状态，不同的状态代表不同的意义。自动机是指系统可以根据相应的条件，在不同的状态下进行转移。从一个初始状态，根据对应的操作（比如录入的字符集）执行状态转移，最终达到终止状态（可能有一到多个终止状态）。</p>
<p>有穷自动机的具体实现称为正则引擎，主要有 DFA 和 NFA 两种，其中 NFA 又分为传统的 NFA 和 POSIX NFA。</p>
<p>DFA：确定性有穷自动机（Deterministic finite automaton）<br>
NFA：非确定性有穷自动机（Non-deterministic finite automaton）</p>
<p>接下来我们来通过一些示例，来详细看下正则表达式的匹配过程。</p>
<h2 id="正则的匹配过程">正则的匹配过程</h2>
<p>在使用到编程语言时，我们经常会“编译”一下正则表达式，来提升效率，比如在 Python3 中它是下面这样的：</p>
<blockquote>
<blockquote>
<blockquote>
<p>import re<br>
reg = re.compile(r&rsquo;a(?:bb)+a&rsquo;)<br>
reg.findall(&lsquo;abbbba&rsquo;)<br>
[&lsquo;abbbba&rsquo;]</p>
</blockquote>
</blockquote>
</blockquote>
<p>这个编译的过程，其实就是生成自动机的过程，正则引擎会拿着这个自动机去和字符串进行匹配。生成的自动机可能是这样的（下图是使用Regexper 工具生成，再次加工得到的）。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/cfd96baf1f7411c6ce338b4ccc18d777.png" alt=""></p>
<p>在状态 s3 时，不需要输入任何字符，状态也有可能转换成 s1。你可以理解成 a(bb)+a 在匹配了字符 abb 之后，到底在 s3 状态，还是在 s1 状态，这是不确定的。这种状态机就是非确定性有穷状态自动机（Non-deterministic finite automaton 简称 NFA）。</p>
<p>**NFA 和 DFA 是可以相互转化的，**当我们把上面的状态表示成下面这样，就是一台 DFA 状态机了，因为在 s0-s4 这几个状态，每个状态都需要特定的输入，才能发生状态变化。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/1b6c9cbef35fff9690627c9cbb9c9b20.png" alt=""></p>
<p>那这两种状态机的工作方式到底有什么不同呢？我们接着往下看。</p>
<h3 id="dfa-nfa-工作机制">DFA&amp; NFA 工作机制</h3>
<p>下面我通过一个示例，来简单说明 <strong>NFA 与 DFA 引擎工作方式的区别</strong>：</p>
<p>字符串：we study on jikeshijian app<br>
正则：jike(zhushou|shijian|shixi)</p>
<p>NFA 引擎的工作方式是，先看正则，再看文本，而且以正则为主导。正则中的第一个字符是 j，NFA 引擎在字符串中查找 j，接着匹配其后是否为 i，如果是 i 则继续，这样一直找到 jike。</p>
<p>regex: jike(zhushou|shijian|shixi)<br>
^<br>
text: we study on jikeshijian app<br>
^</p>
<p>我们再根据正则看文本后面是不是 z，发现不是，此时 zhushou 分支淘汰。</p>
<p>regex: jike(zhushou|shijian|shixi)<br>
^<br>
淘汰此分支 (zhushou)<br>
text: we study on jikeshijian app<br>
^</p>
<p>我们接着看其它的分支，看文本部分是不是 s，直到 shijian 整个匹配上。shijian 在匹配过程中如果不失败，就不会看后面的 shixi 分支。当匹配上了 shijian 后，整个文本匹配完毕，也不会再看 shixi 分支。</p>
<p>假设这里文本改一下，把 jikeshijian 变成 jikeshixi，正则 shi<strong>j</strong>ian 的 j 匹配不上时 shixi 的 x，会接着使用正则 shixi 来进行匹配，重新从 s 开始（NFA 引擎会记住这里）。</p>
<p>第二个分支匹配失败<br>
regex: jike(zhushou|shijian|shixi)<br>
^<br>
淘汰此分支 (正则 j 匹配不上文本 x)<br>
text: we study on jikeshixi app<br>
^</p>
<p>再次尝试第三个分支<br>
regex: jike(zhushou|shijian|shixi)<br>
^<br>
text: we study on jikeshixi app<br>
^</p>
<p>也就是说，NFA 是以正则为主导，反复测试字符串，这样字符串中同一部分，有可能被反复测试很多次。</p>
<p>而 DFA 不是这样的，DFA 会先看文本，再看正则表达式，是以文本为主导的。在具体匹配过程中，DFA 会从 we 中的 w 开始依次查找 j，定位到 j，这个字符后面是 i。所以我们接着看正则部分是否有 i，如果正则后面是个 i，那就以同样的方式，匹配到后面的 ke。</p>
<p>text: we study on jikeshijian app<br>
^<br>
regex: jike(zhushou|shijian|shixi)<br>
^</p>
<p>继续进行匹配，文本 e 后面是字符 s，DFA 接着看正则表达式部分，此时 zhushou 分支被淘汰，开头是 s 的分支 shijian 和 shixi 符合要求。</p>
<p>text: we study on jikeshijian app<br>
^<br>
regex: jike(zhushou|shijian|shixi)<br>
^       ^       ^<br>
淘汰     符合    符合</p>
<p>然后 DFA 依次检查字符串，检测到 shijian 中的 j 时，只有 shijian 分支符合，淘汰 shixi，接着看分别文本后面的 ian，和正则比较，匹配成功。</p>
<p>text: we study on jikeshijian app<br>
^<br>
regex: jike(zhushou|shijian|shixi)<br>
^       ^<br>
符合     淘汰</p>
<p>从这个示例你可以看到，DFA 和 NFA 两种引擎的工作方式完全不同。NFA 是以表达式为主导的，先看正则表达式，再看文本。而 DFA 则是以文本为主导，先看文本，再看正则表达式。</p>
<p>一般来说，DFA 引擎会更快一些，因为整个匹配过程中，字符串只看一遍，不会发生回溯，相同的字符不会被测试两次。也就是说 DFA 引擎执行的时间一般是线性的。DFA 引擎可以确保匹配到可能的最长字符串。但由于 DFA 引擎只包含有限的状态，所以它没有反向引用功能；并且因为它不构造显示扩展，它也不支持捕获子组。</p>
<p>NFA 以表达式为主导，它的引擎是使用贪心匹配回溯算法实现。NFA 通过构造特定扩展，支持子组和反向引用。但由于 NFA 引擎会发生回溯，即它会对字符串中的同一部分，进行很多次对比。因此，在最坏情况下，它的执行速度可能非常慢。</p>
<h3 id="posix-nfa-与-传统-nfa-区别">POSIX NFA 与 传统 NFA 区别</h3>
<p>因为传统的 NFA 引擎“急于”报告匹配结果，找到第一个匹配上的就返回了，所以可能会导致还有更长的匹配未被发现。比如使用正则 pos|posix 在文本 posix 中进行匹配，传统的 NFA 从文本中找到的是 pos，而不是 posix，而 POSIX NFA 找到的是 posix。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/38542d7f0a5ad63dd4aa5549a216796c.png" alt=""></p>
<p>POSIX NFA 的应用很少，主要是 Unix/Linux 中的某些工具。POSIX NFA 引擎与传统的 NFA 引擎类似，但不同之处在于，POSIX NFA 在找到可能的最长匹配之前会继续回溯，也就是说它会尽可能找最长的，如果分支一样长，以最左边的为准（“The Longest-Leftmost”）。因此，POSIX NFA 引擎的速度要慢于传统的 NFA 引擎。</p>
<p>我们日常面对的，一般都是传统的 NFA，所以通常都是最左侧的分支优先，在书写正则的时候务必要注意这一点。</p>
<p>下面是 DFA、传统 NFA 以及 POSIX NFA 引擎的特点总结：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/9100a8640e926d5bbf1f78dd9ad6997d.png" alt=""></p>
<h2 id="回溯">回溯</h2>
<p>回溯是 NFA 引擎才有的，并且只有在正则中出现<strong>量词</strong>或<strong>多选分支结构</strong>时，才可能会发生回溯。</p>
<p>比如我们使用正则 a+ab 来匹配 文本 aab 的时候，过程是这样的，a+ 是贪婪匹配，会占用掉文本中的两个 a，但正则接着又是 a，文本部分只剩下 b，只能通过回溯，让 a+ 吐出一个 a，再次尝试。</p>
<p>如果正则是使用 <code>.*ab</code> 去匹配一个比较长的字符串就更糟糕了，因为 <code>.*</code> 会吃掉整个字符串（不考虑换行，假设文本中没有换行），然后，你会发现正则中还有 ab 没匹配到内容，只能将 <code>.*</code> 匹配上的字符串吐出一个字符，再尝试，还不行，再吐出一个，不断尝试。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/d49149d2114faddbe00c0d429cd99309.png" alt=""></p>
<p>所以在工作中，我们要尽量不用 <strong>.</strong>* ，除非真的有必要，因为点能匹配的范围太广了，我们要尽可能精确。常见的解决方式有两种，比如要提取引号中的内容时，使用“<strong>[^&quot;]+</strong>”，或者使用非贪婪的方式“<strong>.+?</strong>”，来减少“匹配上的内容不断吐出，再次尝试”的过程。</p>
<p>我们再回头看一下之前讲解的店铺名匹配示例：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/123c9b3cf0dd37379e3a31be13a6e667.png" alt=""></p>
<p>从示例我们可以看到，一个很短的字符串，NFA 引擎尝试步骤达到了 9021 次，由于是贪婪匹配，第一个分支能匹配上 this is a cat 部分，接着后面的逗号匹配失败，使用第二个分支匹配，再次失败，此时贪婪匹配部分结束。NFA 引擎接着用正则后面的 $ 来进行匹配，但此处不是文本结尾，匹配不上，发生回溯，吐出第一个分支匹配上的 t，使用第二个分支匹配 t 再试，还是匹配不上。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/38bcc1904977bd70c60736bd8c758b31.png" alt=""></p>
<p>我们继续回溯，第二个分支匹配上的 t 吐出，第一个分支匹配上的 a 也吐出，再用第二个分支匹配 a 再试，如此发生了大量的回溯。你可以使用 regex101.com 中的 Regex Debugger 来调试一下这个过程，加深你的理解。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/b4426427a5682519a130765a785e0f87.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/6f4d0aa0e42e75b16d0c0fdd685ca6bf.png" alt=""></p>
<p>我们来尝试优化一下，把第一个分支中的 A-Za-z 去掉，因为后面多选分支结构中重复了，我们再看一下正则尝试匹配的次数（示例），可以看到只尝试匹配了 57 次就结束了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/f17fe54605b8877a4608cff9cc8d746c.png" alt=""></p>
<p>所以一定要记住，不要在多选择分支中，出现重复的元素。到这里，你对之前文章提到的“回溯不可怕，我们要尽量减少回溯后的判断”是不是有了进一步的理解呢？</p>
<p>另外，之前我们说的独占模式，你可以把它可以理解为贪婪模式的一种优化，它也会发生广义的回溯，但它不会吐出已经匹配上的字符。独占模式匹配到英文逗号那儿，不会吐出已经匹配上的字符，匹配就失败了，所以采用独占模式也能解决性能问题（示例）。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/27c78ed2f728a4d4b6de152f8a7707cc.png" alt=""></p>
<p>但要提醒你的是，独占模式“不吐出已匹配字符”的特性，会使得一些场景不能使用它。另外，只有少数编程语言支持独占模式。</p>
<p>解决这个问题还有其它的方式，比如我们可以尝试移除多选分支选择结构，直接用中括号表示多选一（示例）。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/95109c0c47cfbcbb943b21fbf1ef98d7.png" alt=""></p>
<p>我们会发现性能也是有显著提升（这里只是测试，真正使用的时候，重复的元素都应该去掉，另外这里也不需要保存子组）。</p>
<h2 id="优化建议">优化建议</h2>
<p>学习了原理之后，有助于我们写出更好的正则。我们必须先保证正则的功能是正确的，然后再进行优化性能，下面我给了你一些优化的方法供你参考。</p>
<h3 id="1-测试性能的方法">1. 测试性能的方法</h3>
<p>我们可以使用 ipython 来测试正则的性能，ipython 是一个 Python shell 增强交互工具，在 macOS/Windows/Linux 上都可以安装使用。在测试正则表达式时，它非常有用，比如下面通过一个示例，来测试在字符串中查找 abc 时的时间消耗。</p>
<p>In [1]: import re<br>
In [2]: x = &lsquo;-&rsquo; * 1000000 + &lsquo;abc&rsquo;<br>
In [3]: timeit re.search(&lsquo;abc&rsquo;, x)<br>
480 µs ± 8.06 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</p>
<p>另外，你也可以通过前面 regex101.com 查看正则和文本匹配的次数，来得知正则的性能信息。</p>
<h3 id="2-提前编译好正则">2. 提前编译好正则</h3>
<p>编程语言中一般都有“编译”方法，我们可以使用这个方法提前将正则处理好，这样不用在每次使用的时候去反复构造自动机，从而可以提高正则匹配的性能。</p>
<blockquote>
<blockquote>
<blockquote>
<p>import re<br>
reg = re.compile(r&rsquo;ab?c&rsquo;)  # 先编译好，再使用<br>
reg.findall(&lsquo;abc&rsquo;)<br>
[&lsquo;abc&rsquo;]</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>re.findall(r&rsquo;ab?c&rsquo;, &lsquo;abc&rsquo;)  # 正式使用不建议，但测试功能时较方便<br>
[&lsquo;abc&rsquo;]</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="3-尽量准确表示匹配范围">3. 尽量准确表示匹配范围</h3>
<p>比如我们要匹配引号里面的内容，除了写成“.+?”之外，我们可以写成“[^&quot;]+”。使用 [^&quot;] 要比使用点号好很多，虽然使用的是贪婪模式，但它不会出现点号将引号匹配上，再吐出的问题。</p>
<h3 id="4-提取出公共部分">4. 提取出公共部分</h3>
<p>通过上面对 NFA 引擎的学习，相信你应该明白 (abcd|abxy) 这样的表达式，可以优化成 ab(cd|xy)，因为 NFA 以正则为主导，会导致字符串中的某些部分重复匹配多次，影响效率。</p>
<p>因此我们会知道<code>th(?:is|at)</code>要比<code>this|that</code>要快一些，但从可读性上看，后者要好一些，这个就需要用的时候去权衡，也可以添加代码注释让代码更容易理解。</p>
<p>类似地，如果是锚点，比如<code>(^this|^that) is</code>这样的，锚点部分也应该独立出来，可以写成比如<code>^th(is|at) is</code>的形式，因为锚点部分也是需要尝试去匹配的，匹配次数要尽可能少。</p>
<h3 id="5-出现可能性大的放左边">5. 出现可能性大的放左边</h3>
<p>由于正则是从左到右看的，把出现概率大的放左边，域名中 .com 的使用是比 .net 多的，所以我们可以写成<code>\.(?:com|net)\b</code>，而不是<code>\.(?:net|com)\b</code>。</p>
<h3 id="6-只在必要时才使用子组">6. 只在必要时才使用子组</h3>
<p>在正则中，括号可以用于归组，但如果某部分后续不会再用到，就不需要保存成子组。通常的做法是，在写好正则后，把不需要保存子组的括号中加上 ?: 来表示只用于归组。如果保存成子组，正则引擎必须做一些额外工作来保存匹配到的内容，因为后面可能会用到，这会降低正则的匹配性能。</p>
<h3 id="7-警惕嵌套的子组重复">7. 警惕嵌套的子组重复</h3>
<p>如果一个组里面包含重复，接着这个组整体也可以重复，比如 <code>(.*)*</code> 这个正则，匹配的次数会呈指数级增长，所以尽量不要写这样的正则。</p>
<h3 id="8-避免不同分支重复匹配">8. 避免不同分支重复匹配</h3>
<p>在多选分支选择中，要避免不同分支出现相同范围的情况，上面回溯的例子中，我们已经进行了比较详细的讲解。</p>
<h2 id="总结">总结</h2>
<p>好了，今天的内容讲完了，我来带你总结回顾一下。</p>
<p>今天带你简单学习了有穷自动机的概念，自动机的具体实现称之为正则引擎。</p>
<p>我们学习了正则引擎的匹配原理，NFA 和 DFA 两种引擎的工作方式完全不同，NFA 是以表达式为主导的，先看正则表达式，再看文本。而 DFA 则是以文本为主导的，先看文本，再看正则表达式。POSIX NFA 是指符合 POSIX 标准的 NFA 引擎，它会不断回溯，以确保找到最左侧最长匹配。</p>
<p>接着我们学习了测试正则表达式性能的方法，以及优化的一些方法，比如提前编译好正则，提取出公共部分，尽量准确地表示范围，必要时才使用子组等。</p>
<p>今天所讲的内容总结脑图如下，你可以回顾一下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/61e5588ef8a08f7d14313c6e874c3c27.png" alt=""></p>
<h2 id="课后思考">课后思考</h2>
<p>最后，我们来做一个小练习吧。通过今天学习的内容，这里有一个示例，要求匹配“由字母或数字组成的字符串，但第一个字符要是小写英文字母”，你能说一下针对这个示例，NFA 引擎的匹配过程么？</p>
<p>文本：a12<br>
正则：^(?=[a-z])[a-z0-9]+$</p>
<p>好，今天的课程就结束了，希望可以帮助到你，也希望你在下方的留言区和我参与讨论，并把文章分享给你的朋友或者同事，一起交流一下。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/">正则表达式入门课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/11__%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%88%91%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E5%8F%98%E6%85%A2%E4%BA%86/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">11__容器文件系统：我在容器中读写文件怎么变慢了？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%AB%98%E6%89%8B%E8%AF%BE/11__%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/">
            <span class="next-text nav-default">11__如何实现高性能的异步网络传输？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
