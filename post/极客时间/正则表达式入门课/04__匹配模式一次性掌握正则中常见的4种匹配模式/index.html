<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>04__匹配模式：一次性掌握正则中常见的4种匹配模式 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是涂伟忠。今天我们一起来学习正则中的匹配模式（Match Mode）。
所谓匹配模式，指的是正则中一些改变元字符匹配行为的方式，比如匹配时不区分英文字母大小写。常见的匹配模式有 4 种，分别是不区分大小写模式、点号通配模式、多行模式和注释模式。我们今天主要来讲一下这 4 种模式。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/04__%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%AC%A1%E6%80%A7%E6%8E%8C%E6%8F%A1%E6%AD%A3%E5%88%99%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%844%E7%A7%8D%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/04__%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%AC%A1%E6%80%A7%E6%8E%8C%E6%8F%A1%E6%AD%A3%E5%88%99%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%844%E7%A7%8D%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="04__匹配模式：一次性掌握正则中常见的4种匹配模式">
  <meta property="og:description" content="你好，我是涂伟忠。今天我们一起来学习正则中的匹配模式（Match Mode）。
所谓匹配模式，指的是正则中一些改变元字符匹配行为的方式，比如匹配时不区分英文字母大小写。常见的匹配模式有 4 种，分别是不区分大小写模式、点号通配模式、多行模式和注释模式。我们今天主要来讲一下这 4 种模式。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="正则表达式入门课">

  <meta itemprop="name" content="04__匹配模式：一次性掌握正则中常见的4种匹配模式">
  <meta itemprop="description" content="你好，我是涂伟忠。今天我们一起来学习正则中的匹配模式（Match Mode）。
所谓匹配模式，指的是正则中一些改变元字符匹配行为的方式，比如匹配时不区分英文字母大小写。常见的匹配模式有 4 种，分别是不区分大小写模式、点号通配模式、多行模式和注释模式。我们今天主要来讲一下这 4 种模式。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3087">
  <meta itemprop="keywords" content="正则表达式入门课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="04__匹配模式：一次性掌握正则中常见的4种匹配模式">
  <meta name="twitter:description" content="你好，我是涂伟忠。今天我们一起来学习正则中的匹配模式（Match Mode）。
所谓匹配模式，指的是正则中一些改变元字符匹配行为的方式，比如匹配时不区分英文字母大小写。常见的匹配模式有 4 种，分别是不区分大小写模式、点号通配模式、多行模式和注释模式。我们今天主要来讲一下这 4 种模式。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">04__匹配模式：一次性掌握正则中常见的4种匹配模式</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3087 字 </span>
          <span class="more-meta"> 预计阅读 7 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#不区分大小写模式case-insensitive">不区分大小写模式（Case-Insensitive）</a></li>
        <li><a href="#点号通配模式dot-all">点号通配模式（Dot All）</a></li>
        <li><a href="#多行匹配模式multiline">多行匹配模式（Multiline）</a></li>
        <li><a href="#注释模式comment">注释模式（Comment）</a></li>
      </ul>
    </li>
    <li><a href="#输出结果-2020-06-2020-07">输出结果 [(&lsquo;2020&rsquo;, &lsquo;06&rsquo;), (&lsquo;2020&rsquo;, &lsquo;07&rsquo;)]</a></li>
    <li><a href="#输出结果-2020-06-2020-07-1">输出结果 [(&lsquo;2020&rsquo;, &lsquo;06&rsquo;), (&lsquo;2020&rsquo;, &lsquo;07&rsquo;)]</a>
      <ul>
        <li><a href="#总结">总结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是涂伟忠。今天我们一起来学习正则中的匹配模式（Match Mode）。</p>
<p>所谓匹配模式，指的是正则中一些<strong>改变元字符匹配行为</strong>的方式，比如匹配时不区分英文字母大小写。常见的匹配模式有 4 种，分别是不区分大小写模式、点号通配模式、多行模式和注释模式。我们今天主要来讲一下这 4 种模式。</p>
<p>需要注意的是，这里的“模式”对应的是英文中的 mode，而不是 pattern。有些地方会把正则表达式 pattern 也翻译成模式，你在网上看到的技术文章中讲的正则模式，有可能指的是正则表达式本身，这一点你需要注意区别。</p>
<h2 id="不区分大小写模式case-insensitive">不区分大小写模式（Case-Insensitive）</h2>
<p>首先，我们来看一下不区分大小写模式。它有什么用呢？学一个知识的时候，我一般喜欢先从它的应用出发，这样有时候更能激发我学习的兴趣，也更容易看到学习成果。</p>
<p>下面我来举个例子说明一下。在进行文本匹配时，我们要关心单词本身的意义。比如要查找单词 cat，我们并不需要关心单词是 CAT、Cat，还是 cat。根据之前我们学到的知识，你可能会把正则写成这样：<strong>[Cc][Aa][Tt]</strong>，这样写虽然可以达到目的，但不够直观，如果单词比较长，写起来容易出错，阅读起来也比较困难。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/73a263b2ffa1cc8c3342b4a406e29795.png" alt=""></p>
<p>那么有没有更好的办法来实现这个需求呢？这时候不区分大小写模式就派上用场了。</p>
<p>我们前面说了，不区分大小写是匹配模式的一种。当我们把<strong>模式修饰符</strong>放在整个正则前面时，就表示整个正则表达式都是不区分大小写的。模式修饰符是通过 <strong>(? 模式标识)</strong> 的方式来表示的。我们只需要把模式修饰符放在对应的正则前，就可以使用指定的模式了。在不区分大小写模式中，由于不分大小写的英文是 Case-<strong>I</strong>nsensitive，那么对应的模式标识就是 I 的小写字母 i，所以不区分大小写的 cat 就可以写成 **(?i)**cat。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/d1569477c61c452dc06a26ccb428ca80.png" alt=""></p>
<p>你看，和**[Cc][Aa][Tt]** 相比，这样是不是清晰简洁了很多呢？</p>
<p>我们也可以用它来尝试匹配两个连续出现的 cat，如下图所示，你会发现，即便是第一个 cat 和第二个 cat 大小写不一致，也可以匹配上。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/60be620ee85c2d710e7d74f8a6be9434.png" alt=""></p>
<p>我给到了你一个测试链接，你可以在这里试试不区分大小写模式：</p>
<p><a href="https://regex101.com/r/x1lg4P/1">https://regex101.com/r/x1lg4P/1</a>。</p>
<p>如果我们想要前面匹配上的结果，和第二次重复时的大小写一致，那该怎么做呢？我们只需要用括号把<strong>修饰符和正则 cat 部分</strong>括起来，加括号相当于作用范围的限定，让不区分大小写只作用于这个括号里的内容。同样的，我在这里给你放了一个测试链接，你可以自己看一下。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/2725f6b831826ec814b72043a2d82b73.png" alt=""></p>
<p>需要注意的是，这里正则写成了 ((?i)cat) \1，而不是 ((?i)(cat)) \1。也就是说，我们给修饰符和 cat 整体加了个括号，而原来 cat 部分的括号去掉了。如果 cat 保留原来的括号，即 ((?i)(cat)) \1，这样正则中就会有两个子组，虽然结果也是对的，但这其实没必要。在上一讲里我们已经讲解了相关的内容，如果忘记了你可以回去复习一下。</p>
<p>到这里，我们再进阶一下。如果用正则匹配，实现部分区分大小写，另一部分不区分大小写，这该如何操作呢？就比如说我现在想要，the cat 中的 the 不区分大小写，cat 区分大小写。</p>
<p>通过上面的学习，你应该能很快写出相应的正则，也就是 (**(?i)**the) cat。实现的效果如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/ec3715b548536cf1ec7beeeb118cbf3d.png" alt=""></p>
<p>我把部分区分大小写，部分不区分大小写的测试链接放在这里，你可以看一下。</p>
<p>有一点需要你注意一下，上面讲到的通过<strong>修饰符指定匹配模式</strong>的方式，在大部分编程语言中都是可以直接使用的，但在 JS 中我们需要使用 /regex/<strong>i</strong> 来指定匹配模式。在编程语言中通常会提供一些预定义的常量，来进行匹配模式的指定。比如 Python 中可以使用 re.IGNORECASE 或 re.I，来传入正则函数中来表示不区分大小写。我下面给出了你一个示例，你可以看一下。</p>
<blockquote>
<blockquote>
<blockquote>
<p>import re<br>
re.findall(r&quot;cat&quot;, &ldquo;CAT Cat cat&rdquo;, re.IGNORECASE)<br>
[&lsquo;CAT&rsquo;, &lsquo;Cat&rsquo;, &lsquo;cat&rsquo;]</p>
</blockquote>
</blockquote>
</blockquote>
<p>到这里我简单总结一下不区分大小写模式的要点：</p>
<ol>
<li>不区分大小写模式的指定方式，使用模式修饰符 (?i)；</li>
<li>修饰符如果在括号内，作用范围是这个括号内的正则，而不是整个正则；</li>
<li>使用编程语言时可以使用预定义好的常量来指定匹配模式。</li>
</ol>
<h2 id="点号通配模式dot-all">点号通配模式（Dot All）</h2>
<p>在基础篇的第一讲里，我为你讲解了元字符相关的知识，你还记得英文的点（.）有什么用吗？它可以匹配上任何符号，但不能匹配换行。当我们需要匹配真正的“任意”符号的时候，可以使用 [\s\S] 或 [\d\D] 或 [\w\W] 等。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/8f5dfbe0006128a89ac0814acd8f2f2a.png" alt=""></p>
<p>但是这么写不够简洁自然，所以正则中提供了一种模式，让英文的点（.）可以匹配上包括换行的任何字符。</p>
<p>这个模式就是<strong>点号通配模式</strong>，有很多地方把它称作单行匹配模式，但这么说容易造成误解，毕竟它与多行匹配模式没有联系，因此在课程中我们统一用更容易理解的“点号通配模式”。</p>
<p>单行的英文表示是 <strong>S</strong>ingle Line，单行模式对应的修饰符是 <strong>(?s)</strong>，我还是选择用 the cat 来给你举一个点号通配模式的例子。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/31fbd96a186754f037b270d5863c9cc0.png" alt=""></p>
<p>需要注意的是，JavasScript 不支持此模式，那么我们就可以使用前面说的 [\s\S] 等方式替代。在 Ruby 中则是用 Multiline，来表示点号通配模式（单行匹配模式），我猜测设计者的意图是把点（.）号理解成“能匹配多行”。</p>
<h2 id="多行匹配模式multiline">多行匹配模式（Multiline）</h2>
<p>讲完了点号通配模式，我们再来看看多行匹配模式。通常情况下，^ 匹配整个字符串的开头，匹配整个字符串的结尾。多行匹配模式改变的就是和 的匹配行为。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/f13adbcd58bec68d705b0e47fc3b227d.png" alt=""></p>
<p>多行模式的作用在于，使 ^ 和 $ 能匹配上<strong>每行</strong>的开头或结尾，我们可以使用模式修饰符号 (?m) 来指定这个模式。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/02d700da5750290f9e7fe248584e5143.png" alt=""></p>
<p>这个模式有什么用呢？在处理日志时，如果日志以时间开头，有一些日志打印了堆栈信息，占用了多行，我们就可以使用多行匹配模式，在日志中匹配到以时间开头的每一行日志。</p>
<p>值得一提的是，正则中还有 \A 和 \z（Python 中是 \Z）这两个元字符容易混淆，\A 仅匹配整个字符串的开始，\z 仅匹配整个字符串的结束，在多行匹配模式下，它们的匹配行为不会改变，如果只想匹配整个字符串，而不是匹配每一行，用这个更严谨一些。</p>
<h2 id="注释模式comment">注释模式（Comment）</h2>
<p>在实际工作中，正则可能会很复杂，这就导致编写、阅读和维护正则都会很困难。我们在写代码的时候，通常会在一些关键的地方加上注释，让代码更易于理解。很多语言也支持在正则中添加注释，让正则更容易阅读和维护，这就是正则的注释模式。正则中注释模式是使用 (?#comment) 来表示。</p>
<p>比如我们可以把单词重复出现一次的正则 (\w+) \1 写成下面这样，这样的话，就算不是很懂正则的人也可以通过注释看懂正则的意思。</p>
<p>(\w+)(?#word) \1(?#word repeat again)</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/1274e6ef00f677e04c495f3d4ac6b26d.png" alt=""></p>
<p>在很多编程语言中也提供了 x 模式来书写正则，也可以起到注释的作用。我用 Python3 给你举了一个例子，你可以参考一下。</p>
<p>import re</p>
<p>regex = r&rsquo;&rsquo;&rsquo;(?mx)  # 使用多行模式和 x 模式<br>
^          # 开头<br>
(\d{4})    # 年<br>
(\d{2})    # 月<br>
$          # 结尾<br>
&rsquo;&rsquo;&rsquo;</p>
<p>re.findall(regex, &lsquo;202006\n202007&rsquo;)</p>
<h1 id="输出结果-2020-06-2020-07">输出结果 [(&lsquo;2020&rsquo;, &lsquo;06&rsquo;), (&lsquo;2020&rsquo;, &lsquo;07&rsquo;)]</h1>
<p>需要注意的是在 x 模式下，所有的换行和空格都会被忽略。为了换行和空格的正确使用，我们可以通过把空格放入字符组中，或将空格转义来解决换行和空格的忽略问题。我下面给了你一个示例，你可以看看。</p>
<p>regex = r&rsquo;&rsquo;&rsquo;(?mx)<br>
^          # 开头<br>
(\d{4})    # 年<br>
[ ]        # 空格<br>
(\d{2})    # 月<br>
$          # 结尾<br>
&rsquo;&rsquo;&rsquo;</p>
<p>re.findall(regex, &lsquo;2020 06\n2020 07&rsquo;)</p>
<h1 id="输出结果-2020-06-2020-07-1">输出结果 [(&lsquo;2020&rsquo;, &lsquo;06&rsquo;), (&lsquo;2020&rsquo;, &lsquo;07&rsquo;)]</h1>
<h2 id="总结">总结</h2>
<p>最后，我来给你总结一下，正则中常见的四种匹配模式，分别是：不区分大小写、点号通配模式、多行模式和注释模式。</p>
<ol>
<li>不区分大小写模式，它可以让整个正则或正则中某一部分进行不区分大小写的匹配。</li>
<li>点号通配模式也叫单行匹配，改变的是点号的匹配行为，让其可以匹配任何字符，包括换行。</li>
<li>多行匹配说的是 ^ 和 $ 的匹配行为，让其可以匹配上每行的开头或结尾。</li>
<li>注释模式则可以在正则中添加注释，让正则变得更容易阅读和维护。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/f16b14daf08e2aa742230d9a44728d1e.png" alt=""></p>
<h2 id="思考题">思考题</h2>
<p>最后，我们来做一个小练习吧。HTML 标签是不区分大小写的，比如我们要提取网页中的 head 标签中的内容，用正则如何实现呢？</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/802e2d2b839af80325aa61069641fd04.png" alt=""></p>
<p>你可以动手试一试，用文本编辑器或你熟悉的编程语言来实现，经过不断练习你才能更好地掌握学习的内容。</p>
<p>今天的课程就结束了，希望可以帮助到你，也希望你在下方的留言区和我参与讨论，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/">正则表达式入门课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/04__%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E4%B8%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E8%BF%99%E4%BB%B6%E4%BA%8B%E5%BA%94%E8%AF%A5%E4%BB%8E%E5%93%AA%E9%87%8C%E7%9D%80%E6%89%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">04__内存优化（下）：内存优化这件事，应该从哪里着手？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AF%B4%E9%80%8F%E6%95%B0%E5%AD%97%E5%8C%96%E8%BD%AC%E5%9E%8B/04__%E7%A0%B4%E9%99%A4%E8%AF%AF%E8%A7%A3%E4%BC%81%E4%B8%9A%E6%9E%B6%E6%9E%84%E7%9C%9F%E7%9A%84%E5%81%9A%E4%B8%8D%E5%81%9A%E9%83%BD%E8%A1%8C%E5%90%97/">
            <span class="next-text nav-default">04__破除误解：企业架构真的做不做都行吗？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
