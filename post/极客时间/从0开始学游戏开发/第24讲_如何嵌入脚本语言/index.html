<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>第24讲_如何嵌入脚本语言？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="从 2005 年开始，逐渐流行使用 C/C&#43;&#43; 语言结合脚本语言（Lua、Python、Ruby 等等）编写游戏。这是因为用 C/C&#43;&#43; 编写游戏的传统方式，硬代码太多，而使用硬代码编写的游戏，更新难度很大，除非重新编译一次程序。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E7%AC%AC24%E8%AE%B2_%E5%A6%82%E4%BD%95%E5%B5%8C%E5%85%A5%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E7%AC%AC24%E8%AE%B2_%E5%A6%82%E4%BD%95%E5%B5%8C%E5%85%A5%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="第24讲_如何嵌入脚本语言？">
  <meta property="og:description" content="从 2005 年开始，逐渐流行使用 C/C&#43;&#43; 语言结合脚本语言（Lua、Python、Ruby 等等）编写游戏。这是因为用 C/C&#43;&#43; 编写游戏的传统方式，硬代码太多，而使用硬代码编写的游戏，更新难度很大，除非重新编译一次程序。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="从0开始学游戏开发">

  <meta itemprop="name" content="第24讲_如何嵌入脚本语言？">
  <meta itemprop="description" content="从 2005 年开始，逐渐流行使用 C/C&#43;&#43; 语言结合脚本语言（Lua、Python、Ruby 等等）编写游戏。这是因为用 C/C&#43;&#43; 编写游戏的传统方式，硬代码太多，而使用硬代码编写的游戏，更新难度很大，除非重新编译一次程序。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3715">
  <meta itemprop="keywords" content="从0开始学游戏开发">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="第24讲_如何嵌入脚本语言？">
  <meta name="twitter:description" content="从 2005 年开始，逐渐流行使用 C/C&#43;&#43; 语言结合脚本语言（Lua、Python、Ruby 等等）编写游戏。这是因为用 C/C&#43;&#43; 编写游戏的传统方式，硬代码太多，而使用硬代码编写的游戏，更新难度很大，除非重新编译一次程序。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">第24讲_如何嵌入脚本语言？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3715 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#为什么使用-lua-脚本嵌入-cc-硬代码">为什么使用 Lua 脚本嵌入 C/C++ 硬代码？</a></li>
        <li><a href="#你需要了解三个-lua-语言的细节问题">你需要了解三个 Lua 语言的细节问题</a></li>
        <li><a href="#如何使用-lua-以及-libluaa-来进行与-c-语言的绑定操作">如何使用 Lua 以及 liblua.a 来进行与 C 语言的绑定操作？</a></li>
        <li><a href="#小结">小结</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>从 2005 年开始，逐渐流行使用 C/C++ 语言结合脚本语言（Lua、Python、Ruby 等等）编写游戏。这是因为用 C/C++ 编写游戏的传统方式，硬代码太多，而使用硬代码编写的游戏，更新难度很大，除非重新编译一次程序。</p>
<p>于是，就有人开始使用配置文件来做活动逻辑。比如填写好配置表、玩家等级多少、攻击力如何、等于多少的伤害力等等，一开始就将这些内容都读取进代码，在游戏中实时计算出来。</p>
<p>但是这种方法其实也并不方便。很久以前的游戏，由于硬件资源限制，所以一般都加载 WAV 格式。而加载 MP3 则需要机器对音乐文件进行解压缩再播放，如果机器硬件计算能力不好的话，会由于解压缩而导致整个游戏的运行效率下降。</p>
<p>脚本语言也是如此，如果机器硬件能力不好的话，会由于脚本语言的虚拟机要解释程序，导致游戏运行效率下降。随着电脑硬件的提升，我们在游戏中加载 MP3 音乐文件成为可能，而在游戏中加载脚本语言进行逻辑编写当然也是可以的。</p>
<p>《魔兽世界》就是使用 Lua 脚本语言编写的。类似《GTA》等大型游戏，都拥有一套自己的脚本语言和体系。 <strong>使用脚本语言，是为了能够在编写硬代码的同时，也能很方便地、不需要重新编译地编写逻辑代码。</strong> 事实上，现在很多大型游戏都使用这种方式来编写代码，甚至一些游戏引擎本身，也支持脚本语言和引擎本身所提供的语言分离编写。比如引擎用 C++ 语言编写，脚本语言用 Lua 编写。</p>
<h2 id="为什么使用-lua-脚本嵌入-cc-硬代码">为什么使用 Lua 脚本嵌入 C/C++ 硬代码？</h2>
<p>今天我就来教你使用 Lua 脚本来嵌入 C/C++ 硬代码。为什么我要选择 Lua 脚本语言来编写代码呢？</p>
<p>因为<strong>Lua 脚本足够轻量级，几乎没有冗余的代码。Lua 虚拟机的执行效率几乎可以媲美 C/C++ 的执行效率</strong>。如果选择 Python、Ruby 等常用脚本语言来嵌入，并不是不行，而是要付出执行效率作为代价。因为 Python、Ruby 的执行效率远逊于 Lua。</p>
<p>如果没有非常多的编码经验，你可能会问，为什么 Python、Ruby 的执行效率远逊于 Lua 呢？这个问题，用一本书的篇幅恐怕才能彻底讲明白。我这里只简要说一下原因。</p>
<p>Lua 的虚拟机很简单，指令设计得也精简，Lua 本身是基于寄存器的虚拟机实现，而 Python 等其他脚本语言是基于堆栈的虚拟机，而基于寄存器的虚拟机字节码更简单、高效。因为字节码，一般会同时包含指令、操作数、操作目标等内容。</p>
<p>另一方面，Python、Ruby 之所以应用范围广，是因为它们拥有大量的成熟库和框架，而 Lua 只是一种很纯粹的脚本语言。因为 Lua 没有过多的第三方库，只提供最基础的 I/O 处理、数学运算处理、字符串处理等，别的与操作系统相关度密切的，例如网络、多线程、音频视频处理等等都不提供。</p>
<p>我在<a href="./8782.md">第 6 讲</a>里，已经非常详细地讲过，如何将 Lua 脚本编译成为静态库，如果不记得的话，可以回去复习一下。编译好静态库 liblua.a 之后，我们就可以在编程中使用它了。</p>
<p>你也可以选择在解压缩出来的目录内，使用 make 命令来直接编译，编译会生成 Lua 虚拟机的执行文件 lua.exe、luac.exe，当然这需要一整套 MinGW 的环境支持。</p>
<p>开始，我们还是使用 MinGW Development Studio 来创建一个工程。由于只是示例，所以名字可以任意取。我取一个叫作 lua_test 的工程名，并且将工程设置为 Win32 Console Application。你可以看这个示例图。<br>
<img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/f6cd239595a271c3e8e64cef32a738b8.png" alt=""></p>
<p>建立好了工程之后，我们新建一个 test.c 文件。这个文件位于 lua 源代码路径下。我们将 liblua.a 文件也放到同一个目录下，以方便后续链接时候调用。</p>
<p>在包含 Lua 头文件之前，我们需要将头文件写在某一个.hpp 文件下，以便一次性包含进去，我们的代码可以这么写。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#ifdef __CPLUSPLUS
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">extern &#34;C&#34; {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#endif
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &#34;src/lua.h&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &#34;src/lualib.h&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &#34;src/lauxlib.h&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#ifdef __CPLUSPLUS
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#endi
</span></span></code></pre></td></tr></table>
</div>
</div><p>你可以看到，这里面包含了三个代码。这三个代码来自 src 目录下，其中最后一个 lauxlib.h 包含了大量的 C 语言形式的接口以及扩展接口。而定义 extern &ldquo;C&rdquo; 的意思是，使用 C 的方式进行链接，前置条件是，你的语言是 C++ 语言（ifdef __CPLUSPLUS）。</p>
<p>定义好了这个 hpp 文件后，我们可以在 C 或者 C++ 语言中进行包含。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include “lua.hpp”
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="你需要了解三个-lua-语言的细节问题">你需要了解三个 Lua 语言的细节问题</h2>
<p>写完定义之后，我们就可以开始对 Lua 进行一系列的绑定操作了。在编程之前，我先用一些你能看得懂的语言，对 Lua 语言的细节进行一些描述。有三个点，需要你着重记一下。</p>
<p>首先，<strong>Lua 的下标都是以 1 为最初始的值</strong>（当然反向可以使用 -1 为下标），而不是我们所熟悉的 0。有个传言说，是因为作者当时编写最初版本的 Lua 时，计算错误才导致的，所以就这么一直沿用下来了，这个说法虽然不可考，但也算是一种解释。</p>
<p>其次，在 C/C++ 内嵌 Lua 的做法中，<strong>Lua 有两种读取脚本的方法。</strong></p>
<ul>
<li>一种方式是<strong>读取后直接运行，调用的函数是 luaL_dofile</strong>。使用这个函数，脚本会在读取完毕后直接运行。当然如果出现错误，你也不知道错误的具体位置在哪里，调试起来不是很方便。</li>
<li>第二种方式是<strong>将脚本代码压到栈顶，然后使用 pcall 操作运行脚本，这个函数叫 luaL_loadfile</strong>。事实上第一种方式也是使用这种方式并且将 pcall 操作直接调用起来，第一种方式的代码一看你就能明了。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#define luaL_dofile(L, fn) \</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="n">luaL_loadfile</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span> <span class="o">||</span> <span class="n">lua_pcall</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LUA_MULTRET</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这行代码在 lauxlib.h 中能找到。这段代码写得非常精妙，它的意思是，如果 loadfile 成功，那么就运行 pcall 函数，中间这个 || （或者）已经直接判断了 loadfile 是否成功。因为 loadfile 函数操作成功就返回 0，否则就返回 1。</p>
<p>而在“或者”这个逻辑判断下，只要是 0，就继续往下判断；只要是 1，就直接返回条件为真。所以，在这行代码下，只要是 1，就中断 dofile 这个宏的操作；只要是 0，就进行 pcall 操作。</p>
<p>最后，我要说一下<strong>Lua 的堆栈</strong>。理解了堆栈的计数方式，就能很容易地理解我后续要讲解的代码中的计数方式。Lua 的堆栈可以从这个图里看出来，从栈底往上表示可以用 1、2、3、4、5，而从栈顶往下表示是 -1、-2、-3、-4、-5。<br>
<img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/2ffc8594cd83d6cf76fa98ee2adee25e.png" alt=""></p>
<h2 id="如何使用-lua-以及-libluaa-来进行与-c-语言的绑定操作">如何使用 Lua 以及 liblua.a 来进行与 C 语言的绑定操作？</h2>
<p>我们现在开始使用 Lua 以及 liblua.a 来进行与 C 语言的绑定操作。</p>
<p>首先，我们需要包含之前我们所定义的 lua.hpp 头文件，随后我们开始在 main 入口函数处，定义一些变量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#include &#34;lua.hpp&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">main</span><span class="p">(</span><span class="ne">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="ne">int</span> <span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">lua_State</span><span class="o">*</span> <span class="n">ls</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="err">…</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，我们定义了三个变量，其中 r 是用来接收返回值的；err 是一个常量字符串，用来接收错误字符串并打印出来；而 lua_State* ls 就是 Lua 虚拟机的指针了。</p>
<p>我们再来看接下来的代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ls = luaL_newstate();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">luaL_openlibs(ls);   
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这两行代码中，首先初始化一个虚拟机（在 Lua 5.1 中，使用的函数是 lua_open 来新建虚拟机），并且将虚拟机地址赋值给 ls 指针。随后，我们拿到这个指针之后，就在之后的代码中“打开”Lua 所需要用到的各种库。我们用到 luaL_openlibs。我现在只是给你示范，你可以一个一个库单独打开。</p>
<p>我们新建了虚拟机，并且打开了 Lua 类库。我们继续看下面的代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">r</span> <span class="o">=</span> <span class="n">luaL_loadfile</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">err</span> <span class="o">=</span> <span class="n">lua_tostring</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">printf</span><span class="p">(</span><span class="s2">&#34;err1: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">r</span> <span class="o">=</span> <span class="n">lua_pcall</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">err</span> <span class="o">=</span> <span class="n">lua_tostring</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">printf</span><span class="p">(</span><span class="s2">&#34;err2: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">lua_close</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>我来具体解释一下。这段代码中，argv[1] 的是命令行输入的第一个内容。比如我们的程序叫 lua_test，那么我们在 Windows 命令行中，输入 lua_test a.lua，那么其中 a.lua 就是 argv[1] 这个内容。</p>
<p>luaL_loadfile 我们在前面介绍过，就是载入文件并不运行。当然在这个期间，它会检查基础的语法。如果你少一个括号或者多一个引号，就会在这个时候给你一个错误信息，这个错误信息就是利用 r 这个变量判断的。如果 r 的返回值不等于 0 的话，那就是出错了。出错的时候，Lua 会将出错信息压栈顶，而栈顶是从 -1 开始表示，所以我们要取出栈顶的错误信息 lua_tostring(ls, -1);，并且将它赋值给 err，最后由 err 打印出来。</p>
<p>认为没有错误之后，就是过了这一关。第二关我们需要使用 lua_pcall 函数，来调用 Lua 脚本文件，其中第一个参数是虚拟机指针，第二个参数是传递多少参数给 Lua，第三个参数是这个脚本返回多少值，第四个是错误处理函数，可以是 0，那就是无处理函数。</p>
<p>pcall 的返回值也是一样，如果不是 0 的话，就说明出错了。和之前的 luaL_loadfile 不同，这时候一般是运行时错误，比如运行时类型错误等等。同样的，pcall 也会把错误信息压到栈顶，我们直接去将栈顶的内容转成 string 就可以打印出来了。最后，我们将 Lua 虚拟机通过 lua_close 关闭。</p>
<p>按常理来说，我们现在可以来运行一下效果了，你可以先等等，我们先写一段错误的 Lua 代码，来看看执行起来会发生什么情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">print &#34;test running&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们故意少写一个括号，然后将源代码命名为 a.lua，我们来运行看看。会出现一个这样的错误信息：<br>
<img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/83ec755f7481dc9f1eaba18024e413ea.png" alt=""></p>
<p>在发现语法错误后，程序就会报错，另外，如果你输入了一个根本不存在的文件，比如我们这么运行，test_lua xxx.lua，也会在 loadfile 的时候出错。</p>
<h2 id="小结">小结</h2>
<p>我们今天的内容就到这里。下次我会进一步把 Lua 的脚本嵌入的细节呈现在你面前。我们来总结一下今天的内容。</p>
<ol>
<li>因为 Lua 脚本足够轻量级，几乎没有冗余的代码。Lua 虚拟机的执行效率几乎可以媲美 C/C++ 的执行效率。所以我们选择使用 Lua 脚本来嵌入 C/C++ 硬代码。</li>
<li>Lua 脚本在 C/C++ 语言里面嵌入，需要先声明一个虚拟机并且赋值给指针。</li>
<li>Lua 脚本需要先 loadfile 再 pcall 调用脚本文件，loadfile 会检查最基本的脚本文件内容，比如文件是否存在，比如脚本代码是否出错，而 pcall 会在运行时出错的时候将错误压至栈顶。</li>
<li>Lua 错误会将错误压制栈顶，我们要取出来，需要使用 -1 下标取出栈顶的内容，并转成 string 打印。</li>
</ol>
<p>给你留一个小问题吧。</p>
<p>如果直接使用 luaL_dofile，相对于把 loadfile 和 pcall 分开写，这样有什么优劣呢？</p>
<p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/687aa95b3803eb0079b384dbad39d165.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">从0开始学游戏开发</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%AC%AC24%E8%AE%B2__%E4%BA%91%E4%B8%AD%E7%BD%91%E7%BB%9C%E8%87%AA%E5%B7%B1%E6%8B%BF%E5%9C%B0%E6%88%90%E6%9C%AC%E9%AB%98%E8%B4%AD%E4%B9%B0%E5%85%AC%E5%AF%93%E6%9B%B4%E7%81%B5%E6%B4%BB/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">第24讲__云中网络：自己拿地成本高，购买公寓更灵活</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E6%95%88%E6%95%8F%E6%8D%B7%E6%B5%8B%E8%AF%9549%E8%AE%B2/%E7%AC%AC24%E8%AE%B2bdd%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E8%B7%B5/">
            <span class="next-text nav-default">第24讲：BDD及其自动化实践</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
