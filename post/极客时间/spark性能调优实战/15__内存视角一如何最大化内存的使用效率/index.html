<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>15__内存视角（一）：如何最大化内存的使用效率？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是吴磊。
上一讲我们说，想要提升 CPU 利用率，最重要的就是合理分配执行内存，但是，执行内存只是 Spark 内存分区的一部分。因此，想要合理分配执行内存，我们必须先从整体上合理划分好 Spark 所有的内存区域。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spark%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/15__%E5%86%85%E5%AD%98%E8%A7%86%E8%A7%92%E4%B8%80%E5%A6%82%E4%BD%95%E6%9C%80%E5%A4%A7%E5%8C%96%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%88%E7%8E%87/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spark%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/15__%E5%86%85%E5%AD%98%E8%A7%86%E8%A7%92%E4%B8%80%E5%A6%82%E4%BD%95%E6%9C%80%E5%A4%A7%E5%8C%96%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%88%E7%8E%87/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="15__内存视角（一）：如何最大化内存的使用效率？">
  <meta property="og:description" content="你好，我是吴磊。
上一讲我们说，想要提升 CPU 利用率，最重要的就是合理分配执行内存，但是，执行内存只是 Spark 内存分区的一部分。因此，想要合理分配执行内存，我们必须先从整体上合理划分好 Spark 所有的内存区域。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Spark性能调优实战">

  <meta itemprop="name" content="15__内存视角（一）：如何最大化内存的使用效率？">
  <meta itemprop="description" content="你好，我是吴磊。
上一讲我们说，想要提升 CPU 利用率，最重要的就是合理分配执行内存，但是，执行内存只是 Spark 内存分区的一部分。因此，想要合理分配执行内存，我们必须先从整体上合理划分好 Spark 所有的内存区域。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4945">
  <meta itemprop="keywords" content="Spark性能调优实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="15__内存视角（一）：如何最大化内存的使用效率？">
  <meta name="twitter:description" content="你好，我是吴磊。
上一讲我们说，想要提升 CPU 利用率，最重要的就是合理分配执行内存，但是，执行内存只是 Spark 内存分区的一部分。因此，想要合理分配执行内存，我们必须先从整体上合理划分好 Spark 所有的内存区域。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">15__内存视角（一）：如何最大化内存的使用效率？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4945 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#从一个实例开始">从一个实例开始</a>
          <ul>
            <li><a href="#user-memory-性能隐患">User Memory 性能隐患</a></li>
          </ul>
        </li>
        <li><a href="#性能调优">性能调优</a>
          <ul>
            <li><a href="#storage-memory-规划">Storage Memory 规划</a></li>
          </ul>
        </li>
        <li><a href="#内存规划两步走">内存规划两步走</a>
          <ul>
            <li><a href="#预估内存占用">预估内存占用</a></li>
            <li><a href="#调整内存配置项">调整内存配置项</a></li>
          </ul>
        </li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#每日一练">每日一练</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是吴磊。</p>
<p>上一讲我们说，想要提升 CPU 利用率，最重要的就是合理分配执行内存，但是，执行内存只是 Spark 内存分区的一部分。因此，想要合理分配执行内存，我们必须先从整体上合理划分好 Spark 所有的内存区域。</p>
<p>可在实际开发应用的时候，身边有不少同学向我抱怨：“Spark 划分不同内存区域的原理我都知道，但我还是不知道不同内存区域的大小该怎么设置，纠结来、纠结去。最后，所有跟内存有关的配置项，我还是保留了默认值。”</p>
<p>这种不能把原理和实践结合起来的情况很常见，所以今天这一讲，我就从熟悉的 Label Encoding 实例出发，**一步步带你去分析不同情况下，不同内存区域的调整办法，**帮你归纳出最大化内存利用率的常规步骤。这样，你在调整内存的时候，就能结合应用的需要，做到有章可循、有的放矢。</p>
<h2 id="从一个实例开始">从一个实例开始</h2>
<p>我们先来回顾一下第 5 讲中讲过的 Label Encoding。在 Label Encoding 的业务场景中，我们需要对用户兴趣特征做 Encoding。依据模板中兴趣字符串及其索引位置，我们的任务是把千亿条样本中的用户兴趣转换为对应的索引值。模板文件的内容示例如下所示。</p>
<p>//模板文件<br>
//用户兴趣<br>
体育 - 篮球-NBA-湖人<br>
军事 - 武器 - 步枪-AK47</p>
<p>实现的代码如下所示，注意啦，这里的代码是第 5 讲中优化后的版本。</p>
<p>/**<br>
输入参数：模板文件路径，用户兴趣字符串<br>
返回值：用户兴趣字符串对应的索引值<br>
*/<br>
//函数定义<br>
val findIndex: (String) =&gt; (String) =&gt; Int = {<br>
(filePath) =&gt;<br>
val source = Source.fromFile(filePath, &ldquo;UTF-8&rdquo;)<br>
val lines = source.getLines().toArray<br>
source.close()<br>
val searchMap = lines.zip(0 until lines.size).toMap<br>
(interest) =&gt; searchMap.getOrElse(interest, -1)<br>
}<br>
val partFunc = findIndex(filePath)</p>
<p>//Dataset 中的函数调用<br>
partFunc(&ldquo;体育 - 篮球-NBA-湖人&rdquo;)</p>
<p>下面，咱们先一起回顾一下代码实现思路，再来分析它目前存在的性能隐患，最后去探讨优化它的方法。</p>
<p>首先，findIndex 函数的主体逻辑比较简单，就是读取模板文件和构建 Map 映射，以及查找用户兴趣并返回索引。不过，findIndex 函数被定义成了高阶函数。这样一来，当以模板文件为实参调用这个高阶函数的时候，我们会得到一个内置了 Map 查找字典的标量函数 partFunc，最后在千亿样本上调用 partFunc 完成数据转换。<strong>利用高阶函数，我们就避免了让 Executor 中的每一个 Task 去读取模板文件，以及从头构建 Map 字典这种执行低效的做法。</strong></p>
<p>在运行时，这个函数在 Driver 端会被封装到一个又一个的 Task 中去，随后 Driver 把这些 Task 分发到 Executor，Executor 接收到任务之后，交由线程池去执行（调度系统的内容可以回顾第 5 讲）。这个时候，每个 Task 就像是一架架小飞机，携带着代码“乘客”和数据“行李”，从 Driver 飞往 Executor。Task 小飞机在 Executor 机场着陆之后，代码“乘客”乘坐出租车或是机场大巴，去往 JVM stack；数据“行李”则由专人堆放在 JVM Heap，也就是我们常说的堆内内存。</p>
<p>回顾 Label encoding 中的 findIndex 函数不难发现，其中大部分都是代码“乘客”，唯一的数据“行李”是名为 searchMap 的 Map 字典。像这样用户自定义的数据结构，消耗的内存区域就是堆内内存的 User Memory（Spark 对内存区域的划分内容可以回顾一下第 7 讲）。</p>
<h3 id="user-memory-性能隐患">User Memory 性能隐患</h3>
<p>回顾到这里，你觉得 findIndex 函数有没有性能隐患呢？你可以先自己思考一下，有了答案之后再来看我下面的分析。</p>
<p>答案当然是“有”。首先，每架小飞机都携带这么一份数据“大件行李”，自然需要消耗更多的“燃油”，这里的“燃油”指的<strong>是 Task 分发过程中带来的网络开销</strong>。其次，因为每架小飞机着陆之后，都会在 Executor 的“旅客行李专区”User Memory 寄存上这份同样的数据“行李”，所以，<strong>User Memory 需要确保有足够的空间可以寄存所有旅客的行李，也就是大量的重复数据</strong>。</p>
<p>那么，User Memory 到底需要准备出多大的内存空间才行呢？我们不妨来算一算。这样的计算并不难，只需要用飞机架次乘以行李大小就可以了。</p>
<p>用户自定义的数据结构往往是用于辅助函数完成计算任务的，所以函数执行完毕之后，它携带的数据结构的生命周期也就告一段落。<strong>因此，在 Task 的数量统计上，我们不必在意一个 Executor 总共需要处理多少个 Task，只需要关注它在同一时间可以并行处理的 Task 数量，也就是 Executor 的线程池大小即可</strong>。</p>
<p>我们说过，Executor 线程池大小由 spark.executor.cores 和 spark.task.cpus 这两个参数的商（spark.executor.cores/spark.task.cpus）决定，我们暂且把这个商记作 #threads。</p>
<p>接下来是估算数据“行李”大小，由于 searchMap 并不是分布式数据集，因此我们不必采用先 Cache，再提取 Spark 执行计划统计信息的方式。对于这样的 Java 数据结构，我们完全可以在 REPL 中，通过 Java 的常规方法估算数据存储大小，估算得到的 searchMap 大小记为 #size。</p>
<p>好啦！现在，我们可以算出，User Memory 至少需要提供 #threads * #size 这么大的内存空间，才能支持分布式任务完成计算。但是，对于 User Memory 内存区域来说，使用 #threads * #size 的空间去重复存储同样的数据，本身就是降低了内存的利用率。那么，我们该怎么省掉 #threads * #size 的内存消耗呢？</p>
<h2 id="性能调优">性能调优</h2>
<p>学习过广播变量之后，想必你头脑中已经有了思路。没错，咱们可以尝试使用广播变量，来对示例中的代码进行优化。</p>
<p>仔细观察 findIndex 函数，我们不难发现，函数的核心计算逻辑有两点。一是读取模板文件、创建 Map 映射字典；二是以给定字符串对字典进行查找，并返回查找结果。显然，千亿样本转换的核心需求是其中的第二个环节。既然如此，我们完全可以把创建好的 Map 字典封装成广播变量，然后分发到各个 Executors 中去。</p>
<p>有了广播变量的帮忙，凡是发往同一个 Executor 的 Task 小飞机，都无需亲自携带数据“行李”，这些大件行李会由“联邦广播快递公司”派货机专门发往各个 Executors，Driver 和每个 Executors 之间，都有一班这样的货运专线。思路说完了，优化后的代码如下所示。</p>
<p>/**<br>
广播变量实现方式<br>
*/<br>
//定义广播变量<br>
val source = Source.fromFile(filePath, &ldquo;UTF-8&rdquo;)<br>
val lines = source.getLines().toArray<br>
source.close()<br>
val searchMap = lines.zip(0 until lines.size).toMap<br>
val bcSearchMap = sparkSession.sparkContext.broadcast(searchMap)</p>
<p>//在 Dataset 中访问广播变量<br>
bcSearchMap.value.getOrElse(&ldquo;体育 - 篮球-NBA-湖人&rdquo;, -1)</p>
<p>上面代码的实现思路很简单：第一步还是读取模板文件、创建 Map 字典；第二步，把 Map 字典封装为广播变量。这样一来，在对千亿样本进行转换时，我们直接通过 bcSearchMap.value 读取广播变量内容，然后，通过调用 Map 字典的 getOrElse 方法来获取用户兴趣对应的索引值。</p>
<p>相比最开始的第一种实现方式，第二种实现方式的代码改动还是比较小的，那这一版代码对内存的消耗情况有什么改进呢？</p>
<p>我们发现，Task 小飞机的代码“乘客”换人了！<strong>小飞机之前需要携带函数 findIndex，现在则换成了一位“匿名的乘客”</strong>：一个读取广播变量并调用其 getOrElse 方法的匿名函数。由于这位“匿名的乘客”将大件行李托运给了“联邦广播快递公司”的专用货机，因此，Task 小飞机着陆后，没有任何“行李”需要寄存到 User Memory。换句话说，优化后的版本不会对 User Memory 内存区域进行占用，所以第一种实现方式中 #threads * #size 的内存消耗就可以省掉了。</p>
<h3 id="storage-memory-规划">Storage Memory 规划</h3>
<p>这样一来，原来的内存消耗转嫁到了广播变量身上。但是，广播变量也会消耗内存，这会不会带来新的性能隐患呢？那我们就来看看，广播变量消耗的具体是哪块内存区域。</p>
<p>回顾存储系统那一讲，我们说过，Spark 存储系统主要有 3 个服务对象，分别是 Shuffle 中间文件、RDD 缓存和广播变量。它们都由 Executor 上的 BlockManager 进行管理，对于数据在内存和磁盘中的存储，BlockManager 利用 MemoryStore 和 DiskStore 进行抽象和封装。</p>
<p>那么，广播变量所携带的数据内容会物化到 MemoryStore 中去，以 Executor 为粒度为所有 Task 提供唯一的一份数据拷贝。MemoryStore 产生的内存占用会被记入到 Storage Memory 的账上。<strong>因此，广播变量消耗的就是 Storage Memory 内存区域</strong>。</p>
<p>接下来，我们再来盘算一下，第二种实现方式究竟需要耗费多少内存空间。由于广播变量的分发和存储以 Executor 为粒度，因此每个 Executor 消耗的内存空间，就是 searchMap 一份数据拷贝的大小。searchMap 的大小我们刚刚计算过就是 #size。</p>
<p>明确了 Storage Memory 内存区域的具体消耗之后，我们自然可以根据公式：（spark.executor.memory – 300MB）* spark.memory.fraction * spark.memory.storageFraction 去有针对性地调节相关的内存配置项。</p>
<h2 id="内存规划两步走">内存规划两步走</h2>
<p>现在，咱们在两份不同的代码实现下，分别定量分析了不同内存区域的消耗与占用。对于这些消耗做到心中有数，我们自然就能够相应地去调整相关的配置项参数。基于这样的思路，想要最大化内存利用率，我们需要遵循两个步骤：</p>
<ol>
<li><strong>预估内存占用</strong></li>
<li><strong>调整内存配置项</strong></li>
</ol>
<p>我们以堆内内存为例，来讲一讲内存规划的两步走具体该如何操作。我们都知道，堆内内存划分为 Reserved Memory、User Memory、Storage Memory 和 Execution Memory 这 4 个区域。预留内存固定为 300MB，不用理会，其他 3 个区域需要你去规划。</p>
<h3 id="预估内存占用">预估内存占用</h3>
<p>首先，我们来说内存占用的预估，主要分为三步。</p>
<p>第一步，计算 User Memory 的内存消耗。我们先汇总应用中包含的自定义数据结构，并估算这些对象的总大小 #size，然后<strong>用 #size 乘以 Executor 的线程池大小，即可得到 User Memory 区域的内存消耗 #User</strong>。</p>
<p>第二步，计算 Storage Memory 的内存消耗。我们先汇总应用中涉及的广播变量和分布式数据集缓存，分别估算这两类对象的总大小，分别记为 #bc、#cache。另外，我们把集群中的 Executors 总数记作 #E。这样，<strong>每个 Executor 中 Storage Memory 区域的内存消耗的公式就是：#Storage = #bc + #cache / #E</strong>。</p>
<p>第三步，计算执行内存的消耗。学习上一讲，我们知道执行内存的消耗与多个因素有关。第一个因素是 Executor 线程池大小 #threads，第二个因素是数据分片大小，而数据分片大小取决于数据集尺寸 #dataset 和并行度 #N。因此，<strong>每个 Executor 中执行内存的消耗的计算公式为：#Execution = #threads * #dataset / #N</strong>。</p>
<h3 id="调整内存配置项">调整内存配置项</h3>
<p>得到这 3 个内存区域的预估大小 #User、#Storage、#Execution 之后，调整相关的内存配置项就是一件水到渠成的事情（由公式（spark.executor.memory – 300MB）* spark.memory.fraction * spark.memory.storageFraction）可知），这里我们也可以分为 3 步。</p>
<p>首先，根据定义，<strong>spark.memory.fraction 可以由公式（#Storage + #Execution）/（#User + #Storage + #Execution）计算得到</strong>。</p>
<p>同理，<strong>spark.memory.storageFraction 的数值应该参考（#Storage）/（#Storage + #Execution）</strong>。</p>
<p>最后，对于 Executor 堆内内存总大小 spark.executor.memory 的设置，我们自然要参考 4 个内存区域的总消耗，也就是 <strong>300MB + #User + #Storage + #Execution。不过，我们要注意，利用这个公式计算的前提是，不同内存区域的占比与不同类型的数据消耗一致</strong>。</p>
<p>总的来说，在内存规划的两步走中，第一步预估不同区域的内存占比尤为关键，因为第二步中参数的调整完全取决于第一步的预估结果。如果你按照这两个步骤去设置相关的内存配置项，相信你的应用在运行时就能够充分利用不同的内存区域，避免出现因参数设置不当而导致的内存浪费现象，从而在整体上提升内存利用率。</p>
<h2 id="小结">小结</h2>
<p>合理划分 Spark 所有的内存区域，是同时提升 CPU 与内存利用率的基础。因此，掌握内存规划很重要，在今天这一讲，我们把内存规划归纳为两步走。</p>
<p>第一步是预估内存占用。</p>
<ol>
<li>求出 User Memory 区域的内存消耗，公式为：#User=#size 乘以 Executor 线程池的大小。</li>
<li>求出每个 Executor 中 Storage Memory 区域的内存消耗，公式为：#Storage = #bc + #cache / #E。</li>
<li>求出执行内存区域的内存消耗，公式为：#Execution = #threads * #dataset / #N。</li>
</ol>
<p>第二步是调整内存配置项：根据公式得到的 3 个内存区域的预估大小 #User、#Storage、#Execution，去调整（spark.executor.memory – 300MB）* spark.memory.fraction * spark.memory.storageFraction 公式中涉及的所有配置项。</p>
<ol>
<li>spark.memory.fraction 可以由公式（#Storage + #Execution）/（#User + #Storage + #Execution）计算得到。</li>
<li>spark.memory.storageFraction 的数值应该参考（#Storage）/（#Storage + #Execution）。</li>
<li>spark.executor.memory 的设置，可以通过公式 300MB + #User + #Storage + #Execution 得到。</li>
</ol>
<p>这里，我还想多说几句，<strong>内存规划两步走终归只是手段，它最终要达到的效果和目的，是确保不同内存区域的占比与不同类型的数据消耗保持一致，从而实现内存利用率的最大化</strong>。</p>
<h2 id="每日一练">每日一练</h2>
<ol>
<li>你知道估算 Java 对象存储大小的方法有哪些吗？不同的方法又有哪些优、劣势呢？</li>
<li>对于内存规划的第一步来说，要精确地预估运行时每一个区域的内存消耗，很费时、费力，调优的成本很高。如果我们想省略掉第一步的精确计算，你知道有哪些方法能够粗略、快速地预估不同内存区域的消耗占比吗？</li>
</ol>
<p>期待在留言区看到你的思考和答案，我们下一讲见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/spark%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/">Spark性能调优实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/15__%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bgo%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99%E7%9A%84%E9%A1%BA%E5%BA%8F/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">15__内存模型：Go如何保证并发读写的顺序？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%89%A9%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/15__%E5%B9%B3%E5%8F%B0%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E5%BC%80%E6%BA%90%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%94%9F%E6%80%81%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/">
            <span class="next-text nav-default">15__平台：智能家居开源平台的生态是怎样的？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
