<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>09｜异步处理：如何向服务器端发送请求？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是王沛。这节课我们来学习如何在 React Hooks 中处理 Rest API 请求。
我遇到很多 React 的初学者，刚把 Hello World 跑起来，问的第一个问题就是：我该怎么发请求拿数据呢？
可见，这是最为常见也是最为重要的一个需求。毕竟 90% 以上的前端 App 都是和服务器端打交道，然后通过各种 API 完成各种功能。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/reacthooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/09%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E5%A6%82%E4%BD%95%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/reacthooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/09%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E5%A6%82%E4%BD%95%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="09｜异步处理：如何向服务器端发送请求？">
  <meta property="og:description" content="你好，我是王沛。这节课我们来学习如何在 React Hooks 中处理 Rest API 请求。
我遇到很多 React 的初学者，刚把 Hello World 跑起来，问的第一个问题就是：我该怎么发请求拿数据呢？
可见，这是最为常见也是最为重要的一个需求。毕竟 90% 以上的前端 App 都是和服务器端打交道，然后通过各种 API 完成各种功能。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="ReactHooks核心原理与实战">

  <meta itemprop="name" content="09｜异步处理：如何向服务器端发送请求？">
  <meta itemprop="description" content="你好，我是王沛。这节课我们来学习如何在 React Hooks 中处理 Rest API 请求。
我遇到很多 React 的初学者，刚把 Hello World 跑起来，问的第一个问题就是：我该怎么发请求拿数据呢？
可见，这是最为常见也是最为重要的一个需求。毕竟 90% 以上的前端 App 都是和服务器端打交道，然后通过各种 API 完成各种功能。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4330">
  <meta itemprop="keywords" content="ReactHooks核心原理与实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="09｜异步处理：如何向服务器端发送请求？">
  <meta name="twitter:description" content="你好，我是王沛。这节课我们来学习如何在 React Hooks 中处理 Rest API 请求。
我遇到很多 React 的初学者，刚把 Hello World 跑起来，问的第一个问题就是：我该怎么发请求拿数据呢？
可见，这是最为常见也是最为重要的一个需求。毕竟 90% 以上的前端 App 都是和服务器端打交道，然后通过各种 API 完成各种功能。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">09｜异步处理：如何向服务器端发送请求？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4330 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#实现自己的-api-client">实现自己的 API Client</a></li>
    <li><a href="#使用-hooks-思考异步请求封装远程资源">使用 Hooks 思考异步请求：封装远程资源</a></li>
    <li><a href="#多个-api-调用如何处理并发或串行请求">多个 API 调用：如何处理并发或串行请求？</a></li>
    <li><a href="#小结">小结</a></li>
    <li><a href="#思考题">思考题</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是王沛。这节课我们来学习如何在 React Hooks 中处理 Rest API 请求。</p>
<p>我遇到很多 React 的初学者，刚把 Hello World 跑起来，问的第一个问题就是：我该怎么发请求拿数据呢？</p>
<p>可见，这是最为常见也是最为重要的一个需求。毕竟 90% 以上的前端 App 都是和服务器端打交道，然后通过各种 API 完成各种功能。</p>
<p><strong>虽然发请求拿数据有很多</strong> <strong>种</strong> <strong>做法，但基本上都会遵循一定的规律</strong>，而这正是咱们这节课要介绍的内容。</p>
<p>其实在第一讲，我们就已经看到了异步请求的一个实例，当时我们在一个组件内直接发起了一个请求，并处理了返回结果。但这个简单的例子只是演示了组件中发请求的基本流程，在实际的项目中我们很少会直接这么写，因为<strong>还需要考虑更多的逻辑</strong>。</p>
<p>比如说，如何给所有请求都带上一个 Token 供服务器端验证？如何发起并发请求？等等。此外，咱们整个课程都是从 Hooks 角度去思考问题，那么 Hooks 又能给异步逻辑处理带来怎样的优化？这些都是接下来要具体介绍的内容。</p>
<h1 id="实现自己的-api-client">实现自己的 API Client</h1>
<p>无论大小项目，在开始实现第一个请求的时候，通常我们要做的第一件事应该都是<strong>创建一个自己的 API Client，之后所有的请求都</strong> <strong>会</strong> <strong>通过这个</strong> <strong>Client 发出去</strong>。而不是上来就用 fetch 或者是 axios 去直接发起请求，因为那会造成大量的重复代码。</p>
<p>实现这样一个 Client 之后，你就有了一个统一的地方，去对你需要连接的服务端做一些通用的配置和处理，比如 Token、URL、错误处理等等。</p>
<p>这个步骤呢，虽然跟 React 和 Hooks 没有直接的关系，但是我经常看到很多同学是在多个组件内分别实现了异步请求处理，写了很多重复代码之后，才开始考虑把这个功能提取出来，增加了额外工作量。所以这里我就先简单介绍下，实现这样一个 API Client 需要考虑哪些因素。</p>
<p>通常来说，会包括以下几个方面：</p>
<ol>
<li>一些通用的 Header。比如 Authorization Token。</li>
<li>服务器地址的配置。前端在开发和运行时可能会连接不同的服务器，比如本地服务器或者测试服务器，此时这个 API Client 内部可以根据当前环境判断该连接哪个 URL。</li>
<li>请求未认证的处理。比如如果 Token 过期了，需要有一个统一的地方进行处理，这时就会弹出对话框提示用户重新登录。</li>
</ol>
<p>从我的经验来看，我更推荐把 axios 作为基础来实现这个功能。原因就在于，axios 比起 fetch，提供了更为方便，也更加语义化的 API，比如请求拦截。此外，还很容易创建多个实例，让代码逻辑更简洁。所以我就以 axios 为例，提供一个示例实现：</p>
<p>import axios from &ldquo;axios&rdquo;;</p>
<p>// 定义相关的 endpoint<br>
const endPoints = {<br>
test: &ldquo;<a href="https://60b2643d62ab150017ae21de.mockapi.io/%22">https://60b2643d62ab150017ae21de.mockapi.io/&quot;</a>,<br>
prod: &ldquo;<a href="https://prod.myapi.io/%22">https://prod.myapi.io/&quot;</a>,<br>
staging: &ldquo;<a href="https://staging.myapi.io/%22">https://staging.myapi.io/&quot;</a><br>
};</p>
<p>// 创建 axios 的实例<br>
const instance = axios.create({<br>
// 实际项目中根据当前环境设置 baseURL<br>
baseURL: endPoints.test,<br>
timeout: 30000,<br>
// 为所有请求设置通用的 header<br>
headers: { Authorization: &ldquo;Bear mytoken&rdquo; }<br>
});</p>
<p>// 听过 axios 定义拦截器预处理所有请求<br>
instance.interceptors.response.use(<br>
(res) =&gt; {<br>
// 可以假如请求成功的逻辑，比如 log<br>
return res;<br>
},<br>
(err) =&gt; {<br>
if (err.response.status === 403) {<br>
// 统一处理未授权请求，跳转到登录界面<br>
document.location = &lsquo;/login&rsquo;;<br>
}<br>
return Promise.reject(err);<br>
}<br>
);</p>
<p>export default instance;</p>
<p>这样我们就定义了一个简单的 API Client，之后所有的请求都可以通过 Client 连接到指定的服务器，从而不再需要单独设置 Header，或者处理未授权的请求了。当然，虽然例子中用的是 axios，但如果你更倾向于原生的 fetch API，那么使用 fetch 也是完全可以的。这两种方式没有绝对的优劣，你可以按照自己的喜好进行选择。</p>
<p>有了这个 Client，那接下来的例子中，我们都会使用这个 Client，来连接指定的 server。</p>
<h1 id="使用-hooks-思考异步请求封装远程资源">使用 Hooks 思考异步请求：封装远程资源</h1>
<p>在第 2 讲我曾经介绍过 Hooks 的一个本质特性，那就是万物皆可钩，意思是说我们可以把任何一个数据源变成 React 组件中可以绑定的一个数据源。</p>
<p>这个特性对于远程的 Get 类型的请求非常有用。因为 Get 请求，通常就是用来获取数据的。所以从 Hooks 角度来说，我们可以认为一个 Get 请求就是一个远程数据源。那么把这个数据源封装成 Hooks 后，使用远程 API 将会非常方便。</p>
<p>下面这张图可以比较直观地描述这种模式。对于一个 Get 类型的 API，我们完全可以将它看成一个远程的资源。只是和本地数据不同的地方在于，它有三个状态，分别是：</p>
<ol>
<li>Data: 指的是请求成功后服务器返回的数据；</li>
<li>Error: 请求失败的话，错误信息将放到 Error 状态里；</li>
<li>Pending: 请求发出去，在返回之前会处于 Pending 状态。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/ReactHooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/a949c3f7c8be74eb73ddeda7fd344f76.png" alt=""></p>
<p>有了这三个状态，我们就能够在 UI 上去显示 loading，error 或者获取成功的数据了。使用起来会非常方便。</p>
<p>要实现这样一个 Hook 其实也并不难，比起在组件内部直接发请求，我们只是把代码换了个地方，也就是写到了 Hook 里面。下面是代码的实现：</p>
<p>import { useState, useEffect } from &ldquo;react&rdquo;;<br>
import apiClient from &ldquo;./apiClient&rdquo;;</p>
<p>// 将获取文章的 API 封装成一个远程资源 Hook<br>
const useArticle = (id) =&gt; {<br>
// 设置三个状态分别存储 data, error, loading<br>
const [data, setData] = useState(null);<br>
const [loading, setLoading] = useState(false);<br>
const [error, setError] = useState(null);<br>
useEffect(() =&gt; {<br>
// 重新获取数据时重置三个状态<br>
setLoading(true);<br>
setData(null);<br>
setError(null);<br>
apiClient<br>
.get(<code>/posts/${id}</code>)<br>
.then((res) =&gt; {<br>
// 请求成功时设置返回数据到状态<br>
setLoading(false);<br>
setData(res.data);<br>
})<br>
.catch((err) =&gt; {<br>
// 请求失败时设置错误状态<br>
setLoading(false);<br>
setError(err);<br>
});<br>
}, [id]); // 当 id 变化时重新获取数据</p>
<p>// 将三个状态作为 Hook 的返回值<br>
return {<br>
loading,<br>
error,<br>
data<br>
};<br>
};</p>
<p>那么要显示一篇文章的时候，你的脑子里就不再是一个具体的 API 调用，而可以把它看作一个数据，只不过是个远程数据，于是很自然就有加载状态或者错误状态这些数据了。使用的时候，我们就可以把组件的表现层逻辑写得非常简洁：</p>
<p>import useArticle from &ldquo;./useArticle&rdquo;;</p>
<p>const ArticleView = ({ id }) =&gt; {<br>
// 将 article 看成一个远程资源，有 data, loading, error 三个状态<br>
const { data, loading, error } = useArticle(id);<br>
if (error) return &ldquo;Failed.&rdquo;;<br>
if (!data || loading) return &ldquo;Loading&hellip;&rdquo;;<br>
return (<br>
<div className="exp-09-article-view"><br>
<h1><br>
{id}. {data.title}<br>
</h1><br>
<p>{data.content}</p><br>
</div><br>
);<br>
};</p>
<p>可以看到，有了这样一个 Hook，React 的函数组件几乎不需要有任何业务的逻辑，而只是<strong>把数据映射到 JSX 并显示出来</strong>就可以了，在使用的时候非常方便。</p>
<p>事实上，在我们的项目中，可以把每一个 Get 请求都做成这样一个 Hook。数据请求和处理逻辑都放到 Hooks 中，从而实现 Model 和 View 的隔离，不仅代码更加模块化，而且更易于测试和维护。</p>
<p>这里有同学可能会问，为什么要给每个请求都定义一个 Hook 呢？我们直接提供一个通用的 Hook，比如 useRemoteData，然后把 API 地址传进去，难道不可以吗？</p>
<p>不是完全不可以，但这其实是<strong>为了保证每个 Hook 自身足够简单</strong>。一般来说，为了让服务器的返回数据满足 UI 上的展现要求，通常需要进一步处理。而这个对于每个请求的处理逻辑可能都不一样，通过一定的代码重复，能够避免产生太复杂的逻辑。</p>
<p>同时呢，某个远程资源有可能是由多个请求组成的，那么 Hooks 中的逻辑就会不一样，因为要同时发出去多个请求，组成 UI 展现所需要的数据。所以，将每个 Get 请求都封装成一个 Hook，也是为了让逻辑更清楚。</p>
<p>当然，这个模式<strong>仅适用于 Get 请求的逻辑</strong>，对于其它类型，我在第 6 讲中有提到过。当时举的例子是 useAsync 这样一个自定义的 Hook，同样也是用 Hook 的思想，把请求的不同状态封装成了一个数据源供组件使用。</p>
<h1 id="多个-api-调用如何处理并发或串行请求">多个 API 调用：如何处理并发或串行请求？</h1>
<p>在刚才讲的文章显示的例子中，我们只是简单显示了文章的内容，要知道，实际场景肯定比这个更复杂。比如，还需要显示作者、作者头像，以及文章的评论列表。那么，作为一个完整的页面，就需要<strong>发送三个请求</strong>：</p>
<ol>
<li>获取文章内容；</li>
<li>获取作者信息，包括名字和头像的地址；</li>
<li>获取文章的评论列表；</li>
</ol>
<p>这三个请求<strong>同时包含了并发和串行的场景</strong>：文章内容和评论列表是两个可以并发的请求，它们都通过 Article ID 来获取；用户的信息需要等文章内容返回，这样才能知道作者的 ID，从而根据用户的 ID 获取用户信息，这是一个串行的场景。</p>
<p>如果用传统的思路去实现，可能会写下这样一段代码，或者类似的代码：</p>
<p>// 并发获取文章和评论列表<br>
const [article, comments] = await Promise.all([<br>
fetchArticle(articleId),<br>
fetchComments(articleId)<br>
]);<br>
// 得到文章信息后，通过 userId 获取用户信息<br>
const user = await fetchUser(article.userId);</p>
<p>但是我们知道，<strong>React 函数组件是一个同步的函数</strong>，没有办法直接使用 await 这样的同步方法，而是<strong>要把请求通过副作用去触发</strong>。因此如果按照上面这种传统的思维，是很难把逻辑理顺的。</p>
<p>这时候我们就要回到 React 的本质，那就是状态驱动 UI。这意味着我们可以<strong>从状态变化的角度去组织异步调用</strong>。</p>
<p>函数组件的每一次 render，其实都提供了我们根据状态变化执行不同操作的机会，我们思考的路径，就是<strong>利用这个机制，通过不同的状态组合，来实现异步请求的逻辑</strong>。</p>
<p>那么刚才这个显示作者和评论列表的业务需求，主要的实现思路就包括下面这么四点：</p>
<ol>
<li>组件首次渲染，只有文章 ID 这个信息，产生两个副作用去获取文章内容和评论列表；</li>
<li>组件首次渲染，作者 ID 还不存在，因此不发送任何请求；</li>
<li>文章内容请求返回后，获得了作者 ID，然后发送请求获取用户信息；</li>
<li>展示用户信息。</li>
</ol>
<p>可以看到，这里的任何一个副作用，也就是<strong>异步请求，都是基于数据的状态去进行的</strong>。只有当文章的数据返回之后，我们才能得到作者 ID，从而再发送另外一个请求来获取作者信息。这样基于一个数据状态的变化，我们就实现了串行发送请求这个功能。</p>
<p>所以，在代码层面，我们首先需要对 useUser 这个 Hook 做一个改造，使得它在没有传入 ID 的情况下，就不发送请求。对比上面的 useArticle 这个 Hook，唯一的变化就是<strong>在 useEffect 里加入了</strong> <strong>ID 是</strong> <strong>否存在的判断</strong>：</p>
<p>import { useState, useEffect } from &ldquo;react&rdquo;;<br>
import apiClient from &ldquo;./apiClient&rdquo;;</p>
<p>export default (id) =&gt; {<br>
const [data, setData] = useState(null);<br>
const [loading, setLoading] = useState(false);<br>
const [error, setError] = useState(null);<br>
useEffect(() =&gt; {<br>
// 当 id 不存在，直接返回，不发送请求<br>
if (!id) return;<br>
setLoading(true);<br>
setData(null);<br>
setError(null);<br>
apiClient<br>
.get(<code>/users/${id}</code>)<br>
.then((res) =&gt; {<br>
setLoading(false);<br>
setData(res.data);<br>
})<br>
.catch((err) =&gt; {<br>
setLoading(false);<br>
setError(err);<br>
});<br>
}, [id]);<br>
return {<br>
loading,<br>
error,<br>
data<br>
};<br>
};</p>
<p>那么，在文章的展示页面，我们就可以使用下面的代码来实现：</p>
<p>import { useState } from &ldquo;react&rdquo;;<br>
import CommentList from &ldquo;./CommentList&rdquo;;<br>
import useArticle from &ldquo;./useArticle&rdquo;;<br>
import useUser from &ldquo;./useUser&rdquo;;<br>
import useComments from &ldquo;./useComments&rdquo;;</p>
<p>const ArticleView = ({ id }) =&gt; {<br>
const { data: article, loading, error } = useArticle(id);<br>
const { data: comments } = useComments(id);<br>
const { data: user } = useUser(article?.userId);<br>
if (error) return &ldquo;Failed.&rdquo;;<br>
if (!article || loading) return &ldquo;Loading&hellip;&rdquo;;<br>
return (<br>
<div className="exp-09-article-view"><br>
<h1><br>
{id}. {article.title}<br>
</h1><br>
{user &amp;&amp; (<br>
<div className="user-info"><br>
<img src={user.avatar} height="40px" alt="user" /><br>
<div>{user.name}</div><br>
<div>{article.createdAt}</div><br>
</div><br>
)}<br>
<p>{article.content}</p><br>
&lt;CommentList data={comments || []} /&gt;<br>
</div><br>
);<br>
};</p>
<p>这里，结合代码我们<strong>再理一下其中并发和串行请求的思</strong>路。</p>
<p>因为文章的 ID 已经传进来了，因此 useArticle 和 useComments 这两个 Hooks 会发出两个并发的请求，来分别获取信息。而 userUser 这个 Hook 则需要等 article 内容返回后，才能获得 userId 信息，所以这是一个串行的请求：需要等文章内容的请求完成之后才能发起。</p>
<p>那么，最终完整的页面显示的效果如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/ReactHooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/eb42552efc0820c0aeb869a4def2d2f0.png" alt=""></p>
<p>实际的运行效果你也可以通过文末的代码链接来查看。</p>
<h1 id="小结">小结</h1>
<p>在这一讲，我们看到了怎么从 Hooks 的角度去组织异步请求。</p>
<p>首先，我们<strong>要定义一个自己的 API Client</strong>，封装整个应用中异步请求的一些通过设置，以及统一处理，方便在 Hooks 中使用。</p>
<p>然后，我们需要充分利用 Hooks 能让数据源变得可绑定的能力，<strong>让一个远程 API 对应的数据成为一个语义化的数据源</strong>，既可以把业务逻辑和 UI 展现很好地分开，也有利于测试和维护。</p>
<p>最后呢，我们学习了针对多请求的处理，怎么<strong>利用状态的组合变化来实现并发和串行请求</strong>。</p>
<p>学到这里，你会发现，这节课的内容可能和传统的思考方式有较大区别，所以你一定要结合课程代码，仔细思考和体会，才能将这种思考方式熟记于心，并熟练运用到实际的开发当中。</p>
<p>课程中的例子地址是：https://codesandbox.io/s/react-hooks-course-20vzg。你可以在线查看代码和运行效果。</p>
<h1 id="思考题">思考题</h1>
<ol>
<li>在课程的例子中，每次调用 useArticle 这个 Hook 的时候都会触发副作用去获取数据。但是有时候，我们希望在有些组件自动获取，但有的组件中需要点击某个按钮才去获取数据，那么你会如何设计这个 Hook？（可能这道题有一点难度。）</li>
<li>课程中的 Hook 都是使用的 useState 保存了状态数据，也就意味着状态的范围限定在组件内部，组件销毁后，数据就没了。那么如果希望数据直接缓存到全局状态，应该如何做呢？</li>
</ol>
<p>欢迎把你的思考和想法分享在留言区，我会把其中不错的回答进行置顶，供同学们交流讨论。期待你的分享！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/reacthooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/">ReactHooks核心原理与实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%A9%E8%BD%ACserverless%E6%9E%B6%E6%9E%84/09%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87serverle%E5%BA%94%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">09｜性能优化：如何提升Serverle应用的性能？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%9330%E8%AE%B2/09%E5%8E%9F%E5%AD%90%E6%80%A72pc%E8%BF%98%E6%98%AF%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%8E%8B%E8%80%85%E5%90%97/">
            <span class="next-text nav-default">09｜原子性：2PC还是原子性协议的王者吗？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
