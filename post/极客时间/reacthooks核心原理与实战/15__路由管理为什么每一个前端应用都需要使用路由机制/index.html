<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>15__路由管理：为什么每一个前端应用都需要使用路由机制？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是王沛。今天我们来聊聊如何在 React 中使用路由管理。
所谓路由管理，就是让你的页面能够根据 URL 的变化进行页面的切换，这是前端应用中一个非常重要的机制，同时也是 Web 应用区别于桌面应用的一个重要特征。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/reacthooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/15__%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/reacthooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/15__%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="15__路由管理：为什么每一个前端应用都需要使用路由机制？">
  <meta property="og:description" content="你好，我是王沛。今天我们来聊聊如何在 React 中使用路由管理。
所谓路由管理，就是让你的页面能够根据 URL 的变化进行页面的切换，这是前端应用中一个非常重要的机制，同时也是 Web 应用区别于桌面应用的一个重要特征。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="ReactHooks核心原理与实战">

  <meta itemprop="name" content="15__路由管理：为什么每一个前端应用都需要使用路由机制？">
  <meta itemprop="description" content="你好，我是王沛。今天我们来聊聊如何在 React 中使用路由管理。
所谓路由管理，就是让你的页面能够根据 URL 的变化进行页面的切换，这是前端应用中一个非常重要的机制，同时也是 Web 应用区别于桌面应用的一个重要特征。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4965">
  <meta itemprop="keywords" content="ReactHooks核心原理与实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="15__路由管理：为什么每一个前端应用都需要使用路由机制？">
  <meta name="twitter:description" content="你好，我是王沛。今天我们来聊聊如何在 React 中使用路由管理。
所谓路由管理，就是让你的页面能够根据 URL 的变化进行页面的切换，这是前端应用中一个非常重要的机制，同时也是 Web 应用区别于桌面应用的一个重要特征。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">15__路由管理：为什么每一个前端应用都需要使用路由机制？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4965 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#理解路由的工作原理自己实现一个简单的路由机制">理解路由的工作原理：自己实现一个简单的路由机制</a></li>
        <li><a href="#使用-react-router">使用 React Router</a></li>
        <li><a href="#使用嵌套路由实现二级导航页面">使用嵌套路由：实现二级导航页面</a></li>
        <li><a href="#在-url-中保存页面状态">在 URL 中保存页面状态</a></li>
        <li><a href="#路由层面实现权限控制">路由层面实现权限控制</a></li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是王沛。今天我们来聊聊如何在 React 中使用路由管理。</p>
<p>所谓<strong>路由管理</strong>，就是<strong>让你的页面能够根据 URL 的变化进行页面的切换</strong>，这是<strong>前端应用中一个非常重要的机制</strong>，同时也是 Web 应用区别于桌面应用的一个重要特征。</p>
<p>我们之所以说路由非常重要，主要体现在两个方面。</p>
<p>一方面，路由机制提供了按页面去组织整个应用程序的能力，页面之间的交互可以主要通过 URL 来进行，从而可以让各个业务功能互相独立，实现逻辑的解耦。</p>
<p>另一方面，URL 的全称是 _Uniform Resource Locator_，中文意思是“统一资源定位符”，表明 URL 是用于唯一的定位某个资源的。</p>
<p>所以对于能够通过前端应用展现的每一个资源，你都要考虑 URL 是否能唯一地定位到这个资源。这要求 URL 不仅能定位到某个页面，还要能定位到一些状态，比如当前的 Tab 页是什么，或者页面列表应该是第几页，等等。而路由机制，就可以让你做到这一点。</p>
<p>所以，对于每一个前端应用，无论大小，都应该要有自己的路由机制。而我们在开发每一个功能的时候，在设计之初就应该思考当前实现的功能和 URL 是否需要有什么联系。这样就可以让 URL 能够更准确地定位资源，进而提升用户体验。同时，由于我们将某些状态通过 URL 进行了管理，相关的业务逻辑语义也会更加明确。</p>
<p>那么在今天这节课，我就会跟你完整地介绍前端路由的工作原理，以及典型的使用场景，帮助你能够在自己的应用中熟练掌握路由的使用。</p>
<h2 id="理解路由的工作原理自己实现一个简单的路由机制">理解路由的工作原理：自己实现一个简单的路由机制</h2>
<p>在 React 中的路由管理，一般都会通过路由框架 React Router 去实现。可能很多同学一听到“框架”，下意识地就觉得它的实现非常复杂。其实不然，在 React 中实现一个自己路由框架非常容易，只要<strong>利用最基础的 React 机制</strong>就能够实现。</p>
<p>所以我们首先就来看看，如果要自己实现这样一个机制应该如何去做，这样你就能够真正理解 React Router 这样的路由框架的工作原理了。理解了原理，你也就能在使用时更加得心应手，遇到问题也能自主解决。</p>
<p>在一个前端应用中，所谓的<strong>页面切换</strong>，或者导航，其实是一个页面的局部内容要使用不同的组件去展示。比如说下图，一个页面通常由 header、sider、content 等部分组成，但是在实际的页面切换的时候，改变的其实是 content 部分的内容。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/ReactHooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/e78be10236e4d42744fba283812899c3.png" alt=""></p>
<p>所以这也是和传统的 Web 应用不一样的地方：</p>
<ol>
<li>在服务器端渲染的页面中，每个 URL 的变化都是全部页面内容的切换。</li>
<li>而在前端路由管理中，则一般只在主内容区域 Content 部分变化，Header 和 Sider 是不会变化的。</li>
</ol>
<p>那么，实现路由机制的<strong>核心逻辑</strong>就是<strong>根据 URL 路径这个状态，来决定在主内容区域显示什么组件</strong> **。**示意的代码如下：</p>
<p>const MyRouter = ({ children }) =&gt; {<br>
const routes = _.keyBy(<br>
children.map((c) =&gt; c.props),<br>
&ldquo;path&rdquo;,<br>
);<br>
const [hash] = useHash();<br>
const Page = routes[hash.replace(&quot;#&quot;, &ldquo;&rdquo;)]?.component;<br>
// 如果路由不存在就返回 Not found.<br>
return Page ? <Page /> : &ldquo;Not found.&rdquo;;<br>
};</p>
<p>const Route = () =&gt; null;</p>
<p>这样，我们就简单实现了一个 MyRouter 这样的路由容器组件。我们通过 URL 中的 hash，也就是“#”后面的部分来决定具体渲染哪个组件到主区域。</p>
<p>同时我们定义了一个空组件 Route，来接收路由的具体参数 path 和 component，从而以声明式的方式去定义路由。</p>
<p>那么在使用的时候，就可以用下面的代码实现：</p>
<p>function SamplePages {<br>
return (<br>
<div className="sample-pages"><br>
{/* 定义了侧边导航栏 <em>/}<br>
<div className="sider"><br>
<a href="#page1">Page 1</a><br>
<a href="#page2">Page 2</a><br>
<a href="#page3">Page 3</a><br>
<a href="#page4">Page 4</a><br>
</div><br>
<div className="exp-15-page-container"><br>
{/</em> 定义路由配置 */}<br>
<MyRouter><br>
<Route path="page1" component={Page1} /><br>
<Route path="page2" component={Page2} /><br>
<Route path="page3" component={Page3} /><br>
<Route path="page4" component={Page4} /><br>
</MyRouter><br>
</div><br>
&lt;/&gt;<br>
);<br>
};</p>
<p>通过个例子，一方面，你就掌握了一个简单路由机制的实现，从而可以在一些简单的应用中直接使用，避免引入太多依赖。</p>
<p>另一方面，理解了路由实现的原理，也就能更从容地去使用更完善的第三方路由管理框架了。完整的代码和运行效果你也可以通过文末的链接查看。</p>
<h2 id="使用-react-router">使用 React Router</h2>
<p>React Router 作为 React 全家桶三大成员之一，是几乎所有 React 应用的必备。虽然在刚才的例子中，我们自己实现的机制也能简单地进行路由管理。</p>
<p>但是在实际项目中，还有更多的情况需要考虑，比如路由嵌套、URL 的模式匹配、参数提取等。这些细节上的考虑，意味着我们要做一个完整的路由框架，还是需要很大的工作量的，所以你完全可以用 React Router 这样更成熟的开源方案去管理路由，而无须自己开发。</p>
<p>幸运的是，React Router 的使用非常简单，几乎不需要学习成本，你看一个使用的例子就明白了。</p>
<p>如果你细心的话会发现，我们课程的所有示例页面，就是用 React Router 去管理的。下面就是我们课程 App 的根组件。为了缩短这里代码的长度，就以定义了两讲的示例代码页面路由为例：</p>
<p>// 从 react-router-dom 引入路由框架提供的一些组件<br>
import { BrowserRouter, Switch, Route, Link } from &ldquo;react-router-dom&rdquo;;<br>
// 引入了两个课程示例页面<br>
import Counter from &ldquo;./01/Counter&rdquo;;<br>
import UserList from &ldquo;./01/UserList&rdquo;;</p>
<p>// 使用数组定义了页面组件和导航的标题，从而方便下面的渲染逻辑<br>
const routes = [<br>
[&ldquo;01 Counter&rdquo;, Counter],<br>
[&ldquo;01 UserList&rdquo;, UserList],<br>
];<br>
function App() {<br>
return (<br>
<BrowserRouter><br>
<div className="app"><br>
<ul className="sider"><br>
{routes.map(([label]) =&gt; (<br>
<li><br>
&lt;Link to={<code>/${label.replace(&quot; &quot;, &quot;/&quot;)}</code>}&gt;{label}</Link><br>
</li><br>
))}<br>
</ul><br>
<div id="pageContainer" className="page-container"><br>
<Switch><br>
{routes.map(([label, Component]) =&gt; (<br>
&lt;Route key={label} path={<code>/${label.replace(&quot; &quot;, &quot;/&quot;)}</code>}&gt;<br>
<Component /><br>
</Route><br>
))}<br>
{/* 定义一个默认的路由 */}<br>
<Route path="/" exact><br>
<h1>Welcome!</h1><br>
</Route><br>
<Route path="*">Page not found.</Route><br>
</Switch><br>
</div><br>
</div><br>
</BrowserRouter><br>
);<br>
}</p>
<p>这里需要注意，React Router <strong>不仅支持浏览器</strong>，<strong>还支持 React Native，以及一些用 Web 实现的移动 App</strong>，所以它提供了多个 npm 模块。</p>
<p>代码里看到的 react-router-dom，其实正是支持浏览器的模块。我们在开发运行于浏览器的 Web App 时，只要引入这个包就可以了。</p>
<p>同时，我们也看到了 BrowserRouter、Link、Route、Switch 等组件的用法。接下来我就简单解释一下组件的作用。</p>
<p><strong>BrowserRouter</strong>：标识用标准的 URL 路径去管理路由，比如 /my-page1 这样的标准 URL 路径。除此之外，还有 MemoryRouter，表示通过内存管理路由；HashRouter，标识通过 hash 管理路由。我们自己实现的例子其实就是用的 hash 来实现路由。</p>
<p><strong>Link</strong>：定义一个导航链接，点击时可以无刷新地改变页面 URL，从而实现 React Router 控制的导航。</p>
<p><strong>Route</strong>: 定义一条路由规则，可以指定匹配的路径、要渲染的内容等等。</p>
<p><strong>Switch</strong>：在默认情况下，所有匹配的 Route 节点都会被展示，但是 Switch 标记可以保证只有第一个匹配到的路由才会被渲染。</p>
<p>这样，我们就使用了 React Router 提供的最基础的功能，实现了页面级别的路由管理。</p>
<p>但是我们要知道，React Router 的能力并不止于此，它的功能非常强大。我强烈建议你去完整阅读下它的官方文档，它的文档都是示例的形式，并不长，很容易看完，这样你就能够知道它的所有能力，从而在遇到具体需求的时候灵活运用。</p>
<p>那么接下来的内容，我们就以 React Router 为基础，来看看路由管理有哪些具体使用场景。相信通过这些例子，你能够进一步了解 React Router 提供的功能。</p>
<h2 id="使用嵌套路由实现二级导航页面">使用嵌套路由：实现二级导航页面</h2>
<p>所谓<strong>嵌套路由</strong>，也称为<strong>子路由</strong>，就是<strong>一个页面组件内部，还需要通过 URL 上的信息来决定组件内部某个区域</strong> <strong>该</strong> <strong>如何显示</strong>。</p>
<p>嵌套路由对应到业务功能，一般就是一个两级导航页面。比如左边是侧边栏导航，用于控制右侧页面的展示。而右侧某个页面呢，又要通过顶部菜单来控制组件的展示。下面这张图就展示了这样一个布局：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/ReactHooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/c51d7f98b0d21136e5ef5a6f6b831342.png" alt=""></p>
<p>这就需要路由框架具备两个能力：</p>
<ol>
<li><strong>能够模糊匹配</strong>。比如 /page1/general、/page1/profile 这样两个路由，需要都能匹配到 Page1 这样一个组件。然后 Page1 内部呢，再根据 general 和 profile 这两个子路由决定展示哪个具体的页面。</li>
<li><strong>Route 能够嵌套使用</strong>。在我们自定义 Route 的例子中，Route 组件仅用于收集路由定义的信息，不渲染任何内容。如果需要路由能嵌套使用，那就意味着需要在 Route 下还能嵌套使用 Route。而这在 React Router 是提供支持的。</li>
</ol>
<p>下面的代码就展示了嵌套路由的用法：</p>
<p>import { BrowserRouter, Route, Link } from &ldquo;react-router-dom&rdquo;;</p>
<p>const Page1 = () =&gt; {<br>
return (<br>
<div className="exp-15-page1"><br>
<div className="exp-15-page1-header"><br>
<Link to="/page1/general">General</Link><br>
<Link to="/page1/profile">Profile</Link><br>
<Link to="/page1/settings">Settings</Link><br>
</div><br>
<div className="exp-15-page1-content"><br>
<Route path="/page1/general">General Page</Route><br>
<Route path="/page1/profile">Profile Page</Route><br>
<Route path="/page1/settings">Settings Page</Route><br>
</div><br>
</div><br>
);<br>
};<br>
const Page2 = () =&gt; &ldquo;Page 2&rdquo;;<br>
const Page3 = () =&gt; &ldquo;Page 3&rdquo;;</p>
<p>function NestedRouting() {<br>
return (<br>
<BrowserRouter><br>
<h1>Nested Routing</h1><br>
<div className="exp-15-nested-routing"><br>
<div className="exp-15-sider"><br>
<Link to="/page1">Page 1</Link><br>
<Link to="/page2">Page 2</Link><br>
<Link to="/page3">Page 3</Link><br>
</div><br>
<div className="exp-15-page-container"><br>
<Route path="/page1"><Page1 /></Route><br>
<Route path="/page2"><Page2 /></Route><br>
<Route path="/page3"><Page3 /></Route><br>
</div><br>
</div><br>
</BrowserRouter><br>
);<br>
}</p>
<p>可以看到，我们首先在 NestedRouting 组件内部定义了一级导航，让以“/page1”开头的路径都使用 Page1 这个组件，而在 Page1 组件内部，就继续使用 Route 组件来定义二级导航。那么这时候的路径，就都是以“/page1”开头的，比如“/page1/general”。通过这样的机制，我们很容易就完成了二级导航这样一个常用的页面导航模式。</p>
<h2 id="在-url-中保存页面状态">在 URL 中保存页面状态</h2>
<p>这节课一开始我就提到了，拥有 URL 是 Web 应用和传统应用最大的一个区别。这意味这 Web 应用的内容是很容易分享的，只要发送一个 URL，别人就能和我们看到同样的内容。</p>
<p>所以在 Web 应用中我们一定要利用好这个特性，一方面可以<strong>提升用户体验，</strong> <strong>另一方面也可以</strong> <strong>简化页面之间的交互</strong>。</p>
<p>要做到这一点，就需要能<strong>将页面的一些状态存放到 URL 中</strong>。那么底下我们就通过一个例子，来看看应该如何利用 React Router 来管理 URL 中的参数。下面这张图就展示了这样一个场景：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/ReactHooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/cc28c3f90aef113c4c29a01b0c269a1f.png" alt=""></p>
<p>页面上有一个 Tabs 组件，在两个 Tab 下分别有两个可以分页的表格。如果要将页面的内容分享给别人，一方面需要定位到当前展开的是哪个 Tab，同时还应该知道当前是表格的第几页，这样别人通过这个 URL 才能看到和你一样的内容。所以我们只要将当前 Tab 状态，和页码的状态放到 URL 中，就可以实现这样的功能。</p>
<p>那么如何去做呢？首先，我们需要<strong>利用 React Router 的参数功能来定义一条路由</strong>：</p>
<Route path="/tabs-page/:activeTab" component={TabsPage} />
<p>这里可以看到，匹配路径中定义参数的方法，就是用冒号定义一个参数名字，这样如果访问 &ldquo;/tabs-page/users&rdquo; 这样的路径时，“users”这个名字就可以通过 React Router 提供的 API 拿到。而对于页码信息，我们可以通过查询字符串去实现。</p>
<p>下面的代码演示了完整的实现：</p>
<p>import { useCallback } from &ldquo;react&rdquo;;<br>
import { Tabs, Table } from &ldquo;antd&rdquo;;<br>
import { useHistory, useParams } from &ldquo;react-router-dom&rdquo;;<br>
import data from &ldquo;../10/data&rdquo;;<br>
import { useSearchParam } from &ldquo;react-use&rdquo;;</p>
<p>const { TabPane } = Tabs;</p>
<p>export default () =&gt; {<br>
// 通过 React Router 的 API 获取 activeTab 这个参数信息<br>
const { activeTab = &ldquo;users&rdquo; } = useParams();<br>
// 通过查询字符串获取当前的页码信息<br>
const page = parseInt(useSearchParam(&ldquo;page&rdquo;), 10) || 1;</p>
<p>// 通过 React Router 提供的 history 对象来操作 URL<br>
const history = useHistory();<br>
const handleTabChange = useCallback(<br>
(tab) =&gt; history.push(<code>/15/TabsPage/${tab}</code>),<br>
[history],<br>
);<br>
// 定义表格的翻页功能<br>
const pagination = {<br>
pageSize: 3,<br>
current: page,<br>
onChange: (p) =&gt; {<br>
history.push(<code>/15/TabsPage/${activeTab}?page=${p}</code>);<br>
},<br>
};<br>
return (<br>
<div><br>
<h1>Tabs Page</h1><br>
<Tabs activeKey={activeTab} onChange={handleTabChange}><br>
<TabPane tab="Users" key="users"><br>
&lt;Table<br>
dataSource={data}<br>
columns={[<br>
{ dataIndex: &ldquo;name&rdquo;, title: &ldquo;User Name&rdquo; },<br>
{ dataIndex: &ldquo;city&rdquo;, title: &ldquo;City&rdquo; },<br>
]}<br>
pagination={pagination}<br>
/&gt;<br>
</TabPane><br>
<TabPane tab="Jobs" key="jobs"><br>
&lt;Table<br>
dataSource={data}<br>
columns={[{ dataIndex: &ldquo;job&rdquo;, title: &ldquo;Job Title&rdquo; }]}<br>
pagination={pagination}<br>
/&gt;<br>
</TabPane><br>
</Tabs><br>
</div><br>
);<br>
}</p>
<p>借由这样的实现，我们就可以通过 &ldquo;/tabs-page/users?page=2&rdquo; 来唯一的确定某个页面和页面的状态了，这样的 URL 是更语义化，并且可被分享的。</p>
<p>还有特别需要注意的一点是，在这个实现中，我们遵循了唯一数据源的原则，避免定义中间状态去存储 tab 和页码的信息，而是直接去操作 URL，这样可以让代码逻辑更加清晰和直观。</p>
<h2 id="路由层面实现权限控制">路由层面实现权限控制</h2>
<p>在一个前端应用中，路由机制不仅能够管理我们的导航，另外一个常用的场景就是进行<strong>权限的控制</strong>。比如说，只有登录了的用户才能访问某些页面，否则就会显示为“未授权”，并提示登录。那么应该如何利用 React Router 去实现权限控制呢？</p>
<p>我们完全可以利用<strong>前端路由的动态特性</strong>。你已经看到了，路由是<strong>通过 JSX 以声明式的方式去定义</strong>的，这就意味着路由的定义规则是可以根据条件进行变化的，也就是所谓的动态路由。</p>
<p>所以我们只需要根据用户是否登录这样一个状态，通过 Route 组件去声明不同的路由就可以了。比如说下面的代码，就展示了权限控制功能应该如何实现：</p>
<p>import { useState } from &ldquo;react&rdquo;;<br>
import { Button } from &ldquo;antd&rdquo;;<br>
import { Route, Link } from &ldquo;react-router-dom&rdquo;;</p>
<p>// 定义了两个示例页面组件<br>
const Page1 = () =&gt; &ldquo;Page 1&rdquo;;<br>
const Page2 = () =&gt; &ldquo;Page 2&rdquo;;</p>
<p>// 定义了一个组件用户展示未登录状态<br>
const UnauthedPage = () =&gt; (<br>
&lt;span style={{ color: &ldquo;red&rdquo; }}&gt;Unauthorized, please log in first.</span><br>
);<br>
export default () =&gt; {<br>
// 模拟用户是否登录的状态，通过一个按钮进行切换<br>
const [loggedIn, setLoggedIn] = useState(false);</p>
<p>// 定义了两套路由，一套用于登录后，一套用于未登录状态<br>
const routes = loggedIn<br>
? [<br>
{<br>
path: &ldquo;/15/RouterAuth&rdquo;,<br>
component: Page1,<br>
},<br>
{<br>
path: &ldquo;/15/RouterAuth/page1&rdquo;,<br>
component: Page1,<br>
},<br>
{<br>
path: &ldquo;/15/RouterAuth/page2&rdquo;,<br>
component: Page2,<br>
},<br>
]<br>
// 如果未登录，那么对于所有 /15/RouterAuth 开头的路径，显示未授权页面<br>
: [{ path: &ldquo;/15/RouterAuth&rdquo;, component: UnauthedPage }];</p>
<p>return (<br>
<div><br>
<h1>Router Auth</h1><br>
&lt;Button<br>
type={loggedIn ? &ldquo;primary&rdquo; : &ldquo;&rdquo;}<br>
onClick={() =&gt; setLoggedIn((v) =&gt; !v)}<br>
&gt;<br>
{loggedIn ? &ldquo;Log Out&rdquo; : &ldquo;Log In&rdquo;}<br>
</Button></p>
<pre><code>  &lt;div className=&quot;exp-15-router-auth&quot;&gt;  
    &lt;div className=&quot;exp-15-sider&quot;&gt;  
      &lt;Link to=&quot;/15/RouterAuth/page1&quot;&gt;Page 1&lt;/Link&gt;  
      &lt;Link to=&quot;/15/RouterAuth/page2&quot;&gt;Page 2&lt;/Link&gt;  
    &lt;/div&gt;  
    &lt;div className=&quot;exp-15-page-container&quot;&gt;  
      {/* */}  
      {routes.map((r) =&gt; (  
        &lt;Route path={r.path} component={r.component} /&gt;  
      ))}  
    &lt;/div&gt;  
  &lt;/div&gt;  
&lt;/div&gt;  
</code></pre>
<p>);</p>
<p>代码中核心的机制就在于我们根据登录状态，创建了不同的路由规则，这样就能在源头上对权限进行集中控制，避免用户未经授权就访问某些受保护的页面。</p>
<p>同时呢，因为在相同的 URL 下进行了信息提示，那么也就更容易实现用户登录后还能返回原页面的功能。</p>
<h2 id="小结">小结</h2>
<p>在这节课我们主要介绍了在 React 应用中如何进行路由的管理。</p>
<p>首先我们了解了路由的重要性，它不仅能起到导航的作用，还能帮助我们更好地组织业务模块的代码。</p>
<p>随后我们自己动手，实现了一个简单的路由机制，认识到路由在本质上就是<strong>根据状态渲染不同的组件</strong>。注意，这里的状态就是 URL 的路径，而组件则是需要导航的页面。理解了这一点，也就能够理解一些开源框架的具体工作原理，那么你在使用时也就会更加从容。</p>
<p>接着，我们介绍了 React 生态中最为主流的 React Router 框架，它提供了很多灵活的 API，既可以让我们可以实现路由的定义和配置，比如灵活的模式匹配、参数、嵌套路由等等，也能让我们在实际项目中更加容易地去实现路由功能。</p>
<p>最后，通过两个例子，我们看到了路由机制在整个前端应用中的作用。要知道，它不仅仅可以起到导航的作用，还能语义化地标识页面状态，以及进行权限控制。前者提升了用户体验，让前端页面真正做到可分享。而后者则起到关注分离的作用，通过将权限控制逻辑在路由层面实现，就可以让这部分逻辑独立出来，而无须和业务逻辑写在一起，让代码更容易理解和维护。</p>
<h2 id="思考题">思考题</h2>
<p>文中提到在 URL 中存储更多状态可以简化页面之间的交互，那么为什么说可以简化交互呢？你能想到哪些场景呢？</p>
<p>欢迎把你的想法和思考分享在留言区，我会和你交流。同时，我也会把其中一些不错的回答在留言区置顶，供大家学习讨论。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/reacthooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/">ReactHooks核心原理与实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AF%B4%E9%80%8F%E8%8A%AF%E7%89%87/15__%E8%81%8A%E8%81%8A%E8%8A%AF%E7%89%87%E6%8A%95%E8%B5%84%E9%A2%86%E5%9F%9F%E7%9A%84%E6%9C%BA%E4%BC%9A/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">15__聊聊芯片投资领域的机会</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%9C%B1%E8%B5%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E8%AF%BE/15__%E6%AF%8F%E4%B8%AA%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86/">
            <span class="next-text nav-default">15__每个工程师都应该了解的：系统拆分</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
