<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>16__按需加载：如何提升应用打开速度？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是王沛。今天我们来聊聊如何提升 React 应用的打开速度。
随着前端技术的不断演进，以及浏览器性能的不断提高，前端应用的开发也变得越来越复杂，因为更多的功能被放到了前端去实现。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/reacthooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/16__%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/reacthooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/16__%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="16__按需加载：如何提升应用打开速度？">
  <meta property="og:description" content="你好，我是王沛。今天我们来聊聊如何提升 React 应用的打开速度。
随着前端技术的不断演进，以及浏览器性能的不断提高，前端应用的开发也变得越来越复杂，因为更多的功能被放到了前端去实现。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="ReactHooks核心原理与实战">

  <meta itemprop="name" content="16__按需加载：如何提升应用打开速度？">
  <meta itemprop="description" content="你好，我是王沛。今天我们来聊聊如何提升 React 应用的打开速度。
随着前端技术的不断演进，以及浏览器性能的不断提高，前端应用的开发也变得越来越复杂，因为更多的功能被放到了前端去实现。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4646">
  <meta itemprop="keywords" content="ReactHooks核心原理与实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="16__按需加载：如何提升应用打开速度？">
  <meta name="twitter:description" content="你好，我是王沛。今天我们来聊聊如何提升 React 应用的打开速度。
随着前端技术的不断演进，以及浏览器性能的不断提高，前端应用的开发也变得越来越复杂，因为更多的功能被放到了前端去实现。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">16__按需加载：如何提升应用打开速度？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4646 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#如何实现按需加载">如何实现按需加载？</a>
          <ul>
            <li><a href="#使用-import-语句定义按需加载的起始模块">使用 import 语句，定义按需加载的起始模块</a></li>
            <li><a href="#使用-react-lodable实现组件的异步加载">使用 react-lodable，实现组件的异步加载</a></li>
          </ul>
        </li>
        <li><a href="#使用-service-worker-缓存前端资源">使用 service worker 缓存前端资源</a>
          <ul>
            <li><a href="#注册-service-worker">注册 Service Worker</a></li>
            <li><a href="#在-service-worker-安装之后初始化缓存机制">在 Service Worker 安装之后初始化缓存机制</a></li>
            <li><a href="#拦截请求">拦截请求</a></li>
          </ul>
        </li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是王沛。今天我们来聊聊如何提升 React 应用的打开速度。</p>
<p>随着前端技术的不断演进，以及浏览器性能的不断提高，前端应用的开发也变得越来越复杂，因为更多的功能被放到了前端去实现。</p>
<p>这也让我们面临这样一个挑战：<strong>如何控制好整个应用的大小，以及如何提升加载性能，才能确保应用的打开速度够快。</strong></p>
<p>我们来分析一下，看怎么解决这个问题。在应用加载的性能指标中，其中一个很重要的指标就是<strong>首屏打开速度</strong>。也就是说，当用户打开你的应用之后，他要花多久才能看到首页面。根据统计显示，如果首页打开时间超过 3 秒，那么就会流失掉 40% 的用户。所以这项指标的重要性不言而喻，也让我们在完成需求开发的同时，要时刻有意识地去控制包的大小。要知道，包越小，首屏打开速度就越快。</p>
<p>照此来看，为了提高首屏加载速度，我们就需要<strong>对应用进行分包</strong>。</p>
<ol>
<li>首先，在打开某个页面时，只加载这个页面相关的内容，也就是<strong>按需加载</strong>。</li>
<li>同时，为了提升后续应用的打开速度，就需要采用高效的缓存策略，避免前端资源的重复下载。</li>
</ol>
<p>所以这节课，我们首先来看看在 React 应用中如何实现按需加载。然后呢，我会和你介绍下 Service Worker 技术，看看怎么利用 Service Worker 来缓存前端资源。虽然它和 React 没有必然的联系，但是作为目前最为有效的提升加载性能的手段，你也需要进行了解并能正确使用。</p>
<h2 id="如何实现按需加载">如何实现按需加载？</h2>
<h3 id="使用-import-语句定义按需加载的起始模块">使用 import 语句，定义按需加载的起始模块</h3>
<p>所谓<strong>按需加载</strong>，就是指在某个组件需要被渲染到页面时，才会去实际地下载这个页面，以及这个页面依赖的所有代码。</p>
<p>比如当用户打开 /users/profile 这个页面时，才会真正加载对应组件的代码。如下图所示，就展示了这样一个结构，其中 Profile Page 就是需要动态加载的组件。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/ReactHooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/1103b977869a6574639a0441b2ee26db.png" alt=""></p>
<p>这样的话，就不需要在一开始时就载入所有代码，影响首屏打开速度。而是通过按需加载，只下载与页面相关的部分。</p>
<p>要实现这个功能，本质上在于，**我们需要有动态加载模块的能力。**也就是在运行时去加载模块，而不是静态地去 import 一个模块。</p>
<p>对于这个需求，<strong>ECMA Script 标准有一个提案</strong>，专门用于动态加载模块，<strong>语法是 import(someModule)</strong>。</p>
<p>注意，这里的 import 和我们一般用于引入模块的静态声明方式不同，比如 import something from &lsquo;somemodule&rsquo; 。但这里的 import 是作为一个函数动态运行的，这个 import() 函数会返回一个 Promise。这样，在模块加载成功后，我们就可以在 Promise 的 then 回调函数中去使用这个模块了。</p>
<p>虽然这只是一个提案，并没有成为标准，但是 Webpack 等打包工具利用了这样的语法去定义代码的分包。也就是说，Webpack 实现了这样的语法。</p>
<p>下面的代码演示了如何使用 import 语句来定义一个分包的拆分点：</p>
<p>function ProfilePage() {<br>
// 定义一个 state 用于存放需要加载的组件<br>
const [RealPage, setRealPage] = useState(null);</p>
<p>// 根据路径动态加载真正的组件实现<br>
import(&rsquo;./RealProfilePage&rsquo;).then((comp) =&gt; {<br>
setRealPage(Comp);<br>
});<br>
// 如果组件未加载则显示 Loading 状态<br>
if (!RealPage) return &lsquo;Loading&hellip;.&rsquo;;</p>
<p>// 组件加载成功后则将其渲染到界面<br>
return <RealPage /><br>
}</p>
<p>在这段代码中，我们定义了 ProfilePage 这样一个实现按需加载功能的组件。这个组件只有被执行时，也就是渲染到界面上时，才会真正加载具体的实现代码。</p>
<p>这里要理解的关键点就在于，**import() 这个语句完全是由 Webpack 进行处理的。**Webpack 会将以“./RealProfilePage”模块为起点的所有依赖模块，单独打成一个包。并且，Webpack 还会生成代码，用于按需加载这个模块。</p>
<p>理解了这一点，我们也就知道了**按需加载的实现原理：**Webpack 利用了动态 import 语句，自动实现了整个应用的拆包。而我们在实际开发中，其实并不需要关心 Webpack 是如何做到的，而只需要考虑：<strong>该在哪个位置使用 import 语句去定义动态加载的拆分点</strong>。</p>
<p>很显然，我们不可能对任何模块都用动态 import 去加载，因为这会损害用户体验，导致每个功能都得等模块加载。总体需要采用的策略是：<strong>按业务模块为目标去做隔离，尽量在每个模块的起始页面去定义这个拆分点。</strong></p>
<h3 id="使用-react-lodable实现组件的异步加载">使用 react-lodable，实现组件的异步加载</h3>
<p>上面的例子你已经看到了如何去实现一个 React 组件的动态加载，它的总体思路其实主要就是三个部分：</p>
<ol>
<li>定义一个加载器组件，在使用的地方依赖于这个加载器组件而不是原组件；</li>
<li>在加载器组件的执行过程中，使用 import 去动态加载真实的实现代码；</li>
<li>处理加载过程，和加载出错的场景，确保用户体验。</li>
</ol>
<p>显然，这样的逻辑是可以提取出来重用的。而 <strong>react-loadable，正是这样一个开源的 npm 模块，专门用于 React 组件的按需加载</strong>。</p>
<p>因此，在实际的项目开发中，我们一般都会直接使用 react-loadable 来完成按需加载，而不用自己去实现。</p>
<p>我们先看一下它的示例用法。</p>
<p>import Loadable from &ldquo;react-loadable&rdquo;;</p>
<p>// 创建一个显示加载状态的组件<br>
function Loading({ error }) {<br>
return error ? &lsquo;Failed&rsquo; : &lsquo;Loading&rsquo;;<br>
}<br>
// 创建加载器组件<br>
const HelloLazyLoad = Loadable({<br>
loader: () =&gt; import(&quot;./RealHelloLazyLoad&quot;),<br>
loading: Loading,<br>
});</p>
<p>react-lodable 本身是<strong>通过高阶组件来实现</strong>的，这个高阶组件实现了模块加载、loading 状态以及错误处理的功能。你只要通过它提供的简单 API，就可以很容易实现组件的动态加载。</p>
<p>在代码中，我们可以看到 Loadable 这个高阶组件主要就是两个 API。</p>
<ol>
<li><strong>loader：用于传入一个加载器回调，在组件渲染到页面时被执行</strong>。在这个回调函数中，我们只需要直接使用 import 语句去加载需要的模块就可以了。</li>
<li><strong>loading：表示用于显示加载状态的组件</strong>。在模块加载完成之前，加载器就会渲染这个组件。如果模块加载失败，那么 react-loadable 会将 errors 属性传递给 Loading 组件，方便你根据错误状态来显示不同的信息给用户。</li>
</ol>
<p>可以说，有了 react-loadable，我们就不需要实现完整的模块加载器逻辑了，只需要告诉 Loadable 这个高阶组件应该加载哪个模块，加载过程如何显示，就可以将一个组件封装成能够自动按需加载的组件。</p>
<p>按需加载可以说是减少首屏加载时间最为有效的手段，它可以让用户在打开应用时，无需加载所有代码就能开始使用，从而提升用户体验。</p>
<p>但是对于加载性能的优化，除了按需加载之外，还有一块就是前端资源的缓存。合理的缓存策略，可以保证同样的前端资源永远只下载一次，从而让用户在使用过一次你的应用之后，就永远不用重新下载同样的资源，从而极大提高随后 App 的打开速度。</p>
<p>所以下面就跟大家介绍下如何用 Service Worker 来优化加载性能。</p>
<h2 id="使用-service-worker-缓存前端资源">使用 service worker 缓存前端资源</h2>
<p>Service Worker 其实是很容易被大家忽视的一种缓存机制，因为它通常是和 PWA（Progressive Web Application）联系在一起的，用于开发<strong>离线的 Web 应用</strong>。</p>
<p>这个时候，很多人会觉得如果我不开发离线应用，那是不是就不需要 Service Worker 了？</p>
<p>其实不然。Service Worker 还提供了<strong>拦截前端请求</strong>的能力，使得它能够<strong>结合 Local Storage</strong>，**成为一个独立的缓存方案。**所以它不仅可以用于实现前端静态资源的缓存，还能用来开发离线的 Web 应用。</p>
<p>这样的话，我们可以把 Service Worker 看作<strong>一种前端的资源请求代理</strong>。每一个前端页面发出的请求都会先由这个代理进行处理，然后你再决定请求是直接发送到服务器端，还是从本地的 Local Storage 读取内容返回。</p>
<p>如下图所示，展示了请求的流程：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/ReactHooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/ee65014b726c625e5a00cddeb306bafe.png" alt=""></p>
<p>可以看到，Service Worker 会拦截所有浏览器发送出来的请求，你可以通过代码去控制 Rest API 这些请求发送到服务器；而 JS、CSS 等静态资源，则通过 Cache Storage 存储在浏览器端。</p>
<p>和浏览器自动的资源缓存机制相比，Service Worker 加上 Cache Storage 这个缓存机制，具有更高的准确性和可靠性。因为它可以确保两点：</p>
<ol>
<li><strong>缓存永远不过期。你</strong>只要下载过一次，就永远不需要再重新下载，除非主动删除。</li>
<li>**永远不会访问过期的资源。**换句话说，如果发布了一个新版本，那么你可以通过版本化的一些机制，来确保用户访问到的一定是最新的资源。</li>
</ol>
<p>这样，你的前端应用就像一个只需要安装一次的 App，安装过之后，就不需要再重新下载了，这样使用起来加载速度会更快。</p>
<p>下面就给你介绍下<strong>如何使用 Service Worker 以及 Cache Storage</strong>。</p>
<p>Service Worker 是一段独立于页面之外的 JavaScript 脚本，它并不在 Web 页面中运行，但是会在 Web 页面加载时，由一段代码去触发注册、下载和激活。一旦安装完成之后，Service Worker 就会拦截所有当前域名下的所有请求，由代码逻辑决定应该如何处理。</p>
<p>要使用 Service Worker，基本上分为注册、初始化、拦截请求等步骤，下面我们就看一下各个部分应该如何用代码实现。</p>
<h3 id="注册-service-worker">注册 Service Worker</h3>
<p>使用 Service Worker 的第一步，就是告诉浏览器当前域名下我需要使用 Service Worker。</p>
<p>我们可以使用下面的代码来实现：</p>
<p>if (&lsquo;serviceWorker&rsquo; in navigator) {<br>
navigator.serviceWorker<br>
.register(&rsquo;/sw.js&rsquo;)<br>
.then(() =&gt; {<br>
// 注册成功<br>
console.log(&lsquo;Service worker registered.&rsquo;);<br>
}, (err) =&gt; {<br>
// 注册失败<br>
console.log(&lsquo;ServiceWorker registration failed: &lsquo;, err);<br>
});<br>
});<br>
}</p>
<p>从代码中可以看到，首先我们需要判断当前浏览器是否支持 Service Worker。如果支持，那么就用 register 方法注册一个 Service Worker，它的参数是 Service Worker 脚本的代码路径，例子中的代码路径就是根路径下的 sw.js 这个文件。如果浏览器不支持，则什么都不做。</p>
<h3 id="在-service-worker-安装之后初始化缓存机制">在 Service Worker 安装之后初始化缓存机制</h3>
<p>在 Service Worker 的实现代码被下载和执行后，会触发安装完成的事件，这个时候，你就可以在 sw.js 里监听这个事件，从而初始化自己的缓存机制。</p>
<p>比如下面的代码，就演示了如何在安装事件中配置 Cache Storage：</p>
<p>const cacheName = &lsquo;my_app_cache&rsquo;;<br>
// 在 sw.js 中监听安装完成事件<br>
self.addEventListener(&lsquo;install&rsquo;, function(e) {<br>
console.log(&lsquo;Service worker installed.&rsquo;);<br>
// 初始化 Cache Storage<br>
const cacheOpenPromise = caches.open(cacheName);<br>
// 安装过程中，等待 Cache Storage 配置完成<br>
e.waitUntil(cacheOpenPromise);<br>
});</p>
<p>如果你之前没有了解过 Cache Storage，也不要紧，我简单说明下你就能明白。</p>
<p><strong>Cache Storage</strong> 也是<strong>浏览器提供的一种缓存机制</strong>，专门用于缓存一个请求的 request 和 response 的配对关系。此外，它还提供了 API，用来判断某个 request 是不是有对应的 response 已经缓存。所以 Cache Storage 也可以认为是专门为 Service Worker 提供的缓存机制。</p>
<p>有了这样一段代码，我们就完成了 Service Worker 的安装。需要特别注意的是，每次打开 Web 页面时，页面其实都会调用 Service Worker 的 register 方法去注册。但是浏览器会判断脚本内容是否有变化，只有发生了变化才会重新安装。</p>
<h3 id="拦截请求">拦截请求</h3>
<p>当 Service Worker 安装完成后，接下来就是处于运行状态，能够拦截前端的请求了。你可以通过监听 fetch 事件来处理所有的请求，然后根据请求内容等条件来决定如何处理请求。</p>
<p>比如使用本地缓存或者发送到服务器端，实现的方式就是在 sw.js 文件中加入下面的代码：</p>
<p>// 监听所有的请求<br>
self.addEventListener(&lsquo;fetch&rsquo;, function(e) {<br>
// 如果请求的路径不是 js 结尾，就通过 return false 来告诉<br>
// service worker 这个请求应该发送到服务器端<br>
if (!request.url.endsWith(&rsquo;.js&rsquo;)) return false;</p>
<p>// 否则检查 cache 中是否有对应的 response<br>
const promise = caches.open(cacheName).then(cache =&gt; {<br>
// 使用 cache.match<br>
return cache.match(e.request).then(res =&gt; {<br>
if (res) {<br>
// 如果缓存存在则直接返回结果<br>
return Promise.resolve(res);<br>
} else {<br>
// 否则发出请求，并存到 cache<br>
const req = new Request(e.request.url);<br>
return fetch(corsRequest).then(res =&gt; {<br>
// 更新 cache<br>
cache.put(request, res.clone());<br>
return res;<br>
})<br>
}<br>
});<br>
});<br>
// 使用 e.respondWith 方法给请求返回内容<br>
e.respondWith(promise);<br>
});</p>
<p>在这段代码中，采用的是一种缓存优先的策略。如果发现缓存存在，就使用缓存。否则发送请求到服务器端，然后把响应存放到缓存，并同时返回给调用者。</p>
<p>这是一种最为高效的静态资源缓存策略，因为只会下载一次，但同时也对静态资源的打包有一定要求，那就是任何一次代码更新，都需要有唯一的路径。在实际的项目中，一般会通过加入时间戳，或者版本化的命名静态资源文件来实现。</p>
<p>当然，在实际的项目中，使用 Service Worker 其实还有更多的考虑因素，比如何时删掉旧版本缓存，如何处理请求失败等等。但是核心机制基本就是示例代码中的内容，相信你在真正使用时，能够完善地加入对应的细节处理。</p>
<h2 id="小结">小结</h2>
<p>在这一讲，我们主要学习了如何提升 React 应用的加载性能。主要分为两个部分来讲。</p>
<p>第一部分是资源的分包，用于实现按需加载的功能。在这里，我们主要利用了 import 语句和 Webpack 对分包的支持，这样就能够实现按需加载，从而提高首屏页面的打开速度。</p>
<p>第二个是 Service Worker 的概念和用法。不同于 PWA，这里的 Service Worker 仅仅用作前端静态资源的缓存。这是一个非常高效的缓存机制，可以保证静态资源仅被加载一次，从而极大地提高第二次以及后续打开 App 的速度。</p>
<p>因为 Service Worker 通常和 PWA 联系在一起，所以这也是一个很容易被忽视的技术。但通过今天这一课的学习，你应该能够体会到它作为缓存机制的应用场景，只要用很少的成本就带来很不错的用户体验，所以你一定要在实际项目中加以利用。</p>
<h2 id="思考题">思考题</h2>
<p>除了按需加载和 Service Worker，你还能想到哪些可以提升应用加载性能的方法？</p>
<p>欢迎把你的思考和想法分享在留言区，我会和你交流讨论。也欢迎把课程分享给你的同事或朋友，共同进步。我们下节课再见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/reacthooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/">ReactHooks核心原理与实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/16__%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E6%95%B0%E5%AD%97%E4%B8%96%E7%95%8C%E7%9A%84%E5%AE%88%E6%8A%A4/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">16__安全管理：数字世界的守护</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%80%8F%E8%A7%86http%E5%8D%8F%E8%AE%AE/16__%E6%8A%8A%E5%A4%A7%E8%B1%A1%E8%A3%85%E8%BF%9B%E5%86%B0%E7%AE%B1http%E4%BC%A0%E8%BE%93%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/">
            <span class="next-text nav-default">16__把大象装进冰箱：HTTP传输大文件的方法</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
