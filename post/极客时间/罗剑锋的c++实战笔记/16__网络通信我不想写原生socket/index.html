<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>16__网络通信：我不想写原生Socket - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是 Chrono。
在上一节课，我讲了 JSON、MessagePack 和 ProtoBuffer 这三种数据交换格式。现在，我们手里有了这些跨语言、跨平台的通用数据，该怎么与外部通信交换呢？
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/16__%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%88%91%E4%B8%8D%E6%83%B3%E5%86%99%E5%8E%9F%E7%94%9Fsocket/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/16__%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%88%91%E4%B8%8D%E6%83%B3%E5%86%99%E5%8E%9F%E7%94%9Fsocket/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="16__网络通信：我不想写原生Socket">
  <meta property="og:description" content="你好，我是 Chrono。
在上一节课，我讲了 JSON、MessagePack 和 ProtoBuffer 这三种数据交换格式。现在，我们手里有了这些跨语言、跨平台的通用数据，该怎么与外部通信交换呢？">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="罗剑锋的C&#43;&#43;实战笔记">

  <meta itemprop="name" content="16__网络通信：我不想写原生Socket">
  <meta itemprop="description" content="你好，我是 Chrono。
在上一节课，我讲了 JSON、MessagePack 和 ProtoBuffer 这三种数据交换格式。现在，我们手里有了这些跨语言、跨平台的通用数据，该怎么与外部通信交换呢？">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4857">
  <meta itemprop="keywords" content="罗剑锋的C&#43;&#43;实战笔记">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="16__网络通信：我不想写原生Socket">
  <meta name="twitter:description" content="你好，我是 Chrono。
在上一节课，我讲了 JSON、MessagePack 和 ProtoBuffer 这三种数据交换格式。现在，我们手里有了这些跨语言、跨平台的通用数据，该怎么与外部通信交换呢？">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">16__网络通信：我不想写原生Socket</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4857 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#libcurl高可移植功能丰富的通信库">libcurl：高可移植、功能丰富的通信库</a></li>
        <li><a href="#cpr更现代更易用的通信库">cpr：更现代、更易用的通信库</a></li>
        <li><a href="#zmq高效快速多功能的通信库">ZMQ：高效、快速、多功能的通信库</a></li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#课下作业">课下作业</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是 Chrono。</p>
<p>在上一节课，我讲了 JSON、MessagePack 和 ProtoBuffer 这三种数据交换格式。现在，我们手里有了这些跨语言、跨平台的通用数据，该怎么与外部通信交换呢？</p>
<p>你肯定首先想到的就是 Socket 网络编程，使用 TCP/IP 协议栈收发数据，这样不仅可以在本地的进程间通信，也可以在主机、机房之间异地通信。</p>
<p>大方向上这是没错的，但你也肯定知道，原生的 Socket API 非常底层，要考虑很多细节，比如 TIME_WAIT、CLOSE_WAIT、REUSEADDR 等，如果再加上异步就更复杂了。</p>
<p>虽然你可能看过、学过不少这方面的资料，对如何处理这些问题“胸有成竹”，但无论如何，像 Socket 建连 / 断连、协议格式解析、网络参数调整等，都要自己动手做，想要“凭空”写出一个健壮可靠的网络应用程序还是相当麻烦的。</p>
<p>所以，今天我就来谈谈 C++ 里的几个好用的网络通信库：libcurl、cpr 和 ZMQ，让你摆脱使用原生 Socket 编程的烦恼。</p>
<h2 id="libcurl高可移植功能丰富的通信库">libcurl：高可移植、功能丰富的通信库</h2>
<p>第一个要说的库是 libcurl，它来源于著名的curl 项目，也是 curl 的底层核心。</p>
<p>libcurl 经过了多年的开发和实际项目的验证，非常稳定可靠，拥有上百万的用户，其中不乏 Apple、Facebook、Google、Netflix 等大公司。</p>
<p>它最早只支持 HTTP 协议，但现在已经扩展到支持所有的应用层协议，比如 HTTPS、FTP、LDAP、SMTP 等，功能强大。</p>
<p>libcurl 使用纯 C 语言开发，兼容性、可移植性非常好，基于 C 接口可以很容易写出各种语言的封装，所以 Python、PHP 等语言都有 libcurl 相关的库。</p>
<p>因为 C++ 兼容 C，所以我们也可以在 C++ 程序里直接调用 libcurl 来收发数据。</p>
<p>在使用 libcurl 之前，你需要用 apt-get 或者 yum 等工具安装开发库：</p>
<p>apt-get install libcurl4-openssl-dev</p>
<p>虽然 libcurl 支持很多协议，但最常用的还是 HTTP。所以接下来，我也主要介绍 libcurl 的 HTTP 使用方法，这样对其他的协议你也可以做到“触类旁通”。</p>
<p>libcurl 的接口可以粗略地分成两大类：easy 系列和 multi 系列。其中，easy 系列是同步调用，比较简单；multi 系列是异步的多线程调用，比较复杂。通常情况下，我们用 easy 系列就足够了。</p>
<p>使用 libcurl 收发 HTTP 数据的基本步骤有 4 个：</p>
<ol>
<li>使用 curl_easy_init() 创建一个句柄，类型是 CURL*。但我们完全没有必要关心句柄的类型，直接用 auto 推导就行。</li>
<li>使用 curl_easy_setopt() 设置请求的各种参数，比如请求方法、URL、header/body 数据、超时、回调函数等。这是最关键的操作。</li>
<li>使用 curl_easy_perform() 发送数据，返回的数据会由回调函数处理。</li>
<li>使用 curl_easy_cleanup() 清理句柄相关的资源，结束会话。</li>
</ol>
<p>下面我用个简短的例子来示范一下这 4 步：</p>
<p>#include &lt;curl/curl.h&gt;               // 包含头文件</p>
<p>auto curl = curl_easy_init();        // 创建 CURL 句柄<br>
assert(curl);</p>
<p>curl_easy_setopt(curl, CURLOPT_URL, &ldquo;<a href="http://nginx.org">http://nginx.org</a>&rdquo;); // 设置请求 URI</p>
<p>auto res = curl_easy_perform(curl);   // 发送数据<br>
if (res != CURLE_OK) {                // 检查是否执行成功<br>
cout &laquo; curl_easy_strerror(res) &laquo; endl;<br>
}</p>
<p>curl_easy_cleanup(curl);             // 清理句柄相关的资源</p>
<p>这段代码非常简单，重点是调用 curl_easy_setopt() 设置了 URL，请求 Nginx 官网的首页，其他的都使用默认值即可。</p>
<p>由于没有设置你自己的回调函数，所以 libcurl 会使用内部的默认回调，把得到的 HTTP 响应数据输出到标准流，也就是直接打印到屏幕上。</p>
<p>这个处理结果显然不是我们所期待的，所以如果想要自己处理返回的 HTTP 报文，就得写一个回调函数，在里面实现业务逻辑。</p>
<p>因为 libcurl 是 C 语言实现的，所以回调函数必须是函数指针。不过，C++11 允许你写 lambda 表达式，这利用了一个特别规定：<strong>无捕获的 lambda 表达式可以显式转换成一个函数指针</strong>。注意一定要是“无捕获”，也就是说 lambda 引出符“[]”必须是空的，不能捕获任何外部变量。</p>
<p>所以，只要多做一个简单的转型动作，你就可以用 lambda 表达式直接写 libcurl 的回调，还是熟悉的函数式编程风格：</p>
<p>// 回调函数的原型<br>
size_t write_callback(char* , size_t , size_t , void* );</p>
<p>curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION,        // 设置回调函数<br>
(decltype(&amp;write_callback))      // decltype 获取函数指针类型，显式转换<br>
<a href="./char__ptr,_size_t_size,_size_t_nmemb,_void__userdata.md"></a>// lambda<br>
{<br>
cout &laquo; &ldquo;size = &quot; &laquo; size * nmemb &laquo; endl;   // 简单的处理<br>
return size * nmemb;                // 返回接收的字节数<br>
}<br>
);</p>
<p>libcurl 的用法大概就是这个样子了，开头的准备和结尾的清理工作都很简单，关键的就是 curl_easy_setopt() 这一步的参数设置。我们必须通过查文档知道该用哪些标志宏，写一些单调重复的代码。</p>
<p>你可能想到了，可以自己用 C++ 包装出一个类，就能够少敲点键盘。但不要着急，因为我们有一个更好的选择，就是 cpr。</p>
<h2 id="cpr更现代更易用的通信库">cpr：更现代、更易用的通信库</h2>
<p>cpr 是对 libcurl 的一个 C++11 封装，使用了很多现代 C++ 的高级特性，对外的接口模仿了 Python 的 requests 库，非常简单易用。</p>
<p>你可以从GitHub上获取 cpr 的源码，再用 cmake 编译安装：</p>
<p>git clone <a href="mailto:git@github.com">git@github.com</a>:whoshuu/cpr.git<br>
cmake . -DUSE_SYSTEM_CURL=ON -DBUILD_CPR_TESTS=OFF<br>
make &amp;&amp; make install</p>
<p>和 libcurl 相比，cpr 用起来真的是太轻松了，不需要考虑什么初始化、设置参数、清理等杂事，一句话就能发送 HTTP 请求：</p>
<p>#include &lt;cpr/cpr.h&gt;                            // 包含头文件</p>
<p>auto res = cpr::Get(                           // GET 请求   <br>
cpr::Url{&ldquo;<a href="http://openresty.org">http://openresty.org</a>&rdquo;}   // 传递 URL<br>
);</p>
<p>你也不用写回调函数，HTTP 响应就是函数的返回值，用成员变量 url、header、status_code、text 就能够得到报文的各个组成部分：</p>
<p>cout &laquo; res.elapsed &laquo; endl;            // 请求耗费的时间</p>
<p>cout &laquo; res.url &laquo; endl;               // 请求的 URL<br>
cout &laquo; res.status_code &laquo; endl;       // 响应的状态码<br>
cout &laquo; res.text.length() &laquo; endl;     // 响应的 body 数据</p>
<p>for(auto&amp; x : res.header) {            // 响应的头字段<br>
cout &laquo; x.first &laquo; &ldquo;=&gt;&rdquo;            // 类似 map 的结构<br>
&laquo; x.second &laquo; endl;<br>
}</p>
<p>在 cpr 里，HTTP 协议的概念都被实现为相应的函数或者类，内部再转化为 libcurl 操作，主要的有：</p>
<ol>
<li>GET/HEAD/POST 等请求方法，使用同名的 Get/Head/Post 函数；</li>
<li>URL 使用 Url 类，它其实是 string 的别名；</li>
<li>URL 参数使用 Parameters 类，KV 结构，近似 map；</li>
<li>请求头字段使用 Header 类，它其实是 map 的别名，使用定制的函数实现了大小写无关比较；</li>
<li>Cookie 使用 Cookies 类，也是 KV 结构，近似 map；</li>
<li>请求体使用 Body 类；</li>
<li>超时设置使用 Timeout 类。</li>
</ol>
<p>这些函数和类的用法都非常自然、符合思维习惯，而且因为可以使用 C++11 的花括号“{}”初始化语法，如果你以前用过 Python reqeusts 库的话一定会感到很亲切：</p>
<p>const auto url = &ldquo;<a href="http://openresty.org">http://openresty.org</a>&quot;s;  // 访问的 URL</p>
<p>auto res1 = cpr::Head(                    // 发送 HEAD 请求<br>
cpr::Url{url}                 // 传递 URL<br>
);</p>
<p>auto res2 = cpr::Get(                     // 发送 GET 请求<br>
cpr::Url{url},               // 传递 URL<br>
cpr::Parameters{             // 传递 URL 参数<br>
{&ldquo;a&rdquo;, &ldquo;1&rdquo;}, {&ldquo;b&rdquo;, &ldquo;2&rdquo;}}<br>
);</p>
<p>auto res3 = cpr::Post(                  // 发送 POST 请求<br>
cpr::Url{url},             // 传递 URL<br>
cpr::Header{                // 定制请求头字段<br>
{&ldquo;x&rdquo;, &ldquo;xxx&rdquo;},{&ldquo;expect&rdquo;,&rdquo;&rdquo;}},<br>
cpr::Body{&ldquo;post data&rdquo;},    // 传递 body 数据<br>
cpr::Timeout{200ms}       // 超时时间<br>
);</p>
<p>cpr 也支持异步处理，但它内部没有使用 libcurl 的 multi 接口，而是使用了标准库里的 future 和 async（参见第 14 讲），和 libcurl 的实现相比，既简单又好理解。</p>
<p>异步接口与同步接口的调用方式基本一样，只是名字多了个“Async”的后缀，返回的是一个 future 对象。你可以调用 wait() 或者 get() 来获取响应结果：</p>
<p>auto f = cpr::GetAsync(                    // 异步发送 GET 请求<br>
cpr::Url{&ldquo;<a href="http://openresty.org">http://openresty.org</a>&rdquo;}<br>
);</p>
<p>auto res = f.get();                       // 等待响应结果<br>
cout &laquo; res.elapsed &laquo; endl;              // 请求耗费的时间</p>
<p>看了上面这些介绍，你是不是有些心动了。说实话，我原来在 C++ 里也是一直用 libcurl，也写过自己的包装类，直到发现了 cpr 这个“大杀器”，就立即“弃暗投明”了。</p>
<p>相信有了 cpr，你今后在 C++ 里写 HTTP 应用就不再是痛苦，而是一种享受了。</p>
<h2 id="zmq高效快速多功能的通信库">ZMQ：高效、快速、多功能的通信库</h2>
<p>libcurl 和 cpr 处理的都是 HTTP 协议，虽然用起来很方便，但协议自身也有一些限制，比如必须要一来一回，必须点对点直连，在超大数据量通信的时候就不是太合适。</p>
<p>还有一点，libcurl 和 cpr 只能充当 HTTP 的客户端，如果你想写服务器端程序，这两个工具就完全派不上用场。</p>
<p>所以，我们就需要一个更底层、更灵活的网络通信工具，它应该能够弥补 libcurl 和 cpr 的不足，不仅快速高效，还能同时支持客户端和服务器端编程。</p>
<p>这就是我要说的第三个库：ZMQ。</p>
<p>其实，ZMQ 不仅是一个单纯的网络通信库，更像是一个高级的异步并发框架。</p>
<p>从名字上就可以看出来，Zero Message Queue——零延迟的消息队列，意味着它除了可以收发数据外，还可以用作消息中间件，解耦多个应用服务之间的强依赖关系，搭建高效、有弹性的分布式系统，从而超越原生的 Socket。</p>
<p>作为消息队列，ZMQ 的另一大特点是零配置零维护零成本，不需要搭建额外的代理服务器，只要安装了开发库就能够直接使用，相当于把消息队列功能直接嵌入到你的应用程序里：</p>
<p>apt-get install libzmq3-dev</p>
<p>ZMQ 是用 C++ 开发的，但出于兼容的考虑，对外提供的是纯 C 接口。不过它也有很多 C++ 封装，这里我选择的是自带的cppzmq，虽然比较简单，但也基本够用了。</p>
<p>由于 ZMQ 把自身定位于更高层次的“异步消息队列”，所以它的用法就不像 Socket、HTTP 那么简单直白，而是定义了 5 种不同的工作模式，来适应实际中常见的网络通信场景。</p>
<p>我来大概说一下这 5 种模式：</p>
<ol>
<li>原生模式（RAW），没有消息队列功能，相当于底层 Socket 的简单封装；</li>
<li>结对模式（PAIR），两个端点一对一通信；</li>
<li>请求响应模式（REQ-REP），也是两个端点一对一通信，但请求必须有响应；</li>
<li>发布订阅模式（PUB-SUB），一对多通信，一个端点发布消息，多个端点接收处理；</li>
<li>管道模式（PUSH-PULL），或者叫流水线，可以一对多，也可以多对一。</li>
</ol>
<p>前四种模式类似 HTTP 协议、Client-Server 架构，很简单，就不多说了。我拿我在工作中比较常用的管道模式来给你示范一下 ZMQ 的用法，它非常适合进程间无阻塞传送海量数据，也有点 map-reduce 的意思。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84C++%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/336be2bf18494d4a523dd69186d0b798.png" alt=""></p>
<p>在 ZMQ 里有两个基本的类。</p>
<ol>
<li>第一个是 context_t，它是 ZMQ 的运行环境。使用 ZMQ 的任何功能前，必须要先创建它。</li>
<li>第二个是 socket_t，表示 ZMQ 的套接字，需要指定刚才说的那 5 种工作模式。注意它与原生 Socket 没有任何关系，只是借用了名字来方便理解。</li>
</ol>
<p>下面的代码声明了一个全局的 ZMQ 环境变量，并定义了一个 lambda 表达式，生产 ZMQ 套接字：</p>
<p>const auto thread_num = 1;              // 并发线程数</p>
<p>zmq::context_t context(thread_num);     // ZMQ 环境变量</p>
<p>auto make_sock = <a href="./auto_mode.md">&amp;</a>        // 定义一个 lambda 表达式<br>
{<br>
return zmq::socket_t(context, mode); // 创建 ZMQ 套接字<br>
};</p>
<p>和原生 Socket 一样，ZMQ 套接字也必须关联到一个确定的地址才能收发数据，但它不仅支持 TCP/IP，还支持进程内和进程间通信，这在本机交换数据时会更高效：</p>
<ol>
<li>TCP 通信地址的形式是“tcp://…”，指定 IP 地址和端口号；</li>
<li>进程内通信地址的形式是“inproc://…”，指定一个本地可访问的路径；</li>
<li>进程间通信地址的形式是“ipc://…”，也是一个本地可访问的路径。</li>
</ol>
<p>用 bind()/connect() 这两个函数把 ZMQ 套接字连接起来之后，就可以用 send()/recv() 来收发数据了，看一下示例代码吧：</p>
<p>const auto addr = &ldquo;ipc:///dev/shm/zmq.sock&quot;s;  // 通信地址</p>
<p>auto receiver = <a href="">=</a>                     // lambda 表达式接收数据<br>
{<br>
auto sock = make_sock(ZMQ_PULL);      // 创建 ZMQ 套接字，拉数据</p>
<pre><code>sock.bind(addr);                     // 绑定套接字  
assert(sock.connected());  

zmq::message_t msg;  
sock.recv(&amp;msg);                      // 接收消息  

string s = {msg.data&lt;char&gt;(), msg.size()};  
cout &lt;&lt; s &lt;&lt; endl;  
</code></pre>
<p>};</p>
<p>auto sender = <a href="">=</a>                     // lambda 表达式发送数据<br>
{<br>
auto sock = make_sock(ZMQ_PUSH);     // 创建 ZMQ 套接字，推数据</p>
<pre><code>sock.connect(addr);                  // 连接到对端  
assert(sock.connected());  

string s = &quot;hello zmq&quot;;  
sock.send(s.data(), s.size());       // 发送消息  
</code></pre>
<p>};</p>
<p>这段代码实现了两个最基本的客户端和服务器，看起来好像没什么特别的。但你应该注意到，使用 ZMQ 完全不需要考虑底层的 TCP/IP 通信细节，它会保证消息异步、安全、完整地到达服务器，让你关注网络通信之上更有价值的业务逻辑。</p>
<p>ZMQ 的用法就是这么简单，但想要进一步发掘它的潜力，处理大流量的数据还是要去看它的文档，选择合适的工作模式，再仔细调节各种参数。</p>
<p>接下来，我再给你分享两个实际工作中会比较有用的细节吧。</p>
<p>一个是 <strong>ZMQ 环境的线程数</strong>。它的默认值是 1，太小了，适当增大一些就可以提高 ZMQ 的并发处理能力。我一般用的是 4~6，具体设置为多少最好还是通过性能测试来验证下。</p>
<p>另一个是<strong>收发消息时的本地缓存数量</strong>，ZMQ 的术语叫 High Water Mark。如果收发的数据过多，数量超过 HWM，ZMQ 要么阻塞，要么丢弃消息。</p>
<p>HWM 需要调用套接字的成员函数 setsockopt() 来设置，注意收发使用的是两个不同的标志：</p>
<p>sock.setsockopt(ZMQ_RCVHWM, 1000);     // 接收消息最多缓存 1000 条<br>
sock.setsockopt(ZMQ_SNDHWM, 100);      // 发送消息最多缓存 100 条</p>
<p>我们把 HWM 设置成多大都可以，比如我就曾经在一个高并发系统里用过 100 万以上的值，不用担心，ZMQ 会把一切都处理得很好。</p>
<p>关于 ZMQ 就暂时说到这里，它还有很多强大的功能，你可以阅读官网上的教程和指南，里面非常详细地讨论了 ZMQ 的各种模式和要点。</p>
<h2 id="小结">小结</h2>
<p>好了，我来给今天的内容做一个小结：</p>
<ol>
<li>libcurl 是一个功能完善、稳定可靠的应用层通信库，最常用的就是 HTTP 协议；</li>
<li>cpr 是对 libcurl 的 C++ 封装，接口简单易用；</li>
<li>libcurl 和 cpr 都只能作为客户端来使用，不能编写服务器端应用；</li>
<li>ZMQ 是一个高级的网络通信库，支持多种通信模式，可以把消息队列功能直接嵌入应用程序，搭建出高效、灵活、免管理的分布式系统。</li>
</ol>
<p>最后，再说说即将到来的 C++20，原本预计会加入期待已久的 networking 库，但现在已经被推迟到了下一个版本（C++23）。</p>
<p>networking 库基于已有多年实践的 boost.asio，采用前摄器模式（Proactor）统一封装了操作系统的各种异步机制（epoll、kqueue、IOCP），而且支持协程。有了它，我们的网络通信工作就会更加轻松。</p>
<h2 id="课下作业">课下作业</h2>
<p>最后是课下作业时间，给你留两个思考题：</p>
<ol>
<li>你在网络编程的时候都遇到过哪些“坑”，今天说的这几个库能否解决你的问题？</li>
<li>你觉得 ZMQ 能够在多大程度上代替原生 Socket？</li>
</ol>
<p>欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84C++%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/2589d63cc7b3bf6730933a6799bf5772.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/">罗剑锋的C&#43;&#43;实战笔记</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%9836%E8%AE%B2/16__%E5%9B%A2%E9%98%9F%E5%BB%BA%E8%AE%BE%E8%AF%A5%E4%BB%8E%E5%93%AA%E9%87%8C%E5%85%A5%E6%89%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">16__团队建设该从哪里入手？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/16__%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B8%AD%E5%A4%8D%E6%9D%82%E5%A4%9A%E5%8F%98%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96/">
            <span class="next-text nav-default">16__网络优化（中）：复杂多变的移动网络该如何优化？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
