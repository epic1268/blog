<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>22__知识串讲（下）：带你开发一个书店应用 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是 Chrono。
在上节课里，我给出了一个书店程序的例子，讲了项目设计、类图和自旋锁、Lua 配置文件解析等工具类，搭建出了应用的底层基础。
今天，我接着讲剩下的主要业务逻辑部分，也就是数据的表示与统计，还有数据的接收和发送主循环，最终开发出完整的应用程序。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/22__%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%E4%B8%8B%E5%B8%A6%E4%BD%A0%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E4%B9%A6%E5%BA%97%E5%BA%94%E7%94%A8/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/22__%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%E4%B8%8B%E5%B8%A6%E4%BD%A0%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E4%B9%A6%E5%BA%97%E5%BA%94%E7%94%A8/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="22__知识串讲（下）：带你开发一个书店应用">
  <meta property="og:description" content="你好，我是 Chrono。
在上节课里，我给出了一个书店程序的例子，讲了项目设计、类图和自旋锁、Lua 配置文件解析等工具类，搭建出了应用的底层基础。
今天，我接着讲剩下的主要业务逻辑部分，也就是数据的表示与统计，还有数据的接收和发送主循环，最终开发出完整的应用程序。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="罗剑锋的C&#43;&#43;实战笔记">

  <meta itemprop="name" content="22__知识串讲（下）：带你开发一个书店应用">
  <meta itemprop="description" content="你好，我是 Chrono。
在上节课里，我给出了一个书店程序的例子，讲了项目设计、类图和自旋锁、Lua 配置文件解析等工具类，搭建出了应用的底层基础。
今天，我接着讲剩下的主要业务逻辑部分，也就是数据的表示与统计，还有数据的接收和发送主循环，最终开发出完整的应用程序。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4133">
  <meta itemprop="keywords" content="罗剑锋的C&#43;&#43;实战笔记">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="22__知识串讲（下）：带你开发一个书店应用">
  <meta name="twitter:description" content="你好，我是 Chrono。
在上节课里，我给出了一个书店程序的例子，讲了项目设计、类图和自旋锁、Lua 配置文件解析等工具类，搭建出了应用的底层基础。
今天，我接着讲剩下的主要业务逻辑部分，也就是数据的表示与统计，还有数据的接收和发送主循环，最终开发出完整的应用程序。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">22__知识串讲（下）：带你开发一个书店应用</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4133 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#数据定义">数据定义</a></li>
        <li><a href="#序列化">序列化</a></li>
        <li><a href="#数据存储与统计">数据存储与统计</a></li>
        <li><a href="#服务端主线程">服务端主线程</a></li>
        <li><a href="#数据外发线程">数据外发线程</a></li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#课下作业">课下作业</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是 Chrono。</p>
<p>在上节课里，我给出了一个书店程序的例子，讲了项目设计、类图和自旋锁、Lua 配置文件解析等工具类，搭建出了应用的底层基础。</p>
<p>今天，我接着讲剩下的主要业务逻辑部分，也就是数据的表示与统计，还有数据的接收和发送主循环，最终开发出完整的应用程序。</p>
<p>这里我再贴一下项目的 UML 图，希望给你提个醒。借助图形，我们往往能够更好地把握程序的总体结构。</p>
<p>图中间标注为绿色的两个类 SalesData、Summary 和两个 lambda 表达式 recv_cycle、log_cycle 是今天这节课的主要内容，实现了书店程序的核心业务逻辑，所以需要你重点关注它。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84C++%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/bfcb736a8ef0a74d3907d32d093a4b2c.png" alt=""></p>
<h2 id="数据定义">数据定义</h2>
<p>首先，我们来看一下怎么表示书本的销售记录。这里用的是 SalesData 类，它是书店程序数据统计的基础。</p>
<p>如果是实际的项目，SalesData 会很复杂，因为一本书的相关信息有很多。但是，我们的这个例子只是演示，所以就简化了一些，基本的成员只有三个：ID 号、销售册数和销售金额。</p>
<p>上节课，在讲自旋锁、配置文件等类时，我只是重点说了说代码内部逻辑，没有完整地细说，到底该怎么应用前面讲过的那些 C++ 编码准则。</p>
<p>那么，这次在定义 SalesData 类的时候，我就集中归纳一下。这些都是我写 C++ 代码时的“惯用法”，你也可以在自己的代码里应用它们，让代码更可读可维护：</p>
<ol>
<li>适当使用空行分隔代码里的逻辑段落；</li>
<li>类名使用 CamelCase，函数和变量用 snake_case，成员变量加“m_”前缀；</li>
<li>在编译阶段使用静态断言，保证整数、浮点数的精度；</li>
<li>使用 final 终结类继承体系，不允许别人产生子类；</li>
<li>使用 default 显示定义拷贝构造、拷贝赋值、转移构造、转移赋值等重要函数；</li>
<li>使用委托构造来编写多个不同形式的构造函数；</li>
<li>成员变量在声明时直接初始化；</li>
<li>using 定义类型别名；</li>
<li>使用 const 来修饰常函数；</li>
<li>使用 noexcept 标记不抛出异常，优化函数。</li>
</ol>
<p>列的点比较多，你可以对照着源码来进行理解：</p>
<p>class SalesData final                   // final 禁止继承<br>
{<br>
public:<br>
using this_type = SalesData;         // 自己的类型别名<br>
public:<br>
using string_type       = std::string;         // 外部的类型别名<br>
using string_view_type  = const std::string&amp;;<br>
using uint_type         = unsigned int;<br>
using currency_type     = double;</p>
<p>STATIC_ASSERT(sizeof(uint_type) &gt;= 4);          // 静态断言<br>
STATIC_ASSERT(sizeof(currency_type) &gt;= 4);<br>
public:<br>
SalesData(string_view_type id, uint_type s, currency_type r) noexcept         // 构造函数，保证不抛出异常<br>
: m_id(id), m_sold(s), m_revenue(r)<br>
{}</p>
<p>SalesData(string_view_type id) noexcept         // 委托构造<br>
: SalesData(id, 0, 0)<br>
{} <br>
public:<br>
SalesData() = default;                 // 显式 default<br>
~SalesData() = default;</p>
<p>SalesData(const this_type&amp;) = default;<br>
SalesData&amp; operator=(const this_type&amp;) = default;</p>
<p>SalesData(this_type&amp;&amp; s) = default;  // 显式转移构造<br>
SalesData&amp; operator=(this_type&amp;&amp; s) = default;<br>
private:<br>
string_type m_id        = &ldquo;&rdquo;;         // 成员变量初始化<br>
uint_type   m_sold      = 0;<br>
uint_type   m_revenue   = 0;<br>
public:<br>
void inc_sold(uint_type s) noexcept        // 不抛出异常<br>
{<br>
m_sold += s;<br>
}<br>
public:<br>
string_view_type id() const noexcept       // 常函数，不抛出异常<br>
{<br>
return m_id;<br>
}</p>
<p>uint_type sold() const noexcept           // 常函数，不抛出异常<br>
{<br>
return m_sold;<br>
}<br>
};</p>
<p>需要注意的是，代码里显式声明了转移构造和转移赋值函数，这样，在放入容器的时候就避免了拷贝，能提高运行效率。</p>
<h2 id="序列化">序列化</h2>
<p>SalesData 作为销售记录，需要在网络上传输，所以就需要序列化和反序列化。</p>
<p>这里我选择的是 MessagePack（第 15 讲），我看重的是它小巧轻便的特性，而且用起来也很容易，只要在类定义里添加一个宏，就可以实现序列化：</p>
<p>public:<br>
MSGPACK_DEFINE(m_id, m_sold, m_revenue);  // 实现 MessagePack 序列化功能</p>
<p>为了方便使用，还可以为 SalesData 增加一个专门序列化的成员函数 pack()：</p>
<p>public:<br>
msgpack::sbuffer pack() const          // 成员函数序列化<br>
{<br>
msgpack::sbuffer sbuf;<br>
msgpack::pack(sbuf, *this);</p>
<pre><code>  return sbuf;  
</code></pre>
<p>}</p>
<p>不过你要注意，写这个函数的同时也给 SalesData 类增加了点复杂度，在一定程度上违反了单一职责原则和接口隔离原则。</p>
<p>如果你在今后的实际项目中遇到类似的问题，就要权衡后再做决策，确认引入新功能带来的好处大于它增加的复杂度，尽量抵制扩充接口的诱惑，否则很容易写出“巨无霸”类。</p>
<h2 id="数据存储与统计">数据存储与统计</h2>
<p>有了销售记录之后，我们就可以定义用于数据存储和统计的 Summary 类了。</p>
<p>Summary 类依然要遵循刚才的那些基本准则。从 UML 类图里可以看到，它关联了好几个类，所以类型别名对于它来说就特别重要，不仅可以简化代码，也方便后续的维护，你可要仔细看一下源码：</p>
<p>class Summary final                       // final 禁止继承<br>
{<br>
public:<br>
using this_type = Summary;               // 自己的类型别名<br>
public:<br>
using sales_type        = SalesData;       // 外部的类型别名<br>
using lock_type         = SpinLock;<br>
using lock_guard_type   = SpinLockGuard;</p>
<p>using string_type       = std::string;<br>
using map_type          =                  // 容器类型定义<br>
std::map&lt;string_type, sales_type&gt;;<br>
using minmax_sales_type =<br>
std::pair&lt;string_type, string_type&gt;;<br>
public:<br>
Summary() = default;                   // 显式 default<br>
~Summary() = default;</p>
<p>Summary(const this_type&amp;) = delete;    // 显式 delete<br>
Summary&amp; operator=(const this_type&amp;) = delete;<br>
private:<br>
mutable lock_type   m_lock;            // 自旋锁<br>
map_type            m_sales;           // 存储销售记录<br>
};</p>
<p>Summary 类的职责是存储大量的销售记录，所以需要选择恰当的容器。</p>
<p>考虑到销售记录不仅要存储，还有对数据的排序要求，所以我选择了可以在插入时自动排序的有序容器 map。</p>
<p>不过要注意，这里我没有定制比较函数，所以默认是按照书号来排序的，不符合按销售量排序的要求。</p>
<p>（如果要按销售量排序的话就比较麻烦，因为不能用随时变化的销量作为 Key，而标准库里又没有多索引容器，所以，你可以试着把它改成 unordered_map，然后再用 vector 暂存来排序）。</p>
<p>为了能够在多线程里正确访问，Summary 使用自旋锁来保护核心数据，在对容器进行任何操作前都要获取锁。锁不影响类的状态，所以要用 mutable 修饰。</p>
<p>因为有了 RAII 的 SpinLockGuard（第 21 讲），所以自旋锁用起来很优雅，直接构造一个变量就行，不用担心异常安全的问题。你可以看一下成员函数 add_sales() 的代码，里面还用到了容器的查找算法。</p>
<p>public:<br>
void add_sales(const sales_type&amp; s)       // 非 const<br>
{<br>
lock_guard_type guard(m_lock);          // 自动锁定，自动解锁</p>
<pre><code>const auto&amp; id = s.id();                // const auto 自动类型推导  

if (m_sales.find(id) == m_sales.end()) {// 查找算法  
    m_sales[id] = s;                    // 没找到就添加元素  
    return;  
}  

m_sales[id].inc_sold(s.sold());        // 找到就修改销售量  
m_sales[id].inc_revenue(s.revenue());  
</code></pre>
<p>}</p>
<p>Summary 类里还有一个特别的统计功能，计算所有图书销量的第一名和最后一名。这用到了 minmax_element 算法（第 13 讲）。又因为比较规则是销量，而不是 ID 号，所以还要用 lambda 表达式自定义比较函数：</p>
<p>public:<br>
minmax_sales_type minmax_sales() const    //常函数<br>
{<br>
lock_guard_type guard(m_lock);          // 自动锁定，自动解锁</p>
<pre><code>if (m_sales.empty()) {                  // 容器空则不处理  
  return minmax_sales_type();  
}  

auto ret = std::minmax_element(        // 求最大最小值  
  std::begin(m_sales), std::end(m_sales),// 全局函数获取迭代器  
  [](./const_auto&amp;_a,_const_auto&amp;_b.md)    // 匿名 lambda 表达式  
  {  
      return a.second.sold() &lt; b.second.sold();  
  });  

auto min_pos = ret.first;            // 返回的是两个迭代器位置  
auto max_pos = ret.second;  

return {min_pos-&gt;second.id(), max_pos-&gt;second.id()};  
</code></pre>
<p>}</p>
<h2 id="服务端主线程">服务端主线程</h2>
<p>好了，所有的功能类都开发完了，现在就可以把它们都组合起来了。</p>
<p>因为客户端程序比较简单，只是序列化，再用 ZMQ 发送，所以我就不讲了，你可以课下去看GitHub上的源码，今天我主要讲服务器端。</p>
<p>在 main() 函数开头，首先要加载配置文件，然后是数据存储类 Summary，再定义一个用来计数的原子变量 count（第 14 讲），这些就是程序运行的全部环境数据：</p>
<p>Config conf;                  // 封装读取 Lua 配置文件<br>
conf.load(&quot;./conf.lua&quot;);      // 解析配置文件</p>
<p>Summary sum;                  // 数据存储和统计<br>
std::atomic_int count {0};    // 计数用的原子变量</p>
<p>接下来的服务器主循环，我使用了 lambda 表达式，引用捕获上面的那些变量：</p>
<p>auto recv_cycle = <a href="">&amp;</a>      // 主循环 lambda 表达式<br>
{<br>
&hellip;<br>
};</p>
<p>主要的业务逻辑其实很简单，就是 ZMQ 接收数据，然后 MessagePack 反序列化，存储数据。</p>
<p>不过为了避免阻塞、充分利用多线程，我在收到数据后，就把它包装进智能指针，再扔到另外一个线程里去处理了。这样主循环就只接收数据，不会因为反序列化、插入、排序等大计算量的工作而阻塞。</p>
<p>我在代码里加上了详细的注释，你一定要仔细看、认真理解：</p>
<p>auto recv_cycle = <a href="">&amp;</a>               // 主循环 lambda 表达式<br>
{<br>
using zmq_ctx = ZmqContext&lt;1&gt;;       // ZMQ 的类型别名</p>
<p>auto sock = zmq_ctx::recv_sock();   // 自动类型推导获得接收 Socket</p>
<p>sock.bind(                           // 绑定 ZMQ 接收端口<br>
conf.get<string>(&ldquo;config.zmq_ipc_addr&rdquo;));   // 读取 Lua 配置文件</p>
<p>for(;;) {                           // 服务器无限循环<br>
auto msg_ptr =                   // 自动类型推导获得智能指针<br>
std::make_shared&lt;zmq_message_type&gt;();</p>
<pre><code>sock.recv(msg_ptr.get());        // ZMQ 阻塞接收数据  

++count;                          // 增加原子计数  

std::thread(            // 再启动一个线程反序列化存储，没有用 async  
[&amp;sum, msg_ptr]()                // 显式捕获，注意！！  
{  
    SalesData book;  

    auto obj = msgpack::unpack(      // 反序列化  
                msg_ptr-&gt;data&lt;char&gt;(), msg_ptr-&gt;size()).get();  
    obj.convert(book);  

    sum.add_sales(book);            // 存储数据  
}).detach();                        // 分离线程，异步运行  
</code></pre>
<p>}                                     // for(;;) 结束<br>
};                                      // recv_cycle lambda</p>
<p>你要特别注意 lambda 表达式与智能指针的配合方式，要用值捕获而不能是引用捕获，否则，在线程运行的时候，智能指针可能会因为离开作用域而被销毁，引用失效，导致无法预知的错误。</p>
<p>有了这个 lambda，现在就可以用 async（第 14 讲）来启动服务循环：</p>
<p>auto fu1 = std::async(std::launch::async, recv_cycle);<br>
fu1.wait();</p>
<p>现在我们就能够接收客户端发过来的数据，开始统计了。</p>
<h2 id="数据外发线程">数据外发线程</h2>
<p>recv_cycle 是接收前端发来的数据，我们还需要一个线程把统计数据外发出去。同样，我实现一个 lambda 表达式：log_cycle。</p>
<p>它采用了 HTTP 协议，把数据打包成 JSON，发送到后台的某个 RESTful 服务器。</p>
<p>搭建符合要求的 Web 服务不是件小事，所以这里为了方便测试，我联动了一下《透视 HTTP 协议》，用那里的 OpenResty 写了个的 HTTP 接口：接收 POST 数据，然后打印到日志里，你可以参考第 41 讲在 Linux 上搭建这个后台服务。</p>
<p>log_cycle 其实就是一个简单的 HTTP 客户端，所以代码的处理逻辑比较好理解，要注意的知识点主要有三个，都是前面讲过的：</p>
<ol>
<li>读取 Lua 配置中的 HTTP 服务器地址和周期运行时间（第 17 讲）；</li>
<li>JSON 序列化数据（第 15 讲）；</li>
<li>HTTP 客户端发送请求（第 16 讲）。</li>
</ol>
<p>你如果有点忘了，可以回顾一下，再结合下面的代码来理解、学习：</p>
<p>auto log_cycle = <a href="">&amp;</a>              // 外发循环 lambda 表达式<br>
{<br>
// 获取 Lua 配置文件里的配置项<br>
auto http_addr = conf.get<string>(&ldquo;config.http_addr&rdquo;);<br>
auto time_interval = conf.get<int>(&ldquo;config.time_interval&rdquo;);</p>
<p>for(;;) {                        // 无限循环<br>
std::this_thread::sleep_for(time_interval * 1s);  // 线程睡眠等待</p>
<pre><code>json_t j;                        // JSON 序列化数据  
j[&quot;count&quot;] = static_cast&lt;int&gt;(count);  
j[&quot;minmax&quot;] = sum.minmax_sales();  

auto res = cpr::Post(            // 发送 HTTP POST 请求  
           cpr::Url{http_addr},  
           cpr::Body{j.dump()},  
           cpr::Timeout{200ms}  // 设置超时时间  
);  

if (res.status_code != 200) {    // 检查返回的状态码  
    cerr &lt;&lt; &quot;http post failed&quot; &lt;&lt; endl;  
}  
</code></pre>
<p>}                                   // for(;;)<br>
};                                    // log_cycle lambda</p>
<p>然后，还是要在主线程里用 async() 函数来启动这个 lambda 表达式，让它在后台定时上报数据。</p>
<p>auto fu2 = std::async(std::launch::async, log_cycle);</p>
<p>这样，整个书店程序就全部完成了，试着去编译运行一下看看吧。</p>
<h2 id="小结">小结</h2>
<p>好了，今天我就把书店示例程序从头到尾给讲完了。可以看到，代码里面应用了很多我们之前讲的 C++ 特性，这些特性互相重叠、嵌套，紧凑地集成在了这个不是很大的程序里，代码整齐，逻辑清楚，很容易就实现了多线程、高性能的服务端程序，开发效率和运行效率都非常高。</p>
<p>我再对今天代码里的要点做个简单的小结：</p>
<ol>
<li>编写类的时候要用好 final、default、using、const 等关键字，从代码细节着手提高效率和安全性；</li>
<li>对于中小型项目，序列化格式可以选择小巧高效的 MessagePack；</li>
<li>在存储数据时，应当选择恰当的容器，有序容器在插入元素时会自动排序，但注意排序的依据只能是 Key；</li>
<li>在使用 lambda 表达式的时候，要特别注意捕获变量的生命周期，如果是在线程里异步执行，应当尽量用智能指针的值捕获，虽然有点麻烦，但比较安全。</li>
</ol>
<p>那么，这些代码是否对你的工作有一些启迪呢？你是否能够把这些知识点成功地应用到实际项目里呢？希望你能多学习我在课程里给你分享的开发技巧和经验建议，熟练地掌握它们，写出媲美甚至超越示例代码的 C++ 程序。</p>
<h2 id="课下作业">课下作业</h2>
<p>最后是课下作业时间，这次就不是思考题，全是动手题，是时候检验你的编码实战能力了：</p>
<ol>
<li>添加 try-catch，处理可能发生的异常（第 9 讲）；</li>
<li>写一个动态库，用 Lua/Python 调用 C++ 发送请求，以脚本的方式简化客户端测试（第 17 讲）；</li>
<li>把前端与服务器的数据交换格式改成 JSON 或者 ProtoBuf（第 15 讲），然后用工厂类封装序列化和反序列化功能，隔离接口（第 19 讲、第 20 讲）。</li>
</ol>
<p>再补充一点，在动手实践的过程中，你还可以顺便练习一下 Git 的版本管理：不要直接在 master 分支上开发，而是开几个不同的 feature 分支，测试完确认没有问题后，再合并到主干上。</p>
<p>欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84C++%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/dc438274c7031b658d169495568d0558.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/">罗剑锋的C&#43;&#43;实战笔记</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/22__%E6%94%AF%E4%BB%98%E8%AE%A2%E5%8D%95%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%A7%A3%E5%86%B3for%E5%BE%AA%E7%8E%AF%E4%BA%A7%E7%94%9F%E7%9A%84%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">22__支付订单信息：如何高效解决for循环产生的内存溢出？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/22__%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%B6%E6%9E%84%E5%BB%BA%E8%AE%AE/">
            <span class="next-text nav-default">22__桌面程序的架构建议</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
