<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>05__面向对象编程：怎样才能写出一个“好”的类？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是 Chrono。
如果按照前几节课的惯例，今天应该是讲运行阶段的。但是，运行阶段跟前面的编码、预处理和编译阶段不同，它是动态的、实时的，内外部环境非常复杂，CPU、内存、磁盘、信号、网络套接字……各种资源交织在一起，可谓千变万化（正如我在第 1 节课里所说，每一个阶段的差异都非常大）。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/05__%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E7%B1%BB/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/05__%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E7%B1%BB/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="05__面向对象编程：怎样才能写出一个“好”的类？">
  <meta property="og:description" content="你好，我是 Chrono。
如果按照前几节课的惯例，今天应该是讲运行阶段的。但是，运行阶段跟前面的编码、预处理和编译阶段不同，它是动态的、实时的，内外部环境非常复杂，CPU、内存、磁盘、信号、网络套接字……各种资源交织在一起，可谓千变万化（正如我在第 1 节课里所说，每一个阶段的差异都非常大）。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="罗剑锋的C&#43;&#43;实战笔记">

  <meta itemprop="name" content="05__面向对象编程：怎样才能写出一个“好”的类？">
  <meta itemprop="description" content="你好，我是 Chrono。
如果按照前几节课的惯例，今天应该是讲运行阶段的。但是，运行阶段跟前面的编码、预处理和编译阶段不同，它是动态的、实时的，内外部环境非常复杂，CPU、内存、磁盘、信号、网络套接字……各种资源交织在一起，可谓千变万化（正如我在第 1 节课里所说，每一个阶段的差异都非常大）。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4812">
  <meta itemprop="keywords" content="罗剑锋的C&#43;&#43;实战笔记">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="05__面向对象编程：怎样才能写出一个“好”的类？">
  <meta name="twitter:description" content="你好，我是 Chrono。
如果按照前几节课的惯例，今天应该是讲运行阶段的。但是，运行阶段跟前面的编码、预处理和编译阶段不同，它是动态的、实时的，内外部环境非常复杂，CPU、内存、磁盘、信号、网络套接字……各种资源交织在一起，可谓千变万化（正如我在第 1 节课里所说，每一个阶段的差异都非常大）。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">05__面向对象编程：怎样才能写出一个“好”的类？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4812 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#设计思想">设计思想</a></li>
        <li><a href="#实现原则">实现原则</a></li>
        <li><a href="#编码准则">编码准则</a></li>
        <li><a href="#常用技巧">常用技巧</a></li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#课下作业">课下作业</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是 Chrono。</p>
<p>如果按照前几节课的惯例，今天应该是讲运行阶段的。但是，运行阶段跟前面的编码、预处理和编译阶段不同，它是动态的、实时的，内外部环境非常复杂，CPU、内存、磁盘、信号、网络套接字……各种资源交织在一起，可谓千变万化（正如我在第 1 节课里所说，每一个阶段的差异都非常大）。</p>
<p>解决这个阶段面临的问题已经不是编程技术了，更多的是要依靠各种调试、分析、日志工具，比如 GDB、Valgrind、Systemtap 等。</p>
<p>所以，我觉得把这些运行阶段的工具、技巧放在课程前面不是太合适，咱们还是往后延一延，等把 C++ 的核心知识点都学完了，再来看它比较好。</p>
<p>那么，今天要和你聊哪些内容呢？</p>
<p>我想了想，还是讲讲“面向对象编程”（Object Oriented Programming）吧。毕竟，它是 C++ 诞生之初“安身立命”的看家本领，也是 C++ 的核心编程范式。</p>
<p>不管我们是否喜欢，“面向对象”早就已经成为了编程界的共识和主流。C++、Java、Python 等流行的语言，无一不支持面向对象编程，而像 Pascal、BASIC、PHP 那样早期面向过程的语言，在发展过程中也都增加了对它的支持，新出的 Go、Swift、Rust 就更不用说了。</p>
<p>毫无疑问，<strong>掌握“面向对象编程”是现在程序员的基本素养</strong>。但落到实际开发时，每个人对它的理解程度却有深有浅，应用的水平也有高有低，有的人设计出的类精致灵活，而有的人设计出来的却是粗糙笨重。</p>
<p>细想起来，“面向对象”里面可以研究的地方实在是太多了。那么，到底“面向对象”的精髓是什么？怎样才能用好它？怎样才能写出一个称得上是“好”的类呢？</p>
<p>所以，今天我就从设计思想、实现原则和编码准则这几个角度谈谈我对它的体会心得，以及在 C++ 里应用的一些经验技巧，帮你写出更高效、更安全、更灵活的类。（在第 19、20 课，我还会具体讲解，到时候你可以参考下。）</p>
<h2 id="设计思想">设计思想</h2>
<p>首先要说的是，虽然很多语言都内建语法支持面向对象编程，但它本质上是一种设计思想、方法，与语言细节无关，要点是<strong>抽象</strong>（Abstraction）和<strong>封装</strong>（Encapsulation）。</p>
<p>掌握了这种代码之外的思考方式，就可以“高屋建瓴”，站在更高的维度上去设计程序，不会被语言、语法所限制。</p>
<p>所以，即使是像 C 这样“纯”面向过程的编程语言，也能够应用面向对象的思想，以 struct 实现抽象和封装，得到良好的程序结构。</p>
<p>面向对象编程的基本出发点是“对现实世界的模拟”，把问题中的实体抽象出来，封装为程序里的类和对象，这样就在计算机里为现实问题建立了一个“虚拟模型”。</p>
<p>然后以这个模型为基础不断演化，继续抽象对象之间的关系和通信，再用更多的对象去描述、模拟……直到最后，就形成了一个由许多互相联系的对象构成的系统。</p>
<p>把这个系统设计出来、用代码实现出来，就是“面向对象编程”了。</p>
<p>不过，因为现实世界非常复杂，“面向对象编程”作为一种工程方法，是不可能完美模拟的，纯粹的面向对象也有一些缺陷，其中最明显的就是“继承”。</p>
<p>“继承”的本意是重用代码，表述类型的从属关系（Is-A），但它却不能与现实完全对应，所以用起来就会出现很多意外情况。</p>
<p>比如那个著名的长方形的例子。Rectangle 表示长方形，Square 继承 Rectangle，表示正方形。现在问题就来了，这个关系在数学中是正确的，但表示为代码却不太正确。长方形可以用成员函数单独变更长宽，但正方形却不行，长和宽必须同时变更。</p>
<p>还有那个同样著名的鸟类的例子。基类 Bird 有个 Fly 方法，所有的鸟类都应该继承它。但企鹅、鸵鸟这样的鸟类却不会飞，实现它们就必须改写 Fly 方法。</p>
<p>各种编程语言为此都加上了一些“补丁”，像 C++ 就有“多态”“虚函数”“重载”，虽然解决了“继承”的问题，但也使代码复杂化了，一定程度上扭曲了“面向对象”的本意。</p>
<h2 id="实现原则">实现原则</h2>
<p>说了些“高大上”的理论，是不是有点犯迷糊？没关系，下面，我就在 C++ 里细化一下。</p>
<p>就像我刚才说的，“面向对象编程”的关键点是“抽象”和“封装”，而“继承”“多态”并不是核心，只能算是附加品。</p>
<p>所以，我建议你在设计类的时候<strong>尽量少用继承和虚函数</strong>。</p>
<p>特别的，如果完全没有继承关系，就可以让对象不必承受“父辈的重担”（父类成员、虚表等额外开销），轻装前行，更小更快。没有隐含的重用代码也会降低耦合度，让类更独立，更容易理解。</p>
<p>还有，把“继承”切割出去之后，可以避免去记忆、实施那一大堆难懂的相关规则，比如 public/protected/private 继承方式的区别、多重继承、纯虚接口类、虚析构函数，还可以绕过动态转型、对象切片、函数重载等很多危险的陷阱，减少冗余代码，提高代码的健壮性。</p>
<p>如果非要用继承不可，那么我觉得一定要<strong>控制继承的层次</strong>，用 UML 画个类体系的示意图来辅助检查。如果继承深度超过三层，就说明有点“过度设计”了，需要考虑用组合关系替代继承关系，或者改用模板和泛型。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84C++%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/292d2cd603d348a0b17a99b1cbe086b4.png" alt=""></p>
<p>在设计类接口的时候，我们也要让类尽量简单、“短小精悍”，<strong>只负责单一的功能</strong>。</p>
<p>如果很多功能混在了一起，出现了“万能类”“意大利面条类”（有时候也叫 God Class），就要应用设计模式、重构等知识，把大类拆分成多个各负其责的小类。</p>
<p>我还看到过很多人有一种不好的习惯，就是喜欢在类内部定义一些嵌套类，美其名曰“高内聚”。但恰恰相反，这些内部类反而与上级类形成了强耦合关系，也是另一种形式的“万能类”。</p>
<p>其实，这本来是名字空间该做的事情，用类来实现就有点“越权”了。正确的做法应该是，<strong>定义一个新的名字空间，把内部类都“提”到外面，降低原来类的耦合度和复杂度</strong>。</p>
<h2 id="编码准则">编码准则</h2>
<p>有了这些实现原则，下面我再来讲几个编码时的细节，从安全和性能方面帮你改善类的代码。</p>
<p>C++11 新增了一个特殊的标识符“<strong>final</strong>”（注意，它不是关键字），把它用于类定义，就可以显式地禁用继承，防止其他人有意或者无意地产生派生类。无论是对人还是对编译器，效果都非常好，我建议你一定要积极使用。</p>
<p>class DemoClass final    // 禁止任何人继承我<br>
{ &hellip; };</p>
<p>在必须使用继承的场合，建议你<strong>只使用 public 继承，避免使用 virtual、protected</strong>，因为它们会让父类与子类的关系变得难以捉摸，带来很多麻烦。当到达继承体系底层时，也要及时使用“final”，终止继承关系。</p>
<p>class Interface        // 接口类定义，没有 final，可以被继承<br>
{ &hellip; };</p>
<p>class Implement final : // 实现类，final 禁止再被继承<br>
public Interface    // 只用 public 继承<br>
{ &hellip; };</p>
<p>C++ 里类的四大函数你一定知道吧，它们是构造函数、析构函数、拷贝构造函数、拷贝赋值函数。C++11 因为引入了右值（Rvalue）和转移（Move），又多出了两大函数：<strong>转移构造函数</strong>和<strong>转移赋值函数</strong>。所以，在现代 C++ 里，一个类总是会有六大基本函数：<strong>三个构造</strong>、<strong>两个赋值</strong>、<strong>一个析构</strong>。</p>
<p>好在 C++ 编译器会自动为我们生成这些函数的默认实现，省去我们重复编写的时间和精力。但我建议，对于比较重要的构造函数和析构函数，应该用“<strong>= default</strong>”的形式，明确地告诉编译器（和代码阅读者）：“应该实现这个函数，但我不想自己写。”这样编译器就得到了明确的指示，可以做更好的优化。</p>
<p>class DemoClass final<br>
{<br>
public:<br>
DemoClass() = default;  // 明确告诉编译器，使用默认实现<br>
~DemoClass() = default;  // 明确告诉编译器，使用默认实现<br>
};</p>
<p>这种“= default”是 C++11 新增的专门用于六大基本函数的用法，相似的，还有一种“<strong>= delete</strong>”的形式。它表示<strong>明确地禁用某个函数形式</strong>，而且不限于构造 / 析构，可以用于任何函数（成员函数、自由函数）。</p>
<p>比如说，如果你想要禁止对象拷贝，就可以用这种语法显式地把拷贝构造和拷贝赋值“delete”掉，让外界无法调用。</p>
<p>class DemoClass final<br>
{<br>
public:<br>
DemoClass(const DemoClass&amp;) = delete;              // 禁止拷贝构造<br>
DemoClass&amp; operator=(const DemoClass&amp;) = delete;  // 禁止拷贝赋值<br>
};</p>
<p>因为 C++ 有隐式构造和隐式转型的规则，如果你的类里有单参数的构造函数，或者是转型操作符函数，为了防止意外的类型转换，保证安全，就要使用“<strong>explicit</strong>”将这些函数标记为“显式”。</p>
<p>class DemoClass final<br>
{<br>
public:<br>
explicit DemoClass(const string_type&amp; str)  // 显式单参构造函数<br>
{ &hellip; }</p>
<pre><code>explicit operator bool()                  // 显式转型为 bool  
{ ... }  
</code></pre>
<p>};</p>
<h2 id="常用技巧">常用技巧</h2>
<p>C++11 里还有很多能够让类更优雅的新特性，这里我从“投入产出比”的角度出发，挑出了三个我最喜欢的特性，给你介绍一下，让你不用花太多力气就能很好地改善代码质量。</p>
<p>第一个是“<strong>委托构造</strong>”（delegating constructor）。</p>
<p>如果你的类有多个不同形式的构造函数，为了初始化成员肯定会有大量的重复代码。为了避免重复，常见的做法是把公共的部分提取出来，放到一个 init() 函数里，然后构造函数再去调用。这种方法虽然可行，但<strong>效率和可读性较差</strong>，毕竟 init() 不是真正的构造函数。</p>
<p>在 C++11 里，你就可以使用“委托构造”的新特性，一个构造函数直接调用另一个构造函数，把构造工作“委托”出去，既简单又高效。</p>
<p>class DemoDelegating final<br>
{<br>
private:<br>
int a;                              // 成员变量<br>
public:<br>
DemoDelegating(int x) : a(x)        // 基本的构造函数<br>
{}</p>
<pre><code>DemoDelegating() :                 // 无参数的构造函数  
    DemoDelegating(0)               // 给出默认值，委托给第一个构造函数  
{}    

DemoDelegating(const string&amp; s) : // 字符串参数构造函数  
    DemoDelegating(stoi(s))        // 转换成整数，再委托给第一个构造函数  
{}    
</code></pre>
<p>};</p>
<p>第二个是“<strong>成员变量初始化</strong>”（In-class member initializer）。</p>
<p>如果你的类有很多成员变量，那么在写构造函数的时候就比较麻烦，必须写出一长串的名字来逐个初始化，不仅不美观，更危险的是，容易“手抖”，遗漏成员，造成未初始化的隐患。</p>
<p>而在 C++11 里，你可以在类里声明变量的同时给它赋值，实现初始化，这样<strong>不但简单清晰，也消除了隐患。</strong></p>
<p>class DemoInit final                  // 有很多成员变量的类<br>
{<br>
private:<br>
int                 a = 0;        // 整数成员，赋值初始化<br>
string              s = &ldquo;hello&rdquo;;  // 字符串成员，赋值初始化<br>
vector<int>         v{1, 2, 3};   // 容器成员，使用花括号的初始化列表<br>
public:<br>
DemoInit() = default;             // 默认构造函数<br>
~DemoInit() = default;             // 默认析构函数<br>
public:<br>
DemoInit(int x) : a(x) {}         // 可以单独初始化成员，其他用默认值<br>
};</p>
<p>第三个是“<strong>类型别名</strong>”（Type Alias）。</p>
<p>C++11 扩展了关键字 using 的用法，增加了 typedef 的能力，可以定义类型别名。它的格式与 typedef 正好相反，别名在左边，原名在右边，是标准的赋值形式，所以易写易读。</p>
<p>using uint_t = unsigned int;        // using 别名<br>
typedef unsigned int uint_t；      // 等价的 typedef</p>
<p>在写类的时候，我们经常会用到很多外部类型，比如标准库里的 string、vector，还有其他的第三方库和自定义类型。这些名字通常都很长（特别是带上名字空间、模板参数），书写起来很不方便，这个时候我们就可以在类里面用 using 给它们起别名，不仅简化了名字，同时还能增强可读性。</p>
<p>class DemoClass final<br>
{<br>
public:<br>
using this_type         = DemoClass;          // 给自己也起个别名<br>
using kafka_conf_type   = KafkaConfig;        // 外部类起别名</p>
<p>public:<br>
using string_type   = std::string;            // 字符串类型别名<br>
using uint32_type   = uint32_t;              // 整数类型别名</p>
<pre><code>using set_type      = std::set&lt;int&gt;;          // 集合类型别名  
using vector_type   = std::vector&lt;std::string&gt;;// 容器类型别名  
</code></pre>
<p>private:<br>
string_type     m_name  = &ldquo;tom&rdquo;;              // 使用类型别名声明变量<br>
uint32_type     m_age   = 23;                  // 使用类型别名声明变量<br>
set_type        m_books;                      // 使用类型别名声明变量</p>
<p>private:<br>
kafka_conf_type m_conf;                       // 使用类型别名声明变量<br>
};</p>
<p>类型别名不仅能够让代码规范整齐，而且因为引入了这个“语法层面的宏定义”，将来在维护时还可以随意改换成其他的类型。比如，把字符串改成 string_view（C++17 里的字符串只读视图），把集合类型改成 unordered_set，只要变动别名定义就行了，原代码不需要做任何改动。</p>
<h2 id="小结">小结</h2>
<p>今天我们谈了“面向对象编程”，这节课的内容也比较多，我划一下重点。</p>
<ol>
<li>“面向对象编程”是一种设计思想，要点是“抽象”和“封装”，“继承”“多态”是衍生出的特性，不完全符合现实世界。</li>
<li>在 C++ 里应当少用继承和虚函数，降低对象的成本，绕过那些难懂易错的陷阱。</li>
<li>使用特殊标识符“final”可以禁止类被继承，简化类的层次关系。</li>
<li>类有六大基本函数，对于重要的构造 / 析构函数，可以使用“= default”来显式要求编译器使用默认实现。</li>
<li>“委托构造”和“成员变量初始化”特性可以让创建对象的工作更加轻松。</li>
<li>使用 using 或 typedef 可以为类型起别名，既能够简化代码，还能够适应将来的变化。</li>
</ol>
<p>所谓“仁者见仁智者见智”，今天我讲的也只能算是我自己的经验、体会。到底要怎么用，你还是要看自己的实际情况，千万不要完全照搬。</p>
<h2 id="课下作业">课下作业</h2>
<p>这次的课下作业时间，我给你留两个思考题：</p>
<ol>
<li>你对“面向对象编程”有哪些认识，是否赞同这节课的观点？（希望你大胆地说出来，如果意见有分歧，那也很正常，我们一起讨论。）</li>
<li>你觉得应用这节课讲到的准则和技巧能否写出一个“好”的类，还缺什么吗？</li>
</ol>
<p>欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84C++%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/357e4b69597dfef228bba8fa61b291fd.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/">罗剑锋的C&#43;&#43;实战笔记</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AF%B4%E9%80%8F%E5%8C%BA%E5%9D%97%E9%93%BE/05__%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AB%99%E5%9C%A8%E4%BA%86%E5%B7%A8%E4%BA%BA%E8%82%A9%E8%86%80%E4%B8%8A/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">05__密码学：为什么说区块链站在了巨人肩膀上？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%BE%8E/05__%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E5%88%B0%E5%BA%95%E6%98%AF%E6%83%B3%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/">
            <span class="next-text nav-default">05__敏捷开发到底是想解决什么问题？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
