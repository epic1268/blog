<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>10__lambda：函数式编程带来了什么？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是 Chrono。
在第 1 节课的时候，我就说到过“函数式编程”，但只是简单提了提，没有展开讲。
作为现代 C&#43;&#43; 里的五种基本编程范式之一，“函数式编程”的作用和地位正在不断上升，而且在其他语言里也非常流行，很有必要再深入研究一下。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/10__lambda%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%B8%A6%E6%9D%A5%E4%BA%86%E4%BB%80%E4%B9%88/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/10__lambda%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%B8%A6%E6%9D%A5%E4%BA%86%E4%BB%80%E4%B9%88/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="10__lambda：函数式编程带来了什么？">
  <meta property="og:description" content="你好，我是 Chrono。
在第 1 节课的时候，我就说到过“函数式编程”，但只是简单提了提，没有展开讲。
作为现代 C&#43;&#43; 里的五种基本编程范式之一，“函数式编程”的作用和地位正在不断上升，而且在其他语言里也非常流行，很有必要再深入研究一下。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="罗剑锋的C&#43;&#43;实战笔记">

  <meta itemprop="name" content="10__lambda：函数式编程带来了什么？">
  <meta itemprop="description" content="你好，我是 Chrono。
在第 1 节课的时候，我就说到过“函数式编程”，但只是简单提了提，没有展开讲。
作为现代 C&#43;&#43; 里的五种基本编程范式之一，“函数式编程”的作用和地位正在不断上升，而且在其他语言里也非常流行，很有必要再深入研究一下。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4672">
  <meta itemprop="keywords" content="罗剑锋的C&#43;&#43;实战笔记">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="10__lambda：函数式编程带来了什么？">
  <meta name="twitter:description" content="你好，我是 Chrono。
在第 1 节课的时候，我就说到过“函数式编程”，但只是简单提了提，没有展开讲。
作为现代 C&#43;&#43; 里的五种基本编程范式之一，“函数式编程”的作用和地位正在不断上升，而且在其他语言里也非常流行，很有必要再深入研究一下。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">10__lambda：函数式编程带来了什么？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4672 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#c-函数的特殊性">C++ 函数的特殊性</a></li>
        <li><a href="#认识-lambda">认识 lambda</a></li>
        <li><a href="#使用-lambda-的注意事项">使用 lambda 的注意事项</a></li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#课下作业">课下作业</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是 Chrono。</p>
<p>在第 1 节课的时候，我就说到过“函数式编程”，但只是简单提了提，没有展开讲。</p>
<p>作为现代 C++ 里的五种基本编程范式之一，“函数式编程”的作用和地位正在不断上升，而且在其他语言里也非常流行，很有必要再深入研究一下。</p>
<p>掌握了函数式编程，你就又多了一件“趁手的兵器”，可以更好地运用标准库里的容器和算法，写出更灵活、紧凑、优雅的代码。</p>
<p>所以，今天我就和你聊聊函数式编程，看看它给 C++ 带来了什么。</p>
<h2 id="c-函数的特殊性">C++ 函数的特殊性</h2>
<p>说到“函数式编程”，那肯定就要先从函数（function）说起。</p>
<p>C++ 里的函数概念来源于 C，是面向过程编程范式的基本部件。但严格来说，它其实应该叫“子过程”（sub-procedure）、“子例程”（sub-routine），是命令的集合、操作步骤的抽象。</p>
<p>函数的目的是封装执行的细节，简化程序的复杂度，但因为它有入口参数，有返回值，形式上和数学里的函数很像，所以就被称为“函数”。</p>
<p>在语法层面上，C/C++ 里的函数是比较特别的。虽然有函数类型，但不存在对应类型的变量，不能直接操作，只能用指针去间接操作（即函数指针），这让函数在类型体系里显得有点“格格不入”。</p>
<p>函数在用法上也有一些特殊之处。在 C/C++ 里，所有的函数都是全局的，没有生存周期的概念（static、名字空间的作用很弱，只是简单限制了应用范围，避免名字冲突）。而且函数也都是平级的，不能在函数里再定义函数，也就是<strong>不允许定义嵌套函数、函数套函数</strong>。</p>
<p>void my_square(int x)           // 定义一个函数<br>
{<br>
cout &laquo; x*x &laquo; endl;       // 函数的具体内容<br>
}</p>
<p>auto pfunc = &amp;my_square;       // 只能用指针去操作函数，指针不是函数<br>
(<em>pfunc)(3);                    // 可以用</em>访问函数<br>
pfunc(3);                       // 也可以直接调用函数指针</p>
<p>所以，在面向过程编程范式里，函数和变量虽然是程序里最关键的两个组成部分，但却因为没有值、没有作用域而不能一致地处理。函数只能是函数，变量只能是变量，彼此之间虽不能说是“势同水火”，但至少是“泾渭分明”。</p>
<h2 id="认识-lambda">认识 lambda</h2>
<p>好了，搞清楚了函数，现在再来看看 C++11 引入的 lambda 表达式，下面是一个简单的例子：</p>
<p>auto func = <a href="./int_x.md"></a>          // 定义一个 lambda 表达式<br>
{  <br>
cout &laquo; x*x &laquo; endl;      // lambda 表达式的具体内容<br>
};</p>
<p>func(3);                      // 调用 lambda 表达式</p>
<p>暂时不考虑代码里面的语法细节，单从第一印象上，我们可以看到有一个函数，但更重要的，是这个函数采用了赋值的方式，存入了一个变量。</p>
<p>这就是 lambda 表达式与普通函数最大、也是最根本的区别。</p>
<p>因为 lambda 表达式是一个变量，所以，我们就可以“按需分配”，随时随地在调用点“<strong>就地</strong>”定义函数，限制它的作用域和生命周期，实现函数的局部化。</p>
<p>而且，因为 lambda 表达式和变量一样是“一等公民”，用起来也就更灵活自由，能对它做各种运算，生成新的函数。这就像是数学里的复合函数那样，把多个简单功能的小 lambda 表达式组合，变成一个复杂的大 lambda 表达式。</p>
<p>如果你比较熟悉 C++98，或者看过一些相关的资料，可能会觉得 lambda 表达式只不过是函数对象（function object）的一种简化形式，只是一个好用的“语法糖”（syntactic sugar）。</p>
<p>大道理上是没错的，但如果把它简单地等同于函数对象，认为它只是免去了手写函数对象的麻烦，那就实在是有点太“肤浅”了。</p>
<p>lambda 表达式为 C++ 带来的变化可以说是革命性的。虽然它表面上只是一个很小的改进，简化了函数的声明 / 定义，但深层次带来的编程理念的变化，却是非常巨大的。</p>
<p>这和 C++ 当初引入 bool、class、template 这些特性时有点类似，乍看上去好像只是一点点的语法改变，但后果却如同雪崩，促使人们更多地去思考、探索新的编程方向，而 lambda 引出的全新思维方式就是“函数式编程”——把写计算机程序看作是数学意义上的求解函数。</p>
<p>C++ 里的 lambda 表达式除了可以像普通函数那样被调用，还有一个普通函数所不具备的特殊本领，就是可以**“捕获”外部变量**，在内部的代码里直接操作。</p>
<p>int n = 10;                     // 一个外部变量</p>
<p>auto func = <a href="./int_x.md">=</a>          // lambda 表达式，用“=”值捕获<br>
{<br>
cout &laquo; x*n &laquo; endl;        // 直接操作外部变量<br>
};</p>
<p>func(3);                    // 调用 lambda 表达式</p>
<p>看到这里，如果你用过 JavaScript，那么一定会有种眼熟的感觉。没错，lambda 表达式就是在其他语言中大名鼎鼎的“<strong>闭包</strong>”（closure），这让它真正超越了函数和函数对象。</p>
<p>“闭包”是什么，很难一下子说清楚，我就不详细解释了。说得形象一点，你可以把闭包理解为一个“活的代码块”“活的函数”。它虽然在出现时被定义，但因为保存了定义时捕获的外部变量，就可以跳离定义点，把这段代码“打包”传递到其他地方去执行，而仅凭函数的入口参数是无法做到这一点的。</p>
<p>这就导致函数式编程与命令式编程（即面向过程）在结构上有很大不同，程序流程不再是按步骤执行的“死程序”，而是一个个的“活函数”，像做数学题那样逐步计算、推导出结果，有点像下面的这样：</p>
<p>auto a = <a href="./int_x.md"></a>      // a 函数执行一个功能<br>
{&hellip;}<br>
auto b = <a href="./double_x.md"></a>    // b 函数执行一个功能<br>
{&hellip;}<br>
auto c = <a href="./string_str.md"></a>  // c 函数执行一个功能<br>
{&hellip;}</p>
<p>auto f = <a href="./....md"></a>        // f 函数执行一个功能<br>
{&hellip;}</p>
<p>return f(a, b, c)            // f 调用 a/b/c 运算得到结果</p>
<p>你也可以再对比面向对象来理解。在面向对象编程里，程序是由一个个实体对象组成的，对象通信完成任务。而在函数式编程里，程序是由一个个函数组成的，函数互相嵌套、组合、调用完成任务。</p>
<p>不过，毕竟函数式编程在 C++ 里是一种较新的编程范式，而且面向过程里的函数概念“根深蒂固”，我说了这么多，你可能还是不太能领会它的奥妙，这也很正常。</p>
<p>下面我就来讲讲 lambda 表达式的使用细节，掌握了以后多用，就能够更好地理解了。</p>
<h2 id="使用-lambda-的注意事项">使用 lambda 的注意事项</h2>
<p>要学好用好 lambda，我觉得就是三个重点：语法形式，变量捕获规则，还有泛型的用法。</p>
<p><strong>1.lambda 的形式</strong></p>
<p>首先你要知道，C++ 没有为 lambda 表达式引入新的关键字，并没有“lambda”这样的词汇，而是用了一个特殊的形式“<strong>[]</strong>”，术语叫“<strong>lambda 引出符</strong>”（lambda introducer）。</p>
<p>在 lambda 引出符后面，就可以像普通函数那样，用圆括号声明入口参数，用花括号定义函数体。</p>
<p>下面的代码展示了我最喜欢的一个 lambda 表达式（也是最简单的）：</p>
<p>auto f1 = <a href=""></a>{};      // 相当于空函数，什么也不做</p>
<p>这行语句定义了一个相当于空函数的 lambda 表达式，三个括号“排排坐”，看起来有种奇特的美感，让人不由得想起那句经典台词：“一家人最要紧的就是整整齐齐。”（不过还是差了个尖括号 &lt;&gt;）。</p>
<p>当然了，实际开发中不会有这么简单的 lambda 表达式，它的函数体里可能会有很多语句，所以一定<strong>要有良好的缩进格式</strong>——特别是有嵌套定义的时候，尽量让人能够一眼就看出 lambda 表达式的开始和结束，必要的时候可以用注释来强调。</p>
<p>auto f2 = <a href=""></a>                 // 定义一个 lambda 表达式<br>
{<br>
cout &laquo; &ldquo;lambda f2&rdquo; &laquo; endl;</p>
<pre><code>auto f3 = [](./int_x.md)         // 嵌套定义 lambda 表达式  
{  
    return x*x;  
};// lambda f3              // 使用注释显式说明表达式结束  

cout &lt;&lt; f3(10) &lt;&lt; endl;  
</code></pre>
<p>};  // lambda f2               // 使用注释显式说明表达式结束</p>
<p>你可能注意到了，在 lambda 表达式赋值的时候，我总是使用 auto 来推导类型。这是因为，在 C++ 里，每个 lambda 表达式都会有一个独特的类型，而这个类型只有编译器才知道，我们是无法直接写出来的，所以必须用 auto。</p>
<p>不过，因为 lambda 表达式毕竟不是普通的变量，所以 C++ 也鼓励程序员<strong>尽量“匿名”使用 lambda 表达式</strong>。也就是说，它不必显式赋值给一个有名字的变量，直接声明就能用，免去你费力起名的烦恼。</p>
<p>这样不仅可以让代码更简洁，而且因为“匿名”，lambda 表达式调用完后也就不存在了（也有被拷贝保存的可能），这就最小化了它的影响范围，让代码更加安全。</p>
<p>vector<int> v = {3, 1, 8, 5, 0};     // 标准容器</p>
<p>cout &laquo; *find_if(begin(v), end(v),   // 标准库里的查找算法<br>
<a href="./int_x.md"></a>                // 匿名 lambda 表达式，不需要 auto 赋值<br>
{<br>
return x &gt;= 5;        // 用做算法的谓词判断条件<br>
}                        // lambda 表达式结束<br>
)<br>
&laquo; endl;                        // 语句执行完，lambda 表达式就不存在了</p>
<p><strong>2.lambda 的变量捕获</strong></p>
<p>lambda 的“捕获”功能需要在“[]”里做文章，由于实际的规则太多太细，记忆、理解的成本高，所以我只说几个要点，帮你快速掌握它们：</p>
<ol>
<li>“[=]”表示按值捕获所有外部变量，表达式内部是值的拷贝，并且不能修改；</li>
<li>“[&amp;]”是按引用捕获所有外部变量，内部以引用的方式使用，可以修改；</li>
<li>你也可以在“[]”里明确写出外部变量名，指定按值或者按引用捕获，C++ 在这里给予了非常大的灵活性。</li>
</ol>
<p>int x = 33;               // 一个外部变量</p>
<p>auto f1 = <a href="">=</a>           // lambda 表达式，用“=”按值捕获<br>
{<br>
//x += 10;            // x 只读，不允许修改<br>
};</p>
<p>auto f2 = <a href="">&amp;</a>         // lambda 表达式，用“&amp;”按引用捕获<br>
{<br>
x += 10;            // x 是引用，可以修改<br>
};</p>
<p>auto f3 = <a href="">=, &amp;x</a>       // lambda 表达式，用“&amp;”按引用捕获 x，其他的按值捕获<br>
{<br>
x += 20;              // x 是引用，可以修改<br>
};</p>
<p>“捕获”也是使用 lambda 表达式的一个难点，关键是要理解“<strong>外部变量</strong>”的含义。</p>
<p>我建议，你可以简单地按照其他语言的习惯，称之为“<strong>upvalue</strong>”，也就是在 lambda 表达式定义之前所有出现的变量，不管它是局部的还是全局的。</p>
<p>这就有一个变量生命周期的问题。</p>
<p>使用“[=]”按值捕获的时候，lambda 表达式使用的是变量的独立副本，非常安全。而使用“[&amp;]”的方式捕获引用就存在风险，当 lambda 表达式在离定义点“很远的地方”被调用的时候，引用的变量可能发生了变化，甚至可能会失效，导致难以预料的后果。</p>
<p>所以，我建议你在使用捕获功能的时候要小心，对于“就地”使用的小 lambda 表达式，可以用“[&amp;]”来减少代码量，保持整洁；而对于非本地调用、生命周期较长的 lambda 表达式应慎用“[&amp;]”捕获引用，而且，最好是在“[]”里显式写出变量列表，避免捕获不必要的变量。</p>
<p>class DemoLambda final<br>
{<br>
private:<br>
int x = 0;<br>
public:<br>
auto print()              // 返回一个 lambda 表达式供外部使用<br>
{<br>
return <a href="">this</a>      // 显式捕获 this 指针<br>
{<br>
cout &laquo; &ldquo;member = &quot; &laquo; x &laquo; endl;<br>
};<br>
}<br>
};</p>
<p><strong>3. 泛型的 lambda</strong></p>
<p>在 C++14 里，lambda 表达式又多了一项新本领，可以实现“<strong>泛型化</strong>”，相当于简化了的模板函数，具体语法还是利用了“多才多艺”的 auto：</p>
<p>auto f = <a href="./const_auto&amp;_x.md"></a>        // 参数使用 auto 声明，泛型化<br>
{<br>
return x + x;<br>
};</p>
<p>cout &laquo; f(3) &laquo; endl;             // 参数类型是 int<br>
cout &laquo; f(0.618) &laquo; endl;         // 参数类型是 double</p>
<p>string str = &ldquo;matrix&rdquo;;<br>
cout &laquo; f(str) &laquo; endl;          // 参数类型是 string</p>
<p>这个新特性在写泛型函数的时候非常方便，摆脱了冗长的模板参数和函数参数列表。如果你愿意的话，可以尝试在今后的代码里都使用 lambda 来代替普通函数，能够少写很多代码。</p>
<h2 id="小结">小结</h2>
<p>今天我讲了 lambda 表达式。它不仅仅是对旧有函数对象的简单升级，而是更高级的“闭包”，给 C++ 带来了新的编程理念：函数式编程范式。</p>
<p>在 C 语言里，函数是一个“静止”的代码块，只能被动地接受输入然后输出。而 lambda 的出现则让函数“活”了起来，极大地提升了函数的地位和灵活性。</p>
<p>比照“智能指针”的说法，lambda 完全可以称为是“智能函数”，价值体现在就地定义、变量捕获等能力上，它也给 C++ 的算法、并发（线程、协程）等后续发展方向铺平了道路，在后面讲标准库的时候，我们还会多次遇到它。</p>
<p>虽然目前在 C++ 里，纯函数式编程还比较少见，但“轻度”使用 lambda 表达式也能够改善代码，比如用“map+lambda”的方式来替换难以维护的 if/else/switch，可读性要比大量的分支语句好得多。</p>
<p>小结一下今天的要点内容：</p>
<ol>
<li>lambda 表达式是一个闭包，能够像函数一样被调用，像变量一样被传递；</li>
<li>可以使用 auto 自动推导类型存储 lambda 表达式，但 C++ 鼓励尽量就地匿名使用，缩小作用域；</li>
<li>lambda 表达式使用“[=]”的方式按值捕获，使用“[&amp;]”的方式按引用捕获，空的“[]”则是无捕获（也就相当于普通函数）；</li>
<li>捕获引用时必须要注意外部变量的生命周期，防止变量失效；</li>
<li>C++14 里可以使用泛型的 lambda 表达式，相当于简化的模板函数。</li>
</ol>
<p>末了我再说一句，和 C++ 里的大多数新特性一样，滥用 lambda 表达式的话，就会产生一些难以阅读的代码，比如多个函数的嵌套和串联、调用层次过深。这也需要你在实践中慢慢积累经验，找到最适合你自己的使用方式。</p>
<h2 id="课下作业">课下作业</h2>
<p>最后是课下作业时间，给你留两个思考题吧：</p>
<ol>
<li>你对函数式编程有什么样的理解和认识呢？</li>
<li>lambda 表达式的形式非常简洁，可以在很多地方代替普通函数，那它能不能代替类的成员函数呢？为什么？</li>
</ol>
<p>欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84C++%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/22245e47349a12ed2e2a8661ccb74e10.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/">罗剑锋的C&#43;&#43;实战笔记</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes/10__kubernetes%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%88%A9%E5%99%A8kubeadm/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">10__Kubernetes一键部署利器：kubeadm</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/10__mvc%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90%E6%8E%A7%E5%88%B6%E5%99%A8controller%E7%AF%87/">
            <span class="next-text nav-default">10__MVC架构解析：控制器（Controller）篇</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
