<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>18__性能分析：找出程序的瓶颈 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是 Chrono。
今天是“技能进阶”单元的最后一节课，我也要兑现刚开始在“概论”里的承诺，讲一讲在运行阶段我们能做什么。
运行阶段能做什么 在编码阶段，你会运用之前学习的各种范式和技巧，写出优雅、高效的代码，然后把它交给编译器。经过预处理和编译这两个阶段，源码转换成了二进制的可执行程序，就能够在 CPU 上“跑”起来。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/18__%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%89%BE%E5%87%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%93%B6%E9%A2%88/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/18__%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%89%BE%E5%87%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%93%B6%E9%A2%88/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="18__性能分析：找出程序的瓶颈">
  <meta property="og:description" content="你好，我是 Chrono。
今天是“技能进阶”单元的最后一节课，我也要兑现刚开始在“概论”里的承诺，讲一讲在运行阶段我们能做什么。
运行阶段能做什么 在编码阶段，你会运用之前学习的各种范式和技巧，写出优雅、高效的代码，然后把它交给编译器。经过预处理和编译这两个阶段，源码转换成了二进制的可执行程序，就能够在 CPU 上“跑”起来。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="罗剑锋的C&#43;&#43;实战笔记">

  <meta itemprop="name" content="18__性能分析：找出程序的瓶颈">
  <meta itemprop="description" content="你好，我是 Chrono。
今天是“技能进阶”单元的最后一节课，我也要兑现刚开始在“概论”里的承诺，讲一讲在运行阶段我们能做什么。
运行阶段能做什么 在编码阶段，你会运用之前学习的各种范式和技巧，写出优雅、高效的代码，然后把它交给编译器。经过预处理和编译这两个阶段，源码转换成了二进制的可执行程序，就能够在 CPU 上“跑”起来。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4707">
  <meta itemprop="keywords" content="罗剑锋的C&#43;&#43;实战笔记">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="18__性能分析：找出程序的瓶颈">
  <meta name="twitter:description" content="你好，我是 Chrono。
今天是“技能进阶”单元的最后一节课，我也要兑现刚开始在“概论”里的承诺，讲一讲在运行阶段我们能做什么。
运行阶段能做什么 在编码阶段，你会运用之前学习的各种范式和技巧，写出优雅、高效的代码，然后把它交给编译器。经过预处理和编译这两个阶段，源码转换成了二进制的可执行程序，就能够在 CPU 上“跑”起来。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">18__性能分析：找出程序的瓶颈</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4707 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#运行阶段能做什么">运行阶段能做什么</a></li>
        <li><a href="#系统级工具">系统级工具</a></li>
        <li><a href="#源码级工具">源码级工具</a></li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#课下作业">课下作业</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是 Chrono。</p>
<p>今天是“技能进阶”单元的最后一节课，我也要兑现刚开始在“概论”里的承诺，讲一讲在运行阶段我们能做什么。</p>
<h2 id="运行阶段能做什么">运行阶段能做什么</h2>
<p>在编码阶段，你会运用之前学习的各种范式和技巧，写出优雅、高效的代码，然后把它交给编译器。经过预处理和编译这两个阶段，源码转换成了二进制的可执行程序，就能够在 CPU 上“跑”起来。</p>
<p>在运行阶段，C++ 静态程序变成了动态进程，是一个实时、复杂的状态机，由 CPU 全程掌控。但因为 CPU 的速度实在太快，程序的状态又实在太多，所以前几个阶段的思路、方法在这个时候都用不上。</p>
<p>所以，我认为，在运行阶段能做、应该做的事情主要有三件：<strong>调试</strong>（Debug）<strong>、测试</strong>（Test）<strong>和性能分析</strong>（Performance Profiling）。</p>
<p>调试你一定很熟悉了，常用的工具是 GDB，我在前面的“轻松话题”里也讲过一点它的使用技巧。它的关键是让高速的 CPU 慢下来，把它降速到和人类大脑一样的程度，于是，我们就可以跟得上 CPU 的节奏，理清楚程序的动态流程。</p>
<p>测试的目标是检验程序的功能和性能，保证软件的质量，它与调试是相辅相成的关系。测试发现 Bug，调试去解决 Bug，再返回给测试验证。好的测试对于软件的成功至关重要，有很多现成的测试理论、应用、系统（你可以参考下，我就不多说了）。</p>
<p>一般来说，程序经过调试和测试这两个步骤，就可以上线运行了，进入第三个、也是最难的性能分析阶段。</p>
<p>什么是性能分析呢？</p>
<p>你可以把它跟 Code Review 对比一下。Code Review 是一种静态的程序分析方法，在编码阶段通过观察源码来优化程序、找出隐藏的 Bug。而性能分析是一种动态的程序分析方法，在运行阶段采集程序的各种信息，再整合、研究，找出软件运行的“瓶颈”，为进一步优化性能提供依据，指明方向。</p>
<p>从这个粗略的定义里，你可以看到，性能分析的关键就是“<strong>测量</strong>”，用数据说话。没有实际数据的支撑，优化根本无从谈起，即使做了，也只能是漫无目的的“不成熟优化”，即使成功了，也只是“瞎猫碰上死耗子”而已。</p>
<p>性能分析的范围非常广，可以从 CPU 利用率、内存占用率、网络吞吐量、系统延迟等许多维度来评估。</p>
<p>今天，我只讲多数时候最看重的 CPU 性能分析。因为 CPU 利用率通常是评价程序运行的好坏最直观、最容易获取的指标，优化它是提升系统性能最快速的手段。而其他的几个维度也大多与 CPU 分析相关，可以达到“以点带面”的效果。</p>
<h2 id="系统级工具">系统级工具</h2>
<p>刚才也说了，性能分析的关键是测量，而测量就需要使用工具，那么，你该选什么、又该怎么用工具呢？</p>
<p>其实，Linux 系统自己就内置了很多用于性能分析的工具，比如 top、sar、vmstat、netstat，等等。但是，Linux 的性能分析工具太多、太杂，有点“乱花渐欲迷人眼”的感觉，想要学会并用在实际项目里，不狠下一番功夫是不行的。</p>
<p>所以，为了让你能够快速入门性能分析，我根据我这些年的经验，挑选了四个“高性价比”的工具：top、pstack、strace 和 perf。它们用起来很简单，而且实用性很强，可以观测到程序的很多外部参数和内部函数调用，由内而外、由表及里地分析程序性能。</p>
<p>第一个要说的是“<strong>top</strong>”，它通常是性能分析的“起点”。无论你开发的是什么样的应用程序，敲个 top 命令，就能够简单直观地看到 CPU、内存等几个最关键的性能指标。</p>
<p>top 展示出来的各项指标的含义都非常丰富，我来说几个操作要点吧，帮助你快速地抓住它的关键信息。</p>
<p>一个是按“M”，看内存占用（RES/MEM），另一个是按“P”，看 CPU 占用，这两个都会从大到小自动排序，方便你找出最耗费资源的进程。</p>
<p>另外，你也可以按组合键“xb”，然后用“&lt;&gt;”手动选择排序的列，这样查看起来更自由。</p>
<p>我曾经做过一个“魔改”Nginx 的实际项目，下面的这个截图展示的就是一次 top 查看的性能：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84C++%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/a64eb681ac87cfa910e626433c43a68e.png" alt=""></p>
<p>从 top 的输出结果里，你可以看到进程运行的概况，知道 CPU、内存的使用率。如果你发现某个指标超出了预期，就说明可能存在问题，接下来，你就应该采取更具体的措施去进一步分析。</p>
<p>比如说，这里面的一个进程 CPU 使用率太高，我怀疑有问题，那我就要深入进程内部，看看到底是哪些操作消耗了 CPU。</p>
<p>这时，我们可以选用两个工具：<strong>pstack 和 strace</strong>。</p>
<p>pstack 可以打印出进程的调用栈信息，有点像是给正在运行的进程拍了个快照，你能看到某个时刻的进程里调用的函数和关系，对进程的运行有个初步的印象。</p>
<p>下面这张截图显示了一个进程的部分调用栈，可以看到，跑了好几个 ZMQ 的线程在收发数据：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84C++%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/d80ebcdd220f5b063e1dd671379b10e1.png" alt=""></p>
<p>不过，pstack 显示的只是进程的一个“静态截面”，信息量还是有点少，而 strace 可以显示出进程的正在运行的系统调用，实时查看进程与系统内核交换了哪些信息：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84C++%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/96a3d6eb78fbaa849872ce42cffcda58.png" alt=""></p>
<p>把 pstack 和 strace 结合起来，你大概就可以知道，进程在用户空间和内核空间都干了些什么。当进程的 CPU 利用率过高或者过低的时候，我们有很大概率能直接发现瓶颈所在。</p>
<p>不过，有的时候，你也可能会“一无所获”，毕竟这两个工具获得的信息只是“表象”，数据的“含金量”太低，做不出什么有效的决策，还是得靠“猜”。要拿到更有说服力的“数字”，就得 <strong>perf</strong> 出场了。</p>
<p>perf 可以说是 pstack 和 strace 的“高级版”，它按照固定的频率去“采样”，相当于连续执行多次的 pstack，然后再统计函数的调用次数，算出百分比。只要采样的频率足够大，把这些“瞬时截面”组合在一起，就可以得到进程运行时的可信数据，比较全面地描述出 CPU 使用情况。</p>
<p>我常用的 perf 命令是“<strong>perf top -K -p xxx</strong>”，按 CPU 使用率排序，只看用户空间的调用，这样很容易就能找出最耗费 CPU 的函数。</p>
<p>比如，下面这张图显示的是大部分 CPU 时间都消耗在了 ZMQ 库上，其中，内存拷贝调用居然达到了近 30%，是不折不扣的“大户”。所以，只要能把这些拷贝操作减少一点，就能提升不少性能。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84C++%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/26ae14f5c2ce4eceb52eb1119d68877f.png" alt=""></p>
<p>总之，<strong>使用 perf 通常可以快速定位系统的瓶颈，帮助你找准性能优化的方向</strong>。课下你也可以自己尝试多分析各种进程，比如 Redis、MySQL，等等，观察它们都在干什么。</p>
<h2 id="源码级工具">源码级工具</h2>
<p>top、pstack、strace 和 perf 属于“非侵入”式的分析工具，不需要修改源码，就可以在软件的外部观察、收集数据。它们虽然方便易用，但毕竟是“隔岸观火”，还是不能非常细致地分析软件，效果不是太理想。</p>
<p>所以，我们还需要有“侵入”式的分析工具，在源码里“埋点”，直接写特别的性能分析代码。这样针对性更强，能够有目的地对系统的某个模块做精细化分析，拿到更准确、更详细的数据。</p>
<p>其实，这种做法你并不陌生，比如计时器、计数器、关键节点打印日志，等等，只是通常并没有上升到性能分析的高度，手法比较“原始”。</p>
<p>在这里，我要推荐一个专业的源码级性能分析工具：<strong>Google Performance Tools</strong>，一般简称为 gperftools。它是一个 C++ 工具集，里面包含了几个专门的性能分析工具（还有一个高效的内存分配器 tcmalloc），分析效果直观、友好、易理解，被广泛地应用于很多系统，经过了充分的实际验证。</p>
<p>apt-get install google-perftools<br>
apt-get install libgoogle-perftools-dev</p>
<p>gperftools 的性能分析工具有 CPUProfiler 和 HeapProfiler 两种，用来分析 CPU 和内存。不过，如果你听从我的建议，总是使用智能指针、标准容器，不使用 new/delete，就完全可以不用关心 HeapProfiler。</p>
<p>CPUProfiler 的原理和 perf 差不多，也是按频率采样，默认是每秒 100 次（100Hz），也就是每 10 毫秒采样一次程序的函数调用情况。</p>
<p>它的用法也比较简单，只需要在源码里添加三个函数：</p>
<ol>
<li><strong>ProfilerStart()</strong>，开始性能分析，把数据存入指定的文件里；</li>
<li><strong>ProfilerRegisterThread()</strong>，允许对线程做性能分析；</li>
<li><strong>ProfilerStop()</strong>，停止性能分析。</li>
</ol>
<p>所以，你只要把想做性能分析的代码“夹”在这三个函数之间就行，运行起来后，gperftools 就会自动产生分析数据。</p>
<p>为了写起来方便，我用 shared_ptr 实现一个自动管理功能。这里利用了 void* 和空指针，可以在智能指针析构的时候执行任意代码（简单的 RAII 惯用法）：</p>
<p>auto make_cpu_profiler =            // lambda 表达式启动性能分析<br>
<a href="./const_string&amp;_filename.md"></a>          // 传入性能分析的数据文件名<br>
{<br>
ProfilerStart(filename.c_str());  // 启动性能分析<br>
ProfilerRegisterThread();         // 对线程做性能分析</p>
<p>return std::shared_ptr<void>(     // 返回智能指针<br>
nullptr,                        // 空指针，只用来占位<br>
<a href="./void_.md"></a>{                      // 删除函数执行停止动作<br>
ProfilerStop();             // 停止性能分析<br>
}  <br>
); <br>
};</p>
<p>下面我写一小段代码，测试正则表达式处理文本的性能：</p>
<p>auto cp = make_cpu_profiler(&ldquo;case1.perf&rdquo;);     // 启动性能分析<br>
auto str = &ldquo;neir:automata&quot;s;</p>
<p>for(int i = 0; i &lt; 1000; i++) {               // 循环一千次<br>
auto reg  = make_regex(R&rdquo;(^(\w+):(\w+)$)&quot;);// 正则表达式对象<br>
auto what = make_match();</p>
<p>assert(regex_match(str, what, reg));        // 正则匹配<br>
}</p>
<p>注意，我特意在 for 循环里定义了正则对象，现在就可以用 gperftools 来分析一下，这样做是不是成本很高。</p>
<p>编译运行后会得到一个“case1.perf”的文件，里面就是 gperftools 的分析数据，但它是二进制的，不能直接查看，如果想要获得可读的信息，还需要另外一个工具脚本 pprof。</p>
<p>但是，pprof 脚本并不含在 apt-get 的安装包里，所以，你还要从GitHub上下载源码，然后用“<code>--text</code>”选项，就可以输出文本形式的分析报告：</p>
<p>git clone <a href="mailto:git@github.com">git@github.com</a>:gperftools/gperftools.git</p>
<p>pprof &ndash;text ./a.out case1.perf &gt; case1.txt</p>
<p>Total: 72 samples<br>
4   5.6%   5.6%   4   5.6% __gnu_cxx::__normal_iterator::base<br>
4   5.6%  11.1%   4   5.6% _init<br>
4   5.6%  16.7%   4   5.6% std::vector::begin<br>
3   4.2%  20.8%   4   5.6% __gnu_cxx::operator-<br>
3   4.2%  25.0%   5   6.9% std::__distance<br>
2   2.8%  27.8%   2   2.8% __GI___strnlen<br>
2   2.8%  30.6%   6   8.3% __GI___strxfrm_l<br>
2   2.8%  33.3%   3   4.2% __dynamic_cast<br>
2   2.8%  36.1%   2   2.8% __memset_sse2<br>
2   2.8%  38.9%   2   2.8% operator new[]</p>
<p>pprof 的文本分析报告和 perf 的很像，也是列出了函数的采样次数和百分比，但因为是源码级的采样，会看到大量的内部函数细节，虽然很详细，但很难找出重点。</p>
<p>好在 pprof 也能输出图形化的分析报告，支持有向图和火焰图，需要你提前安装 Graphviz 和 FlameGraph：</p>
<p>apt-get install graphviz<br>
git clone <a href="mailto:git@github.com">git@github.com</a>:brendangregg/FlameGraph.git</p>
<p>然后，你就可以使用“<code>--svg</code>”“<code>--collapsed</code>”等选项，生成更直观易懂的图形报告了：</p>
<p>pprof &ndash;svg ./a.out case1.perf &gt; case1.svg</p>
<p>pprof &ndash;collapsed ./a.out case1.perf &gt; case1.cbt<br>
flamegraph.pl case1.cbt &gt; flame.svg<br>
flamegraph.pl &ndash;invert &ndash;color aqua case1.cbt &gt; icicle.svg</p>
<p>我就拿最方便的火焰图来“看图说话”吧。你也可以在GitHub上找到原图。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84C++%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/ca66a178709ee4d837c04fdc1cf0c567.png" alt=""></p>
<p>这张火焰图实际上是“倒置”的冰柱图，显示的是自顶向下查看函数的调用栈。</p>
<p>由于 C++ 有名字空间、类、模板等特性，函数的名字都很长，看起来有点费劲，不过这样也比纯文本要直观一些，可以很容易地看出，正则表达式占用了绝大部分的 CPU 时间。再仔细观察的话，就会发现，_Compiler() 这个函数是真正的“罪魁祸首”。</p>
<p>找到了问题所在，现在我们就可以优化代码了，把创建正则对象的语句提到循环外面：</p>
<p>auto reg  = make_regex(R&quot;(^(\w+):(\w+)$)&quot;);  // 正则表达式对象<br>
auto what = make_match();</p>
<p>for(int i = 0; i &lt; 1000; i++) {               // 循环一千次<br>
assert(regex_match(str, what, reg));        // 正则匹配<br>
}</p>
<p>再运行程序，你会发现程序瞬间执行完毕，而且因为优化效果太好，gperftools 甚至都来不及采样，不会产生分析数据。</p>
<p>基本的 gperftools 用法就这么多了，你可以再去看它的官方文档了解更多的用法，比如使用环境变量和信号来控制启停性能分析，或者链接 tcmalloc 库，优化 C++ 的内存分配速度。</p>
<h2 id="小结">小结</h2>
<p>好了，今天主要讲了运行阶段里的性能分析，它能够回答为什么系统“不够好”（not good enough），而调试和测试回答的是为什么系统“不好”（not good）。</p>
<p>简单小结一下今天的内容：</p>
<ol>
<li>最简单的性能分析工具是 top，可以快速查看进程的 CPU、内存使用情况；</li>
<li>pstack 和 strace 能够显示进程在用户空间和内核空间的函数调用情况；</li>
<li>perf 以一定的频率采样分析进程，统计各个函数的 CPU 占用百分比；</li>
<li>gperftools 是“侵入”式的性能分析工具，能够生成文本或者图形化的分析报告，最直观的方式是火焰图。</li>
</ol>
<p>性能分析与优化是一门艰深的课题，也是一个广泛的议题，CPU、内存、网络、文件系统、数据库等等，每一个方向都可以再引出无数的话题。</p>
<p>今天介绍的这些，是我挑选的对初学者最有用的内容，学习难度不高，容易上手，见效快。希望你能以此为契机，在今后的日子里多用、多实际操作，并且不断去探索、应用其他的分析工具，综合运用它们给程序“把脉”，才能让 C++ 在运行阶段跑得更好更快更稳，才能不辜负前面编码、预处理和编译阶段的苦心与努力。</p>
<h2 id="课下作业">课下作业</h2>
<p>最后还是留两个思考题吧：</p>
<ol>
<li>你觉得在运行阶段还能够做哪些事情？</li>
<li>你有性能分析的经验吗？听了今天的这节课之后，你觉得什么方式比较适合自己？</li>
</ol>
<p>欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84C++%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/d7a836ffd0ac056ff6a069ac5dd1c127.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/">罗剑锋的C&#43;&#43;实战笔记</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A140%E9%97%AE/18__%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%BB%85%E4%BB%85%E8%A2%AB%E6%B6%88%E8%B4%B9%E4%B8%80%E6%AC%A1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">18__消息投递：如何保证消息仅仅被消费一次？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%9552%E8%AE%B2/18__%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%ACgui%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/">
            <span class="next-text nav-default">18__眼前一亮：带你玩转GUI自动化的测试报告</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
