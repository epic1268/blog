<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>15__序列化：一来一回你还是原来的你吗？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是朱晔。今天，我来和你聊聊序列化相关的坑和最佳实践。
序列化是把对象转换为字节流的过程，以方便传输或存储。反序列化，则是反过来把字节流转换为对象的过程。在介绍文件 IO的时候，我提到字符编码是把字符转换为二进制的过程，至于怎么转换需要由字符集制定规则。同样地，对象的序列化和反序列化，也需要由序列化算法制定规则。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/15__%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%80%E6%9D%A5%E4%B8%80%E5%9B%9E%E4%BD%A0%E8%BF%98%E6%98%AF%E5%8E%9F%E6%9D%A5%E7%9A%84%E4%BD%A0%E5%90%97/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/15__%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%80%E6%9D%A5%E4%B8%80%E5%9B%9E%E4%BD%A0%E8%BF%98%E6%98%AF%E5%8E%9F%E6%9D%A5%E7%9A%84%E4%BD%A0%E5%90%97/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="15__序列化：一来一回你还是原来的你吗？">
  <meta property="og:description" content="你好，我是朱晔。今天，我来和你聊聊序列化相关的坑和最佳实践。
序列化是把对象转换为字节流的过程，以方便传输或存储。反序列化，则是反过来把字节流转换为对象的过程。在介绍文件 IO的时候，我提到字符编码是把字符转换为二进制的过程，至于怎么转换需要由字符集制定规则。同样地，对象的序列化和反序列化，也需要由序列化算法制定规则。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Java业务开发常见错误100例">

  <meta itemprop="name" content="15__序列化：一来一回你还是原来的你吗？">
  <meta itemprop="description" content="你好，我是朱晔。今天，我来和你聊聊序列化相关的坑和最佳实践。
序列化是把对象转换为字节流的过程，以方便传输或存储。反序列化，则是反过来把字节流转换为对象的过程。在介绍文件 IO的时候，我提到字符编码是把字符转换为二进制的过程，至于怎么转换需要由字符集制定规则。同样地，对象的序列化和反序列化，也需要由序列化算法制定规则。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7659">
  <meta itemprop="keywords" content="Java业务开发常见错误100例">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="15__序列化：一来一回你还是原来的你吗？">
  <meta name="twitter:description" content="你好，我是朱晔。今天，我来和你聊聊序列化相关的坑和最佳实践。
序列化是把对象转换为字节流的过程，以方便传输或存储。反序列化，则是反过来把字节流转换为对象的过程。在介绍文件 IO的时候，我提到字符编码是把字符转换为二进制的过程，至于怎么转换需要由字符集制定规则。同样地，对象的序列化和反序列化，也需要由序列化算法制定规则。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">15__序列化：一来一回你还是原来的你吗？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7659 字 </span>
          <span class="more-meta"> 预计阅读 16 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#序列化和反序列化需要确保算法一致">序列化和反序列化需要确保算法一致</a></li>
        <li><a href="#注意-jackson-json-反序列化对额外字段的处理">注意 Jackson JSON 反序列化对额外字段的处理</a></li>
        <li><a href="#反序列化时要小心类的构造方法">反序列化时要小心类的构造方法</a></li>
        <li><a href="#枚举作为-api-接口参数或返回值的两个大坑">枚举作为 API 接口参数或返回值的两个大坑</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考与讨论">思考与讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是朱晔。今天，我来和你聊聊序列化相关的坑和最佳实践。</p>
<p>序列化是把对象转换为字节流的过程，以方便传输或存储。反序列化，则是反过来把字节流转换为对象的过程。在介绍文件 IO的时候，我提到字符编码是把字符转换为二进制的过程，至于怎么转换需要由字符集制定规则。同样地，对象的序列化和反序列化，也需要由序列化算法制定规则。</p>
<p>关于序列化算法，几年前常用的有 JDK（Java）序列化、XML 序列化等，但前者不能跨语言，后者性能较差（时间空间开销大）；现在 RESTful 应用最常用的是 JSON 序列化，追求性能的 RPC 框架（比如 gRPC）使用 protobuf 序列化，这 2 种方法都是跨语言的，而且性能不错，应用广泛。</p>
<p>在架构设计阶段，我们可能会重点关注算法选型，在性能、易用性和跨平台性等中权衡，不过这里的坑比较少。通常情况下，序列化问题常见的坑会集中在业务场景中，比如 Redis、参数和响应序列化反序列化。</p>
<p>今天，我们就一起聊聊开发中序列化常见的一些坑吧。</p>
<h2 id="序列化和反序列化需要确保算法一致">序列化和反序列化需要确保算法一致</h2>
<p>业务代码中涉及序列化时，很重要的一点是要确保序列化和反序列化的算法一致性。有一次我要排查缓存命中率问题，需要运维同学帮忙拉取 Redis 中的 Key，结果他反馈 Redis 中存的都是乱码，怀疑 Redis 被攻击了。其实呢，这个问题就是序列化算法导致的，我们来看下吧。</p>
<p>在这个案例中，开发同学使用 RedisTemplate 来操作 Redis 进行数据缓存。因为相比于 Jedis，使用 Spring 提供的 RedisTemplate 操作 Redis，除了无需考虑连接池、更方便外，还可以与 Spring Cache 等其他组件无缝整合。如果使用 Spring Boot 的话，无需任何配置就可以直接使用。</p>
<p>数据（包含 Key 和 Value）要保存到 Redis，需要经过序列化算法来序列化成字符串。虽然 Redis 支持多种数据结构，比如 Hash，但其每一个 field 的 Value 还是字符串。如果 Value 本身也是字符串的话，能否有便捷的方式来使用 RedisTemplate，而无需考虑序列化呢？</p>
<p>其实是有的，那就是 StringRedisTemplate。</p>
<p>那 StringRedisTemplate 和 RedisTemplate 的区别是什么呢？开头提到的乱码又是怎么回事呢？带着这些问题让我们来研究一下吧。</p>
<p>写一段测试代码，在应用初始化完成后向 Redis 设置两组数据，第一次使用 RedisTemplate 设置 Key 为 redisTemplate、Value 为 User 对象，第二次使用 StringRedisTemplate 设置 Key 为 stringRedisTemplate、Value 为 JSON 序列化后的 User 对象：</p>
<p>@Autowired<br>
private RedisTemplate redisTemplate;<br>
@Autowired<br>
private StringRedisTemplate stringRedisTemplate;<br>
@Autowired<br>
private ObjectMapper objectMapper;</p>
<p>@PostConstruct<br>
public void init() throws JsonProcessingException {<br>
redisTemplate.opsForValue().set(&ldquo;redisTemplate&rdquo;, new User(&ldquo;zhuye&rdquo;, 36));<br>
stringRedisTemplate.opsForValue().set(&ldquo;stringRedisTemplate&rdquo;, objectMapper.writeValueAsString(new User(&ldquo;zhuye&rdquo;, 36)));<br>
}</p>
<p>如果你认为，StringRedisTemplate 和 RedisTemplate 的区别，无非是读取的 Value 是 String 和 Object，那就大错特错了，因为使用这两种方式存取的数据完全无法通用。</p>
<p>我们做个小实验，通过 RedisTemplate 读取 Key 为 stringRedisTemplate 的 Value，使用 StringRedisTemplate 读取 Key 为 redisTemplate 的 Value：</p>
<p>log.info(&ldquo;redisTemplate get {}&rdquo;, redisTemplate.opsForValue().get(&ldquo;stringRedisTemplate&rdquo;));<br>
log.info(&ldquo;stringRedisTemplate get {}&rdquo;, stringRedisTemplate.opsForValue().get(&ldquo;redisTemplate&rdquo;));</p>
<p>结果是，两次都无法读取到 Value：</p>
<p>[11:49:38.478] [http-nio-45678-exec-1] [INFO ] [.t.c.s.demo1.RedisTemplateController:38  ] - redisTemplate get null<br>
[11:49:38.481] [http-nio-45678-exec-1] [INFO ] [.t.c.s.demo1.RedisTemplateController:39  ] - stringRedisTemplate get null</p>
<p>通过 redis-cli 客户端工具连接到 Redis，你会发现根本就没有叫作 redisTemplate 的 Key，所以 StringRedisTemplate 无法查到数据：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/4795d30c82db5d7bd79cda37d263af6e.png" alt=""></p>
<p>查看 RedisTemplate 的源码发现，默认情况下 RedisTemplate 针对 Key 和 Value 使用了 JDK 序列化：</p>
<p>public void afterPropertiesSet() {<br>
&hellip;<br>
if (defaultSerializer == null) {<br>
defaultSerializer = new JdkSerializationRedisSerializer(<br>
classLoader != null ? classLoader : this.getClass().getClassLoader());<br>
}<br>
if (enableDefaultSerializer) {<br>
if (keySerializer == null) {<br>
keySerializer = defaultSerializer;<br>
defaultUsed = true;<br>
}<br>
if (valueSerializer == null) {<br>
valueSerializer = defaultSerializer;<br>
defaultUsed = true;<br>
}<br>
if (hashKeySerializer == null) {<br>
hashKeySerializer = defaultSerializer;<br>
defaultUsed = true;<br>
}<br>
if (hashValueSerializer == null) {<br>
hashValueSerializer = defaultSerializer;<br>
defaultUsed = true;<br>
}<br>
}<br>
&hellip;<br>
}</p>
<p><strong>redis-cli 看到的类似一串乱码的&quot;\xac\xed\x00\x05t\x00\rredisTemplate&quot;字符串，其实就是字符串 redisTemplate 经过 JDK 序列化后的结果</strong>。这就回答了之前提到的乱码问题。而 RedisTemplate 尝试读取 Key 为 stringRedisTemplate 数据时，也会对这个字符串进行 JDK 序列化处理，所以同样无法读取到数据。</p>
<p>而 StringRedisTemplate 对于 Key 和 Value，使用的是 String 序列化方式，Key 和 Value 只能是 String：</p>
<p>public class StringRedisTemplate extends RedisTemplate&lt;String, String&gt; {<br>
public StringRedisTemplate() {<br>
setKeySerializer(RedisSerializer.string());<br>
setValueSerializer(RedisSerializer.string());<br>
setHashKeySerializer(RedisSerializer.string());<br>
setHashValueSerializer(RedisSerializer.string());<br>
}<br>
}</p>
<p>public class StringRedisSerializer implements RedisSerializer<String> {<br>
@Override<br>
public String deserialize(@Nullable byte[] bytes) {<br>
return (bytes == null ? null : new String(bytes, charset));<br>
}</p>
<p>@Override<br>
public byte[] serialize(@Nullable String string) {<br>
return (string == null ? null : string.getBytes(charset));<br>
}<br>
}</p>
<p>看到这里，我们应该知道 RedisTemplate 和 StringRedisTemplate 保存的数据无法通用。修复方式就是，让它们读取自己存的数据：</p>
<ol>
<li>使用 RedisTemplate 读出的数据，由于是 Object 类型的，使用时可以先强制转换为 User 类型；</li>
<li>使用 StringRedisTemplate 读取出的字符串，需要手动将 JSON 反序列化为 User 类型。</li>
</ol>
<p>//使用 RedisTemplate 获取 Value，无需反序列化就可以拿到实际对象，虽然方便，但是 Redis 中保存的 Key 和 Value 不易读<br>
User userFromRedisTemplate = (User) redisTemplate.opsForValue().get(&ldquo;redisTemplate&rdquo;);<br>
log.info(&ldquo;redisTemplate get {}&rdquo;, userFromRedisTemplate);</p>
<p>//使用 StringRedisTemplate，虽然 Key 正常，但是 Value 存取需要手动序列化成字符串<br>
User userFromStringRedisTemplate = objectMapper.readValue(stringRedisTemplate.opsForValue().get(&ldquo;stringRedisTemplate&rdquo;), User.class);<br>
log.info(&ldquo;stringRedisTemplate get {}&rdquo;, userFromStringRedisTemplate);</p>
<p>这样就可以得到正确输出：</p>
<p>[13:32:09.087] [http-nio-45678-exec-6] [INFO ] [.t.c.s.demo1.RedisTemplateController:45  ] - redisTemplate get User(name=zhuye, age=36)<br>
[13:32:09.092] [http-nio-45678-exec-6] [INFO ] [.t.c.s.demo1.RedisTemplateController:47  ] - stringRedisTemplate get User(name=zhuye, age=36)</p>
<p>看到这里你可能会说，使用 RedisTemplate 获取 Value 虽然方便，但是 Key 和 Value 不易读；而使用 StringRedisTemplate 虽然 Key 是普通字符串，但是 Value 存取需要手动序列化成字符串，有没有两全其美的方式呢？</p>
<p>当然有，自己定义 RedisTemplate 的 Key 和 Value 的序列化方式即可：Key 的序列化使用 RedisSerializer.string()（也就是 StringRedisSerializer 方式）实现字符串序列化，而 Value 的序列化使用 Jackson2JsonRedisSerializer：</p>
<p>@Bean<br>
public <T> RedisTemplate&lt;String, T&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {<br>
RedisTemplate&lt;String, T&gt; redisTemplate = new RedisTemplate&lt;&gt;();<br>
redisTemplate.setConnectionFactory(redisConnectionFactory);<br>
Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);<br>
redisTemplate.setKeySerializer(RedisSerializer.string());<br>
redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);<br>
redisTemplate.setHashKeySerializer(RedisSerializer.string());<br>
redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);<br>
redisTemplate.afterPropertiesSet();<br>
return redisTemplate;<br>
}</p>
<p>写代码测试一下存取，直接注入类型为 RedisTemplate&lt;String, User&gt; 的 userRedisTemplate 字段，然后在 right2 方法中，使用注入的 userRedisTemplate 存入一个 User 对象，再分别使用 userRedisTemplate 和 StringRedisTemplate 取出这个对象：</p>
<p>@Autowired<br>
private RedisTemplate&lt;String, User&gt; userRedisTemplate;</p>
<p>@GetMapping(&ldquo;right2&rdquo;)<br>
public void right2() {<br>
User user = new User(&ldquo;zhuye&rdquo;, 36);<br>
userRedisTemplate.opsForValue().set(user.getName(), user);<br>
Object userFromRedis = userRedisTemplate.opsForValue().get(user.getName());<br>
log.info(&ldquo;userRedisTemplate get {} {}&rdquo;, userFromRedis, userFromRedis.getClass());<br>
log.info(&ldquo;stringRedisTemplate get {}&rdquo;, stringRedisTemplate.opsForValue().get(user.getName()));<br>
}</p>
<p>乍一看没啥问题，StringRedisTemplate 成功查出了我们存入的数据：</p>
<p>[14:07:41.315] [http-nio-45678-exec-1] [INFO ] [.t.c.s.demo1.RedisTemplateController:55  ] - userRedisTemplate get {name=zhuye, age=36} class java.util.LinkedHashMap<br>
[14:07:41.318] [http-nio-45678-exec-1] [INFO ] [.t.c.s.demo1.RedisTemplateController:56  ] - stringRedisTemplate get {&ldquo;name&rdquo;:&ldquo;zhuye&rdquo;,&ldquo;age&rdquo;:36}</p>
<p>Redis 里也可以查到 Key 是纯字符串，Value 是 JSON 序列化后的 User 对象：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/fa3bcbcafaca6718d6509fc3b19dec84.png" alt=""></p>
<p>但值得注意的是，这里有一个坑。<strong>第一行的日志输出显示，userRedisTemplate 获取到的 Value，是 LinkedHashMap 类型的</strong>，完全不是泛型的 RedisTemplate 设置的 User 类型。</p>
<p>如果我们把代码里从 Redis 中获取到的 Value 变量类型由 Object 改为 User，编译不会出现问题，但会出现 ClassCastException：</p>
<p>java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to org.geekbang.time.commonmistakes.serialization.demo1.User</p>
<p>修复方式是，修改自定义 RestTemplate 的代码，把 new 出来的 Jackson2JsonRedisSerializer 设置一个自定义的 ObjectMapper，启用 activateDefaultTyping 方法把类型信息作为属性写入序列化后的数据中（当然了，你也可以调整 JsonTypeInfo.As 枚举以其他形式保存类型信息）：</p>
<p>&hellip;<br>
Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);<br>
ObjectMapper objectMapper = new ObjectMapper();<br>
//把类型信息作为属性写入 Value<br>
objectMapper.activateDefaultTyping(objectMapper.getPolymorphicTypeValidator(), ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);<br>
jackson2JsonRedisSerializer.setObjectMapper(objectMapper);<br>
&hellip;</p>
<p>或者，直接使用 RedisSerializer.json() 快捷方法，它内部使用的 GenericJackson2JsonRedisSerializer 直接设置了把类型作为属性保存到 Value 中：</p>
<p>redisTemplate.setKeySerializer(RedisSerializer.string());<br>
redisTemplate.setValueSerializer(RedisSerializer.json());<br>
redisTemplate.setHashKeySerializer(RedisSerializer.string());<br>
redisTemplate.setHashValueSerializer(RedisSerializer.json());</p>
<p>重启程序调用 right2 方法进行测试，可以看到，从自定义的 RedisTemplate 中获取到的 Value 是 User 类型的（第一行日志），而且 Redis 中实际保存的 Value 包含了类型完全限定名（第二行日志）：</p>
<p>[15:10:50.396] [http-nio-45678-exec-1] [INFO ] [.t.c.s.demo1.RedisTemplateController:55  ] - userRedisTemplate get User(name=zhuye, age=36) class org.geekbang.time.commonmistakes.serialization.demo1.User<br>
[15:10:50.399] [http-nio-45678-exec-1] [INFO ] [.t.c.s.demo1.RedisTemplateController:56  ] - stringRedisTemplate get [&ldquo;org.geekbang.time.commonmistakes.serialization.demo1.User&rdquo;,{&ldquo;name&rdquo;:&ldquo;zhuye&rdquo;,&ldquo;age&rdquo;:36}]</p>
<p>因此，反序列化时可以直接得到 User 类型的 Value。</p>
<p>通过对 RedisTemplate 组件的分析，可以看到，当数据需要序列化后保存时，读写数据使用一致的序列化算法的必要性，否则就像对牛弹琴。</p>
<p>这里，我再总结下 Spring 提供的 4 种 RedisSerializer（Redis 序列化器）：</p>
<ol>
<li>默认情况下，RedisTemplate 使用 JdkSerializationRedisSerializer，也就是 JDK 序列化，容易产生 Redis 中保存了乱码的错觉。</li>
<li>通常考虑到易读性，可以设置 Key 的序列化器为 StringRedisSerializer。但直接使用 RedisSerializer.string()，相当于使用了 UTF_8 编码的 StringRedisSerializer，需要注意字符集问题。</li>
<li>如果希望 Value 也是使用 JSON 序列化的话，可以把 Value 序列化器设置为 Jackson2JsonRedisSerializer。默认情况下，不会把类型信息保存在 Value 中，即使我们定义 RedisTemplate 的 Value 泛型为实际类型，查询出的 Value 也只能是 LinkedHashMap 类型。如果希望直接获取真实的数据类型，你可以启用 Jackson ObjectMapper 的 activateDefaultTyping 方法，把类型信息一起序列化保存在 Value 中。</li>
<li>如果希望 Value 以 JSON 保存并带上类型信息，更简单的方式是，直接使用 RedisSerializer.json() 快捷方法来获取序列化器。</li>
</ol>
<h2 id="注意-jackson-json-反序列化对额外字段的处理">注意 Jackson JSON 反序列化对额外字段的处理</h2>
<p>前面我提到，通过设置 JSON 序列化工具 Jackson 的 activateDefaultTyping 方法，可以在序列化数据时写入对象类型。其实，Jackson 还有很多参数可以控制序列化和反序列化，是一个功能强大而完善的序列化工具。因此，很多框架都将 Jackson 作为 JDK 序列化工具，比如 Spring Web。但也正是这个原因，我们使用时要小心各个参数的配置。</p>
<p>比如，在开发 Spring Web 应用程序时，如果自定义了 ObjectMapper，并把它注册成了 Bean，那很可能会导致 Spring Web 使用的 ObjectMapper 也被替换，导致 Bug。</p>
<p>我们来看一个案例。程序一开始是正常的，某一天开发同学希望修改一下 ObjectMapper 的行为，让枚举序列化为索引值而不是字符串值，比如默认情况下序列化一个 Color 枚举中的 Color.BLUE 会得到字符串 BLUE：</p>
<p>@Autowired<br>
private ObjectMapper objectMapper;</p>
<p>@GetMapping(&ldquo;test&rdquo;)<br>
public void test() throws JsonProcessingException {<br>
log.info(&ldquo;color:{}&rdquo;, objectMapper.writeValueAsString(Color.BLUE));<br>
}</p>
<p>enum Color {<br>
RED, BLUE<br>
}</p>
<p>于是，这位同学就重新定义了一个 ObjectMapper Bean，开启了 WRITE_ENUMS_USING_INDEX 功能特性：</p>
<p>@Bean<br>
public ObjectMapper objectMapper(){<br>
ObjectMapper objectMapper=new ObjectMapper();<br>
objectMapper.configure(SerializationFeature.WRITE_ENUMS_USING_INDEX,true);<br>
return objectMapper;<br>
}</p>
<p>开启这个特性后，Color.BLUE 枚举序列化成索引值 1：</p>
<p>[16:11:37.382] [http-nio-45678-exec-1] [INFO ] [c.s.d.JsonIgnorePropertiesController:19  ] - color:1</p>
<p>修改后处理枚举序列化的逻辑是满足了要求，但线上爆出了大量 400 错误，日志中也出现了很多 UnrecognizedPropertyException：</p>
<p>JSON parse error: Unrecognized field &quot;ver&quot; (class org.geekbang.time.commonmistakes.serialization.demo4.UserWrong), not marked as ignorable; nested exception is com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field &quot;version&quot; (class org.geekbang.time.commonmistakes.serialization.demo4.UserWrong), not marked as ignorable (one known property: &quot;name&quot;])\n at [Source: (PushbackInputStream); line: 1, column: 22] (through reference chain: org.geekbang.time.commonmistakes.serialization.demo4.UserWrong[&quot;ver&quot;])</p>
<p>从异常信息中可以看到，这是因为反序列化的时候，原始数据多了一个 version 属性。进一步分析发现，我们使用了 UserWrong 类型作为 Web 控制器 wrong 方法的入参，其中只有一个 name 属性：</p>
<p>@Data<br>
public class UserWrong {<br>
private String name;<br>
}</p>
<p>@PostMapping(&ldquo;wrong&rdquo;)<br>
public UserWrong wrong(@RequestBody UserWrong user) {<br>
return user;<br>
}</p>
<p>而客户端实际传过来的数据多了一个 version 属性。那，为什么之前没这个问题呢？</p>
<p>问题就出在，<strong>自定义 ObjectMapper 启用 WRITE_ENUMS_USING_INDEX 序列化功能特性时，覆盖了 Spring Boot 自动创建的 ObjectMapper</strong>；而这个自动创建的 ObjectMapper 设置过 FAIL_ON_UNKNOWN_PROPERTIES 反序列化特性为 false，以确保出现未知字段时不要抛出异常。源码如下：</p>
<p>public MappingJackson2HttpMessageConverter() {<br>
this(Jackson2ObjectMapperBuilder.json().build());<br>
}</p>
<p>public class Jackson2ObjectMapperBuilder {</p>
<p>&hellip;</p>
<p>private void customizeDefaultFeatures(ObjectMapper objectMapper) {<br>
if (!this.features.containsKey(MapperFeature.DEFAULT_VIEW_INCLUSION)) {<br>
configureFeature(objectMapper, MapperFeature.DEFAULT_VIEW_INCLUSION, false);<br>
}<br>
if (!this.features.containsKey(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {<br>
configureFeature(objectMapper, DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);<br>
}<br>
}<br>
}</p>
<p>要修复这个问题，有三种方式：</p>
<ol>
<li>第一种，同样禁用自定义的 ObjectMapper 的 FAIL_ON_UNKNOWN_PROPERTIES：</li>
</ol>
<p>@Bean<br>
public ObjectMapper objectMapper(){<br>
ObjectMapper objectMapper=new ObjectMapper();<br>
objectMapper.configure(SerializationFeature.WRITE_ENUMS_USING_INDEX,true);<br>
objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);<br>
return objectMapper;<br>
}</p>
<ol>
<li>第二种，设置自定义类型，加上 @JsonIgnoreProperties 注解，开启 ignoreUnknown 属性，以实现反序列化时忽略额外的数据：</li>
</ol>
<p>@Data<br>
@JsonIgnoreProperties(ignoreUnknown = true)<br>
public class UserRight {<br>
private String name;<br>
}</p>
<ol>
<li>第三种，不要自定义 ObjectMapper，而是直接在配置文件设置相关参数，来修改 Spring 默认的 ObjectMapper 的功能。比如，直接在配置文件启用把枚举序列化为索引号：</li>
</ol>
<p>spring.jackson.serialization.write_enums_using_index=true</p>
<p>或者可以直接定义 Jackson2ObjectMapperBuilderCustomizer Bean 来启用新特性：</p>
<p>@Bean<br>
public Jackson2ObjectMapperBuilderCustomizer customizer(){<br>
return builder -&gt; builder.featuresToEnable(SerializationFeature.WRITE_ENUMS_USING_INDEX);<br>
}</p>
<p>这个案例告诉我们两点：</p>
<ol>
<li>Jackson 针对序列化和反序列化有大量的细节功能特性，我们可以参考 Jackson 官方文档来了解这些特性，详见SerializationFeature、DeserializationFeature和MapperFeature。</li>
<li>忽略多余字段，是我们写业务代码时最容易遇到的一个配置项。Spring Boot 在自动配置时贴心地做了全局设置。如果需要设置更多的特性，可以直接修改配置文件 spring.jackson.** 或设置 Jackson2ObjectMapperBuilderCustomizer 回调接口，来启用更多设置，无需重新定义 ObjectMapper Bean。</li>
</ol>
<h2 id="反序列化时要小心类的构造方法">反序列化时要小心类的构造方法</h2>
<p>使用 Jackson 反序列化时，除了要注意忽略额外字段的问题外，还要小心类的构造方法。我们看一个实际的踩坑案例吧。</p>
<p>有一个 APIResult 类包装了 REST 接口的返回体（作为 Web 控制器的出参），其中 boolean 类型的 success 字段代表是否处理成功、int 类型的 code 字段代表处理状态码。</p>
<p>开始时，在返回 APIResult 的时候每次都根据 code 来设置 success。如果 code 是 2000，那么 success 是 true，否则是 false。后来为了减少重复代码，把这个逻辑放到了 APIResult 类的构造方法中处理：</p>
<p>@Data<br>
public class APIResultWrong {<br>
private boolean success;<br>
private int code;</p>
<pre><code>public APIResultWrong() {  
}  

public APIResultWrong(int code) {  
    this.code = code;  
    if (code == 2000) success = true;  
    else success = false;  
}  
</code></pre>
<p>}</p>
<p>经过改动后发现，即使 code 为 2000，返回 APIResult 的 success 也是 false。比如，我们反序列化两次 APIResult，一次使用 code==1234，一次使用 code==2000：</p>
<p>@Autowired<br>
ObjectMapper objectMapper;</p>
<p>@GetMapping(&ldquo;wrong&rdquo;)<br>
public void wrong() throws JsonProcessingException {<br>
log.info(&ldquo;result :{}&rdquo;, objectMapper.readValue(&quot;{&quot;code&quot;:1234}&quot;, APIResultWrong.class));<br>
log.info(&ldquo;result :{}&rdquo;, objectMapper.readValue(&quot;{&quot;code&quot;:2000}&quot;, APIResultWrong.class));<br>
}</p>
<p>日志输出如下：</p>
<p>[17:36:14.591] [http-nio-45678-exec-1] [INFO ] [DeserializationConstructorController:20  ] - result :APIResultWrong(success=false, code=1234)<br>
[17:36:14.591] [http-nio-45678-exec-1] [INFO ] [DeserializationConstructorController:21  ] - result :APIResultWrong(success=false, code=2000)</p>
<p>可以看到，两次的 APIResult 的 success 字段都是 false。</p>
<p>出现这个问题的原因是，<strong>默认情况下，在反序列化的时候，Jackson 框架只会调用无参构造方法创建对象</strong>。如果走自定义的构造方法创建对象，需要通过 @JsonCreator 来指定构造方法，并通过 @JsonProperty 设置构造方法中参数对应的 JSON 属性名：</p>
<p>@Data<br>
public class APIResultRight {<br>
&hellip;</p>
<pre><code>@JsonCreator  
public APIResultRight(@JsonProperty(&quot;code&quot;) int code) {  
    this.code = code;  
    if (code == 2000) success = true;  
    else success = false;  
}  
</code></pre>
<p>}</p>
<p>重新运行程序，可以得到正确输出：</p>
<p>[17:41:23.188] [http-nio-45678-exec-1] [INFO ] [DeserializationConstructorController:26  ] - result :APIResultRight(success=false, code=1234)<br>
[17:41:23.188] [http-nio-45678-exec-1] [INFO ] [DeserializationConstructorController:27  ] - result :APIResultRight(success=true, code=2000)</p>
<p>可以看到，这次传入 code==2000 时，success 可以设置为 true。</p>
<h2 id="枚举作为-api-接口参数或返回值的两个大坑">枚举作为 API 接口参数或返回值的两个大坑</h2>
<p>在前面的例子中，我演示了如何把枚举序列化为索引值。但对于枚举，我建议尽量在程序内部使用，而不是作为 API 接口的参数或返回值，原因是枚举涉及序列化和反序列化时会有两个大坑。</p>
<p>**第一个坑是，客户端和服务端的枚举定义不一致时，会出异常。**比如，客户端版本的枚举定义了 4 个枚举值：</p>
<p>@Getter<br>
enum StatusEnumClient {<br>
CREATED(1, &ldquo;已创建&rdquo;),<br>
PAID(2, &ldquo;已支付&rdquo;),<br>
DELIVERED(3, &ldquo;已送到&rdquo;),<br>
FINISHED(4, &ldquo;已完成&rdquo;);</p>
<pre><code>private final int status;  
private final String desc;  

StatusEnumClient(Integer status, String desc) {  
    this.status = status;  
    this.desc = desc;  
}  
</code></pre>
<p>}</p>
<p>服务端定义了 5 个枚举值：</p>
<p>@Getter<br>
enum StatusEnumServer {<br>
&hellip;<br>
CANCELED(5, &ldquo;已取消&rdquo;);</p>
<pre><code>private final int status;  
private final String desc;  

StatusEnumServer(Integer status, String desc) {  
    this.status = status;  
    this.desc = desc;  
}  
</code></pre>
<p>}</p>
<p>写代码测试一下，使用 RestTemplate 来发起请求，让服务端返回客户端不存在的枚举值：</p>
<p>@GetMapping(&ldquo;getOrderStatusClient&rdquo;)<br>
public void getOrderStatusClient() {<br>
StatusEnumClient result = restTemplate.getForObject(&ldquo;http://localhost:45678/enumusedinapi/getOrderStatus&rdquo;, StatusEnumClient.class);<br>
log.info(&ldquo;result {}&rdquo;, result);<br>
}</p>
<p>@GetMapping(&ldquo;getOrderStatus&rdquo;)<br>
public StatusEnumServer getOrderStatus() {<br>
return StatusEnumServer.CANCELED;<br>
}</p>
<p>访问接口会出现如下异常信息，提示在枚举 StatusEnumClient 中找不到 CANCELED：</p>
<p>JSON parse error: Cannot deserialize value of type <code>org.geekbang.time.commonmistakes.enums.enumusedinapi.StatusEnumClient</code> from String &ldquo;CANCELED&rdquo;: not one of the values accepted for Enum class: [CREATED, FINISHED, DELIVERED, PAID];</p>
<p>要解决这个问题，可以开启 Jackson 的 read_unknown_enum_values_using_default_value 反序列化特性，也就是在枚举值未知的时候使用默认值：</p>
<p>spring.jackson.deserialization.read_unknown_enum_values_using_default_value=true</p>
<p>并为枚举添加一个默认值，使用 @JsonEnumDefaultValue 注解注释：</p>
<p>@JsonEnumDefaultValue<br>
UNKNOWN(-1, &ldquo;未知&rdquo;);</p>
<p>需要注意的是，这个枚举值一定是添加在客户端 StatusEnumClient 中的，因为反序列化使用的是客户端枚举。</p>
<p>这里还有一个小坑是，仅仅这样配置还不能让 RestTemplate 生效这个反序列化特性，还需要配置 RestTemplate，来使用 Spring Boot 的 MappingJackson2HttpMessageConverter 才行：</p>
<p>@Bean<br>
public RestTemplate restTemplate(MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter) {<br>
return new RestTemplateBuilder()<br>
.additionalMessageConverters(mappingJackson2HttpMessageConverter)<br>
.build();<br>
}</p>
<p>现在，请求接口可以返回默认值了：</p>
<p>[21:49:03.887] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.e.e.EnumUsedInAPIController:25  ] - result UNKNOWN</p>
<p><strong>第二个坑，也是更大的坑，枚举序列化反序列化实现自定义的字段非常麻烦，会涉及 Jackson 的 Bug</strong>。比如，下面这个接口，传入枚举 List，为 List 增加一个 CENCELED 枚举值然后返回：</p>
<p>@PostMapping(&ldquo;queryOrdersByStatusList&rdquo;)<br>
public List<StatusEnumServer> queryOrdersByStatus(@RequestBody List<StatusEnumServer> enumServers) {<br>
enumServers.add(StatusEnumServer.CANCELED);<br>
return enumServers;<br>
}</p>
<p>如果我们希望根据枚举的 Desc 字段来序列化，传入“已送到”作为入参：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/35211eaf865ce4a5bb37c9c699a2ccae.png" alt=""></p>
<p>会得到异常，提示“已送到”不是正确的枚举值：</p>
<p>JSON parse error: Cannot deserialize value of type <code>org.geekbang.time.commonmistakes.enums.enumusedinapi.StatusEnumServer</code> from String &ldquo;已送到&rdquo;: not one of the values accepted for Enum class: [CREATED, CANCELED, FINISHED, DELIVERED, PAID]</p>
<p>显然，这里反序列化使用的是枚举的 name，序列化也是一样：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/608458e5aa3c30b34c556d2a4eaf602c.png" alt=""></p>
<p>你可能也知道，要让枚举的序列化和反序列化走 desc 字段，可以在字段上加 @JsonValue 注解，修改 StatusEnumServer 和 StatusEnumClient：</p>
<p>@JsonValue<br>
private final String desc;</p>
<p>然后再尝试下，果然可以用 desc 作为入参了，而且出参也使用了枚举的 desc：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/9a8704eeab0be2fd83bbd2d17a3927be.png" alt=""></p>
<p>但是，如果你认为这样就完美解决问题了，那就大错特错了。你可以再尝试把 @JsonValue 注解加在 int 类型的 status 字段上，也就是希望序列化反序列化走 status 字段：</p>
<p>@JsonValue<br>
private final int status;</p>
<p>写一个客户端测试一下，传入 CREATED 和 PAID 两个枚举值：</p>
<p>@GetMapping(&ldquo;queryOrdersByStatusListClient&rdquo;)<br>
public void queryOrdersByStatusListClient() {<br>
List<StatusEnumClient> request = Arrays.asList(StatusEnumClient.CREATED, StatusEnumClient.PAID);<br>
HttpEntity&lt;List<StatusEnumClient>&gt; entity = new HttpEntity&lt;&gt;(request, new HttpHeaders());<br>
List<StatusEnumClient> response = restTemplate.exchange(&ldquo;http://localhost:45678/enumusedinapi/queryOrdersByStatusList&rdquo;,<br>
HttpMethod.POST, entity, new ParameterizedTypeReference&lt;List<StatusEnumClient>&gt;() {}).getBody();<br>
log.info(&ldquo;result {}&rdquo;, response);<br>
}</p>
<p>请求接口可以看到，传入的是 CREATED 和 PAID，返回的居然是 DELIVERED 和 FINISHED。果然如标题所说，一来一回你已不是原来的你：</p>
<p>[22:03:03.579] [http-nio-45678-exec-4] [INFO ] [o.g.t.c.e.e.EnumUsedInAPIController:34  ] - result [DELIVERED, FINISHED, UNKNOWN]</p>
<p>出现这个问题的原因是，<strong>序列化走了 status 的值，而反序列化并没有根据 status 来，还是使用了枚举的 ordinal() 索引值</strong>。这是 Jackson至今（2.10）没有解决的 Bug，应该会在 2.11 解决。</p>
<p>如下图所示，我们调用服务端接口，传入一个不存在的 status 值 0，也能反序列化成功，最后服务端的返回是 1：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/bfb118578a0a5bc1e8da7a9d8c9fe283.png" alt=""></p>
<p>有一个解决办法是，设置 @JsonCreator 来强制反序列化时使用自定义的工厂方法，可以实现使用枚举的 status 字段来取值。我们把这段代码加在 StatusEnumServer 枚举类中：</p>
<p>@JsonCreator<br>
public static StatusEnumServer parse(Object o) {<br>
return Arrays.stream(StatusEnumServer.values()).filter(value-&gt;o.equals(value.status)).findFirst().orElse(null);<br>
}</p>
<p>要特别注意的是，我们同样要为 StatusEnumClient 也添加相应的方法。因为除了服务端接口接收 StatusEnumServer 参数涉及一次反序列化外，从服务端返回值转换为 List 还会有一次反序列化：</p>
<p>@JsonCreator<br>
public static StatusEnumClient parse(Object o) {<br>
return Arrays.stream(StatusEnumClient.values()).filter(value-&gt;o.equals(value.status)).findFirst().orElse(null);<br>
}</p>
<p>重新调用接口发现，虽然结果正确了，但是服务端不存在的枚举值 CANCELED 被设置为了 null，而不是 @JsonEnumDefaultValue 设置的 UNKNOWN。</p>
<p>这个问题，我们之前已经通过设置 @JsonEnumDefaultValue 注解解决了，但现在又出现了：</p>
<p>[22:20:13.727] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.e.e.EnumUsedInAPIController:34  ] - result [CREATED, PAID, null]</p>
<p>原因也很简单，我们自定义的 parse 方法实现的是找不到枚举值时返回 null。</p>
<p>为彻底解决这个问题，并避免通过 @JsonCreator 在枚举中自定义一个非常复杂的工厂方法，我们可以实现一个自定义的反序列化器。这段代码比较复杂，我特意加了详细的注释：</p>
<p>class EnumDeserializer extends JsonDeserializer<Enum> implements<br>
ContextualDeserializer {</p>
<pre><code>private Class&lt;Enum&gt; targetClass;  

public EnumDeserializer() {  
}  

public EnumDeserializer(Class&lt;Enum&gt; targetClass) {  
    this.targetClass = targetClass;  
}  

@Override  
public Enum deserialize(JsonParser p, DeserializationContext ctxt) {  
    //找枚举中带有@JsonValue 注解的字段，这是我们反序列化的基准字段  
    Optional&lt;Field&gt; valueFieldOpt = Arrays.asList(targetClass.getDeclaredFields()).stream()  
            .filter(m -&gt; m.isAnnotationPresent(JsonValue.class))  
            .findFirst();  

    if (valueFieldOpt.isPresent()) {  
        Field valueField = valueFieldOpt.get();  
        if (!valueField.isAccessible()) {  
            valueField.setAccessible(true);  
        }  
        //遍历枚举项，查找字段的值等于反序列化的字符串的那个枚举项  
        return Arrays.stream(targetClass.getEnumConstants()).filter(e -&gt; {  
            try {  
                return valueField.get(e).toString().equals(p.getValueAsString());  
            } catch (Exception ex) {  
                ex.printStackTrace();  
            }  
            return false;  
        }).findFirst().orElseGet(() -&gt; Arrays.stream(targetClass.getEnumConstants()).filter(e -&gt; {  
            //如果找不到，就需要寻找默认枚举值来替代，同样遍历所有枚举项，查找@JsonEnumDefaultValue 注解标识的枚举项  
            try {  
                return targetClass.getField(e.name()).isAnnotationPresent(JsonEnumDefaultValue.class);  
            } catch (Exception ex) {  
                ex.printStackTrace();  
            }  
            return false;  
        }).findFirst().orElse(null));  
    }  
    return null;  
}  

@Override  
public JsonDeserializer&lt;?&gt; createContextual(DeserializationContext ctxt,  
                                            BeanProperty property) throws JsonMappingException {  
    targetClass = (Class&lt;Enum&gt;) ctxt.getContextualType().getRawClass();  
    return new EnumDeserializer(targetClass);  
}  
</code></pre>
<p>}</p>
<p>然后，把这个自定义反序列化器注册到 Jackson 中：</p>
<p>@Bean<br>
public Module enumModule() {<br>
SimpleModule module = new SimpleModule();<br>
module.addDeserializer(Enum.class, new EnumDeserializer());<br>
return module;<br>
}</p>
<p>第二个大坑终于被完美地解决了：</p>
<p>[22:32:28.327] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.e.e.EnumUsedInAPIController:34  ] - result [CREATED, PAID, UNKNOWN]</p>
<p>这样做，虽然解决了序列化反序列化使用枚举中自定义字段的问题，也解决了找不到枚举值时使用默认值的问题，但解决方案很复杂。因此，我还是建议在 DTO 中直接使用 int 或 String 等简单的数据类型，而不是使用枚举再配合各种复杂的序列化配置，来实现枚举到枚举中字段的映射，会更加清晰明了。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>今天，我基于 Redis 和 Web API 的入参和出参两个场景，和你介绍了序列化和反序列化时需要避开的几个坑。</p>
<p>第一，要确保序列化和反序列化算法的一致性。因为，不同序列化算法输出必定不同，要正确处理序列化后的数据就要使用相同的反序列化算法。</p>
<p>第二，Jackson 有大量的序列化和反序列化特性，可以用来微调序列化和反序列化的细节。需要注意的是，如果自定义 ObjectMapper 的 Bean，小心不要和 Spring Boot 自动配置的 Bean 冲突。</p>
<p>第三，在调试序列化反序列化问题时，我们一定要捋清楚三点：是哪个组件在做序列化反序列化、整个过程有几次序列化反序列化，以及目前到底是序列化还是反序列化。</p>
<p>第四，对于反序列化默认情况下，框架调用的是无参构造方法，如果要调用自定义的有参构造方法，那么需要告知框架如何调用。更合理的方式是，对于需要序列化的 POJO 考虑尽量不要自定义构造方法。</p>
<p>第五，枚举不建议定义在 DTO 中跨服务传输，因为会有版本问题，并且涉及序列化反序列化时会很复杂，容易出错。因此，我只建议在程序内部使用枚举。</p>
<p>最后还有一点需要注意，如果需要跨平台使用序列化的数据，那么除了两端使用的算法要一致外，还可能会遇到不同语言对数据类型的兼容问题。这，也是经常踩坑的一个地方。如果你有相关需求，可以多做实验、多测试。</p>
<p>今天用到的代码，我都放在了 GitHub 上，你可以点击这个链接查看。</p>
<h2 id="思考与讨论">思考与讨论</h2>
<ol>
<li>在讨论 Redis 序列化方式的时候，我们自定义了 RedisTemplate，让 Key 使用 String 序列化、让 Value 使用 JSON 序列化，从而使 Redis 获得的 Value 可以直接转换为需要的对象类型。那么，使用 RedisTemplate&lt;String, Long&gt; 能否存取 Value 是 Long 的数据呢？这其中有什么坑吗？</li>
<li>你可以看一下 Jackson2ObjectMapperBuilder 类源码的实现（注意 configure 方法），分析一下其除了关闭 FAIL_ON_UNKNOWN_PROPERTIES 外，还做了什么吗？</li>
</ol>
<p>关于序列化和反序列化，你还遇到过什么坑吗？我是朱晔，欢迎在评论区与我留言分享，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/">Java业务开发常见错误100例</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/15__%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%80%E5%8D%95%E9%80%9A%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">15__序列化：简单通用的数据交换格式有哪些？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E7%9D%80%E9%AB%98%E6%89%8B%E5%AD%A6%E5%A4%8D%E7%9B%98/15__%E4%B8%9A%E5%8A%A1%E5%85%B3%E9%94%AE%E7%82%B9%E6%94%B9%E8%BF%9B%E4%B8%80%E4%B8%AA%E7%82%B9%E4%B8%9A%E7%BB%A9%E5%A2%9E%E9%95%BF50/">
            <span class="next-text nav-default">15__业务关键点：改进一个点业绩增长50%？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
