<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>06__20%的业务代码的Spring声明式事务，可能都没处理正确 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是朱晔。今天，我来和你聊聊业务代码中与数据库事务相关的坑。
Spring 针对 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API (JPA) 等事务 API，实现了一致的编程模型，而 Spring 的声明式事务功能更是提供了极其方便的事务配置方式，配合 Spring Boot 的自动配置，大多数 Spring Boot 项目只需要在方法上标记 @Transactional 注解，即可一键开启方法的事务性配置。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/06__20%E7%9A%84%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E7%9A%84spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8F%AF%E8%83%BD%E9%83%BD%E6%B2%A1%E5%A4%84%E7%90%86%E6%AD%A3%E7%A1%AE/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/06__20%E7%9A%84%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E7%9A%84spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8F%AF%E8%83%BD%E9%83%BD%E6%B2%A1%E5%A4%84%E7%90%86%E6%AD%A3%E7%A1%AE/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="06__20%的业务代码的Spring声明式事务，可能都没处理正确">
  <meta property="og:description" content="你好，我是朱晔。今天，我来和你聊聊业务代码中与数据库事务相关的坑。
Spring 针对 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API (JPA) 等事务 API，实现了一致的编程模型，而 Spring 的声明式事务功能更是提供了极其方便的事务配置方式，配合 Spring Boot 的自动配置，大多数 Spring Boot 项目只需要在方法上标记 @Transactional 注解，即可一键开启方法的事务性配置。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Java业务开发常见错误100例">

  <meta itemprop="name" content="06__20%的业务代码的Spring声明式事务，可能都没处理正确">
  <meta itemprop="description" content="你好，我是朱晔。今天，我来和你聊聊业务代码中与数据库事务相关的坑。
Spring 针对 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API (JPA) 等事务 API，实现了一致的编程模型，而 Spring 的声明式事务功能更是提供了极其方便的事务配置方式，配合 Spring Boot 的自动配置，大多数 Spring Boot 项目只需要在方法上标记 @Transactional 注解，即可一键开启方法的事务性配置。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6326">
  <meta itemprop="keywords" content="Java业务开发常见错误100例">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="06__20%的业务代码的Spring声明式事务，可能都没处理正确">
  <meta name="twitter:description" content="你好，我是朱晔。今天，我来和你聊聊业务代码中与数据库事务相关的坑。
Spring 针对 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API (JPA) 等事务 API，实现了一致的编程模型，而 Spring 的声明式事务功能更是提供了极其方便的事务配置方式，配合 Spring Boot 的自动配置，大多数 Spring Boot 项目只需要在方法上标记 @Transactional 注解，即可一键开启方法的事务性配置。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">06__20%的业务代码的Spring声明式事务，可能都没处理正确</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6326 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#小心-spring-的事务可能没有生效">小心 Spring 的事务可能没有生效</a></li>
        <li><a href="#事务即便生效也不一定能回滚">事务即便生效也不一定能回滚</a></li>
        <li><a href="#请确认事务传播配置是否符合自己的业务逻辑">请确认事务传播配置是否符合自己的业务逻辑</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考与讨论">思考与讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是朱晔。今天，我来和你聊聊业务代码中与数据库事务相关的坑。</p>
<p>Spring 针对 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API (JPA) 等事务 API，实现了一致的编程模型，而 Spring 的声明式事务功能更是提供了极其方便的事务配置方式，配合 Spring Boot 的自动配置，大多数 Spring Boot 项目只需要在方法上标记 @Transactional 注解，即可一键开启方法的事务性配置。</p>
<p>据我观察，大多数业务开发同学都有事务的概念，也知道如果整体考虑多个数据库操作要么成功要么失败时，需要通过数据库事务来实现多个操作的一致性和原子性。但，在使用上大多仅限于为方法标记 @Transactional，不会去关注事务是否有效、出错后事务是否正确回滚，也不会考虑复杂的业务代码中涉及多个子业务逻辑时，怎么正确处理事务。</p>
<p>事务没有被正确处理，一般来说不会过于影响正常流程，也不容易在测试阶段被发现。但当系统越来越复杂、压力越来越大之后，就会带来大量的数据不一致问题，随后就是大量的人工介入查看和修复数据。</p>
<p>所以说，一个成熟的业务系统和一个基本可用能完成功能的业务系统，在事务处理细节上的差异非常大。要确保事务的配置符合业务功能的需求，往往不仅仅是技术问题，还涉及产品流程和架构设计的问题。今天这一讲的标题“20% 的业务代码的 Spring 声明式事务，可能都没处理正确”中，20% 这个数字在我看来还是比较保守的。</p>
<p>我今天要分享的内容，就是帮助你在技术问题上理清思路，避免因为事务处理不当让业务逻辑的实现产生大量偶发 Bug。</p>
<h2 id="小心-spring-的事务可能没有生效">小心 Spring 的事务可能没有生效</h2>
<p>在使用 @Transactional 注解开启声明式事务时，第一个最容易忽略的问题是，很可能事务并没有生效。</p>
<p>实现下面的 Demo 需要一些基础类，首先定义一个具有 ID 和姓名属性的 UserEntity，也就是一个包含两个字段的用户表：</p>
<p>@Entity<br>
@Data<br>
public class UserEntity {<br>
@Id<br>
@GeneratedValue(strategy = AUTO)<br>
private Long id;<br>
private String name;</p>
<pre><code>public UserEntity() { }  

public UserEntity(String name) {  
    this.name = name;  
}  
</code></pre>
<p>}</p>
<p>为了方便理解，我使用 Spring JPA 做数据库访问，实现这样一个 Repository，新增一个根据用户名查询所有数据的方法：</p>
<p>@Repository<br>
public interface UserRepository extends JpaRepository&lt;UserEntity, Long&gt; {<br>
List<UserEntity> findByName(String name);<br>
}</p>
<p>定义一个 UserService 类，负责业务逻辑处理。如果不清楚 @Transactional 的实现方式，只考虑代码逻辑的话，这段代码看起来没有问题。</p>
<p>定义一个入口方法 createUserWrong1 来调用另一个私有方法 createUserPrivate，私有方法上标记了 @Transactional 注解。当传入的用户名包含 test 关键字时判断为用户名不合法，抛出异常，让用户创建操作失败，期望事务可以回滚：</p>
<p>@Service<br>
@Slf4j<br>
public class UserService {<br>
@Autowired<br>
private UserRepository userRepository;</p>
<pre><code>//一个公共方法供 Controller 调用，内部调用事务性的私有方法  
public int createUserWrong1(String name) {  
    try {  
        this.createUserPrivate(new UserEntity(name));  
    } catch (Exception ex) {  
        log.error(&quot;create user failed because {}&quot;, ex.getMessage());  
    }  
    return userRepository.findByName(name).size();  
}  

//标记了@Transactional 的 private 方法  
@Transactional  
private void createUserPrivate(UserEntity entity) {  
    userRepository.save(entity);  
    if (entity.getName().contains(&quot;test&quot;))  
        throw new RuntimeException(&quot;invalid username!&quot;);  
}  

//根据用户名查询用户数  
public int getUserCount(String name) {  
    return userRepository.findByName(name).size();  
}  
</code></pre>
<p>}</p>
<p>下面是 Controller 的实现，只是调用一下刚才定义的 UserService 中的入口方法 createUserWrong1。</p>
<p>@Autowired<br>
private UserService userService;</p>
<p>@GetMapping(&ldquo;wrong1&rdquo;)<br>
public int wrong1(@RequestParam(&ldquo;name&rdquo;) String name) {<br>
return userService.createUserWrong1(name);<br>
}</p>
<p>调用接口后发现，即便用户名不合法，用户也能创建成功。刷新浏览器，多次发现有十几个的非法用户注册。</p>
<p>这里给出 @Transactional 生效原则 1，<strong>除非特殊配置（比如使用 AspectJ 静态织入实现 AOP），否则只有定义在 public 方法上的 @Transactional 才能生效</strong>。原因是，Spring 默认通过动态代理的方式实现 AOP，对目标方法进行增强，private 方法无法代理到，Spring 自然也无法动态增强事务处理逻辑。</p>
<p>你可能会说，修复方式很简单，把标记了事务注解的 createUserPrivate 方法改为 public 即可。在 UserService 中再建一个入口方法 createUserWrong2，来调用这个 public 方法再次尝试：</p>
<p>public int createUserWrong2(String name) {<br>
try {<br>
this.createUserPublic(new UserEntity(name));<br>
} catch (Exception ex) {<br>
log.error(&ldquo;create user failed because {}&rdquo;, ex.getMessage());<br>
}<br>
return userRepository.findByName(name).size();<br>
}</p>
<p>//标记了@Transactional 的 public 方法<br>
@Transactional<br>
public void createUserPublic(UserEntity entity) {<br>
userRepository.save(entity);<br>
if (entity.getName().contains(&ldquo;test&rdquo;))<br>
throw new RuntimeException(&ldquo;invalid username!&rdquo;);<br>
}</p>
<p>测试发现，调用新的 createUserWrong2 方法事务同样不生效。这里，我给出 @Transactional 生效原则 2，<strong>必须通过代理过的类从外部调用目标方法才能生效</strong>。</p>
<p>Spring 通过 AOP 技术对方法进行增强，要调用增强过的方法必然是调用代理后的对象。我们尝试修改下 UserService 的代码，注入一个 self，然后再通过 self 实例调用标记有 @Transactional 注解的 createUserPublic 方法。设置断点可以看到，self 是由 Spring 通过 CGLIB 方式增强过的类：</p>
<ol>
<li>CGLIB 通过继承方式实现代理类，private 方法在子类不可见，自然也就无法进行事务增强；</li>
<li>this 指针代表对象自己，Spring 不可能注入 this，所以通过 this 访问方法必然不是代理。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/0a179b90dad4cda79b04ca1ad72b9636.png" alt=""></p>
<p>把 this 改为 self 后测试发现，在 Controller 中调用 createUserRight 方法可以验证事务是生效的，非法的用户注册操作可以回滚。</p>
<p>虽然在 UserService 内部注入自己调用自己的 createUserPublic 可以正确实现事务，但更合理的实现方式是，让 Controller 直接调用之前定义的 UserService 的 createUserPublic 方法，因为注入自己调用自己很奇怪，也不符合分层实现的规范：</p>
<p>@GetMapping(&ldquo;right2&rdquo;)<br>
public int right2(@RequestParam(&ldquo;name&rdquo;) String name) {<br>
try {<br>
userService.createUserPublic(new UserEntity(name));<br>
} catch (Exception ex) {<br>
log.error(&ldquo;create user failed because {}&rdquo;, ex.getMessage());<br>
}<br>
return userService.getUserCount(name);<br>
}</p>
<p>我们再通过一张图来回顾下 this 自调用、通过 self 调用，以及在 Controller 中调用 UserService 三种实现的区别：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/1ade6f631690a4ed8f1db14e70e3d170.png" alt=""></p>
<p>通过 this 自调用，没有机会走到 Spring 的代理类；后两种改进方案调用的是 Spring 注入的 UserService，通过代理调用才有机会对 createUserPublic 方法进行动态增强。</p>
<p>这里，我还有一个小技巧，<strong>强烈建议你在开发时打开相关的 Debug 日志，以方便了解 Spring 事务实现的细节，并及时判断事务的执行情况</strong>。</p>
<p>我们的 Demo 代码使用 JPA 进行数据库访问，可以这么开启 Debug 日志：</p>
<p>logging.level.org.springframework.orm.jpa=DEBUG</p>
<p>开启日志后，我们再比较下在 UserService 中通过 this 调用和在 Controller 中通过注入的 UserService Bean 调用 createUserPublic 区别。很明显，this 调用因为没有走代理，事务没有在 createUserPublic 方法上生效，只在 Repository 的 save 方法层面生效：</p>
<p>//在 UserService 中通过 this 调用 public 的 createUserPublic<br>
[10:10:19.913] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :370 ] - Creating new transaction with name [org.springframework.data.jpa.repository.support.SimpleJpaRepository.save]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT<br>
//在 Controller 中通过注入的 UserService Bean 调用 createUserPublic<br>
[10:10:47.750] [http-nio-45678-exec-6] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :370 ] - Creating new transaction with name [org.geekbang.time.commonmistakes.transaction.demo1.UserService.createUserPublic]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</p>
<p>你可能还会考虑一个问题，这种实现在 Controller 里处理了异常显得有点繁琐，还不如直接把 createUserWrong2 方法加上 @Transactional 注解，然后在 Controller 中直接调用这个方法。这样一来，既能从外部（Controller 中）调用 UserService 中的方法，方法又是 public 的能够被动态代理 AOP 增强。</p>
<p>你可以试一下这种方法，但很容易就会踩第二个坑，即因为没有正确处理异常，导致事务即便生效也不一定能回滚。</p>
<h2 id="事务即便生效也不一定能回滚">事务即便生效也不一定能回滚</h2>
<p>通过 AOP 实现事务处理可以理解为，使用 try…catch…来包裹标记了 @Transactional 注解的方法，<strong>当方法出现了异常并且满足一定条件的时候</strong>，在 catch 里面我们可以设置事务回滚，没有异常则直接提交事务。</p>
<p>这里的“一定条件”，主要包括两点。</p>
<p>第一，<strong>只有异常传播出了标记了 @Transactional 注解的方法，事务才能回滚</strong>。在 Spring 的 TransactionAspectSupport 里有个 invokeWithinTransaction 方法，里面就是处理事务的逻辑。可以看到，只有捕获到异常才能进行后续事务处理：</p>
<p>try {<br>
// This is an around advice: Invoke the next interceptor in the chain.<br>
// This will normally result in a target object being invoked.<br>
retVal = invocation.proceedWithInvocation();<br>
}<br>
catch (Throwable ex) {<br>
// target invocation exception<br>
completeTransactionAfterThrowing(txInfo, ex);<br>
throw ex;<br>
}<br>
finally {<br>
cleanupTransactionInfo(txInfo);<br>
}</p>
<p>第二，<strong>默认情况下，出现 RuntimeException（非受检异常）或 Error 的时候，Spring 才会回滚事务</strong>。</p>
<p>打开 Spring 的 DefaultTransactionAttribute 类能看到如下代码块，可以发现相关证据，通过注释也能看到 Spring 这么做的原因，大概的意思是受检异常一般是业务异常，或者说是类似另一种方法的返回值，出现这样的异常可能业务还能完成，所以不会主动回滚；而 Error 或 RuntimeException 代表了非预期的结果，应该回滚：</p>
<p>/**</p>
<ul>
<li>The default behavior is as with EJB: rollback on unchecked exception</li>
<li>({@link RuntimeException}), assuming an unexpected outcome outside of any</li>
<li>business rules. Additionally, we also attempt to rollback on {@link Error} which</li>
<li>is clearly an unexpected outcome as well. By contrast, a checked exception is</li>
<li>considered a business exception and therefore a regular expected outcome of the</li>
<li>transactional business method, i.e. a kind of alternative return value which</li>
<li>still allows for regular completion of resource operations.</li>
<li>
<p>This is largely consistent with TransactionTemplate's default behavior,  
</li>
<li>except that TransactionTemplate also rolls back on undeclared checked exceptions</li>
<li>(a corner case). For declarative transactions, we expect checked exceptions to be</li>
<li>intentionally declared as business exceptions, leading to a commit by default.</li>
<li>@see org.springframework.transaction.support.TransactionTemplate#execute<br>
*/<br>
@Override<br>
public boolean rollbackOn(Throwable ex) {<br>
return (ex instanceof RuntimeException || ex instanceof Error);<br>
}</li>
</ul>
<p>接下来，我和你分享 2 个反例。</p>
<p>重新实现一下 UserService 中的注册用户操作：</p>
<ol>
<li>在 createUserWrong1 方法中会抛出一个 RuntimeException，但由于方法内 catch 了所有异常，异常无法从方法传播出去，事务自然无法回滚。</li>
<li>在 createUserWrong2 方法中，注册用户的同时会有一次 otherTask 文件读取操作，如果文件读取失败，我们希望用户注册的数据库操作回滚。虽然这里没有捕获异常，但因为 otherTask 方法抛出的是受检异常，createUserWrong2 传播出去的也是受检异常，事务同样不会回滚。</li>
</ol>
<p>@Service<br>
@Slf4j<br>
public class UserService {<br>
@Autowired<br>
private UserRepository userRepository;</p>
<pre><code>//异常无法传播出方法，导致事务无法回滚  
@Transactional  
public void createUserWrong1(String name) {  
    try {  
        userRepository.save(new UserEntity(name));  
        throw new RuntimeException(&quot;error&quot;);  
    } catch (Exception ex) {  
        log.error(&quot;create user failed&quot;, ex);  
    }  
}  

//即使出了受检异常也无法让事务回滚  
@Transactional  
public void createUserWrong2(String name) throws IOException {  
    userRepository.save(new UserEntity(name));  
    otherTask();  
}  

//因为文件不存在，一定会抛出一个 IOException  
private void otherTask() throws IOException {  
    Files.readAllLines(Paths.get(&quot;file-that-not-exist&quot;));  
}  
</code></pre>
<p>}</p>
<p>Controller 中的实现，仅仅是调用 UserService 的 createUserWrong1 和 createUserWrong2 方法，这里就贴出实现了。这 2 个方法的实现和调用，虽然完全避开了事务不生效的坑，但因为异常处理不当，导致程序没有如我们期望的文件操作出现异常时回滚事务。</p>
<p>现在，我们来看下修复方式，以及如何通过日志来验证是否修复成功。针对这 2 种情况，对应的修复方法如下。</p>
<p>第一，如果你希望自己捕获异常进行处理的话，也没关系，可以手动设置让当前事务处于回滚状态：</p>
<p>@Transactional<br>
public void createUserRight1(String name) {<br>
try {<br>
userRepository.save(new UserEntity(name));<br>
throw new RuntimeException(&ldquo;error&rdquo;);<br>
} catch (Exception ex) {<br>
log.error(&ldquo;create user failed&rdquo;, ex);<br>
TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();<br>
}<br>
}</p>
<p>运行后可以在日志中看到 Rolling back 字样，确认事务回滚了。同时，我们还注意到“Transactional code has requested rollback”的提示，表明手动请求回滚：</p>
<p>[22:14:49.352] [http-nio-45678-exec-4] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :698 ] - Transactional code has requested rollback<br>
[22:14:49.353] [http-nio-45678-exec-4] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :834 ] - Initiating transaction rollback<br>
[22:14:49.353] [http-nio-45678-exec-4] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :555 ] - Rolling back JPA transaction on EntityManager [SessionImpl(1906719643<open>)]</p>
<p>第二，在注解中声明，期望遇到所有的 Exception 都回滚事务（来突破默认不回滚受检异常的限制）：</p>
<p>@Transactional(rollbackFor = Exception.class)<br>
public void createUserRight2(String name) throws IOException {<br>
userRepository.save(new UserEntity(name));<br>
otherTask();<br>
}</p>
<p>运行后，同样可以在日志中看到回滚的提示：</p>
<p>[22:10:47.980] [http-nio-45678-exec-4] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :834 ] - Initiating transaction rollback<br>
[22:10:47.981] [http-nio-45678-exec-4] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :555 ] - Rolling back JPA transaction on EntityManager [SessionImpl(1419329213<open>)]</p>
<p>在这个例子中，我们展现的是一个复杂的业务逻辑，其中有数据库操作、IO 操作，在 IO 操作出现问题时希望让数据库事务也回滚，以确保逻辑的一致性。在有些业务逻辑中，可能会包含多次数据库操作，我们不一定希望将两次操作作为一个事务来处理，这时候就需要仔细考虑事务传播的配置了，否则也可能踩坑。</p>
<h2 id="请确认事务传播配置是否符合自己的业务逻辑">请确认事务传播配置是否符合自己的业务逻辑</h2>
<p>有这么一个场景：一个用户注册的操作，会插入一个主用户到用户表，还会注册一个关联的子用户。我们希望将子用户注册的数据库操作作为一个独立事务来处理，即使失败也不会影响主流程，即不影响主用户的注册。</p>
<p>接下来，我们模拟一个实现类似业务逻辑的 UserService：</p>
<p>@Autowired<br>
private UserRepository userRepository;</p>
<p>@Autowired<br>
private SubUserService subUserService;</p>
<p>@Transactional<br>
public void createUserWrong(UserEntity entity) {<br>
createMainUser(entity);<br>
subUserService.createSubUserWithExceptionWrong(entity);<br>
}</p>
<p>private void createMainUser(UserEntity entity) {<br>
userRepository.save(entity);<br>
log.info(&ldquo;createMainUser finish&rdquo;);<br>
}</p>
<p>SubUserService 的 createSubUserWithExceptionWrong 实现正如其名，因为最后我们抛出了一个运行时异常，错误原因是用户状态无效，所以子用户的注册肯定是失败的。我们期望子用户的注册作为一个事务单独回滚，不影响主用户的注册，这样的逻辑可以实现吗？</p>
<p>@Service<br>
@Slf4j<br>
public class SubUserService {</p>
<pre><code>@Autowired  
private UserRepository userRepository;  

@Transactional  
public void createSubUserWithExceptionWrong(UserEntity entity) {  
    log.info(&quot;createSubUserWithExceptionWrong start&quot;);  
    userRepository.save(entity);  
    throw new RuntimeException(&quot;invalid status&quot;);  
}  
</code></pre>
<p>}</p>
<p>我们在 Controller 里实现一段测试代码，调用 UserService：</p>
<p>@GetMapping(&ldquo;wrong&rdquo;)<br>
public int wrong(@RequestParam(&ldquo;name&rdquo;) String name) {<br>
try {<br>
userService.createUserWrong(new UserEntity(name));<br>
} catch (Exception ex) {<br>
log.error(&ldquo;createUserWrong failed, reason:{}&rdquo;, ex.getMessage());<br>
}<br>
return userService.getUserCount(name);<br>
}</p>
<p>调用后可以在日志中发现如下信息，很明显事务回滚了，最后 Controller 打出了创建子用户抛出的运行时异常：</p>
<p>[22:50:42.866] [http-nio-45678-exec-8] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :555 ] - Rolling back JPA transaction on EntityManager [SessionImpl(103972212<open>)]<br>
[22:50:42.869] [http-nio-45678-exec-8] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :620 ] - Closing JPA EntityManager [SessionImpl(103972212<open>)] after transaction<br>
[22:50:42.869] [http-nio-45678-exec-8] [ERROR] [t.d.TransactionPropagationController:23  ] - createUserWrong failed, reason:invalid status</p>
<p>你马上就会意识到，不对呀，因为运行时异常逃出了 @Transactional 注解标记的 createUserWrong 方法，Spring 当然会回滚事务了。如果我们希望主方法不回滚，应该把子方法抛出的异常捕获了。</p>
<p>也就是这么改，把 subUserService.createSubUserWithExceptionWrong 包裹上 catch，这样外层主方法就不会出现异常了：</p>
<p>@Transactional<br>
public void createUserWrong2(UserEntity entity) {<br>
createMainUser(entity);<br>
try{<br>
subUserService.createSubUserWithExceptionWrong(entity);<br>
} catch (Exception ex) {<br>
// 虽然捕获了异常，但是因为没有开启新事务，而当前事务因为异常已经被标记为 rollback 了，所以最终还是会回滚。<br>
log.error(&ldquo;create sub user error:{}&rdquo;, ex.getMessage());<br>
}<br>
}</p>
<p>运行程序后可以看到如下日志：</p>
<p>[22:57:21.722] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :370 ] - Creating new transaction with name [org.geekbang.time.commonmistakes.transaction.demo3.UserService.createUserWrong2]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT<br>
[22:57:21.739] [http-nio-45678-exec-3] [INFO ] [t.c.transaction.demo3.SubUserService:19  ] - createSubUserWithExceptionWrong start<br>
[22:57:21.739] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :356 ] - Found thread-bound EntityManager [SessionImpl(1794007607<open>)] for JPA transaction<br>
[22:57:21.739] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :471 ] - Participating in existing transaction<br>
[22:57:21.740] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :843 ] - Participating transaction failed - marking existing transaction as rollback-only<br>
[22:57:21.740] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :580 ] - Setting JPA transaction on EntityManager [SessionImpl(1794007607<open>)] rollback-only<br>
[22:57:21.740] [http-nio-45678-exec-3] [ERROR] [.g.t.c.transaction.demo3.UserService:37  ] - create sub user error:invalid status<br>
[22:57:21.740] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :741 ] - Initiating transaction commit<br>
[22:57:21.740] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :529 ] - Committing JPA transaction on EntityManager [SessionImpl(1794007607<open>)]<br>
[22:57:21.743] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :620 ] - Closing JPA EntityManager [SessionImpl(1794007607<open>)] after transaction<br>
[22:57:21.743] [http-nio-45678-exec-3] [ERROR] [t.d.TransactionPropagationController:33  ] - createUserWrong2 failed, reason:Transaction silently rolled back because it has been marked as rollback-only<br>
org.springframework.transaction.UnexpectedRollbackException: Transaction silently rolled back because it has been marked as rollback-only<br>
&hellip;</p>
<p>需要注意以下几点：</p>
<ol>
<li>如第 1 行所示，对 createUserWrong2 方法开启了异常处理；</li>
<li>如第 5 行所示，子方法因为出现了运行时异常，标记当前事务为回滚；</li>
<li>如第 7 行所示，主方法的确捕获了异常打印出了 create sub user error 字样；</li>
<li>如第 9 行所示，主方法提交了事务；</li>
<li>奇怪的是，如第 11 行和 12 行所示，<strong>Controller 里出现了一个 UnexpectedRollbackException，异常描述提示最终这个事务回滚了，而且是静默回滚的</strong>。之所以说是静默，是因为 createUserWrong2 方法本身并没有出异常，只不过提交后发现子方法已经把当前事务设置为了回滚，无法完成提交。</li>
</ol>
<p>这挺反直觉的。<strong>我们之前说，出了异常事务不一定回滚，这里说的却是不出异常，事务也不一定可以提交</strong>。原因是，主方法注册主用户的逻辑和子方法注册子用户的逻辑是同一个事务，子逻辑标记了事务需要回滚，主逻辑自然也不能提交了。</p>
<p>看到这里，修复方式就很明确了，想办法让子逻辑在独立事务中运行，也就是改一下 SubUserService 注册子用户的方法，为注解加上 propagation = Propagation.REQUIRES_NEW 来设置 REQUIRES_NEW 方式的事务传播策略，也就是执行到这个方法时需要开启新的事务，并挂起当前事务：</p>
<p>@Transactional(propagation = Propagation.REQUIRES_NEW)<br>
public void createSubUserWithExceptionRight(UserEntity entity) {<br>
log.info(&ldquo;createSubUserWithExceptionRight start&rdquo;);<br>
userRepository.save(entity);<br>
throw new RuntimeException(&ldquo;invalid status&rdquo;);<br>
}</p>
<p>主方法没什么变化，同样需要捕获异常，防止异常漏出去导致主事务回滚，重新命名为 createUserRight：</p>
<p>@Transactional<br>
public void createUserRight(UserEntity entity) {<br>
createMainUser(entity);<br>
try{<br>
subUserService.createSubUserWithExceptionRight(entity);<br>
} catch (Exception ex) {<br>
// 捕获异常，防止主方法回滚<br>
log.error(&ldquo;create sub user error:{}&rdquo;, ex.getMessage());<br>
}<br>
}</p>
<p>改造后，重新运行程序可以看到如下的关键日志：</p>
<ol>
<li>第 1 行日志提示我们针对 createUserRight 方法开启了主方法的事务；</li>
<li>第 2 行日志提示创建主用户完成；</li>
<li>第 3 行日志可以看到主事务挂起了，开启了一个新的事务，针对 createSubUserWithExceptionRight 方案，也就是我们的创建子用户的逻辑；</li>
<li>第 4 行日志提示子方法事务回滚；</li>
<li>第 5 行日志提示子方法事务完成，继续主方法之前挂起的事务；</li>
<li>第 6 行日志提示主方法捕获到了子方法的异常；</li>
<li>第 8 行日志提示主方法的事务提交了，随后我们在 Controller 里没看到静默回滚的异常。</li>
</ol>
<p>[23:17:20.935] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :370 ] - Creating new transaction with name [org.geekbang.time.commonmistakes.transaction.demo3.UserService.createUserRight]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT<br>
[23:17:21.079] [http-nio-45678-exec-1] [INFO ] [.g.t.c.transaction.demo3.UserService:55  ] - createMainUser finish<br>
[23:17:21.082] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :420 ] - Suspending current transaction, creating new transaction with name [org.geekbang.time.commonmistakes.transaction.demo3.SubUserService.createSubUserWithExceptionRight]<br>
[23:17:21.153] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :834 ] - Initiating transaction rollback<br>
[23:17:21.160] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :1009] - Resuming suspended transaction after completion of inner transaction<br>
[23:17:21.161] [http-nio-45678-exec-1] [ERROR] [.g.t.c.transaction.demo3.UserService:49  ] - create sub user error:invalid status<br>
[23:17:21.161] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :741 ] - Initiating transaction commit<br>
[23:17:21.161] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :529 ] - Committing JPA transaction on EntityManager [SessionImpl(396441411<open>)]</p>
<p>运行测试程序看到如下结果，getUserCount 得到的用户数量为 1，代表只有一个用户也就是主用户注册完成了，符合预期：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/a4ebbdc0b679c8790edf728a7509e5d2.png" alt=""></p>
<h2 id="重点回顾">重点回顾</h2>
<p>今天，我针对业务代码中最常见的使用数据库事务的方式，即 Spring 声明式事务，与你总结了使用上可能遇到的三类坑，包括：</p>
<p>第一，因为配置不正确，导致方法上的事务没生效。我们务必确认调用 @Transactional 注解标记的方法是 public 的，并且是通过 Spring 注入的 Bean 进行调用的。</p>
<p>第二，因为异常处理不正确，导致事务虽然生效但出现异常时没回滚。Spring 默认只会对标记 @Transactional 注解的方法出现了 RuntimeException 和 Error 的时候回滚，如果我们的方法捕获了异常，那么需要通过手动编码处理事务回滚。如果希望 Spring 针对其他异常也可以回滚，那么可以相应配置 @Transactional 注解的 rollbackFor 和 noRollbackFor 属性来覆盖其默认设置。</p>
<p>第三，如果方法涉及多次数据库操作，并希望将它们作为独立的事务进行提交或回滚，那么我们需要考虑进一步细化配置事务传播方式，也就是 @Transactional 注解的 Propagation 属性。</p>
<p>可见，正确配置事务可以提高业务项目的健壮性。但，又因为健壮性问题往往体现在异常情况或一些细节处理上，很难在主流程的运行和测试中发现，导致业务代码的事务处理逻辑往往容易被忽略，因此<strong>我在代码审查环节一直很关注事务是否正确处理</strong>。</p>
<p>如果你无法确认事务是否真正生效，是否按照预期的逻辑进行，可以尝试打开 Spring 的部分 Debug 日志，通过事务的运作细节来验证。也建议你在单元测试时尽量覆盖多的异常场景，这样在重构时，也能及时发现因为方法的调用方式、异常处理逻辑的调整，导致的事务失效问题。</p>
<p>今天用到的代码，我都放在了 GitHub 上，你可以点击这个链接查看。</p>
<h2 id="思考与讨论">思考与讨论</h2>
<ol>
<li>考虑到 Demo 的简洁，文中所有数据访问使用的都是 Spring Data JPA。国内大多数互联网业务项目是使用 MyBatis 进行数据访问的，使用 MyBatis 配合 Spring 的声明式事务也同样需要注意文中提到的这些点。你可以尝试把今天的 Demo 改为 MyBatis 做数据访问实现，看看日志中是否可以体现出这些坑。</li>
<li>在第一节中我们提到，如果要针对 private 方法启用事务，动态代理方式的 AOP 不可行，需要使用静态织入方式的 AOP，也就是在编译期间织入事务增强代码，可以配置 Spring 框架使用 AspectJ 来实现 AOP。你能否参阅 Spring 的文档“Using @Transactional with AspectJ”试试呢？注意：AspectJ 配合 lombok 使用，还可能会踩一些坑。</li>
</ol>
<p>有关数据库事务，你还遇到过去其他坑吗？我是朱晔，欢迎在评论区与我留言分享，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/">Java业务开发常见错误100例</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/06__0-1%E8%83%8C%E5%8C%85%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84hello_world/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">06__0-1背包：动态规划的Hello_World</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AF%B4%E9%80%8F5g/06__5g%E5%85%B3%E9%94%AE%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84/">
            <span class="next-text nav-default">06__5G关键性能指标是如何通过无线技术来实现的？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
