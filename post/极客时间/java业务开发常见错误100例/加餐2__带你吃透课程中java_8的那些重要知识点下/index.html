<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>加餐2__带你吃透课程中Java_8的那些重要知识点（下） - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是朱晔。
上一讲的几个例子中，其实都涉及了 Stream API 的最基本使用方法。今天，我会与你详细介绍复杂、功能强大的 Stream API。
Stream 流式操作，用于对集合进行投影、转换、过滤、排序等，更进一步地，这些操作能链式串联在一起使用，类似于 SQL 语句，可以大大简化代码。可以说，Stream 操作是 Java 8 中最重要的内容，也是这个课程大部分代码都会用到的操作。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/%E5%8A%A0%E9%A4%902__%E5%B8%A6%E4%BD%A0%E5%90%83%E9%80%8F%E8%AF%BE%E7%A8%8B%E4%B8%ADjava_8%E7%9A%84%E9%82%A3%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/%E5%8A%A0%E9%A4%902__%E5%B8%A6%E4%BD%A0%E5%90%83%E9%80%8F%E8%AF%BE%E7%A8%8B%E4%B8%ADjava_8%E7%9A%84%E9%82%A3%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="加餐2__带你吃透课程中Java_8的那些重要知识点（下）">
  <meta property="og:description" content="你好，我是朱晔。
上一讲的几个例子中，其实都涉及了 Stream API 的最基本使用方法。今天，我会与你详细介绍复杂、功能强大的 Stream API。
Stream 流式操作，用于对集合进行投影、转换、过滤、排序等，更进一步地，这些操作能链式串联在一起使用，类似于 SQL 语句，可以大大简化代码。可以说，Stream 操作是 Java 8 中最重要的内容，也是这个课程大部分代码都会用到的操作。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Java业务开发常见错误100例">

  <meta itemprop="name" content="加餐2__带你吃透课程中Java_8的那些重要知识点（下）">
  <meta itemprop="description" content="你好，我是朱晔。
上一讲的几个例子中，其实都涉及了 Stream API 的最基本使用方法。今天，我会与你详细介绍复杂、功能强大的 Stream API。
Stream 流式操作，用于对集合进行投影、转换、过滤、排序等，更进一步地，这些操作能链式串联在一起使用，类似于 SQL 语句，可以大大简化代码。可以说，Stream 操作是 Java 8 中最重要的内容，也是这个课程大部分代码都会用到的操作。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4657">
  <meta itemprop="keywords" content="Java业务开发常见错误100例">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="加餐2__带你吃透课程中Java_8的那些重要知识点（下）">
  <meta name="twitter:description" content="你好，我是朱晔。
上一讲的几个例子中，其实都涉及了 Stream API 的最基本使用方法。今天，我会与你详细介绍复杂、功能强大的 Stream API。
Stream 流式操作，用于对集合进行投影、转换、过滤、排序等，更进一步地，这些操作能链式串联在一起使用，类似于 SQL 语句，可以大大简化代码。可以说，Stream 操作是 Java 8 中最重要的内容，也是这个课程大部分代码都会用到的操作。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">加餐2__带你吃透课程中Java_8的那些重要知识点（下）</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4657 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#stream-操作详解">Stream 操作详解</a>
          <ul>
            <li><a href="#创建流">创建流</a></li>
            <li><a href="#filter">filter</a></li>
            <li><a href="#map">map</a></li>
            <li><a href="#flatmap">flatMap</a></li>
            <li><a href="#sorted">sorted</a></li>
            <li><a href="#distinct">distinct</a></li>
            <li><a href="#skip--limit">skip &amp; limit</a></li>
            <li><a href="#collect">collect</a></li>
            <li><a href="#groupby">groupBy</a></li>
            <li><a href="#partitionby">partitionBy</a></li>
          </ul>
        </li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考与讨论">思考与讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是朱晔。</p>
<p>上一讲的几个例子中，其实都涉及了 Stream API 的最基本使用方法。今天，我会与你详细介绍复杂、功能强大的 Stream API。</p>
<p>Stream 流式操作，用于对集合进行投影、转换、过滤、排序等，更进一步地，这些操作能链式串联在一起使用，类似于 SQL 语句，可以大大简化代码。可以说，Stream 操作是 Java 8 中最重要的内容，也是这个课程大部分代码都会用到的操作。</p>
<p>我先说明下，有些案例可能不太好理解，建议你对着代码逐一到源码中查看 Stream 操作的方法定义，以及 JDK 中的代码注释。</p>
<h2 id="stream-操作详解">Stream 操作详解</h2>
<p>为了方便你理解 Stream 的各种操作，以及后面的案例，我先把这节课涉及的 Stream 操作汇总到了一张图中。你可以先熟悉一下。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/8f221e71981c11c25831c66d4ba4d9b9.png" alt=""></p>
<p>在接下来的讲述中，我会围绕订单场景，给出如何使用 Stream 的各种 API 完成订单的统计、搜索、查询等功能，和你一起学习 Stream 流式操作的各种方法。你可以结合代码中的注释理解案例，也可以自己运行源码观察输出。</p>
<p>我们先定义一个订单类、一个订单商品类和一个顾客类，用作后续 Demo 代码的数据结构：</p>
<p>//订单类<br>
@Data<br>
public class Order {<br>
private Long id;<br>
private Long customerId;//顾客 ID<br>
private String customerName;//顾客姓名<br>
private List<OrderItem> orderItemList;//订单商品明细<br>
private Double totalPrice;//总价格<br>
private LocalDateTime placedAt;//下单时间<br>
}<br>
//订单商品类<br>
@Data<br>
@AllArgsConstructor<br>
@NoArgsConstructor<br>
public class OrderItem {<br>
private Long productId;//商品 ID<br>
private String productName;//商品名称<br>
private Double productPrice;//商品价格<br>
private Integer productQuantity;//商品数量<br>
}<br>
//顾客类<br>
@Data<br>
@AllArgsConstructor<br>
public class Customer {<br>
private Long id;<br>
private String name;//顾客姓名<br>
}</p>
<p>在这里，我们有一个 orders 字段保存了一些模拟数据，类型是 List。这里，我就不贴出生成模拟数据的代码了。这不会影响你理解后面的代码，你也可以自己下载源码阅读。</p>
<h3 id="创建流">创建流</h3>
<p>要使用流，就要先创建流。创建流一般有五种方式：</p>
<ol>
<li>通过 stream 方法把 List 或数组转换为流；</li>
<li>通过 Stream.of 方法直接传入多个元素构成一个流；</li>
<li>通过 Stream.iterate 方法使用迭代的方式构造一个无限流，然后使用 limit 限制流元素个数；</li>
<li>通过 Stream.generate 方法从外部传入一个提供元素的 Supplier 来构造无限流，然后使用 limit 限制流元素个数；</li>
<li>通过 IntStream 或 DoubleStream 构造基本类型的流。</li>
</ol>
<p>//通过 stream 方法把 List 或数组转换为流<br>
@Test<br>
public void stream()<br>
{<br>
Arrays.asList(&ldquo;a1&rdquo;, &ldquo;a2&rdquo;, &ldquo;a3&rdquo;).stream().forEach(System.out::println);<br>
Arrays.stream(new int[]{1, 2, 3}).forEach(System.out::println);<br>
}</p>
<p>//通过 Stream.of 方法直接传入多个元素构成一个流<br>
@Test<br>
public void of()<br>
{<br>
String[] arr = {&ldquo;a&rdquo;, &ldquo;b&rdquo;, &ldquo;c&rdquo;};<br>
Stream.of(arr).forEach(System.out::println);<br>
Stream.of(&ldquo;a&rdquo;, &ldquo;b&rdquo;, &ldquo;c&rdquo;).forEach(System.out::println);<br>
Stream.of(1, 2, &ldquo;a&rdquo;).map(item -&gt; item.getClass().getName()).forEach(System.out::println);<br>
}</p>
<p>//通过 Stream.iterate 方法使用迭代的方式构造一个无限流，然后使用 limit 限制流元素个数<br>
@Test<br>
public void iterate()<br>
{<br>
Stream.iterate(2, item -&gt; item * 2).limit(10).forEach(System.out::println);<br>
Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.TEN)).limit(10).forEach(System.out::println);<br>
}</p>
<p>//通过 Stream.generate 方法从外部传入一个提供元素的 Supplier 来构造无限流，然后使用 limit 限制流元素个数<br>
@Test<br>
public void generate()<br>
{<br>
Stream.generate(() -&gt; &ldquo;test&rdquo;).limit(3).forEach(System.out::println);<br>
Stream.generate(Math::random).limit(10).forEach(System.out::println);<br>
}</p>
<p>//通过 IntStream 或 DoubleStream 构造基本类型的流<br>
@Test<br>
public void primitive()<br>
{<br>
//演示 IntStream 和 DoubleStream<br>
IntStream.range(1, 3).forEach(System.out::println);<br>
IntStream.range(0, 3).mapToObj(i -&gt; &ldquo;x&rdquo;).forEach(System.out::println);</p>
<pre><code>IntStream.rangeClosed(1, 3).forEach(System.out::println);  
DoubleStream.of(1.1, 2.2, 3.3).forEach(System.out::println);  

//各种转换，后面注释代表了输出结果  
System.out.println(IntStream.of(1, 2).toArray().getClass()); //class [I  
System.out.println(Stream.of(1, 2).mapToInt(Integer::intValue).toArray().getClass()); //class [I  
System.out.println(IntStream.of(1, 2).boxed().toArray().getClass()); //class [Ljava.lang.Object;  
System.out.println(IntStream.of(1, 2).asDoubleStream().toArray().getClass()); //class [D  
System.out.println(IntStream.of(1, 2).asLongStream().toArray().getClass()); //class [J  

//注意基本类型流和装箱后的流的区别  
Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).stream()   // Stream&lt;String&gt;  
        .mapToInt(String::length)       // IntStream  
        .asLongStream()                 // LongStream  
        .mapToDouble(x -&gt; x / 10.0)     // DoubleStream  
        .boxed()                        // Stream&lt;Double&gt;  
        .mapToLong(x -&gt; 1L)             // LongStream  
        .mapToObj(x -&gt; &quot;&quot;)              // Stream&lt;String&gt;  
        .collect(Collectors.toList());  
</code></pre>
<p>}</p>
<h3 id="filter">filter</h3>
<p>filter 方法可以实现过滤操作，类似 SQL 中的 where。我们可以使用一行代码，通过 filter 方法实现查询所有订单中最近半年金额大于 40 的订单，通过连续叠加 filter 方法进行多次条件过滤：</p>
<p>//最近半年的金额大于 40 的订单<br>
orders.stream()<br>
.filter(Objects::nonNull) //过滤 null 值<br>
.filter(order -&gt; order.getPlacedAt().isAfter(LocalDateTime.now().minusMonths(6))) //最近半年的订单<br>
.filter(order -&gt; order.getTotalPrice() &gt; 40) //金额大于 40 的订单<br>
.forEach(System.out::println);</p>
<p>如果不使用 Stream 的话，必然需要一个中间集合来收集过滤后的结果，而且所有的过滤条件会堆积在一起，代码冗长且不易读。</p>
<h3 id="map">map</h3>
<p>map 操作可以做转换（或者说投影），类似 SQL 中的 select。为了对比，我用两种方式统计订单中所有商品的数量，前一种是通过两次遍历实现，后一种是通过两次 mapToLong+sum 方法实现：</p>
<p>//计算所有订单商品数量<br>
//通过两次遍历实现<br>
LongAdder longAdder = new LongAdder();<br>
orders.stream().forEach(order -&gt;<br>
order.getOrderItemList().forEach(orderItem -&gt; longAdder.add(orderItem.getProductQuantity())));</p>
<p>//使用两次 mapToLong+sum 方法实现<br>
assertThat(longAdder.longValue(), is(orders.stream().mapToLong(order -&gt;<br>
order.getOrderItemList().stream()<br>
.mapToLong(OrderItem::getProductQuantity).sum()).sum()));</p>
<p>显然，后一种方式无需中间变量 longAdder，更直观。</p>
<p>这里再补充一下，使用 for 循环生成数据，是我们平时常用的操作，也是这个课程会大量用到的。现在，我们可以用一行代码使用 IntStream 配合 mapToObj 替代 for 循环来生成数据，比如生成 10 个 Product 元素构成 List：</p>
<p>//把 IntStream 通过转换 Stream<Project><br>
System.out.println(IntStream.rangeClosed(1,10)<br>
.mapToObj(i-&gt;new Product((long)i, &ldquo;product&rdquo;+i, i*100.0))<br>
.collect(toList()));</p>
<h3 id="flatmap">flatMap</h3>
<p>接下来，我们看看 flatMap 展开或者叫扁平化操作，相当于 map+flat，通过 map 把每一个元素替换为一个流，然后展开这个流。</p>
<p>比如，我们要统计所有订单的总价格，可以有两种方式：</p>
<ol>
<li>直接通过原始商品列表的商品个数 * 商品单价统计的话，可以先把订单通过 flatMap 展开成商品清单，也就是把 Order 替换为 Stream，然后对每一个 OrderItem 用 mapToDouble 转换获得商品总价，最后进行一次 sum 求和；</li>
<li>利用 flatMapToDouble 方法把列表中每一项展开替换为一个 DoubleStream，也就是直接把每一个订单转换为每一个商品的总价，然后求和。</li>
</ol>
<p>//直接展开订单商品进行价格统计<br>
System.out.println(orders.stream()<br>
.flatMap(order -&gt; order.getOrderItemList().stream())<br>
.mapToDouble(item -&gt; item.getProductQuantity() * item.getProductPrice()).sum());</p>
<p>//另一种方式 flatMap+mapToDouble=flatMapToDouble<br>
System.out.println(orders.stream()<br>
.flatMapToDouble(order -&gt;<br>
order.getOrderItemList()<br>
.stream().mapToDouble(item -&gt; item.getProductQuantity() * item.getProductPrice()))<br>
.sum());</p>
<p>这两种方式可以得到相同的结果，并无本质区别。</p>
<h3 id="sorted">sorted</h3>
<p>sorted 操作可以用于行内排序的场景，类似 SQL 中的 order by。比如，要实现大于 50 元订单的按价格倒序取前 5，可以通过 Order::getTotalPrice 方法引用直接指定需要排序的依据字段，通过 reversed() 实现倒序：</p>
<p>//大于 50 的订单，按照订单价格倒序前 5<br>
orders.stream().filter(order -&gt; order.getTotalPrice() &gt; 50)<br>
.sorted(comparing(Order::getTotalPrice).reversed())<br>
.limit(5)<br>
.forEach(System.out::println);</p>
<h3 id="distinct">distinct</h3>
<p>distinct 操作的作用是去重，类似 SQL 中的 distinct。比如下面的代码实现：</p>
<ol>
<li>查询去重后的下单用户。使用 map 从订单提取出购买用户，然后使用 distinct 去重。</li>
<li>查询购买过的商品名。使用 flatMap+map 提取出订单中所有的商品名，然后使用 distinct 去重。</li>
</ol>
<p>//去重的下单用户<br>
System.out.println(orders.stream().map(order -&gt; order.getCustomerName()).distinct().collect(joining(&quot;,&quot;)));</p>
<p>//所有购买过的商品<br>
System.out.println(orders.stream()<br>
.flatMap(order -&gt; order.getOrderItemList().stream())<br>
.map(OrderItem::getProductName)<br>
.distinct().collect(joining(&quot;,&quot;)));</p>
<h3 id="skip--limit">skip &amp; limit</h3>
<p>skip 和 limit 操作用于分页，类似 MySQL 中的 limit。其中，skip 实现跳过一定的项，limit 用于限制项总数。比如下面的两段代码：</p>
<ol>
<li>按照下单时间排序，查询前 2 个订单的顾客姓名和下单时间；</li>
<li>按照下单时间排序，查询第 3 和第 4 个订单的顾客姓名和下单时间。</li>
</ol>
<p>//按照下单时间排序，查询前 2 个订单的顾客姓名和下单时间<br>
orders.stream()<br>
.sorted(comparing(Order::getPlacedAt))<br>
.map(order -&gt; order.getCustomerName() + &ldquo;@&rdquo; + order.getPlacedAt())<br>
.limit(2).forEach(System.out::println);<br>
//按照下单时间排序，查询第 3 和第 4 个订单的顾客姓名和下单时间<br>
orders.stream()<br>
.sorted(comparing(Order::getPlacedAt))<br>
.map(order -&gt; order.getCustomerName() + &ldquo;@&rdquo; + order.getPlacedAt())<br>
.skip(2).limit(2).forEach(System.out::println);</p>
<h3 id="collect">collect</h3>
<p>collect 是收集操作，对流进行终结（终止）操作，把流导出为我们需要的数据结构。“终结”是指，导出后，无法再串联使用其他中间操作，比如 filter、map、flatmap、sorted、distinct、limit、skip。</p>
<p>在 Stream 操作中，collect 是最复杂的终结操作，比较简单的终结操作还有 forEach、toArray、min、max、count、anyMatch 等，我就不再展开了，你可以查询JDK 文档，搜索 terminal operation 或 intermediate operation。</p>
<p>接下来，我通过 6 个案例，来演示下几种比较常用的 collect 操作：</p>
<ol>
<li>第一个案例，实现了字符串拼接操作，生成一定位数的随机字符串。</li>
<li>第二个案例，通过 Collectors.toSet 静态方法收集为 Set 去重，得到去重后的下单用户，再通过 Collectors.joining 静态方法实现字符串拼接。</li>
<li>第三个案例，通过 Collectors.toCollection 静态方法获得指定类型的集合，比如把 List转换为 LinkedList。</li>
<li>第四个案例，通过 Collectors.toMap 静态方法将对象快速转换为 Map，Key 是订单 ID、Value 是下单用户名。</li>
<li>第五个案例，通过 Collectors.toMap 静态方法将对象转换为 Map。Key 是下单用户名，Value 是下单时间，一个用户可能多次下单，所以直接在这里进行了合并，只获取最近一次的下单时间。</li>
<li>第六个案例，使用 Collectors.summingInt 方法对商品数量求和，再使用 Collectors.averagingInt 方法对结果求平均值，以统计所有订单平均购买的商品数量。</li>
</ol>
<p>//生成一定位数的随机字符串<br>
System.out.println(random.ints(48, 122)<br>
.filter(i -&gt; (i &lt; 57 || i &gt; 65) &amp;&amp; (i &lt; 90 || i &gt; 97))<br>
.mapToObj(i -&gt; (char) i)<br>
.limit(20)<br>
.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append)<br>
.toString());</p>
<p>//所有下单的用户，使用 toSet 去重后实现字符串拼接<br>
System.out.println(orders.stream()<br>
.map(order -&gt; order.getCustomerName()).collect(toSet())<br>
.stream().collect(joining(&quot;,&quot;, &ldquo;[&rdquo;, &ldquo;]&rdquo;)));</p>
<p>//用 toCollection 收集器指定集合类型<br>
System.out.println(orders.stream().limit(2).collect(toCollection(LinkedList::new)).getClass());</p>
<p>//使用 toMap 获取订单 ID+ 下单用户名的 Map<br>
orders.stream()<br>
.collect(toMap(Order::getId, Order::getCustomerName))<br>
.entrySet().forEach(System.out::println);</p>
<p>//使用 toMap 获取下单用户名 + 最近一次下单时间的 Map<br>
orders.stream()<br>
.collect(toMap(Order::getCustomerName, Order::getPlacedAt, (x, y) -&gt; x.isAfter(y) ? x : y))<br>
.entrySet().forEach(System.out::println);</p>
<p>//订单平均购买的商品数量<br>
System.out.println(orders.stream().collect(averagingInt(order -&gt;<br>
order.getOrderItemList().stream()<br>
.collect(summingInt(OrderItem::getProductQuantity)))));</p>
<p>可以看到，这 6 个操作使用 Stream 方式一行代码就可以实现，但使用非 Stream 方式实现的话，都需要几行甚至十几行代码。</p>
<p>有关 Collectors 类的一些常用静态方法，我总结到了一张图中，你可以再整理一下思路：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/30d109e029f2b98ba248f36479ecb69f.png" alt=""></p>
<p>其中，groupBy 和 partitionBy 比较复杂，我和你举例介绍。</p>
<h3 id="groupby">groupBy</h3>
<p>groupBy 是分组统计操作，类似 SQL 中的 group by 子句。它和后面介绍的 partitioningBy 都是特殊的收集器，同样也是终结操作。分组操作比较复杂，为帮你理解得更透彻，我准备了 8 个案例：</p>
<ol>
<li>第一个案例，按照用户名分组，使用 Collectors.counting 方法统计每个人的下单数量，再按照下单数量倒序输出。</li>
<li>第二个案例，按照用户名分组，使用 Collectors.summingDouble 方法统计订单总金额，再按总金额倒序输出。</li>
<li>第三个案例，按照用户名分组，使用两次 Collectors.summingInt 方法统计商品采购数量，再按总数量倒序输出。</li>
<li>第四个案例，统计被采购最多的商品。先通过 flatMap 把订单转换为商品，然后把商品名作为 Key、Collectors.summingInt 作为 Value 分组统计采购数量，再按 Value 倒序获取第一个 Entry，最后查询 Key 就得到了售出最多的商品。</li>
<li>第五个案例，同样统计采购最多的商品。相比第四个案例排序 Map 的方式，这次直接使用 Collectors.maxBy 收集器获得最大的 Entry。</li>
<li>第六个案例，按照用户名分组，统计用户下的金额最高的订单。Key 是用户名，Value 是 Order，直接通过 Collectors.maxBy 方法拿到金额最高的订单，然后通过 collectingAndThen 实现 Optional.get 的内容提取，最后遍历 Key/Value 即可。</li>
<li>第七个案例，根据下单年月分组统计订单 ID 列表。Key 是格式化成年月后的下单时间，Value 直接通过 Collectors.mapping 方法进行了转换，把订单列表转换为订单 ID 构成的 List。</li>
<li>第八个案例，根据下单年月 + 用户名两次分组统计订单 ID 列表，相比上一个案例多了一次分组操作，第二次分组是按照用户名进行分组。</li>
</ol>
<p>//按照用户名分组，统计下单数量<br>
System.out.println(orders.stream().collect(groupingBy(Order::getCustomerName, counting()))<br>
.entrySet().stream().sorted(Map.Entry.&lt;String, Long&gt;comparingByValue().reversed()).collect(toList()));</p>
<p>//按照用户名分组，统计订单总金额<br>
System.out.println(orders.stream().collect(groupingBy(Order::getCustomerName, summingDouble(Order::getTotalPrice)))<br>
.entrySet().stream().sorted(Map.Entry.&lt;String, Double&gt;comparingByValue().reversed()).collect(toList()));</p>
<p>//按照用户名分组，统计商品采购数量<br>
System.out.println(orders.stream().collect(groupingBy(Order::getCustomerName,<br>
summingInt(order -&gt; order.getOrderItemList().stream()<br>
.collect(summingInt(OrderItem::getProductQuantity)))))<br>
.entrySet().stream().sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed()).collect(toList()));</p>
<p>//统计最受欢迎的商品，倒序后取第一个<br>
orders.stream()<br>
.flatMap(order -&gt; order.getOrderItemList().stream())<br>
.collect(groupingBy(OrderItem::getProductName, summingInt(OrderItem::getProductQuantity)))<br>
.entrySet().stream()<br>
.sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed())<br>
.map(Map.Entry::getKey)<br>
.findFirst()<br>
.ifPresent(System.out::println);</p>
<p>//统计最受欢迎的商品的另一种方式，直接利用 maxBy<br>
orders.stream()<br>
.flatMap(order -&gt; order.getOrderItemList().stream())<br>
.collect(groupingBy(OrderItem::getProductName, summingInt(OrderItem::getProductQuantity)))<br>
.entrySet().stream()<br>
.collect(maxBy(Map.Entry.comparingByValue()))<br>
.map(Map.Entry::getKey)<br>
.ifPresent(System.out::println);</p>
<p>//按照用户名分组，选用户下的总金额最大的订单<br>
orders.stream().collect(groupingBy(Order::getCustomerName, collectingAndThen(maxBy(comparingDouble(Order::getTotalPrice)), Optional::get)))<br>
.forEach((k, v) -&gt; System.out.println(k + &ldquo;#&rdquo; + v.getTotalPrice() + &ldquo;@&rdquo; + v.getPlacedAt()));</p>
<p>//根据下单年月分组，统计订单 ID 列表<br>
System.out.println(orders.stream().collect<br>
(groupingBy(order -&gt; order.getPlacedAt().format(DateTimeFormatter.ofPattern(&ldquo;yyyyMM&rdquo;)),<br>
mapping(order -&gt; order.getId(), toList()))));</p>
<p>//根据下单年月 + 用户名两次分组，统计订单 ID 列表<br>
System.out.println(orders.stream().collect<br>
(groupingBy(order -&gt; order.getPlacedAt().format(DateTimeFormatter.ofPattern(&ldquo;yyyyMM&rdquo;)),<br>
groupingBy(order -&gt; order.getCustomerName(),<br>
mapping(order -&gt; order.getId(), toList())))));</p>
<p>如果不借助 Stream 转换为普通的 Java 代码，实现这些复杂的操作可能需要几十行代码。</p>
<h3 id="partitionby">partitionBy</h3>
<p>partitioningBy 用于分区，分区是特殊的分组，只有 true 和 false 两组。比如，我们把用户按照是否下单进行分区，给 partitioningBy 方法传入一个 Predicate 作为数据分区的区分，输出是 Map&lt;Boolean, List&gt;：</p>
<p>public static <T><br>
Collector&lt;T, ?, Map&lt;Boolean, List<T>&raquo; partitioningBy(Predicate&lt;? super T&gt; predicate) {<br>
return partitioningBy(predicate, toList());<br>
}</p>
<p>测试一下，partitioningBy 配合 anyMatch，可以把用户分为下过订单和没下过订单两组：</p>
<p>//根据是否有下单记录进行分区<br>
System.out.println(Customer.getData().stream().collect(<br>
partitioningBy(customer -&gt; orders.stream().mapToLong(Order::getCustomerId)<br>
.anyMatch(id -&gt; id == customer.getId()))));</p>
<h2 id="重点回顾">重点回顾</h2>
<p>今天，我用了大量的篇幅和案例，和你展开介绍了 Stream 中很多具体的流式操作方法。有些案例可能不太好理解，我建议你对着代码逐一到源码中查看这些操作的方法定义，以及 JDK 中的代码注释。</p>
<p>最后，我建议你思考下，在日常工作中还会使用 SQL 统计哪些信息，这些 SQL 是否也可以用 Stream 来改写呢？Stream 的 API 博大精深，但其中又有规律可循。这其中的规律主要就是，理清楚这些 API 传参的函数式接口定义，就能搞明白到底是需要我们提供数据、消费数据、还是转换数据等。那，掌握 Stream 的方法便是，多测试多练习，以强化记忆、加深理解。</p>
<p>今天用到的代码，我都放在了 GitHub 上，你可以点击这个链接查看。</p>
<h2 id="思考与讨论">思考与讨论</h2>
<ol>
<li>使用 Stream 可以非常方便地对 List 做各种操作，那有没有什么办法可以实现在整个过程中观察数据变化呢？比如，我们进行 filter+map 操作，如何观察 filter 后 map 的原始数据呢？</li>
<li>Collectors 类提供了很多现成的收集器，那我们有没有办法实现自定义的收集器呢？比如，实现一个 MostPopularCollector，来得到 List 中出现次数最多的元素，满足下面两个测试用例：</li>
</ol>
<p>assertThat(Stream.of(1, 1, 2, 2, 2, 3, 4, 5, 5).collect(new MostPopularCollector&lt;&gt;()).get(), is(2));<br>
assertThat(Stream.of(&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;, &lsquo;c&rsquo;, &lsquo;c&rsquo;, &rsquo;d&rsquo;).collect(new MostPopularCollector&lt;&gt;()).get(), is(&lsquo;c&rsquo;));</p>
<p>关于 Java 8，你还有什么使用心得吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/">Java业务开发常见错误100例</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%8A%A0%E9%A4%901%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90%E4%BA%91%E5%8E%9F%E7%94%9Fhtap%E5%9B%BE%E4%B8%8E%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">加餐1概念解析：云原生、HTAP、图与内存数据库</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%8A%A0%E9%A4%902_%E7%AD%94%E7%96%91%E7%B2%BE%E9%80%89%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E4%BD%A0%E9%83%BD%E6%B8%85%E6%A5%9A%E5%90%97/">
            <span class="next-text nav-default">加餐2_｜答疑精选：这些问题你都清楚吗？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
