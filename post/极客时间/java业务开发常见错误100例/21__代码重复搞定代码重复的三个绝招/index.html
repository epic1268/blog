<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>21__代码重复：搞定代码重复的三个绝招 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是朱晔。今天，我来和你聊聊搞定代码重复的三个绝招。
业务同学抱怨业务开发没有技术含量，用不到设计模式、Java 高级特性、OOP，平时写代码都在堆 CRUD，个人成长无从谈起。每次面试官问到“请说说平时常用的设计模式”，都只能答单例模式，因为其他设计模式的确是听过但没用过；对于反射、注解之类的高级特性，也只是知道它们在写框架的时候非常常用，但自己又不写框架代码，没有用武之地。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/21__%E4%BB%A3%E7%A0%81%E9%87%8D%E5%A4%8D%E6%90%9E%E5%AE%9A%E4%BB%A3%E7%A0%81%E9%87%8D%E5%A4%8D%E7%9A%84%E4%B8%89%E4%B8%AA%E7%BB%9D%E6%8B%9B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/21__%E4%BB%A3%E7%A0%81%E9%87%8D%E5%A4%8D%E6%90%9E%E5%AE%9A%E4%BB%A3%E7%A0%81%E9%87%8D%E5%A4%8D%E7%9A%84%E4%B8%89%E4%B8%AA%E7%BB%9D%E6%8B%9B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="21__代码重复：搞定代码重复的三个绝招">
  <meta property="og:description" content="你好，我是朱晔。今天，我来和你聊聊搞定代码重复的三个绝招。
业务同学抱怨业务开发没有技术含量，用不到设计模式、Java 高级特性、OOP，平时写代码都在堆 CRUD，个人成长无从谈起。每次面试官问到“请说说平时常用的设计模式”，都只能答单例模式，因为其他设计模式的确是听过但没用过；对于反射、注解之类的高级特性，也只是知道它们在写框架的时候非常常用，但自己又不写框架代码，没有用武之地。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Java业务开发常见错误100例">

  <meta itemprop="name" content="21__代码重复：搞定代码重复的三个绝招">
  <meta itemprop="description" content="你好，我是朱晔。今天，我来和你聊聊搞定代码重复的三个绝招。
业务同学抱怨业务开发没有技术含量，用不到设计模式、Java 高级特性、OOP，平时写代码都在堆 CRUD，个人成长无从谈起。每次面试官问到“请说说平时常用的设计模式”，都只能答单例模式，因为其他设计模式的确是听过但没用过；对于反射、注解之类的高级特性，也只是知道它们在写框架的时候非常常用，但自己又不写框架代码，没有用武之地。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6756">
  <meta itemprop="keywords" content="Java业务开发常见错误100例">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="21__代码重复：搞定代码重复的三个绝招">
  <meta name="twitter:description" content="你好，我是朱晔。今天，我来和你聊聊搞定代码重复的三个绝招。
业务同学抱怨业务开发没有技术含量，用不到设计模式、Java 高级特性、OOP，平时写代码都在堆 CRUD，个人成长无从谈起。每次面试官问到“请说说平时常用的设计模式”，都只能答单例模式，因为其他设计模式的确是听过但没用过；对于反射、注解之类的高级特性，也只是知道它们在写框架的时候非常常用，但自己又不写框架代码，没有用武之地。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">21__代码重复：搞定代码重复的三个绝招</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6756 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#利用工厂模式--模板方法模式消除-ifelse-和重复代码">利用工厂模式 + 模板方法模式，消除 if…else 和重复代码</a></li>
        <li><a href="#利用注解--反射消除重复代码">利用注解 + 反射消除重复代码</a></li>
        <li><a href="#利用属性拷贝工具消除重复代码">利用属性拷贝工具消除重复代码</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考与讨论">思考与讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是朱晔。今天，我来和你聊聊搞定代码重复的三个绝招。</p>
<p>业务同学抱怨业务开发没有技术含量，用不到设计模式、Java 高级特性、OOP，平时写代码都在堆 CRUD，个人成长无从谈起。每次面试官问到“请说说平时常用的设计模式”，都只能答单例模式，因为其他设计模式的确是听过但没用过；对于反射、注解之类的高级特性，也只是知道它们在写框架的时候非常常用，但自己又不写框架代码，没有用武之地。</p>
<p>其实，我认为不是这样的。设计模式、OOP 是前辈们在大型项目中积累下来的经验，通过这些方法论来改善大型项目的可维护性。反射、注解、泛型等高级特性在框架中大量使用的原因是，框架往往需要以同一套算法来应对不同的数据结构，而这些特性可以帮助减少重复代码，提升项目可维护性。</p>
<p>在我看来，可维护性是大型项目成熟度的一个重要指标，而提升可维护性非常重要的一个手段就是减少代码重复。那为什么这样说呢？</p>
<ol>
<li>如果多处重复代码实现完全相同的功能，很容易修改一处忘记修改另一处，造成 Bug；</li>
<li>有一些代码并不是完全重复，而是相似度很高，修改这些类似的代码容易改（复制粘贴）错，把原本有区别的地方改为了一样。</li>
</ol>
<p>今天，我就从业务代码中最常见的三个需求展开，和你聊聊如何使用 Java 中的一些高级特性、设计模式，以及一些工具消除重复代码，才能既优雅又高端。通过今天的学习，也希望改变你对业务代码没有技术含量的看法。</p>
<h2 id="利用工厂模式--模板方法模式消除-ifelse-和重复代码">利用工厂模式 + 模板方法模式，消除 if…else 和重复代码</h2>
<p>假设要开发一个购物车下单的功能，针对不同用户进行不同处理：</p>
<ol>
<li>普通用户需要收取运费，运费是商品价格的 10%，无商品折扣；</li>
<li>VIP 用户同样需要收取商品价格 10% 的快递费，但购买两件以上相同商品时，第三件开始享受一定折扣；</li>
<li>内部用户可以免运费，无商品折扣。</li>
</ol>
<p>我们的目标是实现三种类型的购物车业务逻辑，把入参 Map 对象（Key 是商品 ID，Value 是商品数量），转换为出参购物车类型 Cart。</p>
<p>先实现针对普通用户的购物车处理逻辑：</p>
<p>//购物车<br>
@Data<br>
public class Cart {<br>
//商品清单<br>
private List<Item> items = new ArrayList&lt;&gt;();<br>
//总优惠<br>
private BigDecimal totalDiscount;<br>
//商品总价<br>
private BigDecimal totalItemPrice;<br>
//总运费<br>
private BigDecimal totalDeliveryPrice;<br>
//应付总价<br>
private BigDecimal payPrice;<br>
}<br>
//购物车中的商品<br>
@Data<br>
public class Item {<br>
//商品 ID<br>
private long id;<br>
//商品数量<br>
private int quantity;<br>
//商品单价<br>
private BigDecimal price;<br>
//商品优惠<br>
private BigDecimal couponPrice;<br>
//商品运费<br>
private BigDecimal deliveryPrice;<br>
}<br>
//普通用户购物车处理<br>
public class NormalUserCart {<br>
public Cart process(long userId, Map&lt;Long, Integer&gt; items) {<br>
Cart cart = new Cart();</p>
<pre><code>    //把 Map 的购物车转换为 Item 列表  
    List&lt;Item&gt; itemList = new ArrayList&lt;&gt;();  
    items.entrySet().stream().forEach(entry -&gt; {  
        Item item = new Item();  
        item.setId(entry.getKey());  
        item.setPrice(Db.getItemPrice(entry.getKey()));  
        item.setQuantity(entry.getValue());  
        itemList.add(item);  
    });  
    cart.setItems(itemList);  

    //处理运费和商品优惠  
    itemList.stream().forEach(item -&gt; {  
        //运费为商品总价的 10%  
        item.setDeliveryPrice(item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())).multiply(new BigDecimal(&quot;0.1&quot;)));  
        //无优惠  
        item.setCouponPrice(BigDecimal.ZERO);  
    });  

    //计算商品总价  
    cart.setTotalItemPrice(cart.getItems().stream().map(item -&gt; item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity()))).reduce(BigDecimal.ZERO, BigDecimal::add));  
    //计算运费总价  
    cart.setTotalDeliveryPrice(cart.getItems().stream().map(Item::getDeliveryPrice).reduce(BigDecimal.ZERO, BigDecimal::add));  
    //计算总优惠  
    cart.setTotalDiscount(cart.getItems().stream().map(Item::getCouponPrice).reduce(BigDecimal.ZERO, BigDecimal::add));  
    //应付总价=商品总价 + 运费总价 - 总优惠  
    cart.setPayPrice(cart.getTotalItemPrice().add(cart.getTotalDeliveryPrice()).subtract(cart.getTotalDiscount()));  
    return cart;  
}  
</code></pre>
<p>}</p>
<p>然后实现针对 VIP 用户的购物车逻辑。与普通用户购物车逻辑的不同在于，VIP 用户能享受同类商品多买的折扣。所以，这部分代码只需要额外处理多买折扣部分：</p>
<p>public class VipUserCart {</p>
<pre><code>public Cart process(long userId, Map&lt;Long, Integer&gt; items) {  
    ...  


    itemList.stream().forEach(item -&gt; {  
        //运费为商品总价的 10%  
        item.setDeliveryPrice(item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())).multiply(new BigDecimal(&quot;0.1&quot;)));  
        //购买两件以上相同商品，第三件开始享受一定折扣  
        if (item.getQuantity() &gt; 2) {  
            item.setCouponPrice(item.getPrice()  
                    .multiply(BigDecimal.valueOf(100 - Db.getUserCouponPercent(userId)).divide(new BigDecimal(&quot;100&quot;)))  
                   .multiply(BigDecimal.valueOf(item.getQuantity() - 2)));  
        } else {  
            item.setCouponPrice(BigDecimal.ZERO);  
        }  
    });  


    ...  
    return cart;  
}  
</code></pre>
<p>}</p>
<p>最后是免运费、无折扣的内部用户，同样只是处理商品折扣和运费时的逻辑差异：</p>
<p>public class InternalUserCart {</p>
<pre><code>public Cart process(long userId, Map&lt;Long, Integer&gt; items) {  
    ...  

    itemList.stream().forEach(item -&gt; {  
        //免运费  
        item.setDeliveryPrice(BigDecimal.ZERO);  
        //无优惠  
        item.setCouponPrice(BigDecimal.ZERO);  
    });  

    ...  
    return cart;  
}  
</code></pre>
<p>}</p>
<p>对比一下代码量可以发现，三种购物车 70% 的代码是重复的。原因很简单，虽然不同类型用户计算运费和优惠的方式不同，但整个购物车的初始化、统计总价、总运费、总优惠和支付价格的逻辑都是一样的。</p>
<p>正如我们开始时提到的，代码重复本身不可怕，可怕的是漏改或改错。比如，写 VIP 用户购物车的同学发现商品总价计算有 Bug，不应该是把所有 Item 的 price 加在一起，而是应该把所有 Item 的 price*quantity 加在一起。这时，他可能会只修改 VIP 用户购物车的代码，而忽略了普通用户、内部用户的购物车中，重复的逻辑实现也有相同的 Bug。</p>
<p>有了三个购物车后，我们就需要根据不同的用户类型使用不同的购物车了。如下代码所示，使用三个 if 实现不同类型用户调用不同购物车的 process 方法：</p>
<p>@GetMapping(&ldquo;wrong&rdquo;)<br>
public Cart wrong(@RequestParam(&ldquo;userId&rdquo;) int userId) {<br>
//根据用户 ID 获得用户类型<br>
String userCategory = Db.getUserCategory(userId);<br>
//普通用户处理逻辑<br>
if (userCategory.equals(&ldquo;Normal&rdquo;)) {<br>
NormalUserCart normalUserCart = new NormalUserCart();<br>
return normalUserCart.process(userId, items);<br>
}<br>
//VIP 用户处理逻辑<br>
if (userCategory.equals(&ldquo;Vip&rdquo;)) {<br>
VipUserCart vipUserCart = new VipUserCart();<br>
return vipUserCart.process(userId, items);<br>
}<br>
//内部用户处理逻辑<br>
if (userCategory.equals(&ldquo;Internal&rdquo;)) {<br>
InternalUserCart internalUserCart = new InternalUserCart();<br>
return internalUserCart.process(userId, items);<br>
}</p>
<pre><code>return null;  
</code></pre>
<p>}</p>
<p>电商的营销玩法是多样的，以后势必还会有更多用户类型，需要更多的购物车。我们就只能不断增加更多的购物车类，一遍一遍地写重复的购物车逻辑、写更多的 if 逻辑吗？</p>
<p>当然不是，相同的代码应该只在一处出现！</p>
<p>如果我们熟记抽象类和抽象方法的定义的话，这时或许就会想到，是否可以把重复的逻辑定义在抽象类中，三个购物车只要分别实现不同的那份逻辑呢？</p>
<p>其实，这个模式就是<strong>模板方法模式</strong>。我们在父类中实现了购物车处理的流程模板，然后把需要特殊处理的地方留空白也就是留抽象方法定义，让子类去实现其中的逻辑。由于父类的逻辑不完整无法单独工作，因此需要定义为抽象类。</p>
<p>如下代码所示，AbstractCart 抽象类实现了购物车通用的逻辑，额外定义了两个抽象方法让子类去实现。其中，processCouponPrice 方法用于计算商品折扣，processDeliveryPrice 方法用于计算运费。</p>
<p>public abstract class AbstractCart {<br>
//处理购物车的大量重复逻辑在父类实现<br>
public Cart process(long userId, Map&lt;Long, Integer&gt; items) {</p>
<pre><code>    Cart cart = new Cart();  

    List&lt;Item&gt; itemList = new ArrayList&lt;&gt;();  
    items.entrySet().stream().forEach(entry -&gt; {  
        Item item = new Item();  
        item.setId(entry.getKey());  
        item.setPrice(Db.getItemPrice(entry.getKey()));  
        item.setQuantity(entry.getValue());  
        itemList.add(item);  
    });  
    cart.setItems(itemList);  
    //让子类处理每一个商品的优惠  
    itemList.stream().forEach(item -&gt; {  
        processCouponPrice(userId, item);  
        processDeliveryPrice(userId, item);  
    });  
    //计算商品总价  
    cart.setTotalItemPrice(cart.getItems().stream().map(item -&gt; item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity()))).reduce(BigDecimal.ZERO, BigDecimal::add));  
    //计算总运费  
</code></pre>
<p>cart.setTotalDeliveryPrice(cart.getItems().stream().map(Item::getDeliveryPrice).reduce(BigDecimal.ZERO, BigDecimal::add));<br>
//计算总折扣<br>
cart.setTotalDiscount(cart.getItems().stream().map(Item::getCouponPrice).reduce(BigDecimal.ZERO, BigDecimal::add));<br>
//计算应付价格<br>
cart.setPayPrice(cart.getTotalItemPrice().add(cart.getTotalDeliveryPrice()).subtract(cart.getTotalDiscount()));<br>
return cart;<br>
}</p>
<pre><code>//处理商品优惠的逻辑留给子类实现  
protected abstract void processCouponPrice(long userId, Item item);  
//处理配送费的逻辑留给子类实现  
protected abstract void processDeliveryPrice(long userId, Item item);  
</code></pre>
<p>}</p>
<p>有了这个抽象类，三个子类的实现就非常简单了。普通用户的购物车 NormalUserCart，实现的是 0 优惠和 10% 运费的逻辑：</p>
<p>@Service(value = &ldquo;NormalUserCart&rdquo;)<br>
public class NormalUserCart extends AbstractCart {</p>
<pre><code>@Override  
protected void processCouponPrice(long userId, Item item) {  
    item.setCouponPrice(BigDecimal.ZERO);  
}  

@Override  
protected void processDeliveryPrice(long userId, Item item) {  
    item.setDeliveryPrice(item.getPrice()  
            .multiply(BigDecimal.valueOf(item.getQuantity()))  
            .multiply(new BigDecimal(&quot;0.1&quot;)));  
}  
</code></pre>
<p>}</p>
<p>VIP 用户的购物车 VipUserCart，直接继承了 NormalUserCart，只需要修改多买优惠策略：</p>
<p>@Service(value = &ldquo;VipUserCart&rdquo;)<br>
public class VipUserCart extends NormalUserCart {</p>
<pre><code>@Override  
protected void processCouponPrice(long userId, Item item) {  
    if (item.getQuantity() &gt; 2) {  
        item.setCouponPrice(item.getPrice()  
                .multiply(BigDecimal.valueOf(100 - Db.getUserCouponPercent(userId)).divide(new BigDecimal(&quot;100&quot;)))  
                .multiply(BigDecimal.valueOf(item.getQuantity() - 2)));  
    } else {  
        item.setCouponPrice(BigDecimal.ZERO);  
    }  
}  
</code></pre>
<p>}</p>
<p>内部用户购物车 InternalUserCart 是最简单的，直接设置 0 运费和 0 折扣即可：</p>
<p>@Service(value = &ldquo;InternalUserCart&rdquo;)<br>
public class InternalUserCart extends AbstractCart {<br>
@Override<br>
protected void processCouponPrice(long userId, Item item) {<br>
item.setCouponPrice(BigDecimal.ZERO);<br>
}</p>
<pre><code>@Override  
protected void processDeliveryPrice(long userId, Item item) {  
    item.setDeliveryPrice(BigDecimal.ZERO);  
}  
</code></pre>
<p>}</p>
<p>抽象类和三个子类的实现关系图，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/c1d93ad8bf818dcb9365ba4001aff255.png" alt=""></p>
<p>是不是比三个独立的购物车程序简单了很多呢？接下来，我们再看看如何能避免三个 if 逻辑。</p>
<p>或许你已经注意到了，定义三个购物车子类时，我们在 @Service 注解中对 Bean 进行了命名。既然三个购物车都叫 XXXUserCart，那我们就可以把用户类型字符串拼接 UserCart 构成购物车 Bean 的名称，然后利用 Spring 的 IoC 容器，通过 Bean 的名称直接获取到 AbstractCart，调用其 process 方法即可实现通用。</p>
<p>其实，这就是<strong>工厂模式</strong>，只不过是借助 Spring 容器实现罢了：</p>
<p>@GetMapping(&ldquo;right&rdquo;)<br>
public Cart right(@RequestParam(&ldquo;userId&rdquo;) int userId) {<br>
String userCategory = Db.getUserCategory(userId);<br>
AbstractCart cart = (AbstractCart) applicationContext.getBean(userCategory + &ldquo;UserCart&rdquo;);<br>
return cart.process(userId, items);<br>
}</p>
<p>试想，之后如果有了新的用户类型、新的用户逻辑，是不是完全不用对代码做任何修改，只要新增一个 XXXUserCart 类继承 AbstractCart，实现特殊的优惠和运费处理逻辑就可以了？</p>
<p><strong>这样一来，我们就利用工厂模式 + 模板方法模式，不仅消除了重复代码，还避免了修改既有代码的风险</strong>。这就是设计模式中的开闭原则：对修改关闭，对扩展开放。</p>
<h2 id="利用注解--反射消除重复代码">利用注解 + 反射消除重复代码</h2>
<p>是不是有点兴奋了，业务代码居然也能 OOP 了。我们再看一个三方接口的调用案例，同样也是一个普通的业务逻辑。</p>
<p>假设银行提供了一些 API 接口，对参数的序列化有点特殊，不使用 JSON，而是需要我们把参数依次拼在一起构成一个大字符串。</p>
<ol>
<li>按照银行提供的 API 文档的顺序，把所有参数构成定长的数据，然后拼接在一起作为整个字符串。</li>
<li>因为每一种参数都有固定长度，未达到长度时需要做填充处理：</li>
<li>字符串类型的参数不满长度部分需要以下划线右填充，也就是字符串内容靠左；</li>
<li>数字类型的参数不满长度部分以 0 左填充，也就是实际数字靠右；</li>
<li>货币类型的表示需要把金额向下舍入 2 位到分，以分为单位，作为数字类型同样进行左填充。</li>
<li>对所有参数做 MD5 操作作为签名（为了方便理解，Demo 中不涉及加盐处理）。</li>
</ol>
<p>比如，创建用户方法和支付方法的定义是这样的：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/b879c1dbd00356f16789f467ec2f7e49.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/12954c1eb4dfaca6fea50637b6e34150.png" alt=""></p>
<p>代码很容易实现，直接根据接口定义实现填充操作、加签名、请求调用操作即可：</p>
<p>public class BankService {</p>
<pre><code>//创建用户方法  
public static String createUser(String name, String identity, String mobile, int age) throws IOException {  
    StringBuilder stringBuilder = new StringBuilder();  
    //字符串靠左，多余的地方填充_  
    stringBuilder.append(String.format(&quot;%-10s&quot;, name).replace(' ', '_'));  
    //字符串靠左，多余的地方填充_  
    stringBuilder.append(String.format(&quot;%-18s&quot;, identity).replace(' ', '_'));  
    //数字靠右，多余的地方用 0 填充  
    stringBuilder.append(String.format(&quot;%05d&quot;, age));  
    //字符串靠左，多余的地方用_填充  
    stringBuilder.append(String.format(&quot;%-11s&quot;, mobile).replace(' ', '_'));  
    //最后加上 MD5 作为签名  
    stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));  
    return Request.Post(&quot;http://localhost:45678/reflection/bank/createUser&quot;)  
            .bodyString(stringBuilder.toString(), ContentType.APPLICATION_JSON)  
            .execute().returnContent().asString();  
}  
  
//支付方法  
public static String pay(long userId, BigDecimal amount) throws IOException {  
    StringBuilder stringBuilder = new StringBuilder();  
    //数字靠右，多余的地方用 0 填充  
    stringBuilder.append(String.format(&quot;%020d&quot;, userId));  
    //金额向下舍入 2 位到分，以分为单位，作为数字靠右，多余的地方用 0 填充  
    stringBuilder.append(String.format(&quot;%010d&quot;, amount.setScale(2, RoundingMode.DOWN).multiply(new BigDecimal(&quot;100&quot;)).longValue()));  
    //最后加上 MD5 作为签名  
    stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));  
    return Request.Post(&quot;http://localhost:45678/reflection/bank/pay&quot;)  
            .bodyString(stringBuilder.toString(), ContentType.APPLICATION_JSON)  
            .execute().returnContent().asString();  
}  
</code></pre>
<p>}</p>
<p>可以看到，这段代码的重复粒度更细：</p>
<ol>
<li>三种标准数据类型的处理逻辑有重复，稍有不慎就会出现 Bug；</li>
<li>处理流程中字符串拼接、加签和发请求的逻辑，在所有方法重复；</li>
<li>实际方法的入参的参数类型和顺序，不一定和接口要求一致，容易出错；</li>
<li>代码层面针对每一个参数硬编码，无法清晰地进行核对，如果参数达到几十个、上百个，出错的概率极大。</li>
</ol>
<p>那应该如何改造这段代码呢？没错，就是要用注解和反射！</p>
<p>使用注解和反射这两个武器，就可以针对银行请求的所有逻辑均使用一套代码实现，不会出现任何重复。</p>
<p>要实现接口逻辑和逻辑实现的剥离，首先需要以 POJO 类（只有属性没有任何业务逻辑的数据类）的方式定义所有的接口参数。比如，下面这个创建用户 API 的参数：</p>
<p>@Data<br>
public class CreateUserAPI {<br>
private String name;<br>
private String identity;<br>
private String mobile;<br>
private int age;<br>
}</p>
<p>有了接口参数定义，我们就能通过自定义注解为接口和所有参数增加一些元数据。如下所示，我们定义一个接口 API 的注解 BankAPI，包含接口 URL 地址和接口说明：</p>
<p>@Retention(RetentionPolicy.RUNTIME)<br>
@Target(ElementType.TYPE)<br>
@Documented<br>
@Inherited<br>
public @interface BankAPI {<br>
String desc() default &ldquo;&rdquo;;<br>
String url() default &ldquo;&rdquo;;<br>
}</p>
<p>然后，我们再定义一个自定义注解 @BankAPIField，用于描述接口的每一个字段规范，包含参数的次序、类型和长度三个属性：</p>
<p>@Retention(RetentionPolicy.RUNTIME)<br>
@Target(ElementType.FIELD)<br>
@Documented<br>
@Inherited<br>
public @interface BankAPIField {<br>
int order() default -1;<br>
int length() default -1;<br>
String type() default &ldquo;&rdquo;;<br>
}</p>
<p>接下来，注解就可以发挥威力了。</p>
<p>如下所示，我们定义了 CreateUserAPI 类描述创建用户接口的信息，通过为接口增加 @BankAPI 注解，来补充接口的 URL 和描述等元数据；通过为每一个字段增加 @BankAPIField 注解，来补充参数的顺序、类型和长度等元数据：</p>
<p>@BankAPI(url = &ldquo;/bank/createUser&rdquo;, desc = &ldquo;创建用户接口&rdquo;)<br>
@Data<br>
public class CreateUserAPI extends AbstractAPI {<br>
@BankAPIField(order = 1, type = &ldquo;S&rdquo;, length = 10)<br>
private String name;<br>
@BankAPIField(order = 2, type = &ldquo;S&rdquo;, length = 18)<br>
private String identity;<br>
@BankAPIField(order = 4, type = &ldquo;S&rdquo;, length = 11) //注意这里的 order 需要按照 API 表格中的顺序<br>
private String mobile;<br>
@BankAPIField(order = 3, type = &ldquo;N&rdquo;, length = 5)<br>
private int age;<br>
}</p>
<p>另一个 PayAPI 类也是类似的实现：</p>
<p>@BankAPI(url = &ldquo;/bank/pay&rdquo;, desc = &ldquo;支付接口&rdquo;)<br>
@Data<br>
public class PayAPI extends AbstractAPI {<br>
@BankAPIField(order = 1, type = &ldquo;N&rdquo;, length = 20)<br>
private long userId;<br>
@BankAPIField(order = 2, type = &ldquo;M&rdquo;, length = 10)<br>
private BigDecimal amount;<br>
}</p>
<p>这 2 个类继承的 AbstractAPI 类是一个空实现，因为这个案例中的接口并没有公共数据可以抽象放到基类。</p>
<p>通过这 2 个类，我们可以在几秒钟内完成和 API 清单表格的核对。理论上，如果我们的核心翻译过程（也就是把注解和接口 API 序列化为请求需要的字符串的过程）没问题，只要注解和表格一致，API 请求的翻译就不会有任何问题。</p>
<p>以上，我们通过注解实现了对 API 参数的描述。接下来，我们再看看反射如何配合注解实现动态的接口参数组装：</p>
<ol>
<li>第 3 行代码中，我们从类上获得了 BankAPI 注解，然后拿到其 URL 属性，后续进行远程调用。</li>
<li>第 6~9 行代码，使用 stream 快速实现了获取类中所有带 BankAPIField 注解的字段，并把字段按 order 属性排序，然后设置私有字段反射可访问。</li>
<li>第 12~38 行代码，实现了反射获取注解的值，然后根据 BankAPIField 拿到的参数类型，按照三种标准进行格式化，将所有参数的格式化逻辑集中在了这一处。</li>
<li>第 41~48 行代码，实现了参数加签和请求调用。</li>
</ol>
<p>private static String remoteCall(AbstractAPI api) throws IOException {<br>
//从 BankAPI 注解获取请求地址<br>
BankAPI bankAPI = api.getClass().getAnnotation(BankAPI.class);<br>
bankAPI.url();<br>
StringBuilder stringBuilder = new StringBuilder();<br>
Arrays.stream(api.getClass().getDeclaredFields()) //获得所有字段<br>
.filter(field -&gt; field.isAnnotationPresent(BankAPIField.class)) //查找标记了注解的字段<br>
.sorted(Comparator.comparingInt(a -&gt; a.getAnnotation(BankAPIField.class).order())) //根据注解中的 order 对字段排序<br>
.peek(field -&gt; field.setAccessible(true)) //设置可以访问私有字段<br>
.forEach(field -&gt; {<br>
//获得注解<br>
BankAPIField bankAPIField = field.getAnnotation(BankAPIField.class);<br>
Object value = &ldquo;&rdquo;;<br>
try {<br>
//反射获取字段值<br>
value = field.get(api);<br>
} catch (IllegalAccessException e) {<br>
e.printStackTrace();<br>
}<br>
//根据字段类型以正确的填充方式格式化字符串<br>
switch (bankAPIField.type()) {<br>
case &ldquo;S&rdquo;: {<br>
stringBuilder.append(String.format(&quot;%-&quot; + bankAPIField.length() + &ldquo;s&rdquo;, value.toString()).replace(&rsquo; &lsquo;, &lsquo;_&rsquo;));<br>
break;<br>
}<br>
case &ldquo;N&rdquo;: {<br>
stringBuilder.append(String.format(&quot;%&quot; + bankAPIField.length() + &ldquo;s&rdquo;, value.toString()).replace(&rsquo; &lsquo;, &lsquo;0&rsquo;));<br>
break;<br>
}<br>
case &ldquo;M&rdquo;: {<br>
if (!(value instanceof BigDecimal))<br>
throw new RuntimeException(String.format(&quot;{} 的 {} 必须是 BigDecimal&quot;, api, field));<br>
stringBuilder.append(String.format(&quot;%0&quot; + bankAPIField.length() + &ldquo;d&rdquo;, ((BigDecimal) value).setScale(2, RoundingMode.DOWN).multiply(new BigDecimal(&ldquo;100&rdquo;)).longValue()));<br>
break;<br>
}<br>
default:<br>
break;<br>
}<br>
});<br>
//签名逻辑<br>
stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));<br>
String param = stringBuilder.toString();<br>
long begin = System.currentTimeMillis();<br>
//发请求<br>
String result = Request.Post(&ldquo;http://localhost:45678/reflection&rdquo; + bankAPI.url())<br>
.bodyString(param, ContentType.APPLICATION_JSON)<br>
.execute().returnContent().asString();<br>
log.info(&ldquo;调用银行 API {} url:{} 参数:{} 耗时:{}ms&rdquo;, bankAPI.desc(), bankAPI.url(), param, System.currentTimeMillis() - begin);<br>
return result;<br>
}</p>
<p>可以看到，<strong>所有处理参数排序、填充、加签、请求调用的核心逻辑，都汇聚在了 remoteCall 方法中</strong>。有了这个核心方法，BankService 中每一个接口的实现就非常简单了，只是参数的组装，然后调用 remoteCall 即可。</p>
<p>//创建用户方法<br>
public static String createUser(String name, String identity, String mobile, int age) throws IOException {<br>
CreateUserAPI createUserAPI = new CreateUserAPI();<br>
createUserAPI.setName(name);<br>
createUserAPI.setIdentity(identity);<br>
createUserAPI.setAge(age);<br>
createUserAPI.setMobile(mobile);<br>
return remoteCall(createUserAPI);<br>
}<br>
//支付方法<br>
public static String pay(long userId, BigDecimal amount) throws IOException {<br>
PayAPI payAPI = new PayAPI();<br>
payAPI.setUserId(userId);<br>
payAPI.setAmount(amount);<br>
return remoteCall(payAPI);<br>
}</p>
<p>其实，<strong>许多涉及类结构性的通用处理，都可以按照这个模式来减少重复代码</strong>。反射给予了我们在不知晓类结构的时候，按照固定的逻辑处理类的成员；而注解给了我们为这些成员补充元数据的能力，使得我们利用反射实现通用逻辑的时候，可以从外部获得更多我们关心的数据。</p>
<h2 id="利用属性拷贝工具消除重复代码">利用属性拷贝工具消除重复代码</h2>
<p>最后，我们再来看一种业务代码中经常出现的代码逻辑，实体之间的转换复制。</p>
<p>对于三层架构的系统，考虑到层之间的解耦隔离以及每一层对数据的不同需求，通常每一层都会有自己的 POJO 作为数据实体。比如，数据访问层的实体一般叫作 DataObject 或 DO，业务逻辑层的实体一般叫作 Domain，表现层的实体一般叫作 Data Transfer Object 或 DTO。</p>
<p>这里我们需要注意的是，如果手动写这些实体之间的赋值代码，同样容易出错。</p>
<p>对于复杂的业务系统，实体有几十甚至几百个属性也很正常。就比如 ComplicatedOrderDTO 这个数据传输对象，描述的是一个订单中的几十个属性。如果我们要把这个 DTO 转换为一个类似的 DO，复制其中大部分的字段，然后把数据入库，势必需要进行很多属性映射赋值操作。就像这样，密密麻麻的代码是不是已经让你头晕了？</p>
<p>ComplicatedOrderDTO orderDTO = new ComplicatedOrderDTO();<br>
ComplicatedOrderDO orderDO = new ComplicatedOrderDO();<br>
orderDO.setAcceptDate(orderDTO.getAcceptDate());<br>
orderDO.setAddress(orderDTO.getAddress());<br>
orderDO.setAddressId(orderDTO.getAddressId());<br>
orderDO.setCancelable(orderDTO.isCancelable());<br>
orderDO.setCommentable(orderDTO.isComplainable()); //属性错误<br>
orderDO.setComplainable(orderDTO.isCommentable()); //属性错误<br>
orderDO.setCancelable(orderDTO.isCancelable());<br>
orderDO.setCouponAmount(orderDTO.getCouponAmount());<br>
orderDO.setCouponId(orderDTO.getCouponId());<br>
orderDO.setCreateDate(orderDTO.getCreateDate());<br>
orderDO.setDirectCancelable(orderDTO.isDirectCancelable());<br>
orderDO.setDeliverDate(orderDTO.getDeliverDate());<br>
orderDO.setDeliverGroup(orderDTO.getDeliverGroup());<br>
orderDO.setDeliverGroupOrderStatus(orderDTO.getDeliverGroupOrderStatus());<br>
orderDO.setDeliverMethod(orderDTO.getDeliverMethod());<br>
orderDO.setDeliverPrice(orderDTO.getDeliverPrice());<br>
orderDO.setDeliveryManId(orderDTO.getDeliveryManId());<br>
orderDO.setDeliveryManMobile(orderDO.getDeliveryManMobile()); //对象错误<br>
orderDO.setDeliveryManName(orderDTO.getDeliveryManName());<br>
orderDO.setDistance(orderDTO.getDistance());<br>
orderDO.setExpectDate(orderDTO.getExpectDate());<br>
orderDO.setFirstDeal(orderDTO.isFirstDeal());<br>
orderDO.setHasPaid(orderDTO.isHasPaid());<br>
orderDO.setHeadPic(orderDTO.getHeadPic());<br>
orderDO.setLongitude(orderDTO.getLongitude());<br>
orderDO.setLatitude(orderDTO.getLongitude()); //属性赋值错误<br>
orderDO.setMerchantAddress(orderDTO.getMerchantAddress());<br>
orderDO.setMerchantHeadPic(orderDTO.getMerchantHeadPic());<br>
orderDO.setMerchantId(orderDTO.getMerchantId());<br>
orderDO.setMerchantAddress(orderDTO.getMerchantAddress());<br>
orderDO.setMerchantName(orderDTO.getMerchantName());<br>
orderDO.setMerchantPhone(orderDTO.getMerchantPhone());<br>
orderDO.setOrderNo(orderDTO.getOrderNo());<br>
orderDO.setOutDate(orderDTO.getOutDate());<br>
orderDO.setPayable(orderDTO.isPayable());<br>
orderDO.setPaymentAmount(orderDTO.getPaymentAmount());<br>
orderDO.setPaymentDate(orderDTO.getPaymentDate());<br>
orderDO.setPaymentMethod(orderDTO.getPaymentMethod());<br>
orderDO.setPaymentTimeLimit(orderDTO.getPaymentTimeLimit());<br>
orderDO.setPhone(orderDTO.getPhone());<br>
orderDO.setRefundable(orderDTO.isRefundable());<br>
orderDO.setRemark(orderDTO.getRemark());<br>
orderDO.setStatus(orderDTO.getStatus());<br>
orderDO.setTotalQuantity(orderDTO.getTotalQuantity());<br>
orderDO.setUpdateTime(orderDTO.getUpdateTime());<br>
orderDO.setName(orderDTO.getName());<br>
orderDO.setUid(orderDTO.getUid());</p>
<p><strong>如果不是代码中有注释，你能看出其中的诸多问题吗</strong>？</p>
<ol>
<li>如果原始的 DTO 有 100 个字段，我们需要复制 90 个字段到 DO 中，保留 10 个不赋值，最后应该如何校验正确性呢？数数吗？即使数出有 90 行代码，也不一定正确，因为属性可能重复赋值。</li>
<li>有的时候字段命名相近，比如 complainable 和 commentable，容易搞反（第 7 和第 8 行），或者对两个目标字段重复赋值相同的来源字段（比如第 28 行）</li>
<li>明明要把 DTO 的值赋值到 DO 中，却在 set 的时候从 DO 自己取值（比如第 20 行），导致赋值无效。</li>
</ol>
<p>这段代码并不是我随手写出来的，而是一个真实案例。有位同学就像代码中那样把经纬度赋值反了，因为落库的字段实在太多了。这个 Bug 很久都没发现，直到真正用到数据库中的经纬度做计算时，才发现一直以来都存错了。</p>
<p>修改方法很简单，可以使用类似 BeanUtils 这种 Mapping 工具来做 Bean 的转换，copyProperties 方法还允许我们提供需要忽略的属性：</p>
<p>ComplicatedOrderDTO orderDTO = new ComplicatedOrderDTO();<br>
ComplicatedOrderDO orderDO = new ComplicatedOrderDO();<br>
BeanUtils.copyProperties(orderDTO, orderDO, &ldquo;id&rdquo;);<br>
return orderDO;</p>
<h2 id="重点回顾">重点回顾</h2>
<p>正所谓“常在河边走哪有不湿鞋”，重复代码多了总有一天会出错。今天，我从几个最常见的维度，和你分享了几个实际业务场景中可能出现的重复问题，以及消除重复的方式。</p>
<p>第一种代码重复是，有多个并行的类实现相似的代码逻辑。我们可以考虑提取相同逻辑在父类中实现，差异逻辑通过抽象方法留给子类实现。使用类似的模板方法把相同的流程和逻辑固定成模板，保留差异的同时尽可能避免代码重复。同时，可以使用 Spring 的 IoC 特性注入相应的子类，来避免实例化子类时的大量 if…else 代码。</p>
<p>第二种代码重复是，使用硬编码的方式重复实现相同的数据处理算法。我们可以考虑把规则转换为自定义注解，作为元数据对类或对字段、方法进行描述，然后通过反射动态读取这些元数据、字段或调用方法，实现规则参数和规则定义的分离。也就是说，把变化的部分也就是规则的参数放入注解，规则的定义统一处理。</p>
<p>第三种代码重复是，业务代码中常见的 DO、DTO、VO 转换时大量字段的手动赋值，遇到有上百个属性的复杂类型，非常非常容易出错。我的建议是，不要手动进行赋值，考虑使用 Bean 映射工具进行。此外，还可以考虑采用单元测试对所有字段进行赋值正确性校验。</p>
<p>最后，我想说的是，我会把代码重复度作为评估一个项目质量的重要指标，如果一个项目几乎没有任何重复代码，那么它内部的抽象一定是非常好的。在做项目重构的时候，你也可以以消除重复为第一目标去考虑实现。</p>
<p>今天用到的代码，我都放在了 GitHub 上，你可以点击这个链接查看。</p>
<h2 id="思考与讨论">思考与讨论</h2>
<ol>
<li>除了模板方法设计模式是减少重复代码的一把好手，观察者模式也常用于减少代码重复（并且是松耦合方式）。Spring 也提供了类似工具（点击这里查看），你能想到有哪些应用场景吗？</li>
<li>关于 Bean 属性复制工具，除了最简单的 Spring 的 BeanUtils 工具类的使用，你还知道哪些对象映射类库吗？它们又有什么功能呢？</li>
</ol>
<p>你还有哪些消除重复代码的心得和方法吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把今天的内容分享给你的朋友或同事，一起交流。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/">Java业务开发常见错误100例</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%81%8C%E5%9C%BA%E6%B1%82%E7%94%9F%E6%94%BB%E7%95%A5/21__%E7%AD%94%E7%96%91%E7%AF%87%E6%83%B3%E5%8D%87%E8%81%8C%E6%88%91%E8%AF%A5%E5%87%86%E5%A4%87%E4%BA%9B%E4%BB%80%E4%B9%88/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">21__答疑篇：想升职，我该准备些什么？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/openresty%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/21__%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%AC%E6%97%B6%E9%97%B4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AD%89%E5%B8%B8%E7%94%A8api/">
            <span class="next-text nav-default">21__带你玩转时间、正则表达式等常用API</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
