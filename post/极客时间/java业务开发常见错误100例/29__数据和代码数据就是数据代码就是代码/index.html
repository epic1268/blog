<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>29__数据和代码：数据就是数据，代码就是代码 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是朱晔。今天，我来和你聊聊数据和代码的问题。
正如这一讲标题“数据就是数据，代码就是代码”所说，Web 安全方面的很多漏洞，都是源自把数据当成了代码来执行，也就是注入类问题，比如：
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/29__%E6%95%B0%E6%8D%AE%E5%92%8C%E4%BB%A3%E7%A0%81%E6%95%B0%E6%8D%AE%E5%B0%B1%E6%98%AF%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81%E5%B0%B1%E6%98%AF%E4%BB%A3%E7%A0%81/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/29__%E6%95%B0%E6%8D%AE%E5%92%8C%E4%BB%A3%E7%A0%81%E6%95%B0%E6%8D%AE%E5%B0%B1%E6%98%AF%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%A0%81%E5%B0%B1%E6%98%AF%E4%BB%A3%E7%A0%81/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="29__数据和代码：数据就是数据，代码就是代码">
  <meta property="og:description" content="你好，我是朱晔。今天，我来和你聊聊数据和代码的问题。
正如这一讲标题“数据就是数据，代码就是代码”所说，Web 安全方面的很多漏洞，都是源自把数据当成了代码来执行，也就是注入类问题，比如：">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Java业务开发常见错误100例">

  <meta itemprop="name" content="29__数据和代码：数据就是数据，代码就是代码">
  <meta itemprop="description" content="你好，我是朱晔。今天，我来和你聊聊数据和代码的问题。
正如这一讲标题“数据就是数据，代码就是代码”所说，Web 安全方面的很多漏洞，都是源自把数据当成了代码来执行，也就是注入类问题，比如：">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7174">
  <meta itemprop="keywords" content="Java业务开发常见错误100例">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="29__数据和代码：数据就是数据，代码就是代码">
  <meta name="twitter:description" content="你好，我是朱晔。今天，我来和你聊聊数据和代码的问题。
正如这一讲标题“数据就是数据，代码就是代码”所说，Web 安全方面的很多漏洞，都是源自把数据当成了代码来执行，也就是注入类问题，比如：">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">29__数据和代码：数据就是数据，代码就是代码</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7174 字 </span>
          <span class="more-meta"> 预计阅读 15 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#sql-注入能干的事情比你想象的更多">SQL 注入能干的事情比你想象的更多</a></li>
        <li><a href="#小心动态执行代码时代码注入漏洞">小心动态执行代码时代码注入漏洞</a></li>
        <li><a href="#xss-必须全方位严防死堵">XSS 必须全方位严防死堵</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考与讨论">思考与讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是朱晔。今天，我来和你聊聊数据和代码的问题。</p>
<p>正如这一讲标题“数据就是数据，代码就是代码”所说，Web 安全方面的很多漏洞，都是源自把数据当成了代码来执行，也就是注入类问题，比如：</p>
<ol>
<li>客户端提供给服务端的查询值，是一个数据，会成为 SQL 查询的一部分。黑客通过修改这个值注入一些 SQL，来达到在服务端运行 SQL 的目的，相当于把查询条件的数据变为了查询代码。这种攻击方式，叫做 SQL 注入。</li>
<li>对于规则引擎，我们可能会用动态语言做一些计算，和 SQL 注入一样外部传入的数据只能当做数据使用，如果被黑客利用传入了代码，那么代码可能就会被动态执行。这种攻击方式，叫做代码注入。</li>
<li>对于用户注册、留言评论等功能，服务端会从客户端收集一些信息，本来用户名、邮箱这类信息是纯文本信息，但是黑客把信息替换为了 JavaScript 代码。那么，这些信息在页面呈现时，可能就相当于执行了 JavaScript 代码。甚至是，服务端可能把这样的代码，当作普通信息保存到了数据库。黑客通过构建 JavaScript 代码来实现修改页面呈现、盗取信息，甚至蠕虫攻击的方式，叫做 XSS（跨站脚本）攻击。</li>
</ol>
<p>今天，我们就通过案例来看一下这三个问题，并了解下应对方式。</p>
<h2 id="sql-注入能干的事情比你想象的更多">SQL 注入能干的事情比你想象的更多</h2>
<p>我们应该都听说过 SQL 注入，也可能知道最经典的 SQL 注入的例子，是通过构造’or’1’=&lsquo;1 作为密码实现登录。这种简单的攻击方式，在十几年前可以突破很多后台的登录，但现在很难奏效了。</p>
<p>最近几年，我们的安全意识增强了，都知道使用参数化查询来避免 SQL 注入问题。其中的原理是，使用参数化查询的话，参数只能作为普通数据，不可能作为 SQL 的一部分，以此有效避免 SQL 注入问题。</p>
<p>虽然我们已经开始关注 SQL 注入的问题，但还是有一些认知上的误区，主要表现在以下三个方面：</p>
<p>第一，<strong>认为 SQL 注入问题只可能发生于 Http Get 请求，也就是通过 URL 传入的参数才可能产生注入点</strong>。这是很危险的想法。从注入的难易度上来说，修改 URL 上的 QueryString 和修改 Post 请求体中的数据，没有任何区别，因为黑客是通过工具来注入的，而不是通过修改浏览器上的 URL 来注入的。甚至 Cookie 都可以用来 SQL 注入，任何提供数据的地方都可能成为注入点。</p>
<p>第二，<strong>认为不返回数据的接口，不可能存在注入问题</strong>。其实，黑客完全可以利用 SQL 语句构造出一些不正确的 SQL，导致执行出错。如果服务端直接显示了错误信息，那黑客需要的数据就有可能被带出来，从而达到查询数据的目的。甚至是，即使没有详细的出错信息，黑客也可以通过所谓盲注的方式进行攻击。我后面再具体解释。</p>
<p>第三，<strong>认为 SQL 注入的影响范围，只是通过短路实现突破登录，只需要登录操作加强防范即可</strong>。首先，SQL 注入完全可以实现拖库，也就是下载整个数据库的内容（之后我们会演示），SQL 注入的危害不仅仅是突破后台登录。其次，根据木桶原理，整个站点的安全性受限于安全级别最低的那块短板。因此，对于安全问题，站点的所有模块必须一视同仁，并不是只加强防范所谓的重点模块。</p>
<p>在日常开发中，虽然我们是使用框架来进行数据访问的，但还可能会因为疏漏而导致注入问题。接下来，我就用一个实际的例子配合专业的 SQL 注入工具sqlmap，来测试下 SQL 注入。</p>
<p>首先，在程序启动的时候使用 JdbcTemplate 创建一个 userdata 表（表中只有 ID、用户名、密码三列），并初始化两条用户信息。然后，创建一个不返回任何数据的 Http Post 接口。在实现上，我们通过 SQL 拼接的方式，把传入的用户名入参拼接到 LIKE 子句中实现模糊查询。</p>
<p>//程序启动时进行表结构和数据初始化<br>
@PostConstruct<br>
public void init() {<br>
//删除表<br>
jdbcTemplate.execute(&ldquo;drop table IF EXISTS <code>userdata</code>;&rdquo;);<br>
//创建表，不包含自增 ID、用户名、密码三列<br>
jdbcTemplate.execute(&ldquo;create TABLE <code>userdata</code> (\n&rdquo; +<br>
&quot;  <code>id</code> bigint(20) NOT NULL AUTO_INCREMENT,\n&quot; +<br>
&quot;  <code>name</code> varchar(255) NOT NULL,\n&quot; +<br>
&quot;  <code>password</code> varchar(255) NOT NULL,\n&quot; +<br>
&quot;  PRIMARY KEY (<code>id</code>)\n&quot; +<br>
&ldquo;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;&rdquo;);<br>
//插入两条测试数据<br>
jdbcTemplate.execute(&ldquo;INSERT INTO <code>userdata</code> (name,password) VALUES (&rsquo;test1&rsquo;,&lsquo;haha1&rsquo;),(&rsquo;test2&rsquo;,&lsquo;haha2&rsquo;)&rdquo;);<br>
}<br>
@Autowired<br>
private JdbcTemplate jdbcTemplate;</p>
<p>//用户模糊搜索接口<br>
@PostMapping(&ldquo;jdbcwrong&rdquo;)<br>
public void jdbcwrong(@RequestParam(&ldquo;name&rdquo;) String name) {<br>
//采用拼接 SQL 的方式把姓名参数拼到 LIKE 子句中<br>
log.info(&quot;{}&quot;, jdbcTemplate.queryForList(&ldquo;SELECT id,name FROM userdata WHERE name LIKE &lsquo;%&rdquo; + name + &ldquo;%&rsquo;&rdquo;));<br>
}</p>
<p>使用 sqlmap 来探索这个接口：</p>
<p>python sqlmap.py -u  http://localhost:45678/sqlinject/jdbcwrong &ndash;data name=test</p>
<p>一段时间后，sqlmap 给出了如下结果：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/a015d2c89cb934a886cf5fc5d1921eb7.png" alt=""></p>
<p>可以看到，这个接口的 name 参数有两种可能的注入方式：一种是报错注入，一种是基于时间的盲注。</p>
<p>接下来，<strong>仅需简单的三步，就可以直接导出整个用户表的内容了</strong>。</p>
<p>第一步，查询当前数据库：</p>
<p>python sqlmap.py -u  http://localhost:45678/sqlinject/jdbcwrong &ndash;data name=test &ndash;current-db</p>
<p>可以得到当前数据库是 common_mistakes：</p>
<p>current database: &lsquo;common_mistakes&rsquo;</p>
<p>第二步，查询数据库下的表：</p>
<p>python sqlmap.py -u  http://localhost:45678/sqlinject/jdbcwrong &ndash;data name=test &ndash;tables -D &ldquo;common_mistakes&rdquo;</p>
<p>可以看到其中有一个敏感表 userdata：</p>
<p>Database: common_mistakes<br>
[7 tables]<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+<br>
| user               |<br>
| common_store       |<br>
| hibernate_sequence |<br>
| m                  |<br>
| news               |<br>
| r                  |<br>
| userdata           |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</p>
<p>第三步，查询 userdata 的数据：</p>
<p>python sqlmap.py -u  http://localhost:45678/sqlinject/jdbcwrong &ndash;data name=test -D &ldquo;common_mistakes&rdquo; -T &ldquo;userdata&rdquo; &ndash;dump</p>
<p>你看，<strong>用户密码信息一览无遗。当然，你也可以继续查看其他表的数据</strong>：</p>
<p>Database: common_mistakes<br>
Table: userdata<br>
[2 entries]<br>
+&mdash;-+&mdash;&mdash;-+&mdash;&mdash;&mdash;-+<br>
| id | name  | password |<br>
+&mdash;-+&mdash;&mdash;-+&mdash;&mdash;&mdash;-+<br>
| 1  | test1 | haha1    |<br>
| 2  | test2 | haha2    |<br>
+&mdash;-+&mdash;&mdash;-+&mdash;&mdash;&mdash;-+</p>
<p>在日志中可以看到，sqlmap 实现拖库的方式是，让 SQL 执行后的出错信息包含字段内容。注意看下错误日志的第二行，错误信息中包含 ID 为 2 的用户的密码字段的值“haha2”。这，就是报错注入的基本原理：</p>
<p>[13:22:27.375] [http-nio-45678-exec-10] [ERROR] [o.a.c.c.C.[.[.[/].[dispatcherServlet]:175 ] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.dao.DuplicateKeyException: StatementCallback; SQL [SELECT id,name FROM userdata WHERE name LIKE &lsquo;%test&rsquo;||(SELECT 0x694a6e64 WHERE 3941=3941 AND (SELECT 9927 FROM(SELECT COUNT(*),CONCAT(0x71626a7a71,(SELECT MID((IFNULL(CAST(password AS NCHAR),0x20)),1,54) FROM common_mistakes.userdata ORDER BY id LIMIT 1,1),0x7170706271,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a))||&rsquo;%&rsquo;]; Duplicate entry &lsquo;qbjzqhaha2qppbq1&rsquo; for key &lsquo;&lt;group_key&gt;&rsquo;; nested exception is java.sql.SQLIntegrityConstraintViolationException: Duplicate entry &lsquo;qbjzqhaha2qppbq1&rsquo; for key &lsquo;&lt;group_key&gt;&rsquo;] with root cause<br>
java.sql.SQLIntegrityConstraintViolationException: Duplicate entry &lsquo;qbjzqhaha2qppbq1&rsquo; for key &lsquo;&lt;group_key&gt;&rsquo;</p>
<p>既然是这样，我们就实现一个 ExceptionHandler 来屏蔽异常，看看能否解决注入问题：</p>
<p>@ExceptionHandler<br>
public void handle(HttpServletRequest req, HandlerMethod method, Exception ex) {<br>
log.warn(String.format(&ldquo;访问 %s -&gt; %s 出现异常！&rdquo;, req.getRequestURI(), method.toString()), ex);<br>
}</p>
<p>重启程序后重新运行刚才的 sqlmap 命令，可以看到报错注入是没戏了，但使用时间盲注还是可以查询整个表的数据：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/2891372226ce869bb77fd298b691ef9c.png" alt=""></p>
<p>所谓盲注，指的是注入后并不能从服务器得到任何执行结果（甚至是错误信息），只能寄希望服务器对于 SQL 中的真假条件表现出不同的状态。比如，对于布尔盲注来说，可能是“真”可以得到 200 状态码，“假”可以得到 500 错误状态码；或者，“真”可以得到内容输出，“假”得不到任何输出。总之，对于不同的 SQL 注入可以得到不同的输出即可。</p>
<p>在这个案例中，因为接口没有输出，也彻底屏蔽了错误，布尔盲注这招儿行不通了。那么退而求其次的方式，就是时间盲注。也就是说，通过在真假条件中加入 SLEEP，来实现通过判断接口的响应时间，知道条件的结果是真还是假。</p>
<p>不管是什么盲注，都是通过真假两种状态来完成的。你可能会好奇，通过真假两种状态如何实现数据导出？</p>
<p>其实你可以想一下，我们虽然不能直接查询出 password 字段的值，但可以按字符逐一来查，判断第一个字符是否是 a、是否是 b……，查询到 h 时发现响应变慢了，自然知道这就是真的，得出第一位就是 h。以此类推，可以查询出整个值。</p>
<p>所以，sqlmap 在返回数据的时候，也是一个字符一个字符跳出结果的，并且时间盲注的整个过程会比报错注入慢许多。</p>
<p>你可以引入p6spy工具打印出所有执行的 SQL，观察 sqlmap 构造的一些 SQL，来分析其中原理：</p>
<dependency>  
    <groupId>com.github.gavlyukovskiy</groupId>  
    <artifactId>p6spy-spring-boot-starter</artifactId>  
    <version>1.6.1</version>  
</dependency>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/d3c42050cc7fff9dfd2cc8830c9e9d0b.png" alt=""></p>
<p>所以说，即使屏蔽错误信息错误码，也不能彻底防止 SQL 注入。真正的解决方式，还是使用参数化查询，让任何外部输入值只可能作为数据来处理。</p>
<p>比如，对于之前那个接口，**在 SQL 语句中使用“?”作为参数占位符，然后提供参数值。**这样修改后，sqlmap 也就无能为力了：</p>
<p>@PostMapping(&ldquo;jdbcright&rdquo;)<br>
public void jdbcright(@RequestParam(&ldquo;name&rdquo;) String name) {<br>
log.info(&quot;{}&quot;, jdbcTemplate.queryForList(&ldquo;SELECT id,name FROM userdata WHERE name LIKE ?&rdquo;, &ldquo;%&rdquo; + name + &ldquo;%&rdquo;));<br>
}</p>
<p><strong>对于 MyBatis 来说，同样需要使用参数化的方式来写 SQL 语句。在 MyBatis 中，“#{}”是参数化的方式，“${}”只是占位符替换。</strong></p>
<p>比如 LIKE 语句。因为使用“#{}”会为参数带上单引号，导致 LIKE 语法错误，所以一些同学会退而求其次，选择“${}”的方式，比如：</p>
<p>@Select(&ldquo;SELECT id,name FROM <code>userdata</code> WHERE name LIKE &lsquo;%${name}%&rsquo;&rdquo;)<br>
List<UserData> findByNameWrong(@Param(&ldquo;name&rdquo;) String name);</p>
<p>你可以尝试一下，使用 sqlmap 同样可以实现注入。正确的做法是，使用“#{}”来参数化 name 参数，对于 LIKE 操作可以使用 CONCAT 函数来拼接 % 符号：</p>
<p>@Select(&ldquo;SELECT id,name FROM <code>userdata</code> WHERE name LIKE CONCAT(&rsquo;%&rsquo;,#{name},&rsquo;%&rsquo;)&rdquo;)<br>
List<UserData> findByNameRight(@Param(&ldquo;name&rdquo;) String name);</p>
<p>又比如 IN 子句。因为涉及多个元素的拼接，一些同学不知道如何处理，也可能会选择使用“${}”。因为使用“#{}”会把输入当做一个字符串来对待：</p>
<select id="findByNamesWrong" resultType="org.geekbang.time.commonmistakes.codeanddata.sqlinject.UserData">  
    SELECT id,name FROM `userdata` WHERE name in (${names})  
</select>
<p>但是，这样直接把外部传入的内容替换到 IN 内部，同样会有注入漏洞：</p>
<p>@PostMapping(&ldquo;mybatiswrong2&rdquo;)<br>
public List mybatiswrong2(@RequestParam(&ldquo;names&rdquo;) String names) {<br>
return userDataMapper.findByNamesWrong(names);<br>
}</p>
<p>你可以使用下面这条命令测试下：</p>
<p>python sqlmap.py -u  http://localhost:45678/sqlinject/mybatiswrong2 &ndash;data names=&quot;&rsquo;test1&rsquo;,&rsquo;test2&rsquo;&quot;</p>
<p>最后可以发现，有 4 种可行的注入方式，分别是布尔盲注、报错注入、时间盲注和联合查询注入：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/e1d0ba04283214ea644553c401227faa.png" alt=""></p>
<p>修改方式是，给 MyBatis 传入一个 List，然后使用其 foreach 标签来拼接出 IN 中的内容，并确保 IN 中的每一项都是使用“#{}”来注入参数：</p>
<p>@PostMapping(&ldquo;mybatisright2&rdquo;)<br>
public List mybatisright2(@RequestParam(&ldquo;names&rdquo;) List<String> names) {<br>
return userDataMapper.findByNamesRight(names);<br>
}</p>
<select id="findByNamesRight" resultType="org.geekbang.time.commonmistakes.codeanddata.sqlinject.UserData">  
    SELECT id,name FROM `userdata` WHERE name in  
    <foreach collection="names" item="item" open="(" separator="," close=")">  
        #{item}  
    </foreach>  
</select>
<p>修改后这个接口就不会被注入了，你可以自行测试一下。</p>
<h2 id="小心动态执行代码时代码注入漏洞">小心动态执行代码时代码注入漏洞</h2>
<p>总结下，我们刚刚看到的 SQL 注入漏洞的原因是，黑客把 SQL 攻击代码通过传参混入 SQL 语句中执行。同样，对于任何解释执行的其他语言代码，也可以产生类似的注入漏洞。我们看一个动态执行 JavaScript 代码导致注入漏洞的案例。</p>
<p>现在，我们要对用户名实现动态的规则判断：通过 ScriptEngineManager 获得一个 JavaScript 脚本引擎，使用 Java 代码来动态执行 JavaScript 代码，实现当外部传入的用户名为 admin 的时候返回 1，否则返回 0：</p>
<p>private ScriptEngineManager scriptEngineManager = new ScriptEngineManager();<br>
//获得 JavaScript 脚本引擎<br>
private ScriptEngine jsEngine = scriptEngineManager.getEngineByName(&ldquo;js&rdquo;);</p>
<p>@GetMapping(&ldquo;wrong&rdquo;)<br>
public Object wrong(@RequestParam(&ldquo;name&rdquo;) String name) {<br>
try {<br>
//通过 eval 动态执行 JavaScript 脚本，这里 name 参数通过字符串拼接方式混入 JavaScript 代码<br>
return jsEngine.eval(String.format(&ldquo;var name=&rsquo;%s&rsquo;; name==&lsquo;admin&rsquo;?1:0;&rdquo;, name));<br>
} catch (ScriptException e) {<br>
e.printStackTrace();<br>
}<br>
return null;<br>
}</p>
<p>这个功能本身没什么问题：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/0bd442700b54806e0b62c7a1e9dd0781.png" alt=""></p>
<p>但是，如果我们把传入的用户名修改为这样：</p>
<p>haha&rsquo;;java.lang.System.exit(0);&rsquo;</p>
<p>就可以达到关闭整个程序的目的。原因是，我们直接把代码和数据拼接在了一起。外部如果构造了一个特殊的用户名先闭合字符串的单引号，再执行一条 System.exit 命令的话，就可以满足脚本不出错，命令被执行。</p>
<p>解决这个问题有两种方式。</p>
<p>第一种方式和解决 SQL 注入一样，需要<strong>把外部传入的条件数据仅仅当做数据来对待。我们可以通过 SimpleBindings 来绑定参数初始化 name 变量</strong>，而不是直接拼接代码：</p>
<p>@GetMapping(&ldquo;right&rdquo;)<br>
public Object right(@RequestParam(&ldquo;name&rdquo;) String name) {<br>
try {<br>
//外部传入的参数<br>
Map&lt;String, Object&gt; parm = new HashMap&lt;&gt;();<br>
parm.put(&ldquo;name&rdquo;, name);<br>
//name 参数作为绑定传给 eval 方法，而不是拼接 JavaScript 代码<br>
return jsEngine.eval(&ldquo;name==&lsquo;admin&rsquo;?1:0;&rdquo;, new SimpleBindings(parm));<br>
} catch (ScriptException e) {<br>
e.printStackTrace();<br>
}<br>
return null;<br>
}</p>
<p>这样就避免了注入问题：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/b791b5c5aba205466850e42f75d4b00d.png" alt=""></p>
<p>第二种解决方法是，使用 SecurityManager 配合 AccessControlContext，来构建一个脚本运行的沙箱环境。脚本能执行的所有操作权限，是通过 setPermissions 方法精细化设置的：</p>
<p>@Slf4j<br>
public class ScriptingSandbox {<br>
private ScriptEngine scriptEngine;<br>
private AccessControlContext accessControlContext;</p>
<pre><code>private SecurityManager securityManager;  
private static ThreadLocal&lt;Boolean&gt; needCheck = ThreadLocal.withInitial(() -&gt; false);  

public ScriptingSandbox(ScriptEngine scriptEngine) throws InstantiationException {  
    this.scriptEngine = scriptEngine;  
    securityManager = new SecurityManager(){  
        //仅在需要的时候检查权限  
        @Override  
        public void checkPermission(Permission perm) {  
            if (needCheck.get() &amp;&amp; accessControlContext != null) {  
                super.checkPermission(perm, accessControlContext);  
            }  
        }  
    };  
    //设置执行脚本需要的权限  
    setPermissions(Arrays.asList(  
            new RuntimePermission(&quot;getProtectionDomain&quot;),  
            new PropertyPermission(&quot;jdk.internal.lambda.dumpProxyClasses&quot;,&quot;read&quot;),  
            new FilePermission(Shell.class.getProtectionDomain().getPermissions().elements().nextElement().getName(),&quot;read&quot;),  
            new RuntimePermission(&quot;createClassLoader&quot;),  
            new RuntimePermission(&quot;accessClassInPackage.jdk.internal.org.objectweb.*&quot;),  
            new RuntimePermission(&quot;accessClassInPackage.jdk.nashorn.internal.*&quot;),  
            new RuntimePermission(&quot;accessDeclaredMembers&quot;),  
            new ReflectPermission(&quot;suppressAccessChecks&quot;)  
    ));  
}  
//设置执行上下文的权限  
public void setPermissions(List&lt;Permission&gt; permissionCollection) {  
    Permissions perms = new Permissions();  

    if (permissionCollection != null) {  
        for (Permission p : permissionCollection) {  
            perms.add(p);  
        }  
    }  

    ProtectionDomain domain = new ProtectionDomain(new CodeSource(null, (CodeSigner[]) null), perms);  
    accessControlContext = new AccessControlContext(new ProtectionDomain[]{domain});  
}  

public Object eval(final String code) {  
    SecurityManager oldSecurityManager = System.getSecurityManager();  
    System.setSecurityManager(securityManager);  
    needCheck.set(true);  
    try {  
        //在 AccessController 的保护下执行脚本  
        return AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {  
            try {  
                return scriptEngine.eval(code);  
            } catch (ScriptException e) {  
                e.printStackTrace();  
            }  
            return null;  
        }, accessControlContext);  

    } catch (Exception ex) {  
        log.error(&quot;抱歉，无法执行脚本 {}&quot;, code, ex);  
    } finally {  
        needCheck.set(false);  
        System.setSecurityManager(oldSecurityManager);  
    }  
    return null;  
}
</code></pre>
<p>写一段测试代码，使用刚才定义的 ScriptingSandbox 沙箱工具类来执行脚本：</p>
<p>@GetMapping(&ldquo;right2&rdquo;)<br>
public Object right2(@RequestParam(&ldquo;name&rdquo;) String name) throws InstantiationException {<br>
//使用沙箱执行脚本<br>
ScriptingSandbox scriptingSandbox = new ScriptingSandbox(jsEngine);<br>
return scriptingSandbox.eval(String.format(&ldquo;var name=&rsquo;%s&rsquo;; name==&lsquo;admin&rsquo;?1:0;&rdquo;, name));<br>
}</p>
<p>这次，我们再使用之前的注入脚本调用这个接口：</p>
<p>http://localhost:45678/codeinject/right2?name=haha%27;java.lang.System.exit(0);%27</p>
<p>可以看到，结果中抛出了 AccessControlException 异常，注入攻击失效了：</p>
<p>[13:09:36.080] [http-nio-45678-exec-1] [ERROR] [o.g.t.c.c.codeinject.ScriptingSandbox:77  ] - 抱歉，无法执行脚本 var name=&lsquo;haha&rsquo;;java.lang.System.exit(0);&rsquo;&rsquo;; name==&lsquo;admin&rsquo;?1:0;<br>
java.security.AccessControlException: access denied (&ldquo;java.lang.RuntimePermission&rdquo; &ldquo;exitVM.0&rdquo;)<br>
at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)<br>
at java.lang.SecurityManager.checkPermission(SecurityManager.java:585)<br>
at org.geekbang.time.commonmistakes.codeanddata.codeinject.ScriptingSandbox$1.checkPermission(ScriptingSandbox.java:30)<br>
at java.lang.SecurityManager.checkExit(SecurityManager.java:761)<br>
at java.lang.Runtime.exit(Runtime.java:107)</p>
<p>在实际应用中，我们可以考虑同时使用这两种方法，确保代码执行的安全性。</p>
<h2 id="xss-必须全方位严防死堵">XSS 必须全方位严防死堵</h2>
<p>对于业务开发来说，XSS 的问题同样要引起关注。</p>
<p>XSS 问题的根源在于，原本是让用户传入或输入正常数据的地方，被黑客替换为了 JavaScript 脚本，页面没有经过转义直接显示了这个数据，然后脚本就被执行了。更严重的是，脚本没有经过转义就保存到了数据库中，随后页面加载数据的时候，数据中混入的脚本又当做代码执行了。黑客可以利用这个漏洞来盗取敏感数据，诱骗用户访问钓鱼网站等。</p>
<p>我们写一段代码测试下。首先，服务端定义两个接口，其中 index 接口查询用户名信息返回给 xss 页面，save 接口使用 @RequestParam 注解接收用户名，并创建用户保存到数据库；然后，重定向浏览器到 index 接口：</p>
<p>@RequestMapping(&ldquo;xss&rdquo;)<br>
@Slf4j<br>
@Controller<br>
public class XssController {<br>
@Autowired<br>
private UserRepository userRepository;<br>
//显示 xss 页面<br>
@GetMapping<br>
public String index(ModelMap modelMap) {<br>
//查数据库<br>
User user = userRepository.findById(1L).orElse(new User());<br>
//给 View 提供 Model<br>
modelMap.addAttribute(&ldquo;username&rdquo;, user.getName());<br>
return &ldquo;xss&rdquo;;<br>
}<br>
//保存用户信息<br>
@PostMapping<br>
public String save(@RequestParam(&ldquo;username&rdquo;) String username, HttpServletRequest request) {<br>
User user = new User();<br>
user.setId(1L);<br>
user.setName(username);<br>
userRepository.save(user);<br>
//保存完成后重定向到首页<br>
return &ldquo;redirect:/xss/&rdquo;;<br>
}<br>
}<br>
//用户类，同时作为 DTO 和 Entity<br>
@Entity<br>
@Data<br>
public class User {<br>
@Id<br>
private Long id;<br>
private String name;<br>
}</p>
<p>我们使用 Thymeleaf 模板引擎来渲染页面。模板代码比较简单，页面加载的时候会在标签显示用户名，用户输入用户名提交后调用 save 接口创建用户：</p>
<div style="font-size: 14px">  
    <form id="myForm" method="post" th:action="@{/xss/}">  
        <label th:utext="${username}"/>  
        <input id="username" name="username" size="100" type="text"/>  
        <button th:text="Register" type="submit"/>  
    </form>  
</div>
<p>打开 xss 页面后，在文本框中输入 <script>alert(‘test’)</script> 点击 Register 按钮提交，页面会弹出 alert 对话框：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/2abf9ca77a1e2c8d793e798547e4df7b.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/542823290b4b4ee03389d8c6354e58fd.png" alt=""></p>
<p>并且，脚本被保存到了数据库：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/ef36e7e54cb3894be93650da5fa29e6b.png" alt=""></p>
<p>你可能想到了，解决方式就是 HTML 转码。既然是通过 @RequestParam 来获取请求参数，那我们定义一个 @InitBinder 实现数据绑定的时候，对字符串进行转码即可：</p>
<p>@ControllerAdvice<br>
public class SecurityAdvice {<br>
@InitBinder<br>
protected void initBinder(WebDataBinder binder) {<br>
//注册自定义的绑定器<br>
binder.registerCustomEditor(String.class, new PropertyEditorSupport() {<br>
@Override<br>
public String getAsText() {<br>
Object value = getValue();<br>
return value != null ? value.toString() : &ldquo;&rdquo;;<br>
}<br>
@Override<br>
public void setAsText(String text) {<br>
//赋值时进行 HTML 转义<br>
setValue(text == null ? null : HtmlUtils.htmlEscape(text));<br>
}<br>
});<br>
}<br>
}</p>
<p>的确，针对这个场景，这种做法是可行的。数据库中保存了转义后的数据，因此数据会被当做 HTML 显示在页面上，而不是当做脚本执行：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/c80259ff5964e539b4b41fb657c79d6c.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/da97fe0c8efb224425fa46cba892644b.png" alt=""></p>
<p>但是，这种处理方式犯了一个严重的错误，那就是没有从根儿上来处理安全问题。因为 @InitBinder 是 Spring Web 层面的处理逻辑，如果有代码不通过 @RequestParam 来获取数据，而是直接从 HTTP 请求获取数据的话，这种方式就不会奏效。比如这样：</p>
<p>user.setName(request.getParameter(&ldquo;username&rdquo;));</p>
<p>更合理的解决方式是，定义一个 servlet Filter，通过 HttpServletRequestWrapper 实现 servlet 层面的统一参数替换：</p>
<p>//自定义过滤器<br>
@Component<br>
@Order(Ordered.HIGHEST_PRECEDENCE)<br>
public class XssFilter implements Filter {<br>
@Override<br>
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {<br>
chain.doFilter(new XssRequestWrapper((HttpServletRequest) request), response);<br>
}<br>
}<br>
public class XssRequestWrapper extends HttpServletRequestWrapper {</p>
<pre><code>public XssRequestWrapper(HttpServletRequest request) {  
    super(request);  
}  

@Override  
public String[] getParameterValues(String parameter) {  
    //获取多个参数值的时候对所有参数值应用 clean 方法逐一清洁  
    return Arrays.stream(super.getParameterValues(parameter)).map(this::clean).toArray(String[]::new);  
}  

@Override  
public String getHeader(String name) {  
    //同样清洁请求头  
    return clean(super.getHeader(name));  
}  

@Override  
public String getParameter(String parameter) {  
    //获取参数单一值也要处理  
    return clean(super.getParameter(parameter));  
}  
//clean 方法就是对值进行 HTML 转义  
private String clean(String value) {  
  return StringUtils.isEmpty(value)? &quot;&quot; : HtmlUtils.htmlEscape(value);  
}  
</code></pre>
<p>}</p>
<p>这样，我们就可以实现所有请求参数的 HTML 转义了。不过，这种方式还是不够彻底，原因是无法处理通过 @RequestBody 注解提交的 JSON 数据。比如，有这样一个 PUT 接口，直接保存了客户端传入的 JSON User 对象：</p>
<p>@PutMapping<br>
public void put(@RequestBody User user) {<br>
userRepository.save(user);<br>
}</p>
<p>通过 Postman 请求这个接口，保存到数据库中的数据还是没有转义：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/0cca4938b225fd6a6d4a9c086f6f4bcd.png" alt=""></p>
<p>我们需要自定义一个 Jackson 反列化器，来实现反序列化时的字符串的 HTML 转义：</p>
<p>//注册自定义的 Jackson 反序列器<br>
@Bean<br>
public Module xssModule() {<br>
SimpleModule module = new SimpleModule();<br>
module.module.addDeserializer(String.class, new XssJsonDeserializer());<br>
return module;<br>
}</p>
<p>public class XssJsonDeserializer extends JsonDeserializer<String> {<br>
@Override<br>
public String deserialize(JsonParser jsonParser, DeserializationContext ctxt) throws IOException, JsonProcessingException {<br>
String value = jsonParser.getValueAsString();<br>
if (value != null) {<br>
//对于值进行 HTML 转义<br>
return HtmlUtils.htmlEscape(value);<br>
}<br>
return value;<br>
}</p>
<pre><code>@Override  
public Class&lt;String&gt; handledType() {  
    return String.class;  
}  
</code></pre>
<p>}</p>
<p>这样就实现了既能转义 Get/Post 通过请求参数提交的数据，又能转义请求体中直接提交的 JSON 数据。</p>
<p>你可能觉得做到这里，我们的防范已经很全面了，但其实不是。这种只能堵新漏，确保新数据进入数据库之前转义。如果因为之前的漏洞，数据库中已经保存了一些 JavaScript 代码，那么读取的时候同样可能出问题。因此，我们还要实现数据读取的时候也转义。</p>
<p>接下来，我们看一下具体的实现方式。</p>
<p>首先，之前我们处理了 JSON 反序列化问题，那么就需要同样处理序列化，实现数据从数据库中读取的时候转义，否则读出来的 JSON 可能包含 JavaScript 代码。</p>
<p>比如，我们定义这样一个 GET 接口以 JSON 来返回用户信息：</p>
<p>@GetMapping(&ldquo;user&rdquo;)<br>
@ResponseBody<br>
public User query() {<br>
return userRepository.findById(1L).orElse(new User());<br>
}</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/832282c8c709429fc2266f2bb2ede2fa.png" alt=""></p>
<p>修改之前的 SimpleModule 加入自定义序列化器，并且实现序列化时处理字符串转义：</p>
<p>//注册自定义的 Jackson 序列器<br>
@Bean<br>
public Module xssModule() {<br>
SimpleModule module = new SimpleModule();<br>
module.addDeserializer(String.class, new XssJsonDeserializer());<br>
module.addSerializer(String.class, new XssJsonSerializer());<br>
return module;<br>
}</p>
<p>public class XssJsonSerializer extends JsonSerializer<String> {<br>
@Override<br>
public Class<String> handledType() {<br>
return String.class;<br>
}</p>
<pre><code>@Override  
public void serialize(String value, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {  
    if (value != null) {  
        //对字符串进行 HTML 转义  
        jsonGenerator.writeString(HtmlUtils.htmlEscape(value));  
    }  
}  
</code></pre>
<p>}</p>
<p>可以看到，这次读到的 JSON 也转义了：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/13bd814e59a4e041d865543711fba893.png" alt=""></p>
<p>其次，我们还需要处理 HTML 模板。对于 Thymeleaf 模板引擎，需要注意的是，使用 th:utext 来显示数据是不会进行转义的，需要使用 th:text：</p>
<label th:text="${username}"/>
<p>经过修改后，即使数据库中已经保存了 JavaScript 代码，呈现的时候也只能作为 HTML 显示了。现在，对于进和出两个方向，我们都实现了补漏。</p>
<p>但，所谓百密总有一疏。为了避免疏漏，进一步控制 XSS 可能带来的危害，我们还要考虑一种情况：如果需要在 Cookie 中写入敏感信息的话，我们可以开启 HttpOnly 属性。这样 JavaScript 代码就无法读取 Cookie 了，即便页面被 XSS 注入了攻击代码，也无法获得我们的 Cookie。</p>
<p>写段代码测试一下。定义两个接口，其中 readCookie 接口读取 Key 为 test 的 Cookie，writeCookie 接口写入 Cookie，根据参数 HttpOnly 确定 Cookie 是否开启 HttpOnly：</p>
<p>//服务端读取 Cookie<br>
@GetMapping(&ldquo;readCookie&rdquo;)<br>
@ResponseBody<br>
public String readCookie(@CookieValue(&ldquo;test&rdquo;) String cookieValue) {<br>
return cookieValue;<br>
}<br>
//服务端写入 Cookie<br>
@GetMapping(&ldquo;writeCookie&rdquo;)<br>
@ResponseBody<br>
public void writeCookie(@RequestParam(&ldquo;httpOnly&rdquo;) boolean httpOnly, HttpServletResponse response) {<br>
Cookie cookie = new Cookie(&ldquo;test&rdquo;, &ldquo;zhuye&rdquo;);<br>
//根据 httpOnly 入参决定是否开启 HttpOnly 属性<br>
cookie.setHttpOnly(httpOnly);<br>
response.addCookie(cookie);<br>
}</p>
<p>可以看到，由于 test 和 _ga 这两个 Cookie 不是 HttpOnly 的。通过 document.cookie 可以输出这两个 Cookie 的内容：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/018045c41c2f8058a0260ccb14d22d72.png" alt=""></p>
<p>为 test 这个 Cookie 启用了 HttpOnly 属性后，就不能被 document.cookie 读取到了，输出中只有 _ga 一项：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/58981ee5a1a9bf35680562a5f3278c58.png" alt=""></p>
<p>但是服务端可以读取到这个 cookie：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/93c0de74fbec6c1afa36b1c6a5ce781c.png" alt=""></p>
<h2 id="重点回顾">重点回顾</h2>
<p>今天，我通过案例，和你具体分析了 SQL 注入和 XSS 攻击这两类注入类安全问题。</p>
<p>在学习 SQL 注入的时候，我们通过 sqlmap 工具看到了几种常用注入方式，这可能改变了我们对 SQL 注入威力的认知：对于 POST 请求、请求没有任何返回数据、请求不会出错的情况下，仍然可以完成注入，并可以导出数据库的所有数据。</p>
<p>对于 SQL 注入来说，避免参数化的查询是最好的堵漏方式；对于 JdbcTemplate 来说，我们可以使用“?”作为参数占位符；对于 MyBatis 来说，我们需要使用“#{}”进行参数化处理。</p>
<p>和 SQL 注入类似的是，脚本引擎动态执行代码，需要确保外部传入的数据只能作为数据来处理，不能和代码拼接在一起，只能作为参数来处理。代码和数据之间需要划出清晰的界限，否则可能产生代码注入问题。同时，我们可以通过设置一个代码的执行沙箱来细化代码的权限，这样即便产生了注入问题，因为权限受限注入攻击也很难发挥威力。</p>
<p><strong>随后通过学习 XSS 案例，我们认识到处理安全问题需要确保三点。</strong></p>
<ol>
<li>第一，要从根本上、从最底层进行堵漏，尽量不要在高层框架层面做，否则堵漏可能不彻底。</li>
<li>第二，堵漏要同时考虑进和出，不仅要确保数据存入数据库的时候进行了转义或过滤，还要在取出数据呈现的时候再次转义，确保万无一失。</li>
<li>第三，除了直接堵漏外，我们还可以通过一些额外的手段限制漏洞的威力。比如，为 Cookie 设置 HttpOnly 属性，来防止数据被脚本读取；又比如，尽可能限制字段的最大保存长度，即使出现漏洞，也会因为长度问题限制黑客构造复杂攻击脚本的能力。</li>
</ol>
<p>今天用到的代码，我都放在了 GitHub 上，你可以点击这个链接查看。</p>
<h2 id="思考与讨论">思考与讨论</h2>
<ol>
<li>在讨论 SQL 注入案例时，最后那次测试我们看到 sqlmap 返回了 4 种注入方式。其中，布尔盲注、时间盲注和报错注入，我都介绍过了。你知道联合查询注入，是什么吗？</li>
<li>在讨论 XSS 的时候，对于 Thymeleaf 模板引擎，我们知道如何让文本进行 HTML 转义显示。FreeMarker 也是 Java 中很常用的模板引擎，你知道如何处理转义吗？</li>
</ol>
<p>你还遇到过其他类型的注入问题吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把今天的内容分享给你的朋友或同事，一起交流。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/">Java业务开发常见错误100例</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/29__%E5%AE%9E%E6%88%98%E5%9B%9B%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%94%BB%E5%9B%BE%E7%A8%8B%E5%BA%8F/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">29__实战（四）：怎么设计一个“画图”程序？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%9C%B1%E8%B5%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E8%AF%BE/29__%E8%AF%B4%E8%AF%B4%E7%A1%85%E8%B0%B7%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/">
            <span class="next-text nav-default">29__说说硅谷互联网公司的开发流程</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
