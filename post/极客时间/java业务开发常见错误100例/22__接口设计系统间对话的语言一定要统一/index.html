<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>22__接口设计：系统间对话的语言，一定要统一 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是朱晔。今天，我要和你分享的主题是，在做接口设计时一定要确保系统之间对话的语言是统一的。
我们知道，开发一个服务的第一步就是设计接口。接口的设计需要考虑的点非常多，比如接口的命名、参数列表、包装结构体、接口粒度、版本策略、幂等性实现、同步异步处理方式等。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/22__%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F%E9%97%B4%E5%AF%B9%E8%AF%9D%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B8%80%E5%AE%9A%E8%A6%81%E7%BB%9F%E4%B8%80/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/22__%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F%E9%97%B4%E5%AF%B9%E8%AF%9D%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B8%80%E5%AE%9A%E8%A6%81%E7%BB%9F%E4%B8%80/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="22__接口设计：系统间对话的语言，一定要统一">
  <meta property="og:description" content="你好，我是朱晔。今天，我要和你分享的主题是，在做接口设计时一定要确保系统之间对话的语言是统一的。
我们知道，开发一个服务的第一步就是设计接口。接口的设计需要考虑的点非常多，比如接口的命名、参数列表、包装结构体、接口粒度、版本策略、幂等性实现、同步异步处理方式等。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Java业务开发常见错误100例">

  <meta itemprop="name" content="22__接口设计：系统间对话的语言，一定要统一">
  <meta itemprop="description" content="你好，我是朱晔。今天，我要和你分享的主题是，在做接口设计时一定要确保系统之间对话的语言是统一的。
我们知道，开发一个服务的第一步就是设计接口。接口的设计需要考虑的点非常多，比如接口的命名、参数列表、包装结构体、接口粒度、版本策略、幂等性实现、同步异步处理方式等。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7393">
  <meta itemprop="keywords" content="Java业务开发常见错误100例">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="22__接口设计：系统间对话的语言，一定要统一">
  <meta name="twitter:description" content="你好，我是朱晔。今天，我要和你分享的主题是，在做接口设计时一定要确保系统之间对话的语言是统一的。
我们知道，开发一个服务的第一步就是设计接口。接口的设计需要考虑的点非常多，比如接口的命名、参数列表、包装结构体、接口粒度、版本策略、幂等性实现、同步异步处理方式等。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">22__接口设计：系统间对话的语言，一定要统一</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7393 字 </span>
          <span class="more-meta"> 预计阅读 15 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#接口的响应要明确表示接口的处理结果">接口的响应要明确表示接口的处理结果</a></li>
        <li><a href="#要考虑接口变迁的版本控制策略">要考虑接口变迁的版本控制策略</a></li>
        <li><a href="#接口处理方式要明确同步还是异步">接口处理方式要明确同步还是异步</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考与讨论">思考与讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是朱晔。今天，我要和你分享的主题是，在做接口设计时一定要确保系统之间对话的语言是统一的。</p>
<p>我们知道，开发一个服务的第一步就是设计接口。接口的设计需要考虑的点非常多，比如接口的命名、参数列表、包装结构体、接口粒度、版本策略、幂等性实现、同步异步处理方式等。</p>
<p>这其中，和接口设计相关比较重要的点有三个，分别是包装结构体、版本策略、同步异步处理方式。今天，我就通过我遇到的实际案例，和你一起看看因为接口设计思路和调用方理解不一致所导致的问题，以及相关的实践经验。</p>
<h2 id="接口的响应要明确表示接口的处理结果">接口的响应要明确表示接口的处理结果</h2>
<p>我曾遇到过一个处理收单的收单中心项目，下单接口返回的响应体中，包含了 success、code、info、message 等属性，以及二级嵌套对象 data 结构体。在对项目进行重构的时候，我们发现真的是无从入手，接口缺少文档，代码一有改动就出错。</p>
<p>有时候，下单操作的响应结果是这样的：success 是 true、message 是 OK，貌似代表下单成功了；但 info 里却提示订单存在风险，code 是一个 5001 的错误码，data 中能看到订单状态是 Cancelled，订单 ID 是 -1，好像又说明没有下单成功。</p>
<p>{<br>
&ldquo;success&rdquo;: true,<br>
&ldquo;code&rdquo;: 5001,<br>
&ldquo;info&rdquo;: &ldquo;Risk order detected&rdquo;,<br>
&ldquo;message&rdquo;: &ldquo;OK&rdquo;,<br>
&ldquo;data&rdquo;: {<br>
&ldquo;orderStatus&rdquo;: &ldquo;Cancelled&rdquo;,<br>
&ldquo;orderId&rdquo;: -1<br>
}<br>
}</p>
<p>有些时候，这个下单接口又会返回这样的结果：success 是 false，message 提示非法用户 ID，看上去下单失败；但 data 里的 orderStatus 是 Created、info 是空、code 是 0。那么，这次下单到底是成功还是失败呢？</p>
<p>{<br>
&ldquo;success&rdquo;: false,<br>
&ldquo;code&rdquo;: 0,<br>
&ldquo;info&rdquo;: &ldquo;&rdquo;,<br>
&ldquo;message&rdquo;: &ldquo;Illegal userId&rdquo;,<br>
&ldquo;data&rdquo;: {<br>
&ldquo;orderStatus&rdquo;: &ldquo;Created&rdquo;,<br>
&ldquo;orderId&rdquo;: 0<br>
}<br>
}</p>
<p>这样的结果，让我们非常疑惑：</p>
<ol>
<li>结构体的 code 和 HTTP 响应状态码，是什么关系？</li>
<li>success 到底代表下单成功还是失败？</li>
<li>info 和 message 的区别是什么？</li>
<li>data 中永远都有数据吗？什么时候应该去查询 data？</li>
</ol>
<p>造成如此混乱的原因是：这个收单服务本身并不真正处理下单操作，只是做一些预校验和预处理；真正的下单操作，需要在收单服务内部调用另一个订单服务来处理；订单服务处理完成后，会返回订单状态和 ID。</p>
<p>在一切正常的情况下，下单后的订单状态就是已创建 Created，订单 ID 是一个大于 0 的数字。而结构体中的 message 和 success，其实是收单服务的处理异常信息和处理成功与否的结果，code、info 是调用订单服务的结果。</p>
<p>对于第一次调用，收单服务自己没问题，success 是 true，message 是 OK，但调用订单服务时却因为订单风险问题被拒绝，所以 code 是 5001，info 是 Risk order detected，data 中的信息是订单服务返回的，所以最终订单状态是 Cancelled。</p>
<p>对于第二次调用，因为用户 ID 非法，所以收单服务在校验了参数后直接就返回了 success 是 false，message 是 Illegal userId。因为请求没有到订单服务，所以 info、code、data 都是默认值，订单状态的默认值是 Created。因此，第二次下单肯定失败了，但订单状态却是已创建。</p>
<p>可以看到，如此混乱的接口定义和实现方式，是无法让调用者分清到底应该怎么处理的。<strong>为了将接口设计得更合理，我们需要考虑如下两个原则：</strong></p>
<ol>
<li>对外隐藏内部实现。虽然说收单服务调用订单服务进行真正的下单操作，但是直接接口其实是收单服务提供的，收单服务不应该“直接”暴露其背后订单服务的状态码、错误描述。</li>
<li>设计接口结构时，明确每个字段的含义，以及客户端的处理方式。</li>
</ol>
<p>基于这两个原则，我们调整一下返回结构体，去掉外层的 info，即不再把订单服务的调用结果告知客户端：</p>
<p>@Data<br>
public class APIResponse<T> {<br>
private boolean success;<br>
private T data;<br>
private int code;<br>
private String message;<br>
}</p>
<p>并明确接口的设计逻辑：</p>
<ol>
<li>如果出现非 200 的 HTTP 响应状态码，就代表请求没有到收单服务，可能是网络出问题、网络超时，或者网络配置的问题。这时，肯定无法拿到服务端的响应体，客户端可以给予友好提示，比如让用户重试，不需要继续解析响应结构体。</li>
<li>如果 HTTP 响应码是 200，解析响应体查看 success，为 false 代表下单请求处理失败，可能是因为收单服务参数验证错误，也可能是因为订单服务下单操作失败。这时，根据收单服务定义的错误码表和 code，做不同处理。比如友好提示，或是让用户重新填写相关信息，其中友好提示的文字内容可以从 message 中获取。</li>
<li>success 为 true 的情况下，才需要继续解析响应体中的 data 结构体。data 结构体代表了业务数据，通常会有下面两种情况。</li>
<li>通常情况下，success 为 true 时订单状态是 Created，获取 orderId 属性可以拿到订单号。</li>
<li>特殊情况下，比如收单服务内部处理不当，或是订单服务出现了额外的状态，虽然 success 为 true，但订单实际状态不是 Created，这时可以给予友好的错误提示。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/a57c93bc57d2c80e1a48752a716021e8.png" alt=""></p>
<p>明确了接口的设计逻辑，我们就是可以实现收单服务的服务端和客户端来模拟这些情况了。</p>
<p>首先，实现服务端的逻辑：</p>
<p>@GetMapping(&ldquo;server&rdquo;)<br>
public APIResponse<OrderInfo> server(@RequestParam(&ldquo;userId&rdquo;) Long userId) {<br>
APIResponse<OrderInfo> response = new APIResponse&lt;&gt;();<br>
if (userId == null) {<br>
//对于 userId 为空的情况，收单服务直接处理失败，给予相应的错误码和错误提示<br>
response.setSuccess(false);<br>
response.setCode(3001);<br>
response.setMessage(&ldquo;Illegal userId&rdquo;);<br>
} else if (userId == 1) {<br>
//对于 userId=1 的用户，模拟订单服务对于风险用户的情况<br>
response.setSuccess(false);<br>
//把订单服务返回的错误码转换为收单服务错误码<br>
response.setCode(3002);<br>
response.setMessage(&ldquo;Internal Error, order is cancelled&rdquo;);<br>
//同时日志记录内部错误<br>
log.warn(&ldquo;用户 {} 调用订单服务失败，原因是 Risk order detected&rdquo;, userId);<br>
} else {<br>
//其他用户，下单成功<br>
response.setSuccess(true);<br>
response.setCode(2000);<br>
response.setMessage(&ldquo;OK&rdquo;);<br>
response.setData(new OrderInfo(&ldquo;Created&rdquo;, 2L));<br>
}<br>
return response;<br>
}</p>
<p>客户端代码，则可以按照流程图上的逻辑来实现，同样模拟三种出错情况和正常下单的情况：</p>
<ol>
<li>error==1 的用例模拟一个不存在的 URL，请求无法到收单服务，会得到 404 的 HTTP 状态码，直接进行友好提示，这是第一层处理。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/c24d7159de764d8a45ca4a2f3330dcc7.png" alt=""></p>
<ol>
<li>error==2 的用例模拟 userId 参数为空的情况，收单服务会因为缺少 userId 参数提示非法用户。这时，可以把响应体中的 message 展示给用户，这是第二层处理。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/f6700a8c24fec1a22fc81ed32eebb97d.png" alt=""></p>
<ol>
<li>error==3 的用例模拟 userId 为 1 的情况，因为用户有风险，收单服务调用订单服务出错。处理方式和之前没有任何区别，因为收单服务会屏蔽订单服务的内部错误。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/2f9d79c894822ef2d5f33988b6896958.png" alt=""></p>
<p>但在服务端可以看到如下错误信息：</p>
<p>[14:13:13.951] [http-nio-45678-exec-8] [WARN ] [.c.a.d.APIThreeLevelStatusController:36  ] - 用户 1 调用订单服务失败，原因是 Risk order detected</p>
<ol>
<li>error==0 的用例模拟正常用户，下单成功。这时可以解析 data 结构体提取业务结果，作为兜底，需要判断订单状态，如果不是 Created 则给予友好提示，否则查询 orderId 获得下单的订单号，这是第三层处理。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/016f7754c28e46d9fbc0040c65850917.png" alt=""></p>
<p>客户端的实现代码如下：</p>
<p>@GetMapping(&ldquo;client&rdquo;)<br>
public String client(@RequestParam(value = &ldquo;error&rdquo;, defaultValue = &ldquo;0&rdquo;) int error) {<br>
String url = Arrays.asList(&ldquo;http://localhost:45678/apiresposne/server?userId=2&rdquo;,<br>
&ldquo;http://localhost:45678/apiresposne/server2&rdquo;,<br>
&ldquo;http://localhost:45678/apiresposne/server?userId=&rdquo;,<br>
&ldquo;http://localhost:45678/apiresposne/server?userId=1&rdquo;).get(error);</p>
<pre><code>//第一层，先看状态码，如果状态码不是 200，不处理响应体  
String response = &quot;&quot;;  
try {  
    response = Request.Get(url).execute().returnContent().asString();  
} catch (HttpResponseException e) {  
    log.warn(&quot;请求服务端出现返回非 200&quot;, e);  
    return &quot;服务器忙，请稍后再试！&quot;;  
} catch (IOException e) {  
    e.printStackTrace();  
}  

//状态码为 200 的情况下处理响应体  
if (!response.equals(&quot;&quot;)) {  
    try {  
        APIResponse&lt;OrderInfo&gt; apiResponse = objectMapper.readValue(response, new TypeReference&lt;APIResponse&lt;OrderInfo&gt;&gt;() {  
        });  
        //第二层，success 是 false 直接提示用户  
        if (!apiResponse.isSuccess()) {  
            return String.format(&quot;创建订单失败，请稍后再试，错误代码： %s 错误原因：%s&quot;, apiResponse.getCode(), apiResponse.getMessage());  
        } else {  
            //第三层，往下解析 OrderInfo  
            OrderInfo orderInfo = apiResponse.getData();  
            if (&quot;Created&quot;.equals(orderInfo.getStatus()))  
                return String.format(&quot;创建订单成功，订单号是：%s，状态是：%s&quot;, orderInfo.getOrderId(), orderInfo.getStatus());  
            else  
                return String.format(&quot;创建订单失败，请联系客服处理&quot;);  
        }  
    } catch (JsonProcessingException e) {  
        e.printStackTrace();  
    }  
}  
return &quot;&quot;;  
</code></pre>
<p>}</p>
<p><strong>相比原来混乱的接口定义和处理逻辑，改造后的代码，明确了接口每一个字段的含义，以及对于各种情况服务端的输出和客户端的处理步骤，对齐了客户端和服务端的处理逻辑</strong>。那么现在，你能回答前面那 4 个让人疑惑的问题了吗？</p>
<p>最后分享一个小技巧。为了简化服务端代码，我们可以把包装 API 响应体 APIResponse 的工作交由框架自动完成，这样直接返回 DTO OrderInfo 即可。对于业务逻辑错误，可以抛出一个自定义异常：</p>
<p>@GetMapping(&ldquo;server&rdquo;)<br>
public OrderInfo server(@RequestParam(&ldquo;userId&rdquo;) Long userId) {<br>
if (userId == null) {<br>
throw new APIException(3001, &ldquo;Illegal userId&rdquo;);<br>
}</p>
<pre><code>if (userId == 1) {  
    ...  
    //直接抛出异常  
    throw new APIException(3002, &quot;Internal Error, order is cancelled&quot;);  
}  
//直接返回 DTO  
return new OrderInfo(&quot;Created&quot;, 2L);  
</code></pre>
<p>}</p>
<p>在 APIException 中包含错误码和错误消息：</p>
<p>public class APIException extends RuntimeException {<br>
@Getter<br>
private int errorCode;<br>
@Getter<br>
private String errorMessage;</p>
<pre><code>public APIException(int errorCode, String errorMessage) {  
    super(errorMessage);  
    this.errorCode = errorCode;  
    this.errorMessage = errorMessage;  
}  

public APIException(Throwable cause, int errorCode, String errorMessage) {  
    super(errorMessage, cause);  
    this.errorCode = errorCode;  
    this.errorMessage = errorMessage;  
}  
</code></pre>
<p>}</p>
<p>然后，定义一个 @RestControllerAdvice 来完成自动包装响应体的工作：</p>
<ol>
<li>通过实现 ResponseBodyAdvice 接口的 beforeBodyWrite 方法，来处理成功请求的响应体转换。</li>
<li>实现一个 @ExceptionHandler 来处理业务异常时，APIException 到 APIResponse 的转换。</li>
</ol>
<p>//此段代码只是 Demo，生产级应用还需要扩展很多细节<br>
@RestControllerAdvice<br>
@Slf4j<br>
public class APIResponseAdvice implements ResponseBodyAdvice<Object> {</p>
<pre><code>//自动处理 APIException，包装为 APIResponse  
@ExceptionHandler(APIException.class)  
public APIResponse handleApiException(HttpServletRequest request, APIException ex) {  
    log.error(&quot;process url {} failed&quot;, request.getRequestURL().toString(), ex);  
    APIResponse apiResponse = new APIResponse();  
    apiResponse.setSuccess(false);  
    apiResponse.setCode(ex.getErrorCode());  
    apiResponse.setMessage(ex.getErrorMessage());  
    return apiResponse;  
}  

//仅当方法或类没有标记@NoAPIResponse 才自动包装  
@Override  
public boolean supports(MethodParameter returnType, Class converterType) {  
    return returnType.getParameterType() != APIResponse.class  
            &amp;&amp; AnnotationUtils.findAnnotation(returnType.getMethod(), NoAPIResponse.class) == null  
            &amp;&amp; AnnotationUtils.findAnnotation(returnType.getDeclaringClass(), NoAPIResponse.class) == null;  
}  

//自动包装外层 APIResposne 响应  
@Override  
public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {  
    APIResponse apiResponse = new APIResponse();  
    apiResponse.setSuccess(true);  
    apiResponse.setMessage(&quot;OK&quot;);  
    apiResponse.setCode(2000);  
    apiResponse.setData(body);  
    return apiResponse;  
}  
</code></pre>
<p>}</p>
<p>在这里，我们实现了一个 @NoAPIResponse 自定义注解。如果某些 @RestController 的接口不希望实现自动包装的话，可以标记这个注解：</p>
<p>@Target({ElementType.METHOD, ElementType.TYPE})<br>
@Retention(RetentionPolicy.RUNTIME)<br>
public @interface NoAPIResponse {<br>
}</p>
<p>在 ResponseBodyAdvice 的 support 方法中，我们排除了标记有这个注解的方法或类的自动响应体包装。比如，对于刚才我们实现的测试客户端 client 方法不需要包装为 APIResponse，就可以标记上这个注解：</p>
<p>@GetMapping(&ldquo;client&rdquo;)<br>
@NoAPIResponse<br>
public String client(@RequestParam(value = &ldquo;error&rdquo;, defaultValue = &ldquo;0&rdquo;) int error)</p>
<p>这样我们的业务逻辑中就不需要考虑响应体的包装，代码会更简洁。</p>
<h2 id="要考虑接口变迁的版本控制策略">要考虑接口变迁的版本控制策略</h2>
<p>接口不可能一成不变，需要根据业务需求不断增加内部逻辑。如果做大的功能调整或重构，涉及参数定义的变化或是参数废弃，导致接口无法向前兼容，这时接口就需要有版本的概念。在考虑接口版本策略设计时，我们需要注意的是，最好一开始就明确版本策略，并考虑在整个服务端统一版本策略。</p>
<p><strong>第一，版本策略最好一开始就考虑。</strong></p>
<p>既然接口总是要变迁的，那么最好一开始就确定版本策略。比如，确定是通过 URL Path 实现，是通过 QueryString 实现，还是通过 HTTP 头实现。这三种实现方式的代码如下：</p>
<p>//通过 URL Path 实现版本控制<br>
@GetMapping(&quot;/v1/api/user&quot;)<br>
public int right1(){<br>
return 1;<br>
}<br>
//通过 QueryString 中的 version 参数实现版本控制<br>
@GetMapping(value = &ldquo;/api/user&rdquo;, params = &ldquo;version=2&rdquo;)<br>
public int right2(@RequestParam(&ldquo;version&rdquo;) int version) {<br>
return 2;<br>
}<br>
//通过请求头中的 X-API-VERSION 参数实现版本控制<br>
@GetMapping(value = &ldquo;/api/user&rdquo;, headers = &ldquo;X-API-VERSION=3&rdquo;)<br>
public int right3(@RequestHeader(&ldquo;X-API-VERSION&rdquo;) int version) {<br>
return 3;<br>
}</p>
<p>这样，客户端就可以在配置中处理相关版本控制的参数，有可能实现版本的动态切换。</p>
<p>这三种方式中，URL Path 的方式最直观也最不容易出错；QueryString 不易携带，不太推荐作为公开 API 的版本策略；HTTP 头的方式比较没有侵入性，如果仅仅是部分接口需要进行版本控制，可以考虑这种方式。</p>
<p><strong>第二，版本实现方式要统一。</strong></p>
<p>之前，我就遇到过一个 O2O 项目，需要针对商品、商店和用户实现 REST 接口。虽然大家约定通过 URL Path 方式实现 API 版本控制，但实现方式不统一，有的是 /api/item/v1，有的是 /api/v1/shop，还有的是 /v1/api/merchant：</p>
<p>@GetMapping(&quot;/api/item/v1&quot;)<br>
public void wrong1(){<br>
}</p>
<p>@GetMapping(&quot;/api/v1/shop&quot;)<br>
public void wrong2(){<br>
}</p>
<p>@GetMapping(&quot;/v1/api/merchant&quot;)<br>
public void wrong3(){<br>
}</p>
<p>显然，商品、商店和商户的接口开发同学，没有按照一致的 URL 格式来实现接口的版本控制。更要命的是，我们可能开发出两个 URL 类似接口，比如一个是 /api/v1/user，另一个是 /api/user/v1，这到底是一个接口还是两个接口呢？</p>
<p>相比于在每一个接口的 URL Path 中设置版本号，更理想的方式是在框架层面实现统一。如果你使用 Spring 框架的话，可以按照下面的方式自定义 RequestMappingHandlerMapping 来实现。</p>
<p>首先，创建一个注解来定义接口的版本。@APIVersion 自定义注解可以应用于方法或 Controller 上：</p>
<p>@Target({ElementType.METHOD, ElementType.TYPE})<br>
@Retention(RetentionPolicy.RUNTIME)<br>
public @interface APIVersion {<br>
String[] value();<br>
}</p>
<p>然后，定义一个 APIVersionHandlerMapping 类继承 RequestMappingHandlerMapping。</p>
<p>RequestMappingHandlerMapping 的作用，是根据类或方法上的 @RequestMapping 来生成 RequestMappingInfo 的实例。我们覆盖 registerHandlerMethod 方法的实现，从 @APIVersion 自定义注解中读取版本信息，拼接上原有的、不带版本号的 URL Pattern，构成新的 RequestMappingInfo，来通过注解的方式为接口增加基于 URL 的版本号：</p>
<p>public class APIVersionHandlerMapping extends RequestMappingHandlerMapping {<br>
@Override<br>
protected boolean isHandler(Class<?> beanType) {<br>
return AnnotatedElementUtils.hasAnnotation(beanType, Controller.class);<br>
}</p>
<pre><code>@Override  
protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {  
    Class&lt;?&gt; controllerClass = method.getDeclaringClass();  
    //类上的 APIVersion 注解  
    APIVersion apiVersion = AnnotationUtils.findAnnotation(controllerClass, APIVersion.class);  
    //方法上的 APIVersion 注解  
    APIVersion methodAnnotation = AnnotationUtils.findAnnotation(method, APIVersion.class);  
    //以方法上的注解优先  
    if (methodAnnotation != null) {  
        apiVersion = methodAnnotation;  
    }  

    String[] urlPatterns = apiVersion == null ? new String[0] : apiVersion.value();  
     
    PatternsRequestCondition apiPattern = new PatternsRequestCondition(urlPatterns);  
    PatternsRequestCondition oldPattern = mapping.getPatternsCondition();  
    PatternsRequestCondition updatedFinalPattern = apiPattern.combine(oldPattern);  
    //重新构建 RequestMappingInfo  
    mapping = new RequestMappingInfo(mapping.getName(), updatedFinalPattern, mapping.getMethodsCondition(),  
            mapping.getParamsCondition(), mapping.getHeadersCondition(), mapping.getConsumesCondition(),  
            mapping.getProducesCondition(), mapping.getCustomCondition());  
    super.registerHandlerMethod(handler, method, mapping);  
}  
</code></pre>
<p>}</p>
<p>最后，也是特别容易忽略的一点，要通过实现 WebMvcRegistrations 接口，来生效自定义的 APIVersionHandlerMapping：</p>
<p>@SpringBootApplication<br>
public class CommonMistakesApplication implements WebMvcRegistrations {<br>
&hellip;<br>
@Override<br>
public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {<br>
return new APIVersionHandlerMapping();<br>
}<br>
}</p>
<p>这样，就实现了在 Controller 上或接口方法上通过注解，来实现以统一的 Pattern 进行版本号控制：</p>
<p>@GetMapping(value = &ldquo;/api/user&rdquo;)<br>
@APIVersion(&ldquo;v4&rdquo;)<br>
public int right4() {<br>
return 4;<br>
}</p>
<p>加上注解后，访问浏览器查看效果：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/523935761ea08d7836c5f1e35792d070.png" alt=""></p>
<p>使用框架来明确 API 版本的指定策略，不仅实现了标准化，更实现了强制的 API 版本控制。对上面代码略做修改，我们就可以实现不设置 @APIVersion 接口就给予报错提示。</p>
<h2 id="接口处理方式要明确同步还是异步">接口处理方式要明确同步还是异步</h2>
<p>看到这个标题，你可能感觉不太好理解，我们直接看一个实际案例吧。</p>
<p>有一个文件上传服务 FileService，其中一个 upload 文件上传接口特别慢，原因是这个上传接口在内部需要进行两步操作，首先上传原图，然后压缩后上传缩略图。如果每一步都耗时 5 秒的话，那么这个接口返回至少需要 10 秒的时间。</p>
<p>于是，开发同学把接口改为了异步处理，每一步操作都限定了超时时间，也就是分别把上传原文件和上传缩略图的操作提交到线程池，然后等待一定的时间：</p>
<p>private ExecutorService threadPool = Executors.newFixedThreadPool(2);</p>
<p>//我没有贴出两个文件上传方法 uploadFile 和 uploadThumbnailFile 的实现，它们在内部只是随机进行休眠然后返回文件名，对于本例来说不是很重要</p>
<p>public UploadResponse upload(UploadRequest request) {<br>
UploadResponse response = new UploadResponse();<br>
//上传原始文件任务提交到线程池处理<br>
Future<String> uploadFile = threadPool.submit(() -&gt; uploadFile(request.getFile()));<br>
//上传缩略图任务提交到线程池处理<br>
Future<String> uploadThumbnailFile = threadPool.submit(() -&gt; uploadThumbnailFile(request.getFile()));<br>
//等待上传原始文件任务完成，最多等待 1 秒<br>
try {<br>
response.setDownloadUrl(uploadFile.get(1, TimeUnit.SECONDS));<br>
} catch (Exception e) {<br>
e.printStackTrace();<br>
}<br>
//等待上传缩略图任务完成，最多等待 1 秒<br>
try {<br>
response.setThumbnailDownloadUrl(uploadThumbnailFile.get(1, TimeUnit.SECONDS));<br>
} catch (Exception e) {<br>
e.printStackTrace();<br>
}<br>
return response;<br>
}</p>
<p>上传接口的请求和响应比较简单，传入二进制文件，传出原文件和缩略图下载地址：</p>
<p>@Data<br>
public class UploadRequest {<br>
private byte[] file;<br>
}</p>
<p>@Data<br>
public class UploadResponse {<br>
private String downloadUrl;<br>
private String thumbnailDownloadUrl;<br>
}</p>
<p>到这里，你能看出这种实现方式的问题是什么吗？</p>
<p>从接口命名上看虽然是同步上传操作，但其内部通过线程池进行异步上传，并因为设置了较短超时所以接口整体响应挺快。但是，<strong>一旦遇到超时，接口就不能返回完整的数据，不是无法拿到原文件下载地址，就是无法拿到缩略图下载地址，接口的行为变得不可预测</strong>：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/142e4ccb3bc9e1842b4878a92ab464ec.png" alt=""></p>
<p>所以，这种优化接口响应速度的方式并不可取，<strong>更合理的方式是，让上传接口要么是彻底的同步处理，要么是彻底的异步处理</strong>：</p>
<ol>
<li>所谓同步处理，接口一定是同步上传原文件和缩略图的，调用方可以自己选择调用超时，如果来得及可以一直等到上传完成，如果等不及可以结束等待，下一次再重试；</li>
<li>所谓异步处理，接口是两段式的，上传接口本身只是返回一个任务 ID，然后异步做上传操作，上传接口响应很快，客户端需要之后再拿着任务 ID 调用任务查询接口查询上传的文件 URL。</li>
</ol>
<p>同步上传接口的实现代码如下，把超时的选择留给客户端：</p>
<p>public SyncUploadResponse syncUpload(SyncUploadRequest request) {<br>
SyncUploadResponse response = new SyncUploadResponse();<br>
response.setDownloadUrl(uploadFile(request.getFile()));<br>
response.setThumbnailDownloadUrl(uploadThumbnailFile(request.getFile()));<br>
return response;<br>
}</p>
<p>这里的 SyncUploadRequest 和 SyncUploadResponse 类，与之前定义的 UploadRequest 和 UploadResponse 是一致的。对于接口的入参和出参 DTO 的命名，我比较建议的方式是，使用接口名 +Request 和 Response 后缀。</p>
<p>接下来，我们看看异步的上传文件接口如何实现。异步上传接口在出参上有点区别，不再返回文件 URL，而是返回一个任务 ID：</p>
<p>@Data<br>
public class AsyncUploadRequest {<br>
private byte[] file;<br>
}</p>
<p>@Data<br>
public class AsyncUploadResponse {<br>
private String taskId;<br>
}</p>
<p>在接口实现上，我们同样把上传任务提交到线程池处理，但是并不会同步等待任务完成，而是完成后把结果写入一个 HashMap，任务查询接口通过查询这个 HashMap 来获得文件的 URL：</p>
<p>//计数器，作为上传任务的 ID<br>
private AtomicInteger atomicInteger = new AtomicInteger(0);<br>
//暂存上传操作的结果，生产代码需要考虑数据持久化<br>
private ConcurrentHashMap&lt;String, SyncQueryUploadTaskResponse&gt; downloadUrl = new ConcurrentHashMap&lt;&gt;();<br>
//异步上传操作<br>
public AsyncUploadResponse asyncUpload(AsyncUploadRequest request) {<br>
AsyncUploadResponse response = new AsyncUploadResponse();<br>
//生成唯一的上传任务 ID<br>
String taskId = &ldquo;upload&rdquo; + atomicInteger.incrementAndGet();<br>
//异步上传操作只返回任务 ID<br>
response.setTaskId(taskId);<br>
//提交上传原始文件操作到线程池异步处理<br>
threadPool.execute(() -&gt; {<br>
String url = uploadFile(request.getFile());<br>
//如果 ConcurrentHashMap 不包含 Key，则初始化一个 SyncQueryUploadTaskResponse，然后设置 DownloadUrl<br>
downloadUrl.computeIfAbsent(taskId, id -&gt; new SyncQueryUploadTaskResponse(id)).setDownloadUrl(url);<br>
});<br>
//提交上传缩略图操作到线程池异步处理<br>
threadPool.execute(() -&gt; {<br>
String url = uploadThumbnailFile(request.getFile());<br>
downloadUrl.computeIfAbsent(taskId, id -&gt; new SyncQueryUploadTaskResponse(id)).setThumbnailDownloadUrl(url);<br>
});<br>
return response;<br>
}</p>
<p>文件上传查询接口则以任务 ID 作为入参，返回两个文件的下载地址，因为文件上传查询接口是同步的，所以直接命名为 syncQueryUploadTask：</p>
<p>//syncQueryUploadTask 接口入参<br>
@Data<br>
@RequiredArgsConstructor<br>
public class SyncQueryUploadTaskRequest {<br>
private final String taskId;//使用上传文件任务 ID 查询上传结果<br>
}<br>
//syncQueryUploadTask 接口出参<br>
@Data<br>
@RequiredArgsConstructor<br>
public class SyncQueryUploadTaskResponse {<br>
private final String taskId; //任务 ID<br>
private String downloadUrl; //原始文件下载 URL<br>
private String thumbnailDownloadUrl; //缩略图下载 URL<br>
}</p>
<p>public SyncQueryUploadTaskResponse syncQueryUploadTask(SyncQueryUploadTaskRequest request) {<br>
SyncQueryUploadTaskResponse response = new SyncQueryUploadTaskResponse(request.getTaskId());<br>
//从之前定义的 downloadUrl ConcurrentHashMap 查询结果<br>
response.setDownloadUrl(downloadUrl.getOrDefault(request.getTaskId(), response).getDownloadUrl());<br>
response.setThumbnailDownloadUrl(downloadUrl.getOrDefault(request.getTaskId(), response).getThumbnailDownloadUrl());<br>
return response;<br>
}</p>
<p>经过改造的 FileService 不再提供一个看起来是同步上传，内部却是异步上传的 upload 方法，改为提供很明确的：</p>
<ol>
<li>同步上传接口 syncUpload；</li>
<li>异步上传接口 asyncUpload，搭配 syncQueryUploadTask 查询上传结果。</li>
</ol>
<p>使用方可以根据业务性质选择合适的方法：如果是后端批处理使用，那么可以使用同步上传，多等待一些时间问题不大；如果是面向用户的接口，那么接口响应时间不宜过长，可以调用异步上传接口，然后定时轮询上传结果，拿到结果再显示。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>今天，我针对接口设计，和你深入探讨了三个方面的问题。</p>
<p>第一，针对响应体的设计混乱、响应结果的不明确问题，服务端需要明确响应体每一个字段的意义，以一致的方式进行处理，并确保不透传下游服务的错误。</p>
<p>第二，针对接口版本控制问题，主要就是在开发接口之前明确版本控制策略，以及尽量使用统一的版本控制策略两方面。</p>
<p>第三，针对接口的处理方式，我认为需要明确要么是同步要么是异步。如果 API 列表中既有同步接口也有异步接口，那么最好直接在接口名中明确。</p>
<p>一个良好的接口文档不仅仅需要说明如何调用接口，更需要补充接口使用的最佳实践以及接口的 SLA 标准。我看到的大部分接口文档只给出了参数定义，但诸如幂等性、同步异步、缓存策略等看似内部实现相关的一些设计，其实也会影响调用方对接口的使用策略，最好也可以体现在接口文档中。</p>
<p>最后，我再额外提一下，对于服务端出错的时候是否返回 200 响应码的问题，其实一直有争论。从 RESTful 设计原则来看，我们应该尽量利用 HTTP 状态码来表达错误，但也不是这么绝对。</p>
<p>如果我们认为 HTTP 状态码是协议层面的履约，那么当这个错误已经不涉及 HTTP 协议时（换句话说，服务端已经收到请求进入服务端业务处理后产生的错误），不一定需要硬套协议本身的错误码。但涉及非法 URL、非法参数、没有权限等无法处理请求的情况，还是应该使用正确的响应码来应对。</p>
<p>今天用到的代码，我都放在了 GitHub 上，你可以点击这个链接查看。</p>
<h2 id="思考与讨论">思考与讨论</h2>
<ol>
<li>在第一节的例子中，接口响应结构体中的 code 字段代表执行结果的错误码，对于业务特别复杂的接口，可能会有很多错误情况，code 可能会有几十甚至几百个。客户端开发人员需要根据每一种错误情况逐一写 if-else 进行不同交互处理，会非常麻烦，你觉得有什么办法来改进吗？作为服务端，是否有必要告知客户端接口执行的错误码呢？</li>
<li>在第二节的例子中，我们在类或方法上标记 @APIVersion 自定义注解，实现了 URL 方式统一的接口版本定义。你可以用类似的方式（也就是自定义 RequestMappingHandlerMapping），来实现一套统一的基于请求头方式的版本控制吗？</li>
</ol>
<p>关于接口设计，你还遇到过其他问题吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把今天的内容分享给你的朋友或同事，一起交流。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/">Java业务开发常见错误100例</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B%E8%AF%BE/22__%E6%8A%80%E6%9C%AF%E5%86%B3%E7%AD%961%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E8%80%85%E5%81%9A%E4%BB%80%E4%B9%88%E5%9B%A2%E9%98%9F%E6%95%88%E7%8E%87%E6%89%8D%E6%9C%80%E9%AB%98/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">22__技术决策（1）：技术管理者做什么，团队效率才最高？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/22__%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E7%BB%84%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%87%AA%E8%A1%8C%E5%B8%83%E7%BD%AE%E4%BC%9A%E8%AE%AE%E5%AE%A4/">
            <span class="next-text nav-default">22__进程空间管理：项目组还可以自行布置会议室</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
