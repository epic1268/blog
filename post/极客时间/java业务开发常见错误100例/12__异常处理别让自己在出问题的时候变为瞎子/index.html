<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>12__异常处理：别让自己在出问题的时候变为瞎子 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是朱晔。今天，我来和你聊聊异常处理容易踩的坑。
应用程序避免不了出异常，捕获和处理异常是考验编程功力的一个精细活。一些业务项目中，我曾看到开发同学在开发业务逻辑时不考虑任何异常处理，项目接近完成时再采用“流水线”的方式进行异常处理，也就是统一为所有方法打上 try…catch…捕获所有异常记录日志，有些技巧的同学可能会使用 AOP 来进行类似的“统一异常处理”。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/12__%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%88%AB%E8%AE%A9%E8%87%AA%E5%B7%B1%E5%9C%A8%E5%87%BA%E9%97%AE%E9%A2%98%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%98%E4%B8%BA%E7%9E%8E%E5%AD%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/12__%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%88%AB%E8%AE%A9%E8%87%AA%E5%B7%B1%E5%9C%A8%E5%87%BA%E9%97%AE%E9%A2%98%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%98%E4%B8%BA%E7%9E%8E%E5%AD%90/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="12__异常处理：别让自己在出问题的时候变为瞎子">
  <meta property="og:description" content="你好，我是朱晔。今天，我来和你聊聊异常处理容易踩的坑。
应用程序避免不了出异常，捕获和处理异常是考验编程功力的一个精细活。一些业务项目中，我曾看到开发同学在开发业务逻辑时不考虑任何异常处理，项目接近完成时再采用“流水线”的方式进行异常处理，也就是统一为所有方法打上 try…catch…捕获所有异常记录日志，有些技巧的同学可能会使用 AOP 来进行类似的“统一异常处理”。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Java业务开发常见错误100例">

  <meta itemprop="name" content="12__异常处理：别让自己在出问题的时候变为瞎子">
  <meta itemprop="description" content="你好，我是朱晔。今天，我来和你聊聊异常处理容易踩的坑。
应用程序避免不了出异常，捕获和处理异常是考验编程功力的一个精细活。一些业务项目中，我曾看到开发同学在开发业务逻辑时不考虑任何异常处理，项目接近完成时再采用“流水线”的方式进行异常处理，也就是统一为所有方法打上 try…catch…捕获所有异常记录日志，有些技巧的同学可能会使用 AOP 来进行类似的“统一异常处理”。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6431">
  <meta itemprop="keywords" content="Java业务开发常见错误100例">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="12__异常处理：别让自己在出问题的时候变为瞎子">
  <meta name="twitter:description" content="你好，我是朱晔。今天，我来和你聊聊异常处理容易踩的坑。
应用程序避免不了出异常，捕获和处理异常是考验编程功力的一个精细活。一些业务项目中，我曾看到开发同学在开发业务逻辑时不考虑任何异常处理，项目接近完成时再采用“流水线”的方式进行异常处理，也就是统一为所有方法打上 try…catch…捕获所有异常记录日志，有些技巧的同学可能会使用 AOP 来进行类似的“统一异常处理”。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">12__异常处理：别让自己在出问题的时候变为瞎子</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6431 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#捕获和处理异常容易犯的错">捕获和处理异常容易犯的错</a></li>
        <li><a href="#小心-finally-中的异常">小心 finally 中的异常</a></li>
        <li><a href="#千万别把异常定义为静态变量">千万别把异常定义为静态变量</a></li>
        <li><a href="#提交线程池的任务出了异常会怎么样">提交线程池的任务出了异常会怎么样？</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考与讨论">思考与讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是朱晔。今天，我来和你聊聊异常处理容易踩的坑。</p>
<p>应用程序避免不了出异常，捕获和处理异常是考验编程功力的一个精细活。一些业务项目中，我曾看到开发同学在开发业务逻辑时不考虑任何异常处理，项目接近完成时再采用“流水线”的方式进行异常处理，也就是统一为所有方法打上 try…catch…捕获所有异常记录日志，有些技巧的同学可能会使用 AOP 来进行类似的“统一异常处理”。</p>
<p>其实，这种处理异常的方式非常不可取。那么今天，我就和你分享下不可取的原因、与异常处理相关的坑和最佳实践。</p>
<h2 id="捕获和处理异常容易犯的错">捕获和处理异常容易犯的错</h2>
<p>“统一异常处理”方式正是我要说的第一个错：<strong>不在业务代码层面考虑异常处理，仅在框架层面粗犷捕获和处理异常</strong>。</p>
<p>为了理解错在何处，我们先来看看大多数业务应用都采用的三层架构：</p>
<ol>
<li>Controller 层负责信息收集、参数校验、转换服务层处理的数据适配前端，轻业务逻辑；</li>
<li>Service 层负责核心业务逻辑，包括各种外部服务调用、访问数据库、缓存处理、消息处理等；</li>
<li>Repository 层负责数据访问实现，一般没有业务逻辑。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/4efad6cbc4afedbac0e507a85a54598d.png" alt=""></p>
<p>每层架构的工作性质不同，且从业务性质上异常可能分为业务异常和系统异常两大类，这就决定了很难进行统一的异常处理。我们从底向上看一下三层架构：</p>
<ol>
<li>Repository 层出现异常或许可以忽略，或许可以降级，或许需要转化为一个友好的异常。如果一律捕获异常仅记录日志，很可能业务逻辑已经出错，而用户和程序本身完全感知不到。</li>
<li>Service 层往往涉及数据库事务，出现异常同样不适合捕获，否则事务无法自动回滚。此外 Service 层涉及业务逻辑，有些业务逻辑执行中遇到业务异常，可能需要在异常后转入分支业务流程。如果业务异常都被框架捕获了，业务功能就会不正常。</li>
<li>如果下层异常上升到 Controller 层还是无法处理的话，Controller 层往往会给予用户友好提示，或是根据每一个 API 的异常表返回指定的异常类型，同样无法对所有异常一视同仁。</li>
</ol>
<p>因此，我不建议在框架层面进行异常的自动、统一处理，尤其不要随意捕获异常。但，框架可以做兜底工作。如果异常上升到最上层逻辑还是无法处理的话，可以以统一的方式进行异常转换，比如通过 @RestControllerAdvice + @ExceptionHandler，来捕获这些“未处理”异常：</p>
<ol>
<li>对于自定义的业务异常，以 Warn 级别的日志记录异常以及当前 URL、执行方法等信息后，提取异常中的错误码和消息等信息，转换为合适的 API 包装体返回给 API 调用方；</li>
<li>对于无法处理的系统异常，以 Error 级别的日志记录异常和上下文信息（比如 URL、参数、用户 ID）后，转换为普适的“服务器忙，请稍后再试”异常信息，同样以 API 包装体返回给调用方。</li>
</ol>
<p>比如，下面这段代码的做法：</p>
<p>@RestControllerAdvice<br>
@Slf4j<br>
public class RestControllerExceptionHandler {<br>
private static int GENERIC_SERVER_ERROR_CODE = 2000;<br>
private static String GENERIC_SERVER_ERROR_MESSAGE = &ldquo;服务器忙，请稍后再试&rdquo;;</p>
<pre><code>@ExceptionHandler  
public APIResponse handle(HttpServletRequest req, HandlerMethod method, Exception ex) {  
    if (ex instanceof BusinessException) {  
        BusinessException exception = (BusinessException) ex;  
        log.warn(String.format(&quot;访问 %s -&gt; %s 出现业务异常！&quot;, req.getRequestURI(), method.toString()), ex);  
        return new APIResponse(false, null, exception.getCode(), exception.getMessage());  
    } else {  
        log.error(String.format(&quot;访问 %s -&gt; %s 出现系统异常！&quot;, req.getRequestURI(), method.toString()), ex);  
        return new APIResponse(false, null, GENERIC_SERVER_ERROR_CODE, GENERIC_SERVER_ERROR_MESSAGE);  
    }  
}  
</code></pre>
<p>}</p>
<p>出现运行时系统异常后，异常处理程序会直接把异常转换为 JSON 返回给调用方：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/6acd2851eaa88f70aa7f3adb3e71a825.png" alt=""></p>
<p>要做得更好，你可以把相关出入参、用户信息在脱敏后记录到日志中，方便出现问题时根据上下文进一步排查。</p>
<p>第二个错，<strong>捕获了异常后直接生吞</strong>。在任何时候，我们捕获了异常都不应该生吞，也就是直接丢弃异常不记录、不抛出。这样的处理方式还不如不捕获异常，因为被生吞掉的异常一旦导致 Bug，就很难在程序中找到蛛丝马迹，使得 Bug 排查工作难上加难。</p>
<p>通常情况下，生吞异常的原因，可能是不希望自己的方法抛出受检异常，只是为了把异常“处理掉”而捕获并生吞异常，也可能是想当然地认为异常并不重要或不可能产生。但不管是什么原因，不管是你认为多么不重要的异常，都不应该生吞，哪怕是一个日志也好。</p>
<p>第三个错，<strong>丢弃异常的原始信息</strong>。我们来看两个不太合适的异常处理方式，虽然没有完全生吞异常，但也丢失了宝贵的异常信息。</p>
<p>比如有这么一个会抛出受检异常的方法 readFile：</p>
<p>private void readFile() throws IOException {<br>
Files.readAllLines(Paths.get(&ldquo;a_file&rdquo;));<br>
}</p>
<p>像这样调用 readFile 方法，捕获异常后，完全不记录原始异常，直接抛出一个转换后异常，导致出了问题不知道 IOException 具体是哪里引起的：</p>
<p>@GetMapping(&ldquo;wrong1&rdquo;)<br>
public void wrong1(){<br>
try {<br>
readFile();<br>
} catch (IOException e) {<br>
//原始异常信息丢失 <br>
throw new RuntimeException(&ldquo;系统忙请稍后再试&rdquo;);<br>
}<br>
}</p>
<p>或者是这样，只记录了异常消息，却丢失了异常的类型、栈等重要信息：</p>
<p>catch (IOException e) {<br>
//只保留了异常消息，栈没有记录<br>
log.error(&ldquo;文件读取错误，{}&rdquo;, e.getMessage());<br>
throw new RuntimeException(&ldquo;系统忙请稍后再试&rdquo;);<br>
}</p>
<p>留下的日志是这样的，看完一脸茫然，只知道文件读取错误的文件名，至于为什么读取错误、是不存在还是没权限，完全不知道。</p>
<p>[12:57:19.746] [http-nio-45678-exec-1] [ERROR] [.g.t.c.e.d.HandleExceptionController:35  ] - 文件读取错误，a_file</p>
<p>这两种处理方式都不太合理，可以改为如下方式：</p>
<p>catch (IOException e) {<br>
log.error(&ldquo;文件读取错误&rdquo;, e);<br>
throw new RuntimeException(&ldquo;系统忙请稍后再试&rdquo;);<br>
}</p>
<p>或者，把原始异常作为转换后新异常的 cause，原始异常信息同样不会丢：</p>
<p>catch (IOException e) {<br>
throw new RuntimeException(&ldquo;系统忙请稍后再试&rdquo;, e);<br>
}</p>
<p>其实，JDK 内部也会犯类似的错。之前我遇到一个使用 JDK10 的应用偶发启动失败的案例，日志中可以看到出现类似的错误信息：</p>
<p>Caused by: java.lang.SecurityException: Couldn&rsquo;t parse jurisdiction policy files in: unlimited<br>
at java.base/javax.crypto.JceSecurity.setupJurisdictionPolicies(JceSecurity.java:355)<br>
at java.base/javax.crypto.JceSecurity.access$000(JceSecurity.java:73)<br>
at java.base/javax.crypto.JceSecurity$1.run(JceSecurity.java:109)<br>
at java.base/javax.crypto.JceSecurity$1.run(JceSecurity.java:106)<br>
at java.base/java.security.AccessController.doPrivileged(Native Method)<br>
at java.base/javax.crypto.JceSecurity.<clinit>(JceSecurity.java:105)<br>
&hellip; 20 more</p>
<p>查看 JDK JceSecurity 类 setupJurisdictionPolicies 方法源码，发现异常 e 没有记录，也没有作为新抛出异常的 cause，当时读取文件具体出现什么异常（权限问题又或是 IO 问题）可能永远都无法知道了，对问题定位造成了很大困扰：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/365938c12dd2a28a099ad41aeada0b92.png" alt=""></p>
<p>第四个错，<strong>抛出异常时不指定任何消息</strong>。我见过一些代码中的偷懒做法，直接抛出没有 message 的异常：</p>
<p>throw new RuntimeException();</p>
<p>这么写的同学可能觉得永远不会走到这个逻辑，永远不会出现这样的异常。但，这样的异常却出现了，被 ExceptionHandler 拦截到后输出了下面的日志信息：</p>
<p>[13:25:18.031] [http-nio-45678-exec-3] [ERROR] [c.e.d.RestControllerExceptionHandler:24  ] - 访问 /handleexception/wrong3 -&gt; org.geekbang.time.commonmistakes.exception.demo1.HandleExceptionController#wrong3(String) 出现系统异常！<br>
java.lang.RuntimeException: null<br>
&hellip;</p>
<p>这里的 null 非常容易引起误解。按照空指针问题排查半天才发现，其实是异常的 message 为空。</p>
<p>总之，如果你捕获了异常打算处理的话，<strong>除了通过日志正确记录异常原始信息外，通常还有三种处理模式</strong>：</p>
<ol>
<li>转换，即转换新的异常抛出。对于新抛出的异常，最好具有特定的分类和明确的异常消息，而不是随便抛一个无关或没有任何信息的异常，并最好通过 cause 关联老异常。</li>
<li>重试，即重试之前的操作。比如远程调用服务端过载超时的情况，盲目重试会让问题更严重，需要考虑当前情况是否适合重试。</li>
<li>恢复，即尝试进行降级处理，或使用默认值来替代原始数据。</li>
</ol>
<p>以上，就是通过 catch 捕获处理异常的一些最佳实践。</p>
<h2 id="小心-finally-中的异常">小心 finally 中的异常</h2>
<p>有些时候，我们希望不管是否遇到异常，逻辑完成后都要释放资源，这时可以使用 finally 代码块而跳过使用 catch 代码块。</p>
<p>但要千万小心 finally 代码块中的异常，因为资源释放处理等收尾操作同样也可能出现异常。比如下面这段代码，我们在 finally 中抛出一个异常：</p>
<p>@GetMapping(&ldquo;wrong&rdquo;)<br>
public void wrong() {<br>
try {<br>
log.info(&ldquo;try&rdquo;);<br>
//异常丢失<br>
throw new RuntimeException(&ldquo;try&rdquo;);<br>
} finally {<br>
log.info(&ldquo;finally&rdquo;);<br>
throw new RuntimeException(&ldquo;finally&rdquo;);<br>
}<br>
}</p>
<p>最后在日志中只能看到 finally 中的异常，<strong>虽然 try 中的逻辑出现了异常，但却被 finally 中的异常覆盖了</strong>。这是非常危险的，特别是 finally 中出现的异常是偶发的，就会在部分时候覆盖 try 中的异常，让问题更不明显：</p>
<p>[13:34:42.247] [http-nio-45678-exec-1] [ERROR] [.a.c.c.C.[.[.[/].[dispatcherServlet]:175 ] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.RuntimeException: finally] with root cause<br>
java.lang.RuntimeException: finally</p>
<p>至于异常为什么被覆盖，原因也很简单，因为一个方法无法出现两个异常。修复方式是，finally 代码块自己负责异常捕获和处理：</p>
<p>@GetMapping(&ldquo;right&rdquo;)<br>
public void right() {<br>
try {<br>
log.info(&ldquo;try&rdquo;);<br>
throw new RuntimeException(&ldquo;try&rdquo;);<br>
} finally {<br>
log.info(&ldquo;finally&rdquo;);<br>
try {<br>
throw new RuntimeException(&ldquo;finally&rdquo;);<br>
} catch (Exception ex) {<br>
log.error(&ldquo;finally&rdquo;, ex);<br>
}<br>
}<br>
}</p>
<p>或者可以把 try 中的异常作为主异常抛出，使用 addSuppressed 方法把 finally 中的异常附加到主异常上：</p>
<p>@GetMapping(&ldquo;right2&rdquo;)<br>
public void right2() throws Exception {<br>
Exception e = null;<br>
try {<br>
log.info(&ldquo;try&rdquo;);<br>
throw new RuntimeException(&ldquo;try&rdquo;);<br>
} catch (Exception ex) {<br>
e = ex;<br>
} finally {<br>
log.info(&ldquo;finally&rdquo;);<br>
try {<br>
throw new RuntimeException(&ldquo;finally&rdquo;);<br>
} catch (Exception ex) {<br>
if (e!= null) {<br>
e.addSuppressed(ex);<br>
} else {<br>
e = ex;<br>
}<br>
}<br>
}<br>
throw e;<br>
}</p>
<p>运行方法可以得到如下异常信息，其中同时包含了主异常和被屏蔽的异常：</p>
<p>java.lang.RuntimeException: try<br>
at org.geekbang.time.commonmistakes.exception.finallyissue.FinallyIssueController.right2(FinallyIssueController.java:69)<br>
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>
&hellip;<br>
Suppressed: java.lang.RuntimeException: finally<br>
at org.geekbang.time.commonmistakes.exception.finallyissue.FinallyIssueController.right2(FinallyIssueController.java:75)<br>
&hellip; 54 common frames omitted</p>
<p>其实这正是 try-with-resources 语句的做法，对于实现了 AutoCloseable 接口的资源，建议使用 try-with-resources 来释放资源，否则也可能会产生刚才提到的，释放资源时出现的异常覆盖主异常的问题。比如如下我们定义一个测试资源，其 read 和 close 方法都会抛出异常：</p>
<p>public class TestResource implements AutoCloseable {<br>
public void read() throws Exception{<br>
throw new Exception(&ldquo;read error&rdquo;);<br>
}<br>
@Override<br>
public void close() throws Exception {<br>
throw new Exception(&ldquo;close error&rdquo;);<br>
}<br>
}</p>
<p>使用传统的 try-finally 语句，在 try 中调用 read 方法，在 finally 中调用 close 方法：</p>
<p>@GetMapping(&ldquo;useresourcewrong&rdquo;)<br>
public void useresourcewrong() throws Exception {<br>
TestResource testResource = new TestResource();<br>
try {<br>
testResource.read();<br>
} finally {<br>
testResource.close();<br>
}<br>
}</p>
<p>可以看到，同样出现了 finally 中的异常覆盖了 try 中异常的问题：</p>
<p>java.lang.Exception: close error<br>
at org.geekbang.time.commonmistakes.exception.finallyissue.TestResource.close(TestResource.java:10)<br>
at org.geekbang.time.commonmistakes.exception.finallyissue.FinallyIssueController.useresourcewrong(FinallyIssueController.java:27)</p>
<p>而改为 try-with-resources 模式之后：</p>
<p>@GetMapping(&ldquo;useresourceright&rdquo;)<br>
public void useresourceright() throws Exception {<br>
try (TestResource testResource = new TestResource()){<br>
testResource.read();<br>
}<br>
}</p>
<p>try 和 finally 中的异常信息都可以得到保留：</p>
<p>java.lang.Exception: read error<br>
at org.geekbang.time.commonmistakes.exception.finallyissue.TestResource.read(TestResource.java:6)<br>
&hellip;<br>
Suppressed: java.lang.Exception: close error<br>
at org.geekbang.time.commonmistakes.exception.finallyissue.TestResource.close(TestResource.java:10)<br>
at org.geekbang.time.commonmistakes.exception.finallyissue.FinallyIssueController.useresourceright(FinallyIssueController.java:35)<br>
&hellip; 54 common frames omitted</p>
<h2 id="千万别把异常定义为静态变量">千万别把异常定义为静态变量</h2>
<p>既然我们通常会自定义一个业务异常类型，来包含更多的异常信息，比如异常错误码、友好的错误提示等，那就需要在业务逻辑各处，手动抛出各种业务异常来返回指定的错误码描述（比如对于下单操作，用户不存在返回 2001，商品缺货返回 2002 等）。</p>
<p>对于这些异常的错误代码和消息，我们期望能够统一管理，而不是散落在程序各处定义。这个想法很好，但稍有不慎就可能会出现把异常定义为静态变量的坑。</p>
<p>我在救火排查某项目生产问题时，遇到了一件非常诡异的事情：我发现异常堆信息显示的方法调用路径，在当前入参的情况下根本不可能产生，项目的业务逻辑又很复杂，就始终没往异常信息是错的这方面想，总觉得是因为某个分支流程导致业务没有按照期望的流程进行。</p>
<p><strong>经过艰难的排查，最终定位到原因是把异常定义为了静态变量，导致异常栈信息错乱</strong>，类似于定义一个 Exceptions 类来汇总所有的异常，把异常存放在静态字段中：</p>
<p>public class Exceptions {<br>
public static BusinessException ORDEREXISTS = new BusinessException(&ldquo;订单已经存在&rdquo;, 3001);<br>
&hellip;<br>
}</p>
<p>把异常定义为静态变量会导致异常信息固化，这就和异常的栈一定是需要根据当前调用来动态获取相矛盾。</p>
<p>我们写段代码来模拟下这个问题：定义两个方法 createOrderWrong 和 cancelOrderWrong 方法，它们内部都会通过 Exceptions 类来获得一个订单不存在的异常；先后调用两个方法，然后抛出。</p>
<p>@GetMapping(&ldquo;wrong&rdquo;)<br>
public void wrong() {<br>
try {<br>
createOrderWrong();<br>
} catch (Exception ex) {<br>
log.error(&ldquo;createOrder got error&rdquo;, ex);<br>
}<br>
try {<br>
cancelOrderWrong();<br>
} catch (Exception ex) {<br>
log.error(&ldquo;cancelOrder got error&rdquo;, ex);<br>
}<br>
}</p>
<p>private void createOrderWrong() {<br>
//这里有问题<br>
throw Exceptions.ORDEREXISTS;<br>
}</p>
<p>private void cancelOrderWrong() {<br>
//这里有问题<br>
throw Exceptions.ORDEREXISTS;<br>
}</p>
<p>运行程序后看到如下日志，cancelOrder got error 的提示对应了 createOrderWrong 方法。显然，cancelOrderWrong 方法在出错后抛出的异常，其实是 createOrderWrong 方法出错的异常：</p>
<p>[14:05:25.782] [http-nio-45678-exec-1] [ERROR] [.c.e.d.PredefinedExceptionController:25  ] - cancelOrder got error<br>
org.geekbang.time.commonmistakes.exception.demo2.BusinessException: 订单已经存在<br>
at org.geekbang.time.commonmistakes.exception.demo2.Exceptions.<clinit>(Exceptions.java:5)<br>
at org.geekbang.time.commonmistakes.exception.demo2.PredefinedExceptionController.createOrderWrong(PredefinedExceptionController.java:50)<br>
at org.geekbang.time.commonmistakes.exception.demo2.PredefinedExceptionController.wrong(PredefinedExceptionController.java:18)</p>
<p>修复方式很简单，改一下 Exceptions 类的实现，通过不同的方法把每一种异常都 new 出来抛出即可：</p>
<p>public class Exceptions {<br>
public static BusinessException orderExists(){<br>
return new BusinessException(&ldquo;订单已经存在&rdquo;, 3001);<br>
}<br>
}</p>
<h2 id="提交线程池的任务出了异常会怎么样">提交线程池的任务出了异常会怎么样？</h2>
<p>在第 3 讲介绍线程池时我提到，线程池常用作异步处理或并行处理。那么，把任务提交到线程池处理，任务本身出现异常时会怎样呢？</p>
<p>我们来看一个例子：提交 10 个任务到线程池异步处理，第 5 个任务抛出一个 RuntimeException，每个任务完成后都会输出一行日志：</p>
<p>@GetMapping(&ldquo;execute&rdquo;)<br>
public void execute() throws InterruptedException {</p>
<pre><code>String prefix = &quot;test&quot;;  
ExecutorService threadPool = Executors.newFixedThreadPool(1, new ThreadFactoryBuilder().setNameFormat(prefix+&quot;%d&quot;).get());  
//提交 10 个任务到线程池处理，第 5 个任务会抛出运行时异常  
IntStream.rangeClosed(1, 10).forEach(i -&gt; threadPool.execute(() -&gt; {  
    if (i == 5) throw new RuntimeException(&quot;error&quot;);  
    log.info(&quot;I'm done : {}&quot;, i);  
}));  

threadPool.shutdown();  
threadPool.awaitTermination(1, TimeUnit.HOURS);  
</code></pre>
<p>}</p>
<p>观察日志可以发现两点：</p>
<p>&hellip;<br>
[14:33:55.990] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:26  ] - I&rsquo;m done : 4<br>
Exception in thread &ldquo;test0&rdquo; java.lang.RuntimeException: error<br>
at org.geekbang.time.commonmistakes.exception.demo3.ThreadPoolAndExceptionController.lambda$null$0(ThreadPoolAndExceptionController.java:25)<br>
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)<br>
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)<br>
at java.lang.Thread.run(Thread.java:748)<br>
[14:33:55.990] [test1] [INFO ] [e.d.ThreadPoolAndExceptionController:26  ] - I&rsquo;m done : 6<br>
&hellip;</p>
<ol>
<li>任务 1 到 4 所在的线程是 test0，任务 6 开始运行在线程 test1。由于我的线程池通过线程工厂为线程使用统一的前缀 test 加上计数器进行命名，因此<strong>从线程名的改变可以知道因为异常的抛出老线程退出了，线程池只能重新创建一个线程</strong>。如果每个异步任务都以异常结束，那么线程池可能完全起不到线程重用的作用。</li>
<li>因为没有手动捕获异常进行处理，ThreadGroup 帮我们进行了未捕获异常的默认处理，向标准错误输出打印了出现异常的线程名称和异常信息。<strong>显然，这种没有以统一的错误日志格式记录错误信息打印出来的形式，对生产级代码是不合适的</strong>，ThreadGroup 的相关源码如下所示：</li>
</ol>
<p>public void uncaughtException(Thread t, Throwable e) {<br>
if (parent != null) {<br>
parent.uncaughtException(t, e);<br>
} else {<br>
Thread.UncaughtExceptionHandler ueh =<br>
Thread.getDefaultUncaughtExceptionHandler();<br>
if (ueh != null) {<br>
ueh.uncaughtException(t, e);<br>
} else if (!(e instanceof ThreadDeath)) {<br>
System.err.print(&ldquo;Exception in thread &quot;&rdquo;<br>
+ t.getName() + &ldquo;&quot; &ldquo;);<br>
e.printStackTrace(System.err);<br>
}<br>
}<br>
}</p>
<p>修复方式有 2 步：</p>
<ol>
<li>以 execute 方法提交到线程池的异步任务，最好在任务内部做好异常处理；</li>
<li>设置自定义的异常处理程序作为保底，比如在声明线程池时自定义线程池的未捕获异常处理程序：</li>
</ol>
<p>new ThreadFactoryBuilder()<br>
.setNameFormat(prefix+&quot;%d&rdquo;)<br>
.setUncaughtExceptionHandler((thread, throwable)-&gt; log.error(&ldquo;ThreadPool {} got exception&rdquo;, thread, throwable))<br>
.get()</p>
<p>或者设置全局的默认未捕获异常处理程序：</p>
<p>static {<br>
Thread.setDefaultUncaughtExceptionHandler((thread, throwable)-&gt; log.error(&ldquo;Thread {} got exception&rdquo;, thread, throwable));<br>
}</p>
<p>通过线程池 ExecutorService 的 execute 方法提交任务到线程池处理，如果出现异常会导致线程退出，控制台输出中可以看到异常信息。那么，把 execute 方法改为 submit，线程还会退出吗，异常还能被处理程序捕获到吗？</p>
<p><strong>修改代码后重新执行程序可以看到如下日志，说明线程没退出，异常也没记录被生吞了：</strong></p>
<p>[15:44:33.769] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&rsquo;m done : 1<br>
[15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&rsquo;m done : 2<br>
[15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&rsquo;m done : 3<br>
[15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&rsquo;m done : 4<br>
[15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&rsquo;m done : 6<br>
[15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&rsquo;m done : 7<br>
[15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&rsquo;m done : 8<br>
[15:44:33.771] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&rsquo;m done : 9<br>
[15:44:33.771] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&rsquo;m done : 10</p>
<p>为什么会这样呢？</p>
<p>查看 FutureTask 源码可以发现，在执行任务出现异常之后，异常存到了一个 outcome 字段中，只有在调用 get 方法获取 FutureTask 结果的时候，才会以 ExecutionException 的形式重新抛出异常：</p>
<p>public void run() {<br>
&hellip;<br>
try {<br>
Callable<V> c = callable;<br>
if (c != null &amp;&amp; state == NEW) {<br>
V result;<br>
boolean ran;<br>
try {<br>
result = c.call();<br>
ran = true;<br>
} catch (Throwable ex) {<br>
result = null;<br>
ran = false;<br>
setException(ex);<br>
}<br>
&hellip;<br>
}</p>
<p>protected void setException(Throwable t) {<br>
if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {<br>
outcome = t;<br>
UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state<br>
finishCompletion();<br>
}<br>
}</p>
<p>public V get() throws InterruptedException, ExecutionException {<br>
int s = state;<br>
if (s &lt;= COMPLETING)<br>
s = awaitDone(false, 0L);<br>
return report(s);<br>
}</p>
<p>private V report(int s) throws ExecutionException {<br>
Object x = outcome;<br>
if (s == NORMAL)<br>
return (V)x;<br>
if (s &gt;= CANCELLED)<br>
throw new CancellationException();<br>
throw new ExecutionException((Throwable)x);<br>
}</p>
<p>修改后的代码如下所示，我们把 submit 返回的 Future 放到了 List 中，随后遍历 List 来捕获所有任务的异常。这么做确实合乎情理。既然是以 submit 方式来提交任务，那么我们应该关心任务的执行结果，否则应该以 execute 来提交任务：</p>
<p>List<Future> tasks = IntStream.rangeClosed(1, 10).mapToObj(i -&gt; threadPool.submit(() -&gt; {<br>
if (i == 5) throw new RuntimeException(&ldquo;error&rdquo;);<br>
log.info(&ldquo;I&rsquo;m done : {}&rdquo;, i);<br>
})).collect(Collectors.toList());</p>
<p>tasks.forEach(task-&gt; {<br>
try {<br>
task.get();<br>
} catch (Exception e) {<br>
log.error(&ldquo;Got exception&rdquo;, e);<br>
}<br>
});</p>
<p>执行这段程序可以看到如下的日志输出：</p>
<p>[15:44:13.543] [http-nio-45678-exec-1] [ERROR] [e.d.ThreadPoolAndExceptionController:69  ] - Got exception<br>
java.util.concurrent.ExecutionException: java.lang.RuntimeException: error</p>
<h2 id="重点回顾">重点回顾</h2>
<p>在今天的文章中，我介绍了处理异常容易犯的几个错和最佳实践。</p>
<p>第一，注意捕获和处理异常的最佳实践。首先，不应该用 AOP 对所有方法进行统一异常处理，异常要么不捕获不处理，要么根据不同的业务逻辑、不同的异常类型进行精细化、针对性处理；其次，处理异常应该杜绝生吞，并确保异常栈信息得到保留；最后，如果需要重新抛出异常的话，请使用具有意义的异常类型和异常消息。</p>
<p>第二，务必小心 finally 代码块中资源回收逻辑，确保 finally 代码块不出现异常，内部把异常处理完毕，避免 finally 中的异常覆盖 try 中的异常；或者考虑使用 addSuppressed 方法把 finally 中的异常附加到 try 中的异常上，确保主异常信息不丢失。此外，使用实现了 AutoCloseable 接口的资源，务必使用 try-with-resources 模式来使用资源，确保资源可以正确释放，也同时确保异常可以正确处理。</p>
<p>第三，虽然在统一的地方定义收口所有的业务异常是一个不错的实践，但务必确保异常是每次 new 出来的，而不能使用一个预先定义的 static 字段存放异常，否则可能会引起栈信息的错乱。</p>
<p>第四，确保正确处理了线程池中任务的异常，如果任务通过 execute 提交，那么出现异常会导致线程退出，大量的异常会导致线程重复创建引起性能问题，我们应该尽可能确保任务不出异常，同时设置默认的未捕获异常处理程序来兜底；如果任务通过 submit 提交意味着我们关心任务的执行结果，应该通过拿到的 Future 调用其 get 方法来获得任务运行结果和可能出现的异常，否则异常可能就被生吞了。</p>
<p>今天用到的代码，我都放在了 GitHub 上，你可以点击这个链接查看。</p>
<h2 id="思考与讨论">思考与讨论</h2>
<ol>
<li>关于在 finally 代码块中抛出异常的坑，如果在 finally 代码块中返回值，你觉得程序会以 try 或 catch 中返回值为准，还是以 finally 中的返回值为准呢？</li>
<li>对于手动抛出的异常，不建议直接使用 Exception 或 RuntimeException，通常建议复用 JDK 中的一些标准异常，比如IllegalArgumentException、IllegalStateException、UnsupportedOperationException，你能说说它们的适用场景，并列出更多常用异常吗？</li>
</ol>
<p>不知道针对异常处理，你还遇到过什么坑，还有什么最佳实践的心得吗？我是朱晔，欢迎在评论区与我留言分享，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/">Java业务开发常见错误100例</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/etcd%E5%AE%9E%E6%88%98%E8%AF%BE/12__%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8Eraft%E5%AE%9E%E7%8E%B0%E7%9A%84etcd%E8%BF%98%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">12__一致性：为什么基于Raft实现的etcd还会出现数据不一致？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/rpc%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/12__%E5%BC%82%E5%B8%B8%E9%87%8D%E8%AF%95%E5%9C%A8%E7%BA%A6%E5%AE%9A%E6%97%B6%E9%97%B4%E5%86%85%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E5%9C%B0%E9%87%8D%E8%AF%95/">
            <span class="next-text nav-default">12__异常重试：在约定时间内安全可靠地重试</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
