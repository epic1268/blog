<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>13__日志：日志记录真没你想象的那么简单 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是朱晔。今天，我和你分享的是，记录日志可能会踩的坑。
一些同学可能要说了，记录日志还不简单，无非是几个常用的 API 方法，比如 debug、info、warn、error；但我就见过不少坑都是记录日志引起的，容易出错主要在于三个方面：
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/13__%E6%97%A5%E5%BF%97%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9C%9F%E6%B2%A1%E4%BD%A0%E6%83%B3%E8%B1%A1%E7%9A%84%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/13__%E6%97%A5%E5%BF%97%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9C%9F%E6%B2%A1%E4%BD%A0%E6%83%B3%E8%B1%A1%E7%9A%84%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="13__日志：日志记录真没你想象的那么简单">
  <meta property="og:description" content="你好，我是朱晔。今天，我和你分享的是，记录日志可能会踩的坑。
一些同学可能要说了，记录日志还不简单，无非是几个常用的 API 方法，比如 debug、info、warn、error；但我就见过不少坑都是记录日志引起的，容易出错主要在于三个方面：">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Java业务开发常见错误100例">

  <meta itemprop="name" content="13__日志：日志记录真没你想象的那么简单">
  <meta itemprop="description" content="你好，我是朱晔。今天，我和你分享的是，记录日志可能会踩的坑。
一些同学可能要说了，记录日志还不简单，无非是几个常用的 API 方法，比如 debug、info、warn、error；但我就见过不少坑都是记录日志引起的，容易出错主要在于三个方面：">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7358">
  <meta itemprop="keywords" content="Java业务开发常见错误100例">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="13__日志：日志记录真没你想象的那么简单">
  <meta name="twitter:description" content="你好，我是朱晔。今天，我和你分享的是，记录日志可能会踩的坑。
一些同学可能要说了，记录日志还不简单，无非是几个常用的 API 方法，比如 debug、info、warn、error；但我就见过不少坑都是记录日志引起的，容易出错主要在于三个方面：">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">13__日志：日志记录真没你想象的那么简单</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7358 字 </span>
          <span class="more-meta"> 预计阅读 15 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#为什么我的日志会重复记录">为什么我的日志会重复记录？</a></li>
        <li><a href="#使用异步日志改善性能的坑">使用异步日志改善性能的坑</a></li>
        <li><a href="#使用日志占位符就不需要进行日志级别判断了">使用日志占位符就不需要进行日志级别判断了？</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考与讨论">思考与讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是朱晔。今天，我和你分享的是，记录日志可能会踩的坑。</p>
<p>一些同学可能要说了，记录日志还不简单，无非是几个常用的 API 方法，比如 debug、info、warn、error；但我就见过不少坑都是记录日志引起的，容易出错主要在于三个方面：</p>
<ol>
<li>日志框架众多，不同的类库可能会使用不同的日志框架，如何兼容是一个问题。</li>
<li>配置复杂且容易出错。日志配置文件通常很复杂，因此有些开发同学会从其他项目或者网络上复制一份配置文件，但却不知道如何修改，甚至是胡乱修改，造成很多问题。比如，重复记录日志的问题、同步日志的性能问题、异步记录的错误配置问题。</li>
<li>日志记录本身就有些误区，比如没考虑到日志内容获取的代价、胡乱使用日志级别等。</li>
</ol>
<p>Logback、Log4j、Log4j2、commons-logging、JDK 自带的 java.util.logging 等，都是 Java 体系的日志框架，确实非常多。而不同的类库，还可能选择使用不同的日志框架。这样一来，日志的统一管理就变得非常困难。为了解决这个问题，就有了 SLF4J（Simple Logging Facade For Java），如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/000d113b085db9e512619d355e36b716.png" alt=""></p>
<p>SLF4J 实现了三种功能：</p>
<ol>
<li>一是提供了统一的日志门面 API，即图中紫色部分，实现了中立的日志记录 API。</li>
<li>二是桥接功能，即图中蓝色部分，用来把各种日志框架的 API（图中绿色部分）桥接到 SLF4J API。这样一来，即便你的程序中使用了各种日志 API 记录日志，最终都可以桥接到 SLF4J 门面 API。</li>
<li>三是适配功能，即图中红色部分，可以实现 SLF4J API 和实际日志框架（图中灰色部分）的绑定。SLF4J 只是日志标准，我们还是需要一个实际的日志框架。日志框架本身没有实现 SLF4J API，所以需要有一个前置转换。Logback 就是按照 SLF4J API 标准实现的，因此不需要绑定模块做转换。</li>
</ol>
<p>需要理清楚的是，虽然我们可以使用 log4j-over-slf4j 来实现 Log4j 桥接到 SLF4J，也可以使用 slf4j-log4j12 实现 SLF4J 适配到 Log4j，也把它们画到了一列，<strong>但是它不能同时使用它们，否则就会产生死循环。jcl 和 jul 也是同样的道理。</strong></p>
<p>虽然图中有 4 个灰色的日志实现框架，但我看到的业务系统使用最广泛的是 Logback 和 Log4j，它们是同一人开发的。Logback 可以认为是 Log4j 的改进版本，我更推荐使用。所以，关于日志框架配置的案例，我都会围绕 Logback 展开。</p>
<p>Spring Boot 是目前最流行的 Java 框架，它的日志框架也用的是 Logback。那，为什么我们没有手动引入 Logback 的包，就可以直接使用 Logback 了呢？</p>
<p>查看 Spring Boot 的 Maven 依赖树，可以发现 spring-boot-starter 模块依赖了 spring-boot-starter-logging 模块，而 spring-boot-starter-logging 模块又帮我们自动引入了 logback-classic（包含了 SLF4J 和 Logback 日志框架）和 SLF4J 的一些适配器。其中，log4j-to-slf4j 用于实现 Log4j2 API 到 SLF4J 的桥接，jul-to-slf4j 则是实现 java.util.logging API 到 SLF4J 的桥接：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/ce2a28af389880f9b8ae970464649cd5.png" alt=""></p>
<p>接下来，我就用几个实际的案例和你说说日志配置和记录这两大问题，顺便以 Logback 为例复习一下常见的日志配置。</p>
<h2 id="为什么我的日志会重复记录">为什么我的日志会重复记录？</h2>
<p>日志重复记录在业务上非常常见，不但给查看日志和统计工作带来不必要的麻烦，还会增加磁盘和日志收集系统的负担。接下来，我和你分享两个重复记录的案例，同时帮助你梳理 Logback 配置的基本结构。</p>
<p><strong>第一个案例是，logger 配置继承关系导致日志重复记录</strong>。首先，定义一个方法实现 debug、info、warn 和 error 四种日志的记录：</p>
<p>@Log4j2<br>
@RequestMapping(&ldquo;logging&rdquo;)<br>
@RestController<br>
public class LoggingController {<br>
@GetMapping(&ldquo;log&rdquo;)<br>
public void log() {<br>
log.debug(&ldquo;debug&rdquo;);<br>
log.info(&ldquo;info&rdquo;);<br>
log.warn(&ldquo;warn&rdquo;);<br>
log.error(&ldquo;error&rdquo;);<br>
}<br>
}</p>
<p>然后，使用下面的 Logback 配置：</p>
<ol>
<li>第 11 和 12 行设置了全局的日志级别为 INFO，日志输出使用 CONSOLE Appender。</li>
<li>第 3 到 7 行，首先将 CONSOLE Appender 定义为 ConsoleAppender，也就是把日志输出到控制台（System.out/System.err）；然后通过 PatternLayout 定义了日志的输出格式。关于格式化字符串的各种使用方式，你可以进一步查阅官方文档。</li>
<li>第 8 到 10 行实现了一个 Logger 配置，将应用包的日志级别设置为 DEBUG、日志输出同样使用 CONSOLE Appender。</li>
</ol>
<configuration>  
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">  
        <layout class="ch.qos.logback.classic.PatternLayout">  
            <pattern>[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n</pattern>  
        </layout>  
    </appender>  
    <logger name="org.geekbang.time.commonmistakes.logging" level="DEBUG">  
        <appender-ref ref="CONSOLE"/>  
    </logger>  
    <root level="INFO">  
        <appender-ref ref="CONSOLE"/>  
    </root>  
</configuration>
<p>这段配置看起来没啥问题，但执行方法后出现了日志重复记录的问题：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/d294be8b28d934b459582fa39104ee37.png" alt=""></p>
<p>从配置文件的第 9 和 12 行可以看到，CONSOLE 这个 Appender 同时挂载到了两个 Logger 上，一个是我们定义的，一个是，由于我们定义的继承自，<strong>所以同一条日志既会通过 logger 记录，也会发送到 root 记录，因此应用 package 下的日志出现了重复记录。</strong></p>
<p>后来我了解到，这个同学如此配置的初衷是实现自定义的 logger 配置，让应用内的日志暂时开启 DEBUG 级别的日志记录。其实，他完全不需要重复挂载 Appender，去掉下挂载的 Appender 即可：</p>
<logger name="org.geekbang.time.commonmistakes.logging" level="DEBUG"/>
<p>如果自定义的需要把日志输出到不同的 Appender，比如将应用的日志输出到文件 app.log、把其他框架的日志输出到控制台，可以设置的 additivity 属性为 false，这样就不会继承的 Appender 了：</p>
<configuration>  
    <appender name="FILE" class="ch.qos.logback.core.FileAppender">  
        <file>app.log</file>  
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">  
            <pattern>[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n</pattern>  
        </encoder>  
    </appender>  
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">  
      <layout class="ch.qos.logback.classic.PatternLayout">  
            <pattern>[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n</pattern>  
      </layout>  
   </appender>  
    <logger name="org.geekbang.time.commonmistakes.logging" level="DEBUG" additivity="false">  
        <appender-ref ref="FILE"/>  
    </logger>  
   <root level="INFO">  
      <appender-ref ref="CONSOLE" />  
   </root>  
</configuration>
<p><strong>第二个案例是，错误配置 LevelFilter 造成日志重复记录。</strong></p>
<p>一般互联网公司都会使用 ELK 三件套来统一收集日志，有一次我们发现 Kibana 上展示的日志有部分重复，一直怀疑是 Logstash 配置错误，但最后发现还是 Logback 的配置错误引起的。</p>
<p>这个项目的日志是这样配置的：在记录日志到控制台的同时，把日志记录按照不同的级别记录到两个文件中：</p>
<configuration>  
   <property name="logDir" value="./logs" />  
   <property name="app.name" value="common-mistakes" />  
   <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">  
      <layout class="ch.qos.logback.classic.PatternLayout">  
         <pattern>[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n</pattern>  
      </layout>  
   </appender>  
   <appender name="INFO_FILE" class="ch.qos.logback.core.FileAppender">  
      <File>${logDir}/${app.name}_info.log</File>  
      <filter class="ch.qos.logback.classic.filter.LevelFilter">  
         <level>INFO</level>  
      </filter>  
      <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">  
         <pattern>[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n</pattern>  
         <charset>UTF-8</charset>  
      </encoder>  
   </appender>  
   <appender name="ERROR_FILE" class="ch.qos.logback.core.FileAppender  
">  
      <File>${logDir}/${app.name}_error.log</File>  
      <filter class="ch.qos.logback.classic.filter.ThresholdFilter">  
         <level>WARN</level>  
      </filter>  
      <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">  
         <pattern>[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n</pattern>  
         <charset>UTF-8</charset>  
      </encoder>  
   </appender>  
   <root level="INFO">  
      <appender-ref ref="CONSOLE" />  
      <appender-ref ref="INFO_FILE"/>  
      <appender-ref ref="ERROR_FILE"/>  
   </root>  
</configuration>
<p>这个配置文件比较长，我带着你一段一段地看：</p>
<ol>
<li>第 31 到 35 行定义的 root 引用了三个 Appender。</li>
<li>第 5 到 9 行是第一个 ConsoleAppender，用于把所有日志输出到控制台。</li>
<li>第 10 到 19 行定义了一个 FileAppender，用于记录文件日志，并定义了文件名、记录日志的格式和编码等信息。最关键的是，第 12 到 14 行定义的 LevelFilter 过滤日志，将过滤级别设置为 INFO，目的是希望 _info.log 文件中可以记录 INFO 级别的日志。</li>
<li>第 20 到 30 行定义了一个类似的 FileAppender，并使用 ThresholdFilter 来过滤日志，过滤级别设置为 WARN，目的是把 WARN 以上级别的日志记录到另一个 _error.log 文件中。</li>
</ol>
<p>运行一下测试程序：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/5f2c1f203eba52d5fcd9b7c966cd7165.png" alt=""></p>
<p>可以看到，_info.log 中包含了 INFO、WARN 和 ERROR 三个级别的日志，不符合我们的预期；error.log 包含了 WARN 和 ERROR 两个级别的日志。因此，造成了日志的重复收集。</p>
<p>你可能会问，这么明显的日志重复为什么没有及时发现？一些公司使用自动化的 ELK 方案收集日志，日志会同时输出到控制台和文件，开发人员在本机测试时不太会关心文件中记录的日志，而在测试和生产环境又因为开发人员没有服务器访问权限，所以原始日志文件中的重复问题并不容易发现。</p>
<p>为了分析日志重复的原因，我们来复习一下 ThresholdFilter 和 LevelFilter 的配置方式。</p>
<p>分析 ThresholdFilter 的源码发现，当日志级别大于等于配置的级别时返回 NEUTRAL，继续调用过滤器链上的下一个过滤器；否则，返回 DENY 直接拒绝记录日志：</p>
<p>public class ThresholdFilter extends Filter<ILoggingEvent> {<br>
public FilterReply decide(ILoggingEvent event) {<br>
if (!isStarted()) {<br>
return FilterReply.NEUTRAL;<br>
}</p>
<pre><code>    if (event.getLevel().isGreaterOrEqual(level)) {  
        return FilterReply.NEUTRAL;  
    } else {  
        return FilterReply.DENY;  
    }  
}  
</code></pre>
<p>}</p>
<p>在这个案例中，把 ThresholdFilter 设置为 WARN，可以记录 WARN 和 ERROR 级别的日志。</p>
<p>LevelFilter 用来比较日志级别，然后进行相应处理：如果匹配就调用 onMatch 定义的处理方式，默认是交给下一个过滤器处理（AbstractMatcherFilter 基类中定义的默认值）；否则，调用 onMismatch 定义的处理方式，默认也是交给下一个过滤器处理。</p>
<p>public class LevelFilter extends AbstractMatcherFilter<ILoggingEvent> {<br>
public FilterReply decide(ILoggingEvent event) {<br>
if (!isStarted()) {<br>
return FilterReply.NEUTRAL;<br>
}</p>
<pre><code>  if (event.getLevel().equals(level)) {  
      return onMatch;  
  } else {  
      return onMismatch;  
  }  
</code></pre>
<p>}<br>
}</p>
<p>public abstract class AbstractMatcherFilter<E> extends Filter<E> {<br>
protected FilterReply onMatch = FilterReply.NEUTRAL;<br>
protected FilterReply onMismatch = FilterReply.NEUTRAL;<br>
}</p>
<p>和 ThresholdFilter 不同的是，LevelFilter 仅仅配置 level 是无法真正起作用的。<strong>由于没有配置 onMatch 和 onMismatch 属性，所以相当于这个过滤器是无用的，导致 INFO 以上级别的日志都记录了。</strong></p>
<p>定位到问题后，修改方式就很明显了：配置 LevelFilter 的 onMatch 属性为 ACCEPT，表示接收 INFO 级别的日志；配置 onMismatch 属性为 DENY，表示除了 INFO 级别都不记录：</p>
<appender name="INFO_FILE" class="ch.qos.logback.core.FileAppender">  
  <File>${logDir}/${app.name}_info.log</File>  
  <filter class="ch.qos.logback.classic.filter.LevelFilter">  
    <level>INFO</level>  
    <onMatch>ACCEPT</onMatch>  
    <onMismatch>DENY</onMismatch>  
  </filter>  
  ...  
</appender>
<p>这样修改后，_info.log 文件中只会有 INFO 级别的日志，不会出现日志重复的问题了。</p>
<h2 id="使用异步日志改善性能的坑">使用异步日志改善性能的坑</h2>
<p>掌握了把日志输出到文件中的方法后，我们接下来面临的问题是，如何避免日志记录成为应用的性能瓶颈。这可以帮助我们解决，磁盘（比如机械磁盘）IO 性能较差、日志量又很大的情况下，如何记录日志的问题。</p>
<p>我们先来测试一下，记录日志的性能问题，定义如下的日志配置，一共有两个 Appender：</p>
<ol>
<li>FILE 是一个 FileAppender，用于记录所有的日志；</li>
<li>CONSOLE 是一个 ConsoleAppender，用于记录带有 time 标记的日志。</li>
</ol>
<configuration>  
    <appender name="FILE" class="ch.qos.logback.core.FileAppender">  
        <file>app.log</file>  
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">  
            <pattern>[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n</pattern>  
        </encoder>  
    </appender>  
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">  
        <layout class="ch.qos.logback.classic.PatternLayout">  
            <pattern>[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n</pattern>  
        </layout>  
        <filter class="ch.qos.logback.core.filter.EvaluatorFilter">  
            <evaluator class="ch.qos.logback.classic.boolex.OnMarkerEvaluator">  
                <marker>time</marker>  
            </evaluator>  
            <onMismatch>DENY</onMismatch>  
            <onMatch>ACCEPT</onMatch>  
        </filter>  
    </appender>  
    <root level="INFO">  
        <appender-ref ref="FILE"/>  
        <appender-ref ref="CONSOLE"/>  
    </root>  
</configuration>
<p>不知道你有没有注意到，这段代码中有个 EvaluatorFilter（求值过滤器），用于判断日志是否符合某个条件。</p>
<p>在后续的测试代码中，我们会把大量日志输出到文件中，日志文件会非常大，如果性能测试结果也混在其中的话，就很难找到那条日志。所以，这里我们使用 EvaluatorFilter 对日志按照标记进行过滤，并将过滤出的日志单独输出到控制台上。在这个案例中，我们给输出测试结果的那条日志上做了 time 标记。</p>
<p>配合使用标记和 EvaluatorFilter，实现日志的按标签过滤，是一个不错的小技巧。</p>
<p>如下测试代码中，实现了记录指定次数的大日志，每条日志包含 1MB 字节的模拟数据，最后记录一条以 time 为标记的方法执行耗时日志：</p>
<p>@GetMapping(&ldquo;performance&rdquo;)<br>
public void performance(@RequestParam(name = &ldquo;count&rdquo;, defaultValue = &ldquo;1000&rdquo;) int count) {<br>
long begin = System.currentTimeMillis();<br>
String payload = IntStream.rangeClosed(1, 1000000)<br>
.mapToObj(__ -&gt; &ldquo;a&rdquo;)<br>
.collect(Collectors.joining(&quot;&quot;)) + UUID.randomUUID().toString();<br>
IntStream.rangeClosed(1, count).forEach(i -&gt; log.info(&quot;{} {}&quot;, i, payload));<br>
Marker timeMarker = MarkerFactory.getMarker(&ldquo;time&rdquo;);<br>
log.info(timeMarker, &ldquo;took {} ms&rdquo;, System.currentTimeMillis() - begin);<br>
}</p>
<p>执行程序后可以看到，记录 1000 次日志和 10000 次日志的调用耗时，分别是 6.3 秒和 44.5 秒：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/4628a1eb89bc6705457be4b80b356e83.png" alt=""></p>
<p>对于只记录文件日志的代码了来说，这个耗时挺长的。为了分析其中原因，我们需要分析下 FileAppender 的源码。</p>
<p>FileAppender 继承自 OutputStreamAppender，查看 OutputStreamAppender 源码的第 30 到 33 行发现，<strong>在追加日志的时候，是直接把日志写入 OutputStream 中，属于同步记录日志：</strong></p>
<p>public class OutputStreamAppender<E> extends UnsynchronizedAppenderBase<E> {<br>
private OutputStream outputStream;<br>
boolean immediateFlush = true;<br>
@Override<br>
protected void append(E eventObject) {<br>
if (!isStarted()) {<br>
return;<br>
}<br>
subAppend(eventObject);<br>
}</p>
<pre><code>protected void subAppend(E event) {  
    if (!isStarted()) {  
        return;  
    }  
    try {  
        //编码 LoggingEvent  
        byte[] byteArray = this.encoder.encode(event);  
        //写字节流  
        writeBytes(byteArray);  
    } catch (IOException ioe) {  
        ...  
    }  
}  

private void writeBytes(byte[] byteArray) throws IOException {  
    if(byteArray == null || byteArray.length == 0)  
        return;  
      
    lock.lock();  
    try {  
        //这个 OutputStream 其实是一个 ResilientFileOutputStream，其内部使用的是带缓冲的 BufferedOutputStream  
        this.outputStream.write(byteArray);  
        if (immediateFlush) {  
            this.outputStream.flush();//刷入 OS  
        }  
    } finally {  
        lock.unlock();  
    }  
}  
</code></pre>
<p>}</p>
<p>分析到这里，我们就明白为什么日志大量写入时会耗时这么久了。那，有没有办法实现大量日志写入时，不会过多影响业务逻辑执行耗时，影响吞吐量呢？</p>
<p>办法当然有了，使用 Logback 提供的 AsyncAppender 即可实现异步的日志记录。AsyncAppende 类似装饰模式，也就是在不改变类原有基本功能的情况下为其增添新功能。这样，我们就可以把 AsyncAppender 附加在其他的 Appender 上，将其变为异步的。</p>
<p>定义一个异步 Appender ASYNCFILE，包装之前的同步文件日志记录的 FileAppender，就可以实现异步记录日志到文件：</p>
<appender name="ASYNCFILE" class="ch.qos.logback.classic.AsyncAppender">  
    <appender-ref ref="FILE"/>  
</appender>  
<root level="INFO">  
    <appender-ref ref="ASYNCFILE"/>  
    <appender-ref ref="CONSOLE"/>  
</root>
<p>测试一下可以发现，记录 1000 次日志和 10000 次日志的调用耗时，分别是 735 毫秒和 668 毫秒：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/c5009cfc82ee56bdf69f8e72eee4df5c.png" alt=""></p>
<p>性能居然这么好，你觉得其中有什么问题吗？异步日志真的如此神奇和万能吗？当然不是，因为这样并没有记录下所有日志。<strong>我之前就遇到过很多关于 AsyncAppender 异步日志的坑，这些坑可以归结为三类：</strong></p>
<ol>
<li>记录异步日志撑爆内存；</li>
<li>记录异步日志出现日志丢失；</li>
<li>记录异步日志出现阻塞。</li>
</ol>
<p>为了解释这三种坑，我来模拟一个慢日志记录场景：首先，自定义一个继承自 ConsoleAppender 的 MySlowAppender，作为记录到控制台的输出器，写入日志时休眠 1 秒。</p>
<p>public class MySlowAppender extends ConsoleAppender {<br>
@Override<br>
protected void subAppend(Object event) {<br>
try {<br>
// 模拟慢日志<br>
TimeUnit.MILLISECONDS.sleep(1);<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
super.subAppend(event);<br>
}<br>
}</p>
<p>然后，在配置文件中使用 AsyncAppender，将 MySlowAppender 包装为异步日志记录：</p>
<configuration>  
<appender name="CONSOLE" class="org.geekbang.time.commonmistakes.logging.async.MySlowAppender">  
    <layout class="ch.qos.logback.classic.PatternLayout">  
            <pattern>[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n</pattern>  
    </layout>  
  </appender>  
  <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">  
    <appender-ref ref="CONSOLE" />  
  </appender>  
  <root level="INFO">  
    <appender-ref ref="ASYNC" />  
  </root>  
</configuration>
<p>定义一段测试代码，循环记录一定次数的日志，最后输出方法执行耗时：</p>
<p>@GetMapping(&ldquo;manylog&rdquo;)<br>
public void manylog(@RequestParam(name = &ldquo;count&rdquo;, defaultValue = &ldquo;1000&rdquo;) int count) {<br>
long begin = System.currentTimeMillis();<br>
IntStream.rangeClosed(1, count).forEach(i -&gt; log.info(&ldquo;log-{}&rdquo;, i));<br>
System.out.println(&ldquo;took &quot; + (System.currentTimeMillis() - begin) + &quot; ms&rdquo;);<br>
}</p>
<p>执行方法后发现，耗时很短但出现了日志丢失：我们要记录 1000 条日志，最终控制台只能搜索到 215 条日志，而且日志的行号变为了一个问号。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/5b1f2dbf3268f56073ed76579af56bc4.png" alt=""></p>
<p>出现这个问题的原因在于，AsyncAppender 提供了一些配置参数，而我们没用对。我们结合相关源码分析一下：</p>
<ol>
<li>includeCallerData 用于控制是否收集调用方数据，默认是 false，此时方法行号、方法名等信息将不能显示（源码第 2 行以及 7 到 11 行）。</li>
<li>queueSize 用于控制阻塞队列大小，使用的 ArrayBlockingQueue 阻塞队列（源码第 15 到 17 行），默认大小是 256，即内存中最多保存 256 条日志。</li>
<li>discardingThreshold 是控制丢弃日志的阈值，主要是防止队列满后阻塞。默认情况下，队列剩余量低于队列长度的 20%，就会丢弃 TRACE、DEBUG 和 INFO 级别的日志。（参见源码第 3 到 6 行、18 到 19 行、26 到 27 行、33 到 34 行、40 到 42 行）</li>
<li>neverBlock 用于控制队列满的时候，加入的数据是否直接丢弃，不会阻塞等待，默认是 false（源码第 44 到 68 行）。这里需要注意一下 offer 方法和 put 方法的区别，当队列满的时候 offer 方法不阻塞，而 put 方法会阻塞；neverBlock 为 true 时，使用 offer 方法。</li>
</ol>
<p>public class AsyncAppender extends AsyncAppenderBase<ILoggingEvent> {<br>
boolean includeCallerData = false;//是否收集调用方数据<br>
protected boolean isDiscardable(ILoggingEvent event) {<br>
Level level = event.getLevel();<br>
return level.toInt() &lt;= Level.INFO_INT;//丢弃&lt;=INFO 级别的日志<br>
}<br>
protected void preprocess(ILoggingEvent eventObject) {<br>
eventObject.prepareForDeferredProcessing();<br>
if (includeCallerData)<br>
eventObject.getCallerData();<br>
}<br>
}<br>
public class AsyncAppenderBase<E> extends UnsynchronizedAppenderBase<E> implements AppenderAttachable<E> {</p>
<pre><code>BlockingQueue&lt;E&gt; blockingQueue;//异步日志的关键，阻塞队列  
public static final int DEFAULT_QUEUE_SIZE = 256;//默认队列大小  
int queueSize = DEFAULT_QUEUE_SIZE;  
static final int UNDEFINED = -1;  
int discardingThreshold = UNDEFINED;  
boolean neverBlock = false;//控制队列满的时候加入数据时是否直接丢弃，不会阻塞等待  

@Override  
public void start() {  
     ...  
    blockingQueue = new ArrayBlockingQueue&lt;E&gt;(queueSize);  
    if (discardingThreshold == UNDEFINED)  
        discardingThreshold = queueSize / 5;//默认丢弃阈值是队列剩余量低于队列长度的 20%，参见 isQueueBelowDiscardingThreshold 方法  
    ...  
}  

@Override  
protected void append(E eventObject) {  
    if (isQueueBelowDiscardingThreshold() &amp;&amp; isDiscardable(eventObject)) { //判断是否可以丢数据  
        return;  
    }  
    preprocess(eventObject);  
    put(eventObject);  
}  

private boolean isQueueBelowDiscardingThreshold() {  
    return (blockingQueue.remainingCapacity() &lt; discardingThreshold);  
}  

private void put(E eventObject) {  
    if (neverBlock) { //根据 neverBlock 决定使用不阻塞的 offer 还是阻塞的 put 方法  
        blockingQueue.offer(eventObject);  
    } else {  
        putUninterruptibly(eventObject);  
    }  
}  
//以阻塞方式添加数据到队列  
private void putUninterruptibly(E eventObject) {  
    boolean interrupted = false;  
    try {  
        while (true) {  
            try {  
                blockingQueue.put(eventObject);  
                break;  
            } catch (InterruptedException e) {  
                interrupted = true;  
            }  
        }  
    } finally {  
        if (interrupted) {  
            Thread.currentThread().interrupt();  
        }  
    }  
}  
</code></pre>
<p>}</p>
<p>看到默认队列大小为 256，达到 80% 容量后开始丢弃 &lt;=INFO 级别的日志后，我们就可以理解日志中为什么只有 215 条 INFO 日志了。</p>
<p>我们可以继续分析下异步记录日志出现坑的原因。</p>
<ol>
<li>queueSize 设置得特别大，就可能会导致 OOM。</li>
<li>queueSize 设置得比较小（默认值就非常小），且 discardingThreshold 设置为大于 0 的值（或者为默认值），队列剩余容量少于 discardingThreshold 的配置就会丢弃 &lt;=INFO 的日志。这里的坑点有两个。一是，因为 discardingThreshold 的存在，设置 queueSize 时容易踩坑。比如，本例中最大日志并发是 1000，即便设置 queueSize 为 1000 同样会导致日志丢失。二是，discardingThreshold 参数容易有歧义，它不是百分比，而是日志条数。对于总容量 10000 的队列，如果希望队列剩余容量少于 1000 条的时候丢弃，需要配置为 1000。</li>
<li>neverBlock 默认为 false，意味着总可能会出现阻塞。如果 discardingThreshold 为 0，那么队列满时再有日志写入就会阻塞；如果 discardingThreshold 不为 0，也只会丢弃 &lt;=INFO 级别的日志，那么出现大量错误日志时，还是会阻塞程序。</li>
</ol>
<p>可以看出 queueSize、discardingThreshold 和 neverBlock 这三个参数息息相关，务必按需进行设置和取舍，到底是性能为先，还是数据不丢为先：</p>
<ol>
<li>如果考虑绝对性能为先，那就设置 neverBlock 为 true，永不阻塞。</li>
<li>如果考虑绝对不丢数据为先，那就设置 discardingThreshold 为 0，即使是 &lt;=INFO 的级别日志也不会丢，但最好把 queueSize 设置大一点，毕竟默认的 queueSize 显然太小，太容易阻塞。</li>
<li>如果希望兼顾两者，可以丢弃不重要的日志，把 queueSize 设置大一点，再设置一个合理的 discardingThreshold。</li>
</ol>
<p>以上就是日志配置最常见的两个误区了。接下来，我们再看一个日志记录本身的误区。</p>
<h2 id="使用日志占位符就不需要进行日志级别判断了">使用日志占位符就不需要进行日志级别判断了？</h2>
<p>不知道你有没有听人说过：SLF4J 的{}占位符语法，到真正记录日志时才会获取实际参数，因此解决了日志数据获取的性能问题。你觉得，这种说法对吗？</p>
<p>为了验证这个问题，我们写一段测试代码：有一个 slowString 方法，返回结果耗时 1 秒：</p>
<p>private String slowString(String s) {<br>
System.out.println(&ldquo;slowString called via &quot; + s);<br>
try {<br>
TimeUnit.SECONDS.sleep(1);<br>
} catch (InterruptedException e) {<br>
}<br>
return &ldquo;OK&rdquo;;<br>
}</p>
<p>如果我们记录 DEBUG 日志，并设置只记录 &gt;=INFO 级别的日志，程序是否也会耗时 1 秒呢？我们使用三种方法来测试：</p>
<ol>
<li>拼接字符串方式记录 slowString；</li>
<li>使用占位符方式记录 slowString；</li>
<li>先判断日志级别是否启用 DEBUG。</li>
</ol>
<p>StopWatch stopWatch = new StopWatch();<br>
stopWatch.start(&ldquo;debug1&rdquo;);<br>
log.debug(&ldquo;debug1:&rdquo; + slowString(&ldquo;debug1&rdquo;));<br>
stopWatch.stop();<br>
stopWatch.start(&ldquo;debug2&rdquo;);<br>
log.debug(&ldquo;debug2:{}&rdquo;, slowString(&ldquo;debug2&rdquo;));<br>
stopWatch.stop();<br>
stopWatch.start(&ldquo;debug3&rdquo;);<br>
if (log.isDebugEnabled())<br>
log.debug(&ldquo;debug3:{}&rdquo;, slowString(&ldquo;debug3&rdquo;));<br>
stopWatch.stop();</p>
<p>可以看到，前两种方式都调用了 slowString 方法，所以耗时都是 1 秒：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/142760f5cecac759f8be825510d5f258.png" alt=""></p>
<p>使用占位符方式记录 slowString 的方式，同样需要耗时 1 秒，是因为这种方式虽然允许我们传入 Object，不用拼接字符串，但也只是延迟（如果日志不记录那么就是省去）了日志参数对象.toString() 和字符串拼接的耗时。</p>
<p>在这个案例中，除非事先判断日志级别，否则必然会调用 slowString 方法。<strong>回到之前提的问题，使用{}占位符语法不能通过延迟参数值获取，来解决日志数据获取的性能问题。</strong></p>
<p>除了事先判断日志级别，我们还可以通过 lambda 表达式进行延迟参数内容获取。但，SLF4J 的 API 还不支持 lambda，因此需要使用 Log4j2 日志 API，把 Lombok 的 @Slf4j 注解替换为 @Log4j2 注解，这样就可以提供一个 lambda 表达式作为提供参数数据的方法：</p>
<p>@Log4j2<br>
public class LoggingController {<br>
&hellip;<br>
log.debug(&ldquo;debug4:{}&rdquo;, ()-&gt;slowString(&ldquo;debug4&rdquo;));</p>
<p>像这样调用 debug 方法，签名是 Supplier<?>，参数会延迟到真正需要记录日志时再获取：</p>
<p>void debug(String message, Supplier<?>&hellip; paramSuppliers);</p>
<p>public void logIfEnabled(final String fqcn, final Level level, final Marker marker, final String message,<br>
final Supplier<?>&hellip; paramSuppliers) {<br>
if (isEnabled(level, marker, message)) {<br>
logMessage(fqcn, level, marker, message, paramSuppliers);<br>
}<br>
}<br>
protected void logMessage(final String fqcn, final Level level, final Marker marker, final String message,<br>
final Supplier<?>&hellip; paramSuppliers) {<br>
final Message msg = messageFactory.newMessage(message, LambdaUtil.getAll(paramSuppliers));<br>
logMessageSafely(fqcn, level, marker, msg, msg.getThrowable());<br>
}</p>
<p>修改后再次运行测试，可以看到这次 debug4 并不会调用 slowString 方法：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/e88d925486ee6eebd77ebc461434b5b9.png" alt=""></p>
<p>其实，我们只是换成了 Log4j2 API，真正的日志记录还是走的 Logback 框架。没错，这就是 SLF4J 适配的一个好处。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>我将记录日志的坑，总结为框架使用配置和记录本身两个方面。</p>
<p>Java 的日志框架众多，SLF4J 实现了这些框架记录日志的统一。在使用 SLF4J 时，我们需要理清楚其桥接 API 和绑定这两个模块。如果程序启动时出现 SLF4J 的错误提示，那很可能是配置出现了问题，可以使用 Maven 的 dependency:tree 命令梳理依赖关系。</p>
<p>Logback 是 Java 最常用的日志框架，其配置比较复杂，你可以参考官方文档中关于 Appender、Layout、Filter 的配置，切记不要随意从其他地方复制别人的配置，避免出现错误或与当前需求不符。</p>
<p>使用异步日志解决性能问题，是用空间换时间。但空间毕竟有限，当空间满了之后，我们要考虑是阻塞等待，还是丢弃日志。如果更希望不丢弃重要日志，那么选择阻塞等待；如果更希望程序不要因为日志记录而阻塞，那么就需要丢弃日志。</p>
<p>最后，我强调的是，日志框架提供的参数化日志记录方式不能完全取代日志级别的判断。如果你的日志量很大，获取日志参数代价也很大，就要进行相应日志级别的判断，避免不记录日志也要花费时间获取日志参数的问题。</p>
<p>今天用到的代码，我都放在了 GitHub 上，你可以点击这个链接查看。</p>
<h2 id="思考与讨论">思考与讨论</h2>
<ol>
<li>在第一小节的案例中，我们把 INFO 级别的日志存放到 _info.log 中，把 WARN 和 ERROR 级别的日志存放到 _error.log 中。如果现在要把 INFO 和 WARN 级别的日志存放到 _info.log 中，把 ERROR 日志存放到 _error.log 中，应该如何配置 Logback 呢？</li>
<li>生产级项目的文件日志肯定需要按时间和日期进行分割和归档处理，以避免单个文件太大，同时保留一定天数的历史日志，你知道如何配置吗？可以在官方文档找到答案。</li>
</ol>
<p>针对日志记录和配置，你还遇到过其他坑吗？我是朱晔，欢迎在评论区与我留言分享，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/">Java业务开发常见错误100例</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%9B%A0%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E8%AF%BE/13__%E8%AE%A4%E8%AF%86%E4%BA%BA%E7%9A%84%E6%80%9D%E7%BB%B4%E7%BC%BA%E9%99%B7%E4%B8%8D%E7%90%86%E6%80%A7%E7%9A%84%E6%88%91%E4%BB%AC/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">13__认识人的思维缺陷：不理性的我们</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/13__%E5%AE%B9%E5%99%A8%E7%A3%81%E7%9B%98%E9%99%90%E9%80%9F%E6%88%91%E7%9A%84%E5%AE%B9%E5%99%A8%E9%87%8C%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%A8%B3%E5%AE%9A_/">
            <span class="next-text nav-default">13__容器磁盘限速：我的容器里磁盘读写为什么不稳定_</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
