<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>加餐1__带你吃透课程中Java_8的那些重要知识点（上） - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是朱晔。
Java 8 是目前最常用的 JDK 版本，在增强代码可读性、简化代码方面，相比 Java 7 增加了很多功能，比如 Lambda、Stream 流操作、并行流（ParallelStream）、Optional 可空类型、新日期时间类型等。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/%E5%8A%A0%E9%A4%901__%E5%B8%A6%E4%BD%A0%E5%90%83%E9%80%8F%E8%AF%BE%E7%A8%8B%E4%B8%ADjava_8%E7%9A%84%E9%82%A3%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8A/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/%E5%8A%A0%E9%A4%901__%E5%B8%A6%E4%BD%A0%E5%90%83%E9%80%8F%E8%AF%BE%E7%A8%8B%E4%B8%ADjava_8%E7%9A%84%E9%82%A3%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8A/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="加餐1__带你吃透课程中Java_8的那些重要知识点（上）">
  <meta property="og:description" content="你好，我是朱晔。
Java 8 是目前最常用的 JDK 版本，在增强代码可读性、简化代码方面，相比 Java 7 增加了很多功能，比如 Lambda、Stream 流操作、并行流（ParallelStream）、Optional 可空类型、新日期时间类型等。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Java业务开发常见错误100例">

  <meta itemprop="name" content="加餐1__带你吃透课程中Java_8的那些重要知识点（上）">
  <meta itemprop="description" content="你好，我是朱晔。
Java 8 是目前最常用的 JDK 版本，在增强代码可读性、简化代码方面，相比 Java 7 增加了很多功能，比如 Lambda、Stream 流操作、并行流（ParallelStream）、Optional 可空类型、新日期时间类型等。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6160">
  <meta itemprop="keywords" content="Java业务开发常见错误100例">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="加餐1__带你吃透课程中Java_8的那些重要知识点（上）">
  <meta name="twitter:description" content="你好，我是朱晔。
Java 8 是目前最常用的 JDK 版本，在增强代码可读性、简化代码方面，相比 Java 7 增加了很多功能，比如 Lambda、Stream 流操作、并行流（ParallelStream）、Optional 可空类型、新日期时间类型等。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">加餐1__带你吃透课程中Java_8的那些重要知识点（上）</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6160 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#如何在项目中用上-lambda-表达式和-stream-操作">如何在项目中用上 Lambda 表达式和 Stream 操作？</a></li>
        <li><a href="#lambda-表达式">Lambda 表达式</a></li>
        <li><a href="#使用-java-8-简化代码">使用 Java 8 简化代码</a>
          <ul>
            <li><a href="#使用-stream-简化集合操作">使用 Stream 简化集合操作</a></li>
            <li><a href="#有关-optional-可空类型">有关 Optional 可空类型</a></li>
            <li><a href="#java-8-类对于函数式-api-的增强">Java 8 类对于函数式 API 的增强</a></li>
          </ul>
        </li>
        <li><a href="#并行流">并行流</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考与讨论">思考与讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是朱晔。</p>
<p>Java 8 是目前最常用的 JDK 版本，在增强代码可读性、简化代码方面，相比 Java 7 增加了很多功能，比如 Lambda、Stream 流操作、并行流（ParallelStream）、Optional 可空类型、新日期时间类型等。</p>
<p>这个课程中的所有案例，都充分使用了 Java 8 的各种特性来简化代码。这也就意味着，如果你不了解这些特性的话，理解课程内的 Demo 可能会有些困难。因此，我将这些特性，单独拎了出来组成了两篇加餐。由于后面有单独一节课去讲 Java 8 的日期时间类型，所以这里就不赘述了。</p>
<h2 id="如何在项目中用上-lambda-表达式和-stream-操作">如何在项目中用上 Lambda 表达式和 Stream 操作？</h2>
<p>Java 8 的特性有很多，除了这两篇加餐外，我再给你推荐一本全面介绍 Java 8 的书，叫《Java 实战（第二版）》。此外，有同学在留言区问，怎么把 Lambda 表达式和 Stream 操作运用到项目中。其实，业务代码中可以使用这些特性的地方有很多。</p>
<p>这里，为了帮助你学习，并把这些特性用到业务开发中，我有三个小建议。</p>
<p>第一，从 List 的操作开始，先尝试把遍历 List 来筛选数据和转换数据的操作，使用 Stream 的 filter 和 map 实现，这是 Stream 最常用、最基本的两个 API。你可以重点看看接下来两节的内容来入门。</p>
<p>第二，使用高级的 IDE 来写代码，以此找到可以利用 Java 8 语言特性简化代码的地方。比如，对于 IDEA，我们可以把匿名类型使用 Lambda 替换的检测规则，设置为 Error 级别严重程度：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/096a9b6dcb499f2811e5e1fdbb61bb7b.png" alt=""></p>
<p>这样运行 IDEA 的 Inspect Code 的功能，可以在 Error 级别的错误中看到这个问题，引起更多关注，帮助我们建立使用 Lambda 表达式的习惯：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/1f398e32f264d41a0255a0e29c53a203.png" alt=""></p>
<p>第三，如果你不知道如何把匿名类转换为 Lambda 表达式，可以借助 IDE 来重构：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/9b3634ba961ed628c89c08343a8e33fc.png" alt=""></p>
<p>反过来，如果你在学习课程内案例时，如果感觉阅读 Lambda 表达式和 Stream API 比较吃力，同样可以借助 IDE 把 Java 8 的写法转换为使用循环的写法：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/c603ab244a4776a8aa1eec6117660b55.png" alt=""></p>
<p>或者是把 Lambda 表达式替换为匿名类：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/ba333235d2ff8bc36c8622784915595c.png" alt=""></p>
<h2 id="lambda-表达式">Lambda 表达式</h2>
<p>Lambda 表达式的初衷是，进一步简化匿名类的语法（不过实现上，Lambda 表达式并不是匿名类的语法糖），使 Java 走向函数式编程。对于匿名类，虽然没有类名，但还是要给出方法定义。这里有个例子，分别使用匿名类和 Lambda 表达式创建一个线程打印字符串：</p>
<p>//匿名类<br>
new Thread(new Runnable(){<br>
@Override<br>
public void run(){<br>
System.out.println(&ldquo;hello1&rdquo;);<br>
}<br>
}).start();<br>
//Lambda 表达式<br>
new Thread(() -&gt; System.out.println(&ldquo;hello2&rdquo;)).start();</p>
<p>那么，Lambda 表达式如何匹配 Java 的类型系统呢？</p>
<p>答案就是，函数式接口。</p>
<p>函数式接口是一种只有单一抽象方法的接口，使用 @FunctionalInterface 来描述，可以隐式地转换成 Lambda 表达式。使用 Lambda 表达式来实现函数式接口，不需要提供类名和方法定义，通过一行代码提供函数式接口的实例，就可以让函数成为程序中的头等公民，可以像普通数据一样作为参数传递，而不是作为一个固定的类中的固定方法。</p>
<p>那，函数式接口到底是什么样的呢？java.util.function 包中定义了各种函数式接口。比如，用于提供数据的 Supplier 接口，就只有一个 get 抽象方法，没有任何入参、有一个返回值：</p>
<p>@FunctionalInterface<br>
public interface Supplier<T> {</p>
<pre><code>/**  
 * Gets a result.  
 *  
 * @return a result  
 */  
T get();  
</code></pre>
<p>}</p>
<p>我们可以使用 Lambda 表达式或方法引用，来得到 Supplier 接口的实例：</p>
<p>//使用 Lambda 表达式提供 Supplier 接口实现，返回 OK 字符串<br>
Supplier<String> stringSupplier = ()-&gt;&ldquo;OK&rdquo;;<br>
//使用方法引用提供 Supplier 接口实现，返回空字符串<br>
Supplier<String> supplier = String::new;</p>
<p>这样，是不是很方便？为了帮你掌握函数式接口及其用法，我再举几个使用 Lambda 表达式或方法引用来构建函数的例子：</p>
<p>//Predicate 接口是输入一个参数，返回布尔值。我们通过 and 方法组合两个 Predicate 条件，判断是否值大于 0 并且是偶数<br>
Predicate<Integer> positiveNumber = i -&gt; i &gt; 0;<br>
Predicate<Integer> evenNumber = i -&gt; i % 2 == 0;<br>
assertTrue(positiveNumber.and(evenNumber).test(2));</p>
<p>//Consumer 接口是消费一个数据。我们通过 andThen 方法组合调用两个 Consumer，输出两行 abcdefg<br>
Consumer<String> println = System.out::println;<br>
println.andThen(println).accept(&ldquo;abcdefg&rdquo;);</p>
<p>//Function 接口是输入一个数据，计算后输出一个数据。我们先把字符串转换为大写，然后通过 andThen 组合另一个 Function 实现字符串拼接<br>
Function&lt;String, String&gt; upperCase = String::toUpperCase;<br>
Function&lt;String, String&gt; duplicate = s -&gt; s.concat(s);<br>
assertThat(upperCase.andThen(duplicate).apply(&ldquo;test&rdquo;), is(&ldquo;TESTTEST&rdquo;));</p>
<p>//Supplier 是提供一个数据的接口。这里我们实现获取一个随机数<br>
Supplier<Integer> random = ()-&gt;ThreadLocalRandom.current().nextInt();<br>
System.out.println(random.get());</p>
<p>//BinaryOperator 是输入两个同类型参数，输出一个同类型参数的接口。这里我们通过方法引用获得一个整数加法操作，通过 Lambda 表达式定义一个减法操作，然后依次调用<br>
BinaryOperator<Integer> add = Integer::sum;<br>
BinaryOperator<Integer> subtraction = (a, b) -&gt; a - b;<br>
assertThat(subtraction.apply(add.apply(1, 2), 3), is(0));</p>
<p>Predicate、Function 等函数式接口，还使用 default 关键字实现了几个默认方法。这样一来，它们既可以满足函数式接口只有一个抽象方法，又能为接口提供额外的功能：</p>
<p>@FunctionalInterface<br>
public interface Function&lt;T, R&gt; {<br>
R apply(T t);<br>
default <V> Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) {<br>
Objects.requireNonNull(before);<br>
return (V v) -&gt; apply(before.apply(v));<br>
}<br>
default <V> Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {<br>
Objects.requireNonNull(after);<br>
return (T t) -&gt; after.apply(apply(t));<br>
}<br>
}</p>
<p>很明显，Lambda 表达式给了我们复用代码的更多可能性：我们可以把一大段逻辑中变化的部分抽象出函数式接口，由外部方法提供函数实现，重用方法内的整体逻辑处理。</p>
<p>不过需要注意的是，在自定义函数式接口之前，可以先确认下java.util.function 包中的 43 个标准函数式接口是否能满足需求，我们要尽可能重用这些接口，因为使用大家熟悉的标准接口可以提高代码的可读性。</p>
<h2 id="使用-java-8-简化代码">使用 Java 8 简化代码</h2>
<p>这一部分，我会通过几个具体的例子，带你感受一下使用 Java 8 简化代码的三个重要方面：</p>
<ol>
<li>使用 Stream 简化集合操作；</li>
<li>使用 Optional 简化判空逻辑；</li>
<li>JDK8 结合 Lambda 和 Stream 对各种类的增强。</li>
</ol>
<h3 id="使用-stream-简化集合操作">使用 Stream 简化集合操作</h3>
<p>Lambda 表达式可以帮我们用简短的代码实现方法的定义，给了我们复用代码的更多可能性。利用这个特性，我们可以把集合的投影、转换、过滤等操作抽象成通用的接口，然后通过 Lambda 表达式传入其具体实现，这也就是 Stream 操作。</p>
<p>我们看一个具体的例子。这里有一段 20 行左右的代码，实现了如下的逻辑：</p>
<ol>
<li>把整数列表转换为 Point2D 列表；</li>
<li>遍历 Point2D 列表过滤出 Y 轴 &gt;1 的对象；</li>
<li>计算 Point2D 点到原点的距离；</li>
<li>累加所有计算出的距离，并计算距离的平均值。</li>
</ol>
<p>private static double calc(List<Integer> ints) {<br>
//临时中间集合<br>
List<Point2D> point2DList = new ArrayList&lt;&gt;();<br>
for (Integer i : ints) {<br>
point2DList.add(new Point2D.Double((double) i % 3, (double) i / 3));<br>
}<br>
//临时变量，纯粹是为了获得最后结果需要的中间变量<br>
double total = 0;<br>
int count = 0;</p>
<pre><code>for (Point2D point2D : point2DList) {  
    //过滤  
    if (point2D.getY() &gt; 1) {  
        //算距离  
        double distance = point2D.distance(0, 0);  
        total += distance;  
        count++;  
    }  
}  
//注意 count 可能为 0 的可能  
return count &gt;0 ? total / count : 0;  
</code></pre>
<p>}</p>
<p>现在，我们可以使用 Stream 配合 Lambda 表达式来简化这段代码。简化后一行代码就可以实现这样的逻辑，更重要的是代码可读性更强了，通过方法名就可以知晓大概是在做什么事情。比如：</p>
<ol>
<li>map 方法传入的是一个 Function，可以实现对象转换；</li>
<li>filter 方法传入一个 Predicate，实现对象的布尔判断，只保留返回 true 的数据；</li>
<li>mapToDouble 用于把对象转换为 double；</li>
<li>通过 average 方法返回一个 OptionalDouble，代表可能包含值也可能不包含值的可空 double。</li>
</ol>
<p>下面的第三行代码，就实现了上面方法的所有工作：</p>
<p>List<Integer> ints = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);<br>
double average = calc(ints);<br>
double streamResult = ints.stream()<br>
.map(i -&gt; new Point2D.Double((double) i % 3, (double) i / 3))<br>
.filter(point -&gt; point.getY() &gt; 1)<br>
.mapToDouble(point -&gt; point.distance(0, 0))<br>
.average()<br>
.orElse(0);<br>
//如何用一行代码来实现，比较一下可读性<br>
assertThat(average, is(streamResult));</p>
<p>到这里，你可能会问了，OptionalDouble 又是怎么回事儿？</p>
<h3 id="有关-optional-可空类型">有关 Optional 可空类型</h3>
<p>其实，类似 OptionalDouble、OptionalInt、OptionalLong 等，是服务于基本类型的可空对象。此外，Java8 还定义了用于引用类型的 Optional 类。使用 Optional，不仅可以避免使用 Stream 进行级联调用的空指针问题；更重要的是，它提供了一些实用的方法帮我们避免判空逻辑。</p>
<p>如下是一些例子，演示了如何使用 Optional 来避免空指针，以及如何使用它的 fluent API 简化冗长的 if-else 判空逻辑：</p>
<p>@Test(expected = IllegalArgumentException.class)<br>
public void optional() {<br>
//通过 get 方法获取 Optional 中的实际值<br>
assertThat(Optional.of(1).get(), is(1));<br>
//通过 ofNullable 来初始化一个 null，通过 orElse 方法实现 Optional 中无数据的时候返回一个默认值<br>
assertThat(Optional.ofNullable(null).orElse(&ldquo;A&rdquo;), is(&ldquo;A&rdquo;));<br>
//OptionalDouble 是基本类型 double 的 Optional 对象，isPresent 判断有无数据<br>
assertFalse(OptionalDouble.empty().isPresent());<br>
//通过 map 方法可以对 Optional 对象进行级联转换，不会出现空指针，转换后还是一个 Optional<br>
assertThat(Optional.of(1).map(Math::incrementExact).get(), is(2));<br>
//通过 filter 实现 Optional 中数据的过滤，得到一个 Optional，然后级联使用 orElse 提供默认值<br>
assertThat(Optional.of(1).filter(integer -&gt; integer % 2 == 0).orElse(null), is(nullValue()));<br>
//通过 orElseThrow 实现无数据时抛出异常<br>
Optional.empty().orElseThrow(IllegalArgumentException::new);<br>
}</p>
<p>我把 Optional 类的常用方法整理成了一张图，你可以对照案例再复习一下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/b7a4c9454bf15681fc135a8629e56c28.png" alt=""></p>
<h3 id="java-8-类对于函数式-api-的增强">Java 8 类对于函数式 API 的增强</h3>
<p>除了 Stream 之外，Java 8 中有很多类也都实现了函数式的功能。</p>
<p>比如，要通过 HashMap 实现一个缓存的操作，在 Java 8 之前我们可能会写出这样的 getProductAndCache 方法：先判断缓存中是否有值；如果没有值，就从数据库搜索取值；最后，把数据加入缓存。</p>
<p>private Map&lt;Long, Product&gt; cache = new ConcurrentHashMap&lt;&gt;();</p>
<p>private Product getProductAndCache(Long id) {<br>
Product product = null;<br>
//Key 存在，返回 Value<br>
if (cache.containsKey(id)) {<br>
product = cache.get(id);<br>
} else {<br>
//不存在，则获取 Value<br>
//需要遍历数据源查询获得 Product<br>
for (Product p : Product.getData()) {<br>
if (p.getId().equals(id)) {<br>
product = p;<br>
break;<br>
}<br>
}<br>
//加入 ConcurrentHashMap<br>
if (product != null)<br>
cache.put(id, product);<br>
}<br>
return product;<br>
}</p>
<p>@Test<br>
public void notcoolCache() {<br>
getProductAndCache(1L);<br>
getProductAndCache(100L);</p>
<pre><code>System.out.println(cache);  
assertThat(cache.size(), is(1));  
assertTrue(cache.containsKey(1L));  
</code></pre>
<p>}</p>
<p>而在 Java 8 中，我们利用 ConcurrentHashMap 的 computeIfAbsent 方法，用一行代码就可以实现这样的繁琐操作：</p>
<p>private Product getProductAndCacheCool(Long id) {<br>
return cache.computeIfAbsent(id, i -&gt; //当 Key 不存在的时候提供一个 Function 来代表根据 Key 获取 Value 的过程<br>
Product.getData().stream()<br>
.filter(p -&gt; p.getId().equals(i)) //过滤<br>
.findFirst() //找第一个，得到 Optional<Product><br>
.orElse(null)); //如果找不到 Product，则使用 null<br>
}</p>
<p>@Test<br>
public void coolCache()<br>
{<br>
getProductAndCacheCool(1L);<br>
getProductAndCacheCool(100L);</p>
<pre><code>System.out.println(cache);  
assertThat(cache.size(), is(1));  
assertTrue(cache.containsKey(1L));  
</code></pre>
<p>}</p>
<p>computeIfAbsent 方法在逻辑上相当于：</p>
<p>if (map.get(key) == null) {<br>
V newValue = mappingFunction.apply(key);<br>
if (newValue != null)<br>
map.put(key, newValue);<br>
}</p>
<p>又比如，利用 Files.walk 返回一个 Path 的流，通过两行代码就能实现递归搜索 +grep 的操作。整个逻辑是：递归搜索文件夹，查找所有的.java 文件；然后读取文件每一行内容，用正则表达式匹配 public class 关键字；最后输出文件名和这行内容。</p>
<p>@Test<br>
public void filesExample() throws IOException {<br>
//无限深度，递归遍历文件夹<br>
try (Stream<Path> pathStream = Files.walk(Paths.get(&quot;.&quot;))) {<br>
pathStream.filter(Files::isRegularFile) //只查普通文件<br>
.filter(FileSystems.getDefault().getPathMatcher(&ldquo;glob:**/*.java&rdquo;)::matches) //搜索 java 源码文件<br>
.flatMap(ThrowingFunction.unchecked(path -&gt;<br>
Files.readAllLines(path).stream() //读取文件内容，转换为 Stream<List><br>
.filter(line -&gt; Pattern.compile(&ldquo;public class&rdquo;).matcher(line).find()) //使用正则过滤带有 public class 的行<br>
.map(line -&gt; path.getFileName() + &quot; &raquo; &quot; + line))) //把这行文件内容转换为文件名 + 行<br>
.forEach(System.out::println); //打印所有的行<br>
}<br>
}</p>
<p>输出结果如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/b4293b601588de0b8abe2fb74f083362.png" alt=""></p>
<p>我再和你分享一个小技巧吧。因为 Files.readAllLines 方法会抛出一个受检异常（IOException），所以我使用了一个自定义的函数式接口，用 ThrowingFunction 包装这个方法，把受检异常转换为运行时异常，让代码更清晰：</p>
<p>@FunctionalInterface<br>
public interface ThrowingFunction&lt;T, R, E extends Throwable&gt; {<br>
static &lt;T, R, E extends Throwable&gt; Function&lt;T, R&gt; unchecked(ThrowingFunction&lt;T, R, E&gt; f) {<br>
return t -&gt; {<br>
try {<br>
return f.apply(t);<br>
} catch (Throwable e) {<br>
throw new RuntimeException(e);<br>
}<br>
};<br>
}</p>
<pre><code>R apply(T t) throws E;  
</code></pre>
<p>}</p>
<p>如果用 Java 7 实现类似逻辑的话，大概需要几十行代码，你可以尝试下。</p>
<h2 id="并行流">并行流</h2>
<p>前面我们看到的 Stream 操作都是串行 Stream，操作只是在一个线程中执行，此外 Java 8 还提供了并行流的功能：通过 parallel 方法，一键把 Stream 转换为并行操作提交到线程池处理。</p>
<p>比如，如下代码通过线程池来并行消费处理 1 到 100：</p>
<p>IntStream.rangeClosed(1,100).parallel().forEach(i-&gt;{<br>
System.out.println(LocalDateTime.now() + &quot; : &quot; + i);<br>
try {<br>
Thread.sleep(1000);<br>
} catch (InterruptedException e) { }<br>
});</p>
<p>并行流不确保执行顺序，并且因为每次处理耗时 1 秒，所以可以看到在 8 核机器上，数组是按照 8 个一组 1 秒输出一次：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/d80f3aff3c751ee759ce5b675d86b26c.png" alt=""></p>
<p>在这个课程中，有很多类似使用 threadCount 个线程对某个方法总计执行 taskCount 次操作的案例，用于演示并发情况下的多线程问题或多线程处理性能。除了会用到并行流，我们有时也会使用线程池或直接使用线程进行类似操作。为了方便你对比各种实现，这里我一次性给出实现此类操作的五种方式。</p>
<p>为了测试这五种实现方式，我们设计一个场景：使用 20 个线程（threadCount）以并行方式总计执行 10000 次（taskCount）操作。因为单个任务单线程执行需要 10 毫秒（任务代码如下），也就是每秒吞吐量是 100 个操作，那 20 个线程 QPS 是 2000，执行完 10000 次操作最少耗时 5 秒。</p>
<p>private void increment(AtomicInteger atomicInteger) {<br>
atomicInteger.incrementAndGet();<br>
try {<br>
TimeUnit.MILLISECONDS.sleep(10);<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
}</p>
<p>现在我们测试一下这五种方式，是否都可以利用更多的线程并行执行操作。</p>
<p>第一种方式是使用线程。直接把任务按照线程数均匀分割，分配到不同的线程执行，使用 CountDownLatch 来阻塞主线程，直到所有线程都完成操作。这种方式，需要我们自己分割任务：</p>
<p>private int thread(int taskCount, int threadCount) throws InterruptedException {<br>
//总操作次数计数器<br>
AtomicInteger atomicInteger = new AtomicInteger();<br>
//使用 CountDownLatch 来等待所有线程执行完成<br>
CountDownLatch countDownLatch = new CountDownLatch(threadCount);<br>
//使用 IntStream 把数字直接转为 Thread<br>
IntStream.rangeClosed(1, threadCount).mapToObj(i -&gt; new Thread(() -&gt; {<br>
//手动把 taskCount 分成 taskCount 份，每一份有一个线程执行<br>
IntStream.rangeClosed(1, taskCount / threadCount).forEach(j -&gt; increment(atomicInteger));<br>
//每一个线程处理完成自己那部分数据之后，countDown 一次<br>
countDownLatch.countDown();<br>
})).forEach(Thread::start);<br>
//等到所有线程执行完成<br>
countDownLatch.await();<br>
//查询计数器当前值<br>
return atomicInteger.get();<br>
}</p>
<p>第二种方式是，使用 Executors.newFixedThreadPool 来获得固定线程数的线程池，使用 execute 提交所有任务到线程池执行，最后关闭线程池等待所有任务执行完成：</p>
<p>private int threadpool(int taskCount, int threadCount) throws InterruptedException {<br>
//总操作次数计数器<br>
AtomicInteger atomicInteger = new AtomicInteger();<br>
//初始化一个线程数量=threadCount 的线程池<br>
ExecutorService executorService = Executors.newFixedThreadPool(threadCount);<br>
//所有任务直接提交到线程池处理<br>
IntStream.rangeClosed(1, taskCount).forEach(i -&gt; executorService.execute(() -&gt; increment(atomicInteger)));<br>
//提交关闭线程池申请，等待之前所有任务执行完成<br>
executorService.shutdown();<br>
executorService.awaitTermination(1, TimeUnit.HOURS);<br>
//查询计数器当前值<br>
return atomicInteger.get();<br>
}</p>
<p>第三种方式是，使用 ForkJoinPool 而不是普通线程池执行任务。</p>
<p>ForkJoinPool 和传统的 ThreadPoolExecutor 区别在于，前者对于 n 并行度有 n 个独立队列，后者是共享队列。如果有大量执行耗时比较短的任务，ThreadPoolExecutor 的单队列就可能会成为瓶颈。这时，使用 ForkJoinPool 性能会更好。</p>
<p>因此，ForkJoinPool 更适合大任务分割成许多小任务并行执行的场景，而 ThreadPoolExecutor 适合许多独立任务并发执行的场景。</p>
<p>在这里，我们先自定义一个具有指定并行数的 ForkJoinPool，再通过这个 ForkJoinPool 并行执行操作：</p>
<p>private int forkjoin(int taskCount, int threadCount) throws InterruptedException {<br>
//总操作次数计数器<br>
AtomicInteger atomicInteger = new AtomicInteger();<br>
//自定义一个并行度=threadCount 的 ForkJoinPool<br>
ForkJoinPool forkJoinPool = new ForkJoinPool(threadCount);<br>
//所有任务直接提交到线程池处理<br>
forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, taskCount).parallel().forEach(i -&gt; increment(atomicInteger)));<br>
//提交关闭线程池申请，等待之前所有任务执行完成<br>
forkJoinPool.shutdown();<br>
forkJoinPool.awaitTermination(1, TimeUnit.HOURS);<br>
//查询计数器当前值<br>
return atomicInteger.get();<br>
}</p>
<p>第四种方式是，直接使用并行流，并行流使用公共的 ForkJoinPool，也就是 ForkJoinPool.commonPool()。</p>
<p>公共的 ForkJoinPool 默认的并行度是 CPU 核心数 -1，原因是对于 CPU 绑定的任务分配超过 CPU 个数的线程没有意义。由于并行流还会使用主线程执行任务，也会占用一个 CPU 核心，所以公共 ForkJoinPool 的并行度即使 -1 也能用满所有 CPU 核心。</p>
<p>这里，我们通过配置强制指定（增大）了并行数，但因为使用的是公共 ForkJoinPool，所以可能会存在干扰，你可以回顾下第 3 讲有关线程池混用产生的问题：</p>
<p>private int stream(int taskCount, int threadCount) {<br>
//设置公共 ForkJoinPool 的并行度<br>
System.setProperty(&ldquo;java.util.concurrent.ForkJoinPool.common.parallelism&rdquo;, String.valueOf(threadCount));<br>
//总操作次数计数器<br>
AtomicInteger atomicInteger = new AtomicInteger();<br>
//由于我们设置了公共 ForkJoinPool 的并行度，直接使用 parallel 提交任务即可<br>
IntStream.rangeClosed(1, taskCount).parallel().forEach(i -&gt; increment(atomicInteger));<br>
//查询计数器当前值<br>
return atomicInteger.get();<br>
}</p>
<p>第五种方式是，使用 CompletableFuture 来实现。CompletableFuture.runAsync 方法可以指定一个线程池，一般会在使用 CompletableFuture 的时候用到：</p>
<p>private int completableFuture(int taskCount, int threadCount) throws InterruptedException, ExecutionException {<br>
//总操作次数计数器<br>
AtomicInteger atomicInteger = new AtomicInteger();<br>
//自定义一个并行度=threadCount 的 ForkJoinPool<br>
ForkJoinPool forkJoinPool = new ForkJoinPool(threadCount);<br>
//使用 CompletableFuture.runAsync 通过指定线程池异步执行任务<br>
CompletableFuture.runAsync(() -&gt; IntStream.rangeClosed(1, taskCount).parallel().forEach(i -&gt; increment(atomicInteger)), forkJoinPool).get();<br>
//查询计数器当前值<br>
return atomicInteger.get();<br>
}</p>
<p>上面这五种方法都可以实现类似的效果：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/4f129b5ddc6fd2acfd539c44772156f0.png" alt=""></p>
<p>可以看到，这 5 种方式执行完 10000 个任务的耗时都在 5.4 秒到 6 秒之间。这里的结果只是证明并行度的设置是有效的，并不是性能比较。</p>
<p>如果你的程序对性能要求特别敏感，建议通过性能测试根据场景决定适合的模式。一般而言，使用线程池（第二种）和直接使用并行流（第四种）的方式在业务代码中比较常用。但需要注意的是，我们通常会重用线程池，而不会像 Demo 中那样在业务逻辑中直接声明新的线程池，等操作完成后再关闭。</p>
<p><strong>另外需要注意的是，在上面的例子中我们一定是先运行 stream 方法再运行 forkjoin 方法，对公共 ForkJoinPool 默认并行度的修改才能生效。</strong></p>
<p>这是因为 ForkJoinPool 类初始化公共线程池是在静态代码块里，加载类时就会进行的，如果 forkjoin 方法中先使用了 ForkJoinPool，即便 stream 方法中设置了系统属性也不会起作用。因此我的建议是，设置 ForkJoinPool 公共线程池默认并行度的操作，应该放在应用启动时设置。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>今天，我和你简单介绍了 Java 8 中最重要的几个功能，包括 Lambda 表达式、Stream 流式操作、Optional 可空对象、并行流操作。这些特性，可以帮助我们写出简单易懂、可读性更强的代码。特别是使用 Stream 的链式方法，可以用一行代码完成之前几十行代码的工作。</p>
<p>因为 Stream 的 API 非常多，使用方法也是千变万化，因此我会在下一讲和你详细介绍 Stream API 的一些使用细节。</p>
<p>今天用到的代码，我都放在了 GitHub 上，你可以点击这个链接查看。</p>
<h2 id="思考与讨论">思考与讨论</h2>
<ol>
<li>检查下代码中是否有使用匿名类，以及通过遍历 List 进行数据过滤、转换和聚合的代码，看看能否使用 Lambda 表达式和 Stream 来重新实现呢？</li>
<li>对于并行流部分的并行消费处理 1 到 100 的例子，如果把 forEach 替换为 forEachOrdered，你觉得会发生什么呢？</li>
</ol>
<p>关于 Java 8，你还有什么使用心得吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/">Java业务开发常见错误100例</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/%E5%8A%A0%E9%A4%9006__bcc%E5%85%A5%E9%97%A8ebpf%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">加餐06__BCC：入门eBPF的前端工具</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E6%95%88%E6%95%8F%E6%8D%B7%E6%B5%8B%E8%AF%9549%E8%AE%B2/%E5%8A%A0%E9%A4%901%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8Ek8%E5%92%8Cdocker%E7%9A%84jenkin%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/">
            <span class="next-text nav-default">加餐1：搭建基于K8和Docker的Jenkin可伸缩持续集成系统</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
