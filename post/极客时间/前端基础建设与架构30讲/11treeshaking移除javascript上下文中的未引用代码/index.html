<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>11TreeShaking：移除JavaScript上下文中的未引用代码 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="时至今日，Tree Shaking 对于前端工程师来说，已经不是一个陌生的名词了。顾名思义：Tree Shaking 译为“摇树”，它通常用于描述移除 JavaScript 上下文中的未引用代码（dead-code）。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%9E%B6%E6%9E%8430%E8%AE%B2/11treeshaking%E7%A7%BB%E9%99%A4javascript%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%9A%84%E6%9C%AA%E5%BC%95%E7%94%A8%E4%BB%A3%E7%A0%81/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%9E%B6%E6%9E%8430%E8%AE%B2/11treeshaking%E7%A7%BB%E9%99%A4javascript%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%9A%84%E6%9C%AA%E5%BC%95%E7%94%A8%E4%BB%A3%E7%A0%81/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="11TreeShaking：移除JavaScript上下文中的未引用代码">
  <meta property="og:description" content="时至今日，Tree Shaking 对于前端工程师来说，已经不是一个陌生的名词了。顾名思义：Tree Shaking 译为“摇树”，它通常用于描述移除 JavaScript 上下文中的未引用代码（dead-code）。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="前端基础建设与架构30讲">

  <meta itemprop="name" content="11TreeShaking：移除JavaScript上下文中的未引用代码">
  <meta itemprop="description" content="时至今日，Tree Shaking 对于前端工程师来说，已经不是一个陌生的名词了。顾名思义：Tree Shaking 译为“摇树”，它通常用于描述移除 JavaScript 上下文中的未引用代码（dead-code）。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5152">
  <meta itemprop="keywords" content="前端基础建设与架构30讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="11TreeShaking：移除JavaScript上下文中的未引用代码">
  <meta name="twitter:description" content="时至今日，Tree Shaking 对于前端工程师来说，已经不是一个陌生的名词了。顾名思义：Tree Shaking 译为“摇树”，它通常用于描述移除 JavaScript 上下文中的未引用代码（dead-code）。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">11TreeShaking：移除JavaScript上下文中的未引用代码</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5152 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>时至今日，Tree Shaking 对于前端工程师来说，已经不是一个陌生的名词了。顾名思义：Tree Shaking 译为“摇树”，它通常用于描述移除 JavaScript 上下文中的未引用代码（dead-code）。</p>
<p>据我观察，Tree Shaking 也经常出现在诸多候选人的简历当中。然而可惜的是，大部分候选人都知道 Tree Shaking 的定义，但“知其然不知其所以然”，并没有在工程中真正实践过 Tree Shaking 技术，更没有深入理解 Tree Shaking 这个概念。社区上一些好的文章，比如《你的 Tree-Shaking 并没什么卵用》发布于 2018 年初，但就目前来看，其中内容也有些“过期”了。</p>
<p>这一节，就让我们真正深入学习 Tree Shaking 这个概念。</p>
<p>Tree Shaking 必备理论</p>
<p>Tree Shaking 概念很好理解，这个词最先在 Rollup 社区流行，后续蔓延到整个前端生态。Tree Shaking 背后的理论知识独成体系，我们先从其原理入手，试着分析并回答以下问题。</p>
<p>问题一：Tree Shaking 为什么要依赖 ESM 规范？</p>
<p>事实上，Tree Shaking 是在编译时进行无用代码消除的，因此它需要在编译时确定依赖关系，进而确定哪些代码可以被“摇掉”，而 ESM 具备以下特点：</p>
<p>import 模块名只能是字符串常量</p>
<p>import 一般只能在模块的最顶层出现</p>
<p>import binding 是 immutable 的</p>
<p>这些特点使得 ESM 具有静态分析能力。而CommonJS 定义的模块化规范，只有在执行代码后，才能动态确定依赖模块，因此不具备 Tree Shaking 的先天条件。</p>
<p>在传统编译型语言中，一般由编译器将无用代码在 AST（抽象语法树）中删除，而前端 JavaScript 并没有正统“编译器”这个概念，那么 Tree Shaking 就需要在工程链中由工程化工具完成。</p>
<p>问题二：什么是副作用模块，如何对副作用模块进行 Tree Shaking?</p>
<p>如果你熟悉函数式开发理念，可能听说过“副作用函数”，但什么是“副作用模块”呢？它又和 Tree Shaking 有什么关联呢？很多人清楚的 Tree Shaking 只是皮毛，而并不清楚 Tree Shaking 并不能“摇掉”副作用模块，具体我们看这样一段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">export</span> <span class="n">function</span> <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">export</span> <span class="k">const</span> <span class="n">memoizedAdd</span> <span class="o">=</span> <span class="n">window</span><span class="o">.</span><span class="n">memoize</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当该模块被 import 时，
window.memoize
方法会被执行，那么对于工程化工具（比如 Webpack）来说，分析思路是这样的：</p>
<p>创建一个纯函数
add
，如果没有其他模块引用
add
函数，那么
add
函数可以被 Tree Shaking 掉；</p>
<p>接着调用
window.memoize
方法，并传入
add
函数作为其参数；</p>
<p>工程化工具（比如 Webpack）并不知道
window.memoize
方法会做什么事情，也许
window.memoize
方法会调用
add
函数，并触发某些副作用（比如维护一个全局的 Cache Map）；</p>
<p>工程化工具（比如 Webpack）为了安全起见，即便没有其他模块依赖的
add
函数，那么也要将
add
函数打包到最后的 bundle 中。</p>
<p>因此，具有副作用的模块难以被 Tree Shaking 优化，即便开发者知道
window.memoize
方法是无副作用的。</p>
<p>为了解决“具有副作用的模块难以被 Tree Shaking 优化”这个问题，Webpack 给出了自己的方案，我们可以利用 package.json 的
sideEffects
属性来告诉工程化工具哪些模块具有副作用，哪些剩余模块没有副作用，可以被 Tree Shaking 优化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;name&#34;: &#34;your-project&#34;,
</span></span><span class="line"><span class="cl">  &#34;sideEffects&#34;: false
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>表示全部代码均无副作用，告知 webpack，它可以安全地删除未用到的 export 导出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;name&#34;: &#34;your-project&#34;,
</span></span><span class="line"><span class="cl">  &#34;sideEffects&#34;: [
</span></span><span class="line"><span class="cl">    &#34;./src/some-side-effectful-file.js&#34;，
</span></span><span class="line"><span class="cl">    &#34;*.css&#34;
</span></span><span class="line"><span class="cl">  ]
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过数组表示，
./src/some-side-effectful-file.js
和所有
.css
文件模块都有副作用。对于 Webpack 工具，开发者可以在module.rule配置中声明副作用模块。</p>
<p>事实上，仅对上面
add
函数，即便不通过声明 sideEffects，Webpack 也足够智能，能够分析出可 Tree Shaking 掉的部分，不过这需要我们对上述代码进行重构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">import</span> <span class="p">{</span> <span class="n">memoize</span> <span class="p">}</span> <span class="n">from</span> <span class="s1">&#39;./util&#39;</span>
</span></span><span class="line"><span class="cl"><span class="k">export</span> <span class="n">function</span> <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">export</span> <span class="k">const</span> <span class="n">memoizedAdd</span> <span class="o">=</span> <span class="n">memoize</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时 Webpack 的分析逻辑：</p>
<p>memoize
函数是一个 ESM 模块，我们去
util.js
中检查一下
memoize
函数内容；</p>
<p>在
util.js
中，发现
memoize
函数是一个纯函数，因此如果
add
函数没有被其他模块依赖，可以被安全 Tree Shaking 掉。</p>
<p>所以，我们能得出一个 Tree Shaking 友好的最佳实践——在业务项目中，设置最小化副作用范围，同时通过合理的配置，给工程化工具最多的副作用信息。</p>
<p>下面，我们再来看一个 Tree Shaking 友好的实践案例。</p>
<p>一个 Tree Shaking 友好的导出模式</p>
<p>参考以下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">export</span> <span class="n">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">subtract</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>以及：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">export</span> <span class="k">class</span> <span class="n">Number</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">constructor</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">this</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">num</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">add</span><span class="p">(</span><span class="n">otherNum</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">num</span> <span class="o">+</span> <span class="n">otherNum</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">subtract</span><span class="p">(</span><span class="n">otherNum</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">num</span> <span class="o">-</span> <span class="n">otherNum</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于上述情况，以 Webpack 为例，Webpack 将会趋向保留整个默认导出对象/class（Webpack 和 Rollup 只处理函数和顶层的 import/export 变量，不能把没用到的类或对象内部的方法消除掉）。</p>
<p>因此：</p>
<p>导出一个包含多项属性和方法的对象</p>
<p>导出一个包含多项属性和方法的 class</p>
<p>使用
export default
导出</p>
<p>都不利于 Tree Shaking。即便现代化工程工具或 Webpack 支持对于对象或 class 的方法属性剪裁（比如 webpack-deep-scope-plugin 这个插件的设计，或 Webpack 和 Rollup 新版本的跟进），这些都产生了不必要的成本，增加了编译时负担。</p>
<p>我们更加推荐的原则是：原子化和颗粒化导出。如下代码，就是一个更好的实践：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">export</span> <span class="n">function</span> <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">export</span> <span class="n">function</span> <span class="n">subtract</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种方式可以让 Webpack 更好地在编译时掌控和分析 Tree Shaking 信息，取得一个更优的 bundle size。</p>
<p>前端工程生态和 Tree Shaking 实践</p>
<p>通过上述内容，我们可以看出 Tree Shaking 依托于 ESM 静态分析的理论技术，而真正的 Tree Shaking 过程，还需要依靠前端工程工具实现。Tree Shaking 链路当然也就和前端工程生态绑定在一起，我们继续从工程生态层面，分析 Tree Shaking 实践。</p>
<p>Babel 和 Tree Shaking</p>
<p>Babel 已经成为现代化工程和基建方案的必备工具，但是考虑到 Tree Shaking，需要开发者注意：如果使用 Babel 对代码进行编译，Babel 默认会将 ESM 编译为 CommonJS 模块规范。而我们从前面理论知识知道，Tree Shaking 必须依托于 ESM。</p>
<p>为此，我们需要配置 Babel 对于模块化的编译降级，具体配置项在 babel-preset-env#modules 中可以找到。</p>
<p>但既然是“前端工程生态”，那问题就没这么好解决。事实上，如果我们不使用 Babel 将代码编译为 CommonJS 规范的代码，某些工程链上的工具可能就要罢工了。比如 Jest，Jest 是基于 Node.js 开发的，运行在 Node.js 环境。因此使用 Jest 进行测试时，也就需要模块符合 CommonJS 规范，那么如何处理这种“模块死锁”呢？</p>
<p>思路之一是根据不同的环境，采用不同的 Babel 配置。在 production 编译环境中，我们配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">production: {
</span></span><span class="line"><span class="cl">   presets: [
</span></span><span class="line"><span class="cl">    [
</span></span><span class="line"><span class="cl">     &#39;@babel/preset-env&#39;,
</span></span><span class="line"><span class="cl">     {
</span></span><span class="line"><span class="cl">      modules: false
</span></span><span class="line"><span class="cl">     }
</span></span><span class="line"><span class="cl">    ]
</span></span><span class="line"><span class="cl">   ]
</span></span><span class="line"><span class="cl">  },
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在测试环境中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">test: {
</span></span><span class="line"><span class="cl">   presets: [
</span></span><span class="line"><span class="cl">    [
</span></span><span class="line"><span class="cl">     &#39;@babel/preset-env&#39;,
</span></span><span class="line"><span class="cl">     {
</span></span><span class="line"><span class="cl">      modules: &#39;commonjs
</span></span><span class="line"><span class="cl">     }
</span></span><span class="line"><span class="cl">    ]
</span></span><span class="line"><span class="cl">   ]
</span></span><span class="line"><span class="cl">  },
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是在测试环境中，编译了业务代码为 CommonJS 规范并没有大功告成，我们还需要处理第三方模块代码。一些第三方模块代码为了方便进行 Tree Shaking，暴露出符合 ESM 模块的代码，对于这些模块，比如 Library1、Library2，我们还需要进行处理，这时候需要配置 Jest：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">path</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">librariesToRecompile</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl"> <span class="s1">&#39;Library1&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="s1">&#39;Library2&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">transformIgnorePatterns</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">  <span class="err">`</span><span class="p">[</span>\\<span class="o">/</span><span class="p">]</span><span class="n">node_modules</span><span class="p">[</span>\\<span class="o">/</span><span class="p">](</span><span class="err">?</span><span class="o">!</span><span class="p">(</span><span class="o">$</span><span class="p">{</span><span class="n">librariesToRecompile</span><span class="p">}))</span><span class="o">.*$</span><span class="err">`</span>
</span></span><span class="line"><span class="cl"> <span class="p">],</span>
</span></span><span class="line"><span class="cl"> <span class="n">transform</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;^.+\.jsx?$&#39;</span><span class="p">:</span> <span class="n">path</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">__dirname</span><span class="p">,</span> <span class="s1">&#39;transformer.js&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>transformIgnorePatterns
是 Jest 的一个配置项，默认值为
node_modules
，它表示：
node_modules
中的第三方模块代码，都不需要经过
babel-jest
编译。因此，我们自定义
transformIgnorePatterns
的值为一个包含了 Library1、Library2 的正则表达式即可。</p>
<p>Webpack 和 Tree Shaking</p>
<p>上面我们已经讲解了很多关于 Webpack 处理 Tree Shaking 的内容了，这里我们进一步补充。事实上，Webpack4.0 以上版本在 mode 为 production 时，会自动开启 Tree Shaking 能力。默认 production mode 的配置如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">mode</span><span class="p">:</span> <span class="s1">&#39;production&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="n">optimization</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">usedExports</span><span class="p">:</span> <span class="bp">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">minimizer</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">   <span class="n">new</span> <span class="n">TerserPlugin</span><span class="p">({</span><span class="o">...</span><span class="p">})</span> <span class="o">//</span> <span class="err">支持删除死代码的压缩器</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其实，Webpack 真正执行模块去除，是依赖了 TerserPlugin、UglifyJS 等压缩插件。Webpack 负责对模块进行分析和标记，而这些压缩插件负责根据标记结果，进行代码删除。Webpack 在分析时，有三类相关的标记：</p>
<p>harmony export，被使用过的 export 会被标记为 harmony export；</p>
<p>unused harmony export，没被使用过的 export 标记为 unused harmony export；</p>
<p>harmony import，所有 import 标记为 harmony import。</p>
<p>上述标记实现的 Webpack 源码在
lib/dependencies/
文件中，这里不再进行源码解读了。具体过程主要是：</p>
<p>Webpack 在编译分析阶段，将每一个模块放入 ModuleGraph 中维护；</p>
<p>依靠 HarmonyExportSpecifierDependency 和 HarmonyImportSpecifierDependency 分别识别和处理 import 以及 export；</p>
<p>依靠 HarmonyExportSpecifierDependency 识别 used export 和 unused export。</p>
<p>至此，我们理解了使用 Webpack 进行 Tree Shaking 的原理。接下来，我们再看看著名的公共库都是如何处理 Tree Shaking 的。</p>
<p>Vue 和 Tree Shaking</p>
<p>在 Vue 2.0 版本中，Vue 对象会存在一些全局 API，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">import Vue from &#39;vue&#39;
</span></span><span class="line"><span class="cl">Vue.nextTick(() =&gt; {
</span></span><span class="line"><span class="cl">  //...
</span></span><span class="line"><span class="cl">})
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们没有使用
Vue.nextTick
方法，那么
nextTick
这样的全局 API 就成了 dead code，且不容易被 Tree Shaking 掉。为此，在 Vue 3 中，Vue 团队考虑了 Tree Shaking 兼容，进行了重构，全局 API 需要通过原生 ES Module 的引用方式进行具名引用，对应前面的代码，需要：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">import { nextTick } from &#39;vue&#39;
</span></span><span class="line"><span class="cl">nextTick(() =&gt; {
</span></span><span class="line"><span class="cl">  //...
</span></span><span class="line"><span class="cl">})
</span></span></code></pre></td></tr></table>
</div>
</div><p>除了这些全局 API ，Vue 3.0 也实现了很多内置的组件以及工具的具名导出。这些都是前端生态中，公共库拥抱 Tree Shaking 的表现。</p>
<p>此外，我们也可以灵活使用 build-time flags 来帮助构建工具实现 Tree Shaking。以 WebpackDefinePlugin 为例，下面代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">import { validateoptions } from &#39;./validation&#39;
</span></span><span class="line"><span class="cl">function init(options) {
</span></span><span class="line"><span class="cl">	if (!__PRODUCTION__) {
</span></span><span class="line"><span class="cl">		validateoptions(options)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过
<strong>PRODUCTION</strong>
变量，在 production 环境下，我们可以将
validateoptions
函数进行删除。</p>
<p>如何设计一个兼顾 Tree Shaking 和易用性的公共库</p>
<p>上面我们分析了 Vue 拥抱 Tree Shaking 的例子，下面我们应该从另一个更宏观的角度看待这个问题。作为一个公共库的设计者，我们应该如何兼顾 Tree Shaking 和易用性的公共库呢？</p>
<p>试想，如果我们以 ESM 的方式对外暴露代码，那么就很难直接兼容 CommonJS 规范，也就是说在 Node.js 环境中，使用者如果直接以 require 方式引用的话，就会得到报错。如果以 CommonJS 规范对外暴露代码，又不利于 Tree Shaking。</p>
<p>因此，如果想要一个 npm 包既能向外提供 ESM 规范的代码，又能向外提供 CommonJS 规范的代码，我们就只能通过“协约”来定义清楚。实际上，npm
package.json
以及社区工程化规范，解决了这个问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;name&#34;: &#34;Library&#34;,
</span></span><span class="line"><span class="cl">  &#34;main&#34;: &#34;dist/index.cjs.js&#34;,
</span></span><span class="line"><span class="cl">  &#34;module&#34;: &#34;dist/index.esm.js&#34;,
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>其实，标准 package.json 语法中，只有一个入口
main
。作为公共库设计者，我们通过
main
来暴露 CommonJS 规范打包的代码
dist/index.cjs.js
；在 Webpack 等构建工具中，又支持了
module
——这个新的入口字段。因此，
module
并非 package.json 的标准字段，而是打包工具专用的字段，用来指定符合 ESM 标准的入口文件。</p>
<p>这样一来，当
require(&lsquo;Library&rsquo;)
时，Webpack 会找到：
dist/index.cjs.js
；当
import Library from &lsquo;Library&rsquo;
时，Webpack 会找到：
dist/index.esm.js
。</p>
<p>这里我们不妨举一个著名的公共库例子，那就是 Lodash。Lodash 其实并不支持 Tree Shaking，其
package.json
：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;name&#34;: &#34;lodash&#34;,
</span></span><span class="line"><span class="cl">  &#34;version&#34;: &#34;5.0.0&#34;,
</span></span><span class="line"><span class="cl">  &#34;license&#34;: &#34;MIT&#34;,
</span></span><span class="line"><span class="cl">  &#34;private&#34;: true,
</span></span><span class="line"><span class="cl">  &#34;main&#34;: &#34;lodash.js&#34;,
</span></span><span class="line"><span class="cl">  &#34;engines&#34;: {
</span></span><span class="line"><span class="cl">    &#34;node&#34;: &#34;&gt;=4.0.0&#34;
</span></span><span class="line"><span class="cl">  },
</span></span><span class="line"><span class="cl">  //...
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>只有一个
main
入口，且
lodash.js
是 UMD 形式的代码，不利于做到 Tree Shaking。为了支持 Tree shakibng，lodash 打包出来专门的 lodash-es，其
package.json
：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;main&#34;: &#34;lodash.js&#34;,
</span></span><span class="line"><span class="cl">  &#34;module&#34;: &#34;lodash.js&#34;,
</span></span><span class="line"><span class="cl">  &#34;name&#34;: &#34;lodash-es&#34;,
</span></span><span class="line"><span class="cl">  &#34;sideEffects&#34;: false,
</span></span><span class="line"><span class="cl">  //...
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>由上述代码可知，lodash-es
main
、
module
、
sideEffects
三字段齐全，通过 ESM 导出，天然支持了 Tree Shaking。</p>
<p>总之，万变不离其宗，只要我们掌握了 Tree Shaking 的原理，那么在涉及公共库时，就能做到游刃有余，以各种形式支持到 Tree Shaking。当然，普遍做法是在第三方库打包构建时，参考 antd，一般都会构建出 lib/ 和 es/ 两个文件夹，并配置
package.json
的
main
、
module
字段即可。</p>
<p>CSS 和 Tree Shaking</p>
<p>以上内容都是针对 JavaScript 代码的 Tree Shaking，作为前端工程师，我们当然也要考虑对 CSS 文件做 Tree Shaking。</p>
<p>实现思路也很简单，CSS 的 Tree Shaking 要在样式表中，找出没有被应用到选择器样式，进行删除。那么我们只需要：</p>
<p>遍历所有 CSS 文件的选择器；</p>
<p>根据所有 CSS 文件的选择器，在 JavaScript 代码中进行选择器匹配；</p>
<p>如果没有匹配到，则删除对应选择器的样式代码。</p>
<p>如何遍历所有 CSS 文件的选择器呢？Babel 依靠 AST 技术，完成了对 JavaScript 代码的遍历分析，而在样式世界中，PostCSS 就起到了 Babel 的作用。PostCSS 提供了一个解析器，它能够将 CSS 解析成 AST 抽象语法树，我们可以通过 PostCSS 插件对 CSS 对应的 AST 进行操作，达到 Tree Shaking 的目的。</p>
<p>PostCSS 原理如下图：</p>
<p>PostCSS 原理图</p>
<p>这里给大家推荐 purgecss-webpack-plugin，其原理也很简单：</p>
<p>监听 Webpack compilation 完成阶段，从 compilation 中找到所有的 CSS 文件（对应源码）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">export</span> <span class="n">default</span> <span class="k">class</span> <span class="n">PurgeCSSPlugin</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">options</span><span class="p">:</span> <span class="n">UserDefinedOptions</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">purgedStats</span><span class="p">:</span> <span class="n">PurgedStats</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="n">constructor</span><span class="p">(</span><span class="n">options</span><span class="p">:</span> <span class="n">UserDefinedOptions</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">this</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">apply</span><span class="p">(</span><span class="n">compiler</span><span class="p">:</span> <span class="n">Compiler</span><span class="p">):</span> <span class="n">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">compiler</span><span class="o">.</span><span class="n">hooks</span><span class="o">.</span><span class="n">compilation</span><span class="o">.</span><span class="n">tap</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">pluginName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">this</span><span class="o">.</span><span class="n">initializePlugin</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="o">//...</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将所有的 CSS 文件交给 PostCss 处理（源码关键部分，对 CSS AST 应用规则）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public walkThroughCSS(
</span></span><span class="line"><span class="cl">    root: postcss.Root,
</span></span><span class="line"><span class="cl">    selectors: ExtractorResultSets
</span></span><span class="line"><span class="cl">  ): void {
</span></span><span class="line"><span class="cl">    root.walk((node) =&gt; {
</span></span><span class="line"><span class="cl">      if (node.type === &#34;rule&#34;) {
</span></span><span class="line"><span class="cl">        return this.evaluateRule(node, selectors);
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      if (node.type === &#34;atrule&#34;) {
</span></span><span class="line"><span class="cl">        return this.evaluateAtRule(node);
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      if (node.type === &#34;comment&#34;) {
</span></span><span class="line"><span class="cl">        if (isIgnoreAnnotation(node, &#34;start&#34;)) {
</span></span><span class="line"><span class="cl">          this.ignore = true;
</span></span><span class="line"><span class="cl">          // remove ignore annotation
</span></span><span class="line"><span class="cl">          node.remove();
</span></span><span class="line"><span class="cl">        } else if (isIgnoreAnnotation(node, &#34;end&#34;)) {
</span></span><span class="line"><span class="cl">          this.ignore = false;
</span></span><span class="line"><span class="cl">          // remove ignore annotation
</span></span><span class="line"><span class="cl">          node.remove();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">    });
</span></span><span class="line"><span class="cl">  }
</span></span></code></pre></td></tr></table>
</div>
</div><p>利用 PostCss 插件能力，基于 AST 技术，找出无用代码并进行删除。</p>
<p>核心删除未使用 CSS 代码的逻辑在
purge
方法中，这里我们不再展开。</p>
<p>总结</p>
<p>本小节，我们分析了 Tree Shaking 相关知识，我们发现这一理论内容还需要配合构建工具完成落地，而这一系列过程不只是想象中那样简单。</p>
<p>这里我想给你留一个思考题，Rollup 是如何实现 Tree Shaking 的呢？欢迎在留言区和我分享你的观点。</p>
<p>更多内容，我们会结合下一讲“如何理解 AST 实现和编译原理？”，带你实现一个真实的 AST 的落地场景，完成一个简易版 Tree Shaking 实现。我们下一讲再见！</p>
<p>-&ndash; ### 精选评论 ##### **铭： &gt; 写的很好 ##### **7269： &gt; 那个裁剪css的插件，我们业务中很多动态class，貌似只能配置白名单了 ##### *萱： &gt; 有些html中的css类是js动态生成的，那岂不是把一些css给摇树掉了？ ######     讲师回复： &gt;     不会，会根据 js 进行分析 ##### **3336： &gt; 是不是UMD模块代码做不到TreeShaking？ ######     讲师回复： &gt;     是 ##### *威： &gt; import现在不一定在最顶层鸭 ######     讲师回复： &gt;     static import vs dynamic import ##### **平： &gt; 问一下，如果项目里有一个包不支持 Tree Shaking，那打包时整个项目时，除了这个不支持的包以为，其他包都是用Tree Shaking打包吗？ ######     讲师回复： &gt;     是，但得看你配置和实现</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%9E%B6%E6%9E%8430%E8%AE%B2/">前端基础建设与架构30讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kubernetes%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/11k8service%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">11K8Service：轻松搞定服务发现和负载均衡</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/11webflux%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%9C%8D%E5%8A%A1/">
            <span class="next-text nav-default">11WebFlux（下）：如何使用函数式编程模型构建异步非阻塞服务？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
