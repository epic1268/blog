<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>21如何利用JavaScript实现经典数据结构？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="前面几讲我们从编程思维的角度分析了软件设计哲学。从这一讲开始，我们将深入数据结构这个话题。
数据结构是计算机中组织和存储数据的特定方式，它的目的是方便且高效地对数据进行访问和修改。数据结构体现了数据之间的关系，以及操作数据的一系列方法。数据又是程序的基本单元，因此无论哪种语言、哪种领域，都离不开数据结构；另一方面，数据结构是算法的基础，其本身也包含了算法的部分内容。也就是说，想要掌握算法，有一个坚固的数据结构基础是必要条件。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%9E%B6%E6%9E%8430%E8%AE%B2/21%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8javascript%E5%AE%9E%E7%8E%B0%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%9E%B6%E6%9E%8430%E8%AE%B2/21%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8javascript%E5%AE%9E%E7%8E%B0%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="21如何利用JavaScript实现经典数据结构？">
  <meta property="og:description" content="前面几讲我们从编程思维的角度分析了软件设计哲学。从这一讲开始，我们将深入数据结构这个话题。
数据结构是计算机中组织和存储数据的特定方式，它的目的是方便且高效地对数据进行访问和修改。数据结构体现了数据之间的关系，以及操作数据的一系列方法。数据又是程序的基本单元，因此无论哪种语言、哪种领域，都离不开数据结构；另一方面，数据结构是算法的基础，其本身也包含了算法的部分内容。也就是说，想要掌握算法，有一个坚固的数据结构基础是必要条件。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="前端基础建设与架构30讲">

  <meta itemprop="name" content="21如何利用JavaScript实现经典数据结构？">
  <meta itemprop="description" content="前面几讲我们从编程思维的角度分析了软件设计哲学。从这一讲开始，我们将深入数据结构这个话题。
数据结构是计算机中组织和存储数据的特定方式，它的目的是方便且高效地对数据进行访问和修改。数据结构体现了数据之间的关系，以及操作数据的一系列方法。数据又是程序的基本单元，因此无论哪种语言、哪种领域，都离不开数据结构；另一方面，数据结构是算法的基础，其本身也包含了算法的部分内容。也就是说，想要掌握算法，有一个坚固的数据结构基础是必要条件。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6222">
  <meta itemprop="keywords" content="前端基础建设与架构30讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="21如何利用JavaScript实现经典数据结构？">
  <meta name="twitter:description" content="前面几讲我们从编程思维的角度分析了软件设计哲学。从这一讲开始，我们将深入数据结构这个话题。
数据结构是计算机中组织和存储数据的特定方式，它的目的是方便且高效地对数据进行访问和修改。数据结构体现了数据之间的关系，以及操作数据的一系列方法。数据又是程序的基本单元，因此无论哪种语言、哪种领域，都离不开数据结构；另一方面，数据结构是算法的基础，其本身也包含了算法的部分内容。也就是说，想要掌握算法，有一个坚固的数据结构基础是必要条件。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">21如何利用JavaScript实现经典数据结构？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6222 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>前面几讲我们从编程思维的角度分析了软件设计哲学。从这一讲开始，我们将深入数据结构这个话题。</p>
<p>数据结构是计算机中组织和存储数据的特定方式，它的目的是方便且高效地对数据进行访问和修改。数据结构体现了数据之间的关系，以及操作数据的一系列方法。数据又是程序的基本单元，因此无论哪种语言、哪种领域，都离不开数据结构；另一方面，数据结构是算法的基础，其本身也包含了算法的部分内容。也就是说，想要掌握算法，有一个坚固的数据结构基础是必要条件。</p>
<p>下面我们用 JavaScript 实现几个常见的数据结构。</p>
<p>数据结构介绍</p>
<p>我通常将数据结构分为八大类。</p>
<p>数组：Array</p>
<p>堆栈：Stack</p>
<p>队列：Queue</p>
<p>链表：Linked Lists</p>
<p>树：Trees</p>
<p>图：Graphs</p>
<p>字典树：Trie</p>
<p>散列表（哈希表）：Hash Tables</p>
<p>我们可以先大体感知一下各种数据结构之间的关系：</p>
<p>栈和队列是类似数组的结构，非常多的初级题目要求用数组实现栈和队列，它们在插入和删除的方式上和数组有所差异，但是实现还是非常简单的；</p>
<p>链表、树和图这种数据结构的特点是，其节点需要引用其他节点，因此在增/删时，需要注意对相关前驱和后继节点的影响；</p>
<p>可以从堆栈和队列出发，构建出链表；</p>
<p>树和图最为复杂，但它们本质上扩展了链表的概念；</p>
<p>散列表的关键是理解散列函数，明白依赖散列函数实现保存和定位数据的过程；</p>
<p>直观上认为，链表适合记录和存储数据；哈希表和字典树在检索数据以及搜索方面有更大的应用场景。</p>
<p>以上这些“直观感性”的认知并不是“恒等式”，我们将在下面的学习中去印证这些“认知”，这两讲中，你将会看到熟悉的 React、Vue 框架的部分实现，将会看到典型的算法场景，也请你做好相关基础知识的储备。</p>
<p>堆栈和队列</p>
<p>栈和队列是一种操作受限的线性结构，它们非常简单，虽然 JavaScript 并没有原生内置这样的数据结构，但是我们可以轻松地模拟出来。</p>
<p>栈的实现，后进先出 LIFO（Last in、First out）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Stack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">constructor</span><span class="p">(</span><span class="o">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  	 <span class="o">//</span> <span class="err">使用数组进行模拟</span>
</span></span><span class="line"><span class="cl">    <span class="n">this</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="n">args</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">push</span><span class="p">(</span><span class="o">...</span><span class="n">items</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  	 <span class="o">//</span> <span class="err">入栈</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">...</span> <span class="n">items</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  	<span class="o">//</span> <span class="err">出栈，从数组尾部弹出一项</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">peek</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">        <span class="err">?</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl">        <span class="p">:</span> <span class="n">this</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="n">this</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">isEmpty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">size</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">length</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>队列的实现，先进先出 FIFO（First in、First out），“比葫芦画瓢”即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Queue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">constructor</span><span class="p">(</span><span class="o">...</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  	 <span class="o">//</span> <span class="err">使用数组进行模拟</span>
</span></span><span class="line"><span class="cl">    <span class="n">this</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="n">args</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">enqueue</span><span class="p">(</span><span class="o">...</span><span class="n">items</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">入队</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">...</span> <span class="n">items</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">dequeue</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">出队</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">shift</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">front</span><span class="p">()</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="err">?</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl">        <span class="p">:</span> <span class="n">this</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">back</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="err">?</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl">        <span class="p">:</span> <span class="n">this</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="n">this</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">isEmpty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">size</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">length</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以看到不管是栈还是队列，都是用数组进行模拟的。数组是最基本的数据结构，但是它的价值是惊人的。我们会在下一讲，进一步介绍栈和队列的应用场景。</p>
<p>链表（单向链表和双向链表）</p>
<p>堆栈和队列都可以利用数组实现，链表和数组一样，也实现了按照一定的顺序存储元素，不同的地方在于链表不能像数组一样通过下标访问，而是每一个元素都能够通过“指针”指向下一个元素。我们可以直观地得出结论：链表不需要一段连续的存储空间，“指向下一个元素”的方式能够更大限度地利用内存。</p>
<p>根据上述内容，我们可以总结出链表的优点在于：</p>
<p>链表的插入和删除操作的时间复杂度是常数级的，我们只需要改变相关节点的指针指向即可；</p>
<p>链表可以像数组一样顺序访问，查找元素的时间复杂度是线性的。</p>
<p>要想实现链表，我们需要先对链表进行分类，常见的有单链表和双向链表。</p>
<p>单链表：单链表是维护一系列节点的数据结构，其特点是：每个节点包含了数据，同时包含指向链表中下一个节点的指针。</p>
<p>双向链表：不同于单链表，双向链表特点：每个节点分支除了包含其数据以外，还包含了分别指向其前驱和后继节点的指针。</p>
<p>首先，根据双向链表的特点，我们实现一个节点构造函数（节点类），如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="ne">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">constructor</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="n">data</span> <span class="err">为当前节点储存的数据</span>
</span></span><span class="line"><span class="cl">        <span class="n">this</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="n">next</span> <span class="err">指向下一个节点</span>
</span></span><span class="line"><span class="cl">        <span class="n">this</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">null</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="n">prev</span> <span class="err">指向前一个节点</span>
</span></span><span class="line"><span class="cl">        <span class="n">this</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">null</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>有了节点类，我们来初步实现双向链表类，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">DoublyLinkedList</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">双向链表开头</span>
</span></span><span class="line"><span class="cl">        <span class="n">this</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">null</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">双向链表结尾</span>
</span></span><span class="line"><span class="cl">      	 <span class="n">this</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">null</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，需要实现双向链表原型上的一些方法，这些方法包括以下几种。</p>
<p>add：在链表尾部添加一个新的节点，实现如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">add(item) {
</span></span><span class="line"><span class="cl">  // 实例化一个节点
</span></span><span class="line"><span class="cl">  let node = new Node(item)
</span></span><span class="line"><span class="cl">  // 如果当前链表还没有头
</span></span><span class="line"><span class="cl">  if(!this.head) {
</span></span><span class="line"><span class="cl">    this.head = node
</span></span><span class="line"><span class="cl">    this.tail = node
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  // 如果当前链表已经有了头，只需要在尾部加上该节点
</span></span><span class="line"><span class="cl">  else {
</span></span><span class="line"><span class="cl">    // 把当前的尾部作为新节点的 prev
</span></span><span class="line"><span class="cl">    node.prev = this.tail
</span></span><span class="line"><span class="cl">    // 把当前的尾部的 next 指向为新节点 node
</span></span><span class="line"><span class="cl">    this.tail.next = node
</span></span><span class="line"><span class="cl">    this.tail = node
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>addAt：在链表指定位置添加一个新的节点，实现如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">addAt(index, item) {
</span></span><span class="line"><span class="cl">   let current = this.head
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">   // 维护查找时当前节点的索引
</span></span><span class="line"><span class="cl">   let counter = 1
</span></span><span class="line"><span class="cl">   let node = new Node(item)
</span></span><span class="line"><span class="cl">   // 如果在头部插入
</span></span><span class="line"><span class="cl">   if (index === 0) {
</span></span><span class="line"><span class="cl">     this.head.prev = node
</span></span><span class="line"><span class="cl">     node.next = this.head
</span></span><span class="line"><span class="cl">     this.head = node
</span></span><span class="line"><span class="cl">   } 
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">   // 非头部插入，需要从头开始，找寻插入位置
</span></span><span class="line"><span class="cl">   else {
</span></span><span class="line"><span class="cl">     while(current) {
</span></span><span class="line"><span class="cl">      current = current.next
</span></span><span class="line"><span class="cl">      if( counter === index) {
</span></span><span class="line"><span class="cl">        node.prev = current.prev
</span></span><span class="line"><span class="cl">        current.prev.next = node
</span></span><span class="line"><span class="cl">        node.next = current
</span></span><span class="line"><span class="cl">        current.prev = node
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      counter++
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>remove：删除链表指定数据项节点，实现如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">remove(item) {
</span></span><span class="line"><span class="cl">  let current = this.head
</span></span><span class="line"><span class="cl">  while (current) {
</span></span><span class="line"><span class="cl">       // 找到了目标节点
</span></span><span class="line"><span class="cl">    if (current.data === item ) {
</span></span><span class="line"><span class="cl">      // 目标链表只有当前目标项，即目标节点即是链表头又是链表尾
</span></span><span class="line"><span class="cl">      if (current == this.head &amp;&amp; current == this.tail) {
</span></span><span class="line"><span class="cl">        this.head = null
</span></span><span class="line"><span class="cl">        this.tail = null
</span></span><span class="line"><span class="cl">      } 
</span></span><span class="line"><span class="cl">      // 目标节点为链表头
</span></span><span class="line"><span class="cl">      else if (current == this.head ) {
</span></span><span class="line"><span class="cl">        this.head = this.head.next
</span></span><span class="line"><span class="cl">        this.head.prev = null
</span></span><span class="line"><span class="cl">      } 
</span></span><span class="line"><span class="cl">      // 目标节点为链表尾部
</span></span><span class="line"><span class="cl">      else if (current == this.tail ) {
</span></span><span class="line"><span class="cl">        this.tail = this.tail.prev;
</span></span><span class="line"><span class="cl">        this.tail.next = null;
</span></span><span class="line"><span class="cl">      } 
</span></span><span class="line"><span class="cl">      // 目标节点在链表首尾之间，中部
</span></span><span class="line"><span class="cl">      else {
</span></span><span class="line"><span class="cl">        current.prev.next = current.next;
</span></span><span class="line"><span class="cl">        current.next.prev = current.prev;
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   current = current.next
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>removeAt：删除链表指定位置节点，实现如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">removeAt(index) {
</span></span><span class="line"><span class="cl">  // 都是从“头”开始遍历
</span></span><span class="line"><span class="cl">  let current = this.head
</span></span><span class="line"><span class="cl">  let counter = 1
</span></span><span class="line"><span class="cl">  // 删除链表头部
</span></span><span class="line"><span class="cl">  if (index === 0 ) {
</span></span><span class="line"><span class="cl">   this.head = this.head.next
</span></span><span class="line"><span class="cl">   this.head.prev = null
</span></span><span class="line"><span class="cl">  } 
</span></span><span class="line"><span class="cl">  else {
</span></span><span class="line"><span class="cl">   while(current) {
</span></span><span class="line"><span class="cl">    current = current.next
</span></span><span class="line"><span class="cl">    // 如果目标节点在链表尾
</span></span><span class="line"><span class="cl">    if (current == this.tail) {
</span></span><span class="line"><span class="cl">     this.tail = this.tail.prev
</span></span><span class="line"><span class="cl">     this.tail.next = null
</span></span><span class="line"><span class="cl">    } 
</span></span><span class="line"><span class="cl">    else if (counter === index) {
</span></span><span class="line"><span class="cl">     current.prev.next = current.next
</span></span><span class="line"><span class="cl">     current.next.prev = current.prev
</span></span><span class="line"><span class="cl">     break
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    counter++
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>reverse：翻转链表，实现如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">reverse() {
</span></span><span class="line"><span class="cl">  let current = this.head
</span></span><span class="line"><span class="cl">  let prev = null
</span></span><span class="line"><span class="cl">  while (current) {
</span></span><span class="line"><span class="cl">   let next = current.next
</span></span><span class="line"><span class="cl">   // 前后倒置
</span></span><span class="line"><span class="cl">   current.next = prev
</span></span><span class="line"><span class="cl">   current.prev = next
</span></span><span class="line"><span class="cl">   prev = current
</span></span><span class="line"><span class="cl">   current = next
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  this.tail = this.head
</span></span><span class="line"><span class="cl">  this.head = prev
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>swap：交换两个节点数据，实现如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">swap(index1, index2) {
</span></span><span class="line"><span class="cl">  // 使 index1 始终小于 index2，方便后面查找交换
</span></span><span class="line"><span class="cl">  if (index1 &gt; index2) {
</span></span><span class="line"><span class="cl">    return this.swap(index2, index1)
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  let current = this.head
</span></span><span class="line"><span class="cl">  let counter = 0
</span></span><span class="line"><span class="cl">  let firstNode
</span></span><span class="line"><span class="cl">  while(current !== null) {
</span></span><span class="line"><span class="cl">    // 找到第一个节点，先存起来
</span></span><span class="line"><span class="cl">    if (counter === index1 ){
</span></span><span class="line"><span class="cl">        firstNode = current
</span></span><span class="line"><span class="cl">    } 
</span></span><span class="line"><span class="cl">    // 找到第二个节点，进行数据交换
</span></span><span class="line"><span class="cl">    else if (counter === index2) {
</span></span><span class="line"><span class="cl">      // ES 提供了更为简洁的交换数据的方式，这里我们用传统方式实现，更为直观
</span></span><span class="line"><span class="cl">      let temp = current.data
</span></span><span class="line"><span class="cl">      current.data = firstNode.data
</span></span><span class="line"><span class="cl">      firstNode.data = temp
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    current = current.next
</span></span><span class="line"><span class="cl">    counter++
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return true
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>isEmpty：查询链表是否为空，实现如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">isEmpty() {
</span></span><span class="line"><span class="cl">  return this.length() &lt; 1
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>length：查询链表长度，实现如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">length() {
</span></span><span class="line"><span class="cl">  let current = this.head
</span></span><span class="line"><span class="cl">  let counter = 0
</span></span><span class="line"><span class="cl">  // 完整遍历一遍链表
</span></span><span class="line"><span class="cl">  while(current !== null) {
</span></span><span class="line"><span class="cl">    counter++
</span></span><span class="line"><span class="cl">    current = current.next
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return counter
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>traverse：遍历链表，实现如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">traverse(fn) {
</span></span><span class="line"><span class="cl">  let current = this.head
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  while(current !== null) {
</span></span><span class="line"><span class="cl">    // 执行遍历时回调 
</span></span><span class="line"><span class="cl">    fn(current)
</span></span><span class="line"><span class="cl">    current = current.next
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return true
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上代码，有了上面 length 方法的遍历实现，traverse 也就不难理解了，它接受一个遍历执行函数，在 while 循环中进行调用。</p>
<p>find：查找某个节点的索引，实现如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">find(item) {
</span></span><span class="line"><span class="cl">  let current = this.head
</span></span><span class="line"><span class="cl">  let counter = 0
</span></span><span class="line"><span class="cl">  while( current ) {
</span></span><span class="line"><span class="cl">    if( current.data == item ) {
</span></span><span class="line"><span class="cl">      return counter
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    current = current.next
</span></span><span class="line"><span class="cl">    counter++
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return false
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>至此，我们就实现了所有双向链表（DoublyLinkedList）的方法。仔细分析整个实现过程，你可以发现：双向链表的实现并不复杂，在手写过程中，需要开发者做到心中有“表”，考虑到当前节点的 next 和 prev 取值，逻辑上还是很简单的。</p>
<p>树</p>
<p>前端开发者应该对树这个数据结构丝毫不陌生，不同于之前介绍的所有数据结构，树是非线性的。因为树决定了其存储的数据直接有明确的层级关系，因此对于维护具有层级特性的数据，树是一个天然良好的选择。</p>
<p>事实上，树有很多种分类，但是它们都具有以下特性：</p>
<p>除了根节点以外，所有的节点都有一个父节点；</p>
<p>每一个节点都可以有若干子节点，如果没有子节点，则称此节点为叶子节点；</p>
<p>一个节点所拥有的叶子节点的个数，称之为该节点的度，因此叶子节点的度为 0；</p>
<p>所有节点中，最大的度为整棵树的度；</p>
<p>树的最大层次称为树的深度。</p>
<p>我们这里对二叉搜索树展开分析。二叉树算是最基本的树，因为它的结构最简单，每个节点至多包含两个子节点。二叉树又非常有用，因为根据二叉树，我们可以延伸出二叉搜索树（BST）、平衡二叉搜索树（AVL）、红黑树（R/B Tree）等。</p>
<p>二叉搜索树有以下特性：</p>
<p>左子树上所有结点的值均小于或等于它的根结点的值；</p>
<p>右子树上所有结点的值均大于或等于它的根结点的值；</p>
<p>左、右子树也分别为二叉搜索树。</p>
<p>根据其特性，我们实现二叉搜索树还是应该先构造一个节点类，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="ne">Node</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="n">constructor</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">this</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">null</span>
</span></span><span class="line"><span class="cl">    <span class="n">this</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">null</span>
</span></span><span class="line"><span class="cl">    <span class="n">this</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后我们实现二叉搜索树的以下方法。</p>
<p>insertNode：根据一个父节点，插入一个子节点，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">insertNode(root, newNode) {
</span></span><span class="line"><span class="cl">  // 根据待插入节点的值的大小，递归调用 this.insertNode
</span></span><span class="line"><span class="cl">  if (newNode.value &lt; root.value) {
</span></span><span class="line"><span class="cl">    (!root.left) ? root.left = newNode : this.insertNode(root.left, newNode)
</span></span><span class="line"><span class="cl">  } else {
</span></span><span class="line"><span class="cl">    (!root.right) ? root.right = newNode : this.insertNode(root.right, newNode)
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>insert：插入一个新节点，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">insert(value) {
</span></span><span class="line"><span class="cl">    let newNode = new Node(value)
</span></span><span class="line"><span class="cl">    // 判读是否是根节点
</span></span><span class="line"><span class="cl">    if (!this.root) {
</span></span><span class="line"><span class="cl">      this.root = newNode
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">    	// 不是根结点，则直接调用 this.insertNode 方法
</span></span><span class="line"><span class="cl">      this.insertNode(this.root, newNode)
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>理解这两个方法是理解二叉搜索树的关键，如果你理解了这两个方法，下面的其他方法也就“不在话下”。</p>
<p>我们可以看到，insertNode 方法先判断目标父节点和插入节点的值，如果插入节点的值更小，则考虑放到父节点的左边，接着递归调用 this.insertNode(root.left, newNode)；如果插入节点的值更大，以此类推即可。insert 方法只是多了一步构造 Node 节点实例，接下来区分有无父节点的情况，调用 this.insertNode 方法即可。</p>
<p>removeNode：根据一个父节点，移除一个子节点，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">removeNode(root, value) {
</span></span><span class="line"><span class="cl">    if (!root) {
</span></span><span class="line"><span class="cl">      return null
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    if (value &lt; root.value) {
</span></span><span class="line"><span class="cl">      root.left = this.removeNode(root.left, value)
</span></span><span class="line"><span class="cl">      return root
</span></span><span class="line"><span class="cl">    } else if (value &gt; root.value) {
</span></span><span class="line"><span class="cl">      root.right = tis.removeNode(root.right, value)
</span></span><span class="line"><span class="cl">      return root
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">      // 找到了需要删除的节点 
</span></span><span class="line"><span class="cl">      // 如果当前 root 节点无左右子节点
</span></span><span class="line"><span class="cl">      if (!root.left &amp;&amp; !root.right) {
</span></span><span class="line"><span class="cl">        root = null
</span></span><span class="line"><span class="cl">        return root
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      // 只有左节点
</span></span><span class="line"><span class="cl">      if (root.left &amp;&amp; !root.right) {
</span></span><span class="line"><span class="cl">        root = root.left
</span></span><span class="line"><span class="cl">        return root
</span></span><span class="line"><span class="cl">      } 
</span></span><span class="line"><span class="cl">      // 只有右节点
</span></span><span class="line"><span class="cl">      else if (root.right) {
</span></span><span class="line"><span class="cl">        root = root.right
</span></span><span class="line"><span class="cl">        return root
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      // 有左右两个子节点
</span></span><span class="line"><span class="cl">      let minRight = this.findMinNode(root.right)
</span></span><span class="line"><span class="cl">      root.value = minRight.value
</span></span><span class="line"><span class="cl">      root.right = this.removeNode(root.right, minRight.value)
</span></span><span class="line"><span class="cl">      return root
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span></code></pre></td></tr></table>
</div>
</div><p>remove：移除一个节点，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">remove(value) {
</span></span><span class="line"><span class="cl">    if (this.root) {
</span></span><span class="line"><span class="cl">      this.removeNode(this.root, value)
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// 找到最小的节点
</span></span><span class="line"><span class="cl">// 该方法不断递归，直到找到最左叶子节点即可
</span></span><span class="line"><span class="cl">findMinNode(root) {
</span></span><span class="line"><span class="cl">    if (!root.left) {
</span></span><span class="line"><span class="cl">      return root
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">      return this.findMinNode(root.left)
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码不难理解，唯一需要说明的是：当需要删除的节点含有左右两个子节点时，因为我们要把当前节点删除，就需要找到合适的“补位”节点，这个“补位”节点一定在该目标节点的右侧树当中，因为这样才能保证“补位”节点的值一定大于该目标节点的左侧树所有节点，而该目标节点的左侧树不需要调整；同时为了保证“补位”节点的值一定要小于该目标节点的右侧树值，因此要找的“补位”节点其实就是该目标节点的右侧树当中最小的那个节点。</p>
<p>searchNode：根据一个父节点，查找子节点，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">searchNode(root, value) {
</span></span><span class="line"><span class="cl">    if (!root) {
</span></span><span class="line"><span class="cl">      return null
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    if (value &lt; root.value) {
</span></span><span class="line"><span class="cl">      return this.searchNode(root.left, value)
</span></span><span class="line"><span class="cl">    } else if (value &gt; root.value) {
</span></span><span class="line"><span class="cl">      return this.searchNode(root.right, value)
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return root
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>search：查找节点，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">search(value) {
</span></span><span class="line"><span class="cl">    if (!this.root) {
</span></span><span class="line"><span class="cl">      return false
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return Boolean(this.searchNode(this.root, value))
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>preOrder：前序遍历，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">preOrder(root) {
</span></span><span class="line"><span class="cl">    if (root) {
</span></span><span class="line"><span class="cl">      console.log(root.value)
</span></span><span class="line"><span class="cl">      this.preOrder(root.left)
</span></span><span class="line"><span class="cl">      this.preOrder(root.right)
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>InOrder：中序遍历，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">inOrder(root) {
</span></span><span class="line"><span class="cl">    if (root) {
</span></span><span class="line"><span class="cl">      this.inOrder(root.left)
</span></span><span class="line"><span class="cl">      console.log(root.value)
</span></span><span class="line"><span class="cl">      this.inOrder(root.right)
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>PostOrder：后续遍历，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">postOrder(root) {
</span></span><span class="line"><span class="cl">    if (root) {
</span></span><span class="line"><span class="cl">      this.postOrder(root.left)
</span></span><span class="line"><span class="cl">      this.postOrder(root.right)
</span></span><span class="line"><span class="cl">      console.log(root.value)
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述前、中、后序遍历的区别其实就在于console.log(root.value) 方法执行的位置。</p>
<p>图</p>
<p>图是由具有边的节点集合组成的数据结构，图可以是定向的或不定向的。图也是应用最广泛的数据结构之一，真实场景中处处有图。当然更多概念还是需要你先进行了解，尤其是图的几种基本元素。</p>
<p>节点：Node</p>
<p>边：Edge</p>
<p>|V|：图中顶点（节点）的总数</p>
<p>|E|：图中的连接总数（边）</p>
<p>这里我们主要实现一个有向图，Graph 类，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Graph</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  	 <span class="o">//</span> <span class="err">使用</span> <span class="n">Map</span> <span class="err">数据结构表述图中顶点关系</span>
</span></span><span class="line"><span class="cl">    <span class="n">this</span><span class="o">.</span><span class="n">AdjList</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Map</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们先通过创建节点，来创建一个图，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">let graph = new Graph();
</span></span><span class="line"><span class="cl">graph.addVertex(&#39;A&#39;)
</span></span><span class="line"><span class="cl">graph.addVertex(&#39;B&#39;)
</span></span><span class="line"><span class="cl">graph.addVertex(&#39;C&#39;)
</span></span><span class="line"><span class="cl">graph.addVertex(&#39;D&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>添加顶点：addVertex，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">addVertex(vertex) {
</span></span><span class="line"><span class="cl">  if (!this.AdjList.has(vertex)) {
</span></span><span class="line"><span class="cl">    this.AdjList.set(vertex, [])
</span></span><span class="line"><span class="cl">  } else {
</span></span><span class="line"><span class="cl">    throw &#39;vertex already exist!&#39;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这时候，A、B、C、D 顶点都对应一个数组，如下代码所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  &#39;A&#39; =&gt; [],
</span></span><span class="line"><span class="cl">  &#39;B&#39; =&gt; [],
</span></span><span class="line"><span class="cl">  &#39;C&#39; =&gt; [],
</span></span><span class="line"><span class="cl">  &#39;D&#39; =&gt; []
</span></span></code></pre></td></tr></table>
</div>
</div><p>数组将用来存储边。我们设计图预计得到如下关系：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Map {
</span></span><span class="line"><span class="cl">  &#39;A&#39; =&gt; [&#39;B&#39;, &#39;C&#39;, &#39;D&#39;],
</span></span><span class="line"><span class="cl">  &#39;B&#39; =&gt; [],
</span></span><span class="line"><span class="cl">  &#39;C&#39; =&gt; [&#39;B&#39;],
</span></span><span class="line"><span class="cl">  &#39;D&#39; =&gt; [&#39;C&#39;]
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>根据以上描述，其实已经可以把图画出来了。addEdge 需要两个参数：一个是顶点，一个是连接对象 Node。我们看看添加边是如何实现的。</p>
<p>添加边：addEdge，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> addEdge(vertex, node) {
</span></span><span class="line"><span class="cl">    if (this.AdjList.has(vertex)) {
</span></span><span class="line"><span class="cl">      if (this.AdjList.has(node)){
</span></span><span class="line"><span class="cl">        let arr = this.AdjList.get(vertex)
</span></span><span class="line"><span class="cl">        if (!arr.includes(node)){
</span></span><span class="line"><span class="cl">          arr.push(node)
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">      } else {
</span></span><span class="line"><span class="cl">        throw `Can&#39;t add non-existing vertex -&gt;&#39;${node}&#39;`
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">      throw `You should add &#39;${vertex}&#39; first`
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>理清楚数据关系，我们就可以打印图了，其实就是一个很简单的 for…of 循环：</p>
<p>打印图：print，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">print() {
</span></span><span class="line"><span class="cl">  // 使用 for of 遍历并打印 this.AdjList
</span></span><span class="line"><span class="cl">  for (let [key, value] of this.AdjList) {
</span></span><span class="line"><span class="cl">    console.log(key, value)
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>剩下的内容就是遍历图了。遍历分为广度优先算法（BFS）和深度优先搜索算法（DFS）。我们先来看下广度优先算法（BFS）。</p>
<p>广度优先算法遍历，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">createVisitedObject() {
</span></span><span class="line"><span class="cl">  let map = {}
</span></span><span class="line"><span class="cl">  for (let key of this.AdjList.keys()) {
</span></span><span class="line"><span class="cl">    arr[key] = false
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return map
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">bfs (initialNode) {
</span></span><span class="line"><span class="cl">  // 创建一个已访问节点的 map
</span></span><span class="line"><span class="cl">  let visited = this.createVisitedObject()
</span></span><span class="line"><span class="cl">  // 模拟一个队列
</span></span><span class="line"><span class="cl">  let queue = []
</span></span><span class="line"><span class="cl">  // 第一个节点已访问
</span></span><span class="line"><span class="cl">  visited[initialNode] = true
</span></span><span class="line"><span class="cl">  // 第一个节点入队列
</span></span><span class="line"><span class="cl">  queue.push(initialNode)
</span></span><span class="line"><span class="cl">  while (queue.length) {
</span></span><span class="line"><span class="cl">    let current = queue.shift()
</span></span><span class="line"><span class="cl">    console.log(current)
</span></span><span class="line"><span class="cl">     // 获得该节点的其他节点关系
</span></span><span class="line"><span class="cl">    let arr = this.AdjList.get(current)
</span></span><span class="line"><span class="cl">    for (let elem of arr) {
</span></span><span class="line"><span class="cl">      // 如果当前节点没有访问过
</span></span><span class="line"><span class="cl">      if (!visited[elem]) {
</span></span><span class="line"><span class="cl">        visited[elem] = true
</span></span><span class="line"><span class="cl">        queue.push(elem)
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上代码所示，我们来进行简单总结。广度优先算法（BFS），是一种利用队列实现的搜索算法。对于图来说，就是从起点出发，对于每次出队列的点，都要遍历其四周的点。</p>
<p>因此 BFS 的实现步骤：</p>
<p>起始节点作为起始，并初始化一个空对象——visited；</p>
<p>初始化一个空数组，该数组将模拟一个队列；</p>
<p>将起始节点标记为已访问；</p>
<p>将起始节点放入队列中；</p>
<p>循环直到队列为空。</p>
<p>深度优先算法，如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">createVisitedObject() {
</span></span><span class="line"><span class="cl">  let map = {}
</span></span><span class="line"><span class="cl">  for (let key of this.AdjList.keys()) {
</span></span><span class="line"><span class="cl">    arr[key] = false
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return map
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl"> // 深度优先算法
</span></span><span class="line"><span class="cl"> dfs(initialNode) {
</span></span><span class="line"><span class="cl">    let visited = this.createVisitedObject()
</span></span><span class="line"><span class="cl">    this.dfsHelper(initialNode, visited)
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  dfsHelper(node, visited) {
</span></span><span class="line"><span class="cl">    visited[node] = true
</span></span><span class="line"><span class="cl">    console.log(node)
</span></span><span class="line"><span class="cl">    let arr = this.AdjList.get(node)
</span></span><span class="line"><span class="cl">    // 遍历节点调用 this.dfsHelper
</span></span><span class="line"><span class="cl">    for (let elem of arr) {
</span></span><span class="line"><span class="cl">      if (!visited[elem]) {
</span></span><span class="line"><span class="cl">        this.dfsHelper(elem, visited)
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上代码，对于深度优先搜索算法（DFS），我把它总结为：“不撞南墙不回头”，从起点出发，先把一个方向的点都遍历完才会改变方向。换成程序语言就是：“DFS 是利用递归实现的搜索算法”。因此 DFS 的实现过程：</p>
<p>起始节点作为起始，创建访问对象；</p>
<p>调用辅助函数递归起始节点。</p>
<p>BFS 的实现重点在于队列，而 DFS 的重点在于递归，这是它们的本质区别。</p>
<p>总结</p>
<p>这一讲我们介绍了和前端最为贴合的几种数据结构，事实上数据结构更重要的是应用，我希望你能够做到：在需要的场景，能够想到最为适合的数据结构处理问题。请你务必掌握好这些内容，接下来的几讲都需要对数据结构有一个较为熟练的掌握和了解。我们马上进入数据结构的应用学习。</p>
<p>本讲内容总结如下：</p>
<p>随着需求的复杂度上升，前端工程师越来越离不开数据结构。是否能够掌握这个难点内容，将是进阶的重要考量。下一讲，我们将解析数据结构在前端中的具体应用场景，来帮助你加深理解，做到灵活应用。</p>
<p>-&ndash; ### 精选评论 ##### **宇： &gt; bfs dfs其实就是层序遍历和前序遍历，树是一种特殊的有向图 ##### *聪： &gt; 【createVisitedObject() { let map = {} for (let key of this.AdjList.keys()) { arr[key] = false } return map}】&mdash;&mdash;-这里arr[key] = false，应是 map[key] = false ？ ######     讲师回复： &gt;     是，这里是个 typo ##### *聪： &gt; 老师，文中【这个“补位”节点一定在该目标节点的右侧树当中】是不是不一定？既然可以选右侧最小的节点，那我要选左侧最大的节点也行吧？ ######     讲师回复： &gt;     右侧 &gt; 左侧</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%9E%B6%E6%9E%8430%E8%AE%B2/">前端基础建设与架构30讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%A7%A3%E8%AF%BB%E4%BD%A0%E8%BA%AB%E8%BE%B9%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6/21%E8%AD%A6%E6%83%95%E6%88%BF%E5%9C%B0%E4%BA%A7%E6%B3%A1%E6%B2%AB%E7%9A%84%E7%A0%B4%E7%81%AD/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">21警惕房地产泡沫的破灭</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90mybatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/21%E6%B7%B1%E6%8C%96mybati%E4%B8%8Espring%E9%9B%86%E6%88%90%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">
            <span class="next-text nav-default">21深挖MyBati与Spring集成底层原理</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
