<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>18__案例篇：内存泄漏了，我该如何定位和处理？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是倪朋飞。
通过前几节对内存基础的学习，我相信你对 Linux 内存的工作原理，已经有了初步了解。
对普通进程来说，能看到的其实是内核提供的虚拟内存，这些虚拟内存还需要通过页表，由系统映射为物理内存。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/18__%E6%A1%88%E4%BE%8B%E7%AF%87%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%BA%86%E6%88%91%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%92%8C%E5%A4%84%E7%90%86/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/18__%E6%A1%88%E4%BE%8B%E7%AF%87%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%BA%86%E6%88%91%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%92%8C%E5%A4%84%E7%90%86/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="18__案例篇：内存泄漏了，我该如何定位和处理？">
  <meta property="og:description" content="你好，我是倪朋飞。
通过前几节对内存基础的学习，我相信你对 Linux 内存的工作原理，已经有了初步了解。
对普通进程来说，能看到的其实是内核提供的虚拟内存，这些虚拟内存还需要通过页表，由系统映射为物理内存。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Linux性能优化实战">

  <meta itemprop="name" content="18__案例篇：内存泄漏了，我该如何定位和处理？">
  <meta itemprop="description" content="你好，我是倪朋飞。
通过前几节对内存基础的学习，我相信你对 Linux 内存的工作原理，已经有了初步了解。
对普通进程来说，能看到的其实是内核提供的虚拟内存，这些虚拟内存还需要通过页表，由系统映射为物理内存。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4669">
  <meta itemprop="keywords" content="Linux性能优化实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="18__案例篇：内存泄漏了，我该如何定位和处理？">
  <meta name="twitter:description" content="你好，我是倪朋飞。
通过前几节对内存基础的学习，我相信你对 Linux 内存的工作原理，已经有了初步了解。
对普通进程来说，能看到的其实是内核提供的虚拟内存，这些虚拟内存还需要通过页表，由系统映射为物理内存。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">18__案例篇：内存泄漏了，我该如何定位和处理？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4669 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#内存的分配和回收">内存的分配和回收</a></li>
        <li><a href="#案例">案例</a></li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#思考">思考</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是倪朋飞。</p>
<p>通过前几节对内存基础的学习，我相信你对 Linux 内存的工作原理，已经有了初步了解。</p>
<p>对普通进程来说，能看到的其实是内核提供的虚拟内存，这些虚拟内存还需要通过页表，由系统映射为物理内存。</p>
<p>当进程通过 malloc() 申请虚拟内存后，系统并不会立即为其分配物理内存，而是在首次访问时，才通过缺页异常陷入内核中分配内存。</p>
<p>为了协调 CPU 与磁盘间的性能差异，Linux 还会使用 Cache 和 Buffer，分别把文件和磁盘读写的数据缓存到内存中。</p>
<p>对应用程序来说，动态内存的分配和回收，是既核心又复杂的一个逻辑功能模块。管理内存的过程中，也很容易发生各种各样的“事故”，比如，</p>
<ul>
<li>没正确回收分配后的内存，导致了泄漏。</li>
<li>访问的是已分配内存边界外的地址，导致程序异常退出，等等。</li>
</ul>
<p>今天我就带你来看看，内存泄漏到底是怎么发生的，以及发生内存泄漏之后该如何排查和定位。</p>
<p>说起内存泄漏，这就要先从内存的分配和回收说起了。</p>
<h2 id="内存的分配和回收">内存的分配和回收</h2>
<p>先回顾一下，你还记得应用程序中，都有哪些方法来分配内存吗？用完后，又该怎么释放还给系统呢？</p>
<p>前面讲进程的内存空间时，我曾经提到过，用户空间内存包括多个不同的内存段，比如只读段、数据段、堆、栈以及文件映射段等。这些内存段正是应用程序使用内存的基本方式。</p>
<p>举个例子，你在程序中定义了一个局部变量，比如一个整数数组 <em>int data[64]</em> ，就定义了一个可以存储 64 个整数的内存段。由于这是一个局部变量，它会从内存空间的栈中分配内存。</p>
<p>栈内存由系统自动分配和管理。一旦程序运行超出了这个局部变量的作用域，栈内存就会被系统自动回收，所以不会产生内存泄漏的问题。</p>
<p>再比如，很多时候，我们事先并不知道数据大小，所以你就要用到标准库函数 <em>malloc()</em> _，_ 在程序中动态分配内存。这时候，系统就会从内存空间的堆中分配内存。</p>
<p>堆内存由应用程序自己来分配和管理。除非程序退出，这些堆内存并不会被系统自动释放，而是需要应用程序明确调用库函数 <em>free()</em> 来释放它们。如果应用程序没有正确释放堆内存，就会造成内存泄漏。</p>
<p>这是两个栈和堆的例子，那么，其他内存段是否也会导致内存泄漏呢？经过我们前面的学习，这个问题并不难回答。</p>
<ul>
<li>只读段，包括程序的代码和常量，由于是只读的，不会再去分配新的内存，所以也不会产生内存泄漏。</li>
<li>数据段，包括全局变量和静态变量，这些变量在定义时就已经确定了大小，所以也不会产生内存泄漏。</li>
<li>最后一个内存映射段，包括动态链接库和共享内存，其中共享内存由程序动态分配和管理。所以，如果程序在分配后忘了回收，就会导致跟堆内存类似的泄漏问题。</li>
</ul>
<p><strong>内存泄漏的危害非常大，这些忘记释放的内存，不仅应用程序自己不能访问，系统也不能把它们再次分配给其他应用</strong>。内存泄漏不断累积，甚至会耗尽系统内存。</p>
<p>虽然，系统最终可以通过 OOM（Out of Memory）机制杀死进程，但进程在 OOM 前，可能已经引发了一连串的反应，导致严重的性能问题。</p>
<p>比如，其他需要内存的进程，可能无法分配新的内存；内存不足，又会触发系统的缓存回收以及 SWAP 机制，从而进一步导致 I/O 的性能问题等等。</p>
<p>内存泄漏的危害这么大，那我们应该怎么检测这种问题呢？特别是，如果你已经发现了内存泄漏，该如何定位和处理呢。</p>
<p>接下来，我们就用一个计算斐波那契数列的案例，来看看内存泄漏问题的定位和处理方法。</p>
<p>斐波那契数列是一个这样的数列：0、1、1、2、3、5、8…，也就是除了前两个数是 0 和 1，其他数都由前面两数相加得到，用数学公式来表示就是 F(n)=F(n-1)+F(n-2)，（n&gt;=2），F(0)=0, F(1)=1。</p>
<h2 id="案例">案例</h2>
<p>今天的案例基于 Ubuntu 18.04，当然，同样适用其他的 Linux 系统。</p>
<ul>
<li>机器配置：2 CPU，8GB 内存</li>
<li>预先安装 sysstat、Docker 以及 bcc 软件包，比如：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># install sysstat docker</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">sudo</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> <span class="n">sysstat</span> <span class="n">docker</span><span class="o">.</span><span class="n">io</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1"># Install bcc</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">sudo</span> <span class="n">apt</span><span class="o">-</span><span class="n">key</span> <span class="n">adv</span> <span class="o">--</span><span class="n">keyserver</span> <span class="n">keyserver</span><span class="o">.</span><span class="n">ubuntu</span><span class="o">.</span><span class="n">com</span> <span class="o">--</span><span class="n">recv</span><span class="o">-</span><span class="n">keys</span> <span class="mi">4052245</span><span class="n">BD4284CDD</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">echo</span> <span class="s2">&#34;deb https://repo.iovisor.org/apt/bionic bionic main&#34;</span> <span class="o">|</span> <span class="n">sudo</span> <span class="n">tee</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">apt</span><span class="o">/</span><span class="n">sources</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">d</span><span class="o">/</span><span class="n">iovisor</span><span class="o">.</span><span class="n">list</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">sudo</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">sudo</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> <span class="n">bcc</span><span class="o">-</span><span class="n">tools</span> <span class="n">libbcc</span><span class="o">-</span><span class="n">examples</span> <span class="n">linux</span><span class="o">-</span><span class="n">headers</span><span class="o">-$</span><span class="p">(</span><span class="n">uname</span> <span class="o">-</span><span class="n">r</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，sysstat 和 Docker 我们已经很熟悉了。sysstat 软件包中的 vmstat，可以观察内存的变化情况；而 Docker 可以运行案例程序。</p>
<p><a href="./bcc.md">bcc</a> 软件包前面也介绍过，它提供了一系列的 Linux 性能分析工具，常用来动态追踪进程和内核的行为。更多工作原理你先不用深究，后面学习我们会逐步接触。这里你只需要记住，按照上面步骤安装完后，它提供的所有工具都位于 /usr/share/bcc/tools 这个目录中。</p>
<blockquote>
<p>注意：bcc-tools 需要内核版本为 4.1 或者更高，如果你使用的是 CentOS7，或者其他内核版本比较旧的系统，那么你需要手动<a href="./462.md">升级内核版本后再安装</a>。</p>
</blockquote>
<p>打开一个终端，SSH 登录到机器上，安装上述工具。</p>
<p>同以前的案例一样，下面的所有命令都默认以 root 用户运行，如果你是用普通用户身份登陆系统，请运行 sudo su root 命令切换到 root 用户。</p>
<p>如果安装过程中有什么问题，同样鼓励你先自己搜索解决，解决不了的，可以在留言区向我提问。如果你以前已经安装过了，就可以忽略这一点了。</p>
<p>安装完成后，再执行下面的命令来运行案例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker run --name=app -itd feisky/app:mem-leak
</span></span></code></pre></td></tr></table>
</div>
</div><p>案例成功运行后，你需要输入下面的命令，确认案例应用已经正常启动。如果一切正常，你应该可以看到下面这个界面：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker logs app
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2th =&gt; 1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">3th =&gt; 2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">4th =&gt; 3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">5th =&gt; 5
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">6th =&gt; 8
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">7th =&gt; 13
</span></span></code></pre></td></tr></table>
</div>
</div><p>从输出中，我们可以发现，这个案例会输出斐波那契数列的一系列数值。实际上，这些数值每隔 1 秒输出一次。</p>
<p>知道了这些，我们应该怎么检查内存情况，判断有没有泄漏发生呢？你首先想到的可能是 top 工具，不过，top 虽然能观察系统和进程的内存占用情况，但今天的案例并不适合。内存泄漏问题，我们更应该关注内存使用的变化趋势。</p>
<p>所以，开头我也提到了，今天推荐的是另一个老熟人，vmstat 工具。</p>
<p>运行下面的 vmstat，等待一段时间，观察内存的变化情况。如果忘了 vmstat 里各指标的含义，记得复习前面内容，或者执行 man vmstat 查询。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 每隔 3 秒输出一组数据
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ vmstat 3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">0  0      0 6601824  97620 1098784    0    0     0     0   62  322  0  0 100  0  0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">0  0      0 6601700  97620 1098788    0    0     0     0   57  251  0  0 100  0  0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">0  0      0 6601320  97620 1098788    0    0     0     3   52  306  0  0 100  0  0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">0  0      0 6601452  97628 1098788    0    0     0    27   63  326  0  0 100  0  0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2  0      0 6601328  97628 1098788    0    0     0    44   52  299  0  0 100  0  0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">0  0      0 6601080  97628 1098792    0    0     0     0   56  285  0  0 100  0  0 
</span></span></code></pre></td></tr></table>
</div>
</div><p>从输出中你可以看到，内存的 free 列在不停的变化，并且是下降趋势；而 buffer 和 cache 基本保持不变。</p>
<p>未使用内存在逐渐减小，而 buffer 和 cache 基本不变，这说明，系统中使用的内存一直在升高。但这并不能说明有内存泄漏，因为应用程序运行中需要的内存也可能会增大。比如说，程序中如果用了一个动态增长的数组来缓存计算结果，占用内存自然会增长。</p>
<p>那怎么确定是不是内存泄漏呢？或者换句话说，有没有简单方法找出让内存增长的进程，并定位增长内存用在哪儿呢？</p>
<p>根据前面内容，你应该想到了用 top 或 ps 来观察进程的内存使用情况，然后找出内存使用一直增长的进程，最后再通过 pmap 查看进程的内存分布。</p>
<p>但这种方法并不太好用，因为要判断内存的变化情况，还需要你写一个脚本，来处理 top 或者 ps 的输出。</p>
<p>这里，我介绍一个专门用来检测内存泄漏的工具，memleak。memleak 可以跟踪系统或指定进程的内存分配、释放请求，然后定期输出一个未释放内存和相应调用栈的汇总情况（默认 5 秒）。</p>
<p>当然，memleak 是 bcc 软件包中的一个工具，我们一开始就装好了，执行 <em>/usr/share/bcc/tools/memleak</em> 就可以运行它。比如，我们运行下面的命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># -a 表示显示每个内存分配请求的大小以及地址</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># -p 指定案例应用的 PID 号</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">share</span><span class="o">/</span><span class="n">bcc</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">memleak</span> <span class="o">-</span><span class="n">a</span> <span class="o">-</span><span class="n">p</span> <span class="o">$</span><span class="p">(</span><span class="n">pidof</span> <span class="n">app</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">WARNING</span><span class="p">:</span> <span class="n">Couldn</span><span class="s1">&#39;t find .text section in /app</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">WARNING</span><span class="p">:</span> <span class="n">BCC</span> <span class="n">can</span><span class="s1">&#39;t handle sym look ups for /app</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">addr</span> <span class="o">=</span> <span class="mi">7</span><span class="n">f8f704732b0</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8192</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">addr</span> <span class="o">=</span> <span class="mi">7</span><span class="n">f8f704772d0</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8192</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">addr</span> <span class="o">=</span> <span class="mi">7</span><span class="n">f8f704712a0</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8192</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">addr</span> <span class="o">=</span> <span class="mi">7</span><span class="n">f8f704752c0</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8192</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="mi">32768</span> <span class="n">bytes</span> <span class="ow">in</span> <span class="mi">4</span> <span class="n">allocations</span> <span class="n">from</span> <span class="n">stack</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">[</span><span class="n">unknown</span><span class="p">]</span> <span class="p">[</span><span class="n">app</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">[</span><span class="n">unknown</span><span class="p">]</span> <span class="p">[</span><span class="n">app</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">start_thread</span><span class="o">+</span><span class="mh">0xdb</span> <span class="p">[</span><span class="n">libpthread</span><span class="o">-</span><span class="mf">2.27</span><span class="o">.</span><span class="n">so</span><span class="p">]</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>从 memleak 的输出可以看到，案例应用在不停地分配内存，并且这些分配的地址没有被回收。</p>
<p>这里有一个问题，Couldn’t find .text section in /app，所以调用栈不能正常输出，最后的调用栈部分只能看到 [unknown] 的标志。</p>
<p>为什么会有这个错误呢？实际上，这是由于案例应用运行在容器中导致的。memleak 工具运行在容器之外，并不能直接访问进程路径 /app。</p>
<p>比方说，在终端中直接运行 ls 命令，你会发现，这个路径的确不存在：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ ls /app
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ls: cannot access &#39;/app&#39;: No such file or directory
</span></span></code></pre></td></tr></table>
</div>
</div><p>类似的问题，我在 CPU 模块中的 <a href="./73738.md">perf 使用方法</a>中已经提到好几个解决思路。最简单的方法，就是在容器外部构建相同路径的文件以及依赖库。这个案例只有一个二进制文件，所以只要把案例应用的二进制文件放到 /app 路径中，就可以修复这个问题。</p>
<p>比如，你可以运行下面的命令，把 app 二进制文件从容器中复制出来，然后重新运行 memleak 工具：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="n">docker</span> <span class="n">cp</span> <span class="n">app</span><span class="p">:</span><span class="o">/</span><span class="n">app</span> <span class="o">/</span><span class="n">app</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">share</span><span class="o">/</span><span class="n">bcc</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">memleak</span> <span class="o">-</span><span class="n">p</span> <span class="o">$</span><span class="p">(</span><span class="n">pidof</span> <span class="n">app</span><span class="p">)</span> <span class="o">-</span><span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Attaching</span> <span class="n">to</span> <span class="n">pid</span> <span class="mi">12512</span><span class="p">,</span> <span class="n">Ctrl</span><span class="o">+</span><span class="n">C</span> <span class="n">to</span> <span class="n">quit</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">03</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">41</span><span class="p">]</span> <span class="n">Top</span> <span class="mi">10</span> <span class="n">stacks</span> <span class="n">with</span> <span class="n">outstanding</span> <span class="n">allocations</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">addr</span> <span class="o">=</span> <span class="mi">7</span><span class="n">f8f70863220</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8192</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">addr</span> <span class="o">=</span> <span class="mi">7</span><span class="n">f8f70861210</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8192</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">addr</span> <span class="o">=</span> <span class="mi">7</span><span class="n">f8f7085b1e0</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8192</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">addr</span> <span class="o">=</span> <span class="mi">7</span><span class="n">f8f7085f200</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8192</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">addr</span> <span class="o">=</span> <span class="mi">7</span><span class="n">f8f7085d1f0</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8192</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="mi">40960</span> <span class="n">bytes</span> <span class="ow">in</span> <span class="mi">5</span> <span class="n">allocations</span> <span class="n">from</span> <span class="n">stack</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">fibonacci</span><span class="o">+</span><span class="mh">0x1f</span> <span class="p">[</span><span class="n">app</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">child</span><span class="o">+</span><span class="mh">0x4f</span> <span class="p">[</span><span class="n">app</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">start_thread</span><span class="o">+</span><span class="mh">0xdb</span> <span class="p">[</span><span class="n">libpthread</span><span class="o">-</span><span class="mf">2.27</span><span class="o">.</span><span class="n">so</span><span class="p">]</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>这一次，我们终于看到了内存分配的调用栈，原来是 fibonacci() 函数分配的内存没释放。</p>
<p>定位了内存泄漏的来源，下一步自然就应该查看源码，想办法修复它。我们一起来看案例应用的源代码 <a href="./app.c.md">app.c</a>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker exec app cat /app.c
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">long long *fibonacci(long long *n0, long long *n1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 分配 1024 个长整数空间方便观测内存的变化情况
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    long long *v = (long long *) calloc(1024, sizeof(long long));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    *v = *n0 + *n1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return v;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  void *child(void *arg)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    long long n0 = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    long long n1 = 1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    long long *v = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (int n = 2; n &gt; 0; n++) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        v = fibonacci(&amp;n0, &amp;n1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        n0 = n1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        n1 = *v;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        printf(&#34;%dth =&gt; %lld\n&#34;, n, *v);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        sleep(1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">... 
</span></span></code></pre></td></tr></table>
</div>
</div><p>你会发现，child() 调用了 fibonacci() 函数，但并没有释放 fibonacci() 返回的内存。所以，想要修复泄漏问题，在 child() 中加一个释放函数就可以了，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void *child(void *arg)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (int n = 2; n &gt; 0; n++) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        v = fibonacci(&amp;n0, &amp;n1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        n0 = n1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        n1 = *v;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        printf(&#34;%dth =&gt; %lld\n&#34;, n, *v);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        free(v);    // 释放内存
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        sleep(1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} 
</span></span></code></pre></td></tr></table>
</div>
</div><p>我把修复后的代码放到了 <a href="./app-fix.c.md">app-fix.c</a>，也打包成了一个 Docker 镜像。你可以运行下面的命令，验证一下内存泄漏是否修复：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 清理原来的案例应用</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="n">docker</span> <span class="n">rm</span> <span class="o">-</span><span class="n">f</span> <span class="n">app</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1"># 运行修复后的应用</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">--</span><span class="n">name</span><span class="o">=</span><span class="n">app</span> <span class="o">-</span><span class="n">itd</span> <span class="n">feisky</span><span class="o">/</span><span class="n">app</span><span class="p">:</span><span class="n">mem</span><span class="o">-</span><span class="n">leak</span><span class="o">-</span><span class="n">fix</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1"># 重新执行 memleak 工具检查内存泄漏情况</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">share</span><span class="o">/</span><span class="n">bcc</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">memleak</span> <span class="o">-</span><span class="n">a</span> <span class="o">-</span><span class="n">p</span> <span class="o">$</span><span class="p">(</span><span class="n">pidof</span> <span class="n">app</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Attaching</span> <span class="n">to</span> <span class="n">pid</span> <span class="mi">18808</span><span class="p">,</span> <span class="n">Ctrl</span><span class="o">+</span><span class="n">C</span> <span class="n">to</span> <span class="n">quit</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span><span class="mi">18</span><span class="p">]</span> <span class="n">Top</span> <span class="mi">10</span> <span class="n">stacks</span> <span class="n">with</span> <span class="n">outstanding</span> <span class="n">allocations</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span><span class="mi">23</span><span class="p">]</span> <span class="n">Top</span> <span class="mi">10</span> <span class="n">stacks</span> <span class="n">with</span> <span class="n">outstanding</span> <span class="n">allocations</span><span class="p">:</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在，我们看到，案例应用已经没有遗留内存，证明我们的修复工作成功完成。</p>
<h2 id="小结">小结</h2>
<p>总结一下今天的内容。</p>
<p>应用程序可以访问的用户内存空间，由只读段、数据段、堆、栈以及文件映射段等组成。其中，堆内存和内存映射，需要应用程序来动态管理内存段，所以我们必须小心处理。不仅要会用标准库函数 <em>malloc()</em> 来动态分配内存，还要记得在用完内存后，调用库函数 _free() 来 _ 释放它们。</p>
<p>今天的案例比较简单，只用加一个 <em>free()</em> 调用就能修复内存泄漏。不过，实际应用程序就复杂多了。比如说，</p>
<ul>
<li>malloc() 和 free() 通常并不是成对出现，而是需要你，在每个异常处理路径和成功路径上都释放内存。</li>
<li>在多线程程序中，一个线程中分配的内存，可能会在另一个线程中访问和释放。</li>
<li>更复杂的是，在第三方的库函数中，隐式分配的内存可能需要应用程序显式释放。</li>
</ul>
<p>所以，为了避免内存泄漏，最重要的一点就是养成良好的编程习惯，比如分配内存后，一定要先写好内存释放的代码，再去开发其他逻辑。还是那句话，有借有还，才能高效运转，再借不难。</p>
<p>当然，如果已经完成了开发任务，你还可以用 memleak 工具，检查应用程序的运行中，内存是否泄漏。如果发现了内存泄漏情况，再根据 memleak 输出的应用程序调用栈，定位内存的分配位置，从而释放不再访问的内存。</p>
<h2 id="思考">思考</h2>
<p>最后，给你留一个思考题。</p>
<p>今天的案例，我们通过增加 <em>free()</em> 调用，释放函数 <em>fibonacci()</em> 分配的内存，修复了内存泄漏的问题。就这个案例而言，还有没有其他更好的修复方法呢？结合前面学习和你自己的工作经验，相信你一定能有更多更好的方案。</p>
<p>欢迎留言和我讨论，写下你的答案和收获，也欢迎你把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/f3ab291e71ad0a9d7fe2c894ccb9706a.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/">Linux性能优化实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/rpc%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/18__%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E5%8F%AF%E9%9D%A0%E7%9A%84%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">18__安全体系：如何建立可靠的安全体系？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%9B%A0%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E8%AF%BE/18__%E6%9C%AC%E5%9C%B0%E5%92%8C%E5%85%A8%E7%90%83%E5%8C%96%E4%BD%A0%E7%9A%84%E5%81%8F%E5%A5%BD%E6%81%B0%E6%81%B0%E6%98%AF%E4%BB%96%E7%9A%84%E7%A6%81%E5%BF%8C/">
            <span class="next-text nav-default">18__本地和全球化：你的偏好恰恰是他的禁忌</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
