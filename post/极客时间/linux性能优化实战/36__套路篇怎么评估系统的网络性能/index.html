<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>36__套路篇：怎么评估系统的网络性能？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是倪朋飞。
上一节，我们回顾了经典的 C10K 和 C1000K 问题。简单回顾一下，C10K 是指如何单机同时处理 1 万个请求（并发连接 1 万）的问题，而 C1000K 则是单机支持处理 100 万个请求（并发连接 100 万）的问题。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/36__%E5%A5%97%E8%B7%AF%E7%AF%87%E6%80%8E%E4%B9%88%E8%AF%84%E4%BC%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/36__%E5%A5%97%E8%B7%AF%E7%AF%87%E6%80%8E%E4%B9%88%E8%AF%84%E4%BC%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="36__套路篇：怎么评估系统的网络性能？">
  <meta property="og:description" content="你好，我是倪朋飞。
上一节，我们回顾了经典的 C10K 和 C1000K 问题。简单回顾一下，C10K 是指如何单机同时处理 1 万个请求（并发连接 1 万）的问题，而 C1000K 则是单机支持处理 100 万个请求（并发连接 100 万）的问题。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Linux性能优化实战">

  <meta itemprop="name" content="36__套路篇：怎么评估系统的网络性能？">
  <meta itemprop="description" content="你好，我是倪朋飞。
上一节，我们回顾了经典的 C10K 和 C1000K 问题。简单回顾一下，C10K 是指如何单机同时处理 1 万个请求（并发连接 1 万）的问题，而 C1000K 则是单机支持处理 100 万个请求（并发连接 100 万）的问题。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6364">
  <meta itemprop="keywords" content="Linux性能优化实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="36__套路篇：怎么评估系统的网络性能？">
  <meta name="twitter:description" content="你好，我是倪朋飞。
上一节，我们回顾了经典的 C10K 和 C1000K 问题。简单回顾一下，C10K 是指如何单机同时处理 1 万个请求（并发连接 1 万）的问题，而 C1000K 则是单机支持处理 100 万个请求（并发连接 100 万）的问题。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">36__套路篇：怎么评估系统的网络性能？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6364 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#性能指标回顾">性能指标回顾</a></li>
        <li><a href="#网络基准测试">网络基准测试</a></li>
        <li><a href="#各协议层的性能测试">各协议层的性能测试</a>
          <ul>
            <li><a href="#转发性能">转发性能</a></li>
            <li><a href="#tcpudp-性能">TCP/UDP 性能</a></li>
            <li><a href="#http-性能">HTTP 性能</a></li>
            <li><a href="#应用负载性能">应用负载性能</a></li>
          </ul>
        </li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#思考">思考</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是倪朋飞。</p>
<p>上一节，我们回顾了经典的 C10K 和 C1000K 问题。简单回顾一下，C10K 是指如何单机同时处理 1 万个请求（并发连接 1 万）的问题，而 C1000K 则是单机支持处理 100 万个请求（并发连接 100 万）的问题。</p>
<p>I/O 模型的优化，是解决 C10K 问题的最佳良方。Linux 2.6 中引入的 epoll，完美解决了 C10K 的问题，并一直沿用至今。今天的很多高性能网络方案，仍都基于 epoll。</p>
<p>自然，随着互联网技术的普及，催生出更高的性能需求。从 C10K 到 C100K，我们只需要增加系统的物理资源，就可以满足要求；但从 C100K 到 C1000K，光增加物理资源就不够了。</p>
<p>这时，就要对系统的软硬件进行统一优化，从硬件的中断处理，到网络协议栈的文件描述符数量、连接状态跟踪、缓存队列，再到应用程序的工作模型等的整个网络链路，都需要深入优化。</p>
<p>再进一步，要实现 C10M，就不是增加物理资源、调优内核和应用程序可以解决的问题了。这时内核中冗长的网络协议栈就成了最大的负担。</p>
<ul>
<li>需要用 XDP 方式，在内核协议栈之前，先处理网络包。</li>
<li>或基于 DPDK，直接跳过网络协议栈，在用户空间通过轮询的方式处理。</li>
</ul>
<p>其中，DPDK 是目前最主流的高性能网络方案，不过，这需要能支持 DPDK 的网卡配合使用。</p>
<p>当然，实际上，在大多数场景中，我们并不需要单机并发 1000 万请求。通过调整系统架构，把请求分发到多台服务器中并行处理，才是更简单、扩展性更好的方案。</p>
<p>不过，这种情况下，就需要我们评估系统的网络性能，以便考察系统的处理能力，并为容量规划提供基准数据。</p>
<p>那么，到底该怎么评估网络的性能呢？今天，我就带你一起来看看这个问题。</p>
<h2 id="性能指标回顾">性能指标回顾</h2>
<p>在评估网络性能前，我们先来回顾一下，衡量网络性能的指标。在 Linux 网络基础篇中，我们曾经说到，带宽、吞吐量、延时、PPS 等，都是最常用的网络性能指标。还记得它们的具体含义吗？你可以先思考一下，再继续下面的内容。</p>
<p>首先，<strong>带宽</strong>，表示链路的最大传输速率，单位是 b/s（比特 / 秒）。在你为服务器选购网卡时，带宽就是最核心的参考指标。常用的带宽有 1000M、10G、40G、100G 等。</p>
<p>第二，<strong>吞吐量</strong>，表示没有丢包时的最大数据传输速率，单位通常为 b/s（比特 / 秒）或者 B/s（字节 / 秒）。吞吐量受带宽的限制，吞吐量 / 带宽也就是该网络链路的使用率。</p>
<p>第三，<strong>延时</strong>，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。这个指标在不同场景中可能会有不同的含义。它可以表示建立连接需要的时间（比如 TCP 握手延时），或者一个数据包往返所需时间（比如 RTT）。</p>
<p>最后，<strong>PPS</strong>，是 Packet Per Second（包 / 秒）的缩写，表示以网络包为单位的传输速率。PPS 通常用来评估网络的转发能力，而基于 Linux 服务器的转发，很容易受到网络包大小的影响（交换机通常不会受到太大影响，即交换机可以线性转发）。</p>
<p>这四个指标中，带宽跟物理网卡配置是直接关联的。一般来说，网卡确定后，带宽也就确定了（当然，实际带宽会受限于整个网络链路中最小的那个模块）。</p>
<p>另外，你可能在很多地方听说过“网络带宽测试”，这里测试的实际上不是带宽，而是网络吞吐量。Linux 服务器的网络吞吐量一般会比带宽小，而对交换机等专门的网络设备来说，吞吐量一般会接近带宽。</p>
<p>最后的 PPS，则是以网络包为单位的网络传输速率，通常用在需要大量转发的场景中。而对 TCP 或者 Web 服务来说，更多会用并发连接数和每秒请求数（QPS，Query per Second）等指标，它们更能反应实际应用程序的性能。</p>
<h2 id="网络基准测试">网络基准测试</h2>
<p>熟悉了网络的性能指标后，接下来，我们再来看看，如何通过性能测试来确定这些指标的基准值。</p>
<p>你可以先思考一个问题。我们已经知道，Linux 网络基于 TCP/IP 协议栈，而不同协议层的行为显然不同。那么，测试之前，你应该弄清楚，你要评估的网络性能，究竟属于协议栈的哪一层？换句话说，你的应用程序基于协议栈的哪一层呢？</p>
<p>根据前面学过的 TCP/IP 协议栈的原理，这个问题应该不难回答。比如：</p>
<ul>
<li>基于 HTTP 或者 HTTPS 的 Web 应用程序，显然属于应用层，需要我们测试 HTTP/HTTPS 的性能；</li>
<li>而对大多数游戏服务器来说，为了支持更大的同时在线人数，通常会基于 TCP 或 UDP，与客户端进行交互，这时就需要我们测试 TCP/UDP 的性能；</li>
<li>当然，还有一些场景，是把 Linux 作为一个软交换机或者路由器来用的。这种情况下，你更关注网络包的处理能力（即 PPS），重点关注网络层的转发性能。</li>
</ul>
<p>接下来，我就带你从下往上，了解不同协议层的网络性能测试方法。不过要注意，低层协议是其上的各层网络协议的基础。自然，低层协议的性能，也就决定了高层的网络性能。</p>
<p>注意，以下所有的测试方法，都需要两台 Linux 虚拟机。其中一台，可以当作待测试的目标机器；而另一台，则可以当作正在运行网络服务的客户端，用来运行测试工具。</p>
<h2 id="各协议层的性能测试">各协议层的性能测试</h2>
<h3 id="转发性能">转发性能</h3>
<p>我们首先来看，网络接口层和网络层，它们主要负责网络包的封装、寻址、路由以及发送和接收。在这两个网络协议层中，每秒可处理的网络包数 PPS，就是最重要的性能指标。特别是 64B 小包的处理能力，值得我们特别关注。那么，如何来测试网络包的处理能力呢？</p>
<p>说到网络包相关的测试，你可能会觉得陌生。不过，其实在专栏开头的 CPU 性能篇中，我们就接触过一个相关工具，也就是软中断案例中的 hping3。</p>
<p>在那个案例中，hping3 作为一个 SYN 攻击的工具来使用。实际上，hping3 更多的用途，是作为一个测试网络包处理能力的性能工具。</p>
<p>今天我再来介绍另一个更常用的工具，Linux 内核自带的高性能网络测试工具 <a href="./pktgen.md">pktgen</a>。pktgen 支持丰富的自定义选项，方便你根据实际需要构造所需网络包，从而更准确地测试出目标服务器的性能。</p>
<p>不过，在 Linux 系统中，你并不能直接找到 pktgen 命令。因为 pktgen 作为一个内核线程来运行，需要你加载 pktgen 内核模块后，再通过 /proc 文件系统来交互。下面就是 pktgen 启动的两个内核线程和 /proc 文件系统的交互文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ modprobe pktgen
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ ps -ef | grep pktgen | grep -v grep
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">root     26384     2  0 06:17 ?        00:00:00 [kpktgend_0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">root     26385     2  0 06:17 ?        00:00:00 [kpktgend_1]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ ls /proc/net/pktgen/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kpktgend_0  kpktgend_1  pgctrl
</span></span></code></pre></td></tr></table>
</div>
</div><p>pktgen 在每个 CPU 上启动一个内核线程，并可以通过 /proc/net/pktgen 下面的同名文件，跟这些线程交互；而 pgctrl 则主要用来控制这次测试的开启和停止。</p>
<blockquote>
<p>如果 modprobe 命令执行失败，说明你的内核没有配置 CONFIG_NET_PKTGEN 选项。这就需要你配置 pktgen 内核模块（即 CONFIG_NET_PKTGEN=m）后，重新编译内核，才可以使用。</p>
</blockquote>
<p>在使用 pktgen 测试网络性能时，需要先给每个内核线程 kpktgend_X 以及测试网卡，配置 pktgen 选项，然后再通过 pgctrl 启动测试。</p>
<p>以发包测试为例，假设发包机器使用的网卡是 eth0，而目标机器的 IP 地址为 192.168.0.30，MAC 地址为 11:11:11:11:11:11。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/193d508cd4c156e8a7cbc73d1ef838f2.png" alt=""></p>
<p>接下来，就是一个发包测试的示例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 定义一个工具函数，方便后面配置各种测试选项
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">function pgset() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    local result
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    echo $1 &gt; $PGDEV
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     result=`cat $PGDEV | fgrep &#34;Result: OK:&#34;`
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if [ &#34;$result&#34; = &#34;&#34; ]; then
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         cat $PGDEV | fgrep Result:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    fi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> # 为 0 号线程绑定 eth0 网卡
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PGDEV=/proc/net/pktgen/kpktgend_0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pgset &#34;rem_device_all&#34;   # 清空网卡绑定
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pgset &#34;add_device eth0&#34;  # 添加 eth0 网卡
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> # 配置 eth0 网卡的测试选项
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PGDEV=/proc/net/pktgen/eth0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pgset &#34;count 1000000&#34;    # 总发包数量
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pgset &#34;delay 5000&#34;       # 不同包之间的发送延迟 (单位纳秒)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pgset &#34;clone_skb 0&#34;      # SKB 包复制
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pgset &#34;pkt_size 64&#34;      # 网络包大小
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pgset &#34;dst 192.168.0.30&#34; # 目的 IP
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pgset &#34;dst_mac 11:11:11:11:11:11&#34;  # 目的 MAC
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> # 启动测试
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PGDEV=/proc/net/pktgen/pgctrl
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pgset &#34;start&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>稍等一会儿，测试完成后，结果可以从 /proc 文件系统中获取。通过下面代码段中的内容，我们可以查看刚才的测试报告：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cat /proc/net/pktgen/eth0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Params: count 1000000  min_pkt_size: 64  max_pkt_size: 64
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     frags: 0  delay: 0  clone_skb: 0  ifname: eth0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     flows: 0 flowlen: 0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Current:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     pkts-sofar: 1000000  errors: 0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     started: 1534853256071us  stopped: 1534861576098us idle: 70673us
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Result: OK: 8320027(c8249354+d70673) usec, 1000000 (64byte,0frags)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  120191pps 61Mb/sec (61537792bps) errors: 0
</span></span></code></pre></td></tr></table>
</div>
</div><p>你可以看到，测试报告主要分为三个部分：</p>
<ul>
<li>第一部分的 Params 是测试选项；</li>
<li>第二部分的 Current 是测试进度，其中，packts so far（pkts-sofar）表示已经发送了 100 万个包，也就表明测试已完成。</li>
<li>第三部分的 Result 是测试结果，包含测试所用时间、网络包数量和分片、PPS、吞吐量以及错误数。</li>
</ul>
<p>根据上面的结果，我们发现，PPS 为 12 万，吞吐量为 61 Mb/s，没有发生错误。那么，12 万的 PPS 好不好呢？</p>
<p>作为对比，你可以计算一下千兆交换机的 PPS。交换机可以达到线速（满负载时，无差错转发），它的 PPS 就是 1000Mbit 除以以太网帧的大小，即 1000Mbps/((64+20)*8bit) = 1.5 Mpps（其中，20B 为以太网帧前导和帧间距的大小）。</p>
<p>你看，即使是千兆交换机的 PPS，也可以达到 150 万 PPS，比我们测试得到的 12 万大多了。所以，看到这个数值你并不用担心，现在的多核服务器和万兆网卡已经很普遍了，稍做优化就可以达到数百万的 PPS。而且，如果你用了上节课讲到的 DPDK 或 XDP，还能达到千万数量级。</p>
<h3 id="tcpudp-性能">TCP/UDP 性能</h3>
<p>掌握了 PPS 的测试方法，接下来，我们再来看 TCP 和 UDP 的性能测试方法。说到 TCP 和 UDP 的测试，我想你已经很熟悉了，甚至可能一下子就能想到相应的测试工具，比如 iperf 或者 netperf。</p>
<p>特别是现在的云计算时代，在你刚拿到一批虚拟机时，首先要做的，应该就是用 iperf，测试一下网络性能是否符合预期。</p>
<p>iperf 和 netperf 都是最常用的网络性能测试工具，测试 TCP 和 UDP 的吞吐量。它们都以客户端和服务器通信的方式，测试一段时间内的平均吞吐量。</p>
<p>接下来，我们就以 iperf 为例，看一下 TCP 性能的测试方法。目前，iperf 的最新版本为 iperf3，你可以运行下面的命令来安装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Ubuntu
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apt-get install iperf3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># CentOS
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">yum install iperf3
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，在目标机器上启动 iperf 服务端：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># -s 表示启动服务端，-i 表示汇报间隔，-p 表示监听端口
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ iperf3 -s -i 1 -p 10000
</span></span></code></pre></td></tr></table>
</div>
</div><p>接着，在另一台机器上运行 iperf 客户端，运行测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># -c 表示启动客户端，192.168.0.30 为目标服务器的 IP
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># -b 表示目标带宽 (单位是 bits/s)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># -t 表示测试时间
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># -P 表示并发数，-p 表示目标服务器监听端口
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ iperf3 -c 192.168.0.30 -b 1G -t 15 -P 2 -p 10000
</span></span></code></pre></td></tr></table>
</div>
</div><p>稍等一会儿（15 秒）测试结束后，回到目标服务器，查看 iperf 的报告：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[ ID] Interval           Transfer     Bandwidth
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[SUM]   0.00-15.04  sec  0.00 Bytes  0.00 bits/sec                  sender
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[SUM]   0.00-15.04  sec  1.51 GBytes   860 Mbits/sec                  receiver
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后的 SUM 行就是测试的汇总结果，包括测试时间、数据传输量以及带宽等。按照发送和接收，这一部分又分为了 sender 和 receiver 两行。</p>
<p>从测试结果你可以看到，这台机器 TCP 接收的带宽（吞吐量）为 860 Mb/s，跟目标的 1Gb/s 相比，还是有些差距的。</p>
<h3 id="http-性能">HTTP 性能</h3>
<p>从传输层再往上，到了应用层。有的应用程序，会直接基于 TCP 或 UDP 构建服务。当然，也有大量的应用，基于应用层的协议来构建服务，HTTP 就是最常用的一个应用层协议。比如，常用的 Apache、Nginx 等各种 Web 服务，都是基于 HTTP。</p>
<p>要测试 HTTP 的性能，也有大量的工具可以使用，比如 ab、webbench 等，都是常用的 HTTP 压力测试工具。其中，ab 是 Apache 自带的 HTTP 压测工具，主要测试 HTTP 服务的每秒请求数、请求延迟、吞吐量以及请求延迟的分布情况等。</p>
<p>运行下面的命令，你就可以安装 ab 工具：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Ubuntu</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> <span class="n">apache2</span><span class="o">-</span><span class="n">utils</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># CentOS</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="n">yum</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> <span class="n">httpd</span><span class="o">-</span><span class="n">tools</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，在目标机器上，使用 Docker 启动一个 Nginx 服务，然后用 ab 来测试它的性能。首先，在目标机器上运行下面的命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker run -p 80:80 -itd nginx
</span></span></code></pre></td></tr></table>
</div>
</div><p>而在另一台机器上，运行 ab 命令，测试 Nginx 的性能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># -c 表示并发请求数为 1000，-n 表示总的请求数为 10000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ ab -c 1000 -n 10000 http://192.168.0.30/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Server Software:        nginx/1.15.8
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Server Hostname:        192.168.0.30
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Server Port:            80
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> Requests per second:    1078.54 [#/sec] (mean)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Time per request:       927.183 [ms] (mean)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Time per request:       0.927 [ms] (mean, across all concurrent requests)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Transfer rate:          890.00 [Kbytes/sec] received
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> Connection Times (ms)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              min  mean[+/-sd] median   max
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Connect:        0   27 152.1      1    1038
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Processing:     9  207 843.0     22    9242
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Waiting:        8  207 843.0     22    9242
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Total:         15  233 857.7     23    9268
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> Percentage of the requests served within a certain time (ms)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  50%     23
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  66%     24
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  75%     24
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  80%     26
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  90%    274
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  95%   1195
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  98%   2335
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  99%   4663
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 100%   9268 (longest request)
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，ab 的测试结果分为三个部分，分别是请求汇总、连接时间汇总还有请求延迟汇总。以上面的结果为例，我们具体来看。</p>
<p>在请求汇总部分，你可以看到：</p>
<ul>
<li>Requests per second 为 1074；</li>
<li>每个请求的延迟（Time per request）分为两行，第一行的 927 ms 表示平均延迟，包括了线程运行的调度时间和网络请求响应时间，而下一行的 0.927ms，则表示实际请求的响应时间；</li>
<li>Transfer rate 表示吞吐量（BPS）为 890 KB/s。</li>
</ul>
<p>连接时间汇总部分，则是分别展示了建立连接、请求、等待以及汇总等的各类时间，包括最小、最大、平均以及中值处理时间。</p>
<p>最后的请求延迟汇总部分，则给出了不同时间段内处理请求的百分比，比如，90% 的请求，都可以在 274ms 内完成。</p>
<h3 id="应用负载性能">应用负载性能</h3>
<p>当你用 iperf 或者 ab 等测试工具，得到 TCP、HTTP 等的性能数据后，这些数据是否就能表示应用程序的实际性能呢？我想，你的答案应该是否定的。</p>
<p>比如，你的应用程序基于 HTTP 协议，为最终用户提供一个 Web 服务。这时，使用 ab 工具，可以得到某个页面的访问性能，但这个结果跟用户的实际请求，很可能不一致。因为用户请求往往会附带着各种各种的负载（payload），而这些负载会影响 Web 应用程序内部的处理逻辑，从而影响最终性能。</p>
<p>那么，为了得到应用程序的实际性能，就要求性能工具本身可以模拟用户的请求负载，而 iperf、ab 这类工具就无能为力了。幸运的是，我们还可以用 wrk、TCPCopy、Jmeter 或者 LoadRunner 等实现这个目标。</p>
<p>以 <a href="./wrk.md">wrk</a> 为例，它是一个 HTTP 性能测试工具，内置了 LuaJIT，方便你根据实际需求，生成所需的请求负载，或者自定义响应的处理方法。</p>
<p>wrk 工具本身不提供 yum 或 apt 的安装方法，需要通过源码编译来安装。比如，你可以运行下面的命令，来编译和安装 wrk：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ https://github.com/wg/wrk
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cd wrk
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ apt-get install build-essential -y
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ make
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ sudo cp wrk /usr/local/bin/
</span></span></code></pre></td></tr></table>
</div>
</div><p>wrk 的命令行参数比较简单。比如，我们可以用 wrk，来重新测一下前面已经启动的 Nginx 的性能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># -c 表示并发连接数 1000，-t 表示线程数为 2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ wrk -c 1000 -t 2 http://192.168.0.30/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Running 10s test @ http://192.168.0.30/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  2 threads and 1000 connections
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Thread Stats   Avg      Stdev     Max   +/- Stdev
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Latency    65.83ms  174.06ms   1.99s    95.85%
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Req/Sec     4.87k   628.73     6.78k    69.00%
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  96954 requests in 10.06s, 78.59MB read
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Socket errors: connect 0, read 0, write 0, timeout 179
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Requests/sec:   9641.31
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Transfer/sec:      7.82MB
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里使用 2 个线程、并发 1000 连接，重新测试了 Nginx 的性能。你可以看到，每秒请求数为 9641，吞吐量为 7.82MB，平均延迟为 65ms，比前面 ab 的测试结果要好很多。</p>
<p>这也说明，性能工具本身的性能，对性能测试也是至关重要的。不合适的性能工具，并不能准确测出应用程序的最佳性能。</p>
<p>当然，wrk 最大的优势，是其内置的 LuaJIT，可以用来实现复杂场景的性能测试。wrk 在调用 Lua 脚本时，可以将 HTTP 请求分为三个阶段，即 setup、running、done，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/1bc969082f9fd873239a17fc01180265.png" alt=""></p>
<p>（图片来自<a href="./200008406328934400.md">网易云博客</a>）</p>
<p>比如，你可以在 setup 阶段，为请求设置认证参数（来自于 wrk 官方<a href="./auth.lua.md">示例</a>）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-- example script that demonstrates response handling and
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-- retrieving an authentication token to set on all future
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-- requests
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> token = nil
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">path  = &#34;/authenticate&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> request = function()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   return wrk.format(&#34;GET&#34;, path)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">end
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> response = function(status, headers, body)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   if not token and status == 200 then
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      token = headers[&#34;X-Token&#34;]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      path  = &#34;/resource&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      wrk.headers[&#34;X-Token&#34;] = token
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   end
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">end
</span></span></code></pre></td></tr></table>
</div>
</div><p>而在执行测试时，通过 -s 选项，执行脚本的路径：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ wrk -c 1000 -t 2 -s auth.lua http://192.168.0.30/
</span></span></code></pre></td></tr></table>
</div>
</div><p>wrk 需要你用 Lua 脚本，来构造请求负载。这对于大部分场景来说，可能已经足够了。不过，它的缺点也正是，所有东西都需要代码来构造，并且工具本身不提供 GUI 环境。</p>
<p>像 Jmeter 或者 LoadRunner（商业产品），则针对复杂场景提供了脚本录制、回放、GUI 等更丰富的功能，使用起来也更加方便。</p>
<h2 id="小结">小结</h2>
<p>今天，我带你一起回顾了网络的性能指标，并学习了网络性能的评估方法。</p>
<p>性能评估是优化网络性能的前提，只有在你发现网络性能瓶颈时，才需要进行网络性能优化。根据 TCP/IP 协议栈的原理，不同协议层关注的性能重点不完全一样，也就对应不同的性能测试方法。比如，</p>
<ul>
<li>在应用层，你可以使用 wrk、Jmeter 等模拟用户的负载，测试应用程序的每秒请求数、处理延迟、错误数等；</li>
<li>而在传输层，则可以使用 iperf 等工具，测试 TCP 的吞吐情况；</li>
<li>再向下，你还可以用 Linux 内核自带的 pktgen，测试服务器的 PPS。</li>
</ul>
<p>由于低层协议是高层协议的基础。所以，一般情况下，我们需要从上到下，对每个协议层进行性能测试，然后根据性能测试的结果，结合 Linux 网络协议栈的原理，找出导致性能瓶颈的根源，进而优化网络性能。</p>
<h2 id="思考">思考</h2>
<p>最后，我想请你来聊一聊。</p>
<ul>
<li>你是如何评估网络性能的？</li>
<li>在评估网络性能时，你会从哪个协议层、选择哪些指标，作为性能测试最核心的目标？</li>
<li>你又会用哪些工具，测试并分析网络的性能呢？</li>
</ul>
<p>你可以结合今天学到的网络知识，总结自己的思路。</p>
<p>欢迎在留言区和我讨论，也欢迎你把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/f3ab291e71ad0a9d7fe2c894ccb9706a.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/">Linux性能优化实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/36__%E5%AE%9E%E6%88%98%E4%BA%8C%E4%B8%8A%E7%A8%8B%E5%BA%8F%E5%87%BA%E9%94%99%E8%AF%A5%E8%BF%94%E5%9B%9E%E5%95%A5null%E5%BC%82%E5%B8%B8%E9%94%99%E8%AF%AF%E7%A0%81%E7%A9%BA%E5%AF%B9%E8%B1%A1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">36__实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2/36__%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/">
            <span class="next-text nav-default">36__为什么临时表可以重名？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
