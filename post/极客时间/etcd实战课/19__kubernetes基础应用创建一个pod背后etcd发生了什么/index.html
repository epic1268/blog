<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>19__Kubernetes基础应用：创建一个Pod背后etcd发生了什么？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是唐聪。
今天我将通过在 Kubernetes 集群中创建一个 Pod 的案例，为你分析 etcd 在其中发挥的作用，带你深入了解 Kubernetes 是如何使用 etcd 的。
希望通过本节课，帮助你从 etcd 的角度更深入理解 Kubernetes，让你知道在 Kubernetes 集群中每一步操作的背后，etcd 会发生什么。更进一步，当你在 Kubernetes 集群中遇到 etcd 相关错误的时候，能从 etcd 角度理解错误含义，高效进行故障诊断。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/etcd%E5%AE%9E%E6%88%98%E8%AF%BE/19__kubernetes%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AApod%E8%83%8C%E5%90%8Eetcd%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/etcd%E5%AE%9E%E6%88%98%E8%AF%BE/19__kubernetes%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AApod%E8%83%8C%E5%90%8Eetcd%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="19__Kubernetes基础应用：创建一个Pod背后etcd发生了什么？">
  <meta property="og:description" content="你好，我是唐聪。
今天我将通过在 Kubernetes 集群中创建一个 Pod 的案例，为你分析 etcd 在其中发挥的作用，带你深入了解 Kubernetes 是如何使用 etcd 的。
希望通过本节课，帮助你从 etcd 的角度更深入理解 Kubernetes，让你知道在 Kubernetes 集群中每一步操作的背后，etcd 会发生什么。更进一步，当你在 Kubernetes 集群中遇到 etcd 相关错误的时候，能从 etcd 角度理解错误含义，高效进行故障诊断。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Etcd实战课">

  <meta itemprop="name" content="19__Kubernetes基础应用：创建一个Pod背后etcd发生了什么？">
  <meta itemprop="description" content="你好，我是唐聪。
今天我将通过在 Kubernetes 集群中创建一个 Pod 的案例，为你分析 etcd 在其中发挥的作用，带你深入了解 Kubernetes 是如何使用 etcd 的。
希望通过本节课，帮助你从 etcd 的角度更深入理解 Kubernetes，让你知道在 Kubernetes 集群中每一步操作的背后，etcd 会发生什么。更进一步，当你在 Kubernetes 集群中遇到 etcd 相关错误的时候，能从 etcd 角度理解错误含义，高效进行故障诊断。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7343">
  <meta itemprop="keywords" content="Etcd实战课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="19__Kubernetes基础应用：创建一个Pod背后etcd发生了什么？">
  <meta name="twitter:description" content="你好，我是唐聪。
今天我将通过在 Kubernetes 集群中创建一个 Pod 的案例，为你分析 etcd 在其中发挥的作用，带你深入了解 Kubernetes 是如何使用 etcd 的。
希望通过本节课，帮助你从 etcd 的角度更深入理解 Kubernetes，让你知道在 Kubernetes 集群中每一步操作的背后，etcd 会发生什么。更进一步，当你在 Kubernetes 集群中遇到 etcd 相关错误的时候，能从 etcd 角度理解错误含义，高效进行故障诊断。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">19__Kubernetes基础应用：创建一个Pod背后etcd发生了什么？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7343 字 </span>
          <span class="more-meta"> 预计阅读 15 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#kubernetes-基础架构">Kubernetes 基础架构</a></li>
        <li><a href="#创建-pod-案例">创建 Pod 案例</a></li>
        <li><a href="#kube-apiserver-请求执行链路">kube-apiserver 请求执行链路</a></li>
        <li><a href="#kubernetes-资源存储格式">Kubernetes 资源存储格式</a></li>
        <li><a href="#通用存储模块">通用存储模块</a>
          <ul>
            <li><a href="#资源安全创建及更新">资源安全创建及更新</a></li>
          </ul>
        </li>
        <li><a href="#watch-机制在-kubernetes-中应用">Watch 机制在 Kubernetes 中应用</a>
          <ul>
            <li><a href="#resource-version-与-etcd-版本号">Resource Version 与 etcd 版本号</a></li>
          </ul>
        </li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是唐聪。</p>
<p>今天我将通过在 Kubernetes 集群中创建一个 Pod 的案例，为你分析 etcd 在其中发挥的作用，带你深入了解 Kubernetes 是如何使用 etcd 的。</p>
<p>希望通过本节课，帮助你从 etcd 的角度更深入理解 Kubernetes，让你知道在 Kubernetes 集群中每一步操作的背后，etcd 会发生什么。更进一步，当你在 Kubernetes 集群中遇到 etcd 相关错误的时候，能从 etcd 角度理解错误含义，高效进行故障诊断。</p>
<h2 id="kubernetes-基础架构">Kubernetes 基础架构</h2>
<p>在带你详细了解 etcd 在 Kubernetes 里的应用之前，我先和你简单介绍下 Kubernetes 集群的整体架构，帮你搞清楚 etcd 在 Kubernetes 集群中扮演的角色与作用。</p>
<p>下图是 Kubernetes 集群的架构图（引用自 Kubernetes 官方文档），从图中你可以看到，它由 Master 节点和 Node 节点组成。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/etcd%E5%AE%9E%E6%88%98%E8%AF%BE/de84a49df64c8b22ba2f1e810e6bd10d.png" alt=""></p>
<p>控制面 Master 节点主要包含以下组件：</p>
<ol>
<li>kube-apiserver，负责对外提供集群各类资源的增删改查及 Watch 接口，它是 Kubernetes 集群中各组件数据交互和通信的枢纽。kube-apiserver 在设计上可水平扩展，高可用 Kubernetes 集群中一般多副本部署。当收到一个创建 Pod 写请求时，它的基本流程是对请求进行认证、限速、授权、准入机制等检查后，写入到 etcd 即可。</li>
<li>kube-scheduler 是调度器组件，负责集群 Pod 的调度。基本原理是通过监听 kube-apiserver 获取待调度的 Pod，然后基于一系列筛选和评优算法，为 Pod 分配最佳的 Node 节点。</li>
<li>kube-controller-manager 包含一系列的控制器组件，比如 Deployment、StatefulSet 等控制器。控制器的核心思想是监听、比较资源实际状态与期望状态是否一致，若不一致则进行协调工作使其最终一致。</li>
<li>etcd 组件，Kubernetes 的元数据存储。</li>
</ol>
<p>Node 节点主要包含以下组件：</p>
<ol>
<li>kubelet，部署在每个节点上的 Agent 的组件，负责 Pod 的创建运行。基本原理是通过监听 APIServer 获取分配到其节点上的 Pod，然后根据 Pod 的规格详情，调用运行时组件创建 pause 和业务容器等。</li>
<li>kube-proxy，部署在每个节点上的网络代理组件。基本原理是通过监听 APIServer 获取 Service、Endpoint 等资源，基于 Iptables、IPVS 等技术实现数据包转发等功能。</li>
</ol>
<p>从 Kubernetes 基础架构介绍中你可以看到，kube-apiserver 是唯一直接与 etcd 打交道的组件，各组件都通过 kube-apiserver 实现数据交互，它们极度依赖 kube-apiserver 提供的资源变化<strong>监听机制</strong>。而 kube-apiserver 对外提供的监听机制，也正是由我们基础篇08中介绍的 etcd <strong>Watch 特性</strong>提供的底层支持。</p>
<h2 id="创建-pod-案例">创建 Pod 案例</h2>
<p>接下来我们就以在 Kubernetes 集群中创建一个 nginx 服务为例，通过这个案例来详细分析 etcd 在 Kubernetes 集群创建 Pod 背后是如何工作的。</p>
<p>下面是创建一个 nginx 服务的 YAML 文件，Workload 是 Deployment，期望的副本数是 1。</p>
<p>apiVersion: apps/v1<br>
kind: Deployment<br>
metadata:<br>
name: nginx-deployment<br>
labels:<br>
app: nginx<br>
spec:<br>
replicas: 1<br>
selector:<br>
matchLabels:<br>
app: nginx<br>
template:<br>
metadata:<br>
labels:<br>
app: nginx<br>
spec:<br>
containers:<br>
- name: nginx<br>
image: nginx:1.14.2<br>
ports:<br>
- containerPort: 80</p>
<p>假设此 YAML 文件名为 nginx.yaml，首先我们通过如下的 kubectl create -f nginx.yml 命令创建 Deployment 资源。</p>
<p>$ kubectl create -f nginx.yml<br>
deployment.apps/nginx-deployment created</p>
<p>创建之后，我们立刻通过如下命令，带标签查询 Pod，输出如下：</p>
<p>$ kubectl get po -l app=nginx<br>
NAME                                READY   STATUS    RESTARTS   AGE<br>
nginx-deployment-756d9fd5f9-fkqnf   1/1     Running   0          8s</p>
<p>那么在 kubectl create 命令发出，nginx Deployment 资源成功创建的背后，kube-apiserver 是如何与 etcd 打交道的呢？它是通过什么接口<strong>安全写入</strong>资源到 etcd 的？</p>
<p>同时，使用 kubectl 带标签查询 Pod 背后，kube-apiserver 是直接从<strong>缓存读取</strong>还是向 etcd 发出一个<strong>线性读</strong>或<strong>串行读</strong>请求呢？若同 namespace 下存在大量的 Pod，此操作性能又是怎样的呢？</p>
<p>接下来我就和你聊聊 kube-apiserver 收到创建和查询请求后，是如何与 etcd 交互的。</p>
<h2 id="kube-apiserver-请求执行链路">kube-apiserver 请求执行链路</h2>
<p>kube-apiserver 作为 Kubernetes 集群交互的枢纽、对外提供 API 供用户访问的组件，因此保障集群安全、保障本身及后端 etcd 的稳定性的等重任也是非它莫属。比如校验创建请求发起者是否合法、是否有权限操作相关资源、是否出现 Bug 产生大量写和读请求等。</p>
<p>下图是 kube-apiserver 的请求执行链路（引用自 sttts 分享的 PDF），当收到一个请求后，它主要经过以下处理链路来完成以上若干职责后，才能与 etcd 交互。</p>
<p>核心链路如下：</p>
<ol>
<li>认证模块，校验发起的请求的用户身份是否合法。支持多种方式，比如 x509 客户端证书认证、静态 token 认证、webhook 认证等。</li>
<li>限速模块，对请求进行简单的限速，默认读 400/s 写 200/s，不支持根据请求类型进行分类、按优先级限速，存在较多问题。Kubernetes 1.19 后已新增 Priority and Fairness 特性取代它，它支持将请求重要程度分类进行限速，支持多租户，可有效保障 Leader 选举之类的高优先级请求得到及时响应，能防止一个异常 client 导致整个集群被限速。</li>
<li>审计模块，可记录用户对资源的详细操作行为。</li>
<li>授权模块，检查用户是否有权限对其访问的资源进行相关操作。支持多种方式，RBAC(Role-based access control)、ABAC(Attribute-based access control)、Webhhook 等。Kubernetes 1.12 版本后，默认授权机制使用的 RBAC。</li>
<li>准入控制模块，提供在访问资源前拦截请求的静态和动态扩展能力，比如要求镜像的拉取策略始终为 AlwaysPullImages。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/etcd%E5%AE%9E%E6%88%98%E8%AF%BE/f4f9a855a597602d3046cf768711b3e9.png" alt=""></p>
<p>经过上面一系列的模块检查后，这时 kube-apiserver 就开始与 etcd 打交道了。在了解 kube-apiserver 如何将我们创建的 Deployment 资源写入到 etcd 前，我先和你介绍下 Kubernetes 的资源是如何组织、存储在 etcd 中。</p>
<h2 id="kubernetes-资源存储格式">Kubernetes 资源存储格式</h2>
<p>我们知道 etcd 仅仅是个 key-value 存储，但是在 Kubernetes 中存在各种各样的资源，并提供了以下几种灵活的资源查询方式：</p>
<ol>
<li>按具体资源名称查询，比如 PodName、kubectl get po/PodName。</li>
<li>按 namespace 查询，获取一个 namespace 下的所有 Pod，比如 kubectl get po -n kube-system。</li>
<li>按标签名，标签是极度灵活的一种方式，你可以为你的 Kubernetes 资源打上各种各样的标签，比如上面案例中的 kubectl get po -l app=nginx。</li>
</ol>
<p>你知道以上这几种查询方式它们的性能优劣吗？假设你是 Kubernetes 开发者，你会如何设计存储格式来满足以上功能点？</p>
<p>首先是按具体资源名称查询。它本质就是个 key-value 查询，只需要写入 etcd 的 key 名称与资源 key 一致即可。</p>
<p>其次是按 namespace 查询。这种查询也并不难。因为我们知道 etcd 支持范围查询，若 key 名称前缀包含 namespace、资源类型，查询的时候指定 namespace 和资源类型的组合的最小开始区间、最大结束区间即可。</p>
<p>最后是标签名查询。这种查询方式非常灵活，业务可随时添加、删除标签，各种标签可相互组合。实现标签查询的办法主要有以下两种：</p>
<ol>
<li>方案一，在 etcd 中存储标签数据，实现通过标签可快速定位（时间复杂度 O(1)）到具体资源名称。然而一个标签可能容易实现，但是在 Kubernetes 集群中，它支持按各个标签组合查询，各个标签组合后的数量相当庞大。在 etcd 中维护各种标签组合对应的资源列表，会显著增加 kube-apiserver 的实现复杂度，导致更频繁的 etcd 写入。</li>
<li>方案二，在 etcd 中不存储标签数据，而是由 kube-apiserver 通过范围遍历 etcd 获取原始数据，然后基于用户指定标签，来筛选符合条件的资源返回给 client。此方案优点是实现简单，但是大量标签查询可能会导致 etcd 大流量等异常情况发生。</li>
</ol>
<p>那么 Kubernetes 集群选择的是哪种实现方式呢？</p>
<p>下面是一个 Kubernetes 集群中的 coredns 一系列资源在 etcd 中的存储格式：</p>
<p>/registry/clusterrolebindings/system:coredns<br>
/registry/clusterroles/system:coredns<br>
/registry/configmaps/kube-system/coredns<br>
/registry/deployments/kube-system/coredns<br>
/registry/events/kube-system/coredns-7fcc6d65dc-6njlg.1662c287aabf742b<br>
/registry/events/kube-system/coredns-7fcc6d65dc-6njlg.1662c288232143ae<br>
/registry/pods/kube-system/coredns-7fcc6d65dc-jvj26<br>
/registry/pods/kube-system/coredns-7fcc6d65dc-mgvtb<br>
/registry/pods/kube-system/coredns-7fcc6d65dc-whzq9<br>
/registry/replicasets/kube-system/coredns-7fcc6d65dc<br>
/registry/secrets/kube-system/coredns-token-hpqbt<br>
/registry/serviceaccounts/kube-system/coredns</p>
<p>从中你可以看到，一方面 Kubernetes 资源在 etcd 中的存储格式由 prefix + &ldquo;/&rdquo; + 资源类型 + &ldquo;/&rdquo; + namespace + &ldquo;/&rdquo; + 具体资源名组成，基于 etcd 提供的范围查询能力，非常简单地支持了按具体资源名称查询和 namespace 查询。</p>
<p>kube-apiserver 提供了如下参数给你配置 etcd prefix，并支持将资源存储在多个 etcd 集群。</p>
<p>&ndash;etcd-prefix string     Default: &ldquo;/registry&rdquo;<br>
The prefix to prepend to all resource paths in etcd.<br>
&ndash;etcd-servers stringSlice<br>
List of etcd servers to connect with (scheme://ip:port), comma separated.<br>
&ndash;etcd-servers-overrides stringSlice<br>
Per-resource etcd servers overrides, comma separated. The individual override format: group/resource#servers, where servers are URLs,<br>
semicolon separated.</p>
<p>另一方面，我们未看到任何标签相关的 key。Kubernetes 实现标签查询的方式显然是方案二，即由 kube-apiserver 通过范围遍历 etcd 获取原始数据，然后基于用户指定标签，来筛选符合条件的资源返回给 client（资源 key 的 value 中记录了资源 YAML 文件内容等，如标签）。</p>
<p>也就是当你执行&quot;kubectl get po -l app=nginx&quot;命令，按标签查询 Pod 时，它会向 etcd 发起一个范围遍历整个 default namespace 下的 Pod 操作。</p>
<p>$ kubectl get po -l app=nginx -v 8<br>
I0301 23:45:25.597465   32411 loader.go:359] Config loaded from file /root/.kube/config<br>
I0301 23:45:25.603182   32411 round_trippers.go:416] GET https://ip:port/api/v1/namespaces/default/pods?<br>
labelSelector=app%3Dnginx&amp;limit=500</p>
<p>etcd 收到的请求日志如下，由此可见当一个 namespace 存在大量 Pod 等资源时，若频繁通过 kubectl，使用标签查询 Pod 等资源，后端 etcd 将出现较大的压力。</p>
<p>{<br>
&ldquo;level&rdquo;:&ldquo;debug&rdquo;,<br>
&ldquo;ts&rdquo;:&ldquo;2021-03-01T23:45:25.609+0800&rdquo;,<br>
&ldquo;caller&rdquo;:&ldquo;v3rpc/interceptor.go:181&rdquo;,<br>
&ldquo;msg&rdquo;:&ldquo;request stats&rdquo;,<br>
&ldquo;start time&rdquo;:&ldquo;2021-03-01T23:45:25.608+0800&rdquo;,<br>
&ldquo;time spent&rdquo;:&ldquo;1.414135ms&rdquo;,<br>
&ldquo;remote&rdquo;:&ldquo;127.0.0.1:44664&rdquo;,<br>
&ldquo;response type&rdquo;:&quot;/etcdserverpb.KV/Range&quot;,<br>
&ldquo;request count&rdquo;:0,<br>
&ldquo;request size&rdquo;:61,<br>
&ldquo;response count&rdquo;:11,<br>
&ldquo;response size&rdquo;:81478,<br>
&ldquo;request content&rdquo;:&ldquo;key:&quot;/registry/pods/default/&rdquo; range_end:&quot;/registry/pods/default0&quot; limit:500 &quot;<br>
}</p>
<p>了解完 Kubernetes 资源的存储格式后，我们再看看 nginx Deployment 资源是如何由 kube-apiserver 写入 etcd 的。</p>
<h2 id="通用存储模块">通用存储模块</h2>
<p>kube-apiserver 启动的时候，会将每个资源的 APIGroup、Version、Resource Handler 注册到路由上。当请求经过认证、限速、授权、准入控制模块检查后，请求就会被转发到对应的资源逻辑进行处理。</p>
<p>同时，kube-apiserver 实现了类似数据库 ORM 机制的通用资源存储机制，提供了对一个资源创建、更新、删除前后的 hook 能力，将其封装成策略接口。当你新增一个资源时，你只需要编写相应的创建、更新、删除等策略即可，不需要写任何 etcd 的 API。</p>
<p>下面是 kube-apiserver 通用存储模块的创建流程图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/etcd%E5%AE%9E%E6%88%98%E8%AF%BE/f824416d57591a248c5c2ccf6966667d.png" alt=""></p>
<p>从图中你可以看到，创建一个资源主要由 BeforeCreate、Storage.Create 以及 AfterCreate 三大步骤组成。</p>
<p>当收到创建 nginx Deployment 请求后，通用存储模块首先会回调各个资源自定义实现的 BeforeCreate 策略，为资源写入 etcd 做一些初始化工作。</p>
<p>下面是 Deployment 资源的创建策略实现，它会进行将 deployment.Generation 设置为 1 等操作。</p>
<p>// PrepareForCreate clears fields that are not allowed to be set by end users on creation.<br>
func (deploymentStrategy) PrepareForCreate(ctx context.Context, obj runtime.Object) {<br>
deployment := obj.(*apps.Deployment)<br>
deployment.Status = apps.DeploymentStatus{}<br>
deployment.Generation = 1</p>
<p>pod.DropDisabledTemplateFields(&amp;deployment.Spec.Template, nil)<br>
}</p>
<p>执行完 BeforeCreate 策略后，它就会执行 Storage.Create 接口，也就是由它真正开始调用底层存储模块 etcd3，将 nginx Deployment 资源对象写入 etcd。</p>
<p>那么 Kubernetes 是使用 etcd Put 接口写入资源 key-value 的吗？如果是，那要如何防止同名资源并发创建被覆盖的问题？</p>
<h3 id="资源安全创建及更新">资源安全创建及更新</h3>
<p>我们知道 etcd 提供了 Put 和 Txn 接口给业务添加 key-value 数据，但是 Put 接口在并发场景下若收到 key 相同的资源创建，就会导致被覆盖。</p>
<p>因此 Kubernetes 很显然无法直接通过 etcd Put 接口来写入数据。</p>
<p>而我们09节中介绍的 etcd 事务接口 Txn，它正是为了多 key 原子更新、并发操作安全性等而诞生的，它提供了丰富的冲突检查机制。</p>
<p>Kubernetes 集群使用的正是事务 Txn 接口来防止并发创建、更新被覆盖等问题。当执行完 BeforeCreate 策略后，这时 kube-apiserver 就会调用 Storage 的模块的 Create 接口写入资源。1.6 版本后的 Kubernete 集群默认使用的存储是 etcd3，它的创建接口简要实现如下：</p>
<p>// Create implements storage.Interface.Create.<br>
func (s *store) Create(ctx context.Context, key string, obj, out runtime.Object, ttl uint64) error {<br>
&hellip;&hellip;<br>
key = path.Join(s.pathPrefix, key)</p>
<p>opts, err := s.ttlOpts(ctx, int64(ttl))<br>
if err != nil {<br>
return err<br>
}</p>
<p>newData, err := s.transformer.TransformToStorage(data, authenticatedDataString(key))<br>
if err != nil {<br>
return storage.NewInternalError(err.Error())<br>
}</p>
<p>startTime := time.Now()<br>
txnResp, err := s.client.KV.Txn(ctx).If(<br>
notFound(key),<br>
).Then(<br>
clientv3.OpPut(key, string(newData), opts&hellip;),<br>
).Commit</p>
<p>从上面的代码片段中，我们可以得出首先它会按照我们介绍的 Kubernetes 资源存储格式拼接 key。</p>
<p>然后若 TTL 非 0，它会根据 TTL 从 leaseManager 获取可复用的 Lease ID。Kubernetes 集群默认若不同 key（如 Kubernetes 的 Event 资源对象）的 TTL 差异在 1 分钟内，可复用同一个 Lease ID，避免大量 Lease 影响 etcd 性能和稳定性。</p>
<p>其次若开启了数据加密，在写入 etcd 前数据还将按加密算法进行转换工作。</p>
<p>最后就是使用 etcd 的 Txn 接口，向 etcd 发起一个创建 deployment 资源的 Txn 请求。</p>
<p>那么 etcd 收到 kube-apiserver 的请求是长什么样子的呢？</p>
<p>下面是 etcd 收到创建 nginx deployment 资源的请求日志：</p>
<p>{<br>
&ldquo;level&rdquo;:&ldquo;debug&rdquo;,<br>
&ldquo;ts&rdquo;:&ldquo;2021-02-11T09:55:45.914+0800&rdquo;,<br>
&ldquo;caller&rdquo;:&ldquo;v3rpc/interceptor.go:181&rdquo;,<br>
&ldquo;msg&rdquo;:&ldquo;request stats&rdquo;,<br>
&ldquo;start time&rdquo;:&ldquo;2021-02-11T09:55:45.911+0800&rdquo;,<br>
&ldquo;time spent&rdquo;:&ldquo;2.697925ms&rdquo;,<br>
&ldquo;remote&rdquo;:&ldquo;127.0.0.1:44822&rdquo;,<br>
&ldquo;response type&rdquo;:&quot;/etcdserverpb.KV/Txn&quot;,<br>
&ldquo;request count&rdquo;:1,<br>
&ldquo;request size&rdquo;:479,<br>
&ldquo;response count&rdquo;:0,<br>
&ldquo;response size&rdquo;:44,<br>
&ldquo;request content&rdquo;:&ldquo;compare:&lt;target:MOD key:&quot;/registry/deployments/default/nginx-deployment&rdquo; mod_revision:0 &gt; success:&lt;request_put:&lt;key:&quot;/registry/deployments/default/nginx-deployment&quot; value_size:421 &raquo; failure:&lt;&gt;&quot;<br>
}</p>
<p>从这个请求日志中，你可以得到以下信息：</p>
<ol>
<li>请求的模块和接口，KV/Txn；</li>
<li>key 路径，/registry/deployments/default/nginx-deployment，由 prefix + &ldquo;/&rdquo; + 资源类型 + &ldquo;/&rdquo; + namespace + &ldquo;/&rdquo; + 具体资源名组成；</li>
<li>安全的并发创建检查机制，mod_revision 为 0 时，也就是此 key 不存在时，才允许执行 put 更新操作。</li>
</ol>
<p>通过 Txn 接口成功将数据写入到 etcd 后，kubectl create -f nginx.yml 命令就执行完毕，返回给 client 了。在以上介绍中你可以看到，kube-apiserver 并没有任何逻辑去真正创建 Pod，但是为什么我们可以马上通过 kubectl get 命令查询到新建并成功运行的 Pod 呢？</p>
<p>这就涉及到了基础架构图中的控制器、调度器、Kubelet 等组件。下面我就为你浅析它们是如何基于 etcd 提供的 Watch 机制工作，最终实现创建 Pod、调度 Pod、运行 Pod 的。</p>
<h2 id="watch-机制在-kubernetes-中应用">Watch 机制在 Kubernetes 中应用</h2>
<p>正如我们基础架构中所介绍的，kube-controller-manager 组件中包含一系列 WorkLoad 的控制器。Deployment 资源就由其中的 Deployment 控制器来负责的，那么它又是如何感知到新建 Deployment 资源，最终驱动 ReplicaSet 控制器创建出 Pod 的呢？</p>
<p>获取数据变化的方案，主要有轮询和推送两种方案组成。轮询会产生大量 expensive request，并且存在高延时。而 etcd Watch 机制提供的流式推送能力，赋予了 kube-apiserver 对外提供数据监听能力。</p>
<p>我们知道在 etcd 中版本号是个逻辑时钟，随着 client 对 etcd 的增、删、改操作而全局递增，它被广泛应用在 MVCC、事务、Watch 特性中。</p>
<p>尤其是在 Watch 特性中，版本号是数据增量同步的核心。当 client 因网络等异常出现连接闪断后，它就可以通过版本号从 etcd server 中快速获取异常后的事件，无需全量同步。</p>
<p>那么在 Kubernetes 集群中，它提供了什么概念来实现增量监听逻辑呢？</p>
<p>答案是 Resource Version。</p>
<h3 id="resource-version-与-etcd-版本号">Resource Version 与 etcd 版本号</h3>
<p>Resource Version 是 Kubernetes API 中非常重要的一个概念，顾名思义，它是一个 Kubernetes 资源的内部版本字符串，client 可通过它来判断资源是否发生了变化。同时，你可以在 Get、List、Watch 接口中，通过指定 Resource Version 值来满足你对数据一致性、高性能等诉求。</p>
<p>那么 Resource Version 有哪些值呢？跟 etcd 版本号是什么关系？</p>
<p>下面我分别以 Get 和 Watch 接口中的 Resource Version 参数值为例，为你剖析它与 etcd 的关系。</p>
<p>在 Get 请求查询案例中，ResourceVersion 主要有以下这三种取值：</p>
<p>第一种是未指定 ResourceVersion，默认空字符串。kube-apiserver 收到一个此类型的读请求后，它会向 etcd 发出共识读 / 线性读请求获取 etcd 集群最新的数据。</p>
<p>第二种是设置 ResourceVersion=&ldquo;0&rdquo;，赋值字符串 0。kube-apiserver 收到此类请求时，它可能会返回任意资源版本号的数据，但是优先返回较新版本。一般情况下它直接从 kube-apiserver 缓存中获取数据返回给 client，有可能读到过期的数据，适用于对数据一致性要求不高的场景。</p>
<p>第三种是设置 ResourceVersion 为一个非 0 的字符串。kube-apiserver 收到此类请求时，它会保证 Cache 中的最新 ResourceVersion 大于等于你传入的 ResourceVersion，然后从 Cache 中查找你请求的资源对象 key，返回数据给 client。基本原理是 kube-apiserver 为各个核心资源（如 Pod）维护了一个 Cache，通过 etcd 的 Watch 机制来实时更新 Cache。当你的 Get 请求中携带了非 0 的 ResourceVersion，它会等待缓存中最新 ResourceVersion 大于等于你 Get 请求中的 ResoureVersion，若满足条件则从 Cache 中查询数据，返回给 client。若不满足条件，它最多等待 3 秒，若超过 3 秒，Cache 中的最新 ResourceVersion 还小于 Get 请求中的 ResourceVersion，就会返回 ResourceVersionTooLarge 错误给 client。</p>
<p>你要注意的是，若你使用的 Get 接口，那么 kube-apiserver 会取资源 key 的 ModRevision 字段填充 Kubernetes 资源的 ResourceVersion 字段（v1.meta/ObjectMeta.ResourceVersion）。若你使用的是 List 接口，kube-apiserver 会在查询时，使用 etcd 当前版本号填充 ListMeta.ResourceVersion 字段（v1.meta/ListMeta.ResourceVersion）。</p>
<p>那么当我们执行 kubectl get po 查询案例时，它的 ResouceVersion 是什么取值呢？查询的是 kube-apiserver 缓存还是 etcd 最新共识数据？</p>
<p>如下所示，你可以通过指定 kubectl 日志级别为 6，观察它向 kube-apiserver 发出的请求参数。从下面请求日志里你可以看到，默认是未指定 Resource Version，也就是会发出一个共识读 / 线性读请求给 etcd，获取 etcd 最新共识数据。</p>
<p>kubectl get po -l app=nginx -v 6<br>
4410 loader.go:359] Config loaded from file /root/.kube/config<br>
4410 round_trippers.go:438] GET https://<em>.</em>.<em>.</em>:*/api/v1/namespaces/default/pods?labelSelector=app%3Dnginx&amp;limit=500 200 OK in 8 milliseconds</p>
<p>这里要提醒下你，在规模较大的集群中，尽量不要使用 kubectl 频繁查询资源。正如我们上面所分析的，它会直接查询 etcd 数据，可能会产生大量的 expensive request 请求，之前我就有见过业务这样用，然后导致了集群不稳定。</p>
<p>介绍完查询案例后，我们再看看 Watch 案例中，它的不同取值含义是怎样的呢？</p>
<p>它同样含有查询案例中的三种取值，官方定义的含义分别如下：</p>
<ol>
<li>未指定 ResourceVersion，默认空字符串。一方面为了帮助 client 建立初始状态，它会将当前已存在的资源通过 Add 事件返回给 client。另一方面，它会从 etcd 当前版本号开始监听，后续新增写请求导致数据变化时可及时推送给 client。</li>
<li>设置 ResourceVersion=&ldquo;0&rdquo;，赋值字符串 0。它同样会帮助 client 建立初始状态，但是它会从任意版本号开始监听（当前 kube-apiserver 的实现指定 ResourceVersion=0 和不指定行为一致，在获取初始状态后，都会从 cache 最新的 ResourceVersion 开始监听），这种场景可能会导致集群返回陈旧的数据。</li>
<li>设置 ResourceVersion 为一个非 0 的字符串。从精确的版本号开始监听数据，它只会返回大于等于精确版本号的变更事件。</li>
</ol>
<p>Kubernetes 的控制器组件就基于以上的 Watch 特性，在快速感知到新建 Deployment 资源后，进入一致性协调逻辑，创建 ReplicaSet 控制器，整体交互流程如下所示。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/etcd%E5%AE%9E%E6%88%98%E8%AF%BE/1243371dec4908642d29ff9339473e01.png" alt=""></p>
<p>Deployment 控制器创建 ReplicaSet 资源对象的日志如下所示。</p>
<p>{<br>
&ldquo;level&rdquo;:&ldquo;debug&rdquo;,<br>
&ldquo;ts&rdquo;:&ldquo;2021-02-11T09:55:45.923+0800&rdquo;,<br>
&ldquo;caller&rdquo;:&ldquo;v3rpc/interceptor.go:181&rdquo;,<br>
&ldquo;msg&rdquo;:&ldquo;request stats&rdquo;,<br>
&ldquo;start time&rdquo;:&ldquo;2021-02-11T09:55:45.917+0800&rdquo;,<br>
&ldquo;time spent&rdquo;:&ldquo;5.922089ms&rdquo;,<br>
&ldquo;remote&rdquo;:&ldquo;127.0.0.1:44828&rdquo;,<br>
&ldquo;response type&rdquo;:&quot;/etcdserverpb.KV/Txn&quot;,<br>
&ldquo;request count&rdquo;:1,<br>
&ldquo;request size&rdquo;:766,<br>
&ldquo;response count&rdquo;:0,<br>
&ldquo;response size&rdquo;:44,<br>
&ldquo;request content&rdquo;:&ldquo;compare:&lt;target:MOD key:&quot;/registry/replicasets/default/nginx-deployment-756d9fd5f9&rdquo; mod_revision:0 &gt; success:&lt;request_put:&lt;key:&quot;/registry/replicasets/default/nginx-deployment-756d9fd5f9&quot; value_size:697 &raquo; failure:&lt;&gt;&quot;<br>
}</p>
<p>真正创建 Pod 则是由 ReplicaSet 控制器负责，它同样基于 Watch 机制感知到新的 RS 资源创建后，发起请求创建 Pod，确保实际运行 Pod 数与期望一致。</p>
<p>{<br>
&ldquo;level&rdquo;:&ldquo;debug&rdquo;,<br>
&ldquo;ts&rdquo;:&ldquo;2021-02-11T09:55:46.023+0800&rdquo;,<br>
&ldquo;caller&rdquo;:&ldquo;v3rpc/interceptor.go:181&rdquo;,<br>
&ldquo;msg&rdquo;:&ldquo;request stats&rdquo;,<br>
&ldquo;start time&rdquo;:&ldquo;2021-02-11T09:55:46.019+0800&rdquo;,<br>
&ldquo;time spent&rdquo;:&ldquo;3.519326ms&rdquo;,<br>
&ldquo;remote&rdquo;:&ldquo;127.0.0.1:44664&rdquo;,<br>
&ldquo;response type&rdquo;:&quot;/etcdserverpb.KV/Txn&quot;,<br>
&ldquo;request count&rdquo;:1,<br>
&ldquo;request size&rdquo;:822,<br>
&ldquo;response count&rdquo;:0,<br>
&ldquo;response size&rdquo;:44,<br>
&ldquo;request content&rdquo;:&ldquo;compare:&lt;target:MOD key:&quot;/registry/pods/default/nginx-deployment-756d9fd5f9-x6r6q&rdquo; mod_revision:0 &gt; success:&lt;request_put:&lt;key:&quot;/registry/pods/default/nginx-deployment-756d9fd5f9-x6r6q&quot; value_size:754 &raquo; failure:&lt;&gt;&quot;<br>
}</p>
<p>在这过程中也产生了若干 Event，下面是 etcd 收到新增 Events 资源的请求，你可以看到 Event 事件 key 关联了 Lease，这个 Lease 正是由我上面所介绍的 leaseManager 所负责创建。</p>
<p>{<br>
&ldquo;level&rdquo;:&ldquo;debug&rdquo;,<br>
&ldquo;ts&rdquo;:&ldquo;2021-02-11T09:55:45.930+0800&rdquo;,<br>
&ldquo;caller&rdquo;:&ldquo;v3rpc/interceptor.go:181&rdquo;,<br>
&ldquo;msg&rdquo;:&ldquo;request stats&rdquo;,<br>
&ldquo;start time&rdquo;:&ldquo;2021-02-11T09:55:45.926+0800&rdquo;,<br>
&ldquo;time spent&rdquo;:&ldquo;3.259966ms&rdquo;,<br>
&ldquo;remote&rdquo;:&ldquo;127.0.0.1:44632&rdquo;,<br>
&ldquo;response type&rdquo;:&quot;/etcdserverpb.KV/Txn&quot;,<br>
&ldquo;request count&rdquo;:1,<br>
&ldquo;request size&rdquo;:449,<br>
&ldquo;response count&rdquo;:0,<br>
&ldquo;response size&rdquo;:44,<br>
&ldquo;request content&rdquo;:&ldquo;compare:&lt;target:MOD key:&quot;/registry/events/default/nginx-deployment.16628eb9f79e0ab0&rdquo; mod_revision:0 &gt; success:&lt;request_put:&lt;key:&quot;/registry/events/default/nginx-deployment.16628eb9f79e0ab0&quot; value_size:369 lease:5772338802590698925 &raquo; failure:&lt;&gt;&quot;<br>
}</p>
<p>Pod 创建出来后，这时 kube-scheduler 监听到待调度的 Pod，于是为其分配 Node，通过 kube-apiserver 的 Bind 接口，将调度后的节点 IP 绑定到 Pod 资源上。kubelet 通过同样的 Watch 机制感知到新建的 Pod 后，发起 Pod 创建流程即可。</p>
<p>以上就是当我们在 Kubernetes 集群中创建一个 Pod 后，Kubernetes 和 etcd 之间交互的简要分析。</p>
<h2 id="小结">小结</h2>
<p>最后我们来小结下今天的内容。我通过一个创建 Pod 案例，首先为你解读了 Kubernetes 集群的 etcd 存储格式，每个资源的保存路径为 prefix + &ldquo;/&rdquo; + 资源类型 + &ldquo;/&rdquo; + namespace + &ldquo;/&rdquo; + 具体资源名组成。结合 etcd3 的范围查询，可快速实现按 namesapace、资源名称查询。按标签查询则是通过 kube-apiserver 遍历指定 namespace 下的资源实现的，若未从 kube-apiserver 的 Cache 中查询，请求较频繁，很可能导致 etcd 流量较大，出现不稳定。</p>
<p>随后我和你介绍了 kube-apiserver 的通用存储模块，它通过在创建、查询、删除、更新操作前增加一系列的 Hook 机制，实现了新增任意资源只需编写相应的 Hook 策略即可。我还重点和你介绍了创建接口，它主要由拼接 key、获取 Lease ID、数据转换、写入 etcd 组成，重点是它通过使用事务接口实现了资源的安全创建及更新。</p>
<p>最后我给你讲解了 Resoure Version 在 Kubernetes 集群中的大量应用，重点和你分析了 Get 和 Watch 请求案例中的 Resource Version 含义，帮助你了解 Resource Version 本质，让你能根据业务场景和对一致性的容忍度，正确的使用 Resource Version 以满足业务诉求。</p>
<h2 id="思考题">思考题</h2>
<p>我还给你留了一个思考题，有哪些原因可能会导致 kube-apiserver 报“too old Resource Version”错误呢？</p>
<p>感谢你的阅读，如果你认为这节课的内容有收获，也欢迎把它分享给你的朋友，谢谢。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/etcd%E5%AE%9E%E6%88%98%E8%AF%BE/">etcd实战课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/19__java%E5%AD%97%E8%8A%82%E7%A0%81%E5%9F%BA%E7%A1%80%E7%AF%87/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">19__Java字节码（基础篇）</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/openresty%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/19__openresty_%E7%9A%84%E6%A0%B8%E5%BF%83%E5%92%8C%E7%B2%BE%E9%AB%93cosocket/">
            <span class="next-text nav-default">19__OpenResty_的核心和精髓：cosocket</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
