<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>18__反应式编程框架设计：如何使程序调用不阻塞等待，立即响应？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="我们在专栏第 1 篇就讨论了为什么在高并发的情况下，程序会崩溃。主要原因是，在高并发的情况下，有大量用户请求需要程序计算处理，而目前的处理方式是，为每个用户请求分配一个线程，当程序内部因为访问数据库等原因造成线程阻塞时，线程无法释放去处理其他请求，这样就会造成请求堆积，不断消耗资源，最终导致程序崩溃。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/18__%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%A6%82%E4%BD%95%E4%BD%BF%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E4%B8%8D%E9%98%BB%E5%A1%9E%E7%AD%89%E5%BE%85%E7%AB%8B%E5%8D%B3%E5%93%8D%E5%BA%94/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/18__%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%A6%82%E4%BD%95%E4%BD%BF%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E4%B8%8D%E9%98%BB%E5%A1%9E%E7%AD%89%E5%BE%85%E7%AB%8B%E5%8D%B3%E5%93%8D%E5%BA%94/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="18__反应式编程框架设计：如何使程序调用不阻塞等待，立即响应？">
  <meta property="og:description" content="我们在专栏第 1 篇就讨论了为什么在高并发的情况下，程序会崩溃。主要原因是，在高并发的情况下，有大量用户请求需要程序计算处理，而目前的处理方式是，为每个用户请求分配一个线程，当程序内部因为访问数据库等原因造成线程阻塞时，线程无法释放去处理其他请求，这样就会造成请求堆积，不断消耗资源，最终导致程序崩溃。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="后端技术面试38讲">

  <meta itemprop="name" content="18__反应式编程框架设计：如何使程序调用不阻塞等待，立即响应？">
  <meta itemprop="description" content="我们在专栏第 1 篇就讨论了为什么在高并发的情况下，程序会崩溃。主要原因是，在高并发的情况下，有大量用户请求需要程序计算处理，而目前的处理方式是，为每个用户请求分配一个线程，当程序内部因为访问数据库等原因造成线程阻塞时，线程无法释放去处理其他请求，这样就会造成请求堆积，不断消耗资源，最终导致程序崩溃。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3892">
  <meta itemprop="keywords" content="后端技术面试38讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="18__反应式编程框架设计：如何使程序调用不阻塞等待，立即响应？">
  <meta name="twitter:description" content="我们在专栏第 1 篇就讨论了为什么在高并发的情况下，程序会崩溃。主要原因是，在高并发的情况下，有大量用户请求需要程序计算处理，而目前的处理方式是，为每个用户请求分配一个线程，当程序内部因为访问数据库等原因造成线程阻塞时，线程无法释放去处理其他请求，这样就会造成请求堆积，不断消耗资源，最终导致程序崩溃。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">18__反应式编程框架设计：如何使程序调用不阻塞等待，立即响应？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3892 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#反应式编程">反应式编程</a></li>
        <li><a href="#反应式编程框架-flower-的基本原理">反应式编程框架 Flower 的基本原理</a></li>
        <li><a href="#反应式编程框架-flower-的设计方法">反应式编程框架 Flower 的设计方法</a></li>
        <li><a href="#反应式编程框架-flower-的落地效果">反应式编程框架 Flower 的落地效果</a></li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>我们在专栏第 1 篇就讨论了为什么在高并发的情况下，程序会崩溃。主要原因是，在高并发的情况下，有大量用户请求需要程序计算处理，而目前的处理方式是，为每个用户请求分配一个线程，当程序内部因为访问数据库等原因造成线程阻塞时，线程无法释放去处理其他请求，这样就会造成请求堆积，不断消耗资源，最终导致程序崩溃。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/756dd4580bb0f8df16b69350b9c122b0.png" alt=""></p>
<p>这是传统的 Web 应用程序运行期的线程特性。对于一个高并发的应用系统来说，总是同时有很多个用户请求到达系统的 Web 容器。Web 容器为每个请求分配一个线程进行处理，线程在处理过程中，如果遇到访问数据库或者远程服务等操作，就会进入阻塞状态，这个时候，如果数据库或者远程服务响应延迟，就会出现程序内的线程无法释放的情况，而外部的请求不断进来，导致计算机资源被快速消耗，最终程序崩溃。</p>
<p>那么有没有不阻塞线程的编程方法呢？</p>
<h2 id="反应式编程">反应式编程</h2>
<p>答案就是反应式编程。反应式编程本质上是一种异步编程方案，在多线程（协程）、异步方法调用、异步 I/O 访问等技术基础之上，提供了一整套与异步调用相匹配的编程模型，从而实现程序调用非阻塞、即时响应等特性，即开发出一个反应式的系统，以应对编程领域越来越高的并发处理需求。</p>
<p>人们还提出了一个反应式宣言，认为反应式系统应该具备如下特质：</p>
<p><strong>即时响应</strong>，应用的调用者可以即时得到响应，无需等到整个应用程序执行完毕。也就是说应用调用是非阻塞的。</p>
<p><strong>回弹性</strong>，当应用程序部分功能失效的时候，应用系统本身能够进行自我修复，保证正常运行，保证响应，不会出现系统崩溃和宕机的情况。</p>
<p><strong>弹性</strong>，系统能够对应用负载压力做出响应，能够自动伸缩以适应应用负载压力，根据压力自动调整自身的处理能力，或者根据自身的处理能力，调整进入系统中的访问请求数量。</p>
<p><strong>消息驱动</strong>，功能模块之间，服务之间，通过消息进行驱动，完成服务的流程。</p>
<p>目前主流的反应式编程框架有 RxJava、Reactor 等，它们的主要特点是基于<strong>观察者设计模式</strong>的异步编程方案，编程模型采用函数式编程。</p>
<p>观察者模式和函数式编程有自己的优势，但是反应式编程并不是必须用观察者模式和函数式编程。Flower 就是一个纯消息驱动，完全异步，支持命令式编程的反应式编程框架。</p>
<p>下面我们就看看 Flower 如何实现异步无阻塞的调用，以及 Flower 这个框架设计使用了什么样的设计原则与模式。</p>
<h2 id="反应式编程框架-flower-的基本原理">反应式编程框架 Flower 的基本原理</h2>
<p>一个使用 Flower 框架开发的典型 Web 应用的线程特性如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/a269661584f8cb157850c50940cb592d.png" alt=""></p>
<p>当并发用户到达应用服务器的时候，Web 容器线程不需要执行应用程序代码，它只是将用户的 HTTP 请求变为请求对象，将请求对象异步交给 Flower 框架的 Service 去处理，自身立刻就返回。因为容器线程不做太多的工作，所以只需极少的容器线程就可以满足高并发的用户请求，用户的请求不会被阻塞，不会因为容器线程不够而无法处理。相比传统的阻塞式编程，Web 容器线程要完成全部的请求处理操作，直到返回响应结果才能释放线程；<strong>使用 Flower 框架只需要极少的容器线程就可以处理较</strong> <strong>多</strong> <strong>的并发用户请求，而且容器线程不会阻塞。</strong></p>
<p>用户请求交给基于 Flower 框架开发的业务 Service 对象以后，Service 之间依然是使用异步消息通讯的方式进行调用，不会直接进行阻塞式的调用。一个 Service 完成业务逻辑处理计算以后，会返回一个处理结果，这个结果以消息的方式异步发送给它的下一个 Service。</p>
<p>传统编程模型的 Service 之间如果进行调用，如我们在专栏第一篇讨论的那样，被调用的 Service 在返回之前，调用的 Service 方法只能阻塞等待。而 Flower 的 Service 之间使用了 AKKA Actor 进行消息通信，调用者的 Service 发送调用消息后，不需要等待被调用者返回结果，就可以处理自己的下一个消息了。事实上，这些 Service 可以复用同一个线程去处理自己的消息，也就是说，<strong>只需要有限的几个线程就可以完成大量的 Service 处理和消息传输，这些线程不会阻塞等待。</strong></p>
<p>我们刚才提到，通常 Web 应用主要的线程阻塞，是因为数据库的访问导致的线程阻塞。Flower 支持异步数据库驱动，用户请求数据库的时候，将请求提交给异步数据库驱动，立刻就返回，不会阻塞当前线程，异步数据库访问连接远程的数据库，进行真正的数据库操作，得到结果以后，将结果以异步回调的方式发送给 Flower 的 Service 进行进一步的处理，<strong>这个时候依然不会有线程被阻塞。</strong></p>
<p>也就是说，使用 Flower 开发的系统，在一个典型的 Web 应用中，几乎没有任何地方会被阻塞，所有的线程都可以被不断地复用，<strong>有限的线程就可以完成大量的并发用户请求，从而大大地提高了系统的吞吐能力和响应时间</strong>，同时，由于线程不会被阻塞，<strong>应用就不会因为并发量太大或者数据库处理缓慢而宕机，从而提高了系统的可用性。</strong></p>
<p>Flower 框架实现异步无阻塞，一方面是利用了 Web 容器的异步特性，主要是 Servlet3.0 以后提供的 AsyncContext，快速释放容器线程；另一方面是利用了异步的数据库驱动以及异步的网络通信，主要是 HttpAsyncClient 等异步通信组件。而 Flower 框架内，核心的应用代码之间的异步无阻塞调用，则是利用了 Akka 的 Actor 模型实现。</p>
<p>Akka Actor 的异步消息驱动实现如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/cdfd63101a4b12d50098336402344135.png" alt=""></p>
<p>一个 Actor 向另一个 Actor 进行通讯的时候，当前 Actor 就是一个消息的发送者 sender，当它想要向另一个 Actor 进行通讯的时候，就需要获得另一个 Actor 的 ActorRef，也就是一个引用，通过引用进行消息通信。而 ActorRef 收到消息以后，会将这个消息放入到目标 Actor 的 Mailbox 里面去，然后就立即返回了。</p>
<p>也就是说一个 Actor 向另一个 Actor 发送消息的时候，不需要另一个 Actor 去真正地处理这个消息，只需要将消息发送到目标 Actor 的 Mailbox 里面就可以了。自己不会被阻塞，可以继续执行自己的操作，而目标 Actor 检查自己的 Mailbox 中是否有消息，如果有消息，Actor 则会在从 Mailbox 里面去获取消息，对消息进行异步的处理，而所有的 Actor 会共享线程，这些线程不会有任何的阻塞。</p>
<h2 id="反应式编程框架-flower-的设计方法">反应式编程框架 Flower 的设计方法</h2>
<p>但是直接使用 Actor 进行编程有很多不便，Flower 框架对 Actor 进行了封装，开发者只需要编写一些细粒度的 Service，这些 Service 会被包装在 Actor 里面，进行异步通信。</p>
<p>Flower Service 例子如下：</p>
<p>public class ServiceA implements Service<Message2> {<br>
@Override<br>
public Object process(Message2 message) {<br>
return message.getAge() + 1;<br>
}<br>
}</p>
<p>每个 Service 都需要实现框架的 Service 接口的 process 方法，process 方法的输入参数就是前一个 Service process 方法的返回值，这样只需要将 Service 编排成一个流程，Service 的返回值就会变成 Actor 的一个消息，被发送给下一个 Service，从而实现 Service 的异步通信。</p>
<p>Service 的流程编排有两种方式，一种方式是编程实现，如下：</p>
<p>getServiceFlow().buildFlow(&ldquo;ServiceA&rdquo;, &ldquo;ServiceB&rdquo;);</p>
<p>表示 ServiceA 的返回值将作为消息发送给 ServiceB，成为 ServiceB 的输入值，这样两个 Service 就可以合作完成一些更复杂的业务逻辑。</p>
<p>Flower 还支持可视化的 Service 流程编排，像下面这张图一样编辑流程定义文件，就可以开发一个异步业务处理流程。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/df9e1c9fa901fceefd6070dc4f8ac8d3.png" alt=""></p>
<p>那么这个 Flower 框架是如何实现的呢？</p>
<p>Flower 框架的设计也是基于前面专栏讨论过的依赖倒置原则。所有应用开发者实现的 Service 类都需要包装在 Actor 里面进行异步调用，但是 Actor 不会依赖开发者实现的 Service 类，开发者也不会依赖 Actor 类，他们共同依赖一个 Service 接口，这个接口是框架提供的，如上面例子所示。</p>
<p>Actor 与 Service 的依赖倒置关系如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/dd9b9138b00396de5373d31ad048c0da.png" alt=""></p>
<p>每个 Actor 都依赖一个 Service 接口，而具体的 Service 实现类，比如 MyService，则实现这个 Service 接口。在运行期实例化 Actor 的时候，这个接口被注入具体的 Service 实现类，比如 MyService。在 Flower 中，调用 MyService 对象，其实就是给包装 MyService 对象的 Actor 发消息，Actor 收到消息，执行自己的 onReceive 方法，在这个方法里，Actor 调用 MyService 的 process 方法，并将 onReceive 收到的 Message 对象当做 process 的输入参数传入。</p>
<p>process 处理完成后，返回一个 Object 对象。Actor 会根据编排好的流程，获取 MyService 在流程中的下一个 Service 对应的 Actor，即 nextServiceActor，将 process 返回的 Object 对象当做消息发送给这个 nextServiceActor。这样，Service 之间就根据编排好的流程，异步、无阻塞地调用执行起来了。</p>
<h2 id="反应式编程框架-flower-的落地效果">反应式编程框架 Flower 的落地效果</h2>
<p>Flower 框架在部分项目中落地应用，应用效果较为显著，一方面，Flower 可以显著提高系统的性能。这是某个 C# 开发的系统使用 Flower 重构后的 TPS 性能比较，使用 Flower 开发的系统 TPS 差不多是原来 C# 系统的两倍。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/6260ea19c1f7c5c9a4378123f674e815.png" alt=""></p>
<p>另一方面，Flower 对系统可用性也有较大提升，目前常见互联网应用架构如下图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/68004f156ae662c774485a3d085235e1.png" alt=""></p>
<p>用户请求通过网关服务器调用微服务完成处理，那么当有某个微服务连接的数据库查询执行较慢时，如图中服务 1，那么按照传统的线程阻塞模型，就会导致服务 1 的线程都被阻塞在这个慢查询的数据库操作上。同样的，网关线程也会阻塞在调用这个延迟比较厉害的服务 1 上。</p>
<p>最终的效果就是，网关所有的线程都被阻塞，即使是不调用服务 1 的用户请求也无法处理，最后整个系统失去响应，应用宕机。使用阻塞式编程，实际的压测效果如下，当服务 1 响应延迟，出错率大幅飙升的时候，通过网关调用正常的服务 2 的出错率也非常高。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/34438bead1a03f77bcf4e07166a4d760.png" alt=""></p>
<p>使用 Flower 开发的网关，实际压测效果如下，同样服务 1 响应延迟，出错率极高的情况下，通过 Flower 网关调用服务 2 完全不受影响。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/11facd83dc9d9b1a87ea42846d38b5b8.png" alt=""></p>
<h2 id="小结">小结</h2>
<p>事实上，Flower 不仅是一个反应式 Web 编程框架，还是反应式的微服务框架。也就是说，Flower 的 Service 可以远程部署到一个 Service 容器里面，就像我们现在常用的微服务架构一样。Flower 会提供一个独立的 Flower 容器，用于启动一些 Service，这些 Service 在启动了以后，会向注册中心进行注册，而且应用程序可以将这些分布式的 Service 进行流程编排，得到一个分布式非阻塞的微服务系统。整体架构和主流的微服务架构很像，主要的区别就是 Flower 的服务是异步的，通过流程编排的方式进行服务调用，而不是通过接口依赖的方式进行调用。</p>
<p>你可以点击这里进入 Flower 框架的源代码地址，欢迎你参与 Flower 开发，也欢迎将 Flower 应用到你的系统开发中。你对 Flower 有什么疑问，也欢迎与我交流。</p>
<h2 id="思考题">思考题</h2>
<p>反应式编程虽然能带来性能和可用性方面的提升，但是也带来一些问题，你觉得反应式编程可能存在的问题有哪些？应该如何应对？你是否愿意在工作实践中尝试反应式编程？</p>
<p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/">后端技术面试38讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/18__%E5%BD%93%E5%8F%8D%E5%B0%84%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%B3%9B%E5%9E%8B%E9%81%87%E5%88%B0oop%E6%97%B6%E4%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">18__当反射、注解和泛型遇到OOP时，会有哪些坑？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/18__%E9%98%B2%E4%BA%BA%E4%B9%8B%E5%BF%83%E4%B8%8D%E5%8F%AF%E6%97%A0%E6%A3%80%E6%9F%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7/">
            <span class="next-text nav-default">18__防人之心不可无：检查数据的有效性</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
