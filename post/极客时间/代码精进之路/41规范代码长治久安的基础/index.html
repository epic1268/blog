<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>41规范代码长治久安的基础 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="40 | 规范，代码长治久安的基础
如果从安全角度去考察，软件是非常脆弱的。今天还是安全的代码，明天可能就有人发现漏洞。安全攻击的问题，大部分出自信息的不对称性；而维护代码安全之所以难，大部分是因为安全问题是不可预见的。那么，该怎么保持代码的长治久安呢？
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/41%E8%A7%84%E8%8C%83%E4%BB%A3%E7%A0%81%E9%95%BF%E6%B2%BB%E4%B9%85%E5%AE%89%E7%9A%84%E5%9F%BA%E7%A1%80/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/41%E8%A7%84%E8%8C%83%E4%BB%A3%E7%A0%81%E9%95%BF%E6%B2%BB%E4%B9%85%E5%AE%89%E7%9A%84%E5%9F%BA%E7%A1%80/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="41规范代码长治久安的基础">
  <meta property="og:description" content="40 | 规范，代码长治久安的基础
如果从安全角度去考察，软件是非常脆弱的。今天还是安全的代码，明天可能就有人发现漏洞。安全攻击的问题，大部分出自信息的不对称性；而维护代码安全之所以难，大部分是因为安全问题是不可预见的。那么，该怎么保持代码的长治久安呢？">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="代码精进之路">

  <meta itemprop="name" content="41规范代码长治久安的基础">
  <meta itemprop="description" content="40 | 规范，代码长治久安的基础
如果从安全角度去考察，软件是非常脆弱的。今天还是安全的代码，明天可能就有人发现漏洞。安全攻击的问题，大部分出自信息的不对称性；而维护代码安全之所以难，大部分是因为安全问题是不可预见的。那么，该怎么保持代码的长治久安呢？">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5760">
  <meta itemprop="keywords" content="代码精进之路">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="41规范代码长治久安的基础">
  <meta name="twitter:description" content="40 | 规范，代码长治久安的基础
如果从安全角度去考察，软件是非常脆弱的。今天还是安全的代码，明天可能就有人发现漏洞。安全攻击的问题，大部分出自信息的不对称性；而维护代码安全之所以难，大部分是因为安全问题是不可预见的。那么，该怎么保持代码的长治久安呢？">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">41规范代码长治久安的基础</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5760 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>40 | 规范，代码长治久安的基础</p>
<p>如果从安全角度去考察，软件是非常脆弱的。今天还是安全的代码，明天可能就有人发现漏洞。安全攻击的问题，大部分出自信息的不对称性；而维护代码安全之所以难，大部分是因为安全问题是不可预见的。那么，该怎么保持代码的长治久安呢？</p>
<p>评审案例</p>
<p>有些函数或者接口，可能在我们刚开始写程序的时候，就已经接触，了解，甚至熟知了它们，比如说 C 语言的 read() 函数、Java 语言的 InputStream.read() 方法。我一点都不怀疑，我们熟知这些函数或接口的规范。比如说，C 语言的 read() 函数在什么情况下返回值为 0？ InputStream.read() 方法在什么情况下返回值为 -1？</p>
<p>我知道，我们用错 read() 的概率很小。但是今天，我要和你讨论一两个不太常见，且非常有趣，的错误的用法。</p>
<p>让我们一起来看几段节选改编的 C 代码，代码中的 socket 表示网络连接的套接字文件描述符（file descriptor）。 你能够找到这些代码里潜在的问题吗？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/socket.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void clientHello(int socket) {
</span></span><span class="line"><span class="cl">    char buffer[1024];
</span></span><span class="line"><span class="cl">    char* hello = &#34;Hello from client!&#34;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    send(socket, hello, strlen(hello), 0);
</span></span><span class="line"><span class="cl">    printf(&#34;Hello message sent\n&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int n = read(socket, buffer, 1024);
</span></span><span class="line"><span class="cl">    printf(&#34;%s\n&#34;, buffer);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;</p>
<p>void serverHello(int socket) {
    char buffer[1024];
    char* hello = &ldquo;Hello from server!&rdquo;;</p>
<p>    int n = read(socket, buffer, 1024);
    printf(&quot;%s\n&quot;, buffer);</p>
<p>    send(socket, hello, strlen(hello), 0);
    printf(&ldquo;Hello message sent\n&rdquo;);
}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#include &lt;stdio.h&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#include &lt;string.h&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#include &lt;unistd.h&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#include &lt;sys/socket.h&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">serverHello</span><span class="p">(</span><span class="ne">int</span> <span class="n">socket</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">char</span><span class="o">*</span> <span class="n">hello</span> <span class="o">=</span> <span class="s2">&#34;Hello from server!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">close</span><span class="p">(</span><span class="n">socket</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s2">&#34;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">send</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">hello</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">hello</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s2">&#34;Hello message sent</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">```</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">现在，我们集中寻找</span> <span class="n">read</span><span class="p">()</span> <span class="err">函数返回值的使用问题。为了方便你分析，我把一个标准的</span> <span class="n">read</span><span class="p">()</span> <span class="err">函数返回值的规范摘抄如下：</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">RETURN</span> <span class="n">VALUESIf</span> <span class="n">successful</span><span class="p">,</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">bytes</span> <span class="n">actually</span> <span class="n">read</span> <span class="n">is</span> <span class="n">returned</span><span class="o">.</span> <span class="n">Upon</span> <span class="n">readingend</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">file</span><span class="p">,</span> <span class="n">zero</span> <span class="n">is</span> <span class="n">returned</span><span class="o">.</span> <span class="n">Otherwise</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span><span class="mi">1</span> <span class="n">is</span> <span class="n">returned</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">globalvariable</span> <span class="n">errno</span> <span class="n">is</span> <span class="n">set</span> <span class="n">to</span> <span class="n">indicate</span> <span class="n">the</span> <span class="n">error</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">上面三段代码里，</span><span class="n">read</span><span class="p">()</span> <span class="err">函数的返回值使用都有什么问题？</span> <span class="err">上面的函数能够实现编码者所期望的功能吗？</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">案例分析</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">上述代码可以作为教学示范的一部分，它们简洁地展示了套接字文件描述符的一些使用方法。但是，这些代码离真正的工业级产品的质量要求还有很大的一段距离。当然了，如果你把上述的代码运行一万次，那么这一万次可能都不会辜负你的期望；运行一百万次，一百万次也可能都是成功的。但是，不论是理论上还是实际上，这些代码还是有可能出现错误的，它们并不是可靠的代码。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">问题出在哪儿呢？如果我们仔细阅读</span> <span class="n">read</span><span class="p">()</span> <span class="err">函数返回值规范，可以注意到，</span><span class="n">read</span><span class="p">()</span> <span class="err">函数的返回值是实际读取的字节数。一段信息，套接字的底层实现可能会分段传输，分段接收。所以，</span><span class="n">read</span><span class="p">()</span> <span class="err">函数并不能保证一次调用就返回完整的一段信息，传送和接收也未必是一一对应的，即使这段信息很短。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">在上述的例子中，如果期望接收到的信息是“</span><span class="n">Hello</span> <span class="n">from</span> <span class="n">server</span><span class="o">!</span><span class="err">”，那么一次</span> <span class="n">read</span><span class="p">()</span> <span class="err">函数的执行，实际接收到的信息可能是完整的信息，也可能是一个开头的字母“</span><span class="n">H</span><span class="err">”。套接字的底层实现并不能保证通过调用一次或者两次</span> <span class="n">read</span><span class="p">()</span> <span class="err">函数，就能够接收到这条完整的信息。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">这其实带来了一个不小的麻烦。如果调用</span> <span class="n">read</span><span class="p">()</span> <span class="err">函数的次数无法确定，那么接收端就要一直读取，直到接收到完整的信息。可是，什么样的信息才是完整的信息呢？接收端似乎并没有办法知道一条信息是否完整。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">比如在上面的例子中，对于接收端来说，怎么知道“</span><span class="n">H</span><span class="err">”不是一条完整的信息，</span> <span class="err">“</span><span class="n">Hello</span><span class="err">”也不是一条完整的信息，而“</span><span class="n">Hello</span> <span class="n">from</span> <span class="n">server</span><span class="o">!</span><span class="err">”就是一条完整的信息呢？无法判断信息的完整性，就会面临信息丢失或者读取阻塞的问题。所以，应用层面的设计，必须考虑如何检验接收消息是否完整。比如，对于</span> <span class="n">HTTP</span> <span class="err">协议而言，请求行必须以“</span><span class="n">CRLF</span><span class="err">”结束。那么，接收端读取到“</span><span class="n">CRLF</span><span class="err">”，就能够确定请求行的数据传输完整了。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">在实际运行中，如果信息足够短，比如上面的“</span><span class="n">Hello</span> <span class="n">from</span> <span class="n">server</span><span class="o">!</span><span class="err">”，那么套接字底层的实现和网络环境，大部分情况下都能够一次传输完整的信息。所以，上述代码运行一万次，可能这一万次都是成功的。即便如此，也不能保证每次传输的都是完整的信息。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">这里面还有另一个不太小的麻烦，是关于</span> <span class="n">read</span><span class="p">()</span> <span class="err">函数的实现的。函数的规范要求，数据传输结束（</span><span class="n">End</span><span class="o">-</span><span class="n">Of</span><span class="o">-</span><span class="ne">File</span><span class="err">）后，</span><span class="n">read</span><span class="p">()</span> <span class="err">函数应该返回</span> <span class="mi">0</span><span class="err">。那么，</span><span class="n">read</span><span class="p">()</span> <span class="err">函数返回</span> <span class="mi">0</span><span class="err">，是不是就表示数据传输结束呢？</span> <span class="err">是的。不然的话，应用程序如何判断数据传输结束又是一个大麻烦。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">可是，的确存在类似的实现，读取操作返回了</span> <span class="mi">0</span><span class="err">，但是数据传输才刚刚开始。下面我要给你讲的这个例子，就是这样的一个看似微不足道，但后果却很严重的问题，把互联网协议的重要安全变更，耽搁了整整十年。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">十年的死局</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">安全套接字协议（</span> <span class="n">Secure</span> <span class="n">Socket</span> <span class="n">Layer</span><span class="p">,</span> <span class="err">简称</span> <span class="n">SSL</span><span class="err">）是用来确保网络通信和事务安全的最常见的标准。现在只要你使用互联网，几乎就是这个标准的使用者。这个标准最初由网景公司（</span><span class="n">NetScape</span><span class="err">）设计并且实现，后来移交给了国际互联网工程任务组（</span><span class="n">The</span> <span class="n">Internet</span> <span class="n">Engineering</span> <span class="n">Task</span> <span class="n">Force</span><span class="err">，简称</span> <span class="n">IETF</span><span class="err">）管理，并且更名为传输层安全协议（</span><span class="n">Trassport</span> <span class="n">Layer</span> <span class="n">Security</span><span class="err">，简称</span> <span class="n">TLS</span><span class="err">）。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">我们通过浏览器输入，并且传输到网站的用户名和密码必须只有我们自己知道，不能在传输的过程中被第三者窃取，也不能传送给指定网站以外的服务器。一般来说，浏览器和服务器之间需要建立安全传输连接。这样，网站的真实性是经过校验的，浏览器和网站之间传输的所有数据都是经过加密的，只有我们自己和网站服务器可以解密、理解传输的数据。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">传输层安全协议就是用来满足这些安全需求的。那它是怎么做到呢？传输层安全协议需要使用一系列的密码技术，来保证安全连接的建立。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">保证数据的私密性使用的是数据加密技术。其中，影响最大的一类数据加密技术使用的是一种叫作链式加密</span> <span class="p">(</span><span class="n">Cipher</span> <span class="n">Block</span> <span class="n">Chaining</span><span class="err">，</span><span class="n">CBC</span><span class="p">)</span> <span class="err">的模式。简单地说，就是前一个加密数据的最后一个数据块，被用来作为后一个数据块加密的输入参数。这样，就形成了后一个加密数据依赖前一个加密数据的链条。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">1999</span> <span class="err">年</span> <span class="mi">1</span> <span class="err">月，传输层安全协议第一版发布，一般简称为</span> <span class="n">TLS</span> <span class="mf">1.0</span><span class="err">。</span><span class="n">TLS</span> <span class="mf">1.0</span> <span class="err">使用链式加密模式作为其加密传输数据的一个技术方案。</span><span class="n">TLS</span> <span class="mf">1.0</span> <span class="err">获得了巨大的成功。我们很难想象如果没有</span> <span class="n">TLS</span> <span class="err">协议，互联网会是一个什么样子。然而，完美的东西，渴求不来也偶遇不到。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">2001</span> <span class="err">年</span> <span class="mi">9</span> <span class="err">月的密码学进展大会上，一位密码学研究者（</span><span class="n">Hugo</span> <span class="n">Krawczyk</span><span class="err">）发表了一篇论文，该论文研究了链式加密的缺陷，以及对于</span> <span class="n">TLS</span> <span class="err">协议的影响。利用链式加密的缺陷，攻击者可以破解出加密密码，使用这个密码，就可以解密加密的传输数据，从而获取传输信息。从此，链式加密，一个有着最广泛影响的技术，开始淡出历史舞台。然而，这个进程非常缓慢，非常缓慢。在新技术替代的过程中，老技术的现有问题，以及新老技术的衔接，会出现很多非常复杂和棘手的问题。原有的技术使用得越多，部署得越广泛，这些问题越复杂。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">2002</span> <span class="err">年，</span><span class="n">OpenSSL</span><span class="err">，一个被广泛使用的实现传输层安全协议的类库，发布了针对链式加密缺陷的安全补丁和缺陷报告。这个解决方案的目的就是打破链式加密模式的链条，在数据块之间插入随机数据。由于随机数据插到了加密数据链之间，解决了链式加密模式的上述缺陷，这使得链式加密的形式和算法得以保留。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">幸运的是，</span><span class="n">TLS</span> <span class="err">协议的设计恰巧允许这种使用方法，那么</span> <span class="n">TLS</span> <span class="err">协议在理论上仍可以继续使用。既然是随机数据，那就是没有任何意义的数据，不能用于实际的应用，接收端必须忽略这些随机数据。</span><span class="n">TLS</span> <span class="err">协议通过传输一个空数据段，然后再传输有效数据，就可以达到添加随机数据的目的。</span> <span class="err">在理论上，这是一个很好的解决方案。然而，现实比想象的还要精彩。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">该解决方案的真正落地，需要</span> <span class="n">read</span><span class="p">()</span> <span class="err">函数或者类似的方法有一个好的实现。在接收到空数据段所代表的随机数据时，需要忽略该数据段，继续等待真正有效的数据，不能返回</span> <span class="mi">0</span><span class="err">。为什么不能返回</span> <span class="mi">0</span> <span class="err">呢？还记得上面的</span> <span class="n">read</span><span class="p">()</span> <span class="err">返回值规范吗？返回值为</span> <span class="mi">0</span><span class="err">，代表数据传输结束，应用程序就不应该继续使用该通道了，后续的数据都会被丢弃。可是对于这个解决方案，如果</span> <span class="n">read</span><span class="p">()</span> <span class="err">返回</span> <span class="mi">0</span><span class="err">，意味着真正的数据传输才刚刚开始，而不是结束。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">如果这样的实现存在，那么这个解决方案不但没有解决安全缺陷问题，还直接导致应用程序不能继续使用。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">有没有这样一时糊涂的实现呢？</span> <span class="n">OpenSSL</span> <span class="err">的缺陷报告里，提到了一个这样的糊涂的实现。有这么有一个产品，名字的简写是</span> <span class="n">MSIE</span><span class="err">。曾经，它是一种特立独行般的存在，到了哪里，哪里就会绽放出不一样的烟火。考虑到</span> <span class="n">MSIE</span> <span class="err">及其相关家族产品巨大的市场使用份额，谁采用该安全缺陷修复解决方案，谁就自绝于市场，自绝于广大的用户。遇到了这种巨大的互操作性问题后，</span><span class="n">OpenSSL</span> <span class="err">随后缺省关闭了这个安全漏洞修补方案。随后，其他公司，比如</span> <span class="n">Google</span> <span class="err">也曾经尝试在他们的产品中做类似的安全修复，都因为这种灾难性的互操作性问题而放弃。安全诚可贵，自由价更高！</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">对于这样糊涂的实现而言，这只能算是一个芝麻蒜皮的小问题。修复这样的问题也应该不是多么困难的事情。可是，真正的困难在于，这样的产品已经有了非常广泛的用户群体，以及产品部署，包括个人计算机、自动取款机、商超收银机以及银行柜员机等各种各样的形式。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">很多产品的部署形式使得产品的升级非常困难，更别提还有很多产品的实现，是以固件的方式存在的了。比如我们家里用的路由器，部署在计算机房里的交换机，以及每辆汽车里的计算机，这些都是升级非常困难的产品。用户越广泛，部署越广泛，升级就越困难，安全变更面临的挑战就越大。芝麻蒜皮的小问题，都可能构筑困难的障碍，带来巨大的风险，从而造成严重的损失。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">可能你会有疑问，我换一个浏览器不就没事了吗？如果服务器使用的是这样糊涂的实现，那么一个浏览器是没有办法访问这样的服务器提供的服务的。如果这样的服务器被广泛使用，那么一个浏览器的合理策略，就是不开启这种安全缺陷修复。很多网站不能访问的浏览器，是一个不会有人使用的浏览器。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">那么，我自己的服务器是不是可以启动这个安全修复呢？问题又回到了客户端，如果客户端使用了这样糊涂的实现，它也没有办法访问修复了的服务器。如果这样的客户端被广泛使用，比如说最流行的浏览器，那么一个服务器的最合理策略就是不开启这种安全修复。假如一个网站有很多用户不能访问，这实在不是网站设计者和拥有者的初衷。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">看起来，这似乎是一个死局！</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">当时的共识是，针对该漏洞的攻击并不会轻易得手，所以即使不修复该漏洞，估计也不是一个多大的问题。同时，针对该漏洞的升级协议也有条不紊地开始了。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">2006</span> <span class="err">年，经过</span> <span class="mi">4</span> <span class="err">年的反复敲打，传输层安全协议版本</span> <span class="mf">1.1</span> <span class="err">发布，一般简称为</span> <span class="n">TLS</span> <span class="mf">1.1</span><span class="err">。</span><span class="n">TLS</span> <span class="mf">1.1</span> <span class="err">的一个重要的任务，就是解决链式加密的缺陷。然而，任何一个标准从制定到落实，都有一段很长的路要走。</span><span class="n">TLS</span> <span class="mf">1.1</span> <span class="err">并没有得到业界及时的响应和应有的重视。携带着安全缺陷的</span> <span class="n">TLS</span> <span class="mf">1.0</span> <span class="err">依然统治着传输安全的世界，似乎大家并没有觉得有太多的不妥之处。</span> <span class="err">时间来到了十年后，</span><span class="mi">2011</span> <span class="err">年</span> <span class="mi">9</span> <span class="err">月。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">无奈的少数派</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">针对链式加密安全漏洞的攻击真的不会轻易得手吗？</span><span class="mi">2010</span> <span class="err">年，一个年轻人（</span><span class="n">Juliano</span> <span class="n">Rizzo</span><span class="err">），在印度尼西亚的海滩上阅读了</span> <span class="n">OpenSSL</span> <span class="err">的缺陷报告。在优美的印尼海滩上，他发现了一种可能非常有效的攻击方法。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">2011</span> <span class="err">年</span> <span class="mi">9</span> <span class="err">月，两位天才般的研究人员（</span><span class="n">Juliano</span> <span class="n">Rizzo</span><span class="err">，</span><span class="n">Thai</span> <span class="n">Duong</span><span class="err">）表示，给他们几分钟时间，他们就可以利用该漏洞入侵你的支付账户。他们给这个攻击技术取了一个超酷的名字，</span><span class="n">BEAST</span><span class="err">。你要是搜索一下“</span><span class="n">the</span> <span class="n">BEAST</span> <span class="n">attack</span><span class="err">”，就知道这是一个多么轰动的攻击技术。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">他们的研究成果受到了密码学家的高度赞美。但是业界厂商的处境就比较尴尬了。毕竟，这是他们十年前尝试修复，但是最后不得不放弃修复的漏洞。十年后的今天，原来阻碍这个漏洞修复的现实障碍，并没有减少。原计划</span> <span class="mi">2011</span> <span class="err">年</span> <span class="mi">7</span> <span class="err">月份公开发表论文的日期，不得不推迟。</span> <span class="err">因为直到</span> <span class="mi">7</span> <span class="err">月份，还是没有合适的修复方案。这让人感到有些失望，有些沮丧。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">7</span> <span class="err">月</span> <span class="mi">20</span> <span class="err">日，事情有了转机。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">如果传输空数据段不被接受，那么传输一个字节呢？空数据的</span> <span class="n">read</span><span class="p">()</span> <span class="err">实现可能返回</span> <span class="mi">0</span><span class="err">，一个字节的</span> <span class="n">read</span><span class="p">()</span> <span class="err">实现应该毫无例外地返回</span> <span class="mi">1</span><span class="err">。在</span> <span class="n">TLS</span> <span class="mf">1.0</span> <span class="err">的链式加密模式下，传输一个字节时，有足够随机的数据插入链式加密数据块之间，简单有效地打破链式加密模式的链条。基于这个想法，</span><span class="mi">7</span> <span class="err">月</span> <span class="mi">20</span> <span class="err">日，一个通常被称为</span> <span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="err">分割的解决方案被提出，并且得到了验证。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">由于该方法简单有效，主流厂商迅速采纳了这个方案，发布了对应产品的安全补丁。幸运的是，</span><span class="n">TLS</span> <span class="mf">1.0</span> <span class="err">续命了十年，业界有更多的时间完成产品的升级换代。不幸但也在预料之中的是，该方案也不是一点兼容性影响都没有。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">比如我们案例中讨论的代码，就出了大问题。预期收到一条完整的信息“</span><span class="n">Hello</span> <span class="n">from</span> <span class="n">server</span><span class="o">!</span><span class="err">”。</span> <span class="err">使用了这个安全补丁后，就必须要接收被分割的两条信息，“</span><span class="n">H</span><span class="err">”以及“</span><span class="n">ello</span> <span class="n">from</span> <span class="n">server</span><span class="o">!</span><span class="err">”。如果应用不能处理分割的信息，就不能好好工作了。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">幸运的是，虽然不能处理分割信息的应用依然存在，但是数量很少。而且，这是应用自身的问题，很难抱怨安全补丁的不是。由于主流的厂商拥抱了</span> <span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="err">分割法，而存在问题的应用又是少数派，这些少数派不得不亲手解决他们自身的问题。否则就面临着应用不得不停工的损失，或者承受安全攻击的风险。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">对于某一个特定的问题来说，一旦我们成为少数派的一部分，就有可能面临软件安全的风险，以及在兼容性方面做妥协。对于接口规范来说，我们应该严格遵从白名单原则，没有明文规定的行为规范，就不是能依赖的行为规范。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">小结</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">通过对这个评审案例的讨论，我想和你分享下面几点个人看法。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">对于应用接口（</span><span class="n">API</span><span class="err">）的使用，一定要严格遵守规范，小失误可能造成大麻烦；</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">对于应用接口（</span><span class="n">API</span><span class="err">）的定义，一定要清晰简单，描述一定要详实周到。如果使用者对规范的理解感到困难或者困惑，可能会带来难以预料的问题；</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">对于应用接口（</span><span class="n">API</span><span class="err">）的实现，一定要在规范许可范围内自由发挥。越是影响广泛的实现，越不要逾越规范的界限。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">这是一个特殊的案例，我们好像聊了一个故事。对这个案例，你还有什么看法吗？</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">一起来动手</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">我们讨论了</span> <span class="n">read</span><span class="p">()</span> <span class="err">函数返回值的问题，可是上述的案例，还有其他的问题存在。你还发现了什么问题？这些问题该怎么更改？你可以使用</span> <span class="n">Java</span> <span class="err">或者你熟悉的语言来修改。这可并不是一个简单的修改，我知道你一定会遇到很多问题，欢迎留言分享你的修改或者问题。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">如果让你给</span> <span class="n">clientHello</span><span class="p">()</span> <span class="err">或者</span> <span class="n">serverHello</span><span class="p">()</span> <span class="err">加上规范描述，你会怎么描述？你会用什么样的文字，告诉这个接口的使用者，该怎么正确地使用这个应用接口？这同样不是一个简单的小练习，欢迎分享你的规范描述。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">如果你觉得这篇文章有所帮助，欢迎点击“请朋友读”，把它分享给你的朋友或者同事。</span>
</span></span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/">代码精进之路</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3tomcat_jetty/41tomcat%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8cpu%E8%BF%87%E9%AB%98%E6%80%8E%E4%B9%88%E5%8A%9E/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">41Tomcat进程占用CPU过高怎么办</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/41%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%A1%88%E4%BE%8B%E7%BE%8E%E5%9B%A2%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%90%BD%E5%9C%B0%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84/">
            <span class="next-text nav-default">41强化学习案例美团是如何在推荐系统中落地强化学习的</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
