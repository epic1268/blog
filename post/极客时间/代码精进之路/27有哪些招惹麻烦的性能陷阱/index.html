<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>27有哪些招惹麻烦的性能陷阱 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="26 | 有哪些招惹麻烦的性能陷阱？
前面，我们讨论了改善代码性能的最基本的办法。接下来，我们讨论一些最佳实践，让我们先从一些容易被忽略的性能陷阱开始。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/27%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8B%9B%E6%83%B9%E9%BA%BB%E7%83%A6%E7%9A%84%E6%80%A7%E8%83%BD%E9%99%B7%E9%98%B1/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/27%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8B%9B%E6%83%B9%E9%BA%BB%E7%83%A6%E7%9A%84%E6%80%A7%E8%83%BD%E9%99%B7%E9%98%B1/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="27有哪些招惹麻烦的性能陷阱">
  <meta property="og:description" content="26 | 有哪些招惹麻烦的性能陷阱？
前面，我们讨论了改善代码性能的最基本的办法。接下来，我们讨论一些最佳实践，让我们先从一些容易被忽略的性能陷阱开始。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="代码精进之路">

  <meta itemprop="name" content="27有哪些招惹麻烦的性能陷阱">
  <meta itemprop="description" content="26 | 有哪些招惹麻烦的性能陷阱？
前面，我们讨论了改善代码性能的最基本的办法。接下来，我们讨论一些最佳实践，让我们先从一些容易被忽略的性能陷阱开始。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4878">
  <meta itemprop="keywords" content="代码精进之路">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="27有哪些招惹麻烦的性能陷阱">
  <meta name="twitter:description" content="26 | 有哪些招惹麻烦的性能陷阱？
前面，我们讨论了改善代码性能的最基本的办法。接下来，我们讨论一些最佳实践，让我们先从一些容易被忽略的性能陷阱开始。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">27有哪些招惹麻烦的性能陷阱</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4878 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>26 | 有哪些招惹麻烦的性能陷阱？</p>
<p>前面，我们讨论了改善代码性能的最基本的办法。接下来，我们讨论一些最佳实践，让我们先从一些容易被忽略的性能陷阱开始。</p>
<p>使用性能测试工具</p>
<p>今天我们的讲解需要用到一个工具，它就是 JMH。JMH 是为 Java 语言或者其他基于 JVM 的编程语言设计的一个基准测试工具。这一节，我们会使用这个工具来分析一些性能的陷阱。这里我们简单地介绍下，这个工具该怎么使用。</p>
<p>第一步，使用 Maven 工具建立一个基准测试项目（需要使用 Maven 工具）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ mvn archetype:generate \
</span></span><span class="line"><span class="cl">          -DinteractiveMode=false \
</span></span><span class="line"><span class="cl">          -DarchetypeGroupId=org.openjdk.jmh \
</span></span><span class="line"><span class="cl">          -DarchetypeArtifactId=jmh-java-benchmark-archetype \
</span></span><span class="line"><span class="cl">          -DgroupId=com.example \
</span></span><span class="line"><span class="cl">          -DartifactId=myJmh \
</span></span><span class="line"><span class="cl">          -Dversion=1.0
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个命令行，会生成一个 myJmh 的工程目录，和一个基准测试模板文件（myJmh/src/main/java/com/example/MyBenchmark.java）。通过更改这个测试模板，就可以得到你想要的基准测试了。</p>
<p>比如，你可以使用后面我们用到的基准测试代码，替换掉模板中的基准测试方法（measureStringApend）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">package com.example;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">import org.openjdk.jmh.annotations.Benchmark;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class MyBenchmark {
</span></span><span class="line"><span class="cl">    @Benchmark
</span></span><span class="line"><span class="cl">    public String measureStringApend() {
</span></span><span class="line"><span class="cl">        String targetString = &#34;&#34;;
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 10000; i++) {
</span></span><span class="line"><span class="cl">            targetString += &#34;hello&#34;;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        return targetString;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二步，编译基准测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cd myJmh
</span></span><span class="line"><span class="cl">$ mvn clean install
</span></span></code></pre></td></tr></table>
</div>
</div><p>第三步，运行你的基准测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cd myJmh
</span></span><span class="line"><span class="cl">$ Java -jar target/benchmarks.jar
</span></span></code></pre></td></tr></table>
</div>
</div><p>稍微等待，基准测试结果就出来了。我们需要关注的是&quot;Score&quot;这一栏，它表示的是每秒钟可以执行的基准测试方法的次数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Benchmark                Mode  Cnt        Score          Error  Units
</span></span><span class="line"><span class="cl">MyBenchmark.testMethod  thrpt   25        35.945 ▒       0.694  ops/s
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是 JMH 工具基本的使用流程，有关这个工具更多的选项和更详细的使用，需要你参考 JMH 的相关文档。</p>
<p>下面，我们通过字符串连接操作和哈希值的例子，来谈论一下这个工具要怎么使用，以及对应的性能问题。同时，我们再看看其他影响性能的一些小陷阱，比如内存的泄露、未关闭的资源和遗漏的 hashCode。</p>
<p>字符串的操作</p>
<p>在 Java 的核心类库里，有三个字符串操作的类，分别问 String、StringBuilder 和 StringBuffer。通过下面的基准测试，我们来了解下这三种不同的字符串操作的性能差异。为了方便，我把 JMH 测试的数据，标注在每个基准测试的方法注释里了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // JMH throughput benchmark: about 32 operations per second
</span></span><span class="line"><span class="cl">    @Benchmark
</span></span><span class="line"><span class="cl">    public String measureStringApend() {
</span></span><span class="line"><span class="cl">        String targetString = &#34;&#34;;
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 10000; i++) {
</span></span><span class="line"><span class="cl">            targetString += &#34;hello&#34;;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        return targetString;
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>    // JMH throughput benchmark: about 5,600 operations per second
    @Benchmark
    public String measureStringBufferApend() {
        StringBuffer buffer = new StringBuffer();
        for (int i = 0; i &lt; 10000; i++) {
            buffer.append(&ldquo;hello&rdquo;);
        }</p>
<p>        return buffer.toString();
    }</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // JMH throughput benchmark: about 21,000 operations per second
</span></span><span class="line"><span class="cl">    @Benchmark
</span></span><span class="line"><span class="cl">    public String measureStringBuilderApend() {
</span></span><span class="line"><span class="cl">        StringBuilder builder = new StringBuilder();
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 10000; i++) {
</span></span><span class="line"><span class="cl">            builder.append(&#34;hello&#34;);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        return builder.toString();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">```
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">对于字符串连接的操作，这个基准测试结果显示，使用 StringBuffer 的字符串连接操作，比使用 String 的操作快了近 200 倍；使用 StringBuilder 的字符串连接操作，比使用 String 的操作快了近 700 倍。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">String 的字符串连接操作为什么慢呢？ 这是因为每一个字符串连接的操作（targetString += “hello”），都需要创建一个新的 String 对象，然后再销毁，再创建。这种模式对 CPU 和内存消耗都比较大。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">StringBuilder 和 StringBuffer 为什么快呢？因为 StringBuilder 和 StringBuffer 的内部实现，预先分配了一定的内存。字符串操作时，只有预分配内存不足，才会扩展内存，这就大幅度减少了内存分配、拷贝和释放的频率。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">StringBuilder 为什么比 StringBuffer 还要快呢？StringBuffer 的字符串操作是多线程安全的，而 StringBuilder 的操作就不是。如果我们看这两个方法的实现代码，除了线程安全的同步以外，几乎没有差别。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">```
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public final class StringBuffer
</span></span><span class="line"><span class="cl">    extends AbstractStringBuilder
</span></span><span class="line"><span class="cl">    implements java.io.Serializable, Comparable&lt;StringBuffer&gt;, CharSequence {
</span></span><span class="line"><span class="cl">    // snipped
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    @HotSpotIntrinsicCandidate
</span></span><span class="line"><span class="cl">    public synchronized StringBuffer append(String str) {
</span></span><span class="line"><span class="cl">        toStringCache = null;
</span></span><span class="line"><span class="cl">        super.append(str);
</span></span><span class="line"><span class="cl">        return this;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //  snipped
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>public final class StringBuilder
    extends AbstractStringBuilder
    implements java.io.Serializable, Comparable<StringBuilder>, CharSequence {
    // snipped</p>
<p>    @Override
    @HotSpotIntrinsicCandidate
    public StringBuilder append(String str) {
        super.append(str);
        return this;
    }</p>
<p>    // snipped
}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">JMH 的基准测试，并没有涉及到线程同步问题，难道使用 synchronized 关键字也会有性能损耗吗？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">我们再来看看另外一个基准测试。这个基准测试，使用线程不安全的 StringBuilder 以及同步的字符串连接，部分模拟了线程安全的 StringBuffer.append() 方法的实现。为了方便你对比，我把没有使用同步的代码也拷贝在下面。
</span></span></code></pre></td></tr></table>
</div>
</div><p>    // JMH throughput benchmark: about 21,000 operations per second
    @Benchmark
    public String measureStringBuilderApend() {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i &lt; 10000; i++) {
            builder.append(&ldquo;hello&rdquo;);
        }</p>
<p>        return builder.toString();
    }</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // JMH throughput benchmark: about 16,000 operations per second
</span></span><span class="line"><span class="cl">    @Benchmark
</span></span><span class="line"><span class="cl">    public String measureStringBuilderSynchronizedApend() {
</span></span><span class="line"><span class="cl">        StringBuilder builder = new StringBuilder();
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 10000; i++) {
</span></span><span class="line"><span class="cl">            synchronized (this) {
</span></span><span class="line"><span class="cl">                builder.append(&#34;hello&#34;);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        return builder.toString();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">```
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这个基准测试结果显示，虽然基准测试并没有使用多个线程，但是使用了线程同步的代码比不使用线程同步的代码慢。线程同步，就是 StringBuffer 比 StringBuilder 慢的原因之一。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">通过上面的基准测试，我们可以得出这样的结论：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">频繁的对象创建、销毁，有损代码的效率；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">减少内存分配、拷贝、释放的频率，可以提高代码的效率；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">即使是单线程环境，使用线程同步依然有损代码的效率。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">从上面的基准测试结果，是不是可以得出结论，我们应该使用 StringBuilder 来进行字符串操作呢？我们再来看几个基准测试的例子。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">下面的例子，测试的是常量字符串的连接操作。从测试结果，我们可以看出，使用 String 的连接操作，要比使用 StringBuilder 的字符串连接快 5 万倍，这是一个让人惊讶的性能差异。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">```
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // JMH throughput benchmark: about 1,440,000,000 operations per second
</span></span><span class="line"><span class="cl">    @Benchmark
</span></span><span class="line"><span class="cl">    public void measureSimpleStringApend() {
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 10000; i++) {
</span></span><span class="line"><span class="cl">            String targetString = &#34;Hello, &#34; + &#34;world!&#34;;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>    // JMH throughput benchmark: about 26,000 operations per second
    @Benchmark
    public void measureSimpleStringBuilderApend() {
        for (int i = 0; i &lt; 10000; i++) {
            StringBuilder builder = new StringBuilder();
            builder.append(&ldquo;hello, &ldquo;);
            builder.append(&ldquo;world!&rdquo;);
        }
    }</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这个巨大的差异，主要来自于 Java 编译器和 JVM 对字符串处理的优化。&#34; Hello, &#34; + &#34; world! &#34; 这样的表达式，并没有真正执行字符串连接。编译器会把它处理成一个连接好的常量字符串&#34;Hello, world!&#34;。这样，也就不存在反复的对象创建和销毁了，常量字符串的连接显示了超高的效率。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">如果字符串的连接里，出现了变量，编译器和 JVM 就没有办法进行优化了。这时候，StringBuilder 的效率优势才能体现出来。下面的两个基准测试结果，就显示了变量对于字符长连接操作效率的影响。
</span></span></code></pre></td></tr></table>
</div>
</div><p>    // JMH throughput benchmark: about 9,000 operations per second
    @Benchmark
    public void measureVariableStringApend() {
        for (int i = 0; i &lt; 10000; i++) {
            String targetString = &ldquo;Hello, &quot; + getAppendix();
        }
    }</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // JMH throughput benchmark: about 26,000 operations per second
</span></span><span class="line"><span class="cl">    @Benchmark
</span></span><span class="line"><span class="cl">    public void measureVariableStringBuilderApend() {
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 10000; i++) {
</span></span><span class="line"><span class="cl">            StringBuilder builder = new StringBuilder();
</span></span><span class="line"><span class="cl">            builder.append(&#34;hello, &#34;);
</span></span><span class="line"><span class="cl">            builder.append(getAppendix());
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>    private String getAppendix() {
       return &ldquo;World!&rdquo;;
    }</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">通过上面的基准测试，我们可以总结出下面的几条最佳实践：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Java 的编译器会优化常量字符串的连接，我们可以放心地把长的字符串换成多行；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">带有变量的字符串连接，StringBuilder 效率更高。如果效率敏感的代码，建议使用 StringBuilder。String 的连接操作可读性更高，效率不敏感的代码可以使用，比如异常信息、调试日志、使用不频繁的代码；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">如果涉及大量的字符串操作，使用 StringBuilder 效率更高；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">除非有线程安全的需求，不推荐使用线程安全的 StringBuffer。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">内存的泄露
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">内存泄漏是 C 语言的一个大问题。为了更好地管理内存，Java 提供了自动的内存管理和垃圾回收机制。但是，Java 依然会泄露内存。这种内存泄漏的主要表现是，如果一个对象不再有用处，而且它的引用还没有清零，垃圾回收器就意识不到这个对象需要及时回收，这时候就引发了内存泄露。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">生命周期长的集合，是 Java 容易发生内存泄漏的地方。比如，可以扩张的静态的集合，或者存活时间长的缓存等。如果不能及时清理掉集合里没有用处的对象，就会造成内存的持续增加，引发内存泄漏问题。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">比如下面这两个例子，就容易发生内存泄露。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">静态的集合：
</span></span></code></pre></td></tr></table>
</div>
</div><p>static final List<Object>
         staticCachedObjects = new LinkedList&lt;&gt;();</p>
<p>// snipped
staticCachedObjects.add(&hellip;);</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">长寿的缓存：
</span></span></code></pre></td></tr></table>
</div>
</div><p>final List<Object>
        longLastingCache = new LinkedList&lt;&gt;();</p>
<p>// snipped
longLastingCache.add(&hellip;);</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">解决这个问题的办法通常是使用 SoftReference 和 WeakReference 来存储对象的引用，或者主动地定期清理。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">静态的集合：
</span></span></code></pre></td></tr></table>
</div>
</div><p>static final List&lt;WeakReference<Object>&gt;
        staticCachedObjects = new LinkedList&lt;&gt;();</p>
<p>// snipped
staticCachedObjects.add(&hellip;);</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">长寿的缓存：
</span></span></code></pre></td></tr></table>
</div>
</div><p>final List&lt;WeakReference<Object>&gt;
        longLastingCache = new LinkedList&lt;&gt;();</p>
<p>// snipped
longLastingCache.add(&hellip;);</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">需要注意的是，缓存的处理是一个复杂的问题，使用 SoftReference 和 WeakReference 未必能够满足你的业务需求。更有效的缓存解决方案，依赖于具体的使用场景。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">未关闭的资源
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">有很多系统资源，需要明确地关闭，要不然，占用的系统资源就不能有效地释放。比如说，数据库连接、套接字连接和 I/O 操作等。原则上，所有实现了 Closable 接口的对象，都应该调用 close() 操作；所有需要明确关闭的类，都应该实现 Closable 接口。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">需要注意的是，close() 操作，一定要使用 try-finally 或者 try-with-resource 语句。要不然，关闭资源的代码可能很复杂。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">如果一个类需要关闭，但是又没有实现 Closable 接口，就比较麻烦，比如 URLConnection. URLConnection.connect() 能够建立连接，该连接需要关闭，但是 URLConnection 没有实现 Closable 接口，关闭的办法只能是关闭对应的 I/O 接口，可是关闭 I/O 输入和输出接口中的一个，还不能保证整个连接会完全关闭。谨慎的代码，需要把 I/O 输入和输出都关闭掉，哪怕不需要输入或者输出。但是这样一来，我们的编码负担就会加重。所以最好的方法就是实现 Closable 接口。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">双向关闭 I/O：
</span></span></code></pre></td></tr></table>
</div>
</div><p>URL url = new URL(&ldquo;<a href="http://www.google.com/%22);">http://www.google.com/&quot;);</a>
URLConnection conn = url.openConnection();
conn.connect();</p>
<p>try (InputStream is = conn.getInputStream()) {
    // sinnped
}</p>
<p>try (OutputStream os = conn.getOutputStream()) {
    // sinnped
}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">单向关闭 I/O：
</span></span></code></pre></td></tr></table>
</div>
</div><p>URL url = new URL(&ldquo;<a href="http://www.google.com/%22);">http://www.google.com/&quot;);</a>
URLConnection conn = url.openConnection();
conn.connect();</p>
<p>try (InputStream is = conn.getInputStream()) {
    // sinnped
}</p>
<p>// The output strean is not close, the connection may be still alive.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">遗漏的 hashCode
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">在使用 Hashtbale、HashMap、HashSet 这样的依赖哈希（hash）值的集合时，有时候我们会忘记要检查产生哈希值的对象，一定要实现 hashCode() 和 equals() 这两个方法。缺省的 hashCode() 实现，返回值是每一个对象都不同的数值。即使是相等的对象，不同的哈希值，使用基于哈希值的集合时，也会被看作不同的对象。这样的行为，可能不符合我们的预期。而且，使用没有实现 hashCode() 和 equals() 这两个方法的对象，可能会造成集合的尺寸持续增加，无端地占用内存，甚至会造成内存的泄漏。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">所以，我们使用基于 hash 的集合时，一定要确保集合里的对象，都正确地实现了 hashCode() 和 equals() 这两个方法。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">撞车的哈希值
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">实现 hashCode() 这个方法的，并没有要求不相等对象的返回值也必须是不相等的。但是如果返回的哈希值不同，对集合的性能就会有比较大的影响。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">下面的两个基准测试结果显示，如果 10,000 个对象，只有 10 个不同的哈希值，它的集合运算的性能是令人担忧的。和使用了不用哈希值的实现相比，性能有几百倍的差异。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这种性能差异，主要是由基于哈希值的集合的实现方式决定的。哈希值如果相同，就要调用其他的方法来识别一个对象。哈希值如果不同，哈希值本身就可以确定一个对象的索引。如果哈希值撞车比例大，这种检索和计算的差距就会很大。
</span></span></code></pre></td></tr></table>
</div>
</div><p>    // JMH throughput benchmark: about 5,000 operations per second
    @Benchmark
    public void measureHashMap() throws IOException {
        Map&lt;HashedKey, String&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; 10000; i++) {
            map.put(new HashedKey(i), &ldquo;value&rdquo;);
        }
    }</p>
<p>    private static class HashedKey {
        final int key;</p>
<p>        HashedKey(int key) {
            this.key = key;
        }</p>
<p>        @Override
        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }</p>
<p>            if (obj instanceof HashedKey) {
                return key == ((HashedKey)obj).key;
            }</p>
<p>            return false;
        }</p>
<p>        @Override
        public int hashCode() {
            return key;
        }
    }</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // JMH throughput benchmark: about 9.5 operations per second
</span></span><span class="line"><span class="cl">    @Benchmark
</span></span><span class="line"><span class="cl">    public void measureCollidedHashMap() throws IOException {
</span></span><span class="line"><span class="cl">        Map&lt;CollidedKey, String&gt; map = new HashMap&lt;&gt;();
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 10000; i++) {
</span></span><span class="line"><span class="cl">            map.put(new CollidedKey(i), &#34;value&#34;);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private static class CollidedKey {
</span></span><span class="line"><span class="cl">        final int key;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        CollidedKey(int key) {
</span></span><span class="line"><span class="cl">            this.key = key;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        @Override
</span></span><span class="line"><span class="cl">        public boolean equals(Object obj) {
</span></span><span class="line"><span class="cl">            if (obj == this) {
</span></span><span class="line"><span class="cl">                return true;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            if (obj instanceof CollidedKey) {
</span></span><span class="line"><span class="cl">                return key == ((CollidedKey)obj).key;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            return false;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        @Override
</span></span><span class="line"><span class="cl">        public int hashCode() {
</span></span><span class="line"><span class="cl">            return key % 10;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">```
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">小结
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">今天，我们主要讨论了一些容易被忽略的性能陷阱。比如，字符串怎么操作才是高效的；Java 常见的内存泄漏；资源关闭的正确方法以及集合的相关性能问题。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">我们虽然使用了 Java 作为示例，但是像集合和字符串操作这样的性能问题，并不局限于特定的编程语言，你也可以看看你熟悉的编程语言有没有类似的问题。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">一起来动手
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这一次的练手题，我们来练习使用 JMH 工具，分析更多的性能问题。在“撞车的哈希值”这一小节，我们测试了 HashMap 的 put 方法，你能不能测试下其他方法以及其他基于哈希值的集合（HashSet，Hashtable）？我们测试的是 10,000 个对象，只有 10 个哈希值。如果 10,000 个对象，有 5,000 个哈希值，性能影响有多大？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">下面的这段代码，你能够找到它的性能问题吗？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">```
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">package com.example;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">import java.util.Arrays;
</span></span><span class="line"><span class="cl">import java.util.Random;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class UserId {
</span></span><span class="line"><span class="cl">    private static final Random random = new Random();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private final byte[] userId = new byte[32];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public UserId() {
</span></span><span class="line"><span class="cl">        random.nextBytes(userId);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public boolean equals(Object obj) {
</span></span><span class="line"><span class="cl">        if (obj == this) {
</span></span><span class="line"><span class="cl">            return true;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (obj instanceof UserId) {
</span></span><span class="line"><span class="cl">            return Arrays.equals(this.userId, ((UserId)obj).userId);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        return false;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public int hashCode() {
</span></span><span class="line"><span class="cl">        int retVal = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; userId.length; i++) {
</span></span><span class="line"><span class="cl">            retVal += userId[i];
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        return retVal;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">```
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">我们前面讨论了下面这段代码的性能问题，你能够使用 JMH 测试一个你的改进方案带来的效率提升吗？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">```
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">import java.util.HashMap;
</span></span><span class="line"><span class="cl">import java.util.Map;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * Given an array of integers, return indices of the two numbers
</span></span><span class="line"><span class="cl">     * such that they add up to a specific target.
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public int[] twoSum(int[] nums, int target) {
</span></span><span class="line"><span class="cl">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; nums.length; i++) {
</span></span><span class="line"><span class="cl">            int complement = target - nums[i];
</span></span><span class="line"><span class="cl">            if (map.containsKey(complement)) {
</span></span><span class="line"><span class="cl">                return new int[] { map.get(complement), i };
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            map.put(nums[i], i);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        throw new IllegalArgumentException(&#34;No two sum solution&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">```
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">另外，你也可以检查一下你手头的代码，看看有没有踩到类似的坑。如果遇到类似的陷阱，看一看能不能改进。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">容易被忽略的性能陷阱，有很多种。这些大大小小的经验，需要我们日复一日的积累。如果你有这方面的经验，或者看到这方面的技术，请你分享在留言区，我们一起来学习、积累这些经验。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">也欢迎点击“请朋友读”，把这篇文章分享给你的朋友或者同事，一起交流一下。
</span></span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/">代码精进之路</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%82%B1%E5%B2%B3%E7%9A%84%E4%BA%A7%E5%93%81%E6%89%8B%E8%AE%B0/27%E5%86%99%E5%A5%BD%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E7%9A%84%E8%AF%80%E7%AA%8D/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">27写好产品文档的诀窍</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/27%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%BA%E7%94%A8%E6%88%B7%E5%B1%8F%E8%94%BDrpc%E8%B0%83%E7%94%A8%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%86%E8%8A%82/">
            <span class="next-text nav-default">27动态代理：为用户屏蔽RPC调用的底层细节</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
