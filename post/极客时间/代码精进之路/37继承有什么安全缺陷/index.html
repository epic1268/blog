<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>37继承有什么安全缺陷 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="36 | 继承有什么安全缺陷？
有时候，为了解决一个问题，我们需要一个解决办法。可是，这个办法本身还会带来更多的问题。新问题的解决带来更新的问题，就这样周而复始，绵延不绝。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/37%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/37%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="37继承有什么安全缺陷">
  <meta property="og:description" content="36 | 继承有什么安全缺陷？
有时候，为了解决一个问题，我们需要一个解决办法。可是，这个办法本身还会带来更多的问题。新问题的解决带来更新的问题，就这样周而复始，绵延不绝。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="代码精进之路">

  <meta itemprop="name" content="37继承有什么安全缺陷">
  <meta itemprop="description" content="36 | 继承有什么安全缺陷？
有时候，为了解决一个问题，我们需要一个解决办法。可是，这个办法本身还会带来更多的问题。新问题的解决带来更新的问题，就这样周而复始，绵延不绝。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3748">
  <meta itemprop="keywords" content="代码精进之路">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="37继承有什么安全缺陷">
  <meta name="twitter:description" content="36 | 继承有什么安全缺陷？
有时候，为了解决一个问题，我们需要一个解决办法。可是，这个办法本身还会带来更多的问题。新问题的解决带来更新的问题，就这样周而复始，绵延不绝。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">37继承有什么安全缺陷</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3748 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>36 | 继承有什么安全缺陷？</p>
<p>有时候，为了解决一个问题，我们需要一个解决办法。可是，这个办法本身还会带来更多的问题。新问题的解决带来更新的问题，就这样周而复始，绵延不绝。</p>
<p>比如上一篇文章中，我们说到的敏感信息通过异常信息泄露的问题，就是面向对象设计和实现给我们带来的小困扰。再比如前面还有一个案例，说到了共享内存或者缓存技术带来的潜在危害和挑战，这些都是成熟技术发展背后需要做出的小妥协。只是有时候，这些小小的妥协如果没有被安排好和处理好，可能就会带来不成比例的代价。</p>
<p>评审案例</p>
<p>我们一起来看一段节选的 java.io.FilePermission 类的定义。你知道为什么 FilePermission 被定义为 final 类吗？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">package java.io;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// &lt;snipped&gt;
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * This class represents access to a file or directory.  A
</span></span><span class="line"><span class="cl"> * FilePermission consists of a pathname and a set of actions
</span></span><span class="line"><span class="cl"> * valid for that pathname.
</span></span><span class="line"><span class="cl"> * &lt;snipped&gt;
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">public final class FilePermission
</span></span><span class="line"><span class="cl">        extends Permission implements Serializable {
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * Creates a new FilePermission object with the specified actions.
</span></span><span class="line"><span class="cl">     * &lt;i&gt;path&lt;/i&gt; is the pathname of a file or directory, and
</span></span><span class="line"><span class="cl">     * &lt;i&gt;actions&lt;/i&gt; contains a comma-separated list of the desired
</span></span><span class="line"><span class="cl">     * actions granted on the file or directory. Possible actions are
</span></span><span class="line"><span class="cl">     * &#34;read&#34;, &#34;write&#34;, &#34;execute&#34;, &#34;delete&#34;, and &#34;readlink&#34;.
</span></span><span class="line"><span class="cl">     * &lt;snipped&gt;
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public FilePermission(String path, String actions);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * Returns the &#34;canonical string representation&#34; of the actions.
</span></span><span class="line"><span class="cl">     * That is, this method always returns present actions in the
</span></span><span class="line"><span class="cl">     * following order: read, write, execute, delete, readlink. 
</span></span><span class="line"><span class="cl">     * &lt;snipped&gt;
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public String getActions();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * Checks if this FilePermission object &#34;implies&#34; the 
</span></span><span class="line"><span class="cl">     * specified permission.
</span></span><span class="line"><span class="cl">     * &lt;snipped&gt;
</span></span><span class="line"><span class="cl">     * @param p the permission to check against.
</span></span><span class="line"><span class="cl">     *
</span></span><span class="line"><span class="cl">     * @return &lt;code&gt;true&lt;/code&gt; if the specified permission
</span></span><span class="line"><span class="cl">     *         is not &lt;code&gt;null&lt;/code&gt; and is implied by this
</span></span><span class="line"><span class="cl">     *         object, &lt;code&gt;false&lt;/code&gt; otherwise.
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public boolean implies(Permission p);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // &lt;snipped&gt;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>FilePermission 被声明为 final，也就意味着该类不能被继承，不能被扩展了。我们都知道，在面向对象的设计中，是否具备可扩展性是一个衡量设计优劣的好指标。如果允许扩展的话，那么想要增加一个“link”的操作就会方便很多，只要扩展 FilePermission 类就可以了。 但是对于 FilePermission 这个类，OpenJDK 为什么放弃了可扩展性？</p>
<p>案例分析</p>
<p>如果我们保留 FilePermission 的可扩展性，你来评审一下下面的代码，可以看出这段代码的问题吗？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">package com.example;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public final class MyFilePermission extends FilePermission {
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public String getActions() {
</span></span><span class="line"><span class="cl">      return &#34;read&#34;;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public boolean implies(Permission p) {
</span></span><span class="line"><span class="cl">      return true;
</span></span><span class="line"><span class="cl">    }  
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你还没有找出这个问题，可能是因为我还遗漏了对 FilePermission 常见使用场景的介绍。在 Java 的安全管理模式下，一个用户通常可能会被授予有限的权限。 比如用户“xuelei”可以读取用户“duke”的文件，但不能更改用户“duke”的文件。</p>
<p>授权的策咯可能看起来像下面的描述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">grant Principal com.sun.security.auth.UnixPrincipal &#34;xuelei&#34; {
</span></span><span class="line"><span class="cl">    permission com.example.MyFilePermission &#34;/home/duke&#34;, &#34;read&#34;;
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>这项策略要想起作用，上面的描述就要转换成一个 MyFilePermission 的实例。然后调用该实例的 implies() 方法类判断是否可以授权一项操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Permission myPermission = ...  // read &#34;/home/duke&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public void checkRead() {
</span></span><span class="line"><span class="cl">  if (myPermission.implies(New FilePermission(file, &#34;read&#34;))) {
</span></span><span class="line"><span class="cl">    // read is allowed.
</span></span><span class="line"><span class="cl">  } else {
</span></span><span class="line"><span class="cl">    // throw exception, read is not allowed.
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public void checkWrite() {
</span></span><span class="line"><span class="cl">  if (myPermission.implies(New FilePermission(file, &#34;write&#34;))) {
</span></span><span class="line"><span class="cl">    // writeis allowed.
</span></span><span class="line"><span class="cl">  } else {
</span></span><span class="line"><span class="cl">    // throw exception, write is not allowed.
</span></span><span class="line"><span class="cl">  }  
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里请注意，MyFilePermission.implies() 总是返回“true”， 所以上述的 checkRead() 和 checkWrite() 方法总是成功的，不管用户被明确指示授予了什么权限，实际上暗地里他已经被授予了所有权限。这就成功地绕过了 Java 的安全管理。</p>
<p>能够绕过 Java 安全机制的主要原因，在于我们允许了 FilePermission 的扩展。而扩展类的实现，有可能有意或者无意地改变了 FilePermission 的规范和运行，从而带来不可预料的行为。</p>
<p>如果你关注 OpenJDK 安全组的代码评审邮件组，你可能会注意到，对于面向对象的可扩展性这一便利和诱惑，很多工程师能够保持住克制。</p>
<p>保持克制，可能会遗漏一两颗看似近在眼前的甜甜的糖果，但可以减轻你对未来长期的担忧。</p>
<p>一个类或者方法如果使用了 final 关键字，我们可以稍微放宽心。如果没有使用 final 关键字，我们可能需要反复揣摩好长时间，仔细权衡可扩展性可能会带来的弊端。</p>
<p>一个公共类或者方法如果使用了 final 关键字，将来如果需要扩展性，就可以去掉这个关键字。但是，如果最开始没有使用 final 关键字，特别是对于公开的接口来说，将来想要加上就可能是一件非常困难的事。</p>
<p>上面的例子是子类通过改变父类的规范和行为带来的潜在问题。那么父类是不是也可以改变子类的行为呢？ 这听起来有点怪异，但是父类对子类行为的影响，有时候也的确是一个让人非常头疼的问题。</p>
<p>麻烦的继承</p>
<p>我先总结一下，父类对子类行为的影响大致有三种：</p>
<p>改变未继承方法的实现，或者子类调用的方法的实现（super）；</p>
<p>变更父类或者父类方法的规范；</p>
<p>为父类添加新方法。</p>
<p>第一种和第三种相对比较容易理解，第二种稍微复杂一点。我们还是通过一个例子来看看其中的问题。</p>
<p>Hashtable 是一个古老的，被广泛使用的类，它最先出现在 JDK 1.0 中。其中，put() 和 remove() 是两个关键的方法。在 JDK 1.2 中，又有更多的方法被添加进来，比如 entrySet() 方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class Hashtable&lt;K,V&gt; ... {
</span></span><span class="line"><span class="cl">    // snipped
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * Returns a {@link Set} view of the mappings contained in
</span></span><span class="line"><span class="cl">     （ this map.
</span></span><span class="line"><span class="cl">     * The set is backed by the map, so changes to the map are
</span></span><span class="line"><span class="cl">     * reflected in the set, and vice-versa.  If the map is modified
</span></span><span class="line"><span class="cl">     * while an iteration over the set is in progress (except through
</span></span><span class="line"><span class="cl">     * the iterator&#39;s own {@code remove} operation, or through the
</span></span><span class="line"><span class="cl">     * {@code setValue} operation on a map entry returned by the
</span></span><span class="line"><span class="cl">     * iterator) the results of the iteration are undefined.  The set
</span></span><span class="line"><span class="cl">     * supports element removal, which removes the corresponding
</span></span><span class="line"><span class="cl">     * mapping from the map, via the {@code Iterator.remove},
</span></span><span class="line"><span class="cl">     * {@code Set.remove}, {@code removeAll}, {@code retainAll} and
</span></span><span class="line"><span class="cl">     * {@code clear} operations.  It does not support the
</span></span><span class="line"><span class="cl">     * {@code add} or {@code addAll} operations.
</span></span><span class="line"><span class="cl">     *
</span></span><span class="line"><span class="cl">     * @since 1.2
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
</span></span><span class="line"><span class="cl">        // snipped
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // snipped
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这就引入了一个难以察觉的潜在的安全漏洞。 你可能会问，添加一个方法不是很常见吗？这能有什么问题呢？</p>
<p>问题在于继承 Hashtable 的子类。假设有一个子类，它的 Hashtable 里要存放敏感数据，数据的添加和删除都需要授权，在 JDK 1.2 之前，这个子类可以重写 put() 和 remove() 方法，加载权限检查的代码。在 JDK 1.2 中，这个子类可能意识不到 Hashtable 添加了 entrySet() 这个新方法，从而也没有意识到要重写覆盖 entrySet() 方法，然而，通过对 entrySet() 返回值的直接操作，就可以执行数据的添加和删除的操作，成功地绕过了授权。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class MySensitiveData extends Hashtable&lt;Object, Object&gt; {
</span></span><span class="line"><span class="cl">    // snipped
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public synchronized Object put(Object key, Object value) {
</span></span><span class="line"><span class="cl">        // check permission and then add the key-value
</span></span><span class="line"><span class="cl">        // snipped
</span></span><span class="line"><span class="cl">        super.put(key, value)
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public synchronized Object remove(Object key) {
</span></span><span class="line"><span class="cl">        // check permission and then remove the key-value
</span></span><span class="line"><span class="cl">        // snipped
</span></span><span class="line"><span class="cl">        return super.remove(key);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // snipped, no override of entrySet()
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>MySensitiveData sensitiveData = &hellip;   // get the handle of the data
Set&lt;Map.Entry&lt;Object, Object&raquo; sdSet = sensitiveData.entrySet();
sdSet.remove(&hellip;);    // no permission check
sdSet.add(&hellip;);       // no permission check</p>
<p>// the sensitive data get modified, unwarranted.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">现实中，这种问题非常容易发生。一般来说，我们的代码总是依赖一定的类库，有时候需要扩展某些类。这个类库可能是第三方的产品，也可能是一个独立的内部类库。但遗憾的是，类库并不知道我们需要拓展哪些类，也可能没办法知道我们该如何拓展。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">所以，当有一个新方法添加到类库的新版本中时，这个新方法会如何影响扩展类，该类库也没有特别多的想象空间和处理办法。就像 Hashtable 要增加 entrySet() 方法时，让 Hashtable 的维护者意识到有一个特殊的 MySensitiveData 扩展，是非常困难和不现实的。然而 Hashtable 增加 entrySet() 方法，合情又合理，也没有什么值得抱怨的。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">然而，当 JDK 1.0/1.1 升级到 JDK 1.2 时，Hashtable 增加了 entrySet() 方法，上述的 MySensitiveData 的实现就存在严重的安全漏洞。要想修复该安全漏洞，MySensitiveData 需要重写覆盖 entrySet() 方法，植入权限检查的代码。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">可是，我们怎样可能知道 MySensitiveData 需要修改呢！ 一般来说，如果依赖的类库进行了升级，没有影响应用的正常运营，我们就正常升级了，而不会想到检查依赖类库做了哪些具体的变更，以及评估每个变更潜在的影响。这实在不是软件升级的初衷，也远远超越了大部分组织的能力范围。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">而且，如果 MySensitiveData 不是直接继承 Hashtable，而是经过了中间环节，这个问题就会更加隐晦，更加难以察觉。
</span></span></code></pre></td></tr></table>
</div>
</div><p>public class IntermediateOne extends Hashtable&lt;Object, Object&gt;;</p>
<p>public class IntermediateTwo extends IntermediateOne;</p>
<p>public class Intermediate extends IntermediateTwo;</p>
<p>public class MySensitiveData extends Intermediate;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">糟糕的是，随着语言变得越来越高级，类库越来越丰富，发现这些潜在问题的难度也是节节攀升。我几乎已经不期待肉眼可以发现并防范这类问题了。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">那么，到底有没有办法可以防范此类风险呢？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">主要有两个方法。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">一方面，当我们变更一个可扩展类时，要极其谨慎小心。一个类如果可以不变更，就尽量不要变更，能在现有框架下解决问题，就尽量不要试图创造新的轮子。有时候，我们的确难以压制想要创造出什么好东西的冲动，这是非常好的品质。只是变更公开类库时，一定要多考虑这么做的潜在影响。你是不是开始思念 final 关键字的好处了？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">另一方面，当我们扩展一个类时，如果涉及到敏感信息的授权与保护，可以考虑使用代理的模式，而不是继承的模式。代理模式可以有效地降低可扩展对象的新增方法带来的影响。
</span></span></code></pre></td></tr></table>
</div>
</div><p>public class MySensitiveData {
    private final Hashtable hashtable = &hellip;</p>
<p>    public synchronized Object put(Object key, Object value) {
        // check permission and then add the key-value
        hashtable.put(key, value)
    }</p>
<p>    public synchronized Object remove(Object key) {
        // check permission and then remove the key-value
        return hashtable.remove(key);
    }
}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">我们使用了 Java 语言来讨论继承的问题，其实这是一个面向对象机制的普遍的问题，甚至它也不单单是面向对象语言的问题，比如使用 C 语言的设计和实现，也存在类似的问题。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">小结
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">通过对这个案例的讨论，我想和你分享下面两点个人看法。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">一个可扩展的类，子类和父类可能会相互影响，从而导致不可预知的行为。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">涉及敏感信息的类，增加可扩展性不一定是个优先选项，要尽量避免父类或者子类的影响。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">学会处理和保护敏感信息，是一个优秀工程师必须迈过的门槛。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">一起来动手
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">了解语言和各种固定模式的缺陷，是我们打怪升级的一个很好的办法。有时候，我们偏重于学习语言或者设计经验的优点，忽视了它们背后做出小小的妥协，或者缺陷。如果能利用好优点，处理好缺陷，我们就可以更好地掌握这些经验总结。毕竟世上哪有什么完美的东西呢？不完美的东西，用好了，就是好东西。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">我们利用讨论区，来聊聊设计模式这个老掉牙的、备受争议的话题。说起“老掉牙”，科技的进步真是快，设计模式十多年前还是一个时髦的话题，如今已经不太受待见了，虽然我们或多或少，或直接或间接地都受益于设计模式的思想。如果你了解过设计模式，你能够分享某个设计模式的优点和缺陷吗？ 使用设计模式有没有给你带来实际的困扰呢？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">上面的例子中，我们提到了使用代理模式来降低父类对子类的影响。那么你知道代理模式的缺陷吗？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">欢迎你把自己的经验和看法写在留言区，我们一起来学习、思考、精进！
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">如果你觉得这篇文章有所帮助，欢迎点击“请朋友读”，把它分享给你的朋友或者同事。
</span></span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/">代码精进之路</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A4%A7%E5%8E%82%E6%99%8B%E5%8D%87%E6%8C%87%E5%8D%97/37%E7%AE%A1%E7%90%86%E4%BA%94%E6%A8%A1%E5%BC%8F%E9%AB%98%E6%89%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">37管理五模式高手常用的管理模式有哪些</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3tomcat_jetty/37%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7tomcat%E7%9A%84%E6%80%A7%E8%83%BD/">
            <span class="next-text nav-default">37如何监控Tomcat的性能</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
