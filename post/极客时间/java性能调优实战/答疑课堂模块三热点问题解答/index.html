<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>答疑课堂：模块三热点问题解答 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是刘超。
不知不觉“多线程性能优化“已经讲完了，今天这讲我来解答下各位同学在这个模块集中提出的两大问题，第一个是有关监测上下文切换异常的命令排查工具，第二个是有关 blockingQueue 的内容。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/%E7%AD%94%E7%96%91%E8%AF%BE%E5%A0%82%E6%A8%A1%E5%9D%97%E4%B8%89%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/%E7%AD%94%E7%96%91%E8%AF%BE%E5%A0%82%E6%A8%A1%E5%9D%97%E4%B8%89%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="答疑课堂：模块三热点问题解答">
  <meta property="og:description" content="你好，我是刘超。
不知不觉“多线程性能优化“已经讲完了，今天这讲我来解答下各位同学在这个模块集中提出的两大问题，第一个是有关监测上下文切换异常的命令排查工具，第二个是有关 blockingQueue 的内容。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Java性能调优实战">

  <meta itemprop="name" content="答疑课堂：模块三热点问题解答">
  <meta itemprop="description" content="你好，我是刘超。
不知不觉“多线程性能优化“已经讲完了，今天这讲我来解答下各位同学在这个模块集中提出的两大问题，第一个是有关监测上下文切换异常的命令排查工具，第二个是有关 blockingQueue 的内容。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3362">
  <meta itemprop="keywords" content="Java性能调优实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="答疑课堂：模块三热点问题解答">
  <meta name="twitter:description" content="你好，我是刘超。
不知不觉“多线程性能优化“已经讲完了，今天这讲我来解答下各位同学在这个模块集中提出的两大问题，第一个是有关监测上下文切换异常的命令排查工具，第二个是有关 blockingQueue 的内容。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">答疑课堂：模块三热点问题解答</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3362 字 </span>
          <span class="more-meta"> 预计阅读 7 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#使用系统命令查看上下文切换">使用系统命令查看上下文切换</a>
          <ul>
            <li><a href="#1-linux-命令行工具之-vmstat-命令">1. Linux 命令行工具之 vmstat 命令</a></li>
            <li><a href="#2-linux-命令行工具之-pidstat-命令">2. Linux 命令行工具之 pidstat 命令</a></li>
            <li><a href="#3-jdk-工具之-jstack-命令">3. JDK 工具之 jstack 命令</a></li>
          </ul>
        </li>
        <li><a href="#多线程队列">多线程队列</a>
          <ul>
            <li><a href="#1-阻塞队列">1. 阻塞队列</a></li>
            <li><a href="#2-非阻塞队列">2. 非阻塞队列</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是刘超。</p>
<p>不知不觉“多线程性能优化“已经讲完了，今天这讲我来解答下各位同学在这个模块集中提出的两大问题，第一个是有关监测上下文切换异常的命令排查工具，第二个是有关 blockingQueue 的内容。</p>
<p>也欢迎你积极留言给我，让我知晓你想了解的内容，或者说出你的困惑，我们共同探讨。下面我就直接切入今天的主题了。</p>
<h2 id="使用系统命令查看上下文切换">使用系统命令查看上下文切换</h2>
<p>在第 15 讲中我提到了上下文切换，其中有用到一些工具进行监测，由于篇幅关系就没有详细介绍，今天我就补充总结几个常用的工具给你。</p>
<h3 id="1-linux-命令行工具之-vmstat-命令">1. Linux 命令行工具之 vmstat 命令</h3>
<p>vmstat 是一款指定采样周期和次数的功能性监测工具，我们可以使用它监控进程上下文切换的情况。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/1dcf113ccb1d0e185e383fc0d5297786.png" alt=""></p>
<p>vmstat 1 3 命令行代表每秒收集一次性能指标，总共获取 3 次。以下为上图中各个性能指标的注释：</p>
<ul>
<li><strong>procs</strong><br>
r：等待运行的进程数<br>
b：处于非中断睡眠状态的进程数</li>
<li><strong>memory</strong><br>
swpd：虚拟内存使用情况<br>
free：空闲的内存<br>
buff：用来作为缓冲的内存数<br>
cache：缓存大小</li>
<li><strong>swap</strong><br>
si：从磁盘交换到内存的交换页数量<br>
so：从内存交换到磁盘的交换页数量</li>
<li><strong>io</strong><br>
bi：发送到快设备的块数<br>
bo：从块设备接收到的块数</li>
<li><strong>system</strong><br>
in：每秒中断数<br>
cs：每秒上下文切换次数</li>
<li><strong>cpu</strong><br>
us：用户 CPU 使用事件<br>
sy：内核 CPU 系统使用时间<br>
id：空闲时间<br>
wa：等待 I/O 时间<br>
st：运行虚拟机窃取的时间</li>
</ul>
<h3 id="2-linux-命令行工具之-pidstat-命令">2. Linux 命令行工具之 pidstat 命令</h3>
<p>我们通过上述的 vmstat 命令只能观察到哪个进程的上下文切换出现了异常，那如果是要查看哪个线程的上下文出现了异常呢？</p>
<p>pidstat 命令就可以帮助我们监测到具体线程的上下文切换。pidstat 是 Sysstat 中一个组件，也是一款功能强大的性能监测工具。我们可以通过命令 yum install sysstat 安装该监控组件。</p>
<p>通过 pidstat -help 命令，我们可以查看到有以下几个常用参数可以监测线程的性能：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/7be035e116dec6a3c306875dcaf86882.png" alt=""></p>
<p>常用参数：</p>
<ul>
<li>-u：默认参数，显示各个进程的 cpu 使用情况；</li>
<li>-r：显示各个进程的内存使用情况；</li>
<li>-d：显示各个进程的 I/O 使用情况；</li>
<li>-w：显示每个进程的上下文切换情况；</li>
<li>-p：指定进程号；</li>
<li>-t：显示进程中线程的统计信息</li>
</ul>
<p>首先，通过 pidstat -w -p pid 命令行，我们可以查看到进程的上下文切换：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/a62d56a26f61ce8c75181651969c03b7.png" alt=""></p>
<ul>
<li>cswch/s：每秒主动任务上下文切换数量</li>
<li>nvcswch/s：每秒被动任务上下文切换数量</li>
</ul>
<p>之后，通过 pidstat -w -p pid -t 命令行，我们可以查看到具体线程的上下文切换：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/7f52a0b94654a4638381d1fb31387a39.png" alt=""></p>
<h3 id="3-jdk-工具之-jstack-命令">3. JDK 工具之 jstack 命令</h3>
<p>查看具体线程的上下文切换异常，我们还可以使用 jstack 命令查看线程堆栈的运行情况。jstack 是 JDK 自带的线程堆栈分析工具，使用该命令可以查看或导出 Java 应用程序中的线程堆栈信息。</p>
<p>jstack 最常用的功能就是使用 jstack pid 命令查看线程堆栈信息，通常是结合 pidstat -p pid -t 一起查看具体线程的状态，也经常用来排查一些死锁的异常。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/6463eae240a060d15d3809ef159ad045.png" alt=""></p>
<p>每个线程堆栈的信息中，都可以查看到线程 ID、线程状态（wait、sleep、running 等状态）以及是否持有锁等。</p>
<p>我们可以通过 jstack 16079 &gt; /usr/dump 将线程堆栈信息日志 dump 下来，之后打开 dump 文件，通过查看线程的状态变化，就可以找出导致上下文切换异常的具体原因。例如，系统出现了大量处于 BLOCKED 状态的线程，我们就需要立刻分析代码找出原因。</p>
<h2 id="多线程队列">多线程队列</h2>
<p>针对这讲的第一个问题，一份上下文切换的命令排查工具就总结完了。下面我来解答第二个问题，是在 17 讲中呼声比较高的有关 blockingQueue 的内容。</p>
<p>在 Java 多线程应用中，特别是在线程池中，队列的使用率非常高。Java 提供的线程安全队列又分为了阻塞队列和非阻塞队列。</p>
<h3 id="1-阻塞队列">1. 阻塞队列</h3>
<p>我们先来看下阻塞队列。阻塞队列可以很好地支持生产者和消费者模式的相互等待，当队列为空的时候，消费线程会阻塞等待队列不为空；当队列满了的时候，生产线程会阻塞直到队列不满。</p>
<p>在 Java 线程池中，也用到了阻塞队列。当创建的线程数量超过核心线程数时，新建的任务将会被放到阻塞队列中。我们可以根据自己的业务需求来选择使用哪一种阻塞队列，阻塞队列通常包括以下几种：</p>
<ul>
<li>**ArrayBlockingQueue：**一个基于数组结构实现的有界阻塞队列，按 FIFO（先进先出）原则对元素进行排序，使用 ReentrantLock、Condition 来实现线程安全；</li>
<li>**LinkedBlockingQueue：**一个基于链表结构实现的阻塞队列，同样按 FIFO（先进先出）原则对元素进行排序，使用 ReentrantLock、Condition 来实现线程安全，吞吐量通常要高于 ArrayBlockingQueue；</li>
<li>**PriorityBlockingQueue：**一个具有优先级的无限阻塞队列，基于二叉堆结构实现的无界限（最大值 Integer.MAX_VALUE - 8）阻塞队列，队列没有实现排序，但每当有数据变更时，都会将最小或最大的数据放在堆最上面的节点上，该队列也是使用了 ReentrantLock、Condition 实现的线程安全；</li>
<li>**DelayQueue：**一个支持延时获取元素的无界阻塞队列，基于 PriorityBlockingQueue 扩展实现，与其不同的是实现了 Delay 延时接口；</li>
<li>**SynchronousQueue：**一个不存储多个元素的阻塞队列，每次进行放入数据时，必须等待相应的消费者取走数据后，才可以再次放入数据，该队列使用了两种模式来管理元素，一种是使用先进先出的队列，一种是使用后进先出的栈，使用哪种模式可以通过构造函数来指定。</li>
</ul>
<p>Java 线程池 Executors 还实现了以下四种类型的 ThreadPoolExecutor，分别对应以上队列，详情如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/91df56b71f45e9e2e71f7fe38e699a4c.png" alt=""></p>
<h3 id="2-非阻塞队列">2. 非阻塞队列</h3>
<p>我们常用的线程安全的非阻塞队列是 ConcurrentLinkedQueue，它是一种无界线程安全队列 (FIFO)，基于链表结构实现，利用 CAS 乐观锁来保证线程安全。</p>
<p>下面我们通过源码来分析下该队列的构造、入列以及出列的具体实现。</p>
<p>**构造函数：**ConcurrentLinkedQueue 由 head、tair 节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用 (next) 组成，节点与节点之间通过 next 关联，从而组成一张链表结构的队列。在队列初始化时，head 节点存储的元素为空，tair 节点等于 head 节点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public ConcurrentLinkedQueue() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   head = tail = new Node&lt;E&gt;(null);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> private static class Node&lt;E&gt; {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        volatile E item;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        volatile Node&lt;E&gt; next;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            .
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            .
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>**入列：**当一个线程入列一个数据时，会将该数据封装成一个 Node 节点，并先获取到队列的队尾节点，当确定此时队尾节点的 next 值为 null 之后，再通过 CAS 将新队尾节点的 next 值设为新节点。此时 p != t，也就是设置 next 值成功，然后再通过 CAS 将队尾节点设置为当前节点即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public boolean offer(E e) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        checkNotNull(e);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 创建入队节点
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //t，p 为尾节点，默认相等，采用失败即重试的方式，直到入队成功         
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        for (Node&lt;E&gt; t = tail, p = t;;) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            // 获取队尾节点的下一个节点
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            Node&lt;E&gt; q = p.next;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            // 如果 q 为 null，则代表 p 就是队尾节点
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            if (q == null) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // 将入列节点设置为当前队尾节点的 next 节点
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                if (p.casNext(null, newNode)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    // 判断 tail 节点和 p 节点距离达到两个节点
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    if (p != t) // hop two nodes at a time
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        // 如果 tail 不是尾节点则将入队节点设置为 tail。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        // 如果失败了，那么说明有其他线程已经把 tail 移动过 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        casTail(t, newNode);  // Failure is OK.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    return true;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            // 如果 p 节点等于 p 的 next 节点，则说明 p 节点和 q 节点都为空，表示队列刚初始化，所以返回  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            else if (p == q)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                p = (t != (t = tail)) ? t : head;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            else
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // Check for tail updates after two hops.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>**出列：**首先获取 head 节点，并判断 item 是否为 null，如果为空，则表示已经有一个线程刚刚进行了出列操作，然后更新 head 节点；如果不为空，则使用 CAS 操作将 head 节点设置为 null，CAS 就会成功地直接返回节点元素，否则还是更新 head 节点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public E poll() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 设置起始点
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        restartFromHead:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        for (;;) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            //p 获取 head 节点
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            for (Node&lt;E&gt; h = head, p = h, q;;) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // 获取头节点元素
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                E item = p.item;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // 如果头节点元素不为 null，通过 cas 设置 p 节点引用的元素为 null
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                if (item != null &amp;&amp; p.casItem(item, null)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    // Successful CAS is the linearization point
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    // for item to be removed from this queue.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    if (p != h) // hop two nodes at a time
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        updateHead(h, ((q = p.next) != null) ? q : p);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    return item;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // 如果 p 节点的下一个节点为 null，则说明这个队列为空，更新 head 结点
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                else if ((q = p.next) == null) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    updateHead(h, p);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    return null;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // 节点出队失败，重新跳到 restartFromHead 来进行出队
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                else if (p == q)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    continue restartFromHead;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                else
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    p = q;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>ConcurrentLinkedQueue 是基于 CAS 乐观锁实现的，在并发时的性能要好于其它阻塞队列，因此很适合作为高并发场景下的排队队列。</p>
<p>今天的答疑就到这里，如果你还有其它问题，请在留言区中提出，我会一一解答。最后欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他加入讨论。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/b7c462671ae86891c7f8ac1941814e21.png" alt="unpreview"></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/">Java性能调优实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/rpc%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AD%94%E7%96%91%E8%AF%BE%E5%A0%82__%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%8E%E8%BF%9B%E9%98%B6%E7%AF%87%E6%80%9D%E8%80%83%E9%A2%98%E7%AD%94%E6%A1%88%E5%90%88%E9%9B%86/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">答疑课堂__基础篇与进阶篇思考题答案合集</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E5%AE%98%E8%AF%86%E4%BA%BA%E6%89%8B%E5%86%8C/%E7%AD%94%E7%96%91%E8%AF%BE%E5%A0%8201%E9%9D%A2%E8%AF%95%E8%AE%A1%E5%88%92%E7%AF%87%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/">
            <span class="next-text nav-default">答疑课堂01：面试计划篇热点问题解答</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
