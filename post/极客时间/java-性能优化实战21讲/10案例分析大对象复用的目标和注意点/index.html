<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>10案例分析：大对象复用的目标和注意点 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content=" title: &ldquo;10案例分析：大对象复用的目标和注意点&rdquo; draft: false date: 2024-06-14 keywords: [10案例分析：大对象复用的目标和注意点, Java 性能优化实战21讲, 极客时间] categories: [Java 性能优化实战21讲] tags: [极客时间] comment: true toc: true autoCollapseToc: true 本课时我们将讲解一下对于“大对象”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%9821%E8%AE%B2/10%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%9821%E8%AE%B2/10%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="10案例分析：大对象复用的目标和注意点">
  <meta property="og:description" content="title: “10案例分析：大对象复用的目标和注意点” draft: false date: 2024-06-14 keywords: [10案例分析：大对象复用的目标和注意点, Java 性能优化实战21讲, 极客时间] categories: [Java 性能优化实战21讲] tags: [极客时间] comment: true toc: true autoCollapseToc: true 本课时我们将讲解一下对于“大对象”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Java 性能优化实战21讲">

  <meta itemprop="name" content="10案例分析：大对象复用的目标和注意点">
  <meta itemprop="description" content="title: “10案例分析：大对象复用的目标和注意点” draft: false date: 2024-06-14 keywords: [10案例分析：大对象复用的目标和注意点, Java 性能优化实战21讲, 极客时间] categories: [Java 性能优化实战21讲] tags: [极客时间] comment: true toc: true autoCollapseToc: true 本课时我们将讲解一下对于“大对象”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5127">
  <meta itemprop="keywords" content="Java 性能优化实战21讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="10案例分析：大对象复用的目标和注意点">
  <meta name="twitter:description" content="title: “10案例分析：大对象复用的目标和注意点” draft: false date: 2024-06-14 keywords: [10案例分析：大对象复用的目标和注意点, Java 性能优化实战21讲, 极客时间] categories: [Java 性能优化实战21讲] tags: [极客时间] comment: true toc: true autoCollapseToc: true 本课时我们将讲解一下对于“大对象”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">10案例分析：大对象复用的目标和注意点</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5127 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#autocollapsetoc-true">title: &ldquo;10案例分析：大对象复用的目标和注意点&rdquo;
draft: false
date: 2024-06-14
keywords: [10案例分析：大对象复用的目标和注意点, Java 性能优化实战21讲, 极客时间]
categories: [Java 性能优化实战21讲]
tags: [极客时间]
comment: true
toc: true
autoCollapseToc: true</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <hr>
<h2 id="autocollapsetoc-true">title: &ldquo;10案例分析：大对象复用的目标和注意点&rdquo;
draft: false
date: 2024-06-14
keywords: [10案例分析：大对象复用的目标和注意点, Java 性能优化实战21讲, 极客时间]
categories: [Java 性能优化实战21讲]
tags: [极客时间]
comment: true
toc: true
autoCollapseToc: true</h2>
<p>本课时我们将讲解一下对于“大对象”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。</p>
<p>那么为什么大对象会影响我们的应用性能呢？</p>
<p>第一，大对象占用的资源多，垃圾回收器要花一部分精力去对它进行回收；</p>
<p>第二，大对象在不同的设备之间交换，会耗费网络流量，以及昂贵的 I/O；</p>
<p>第三，对大对象的解析和处理操作是耗时的，对象职责不聚焦，就会承担额外的性能开销。</p>
<p>结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。</p>
<p>但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的对象复用问题；接下来，从数据的结构纬度和时间维度出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。</p>
<p>String 的 substring 方法</p>
<p>我们都知道，String 在 Java 中是不可变的，如果你改动了其中的内容，它就会生成一个新的字符串。</p>
<p>如果我们想要用到字符串中的一部分数据，就可以使用 substring 方法。</p>
<p>如上图所示，当我们需要一个子字符串的时候，substring 生成了一个新的字符串，这个字符串通过构造函数的 Arrays.copyOfRange 函数进行构造。</p>
<p>这个函数在 JDK7 之后是没有问题的，但在 JDK6 中，却有着内存泄漏的风险，我们可以学习一下这个案例，来看一下大对象复用可能会产生的问题。</p>
<p>上图是我从 JDK 官方的一张截图。可以看到，它在创建子字符串的时候，并不只拷贝所需要的对象，而是把整个 value 引用了起来。如果原字符串比较大，即使不再使用，内存也不会释放。</p>
<p>比如，一篇文章内容可能有几兆，我们仅仅是需要其中的摘要信息，也不得不维持整个的大对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">String content = dao.getArticle(id); 
</span></span><span class="line"><span class="cl">String summary=content.substring(0,100); 
</span></span><span class="line"><span class="cl">articles.put(id,summary);
</span></span></code></pre></td></tr></table>
</div>
</div><p>有一些工作年限比较长的面试官，对 substring 还停留在 JDK6 的印象，但其实，Java 已经将这个 bug 给修改了。</p>
<p>这对我们的借鉴意义是：如果你创建了比较大的对象，并基于这个对象生成了一些其他的信息，这个时候，一定要记得去掉和这个大对象的引用关系。</p>
<p>集合大对象扩容</p>
<p>对象扩容，在 Java 中是司空见惯的现象，比如 StringBuilder、StringBuffer、HashMap，ArrayList 等。概括来讲，Java 的集合，包括 List、Set、Queue、Map 等，其中的数据都不可控。在容量不足的时候，都会有扩容操作，扩容操作需要重新组织数据，所以都不是线程安全的。</p>
<p>我们先来看下 StringBuilder 的扩容代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void expandCapacity(int minimumCapacity) { 
</span></span><span class="line"><span class="cl">        int newCapacity = value.length * 2 + 2; 
</span></span><span class="line"><span class="cl">        if (newCapacity - minimumCapacity &lt; 0) 
</span></span><span class="line"><span class="cl">            newCapacity = minimumCapacity; 
</span></span><span class="line"><span class="cl">        if (newCapacity &lt; 0) { 
</span></span><span class="line"><span class="cl">            if (minimumCapacity &lt; 0) // overflow 
</span></span><span class="line"><span class="cl">                throw new OutOfMemoryError(); 
</span></span><span class="line"><span class="cl">            newCapacity = Integer.MAX_VALUE; 
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">        value = Arrays.copyOf(value, newCapacity); 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>容量不够的时候，会将内存翻倍，并使用 Arrays.copyOf 复制源数据。</p>
<p>下面是 HashMap 的扩容代码，扩容后大小也是翻倍。它的扩容动作就复杂得多，除了有负载因子的影响，它还需要把原来的数据重新进行散列，由于无法使用 native 的 Arrays.copy 方法，速度就会很慢。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">void</span> <span class="n">addEntry</span><span class="p">(</span><span class="ne">int</span> <span class="nb">hash</span><span class="p">,</span> <span class="n">K</span> <span class="n">key</span><span class="p">,</span> <span class="n">V</span> <span class="n">value</span><span class="p">,</span> <span class="ne">int</span> <span class="n">bucketIndex</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">null</span> <span class="o">!=</span> <span class="n">table</span><span class="p">[</span><span class="n">bucketIndex</span><span class="p">]))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">            <span class="n">resize</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">table</span><span class="o">.</span><span class="n">length</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">            <span class="nb">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">null</span> <span class="o">!=</span> <span class="n">key</span><span class="p">)</span> <span class="err">?</span> <span class="nb">hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">            <span class="n">bucketIndex</span> <span class="o">=</span> <span class="n">indexFor</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">length</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="cl">        <span class="n">createEntry</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">bucketIndex</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">resize</span><span class="p">(</span><span class="ne">int</span> <span class="n">newCapacity</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">Entry</span><span class="p">[]</span> <span class="n">oldTable</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="ne">int</span> <span class="n">oldCapacity</span> <span class="o">=</span> <span class="n">oldTable</span><span class="o">.</span><span class="n">length</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">oldCapacity</span> <span class="o">==</span> <span class="n">MAXIMUM_CAPACITY</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">            <span class="n">threshold</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="n">MAX_VALUE</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="cl">        <span class="n">Entry</span><span class="p">[]</span> <span class="n">newTable</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Entry</span><span class="p">[</span><span class="n">newCapacity</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl">        <span class="n">transfer</span><span class="p">(</span><span class="n">newTable</span><span class="p">,</span> <span class="n">initHashSeedAsNeeded</span><span class="p">(</span><span class="n">newCapacity</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl">        <span class="n">table</span> <span class="o">=</span> <span class="n">newTable</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="n">threshold</span> <span class="o">=</span> <span class="p">(</span><span class="ne">int</span><span class="p">)</span><span class="n">Math</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">newCapacity</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="p">,</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>List 的代码大家可自行查看，也是阻塞性的，扩容策略是原长度的 1.5 倍。</p>
<p>由于集合在代码中使用的频率非常高，如果你知道具体的数据项上限，那么不妨设置一个合理的初始化大小。比如，HashMap 需要 1024 个元素，需要 7 次扩容，会影响应用的性能。面试中会频繁出现这个问题，你需要了解这些扩容操作对性能的影响。</p>
<p>但是要注意，像 HashMap 这种有负载因子的集合（0.75），初始化大小 = 需要的个数/负载因子+1，如果你不是很清楚底层的结构，那就不妨保持默认。</p>
<p>接下来，我将从数据的结构纬度和时间维度出发，讲解一下应用层面的优化。</p>
<p>保持合适的对象粒度</p>
<p>给你分享一个实际案例：我们有一个并发量非常高的业务系统，需要频繁使用到用户的基本数据。</p>
<p>如下图所示，由于用户的基本信息，都是存放在另外一个服务中，所以每次用到用户的基本信息，都需要有一次网络交互。更加让人无法接受的是，即使是只需要用户的性别属性，也需要把所有的用户信息查询，拉取一遍。</p>
<p>为了加快数据的查询速度，根据我们之前 《08 | 案例分析：Redis 如何助力秒杀业务》的描述，对数据进行了初步的缓存，放入到了 Redis 中，查询性能有了大的改善，但每次还是要查询很多冗余数据。</p>
<p>原始的 redis key 是这样设计的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type: string 
</span></span><span class="line"><span class="cl">key: user_${userid} 
</span></span><span class="line"><span class="cl">value: json
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样的设计有两个问题：</p>
<p>查询其中某个字段的值，需要把所有 json 数据查询出来，并自行解析；</p>
<p>更新其中某个字段的值，需要更新整个 json 串，代价较高。</p>
<p>针对这种大粒度 json 信息，就可以采用打散的方式进行优化，使得每次更新和查询，都有聚焦的目标。</p>
<p>接下来对 Redis 中的数据进行了以下设计，采用 hash 结构而不是 json 结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type: hash 
</span></span><span class="line"><span class="cl">key: user_${userid} 
</span></span><span class="line"><span class="cl">value: {sex:f, id:1223, age:23}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样，我们使用 hget 命令，或者 hmget 命令，就可以获取到想要的数据，加快信息流转的速度。</p>
<p>Bitmap 把对象变小</p>
<p>除了以上操作，还能再进一步优化吗？比如，我们系统中就频繁用到了用户的性别数据，用来发放一些礼品，推荐一些异性的好友，定时循环用户做一些清理动作等；或者，存放一些用户的状态信息，比如是否在线，是否签到，最近是否发送信息等，从而统计一下活跃用户等。那么对是、否这两个值的操作，就可以使用 Bitmap 这个结构进行压缩。</p>
<p>这里还有个高频面试问题，那就是 Java 的 Boolean 占用的是多少位？</p>
<p>在 Java 虚拟机规范里，描述是：将 Boolean 类型映射成的是 1 和 0 两个数字，它占用的空间是和 int 相同的 32 位。即使有的虚拟机实现把 Boolean 映射到了 byte 类型上，它所占用的空间，对于大量的、有规律的 Boolean 值来说，也是太大了。</p>
<p>如代码所示，通过判断 int 中的每一位，它可以保存 32 个 Boolean 值！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int a= 0b0001_0001_1111_1101_1001_0001_1111_1101;
</span></span></code></pre></td></tr></table>
</div>
</div><p>Bitmap 就是使用 Bit 进行记录的数据结构，里面存放的数据不是 0 就是 1。还记得我们在之前 《08 | 案例分析：Redis 如何助力秒杀业务》中提到的缓存穿透吗？就可以使用 Bitmap 避免，Java 中的相关结构类，就是 java.util.BitSet，BitSet 底层是使用 long 数组实现的，所以它的最小容量是 64。</p>
<p>10 亿的 Boolean 值，只需要 128MB 的内存，下面既是一个占用了 256MB 的用户性别的判断逻辑，可以涵盖长度为 10 亿的 ID。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">static BitSet missSet = new BitSet(010_000_000_000); 
</span></span><span class="line"><span class="cl">static BitSet sexSet = new BitSet(010_000_000_000); 
</span></span><span class="line"><span class="cl">String getSex(int userId) { 
</span></span><span class="line"><span class="cl">    boolean notMiss = missSet.get(userId); 
</span></span><span class="line"><span class="cl">    if (!notMiss) { 
</span></span><span class="line"><span class="cl">        //lazy fetch 
</span></span><span class="line"><span class="cl">        String lazySex = dao.getSex(userId); 
</span></span><span class="line"><span class="cl">        missSet.set(userId, true); 
</span></span><span class="line"><span class="cl">        sexSet.set(userId, &#34;female&#34;.equals(lazySex)); 
</span></span><span class="line"><span class="cl">    } 
</span></span><span class="line"><span class="cl">    return sexSet.get(userId) ? &#34;female&#34; : &#34;male&#34;; 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这些数据，放在堆内内存中，还是过大了。幸运的是，Redis 也支持 Bitmap 结构，如果内存有压力，我们可以把这个结构放到 Redis 中，判断逻辑也是类似的。</p>
<p>再插一道面试算法题：给出一个 1GB 内存的机器，提供 60亿 int 数据，如何快速判断有哪些数据是重复的？</p>
<p>大家可以类比思考一下。Bitmap 是一个比较底层的结构，在它之上还有一个叫作布隆过滤器的结构（Bloom Filter），布隆过滤器可以判断一个值不存在，或者可能存在。</p>
<p>如图，它相比较 Bitmap，它多了一层 hash 算法。既然是 hash 算法，就会有冲突，所以有可能有多个值落在同一个 bit 上。它不像 HashMap一样，使用链表或者红黑树来处理冲突，而是直接将这个hash槽重复使用。从这个特性我们能够看出，布隆过滤器能够明确表示一个值不在集合中，但无法判断一个值确切的在集合中。</p>
<p>Guava 中有一个 BloomFilter 的类，可以方便地实现相关功能。</p>
<p>上面这种优化方式，本质上也是把大对象变成小对象的方式，在软件设计中有很多类似的思路。比如像一篇新发布的文章，频繁用到的是摘要数据，就不需要把整个文章内容都查询出来；用户的 feed 信息，也只需要保证可见信息的速度，而把完整信息存放在速度较慢的大型存储里。</p>
<p>数据的冷热分离</p>
<p>数据除了横向的结构纬度，还有一个纵向的时间维度，对时间维度的优化，最有效的方式就是冷热分离。</p>
<p>所谓热数据，就是靠近用户的，被频繁使用的数据；而冷数据是那些访问频率非常低，年代非常久远的数据。</p>
<p>同一句复杂的 SQL，运行在几千万的数据表上，和运行在几百万的数据表上，前者的效果肯定是很差的。所以，虽然你的系统刚开始上线时速度很快，但随着时间的推移，数据量的增加，就会渐渐变得很慢。</p>
<p>冷热分离是把数据分成两份，如下图，一般都会保持一份全量数据，用来做一些耗时的统计操作。</p>
<p>由于冷热分离在工作中经常遇到，所以面试官会频繁问到数据冷热分离的方案。下面简单介绍三种：</p>
<p>1.数据双写</p>
<p>把对冷热库的插入、更新、删除操作，全部放在一个统一的事务里面。由于热库（比如 MySQL）和冷库（比如 Hbase）的类型不同，这个事务大概率会是分布式事务。在项目初期，这种方式是可行的，但如果是改造一些遗留系统，分布式事务基本上是改不动的，我通常会把这种方案直接废弃掉。</p>
<p>2.写入 MQ 分发</p>
<p>通过 MQ 的发布订阅功能，在进行数据操作的时候，先不落库，而是发送到 MQ 中。单独启动消费进程，将 MQ 中的数据分别落到冷库、热库中。使用这种方式改造的业务，逻辑非常清晰，结构也比较优雅。像订单这种结构比较清晰、对顺序性要求较低的系统，就可以采用 MQ 分发的方式。但如果你的数据库实体量非常大，用这种方式就要考虑程序的复杂性了。</p>
<p>3.使用 Binlog 同步</p>
<p>针对 MySQL，就可以采用 Binlog 的方式进行同步，使用 Canal 组件，可持续获取最新的 Binlog 数据，结合 MQ，可以将数据同步到其他的数据源中。</p>
<p>思维发散</p>
<p>对于结果集的操作，我们可以再发散一下思维。可以将一个简单冗余的结果集，改造成复杂高效的数据结构。这个复杂的数据结构可以代理我们的请求，有效地转移耗时操作。</p>
<p>比如，我们常用的数据库索引，就是一种对数据的重新组织、加速。</p>
<p>B+ tree 可以有效地减少数据库与磁盘交互的次数，它通过类似 B+ tree 的数据结构，将最常用的数据进行索引，存储在有限的存储空间中。</p>
<p>还有就是，在 RPC 中常用的序列化。</p>
<p>有的服务是采用的 SOAP 协议的 WebService，它是基于 XML 的一种协议，内容大传输慢，效率低下。现在的 Web 服务中，大多数是使用 json 数据进行交互的，json 的效率相比 SOAP 就更高一些。</p>
<p>另外，大家应该都听过 google 的 protobuf，由于它是二进制协议，而且对数据进行了压缩，性能是非常优越的。protobuf 对数据压缩后，大小只有 json 的 1/10，xml 的 1/20，但是性能却提高了 5-100 倍。</p>
<p>protobuf 的设计是值得借鉴的，它通过 tag|leng|value 三段对数据进行了非常紧凑的处理，解析和传输速度都特别快。</p>
<p>小结</p>
<p>最后总结一下本课时的内容重点：</p>
<p>首先，我们看了比较老的 JDK 版本中，String 为了复用引起的内容泄漏问题，所以我们平常的编码中，一定要注意大对象的回收，及时切断与它的联系。</p>
<p>接下来，我们看了 Java 中集合的一些扩容操作，如果你知道确切的集合大小，就可以指定一个初始值，避免耗时的扩容操作。</p>
<p>针对大对象，我们有结构纬度的优化和时间维度的优化两种方法：</p>
<p>从结构纬度来说，通过把对象切分成合适的粒度，可以把操作集中在小数据结构上，减少时间处理成本；通过把对象进行压缩、转换，或者提取热点数据，就可以避免大对象的存储和传输成本。</p>
<p>从时间纬度来说，就可以通过冷热分离的手段，将常用的数据存放在高速设备中，减少数据处理的集合，加快处理速度。</p>
<p>到现在为止，我们学习了缓冲、缓存、对象池化、结果缓存池、大对象处理等优化性能的手段，由于它们都加入了额外的中间层，会使得编程模型变得复杂。</p>
<p>接下来，我将在下一课时《11 | 案例分析：如何用设计模式优化性能》中介绍几种常用的设计模式，来看一下设计模式可以如何助力我们的性能优化，又有哪些可以注意的地方。</p>
<p>-&ndash; ### 精选评论 ##### **用户8700： &gt; 128M存的是10亿数据吧？128*1024*1024*8=1,073,741,824 ##### **2081： &gt; 老师总结的很到位，还是涉及到了挺多基础知识点的 ##### **烽： &gt; 老师，为什么说 在 冷热数据分离 方案中，实施 数据双写 时， 针对 已有系统的改造，分布式事务改不动？ ######     讲师回复： &gt;     遗留系统一般技术栈比较老，而且代码比较分散，事务操作不集中。需要先进行一次集中性的重构，但这个重构陈本很大 ##### **华： &gt; 你好 老师 问个关于redis bimap的问题 如果作为签到使用,用户uid比较稀疏导致key比较大 该怎么处理呢? ######     讲师回复： &gt;     如果你只是存是和否的话，如果特别稀疏，可以作为用户的一项属性存在；一般签到都是统计用户的签到历史的，比如最近一个月的签到情况，这种情况下bitmap的key就是日期。而不是一个日期一个bitmap ##### **运： &gt; 这一篇文章很赞 ##### **升： &gt; 打卡，我来迟了 ##### **生： &gt; redis的hash结构应该比string更占用内存空间吧 ######     讲师回复： &gt;     这要看你怎么设计string和hash的key了。实际上，它们占用内存是相差不大的。但hash的好处是你可以根据hashKey查询处单个值，不必像string一样一股脑的查出来，然后在应用端去解析。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%9821%E8%AE%B2/">Java 性能优化实战21讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%9838%E8%AE%B2/10%E6%A1%88%E4%BE%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1docker%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%92%8Ckubernete%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">10案例：微服务Docker容器化部署和Kubernete容器编排</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kubernetes%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/10%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%80%8E%E6%A0%B7%E5%AF%B9%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/">
            <span class="next-text nav-default">10存储管理：怎样对业务数据进行持久化存储？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
