<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>18高级进阶：JIT如何影响JVM的性能？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content=" title: &ldquo;18高级进阶：JIT如何影响JVM的性能？&rdquo; draft: false date: 2024-06-14 keywords: [18高级进阶：JIT如何影响JVM的性能？, Java 性能优化实战21讲, 极客时间] categories: [Java 性能优化实战21讲] tags: [极客时间] comment: true toc: true autoCollapseToc: true 我们在上一课时，我们了解到 Java 虚拟机栈，其实是一个双层的栈，如下图所示，第一层就是针对 method 的栈帧，第二层是针对字节码指令的操作数栈。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%9821%E8%AE%B2/18%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6jit%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8Djvm%E7%9A%84%E6%80%A7%E8%83%BD/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%9821%E8%AE%B2/18%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6jit%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8Djvm%E7%9A%84%E6%80%A7%E8%83%BD/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="18高级进阶：JIT如何影响JVM的性能？">
  <meta property="og:description" content="title: “18高级进阶：JIT如何影响JVM的性能？” draft: false date: 2024-06-14 keywords: [18高级进阶：JIT如何影响JVM的性能？, Java 性能优化实战21讲, 极客时间] categories: [Java 性能优化实战21讲] tags: [极客时间] comment: true toc: true autoCollapseToc: true 我们在上一课时，我们了解到 Java 虚拟机栈，其实是一个双层的栈，如下图所示，第一层就是针对 method 的栈帧，第二层是针对字节码指令的操作数栈。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Java 性能优化实战21讲">

  <meta itemprop="name" content="18高级进阶：JIT如何影响JVM的性能？">
  <meta itemprop="description" content="title: “18高级进阶：JIT如何影响JVM的性能？” draft: false date: 2024-06-14 keywords: [18高级进阶：JIT如何影响JVM的性能？, Java 性能优化实战21讲, 极客时间] categories: [Java 性能优化实战21讲] tags: [极客时间] comment: true toc: true autoCollapseToc: true 我们在上一课时，我们了解到 Java 虚拟机栈，其实是一个双层的栈，如下图所示，第一层就是针对 method 的栈帧，第二层是针对字节码指令的操作数栈。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3848">
  <meta itemprop="keywords" content="Java 性能优化实战21讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="18高级进阶：JIT如何影响JVM的性能？">
  <meta name="twitter:description" content="title: “18高级进阶：JIT如何影响JVM的性能？” draft: false date: 2024-06-14 keywords: [18高级进阶：JIT如何影响JVM的性能？, Java 性能优化实战21讲, 极客时间] categories: [Java 性能优化实战21讲] tags: [极客时间] comment: true toc: true autoCollapseToc: true 我们在上一课时，我们了解到 Java 虚拟机栈，其实是一个双层的栈，如下图所示，第一层就是针对 method 的栈帧，第二层是针对字节码指令的操作数栈。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">18高级进阶：JIT如何影响JVM的性能？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3848 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#autocollapsetoc-true">title: &ldquo;18高级进阶：JIT如何影响JVM的性能？&rdquo;
draft: false
date: 2024-06-14
keywords: [18高级进阶：JIT如何影响JVM的性能？, Java 性能优化实战21讲, 极客时间]
categories: [Java 性能优化实战21讲]
tags: [极客时间]
comment: true
toc: true
autoCollapseToc: true</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <hr>
<h2 id="autocollapsetoc-true">title: &ldquo;18高级进阶：JIT如何影响JVM的性能？&rdquo;
draft: false
date: 2024-06-14
keywords: [18高级进阶：JIT如何影响JVM的性能？, Java 性能优化实战21讲, 极客时间]
categories: [Java 性能优化实战21讲]
tags: [极客时间]
comment: true
toc: true
autoCollapseToc: true</h2>
<p>我们在上一课时，我们了解到 Java 虚拟机栈，其实是一个双层的栈，如下图所示，第一层就是针对 method 的栈帧，第二层是针对字节码指令的操作数栈。</p>
<p>Java 虚拟机栈图</p>
<p>栈帧的创建是需要耗费资源的，尤其是对于 Java 中常见的 getter、setter 方法来说，这些代码通常只有一行，每次都创建栈帧的话就太浪费了。</p>
<p>另外，Java 虚拟机栈对代码的执行，采用的是字节码解释的方式，考虑到下面这段代码，变量 a 声明之后，就再也不被使用，要是按照字节码指令解释执行的话，就要做很多无用功。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class A{
</span></span><span class="line"><span class="cl">    int attr = 0;
</span></span><span class="line"><span class="cl">    public void test(){
</span></span><span class="line"><span class="cl">        int a = attr;
</span></span><span class="line"><span class="cl">        System.out.println(&#34;ok&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面是这段代码的字节码指令，我们能够看到 aload_0，getfield ，istore_1 这三个无用的字节码指令操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"> <span class="n">public</span> <span class="n">void</span> <span class="n">test</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">descriptor</span><span class="p">:</span> <span class="p">()</span><span class="n">V</span>
</span></span><span class="line"><span class="cl">    <span class="n">flags</span><span class="p">:</span> <span class="n">ACC_PUBLIC</span>
</span></span><span class="line"><span class="cl">    <span class="n">Code</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">stack</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">locals</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">args_size</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">         <span class="mi">0</span><span class="p">:</span> <span class="n">aload_0</span>
</span></span><span class="line"><span class="cl">         <span class="mi">1</span><span class="p">:</span> <span class="n">getfield</span>      <span class="c1">#2                  // Field attr:I</span>
</span></span><span class="line"><span class="cl">         <span class="mi">4</span><span class="p">:</span> <span class="n">istore_1</span>
</span></span><span class="line"><span class="cl">         <span class="mi">5</span><span class="p">:</span> <span class="n">getstatic</span>     <span class="c1">#3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span>
</span></span><span class="line"><span class="cl">         <span class="mi">8</span><span class="p">:</span> <span class="n">ldc</span>           <span class="c1">#4                  // String ok</span>
</span></span><span class="line"><span class="cl">        <span class="mi">10</span><span class="p">:</span> <span class="n">invokevirtual</span> <span class="c1">#5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>
</span></span><span class="line"><span class="cl">        <span class="mi">13</span><span class="p">:</span> <span class="k">return</span>
</span></span><span class="line"><span class="cl">      <span class="n">LineNumberTable</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">line</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="n">line</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl">        <span class="n">line</span> <span class="mi">6</span><span class="p">:</span> <span class="mi">13</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外，我们了解到垃圾回收器回收的目标区域主要是堆，堆上创建的对象越多，GC 的压力就越大。要是能把一些变量，直接在栈上分配，那 GC 的压力就会小一些。</p>
<p>其实，我们说的这几个优化的可能性，JVM 已经通过 JIT 编译器（Just In Time Compiler）去做了，JIT 最主要的目标是把解释执行变成编译执行。</p>
<p>为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，这就是 JIT 编译器的功能。</p>
<p>如上图，JVM 会将调用次数很高，或者在 for 循环里频繁被使用的代码，编译成机器码，然后缓存在 CodeCache 区域里，下次调用相同方法的时候，就可以直接使用。</p>
<p>那 JIT 编译都有哪些手段呢？接下来我们详细介绍。</p>
<p>方法内联</p>
<p>在 “05 | 工具实践：基准测试 JMH，精确测量方法性能” 提到 JMH 的时候，我们就了解到 CompilerControl 注解可以控制 JIT 编译器的一些行为。</p>
<p>其中，有一个模式叫作inline，就是内联的意思，它会把一些短小的方法体，直接纳入目标方法的作用范围之内，就像是直接在代码块中追加代码。这样，就少了一次方法调用，执行速度就能够得到提升，这就是方法内联的概念。</p>
<p>可以使用 -XX:-Inline 参数来禁用方法内联，如果想要更细粒度的控制，可以使用 CompileCommand 参数，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XX:CompileCommand=exclude,java/lang/String.indexOf
</span></span></code></pre></td></tr></table>
</div>
</div><p>JMH 就是使用这个参数来实现的自定义编译特性。在 JDK 的源码里，也有很多被 @ForceInline注解的方法，这些方法，会在执行的时候被强制进行内联；而被**@DontInline**注解的方法，则始终不会被内联。</p>
<p>我们从 “05 | 工具实践：基准测试 JMH，精确测量方法性能” 获取第 16 个代码示例，来看一下 JIT 这些优化的效果，主要代码块如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public void target_blank() {
</span></span><span class="line"><span class="cl">    // this method was intentionally left blank
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">@CompilerControl(CompilerControl.Mode.DONT_INLINE)
</span></span><span class="line"><span class="cl">public void target_dontInline() {
</span></span><span class="line"><span class="cl">    // this method was intentionally left blank
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">@CompilerControl(CompilerControl.Mode.INLINE)
</span></span><span class="line"><span class="cl">public void target_inline() {
</span></span><span class="line"><span class="cl">    // this method was intentionally left blank
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">@CompilerControl(CompilerControl.Mode.EXCLUDE)
</span></span><span class="line"><span class="cl">public void target_exclude() {
</span></span><span class="line"><span class="cl">    // this method was intentionally left blank
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>执行结果如下，可以看到不使用 JIT 编译和使用了 JIT 编译的性能差距达到了 100 多倍，使用了内联比不使用内联，速度快了 5 倍。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Benchmark                                Mode  Cnt   Score   Error  Units
</span></span><span class="line"><span class="cl">JMHSample_16_CompilerControl.baseline    avgt    3   0.485 ± 1.492  ns/op
</span></span><span class="line"><span class="cl">JMHSample_16_CompilerControl.blank       avgt    3   0.483 ± 1.518  ns/op
</span></span><span class="line"><span class="cl">JMHSample_16_CompilerControl.dontinline  avgt    3   1.934 ± 3.112  ns/op
</span></span><span class="line"><span class="cl">JMHSample_16_CompilerControl.exclude     avgt    3  57.603 ± 4.435  ns/op
</span></span><span class="line"><span class="cl">JMHSample_16_CompilerControl.inline      avgt    3   0.483 ± 1.520  ns/op
</span></span></code></pre></td></tr></table>
</div>
</div><p>JIT 编译之后的二进制代码，是放在 Code Cache 区域里的。这个区域的大小是固定的，而且一旦启动无法扩容。如果 Code Cache 满了，JVM 并不会报错，但会停止编译。所以编译执行就会退化为解释执行，性能就会降低。不仅如此，JIT 编译器会一直尝试去优化你的代码，造成 CPU 占用上升。</p>
<p>通过参数 -XX:ReservedCodeCacheSize 可以指定 Code Cache 区域的大小，如果你通过监控发现空间达到了上限，就要适当的增加它的大小。</p>
<p>编译层次</p>
<p>HotSpot 虚拟机包含多个即时编译器，有 C1，C2 和 Graal，JDK8 以后采用的是分层编译的模式。使用 jstack 命令获得的线程信息，经常能看到它们的身影。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34;C2 CompilerThread0&#34; #6 daemon prio=9 os_prio=31 cpu=830.41ms elapsed=4252.14s tid=0x00007ffaed023000 nid=0x5a03 waiting on condition  [0x0000000000000000]
</span></span><span class="line"><span class="cl">   java.lang.Thread.State: RUNNABLE
</span></span><span class="line"><span class="cl">   No compile task
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34;C1 CompilerThread0&#34; #8 daemon prio=9 os_prio=31 cpu=549.91ms elapsed=4252.14s tid=0x00007ffaed831800 nid=0x5c03 waiting on condition  [0x0000000000000000]
</span></span><span class="line"><span class="cl">   java.lang.Thread.State: RUNNABLE
</span></span><span class="line"><span class="cl">   No compile task
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用额外线程进行即时编译，可以不用阻塞解释执行的逻辑。JIT 通常会在触发之后就在后台运行，编译完成之后就将相应的字节码替换为编译后的代码。JIT 编译方式有两种：一种是编译方法，另一种是编译循环。</p>
<p>分层编译将 Java 虚拟机的执行状态分为了五个层次。</p>
<p>字节码的解释执行;</p>
<p>执行不带 profiling 的 C1 代码;</p>
<p>执行仅带方法调用次数以及循环执行次数 profiling 的 C1 代码;</p>
<p>执行带所有 profiling 的 C1 代码;</p>
<p>执行 C2 代码。</p>
<p>其中，Profiling 指的是运行时的程序的执行状态数据，比如循环调用的次数、方法调用的次数、分支跳转次数、类型转换次数等。比如 JDK 中的 hprof 工具，就是一种 profiler，说白了就是一些中间的统计数据。</p>
<p>在不启用分层编译的情况下，当方法的调用次数和循环回边的次数的总和，超过由参数 -XX:CompileThreshold 指定的阈值时，便会触发即时编译；但当启用分层编译时，这个参数将会失效，会采用一套动态调整进行调整。</p>
<p>逃逸分析</p>
<p>下面着重讲解一下逃逸分析，这个知识点在面试的时候经常会被问到。</p>
<p>我们先回顾一下上一课时留下的问题：我们常说的对象，除了基本数据类型，一定是在堆上分配的吗？</p>
<p>答案是否定的，通过逃逸分析，JVM 能够分析出一个新的对象的使用范围，从而决定是否要将这个对象分配到堆上。逃逸分析现在是 JVM 的默认行为，可以通过参数 -XX:-DoEscapeAnalysis 关掉它。</p>
<p>那什么样的对象算是逃逸的呢？可以看一下下面的两种典型情况。</p>
<p>如代码所示，对象被赋值给成员变量或者静态变量，可能被外部使用，变量就发生了逃逸。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class EscapeAttr {
</span></span><span class="line"><span class="cl">    Object attr;
</span></span><span class="line"><span class="cl">    public void test() {
</span></span><span class="line"><span class="cl">        attr = new Object();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>再看下面这段代码，对象通过 return 语句返回。由于程序并不能确定这个对象后续会不会被使用，外部的线程能够访问到这个结果，对象也发生了逃逸。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class EscapeReturn {
</span></span><span class="line"><span class="cl">    Object attr;
</span></span><span class="line"><span class="cl">    public Object test() {
</span></span><span class="line"><span class="cl">        Object obj = new Object();
</span></span><span class="line"><span class="cl">        return obj;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>那逃逸分析有什么好处呢？1. 栈上分配</p>
<p>如果一个对象在子程序中被分配，指向该对象的指针永远不会逃逸，对象有可能会被优化为栈分配。栈分配可以快速地在栈帧上创建和销毁对象，不用再分配到堆空间，可以有效地减少 GC 的压力。</p>
<p>2. 分离对象或标量替换</p>
<p>但对象结构通常都比较复杂，如何将对象保存在栈上呢？</p>
<p>JIT 可以将对象打散，全部替换为一个个小的局部变量，这个打散的过程，就叫作标量替换（标量就是不能被进一步分割的变量，比如 int、long 等基本类型）。也就是说，标量替换后的对象，全部变成了局部变量，可以方便地进行栈上分配，而无须改动其他的代码。</p>
<p>从上面的描述我们可以看到，并不是所有的对象或者数组，都会在堆上分配。由于JIT的存在，如果发现某些对象没有逃逸出方法，那么就有可能被优化成栈分配。</p>
<p>3.同步消除</p>
<p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<p>注意这是针对 synchronized 来说的，JUC 中的 Lock 并不能被消除。</p>
<p>要开启同步消除，需要加上 -XX:+EliminateLocks 参数。由于这个参数依赖逃逸分析，所以同时要打开 -XX:+DoEscapeAnalysis 选项。</p>
<p>比如下面这段代码，JIT 判断对象锁只能被一个线程访问，就可以去掉这个同步的影响。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class SyncEliminate {
</span></span><span class="line"><span class="cl">    public void test() {
</span></span><span class="line"><span class="cl">        synchronized (new Object()) {
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>仓库中也有一个 StringBuffer 和 StringBuilder 的 JMH 测试对比，可以看到在开启了锁消除的情况下，它们的效率相差并不大。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Benchmark                          Mode  Cnt       Score       Error   Units
</span></span><span class="line"><span class="cl">BuilderVsBufferBenchmark.buffer   thrpt   10   90085.927 ± 95174.289  ops/ms
</span></span><span class="line"><span class="cl">BuilderVsBufferBenchmark.builder  thrpt   10  103280.200 ± 76172.538  ops/ms
</span></span></code></pre></td></tr></table>
</div>
</div><p>JITWatch</p>
<p>可以使用 jitwatch 工具来观测 JIT 的一些行为。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">https://github.com/AdoptOpenJDK/jitwatch
</span></span></code></pre></td></tr></table>
</div>
</div><p>在代码的启动参数里加入 LogCompilation 等参数开启记录，将生成一个 jitdemo.log 文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> -XX:+UnlockDiagnosticVMOptions -XX:+TraceClassLoading  -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=jitdemo.log
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 jitwatch 工具，可打开这个文件，看到详细的编译结果。</p>
<p>下面是一段测试代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class SimpleInliningTest {
</span></span><span class="line"><span class="cl">    public SimpleInliningTest() {
</span></span><span class="line"><span class="cl">        int sum = 0;
</span></span><span class="line"><span class="cl">        // 1_000_000 is F4240 in hex
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 1_000_000; i++) {
</span></span><span class="line"><span class="cl">            sum = this.add(sum, 99);
</span></span><span class="line"><span class="cl">            // 63 hex
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        System.out.println(&#34;Sum:&#34; + sum);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public int add(int a, int b) {
</span></span><span class="line"><span class="cl">        return a + b;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        new SimpleInliningTest();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>从执行后的结果可以看到，热点 for 循环已经使用 JIT 进行了编译，而里面应用的 add 方法，也已经被内联。</p>
<p>小结</p>
<p>JIT 是现代 JVM 主要的优化点，能够显著地提升程序的执行效率。从解释执行到最高层次的 C2，一个数量级的性能提升也是有可能的。但即时编译的过程是非常缓慢的，既耗时间也费空间，所以这些优化操作会和解释执行同时进行。</p>
<p>值得注意的是，JIT 在某些情况下还会出现逆优化。比如一些热部署方式触发的 redefineClass，就会造成 JIT 编译结果的失效，相关的内联代码也需要重新生成。</p>
<p>JIT 优化并不见得每次都有用，比如下面这段代码，编译后执行，会发生死循环。但如果你在启动的时候，加上 -Djava.compiler=NONE 参数，禁用 JIT，它就能够执行下去。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="k">class</span> <span class="n">Demo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">static</span> <span class="n">final</span> <span class="k">class</span> <span class="n">TestThread</span> <span class="k">extends</span> <span class="ne">Thread</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">boolean</span> <span class="n">stop</span> <span class="o">=</span> <span class="bp">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">public</span> <span class="n">boolean</span> <span class="n">isStop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">stop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="err">@</span><span class="n">Override</span>
</span></span><span class="line"><span class="cl">		<span class="n">public</span> <span class="n">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="ne">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">ex</span><span class="o">.</span><span class="n">printStackTrace</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="n">stop</span> <span class="o">=</span> <span class="bp">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&#34;END&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">public</span> <span class="k">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="ne">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="ne">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">TestThread</span> <span class="n">test</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TestThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="n">test</span><span class="o">.</span><span class="n">start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">test</span><span class="o">.</span><span class="n">isStop</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">			<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&#34;--&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们主要看了方法内联、逃逸分析等概念，了解到一些方法在被优化后，对象并不一定是在堆上分配的，它可能在被标量替换后，直接在栈上分配。这几个知识点也是在面试中经常被问到的。</p>
<p>JIT 的这些优化一般都是在后台进程默默地去做了，我们不需要关注太多。Code Cache 的容量达到上限，会影响程序执行的效率，但除非你有特别多的代码，默认的 240M 一般来说，足够用了。</p>
<p>-&ndash; ### 精选评论 ##### Zorrrrrro： &gt; 死循环那个是经过怎样优化产生的？ ######     讲师回复： &gt;     大体是因为未加volatile关键字造成了指令重排，happens-before原则不能保证。具体原因很复杂，可以参见这里：https://www.zhihu.com/question/263528143 ##### **王者： &gt; 那个是使用jit,哪个没用,哪个是内联,哪个是没有使用内联,看的晕 ######     讲师回复： &gt;     你是指JITWatch这个工具么？在Inling report里面这些信息是有显示的。靠分析二进制代码会比较费劲，建议直接使用工具</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%9821%E8%AE%B2/">Java 性能优化实战21讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/18%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%8A%E9%99%A4%E4%BA%86xa%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%AD%90%E6%8F%90%E4%BA%A4%E7%AE%97%E6%B3%95%E5%90%97/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">18分布式事务（上）：除了XA，还有哪些原子提交算法吗？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%A7%A3%E8%AF%BB%E4%BD%A0%E8%BA%AB%E8%BE%B9%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6/18%E4%B8%AA%E4%BA%BA%E4%B9%B0%E6%88%BF%E9%80%89%E6%8B%A9%E7%9C%BC%E8%A7%81%E4%B8%BA%E5%AE%9E%E7%9A%84%E7%8E%B0%E6%88%BF/">
            <span class="next-text nav-default">18个人买房：选择“眼见为实”的现房</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
