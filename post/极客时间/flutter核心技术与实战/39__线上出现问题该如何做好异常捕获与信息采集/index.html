<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>39__线上出现问题，该如何做好异常捕获与信息采集？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是陈航。
在上一篇文章中，我与你分享了如何为一个 Flutter 工程编写自动化测试用例。设计一个测试用例的基本步骤可以分为 3 步，即定义、执行和验证，而 Flutter 提供的单元测试和 UI 测试框架则可以帮助我们简化这些步骤。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/39__%E7%BA%BF%E4%B8%8A%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E8%AF%A5%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E4%B8%8E%E4%BF%A1%E6%81%AF%E9%87%87%E9%9B%86/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/39__%E7%BA%BF%E4%B8%8A%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E8%AF%A5%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E4%B8%8E%E4%BF%A1%E6%81%AF%E9%87%87%E9%9B%86/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="39__线上出现问题，该如何做好异常捕获与信息采集？">
  <meta property="og:description" content="你好，我是陈航。
在上一篇文章中，我与你分享了如何为一个 Flutter 工程编写自动化测试用例。设计一个测试用例的基本步骤可以分为 3 步，即定义、执行和验证，而 Flutter 提供的单元测试和 UI 测试框架则可以帮助我们简化这些步骤。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Flutter核心技术与实战">

  <meta itemprop="name" content="39__线上出现问题，该如何做好异常捕获与信息采集？">
  <meta itemprop="description" content="你好，我是陈航。
在上一篇文章中，我与你分享了如何为一个 Flutter 工程编写自动化测试用例。设计一个测试用例的基本步骤可以分为 3 步，即定义、执行和验证，而 Flutter 提供的单元测试和 UI 测试框架则可以帮助我们简化这些步骤。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6697">
  <meta itemprop="keywords" content="Flutter核心技术与实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="39__线上出现问题，该如何做好异常捕获与信息采集？">
  <meta name="twitter:description" content="你好，我是陈航。
在上一篇文章中，我与你分享了如何为一个 Flutter 工程编写自动化测试用例。设计一个测试用例的基本步骤可以分为 3 步，即定义、执行和验证，而 Flutter 提供的单元测试和 UI 测试框架则可以帮助我们简化这些步骤。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">39__线上出现问题，该如何做好异常捕获与信息采集？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6697 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#flutter-异常">Flutter 异常</a></li>
        <li><a href="#app-异常的捕获方式">App 异常的捕获方式</a></li>
        <li><a href="#framework-异常的捕获方式">Framework 异常的捕获方式</a></li>
        <li><a href="#异常上报">异常上报</a>
          <ul>
            <li><a href="#dart-接口实现">Dart 接口实现</a></li>
            <li><a href="#ios-接口实现">iOS 接口实现</a></li>
            <li><a href="#android-接口实现">Android 接口实现</a></li>
            <li><a href="#应用工程配置">应用工程配置</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是陈航。</p>
<p>在上一篇文章中，我与你分享了如何为一个 Flutter 工程编写自动化测试用例。设计一个测试用例的基本步骤可以分为 3 步，即定义、执行和验证，而 Flutter 提供的单元测试和 UI 测试框架则可以帮助我们简化这些步骤。</p>
<p>其中，通过单元测试，我们可以很方便地验证单个函数、方法或类的行为，还可以利用 mockito 定制外部依赖返回任意数据，从而让测试更可控；而 UI 测试则提供了与 Widget 交互的能力，我们可以模仿用户行为，对应用进行相应的交互操作，确认其功能是否符合预期。</p>
<p>通过自动化测试，我们可以把重复的人工操作变成自动化的验证步骤，从而在开发阶段更及时地发现问题。但终端设备的碎片化，使得我们终究无法在应用开发期就完全模拟出真实用户的运行环境。所以，无论我们的应用写得多么完美、测试得多么全面，总是无法完全避免线上的异常问题。</p>
<p>这些异常，可能是因为不充分的机型适配、用户糟糕的网络状况；也可能是因为 Flutter 框架自身的 Bug，甚至是操作系统底层的问题。这些异常一旦发生，Flutter 应用会无法响应用户的交互事件，轻则报错，重则功能无法使用甚至闪退，这对用户来说都相当不友好，是开发者最不愿意看到的。</p>
<p>所以，我们要想办法去捕获用户的异常信息，将异常现场保存起来，并上传至服务器，这样我们就可以分析异常上下文，定位引起异常的原因，去解决此类问题了。那么今天，我们就一起来学习下 Flutter 异常的捕获和信息采集，以及对应的数据上报处理。</p>
<h2 id="flutter-异常">Flutter 异常</h2>
<p>Flutter 异常指的是，Flutter 程序中 Dart 代码运行时意外发生的错误事件。我们可以通过与 Java 类似的 try-catch 机制来捕获它。但<strong>与 Java 不同的是，Dart 程序不强制要求我们必须处理异常</strong>。</p>
<p>这是因为，Dart 采用事件循环的机制来运行任务，所以各个任务的运行状态是互相独立的。也就是说，即便某个任务出现了异常我们没有捕获它，Dart 程序也不会退出，只会导致当前任务后续的代码不会被执行，用户仍可以继续使用其他功能。</p>
<p>Dart 异常，根据来源又可以细分为 App 异常和 Framework 异常。Flutter 为这两种异常提供了不同的捕获方式，接下来我们就一起看看吧。</p>
<h2 id="app-异常的捕获方式">App 异常的捕获方式</h2>
<p>App 异常，就是应用代码的异常，通常由未处理应用层其他模块所抛出的异常引起。根据异常代码的执行时序，App 异常可以分为两类，即同步异常和异步异常：同步异常可以通过 try-catch 机制捕获，异步异常则需要采用 Future 提供的 catchError 语句捕获。</p>
<p>这两种异常的捕获方式，如下代码所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 使用 try-catch 捕获同步异常
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">try {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  throw StateError(&#39;This is a Dart exception.&#39;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">catch(e) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  print(e);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 使用 catchError 捕获异步异常
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Future.delayed(Duration(seconds: 1))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    .then((e) =&gt; throw StateError(&#39;This is a Dart exception in Future.&#39;))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    .catchError((e)=&gt;print(e));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 注意，以下代码无法捕获异步异常
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">try {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Future.delayed(Duration(seconds: 1))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      .then((e) =&gt; throw StateError(&#39;This is a Dart exception in Future.&#39;))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">catch(e) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  print(&#34;This line will never be executed. &#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是，这两种方式是不能混用的。可以看到，在上面的代码中，我们是无法使用 try-catch 去捕获一个异步调用所抛出的异常的。</p>
<p>同步的 try-catch 和异步的 catchError，为我们提供了直接捕获特定异常的能力，而如果我们想集中管理代码中的所有异常，Flutter 也提供了 Zone.runZoned 方法。</p>
<p>我们可以给代码执行对象指定一个 Zone，在 Dart 中，Zone 表示一个代码执行的环境范围，其概念类似沙盒，不同沙盒之间是互相隔离的。如果我们想要观察沙盒中代码执行出现的异常，沙盒提供了 onError 回调函数，拦截那些在代码执行对象中的未捕获异常。</p>
<p>在下面的代码中，我们将可能抛出异常的语句放置在了 Zone 里。可以看到，在没有使用 try-catch 和 catchError 的情况下，无论是同步异常还是异步异常，都可以通过 Zone 直接捕获到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">runZoned(() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 同步抛出异常
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  throw StateError(&#39;This is a Dart exception.&#39;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}, onError: (dynamic e, StackTrace stack) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  print(&#39;Sync error caught by zone&#39;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">});
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> runZoned(() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 异步抛出异常
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Future.delayed(Duration(seconds: 1))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      .then((e) =&gt; throw StateError(&#39;This is a Dart exception in Future.&#39;));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}, onError: (dynamic e, StackTrace stack) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  print(&#39;Async error aught by zone&#39;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">});
</span></span></code></pre></td></tr></table>
</div>
</div><p>因此，如果我们想要集中捕获 Flutter 应用中的未处理异常，可以把 main 函数中的 runApp 语句也放置在 Zone 中。这样在检测到代码中运行异常时，我们就能根据获取到的异常上下文信息，进行统一处理了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">runZoned&lt;Future&lt;Null&gt;&gt;(() async {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  runApp(MyApp());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}, onError: (error, stackTrace) async {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> //Do sth for error
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">});
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，我们再看看 Framework 异常应该如何捕获吧。</p>
<h2 id="framework-异常的捕获方式">Framework 异常的捕获方式</h2>
<p>Framework 异常，就是 Flutter 框架引发的异常，通常是由应用代码触发了 Flutter 框架底层的异常判断引起的。比如，当布局不合规范时，Flutter 就会自动弹出一个触目惊心的红色错误界面，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/918060edc22e1f881e5fe07f817bd7ec.png" alt=""></p>
<p>图 1 Flutter 布局错误提示</p>
<p>这其实是因为，Flutter 框架在调用 build 方法构建页面时进行了 try-catch 的处理，并提供了一个 ErrorWidget，用于在出现异常时进行信息提示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">@override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void performRebuild() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Widget built;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  try {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 创建页面
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    built = build();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  } catch (e, stack) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 使用 ErrorWidget 创建页面
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    built = ErrorWidget.builder(_debugReportException(ErrorDescription(&#34;building $this&#34;), e, stack));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  } 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个页面反馈的信息比较丰富，适合开发期定位问题。但如果让用户看到这样一个页面，就很糟糕了。因此，我们通常会重写 ErrorWidget.builder 方法，将这样的错误提示页面替换成一个更加友好的页面。</p>
<p>下面的代码演示了自定义错误页面的具体方法。在这个例子中，我们直接返回了一个居中的 Text 控件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ErrorWidget.builder = (FlutterErrorDetails flutterErrorDetails){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  return Scaffold(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    body: Center(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      child: Text(&#34;Custom Error Widget&#34;),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    )
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  );
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行效果如下所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/34137e7d142ba073b50b6baa1bf78fcb.png" alt=""></p>
<p>图 2 自定义错误提示页面</p>
<p>比起之前触目惊心的红色错误页面，白色主题的自定义页面看起来稍微友好些了。需要注意的是，ErrorWidget.builder 方法提供了一个参数 details 用于表示当前的错误上下文，为避免用户直接看到错误信息，这里我们并没有将它展示到界面上。但是，我们不能丢弃掉这样的异常信息，需要提供统一的异常处理机制，用于后续分析异常原因。</p>
<p>为了集中处理框架异常，<strong>Flutter 提供了 FlutterError 类，这个类的 onError 属性会在接收到框架异常时执行相应的回调</strong>。因此，要实现自定义捕获逻辑，我们只要为它提供一个自定义的错误处理回调即可。</p>
<p>在下面的代码中，我们使用 Zone 提供的 handleUncaughtError 语句，将 Flutter 框架的异常统一转发到当前的 Zone 中，这样我们就可以统一使用 Zone 去处理应用内的所有异常了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">FlutterError.onError = (FlutterErrorDetails details) async {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 转发至 Zone 中
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Zone.current.handleUncaughtError(details.exception, details.stack);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> runZoned&lt;Future&lt;Null&gt;&gt;(() async {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  runApp(MyApp());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}, onError: (error, stackTrace) async {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> //Do sth for error
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">});
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="异常上报">异常上报</h2>
<p>到目前为止，我们已经捕获到了应用中所有的未处理异常。但如果只是把这些异常在控制台中打印出来还是没办法解决问题，我们还需要把它们上报到开发者能看到的地方，用于后续分析定位并解决问题。</p>
<p>关于开发者数据上报，目前市面上有很多优秀的第三方 SDK 服务厂商，比如友盟、Bugly，以及开源的 Sentry 等，而它们提供的功能和接入流程都是类似的。考虑到 Bugly 的社区活跃度比较高，因此我就以它为例，与你演示在抓取到异常后，如何实现自定义数据上报。</p>
<h3 id="dart-接口实现">Dart 接口实现</h3>
<p>目前 Bugly 仅提供了原生 Android/iOS 的 SDK，因此我们需要采用与第 31 篇文章“<a href="./132818.md">如何实现原生推送能力</a>？”中同样的插件工程，为 Bugly 的数据上报提供 Dart 层接口。</p>
<p>与接入 Push 能力相比，接入数据上报要简单得多，我们只需要完成一些前置应用信息关联绑定和 SDK 初始化工作，就可以使用 Dart 层封装好的数据上报接口去上报异常了。可以看到，对于一个应用而言，接入数据上报服务的过程，总体上可以分为两个步骤：</p>
<ol>
<li>初始化 Bugly SDK；</li>
<li>使用数据上报接口。</li>
</ol>
<p>这两步对应着在 Dart 层需要封装的 2 个原生接口调用，即 setup 和 postException，它们都是在方法通道上调用原生代码宿主提供的方法。考虑到数据上报是整个应用共享的能力，因此我们将数据上报类 FlutterCrashPlugin 的接口都封装成了单例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="n">FlutterCrashPlugin</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">//</span> <span class="err">初始化方法通道</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">const</span> <span class="n">MethodChannel</span> <span class="n">_channel</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">MethodChannel</span><span class="p">(</span><span class="s1">&#39;flutter_crash_plugin&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">static</span> <span class="n">void</span> <span class="n">setUp</span><span class="p">(</span><span class="n">appID</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">使用</span> <span class="n">app_id</span> <span class="err">进行</span> <span class="n">SDK</span> <span class="err">注册</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">_channel</span><span class="o">.</span><span class="n">invokeMethod</span><span class="p">(</span><span class="s2">&#34;setUp&#34;</span><span class="p">,{</span><span class="s1">&#39;app_id&#39;</span><span class="p">:</span><span class="n">appID</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="n">void</span> <span class="n">postException</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">将异常和堆栈上报至</span> <span class="n">Bugly</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">_channel</span><span class="o">.</span><span class="n">invokeMethod</span><span class="p">(</span><span class="s2">&#34;postException&#34;</span><span class="p">,{</span><span class="s1">&#39;crash_message&#39;</span><span class="p">:</span><span class="n">error</span><span class="o">.</span><span class="n">toString</span><span class="p">(),</span><span class="s1">&#39;crash_detail&#39;</span><span class="p">:</span><span class="n">stack</span><span class="o">.</span><span class="n">toString</span><span class="p">()});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Dart 层是原生代码宿主的代理，可以看到这一层的接口设计还是比较简单的。接下来，我们分别去接管数据上报的 Android 和 iOS 平台上完成相应的实现。</p>
<h3 id="ios-接口实现">iOS 接口实现</h3>
<p>考虑到 iOS 平台的数据上报配置工作相对较少，因此我们先用 Xcode 打开 example 下的 iOS 工程进行插件开发工作。需要注意的是，由于 iOS 子工程的运行依赖于 Flutter 工程编译构建产物，所以在打开 iOS 工程进行开发前，你需要确保整个工程代码至少 build 过一次，否则 IDE 会报错。</p>
<blockquote>
<p>备注：以下操作步骤参考<a href="./_v=20190712210424.md">Bugly 异常上报 iOS SDK 接入指南</a>。</p>
</blockquote>
<p><strong>首先</strong>，我们需要在插件工程下的 flutter_crash_plugin.podspec 文件中引入 Bugly SDK，即 Bugly，这样我们就可以在原生工程中使用 Bugly 提供的数据上报功能了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Pod::Spec.new do |s|
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  s.dependency &#39;Bugly&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">end
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>然后</strong>，在原生接口 FlutterCrashPlugin 类中，依次初始化插件实例、绑定方法通道，并在方法通道中先后为 setup 与 postException 提供 Bugly iOS SDK 的实现版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">@implementation FlutterCrashPlugin
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">+ (void)registerWithRegistrar:(NSObject&lt;FlutterPluginRegistrar&gt;*)registrar {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 注册方法通道
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    FlutterMethodChannel* channel = [FlutterMethodChannel
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      methodChannelWithName:@&#34;flutter_crash_plugin&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            binaryMessenger:[registrar messenger]];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 初始化插件实例，绑定方法通道 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    FlutterCrashPlugin* instance = [[FlutterCrashPlugin alloc] init];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 注册方法通道回调函数
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    [registrar addMethodCallDelegate:instance channel:channel];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> - (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if([@&#34;setUp&#34; isEqualToString:call.method]) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //Bugly SDK 初始化方法
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        NSString *appID = call.arguments[@&#34;app_id&#34;];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        [Bugly startWithAppId:appID];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    } else if ([@&#34;postException&#34; isEqualToString:call.method]) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      // 获取 Bugly 数据上报所需要的各个参数信息
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      NSString *message = call.arguments[@&#34;crash_message&#34;];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      NSString *detail = call.arguments[@&#34;crash_detail&#34;];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       NSArray *stack = [detail componentsSeparatedByString:@&#34;\n&#34;];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      // 调用 Bugly 数据上报接口
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      [Bugly reportExceptionWithCategory:4 name:message reason:stack[0] callStack:stack extraInfo:@{} terminateApp:NO];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      result(@0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 方法未实现
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    result(FlutterMethodNotImplemented);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> @end
</span></span></code></pre></td></tr></table>
</div>
</div><p>至此，在完成了 Bugly iOS SDK 的接口封装之后，FlutterCrashPlugin 插件的 iOS 部分也就搞定了。接下来，我们去看看 Android 部分如何实现吧。</p>
<h3 id="android-接口实现">Android 接口实现</h3>
<p>与 iOS 类似，我们需要使用 Android Studio 打开 example 下的 android 工程进行插件开发工作。同样，在打开 android 工程前，你需要确保整个工程代码至少 build 过一次，否则 IDE 会报错。</p>
<blockquote>
<p>备注：以下操作步骤参考<a href="./instruction-manual-android.md">Bugly 异常上报 Android SDK 接入指南</a></p>
</blockquote>
<p><strong>首先</strong>，我们需要在插件工程下的 build.gradle 文件引入 Bugly SDK，即 crashreport 与 nativecrashreport，其中前者提供了 Java 和自定义异常的的数据上报能力，而后者则是 JNI 的异常上报封装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">dependencies {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    implementation &#39;com.tencent.bugly:crashreport:latest.release&#39; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    implementation &#39;com.tencent.bugly:nativecrashreport:latest.release&#39; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>然后</strong>，在原生接口 FlutterCrashPlugin 类中，依次初始化插件实例、绑定方法通道，并在方法通道中先后为 setup 与 postException 提供 Bugly Android SDK 的实现版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class FlutterCrashPlugin implements MethodCallHandler {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 注册器，通常为 MainActivity
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  public final Registrar registrar;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 注册插件
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  public static void registerWith(Registrar registrar) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 注册方法通道
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    final MethodChannel channel = new MethodChannel(registrar.messenger(), &#34;flutter_crash_plugin&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 初始化插件实例，绑定方法通道，并注册方法通道回调函数 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    channel.setMethodCallHandler(new FlutterCrashPlugin(registrar));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   private FlutterCrashPlugin(Registrar registrar) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    this.registrar = registrar;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   @Override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  public void onMethodCall(MethodCall call, Result result) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if(call.method.equals(&#34;setUp&#34;)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      //Bugly SDK 初始化方法
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      String appID = call.argument(&#34;app_id&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       CrashReport.initCrashReport(registrar.activity().getApplicationContext(), appID, true);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      result.success(0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    else if(call.method.equals(&#34;postException&#34;)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      // 获取 Bugly 数据上报所需要的各个参数信息
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      String message = call.argument(&#34;crash_message&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      String detail = call.argument(&#34;crash_detail&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      // 调用 Bugly 数据上报接口
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      CrashReport.postException(4,&#34;Flutter Exception&#34;,message,detail,null);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      result.success(0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      result.notImplemented();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在完成了 Bugly Android 接口的封装之后，由于 Android 系统的权限设置较细，考虑到 Bugly 还需要网络、日志读取等权限，因此我们还需要在插件工程的 AndroidManifest.xml 文件中，将这些权限信息显示地声明出来，完成对系统的注册：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;manifest xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  package=&#34;com.hangchen.flutter_crash_plugin&#34;&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    &lt;!-- 电话状态读取权限 --&gt; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    &lt;uses-permission android:name=&#34;android.permission.READ_PHONE_STATE&#34; /&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    &lt;!-- 网络权限 --&gt; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    &lt;uses-permission android:name=&#34;android.permission.INTERNET&#34; /&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    &lt;!-- 访问网络状态权限 --&gt; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    &lt;uses-permission android:name=&#34;android.permission.ACCESS_NETWORK_STATE&#34; /&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    &lt;!-- 访问 wifi 状态权限 --&gt; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    &lt;uses-permission android:name=&#34;android.permission.ACCESS_WIFI_STATE&#34; /&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    &lt;!-- 日志读取权限 --&gt; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    &lt;uses-permission android:name=&#34;android.permission.READ_LOGS&#34; /&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;/manifest&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>至此，在完成了极光 Android SDK 的接口封装和权限配置之后，FlutterCrashPlugin 插件的 Android 部分也搞定了。</p>
<p>FlutterCrashPlugin 插件为 Flutter 应用提供了数据上报的封装，不过要想 Flutter 工程能够真正地上报异常消息，我们还需要为 Flutter 工程关联 Bugly 的应用配置。</p>
<h3 id="应用工程配置">应用工程配置</h3>
<p>在单独为 Android/iOS 应用进行数据上报配置之前，我们首先需要去<a href="./bugly.qq.com.md">Bugly 的官方网站</a>，为应用注册唯一标识符（即 AppKey）。这里需要注意的是，在 Bugly 中，Android 应用与 iOS 应用被视为不同的产品，所以我们需要分别注册：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/9c77513bb13cebc9dd6a6e64805b448e.png" alt=""></p>
<p>图 3 Android 应用 Demo 配置</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/14ac60b7b66899833ff0151903d3d12a.png" alt=""></p>
<p>图 4 iOS 应用 Demo 配置</p>
<p>在得到了 AppKey 之后，我们需要<strong>依次进行 Android 与 iOS 的配置工作</strong>。</p>
<p>iOS 的配置工作相对简单，整个配置过程完全是应用与 Bugly SDK 的关联工作，而这些关联工作仅需要通过 Dart 层调用 setUp 接口，访问原生代码宿主所封装的 Bugly API 就可以完成，因此无需额外操作。</p>
<p>而 Android 的配置工作则相对繁琐些。由于涉及 NDK 和 Android P 网络安全的适配，我们还需要分别在 build.gradle 和 AndroidManifest.xml 文件进行相应的配置工作。</p>
<p><strong>首先</strong>，由于 Bugly SDK 需要支持 NDK，因此我们需要在 App 的 build.gradle 文件中为其增加 NDK 的架构支持：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">defaultConfig {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ndk {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 设置支持的 SO 库架构
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        abiFilters &#39;armeabi&#39; , &#39;x86&#39;, &#39;armeabi-v7a&#39;, &#39;x86_64&#39;, &#39;arm64-v8a&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>然后</strong>，由于 Android P 默认限制 http 明文传输数据，因此我们需要为 Bugly 声明一项网络安全配置 network_security_config.xml，允许其使用 http 传输数据，并在 AndroidManifest.xml 中新增同名网络安全配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//res/xml/network_security_config.xml
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;!-- 网络安全配置 --&gt; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;network-security-config&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    &lt;!-- 允许明文传输数据 --&gt;  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    &lt;domain-config cleartextTrafficPermitted=&#34;true&#34;&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        &lt;!-- 将 Bugly 的域名加入白名单 --&gt; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        &lt;domain includeSubdomains=&#34;true&#34;&gt;android.bugly.qq.com&lt;/domain&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    &lt;/domain-config&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;/network-security-config&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> //AndroidManifest/xml
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;application
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  android:networkSecurityConfig=&#34;@xml/network_security_config&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ...&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;/application&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>至此，Flutter 工程所需的原生配置工作和接口实现，就全部搞定了。</p>
<p>接下来，我们就可以在 Flutter 工程中的 main.dart 文件中，<strong>使用 FlutterCrashPlugin 插件来实现异常数据上报能力了</strong>。当然，我们<strong>首先</strong>还需要在 pubspec.yaml 文件中，将工程对它的依赖显示地声明出来：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">dependencies:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  flutter_push_plugin:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    git:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      url: https://github.com/cyndibaby905/39_flutter_crash_plugin
</span></span></code></pre></td></tr></table>
</div>
</div><p>在下面的代码中，我们在 main 函数里为应用的异常提供了统一的回调，并在回调函数内使用 postException 方法将异常上报至 Bugly。</p>
<p>而在 SDK 的初始化方法里，由于 Bugly 视 iOS 和 Android 为两个独立的应用，因此我们判断了代码的运行宿主，分别使用两个不同的 App ID 对其进行了初始化工作。</p>
<p>此外，为了与你演示具体的异常拦截功能，我们还在两个按钮的点击事件处理中分别抛出了同步和异步两类异常：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 上报数据至 Bugly
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Future&lt;Null&gt; _reportError(dynamic error, dynamic stackTrace) async {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  FlutterCrashPlugin.postException(error, stackTrace);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> Future&lt;Null&gt; main() async {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 注册 Flutter 框架的异常回调
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  FlutterError.onError = (FlutterErrorDetails details) async {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 转发至 Zone 的错误回调
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Zone.current.handleUncaughtError(details.exception, details.stack);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  };
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 自定义错误提示页面
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ErrorWidget.builder = (FlutterErrorDetails flutterErrorDetails){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return Scaffold(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      body: Center(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        child: Text(&#34;Custom Error Widget&#34;),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      )
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    );
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  };
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 使用 runZone 方法将 runApp 的运行放置在 Zone 中，并提供统一的异常回调
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  runZoned&lt;Future&lt;Null&gt;&gt;(() async {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    runApp(MyApp());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }, onError: (error, stackTrace) async {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    await _reportError(error, stackTrace);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  });
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> class MyApp extends StatefulWidget {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  @override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  State&lt;StatefulWidget&gt; createState() =&gt; _MyAppState();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> class _MyAppState extends State&lt;MyApp&gt; {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  @override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  void initState() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 由于 Bugly 视 iOS 和 Android 为两个独立的应用，因此需要使用不同的 App ID 进行初始化
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if(Platform.isAndroid){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      FlutterCrashPlugin.setUp(&#39;43eed8b173&#39;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }else if(Platform.isIOS){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      FlutterCrashPlugin.setUp(&#39;088aebe0d5&#39;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    super.initState();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  @override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Widget build(BuildContext context) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return MaterialApp(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      home: MyHomePage(),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    );
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> class MyHomePage extends StatelessWidget {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  @override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Widget build(BuildContext context) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return Scaffold(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      appBar: AppBar(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        title: Text(&#39;Crashy&#39;),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      body: Center(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        child: Column(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          mainAxisAlignment: MainAxisAlignment.center,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          children: &lt;Widget&gt;[
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            RaisedButton(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              child: Text(&#39;Dart exception&#39;),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              onPressed: () {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // 触发同步异常
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                throw StateError(&#39;This is a Dart exception.&#39;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              },
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            ),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            RaisedButton(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              child: Text(&#39;async Dart exception&#39;),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              onPressed: () {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // 触发异步异常
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                Future.delayed(Duration(seconds: 1))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                      .then((e) =&gt; throw StateError(&#39;This is a Dart exception in Future.&#39;));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              },
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            )
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          ],
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    );
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行这段代码，分别点击 Dart exception 按钮和 async Dart exception 按钮几次，可以看到我们的应用以及控制台并没有提示任何异常信息。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/4f0ec76bc97fd65a9067e4f252dcbc74.png" alt=""></p>
<p>图 5 异常拦截演示示例（iOS）</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/1d4446883cc732210f57caf9945f0548.png" alt=""></p>
<p>图 6 异常拦截演示示例（Android）</p>
<p><strong>然后</strong>，我们打开<a href="./apps.md">Bugly 开发者后台</a>，选择对应的 App，切换到错误分析选项查看对应的面板信息。可以看到，Bugly 已经成功接收到上报的异常上下文了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/542c46112fbcbda09e763ccd98f54ed4.png" alt=""></p>
<p>图 7 Bugly iOS 错误分析上报数据查看</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/3be218c4d17c29b2c9e1a26390dcad3f.png" alt=""></p>
<p>图 8 Bugly Android 错误分析上报数据查看</p>
<h2 id="总结">总结</h2>
<p>好了，今天的分享就到这里，我们来小结下吧。</p>
<p>对于 Flutter 应用的异常捕获，可以分为单个异常捕获和多异常统一拦截两种情况。</p>
<p>其中，单异常捕获，使用 Dart 提供的同步异常 try-catch，以及异步异常 catchError 机制即可实现。而对多个异常的统一拦截，可以细分为如下两种情况：一是 App 异常，我们可以将代码执行块放置到 Zone 中，通过 onError 回调进行统一处理；二是 Framework 异常，我们可以使用 FlutterError.onError 回调进行拦截。</p>
<p>在捕获到异常之后，我们需要上报异常信息，用于后续分析定位问题。考虑到 Bugly 的社区活跃度比较高，所以我以 Bugly 为例，与你讲述了以原生插件封装的形式，如何进行异常信息上报。</p>
<p>需要注意的是，Flutter 提供的异常拦截只能拦截 Dart 层的异常，而无法拦截 Engine 层的异常。这是因为，Engine 层的实现大部分是 C++ 的代码，一旦出现异常，整个程序就直接 Crash 掉了。不过通常来说，这类异常出现的概率极低，一般都是 Flutter 底层的 Bug，与我们在应用层的实现没太大关系，所以我们也无需过度担心。</p>
<p>如果我们想要追踪 Engine 层的异常（比如，给 Flutter 提 Issue），则需要借助于原生系统提供的 Crash 监听机制。这，就是一个很繁琐的工作了。</p>
<p>幸运的是，我们使用的数据上报 SDK Bugly 就提供了这样的能力，可以自动收集原生代码的 Crash。而在 Bugly 收集到对应的 Crash 之后，我们需要做的事情就是，将 Flutter Engine 层对应的符号表下载下来，使用 Android 提供的 ndk-stack、iOS 提供的 symbolicatecrash 或 atos 命令，对相应 Crash 堆栈进行解析，从而得出 Engine 层崩溃的具体代码。</p>
<p>关于这些步骤的详细说明，你可以参考 Flutter<a href="./Crashes.md">官方文档</a>。</p>
<p>我把今天分享涉及的知识点打包到了<a href="./39%5Fcrashy%5Fdemo.md">GitHub</a>中，你可以下载下来，反复运行几次，加深理解与记忆。</p>
<h2 id="思考题">思考题</h2>
<p>最后，我给你留下两道思考题吧。</p>
<p>第一个问题，请扩展 _reportError 和自定义错误提示页面的实现，在 Debug 环境下将异常数据打印至控制台，并保留原有系统错误提示页面实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 上报数据至 Bugly
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Future&lt;Null&gt; _reportError(dynamic error, dynamic stackTrace) async {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  FlutterCrashPlugin.postException(error, stackTrace);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 自定义错误提示页面
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ErrorWidget.builder = (FlutterErrorDetails flutterErrorDetails){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  return Scaffold(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    body: Center(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      child: Text(&#34;Custom Error Widget&#34;),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    )
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  );
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二个问题，并发 Isolate 的异常可以通过今天分享中介绍的捕获机制去拦截吗？如果不行，应该怎么做呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 并发 Isolate
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">doSth(msg) =&gt; throw ConcurrentModificationError(&#39;This is a Dart exception.&#39;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 主 Isolate
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Isolate.spawn(doSth, &#34;Hi&#34;);
</span></span></code></pre></td></tr></table>
</div>
</div><p>欢迎你在评论区给我留言分享你的观点，我会在下一篇文章中等待你！感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/c35b0beb65ba6c713724c0b53ee1b6d3.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/">Flutter核心技术与实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes/39__%E8%B0%88%E8%B0%88service%E4%B8%8Eingress/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">39__谈谈Service与Ingress</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%BE%8E/39__%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E5%81%9A%E5%A5%BD%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E6%8A%8A%E7%BB%8F%E9%AA%8C%E5%8F%98%E6%88%90%E8%83%BD%E5%8A%9B/">
            <span class="next-text nav-default">39__项目总结：做好项目复盘，把经验变成能力</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
