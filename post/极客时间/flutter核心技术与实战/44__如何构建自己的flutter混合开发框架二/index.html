<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>44__如何构建自己的Flutter混合开发框架（二）？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是陈航。
在上一篇文章中，我从工程架构与工作模式两个层面，与你介绍了设计 Flutter 混合框架需要关注的基本设计原则，即确定分工边界。
在工程架构维度，由于 Flutter 模块作为原生工程的一个业务依赖，其运行环境是由原生工程提供的，因此我们需要将它们各自抽象为对应技术栈的依赖管理方式，以分层依赖的方式确定二者的边界。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/44__%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84flutter%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%BA%8C/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/44__%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84flutter%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%BA%8C/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="44__如何构建自己的Flutter混合开发框架（二）？">
  <meta property="og:description" content="你好，我是陈航。
在上一篇文章中，我从工程架构与工作模式两个层面，与你介绍了设计 Flutter 混合框架需要关注的基本设计原则，即确定分工边界。
在工程架构维度，由于 Flutter 模块作为原生工程的一个业务依赖，其运行环境是由原生工程提供的，因此我们需要将它们各自抽象为对应技术栈的依赖管理方式，以分层依赖的方式确定二者的边界。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Flutter核心技术与实战">

  <meta itemprop="name" content="44__如何构建自己的Flutter混合开发框架（二）？">
  <meta itemprop="description" content="你好，我是陈航。
在上一篇文章中，我从工程架构与工作模式两个层面，与你介绍了设计 Flutter 混合框架需要关注的基本设计原则，即确定分工边界。
在工程架构维度，由于 Flutter 模块作为原生工程的一个业务依赖，其运行环境是由原生工程提供的，因此我们需要将它们各自抽象为对应技术栈的依赖管理方式，以分层依赖的方式确定二者的边界。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7060">
  <meta itemprop="keywords" content="Flutter核心技术与实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="44__如何构建自己的Flutter混合开发框架（二）？">
  <meta name="twitter:description" content="你好，我是陈航。
在上一篇文章中，我从工程架构与工作模式两个层面，与你介绍了设计 Flutter 混合框架需要关注的基本设计原则，即确定分工边界。
在工程架构维度，由于 Flutter 模块作为原生工程的一个业务依赖，其运行环境是由原生工程提供的，因此我们需要将它们各自抽象为对应技术栈的依赖管理方式，以分层依赖的方式确定二者的边界。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">44__如何构建自己的Flutter混合开发框架（二）？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7060 字 </span>
          <span class="more-meta"> 预计阅读 15 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#原生插件依赖管理原则">原生插件依赖管理原则</a></li>
        <li><a href="#网络插件依赖管理实践">网络插件依赖管理实践</a></li>
        <li><a href="#网络插件接口封装">网络插件接口封装</a></li>
        <li><a href="#flutter-模块工程依赖管理">Flutter 模块工程依赖管理</a></li>
        <li><a href="#模块工程功能实现">模块工程功能实现</a></li>
        <li><a href="#构建产物应该如何封装">构建产物应该如何封装？</a>
          <ul>
            <li><a href="#ios-构建产物应该如何封装">iOS 构建产物应该如何封装？</a></li>
            <li><a href="#android-构建产物应该如何封装">Android 构建产物应该如何封装？</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是陈航。</p>
<p>在上一篇文章中，我从工程架构与工作模式两个层面，与你介绍了设计 Flutter 混合框架需要关注的基本设计原则，即确定分工边界。</p>
<p>在工程架构维度，由于 Flutter 模块作为原生工程的一个业务依赖，其运行环境是由原生工程提供的，因此我们需要将它们各自抽象为对应技术栈的依赖管理方式，以分层依赖的方式确定二者的边界。</p>
<p>而在工作模式维度，考虑到 Flutter 模块开发是原生开发的上游，因此我们只需要从其构建产物的过程入手，抽象出开发过程中的关键节点和高频节点，以命令行的形式进行统一管理。构建产物是 Flutter 模块的输出，同时也是原生工程的输入，一旦产物完成构建，我们就可以接入原生开发的工作流了。</p>
<p>可以看到，在 Flutter 混合框架中，Flutter 模块与原生工程是相互依存、互利共赢的关系：</p>
<ul>
<li>Flutter 跨平台开发效率高，渲染性能和多端体验一致性好，因此在分工上主要专注于实现应用层的独立业务（页面）的渲染闭环；</li>
<li>而原生开发稳定性高，精细化控制力强，底层基础能力丰富，因此在分工上主要专注于提供整体应用架构，为 Flutter 模块提供稳定的运行环境及对应的基础能力支持。</li>
</ul>
<p>那么，在原生工程中为 Flutter 模块提供基础能力支撑的过程中，面对跨技术栈的依赖管理，我们该遵循何种原则呢？对于 Flutter 模块及其依赖的原生插件们，我们又该如何以标准的原生工程依赖形式进行组件封装呢？</p>
<p>在今天的文章中，我就通过一个典型案例，与你讲述这两个问题的解决办法。</p>
<h2 id="原生插件依赖管理原则">原生插件依赖管理原则</h2>
<p>在前面<a href="./127601.md">第 26</a>和<a href="./132818.md">31 篇</a>文章里，我与你讲述了为 Flutter 应用中的 Dart 代码提供原生能力支持的两种方式，即：在原生工程中的 Flutter 应用入口注册原生代码宿主回调的轻量级方案，以及使用插件工程进行独立拆分封装的工程化解耦方案。</p>
<p>无论使用哪种方式，Flutter 应用工程都为我们提供了一体化的标准解决方案，能够在集成构建时自动管理原生代码宿主及其相应的原生依赖，因此我们只需要在应用层使用 pubspec.yaml 文件去管理 Dart 的依赖。</p>
<p>但<strong>对于混合工程而言，依赖关系的管理则会复杂一些</strong>。这是因为，与 Flutter 应用工程有着对原生组件简单清晰的单向依赖关系不同，混合工程对原生组件的依赖关系是多向的：Flutter 模块工程会依赖原生组件，而原生工程的组件之间也会互相依赖。</p>
<p>如果继续让 Flutter 的工具链接管原生组件的依赖关系，那么整个工程就会陷入不稳定的状态之中。因此，对于混合工程的原生依赖，Flutter 模块并不做介入，完全交由原生工程进行统一管理。而 Flutter 模块工程对原生工程的依赖，体现在依赖原生代码宿主提供的底层基础能力的原生插件上。</p>
<p>接下来，我就以网络通信这一基础能力为例，与你展开说明原生工程与 Flutter 模块工程之间应该如何管理依赖关系。</p>
<h2 id="网络插件依赖管理实践">网络插件依赖管理实践</h2>
<p>在第 24 篇文章“<a href="./121163.md">HTTP 网络编程与 JSON 解析</a>”中，我与你介绍了在 Flutter 中，我们可以通过 HttpClient、http 与 dio 这三种通信方式，实现与服务端的数据交换。</p>
<p>但在混合工程中，考虑到其他原生组件也需要使用网络通信能力，所以通常是由原生工程来提供网络通信功能的。因为这样不仅可以在工程架构层面实现更合理的功能分治，还可以统一整个 App 内数据交换的行为。比如，在网络引擎中为接口请求增加通用参数，或者是集中拦截错误等。</p>
<p>关于原生网络通信功能，目前市面上有很多优秀的第三方开源 SDK，比如 iOS 的 AFNetworking 和 Alamofire、Android 的 OkHttp 和 Retrofit 等。考虑到 AFNetworking 和 OkHttp 在各自平台的社区活跃度相对最高，因此我就以它俩为例，与你演示混合工程的原生插件管理方法。</p>
<h2 id="网络插件接口封装">网络插件接口封装</h2>
<p>要想搞清楚如何管理原生插件，我们需要先使用方法通道来建立 Dart 层与原生代码宿主之间的联系。</p>
<p>原生工程为 Flutter 模块提供原生代码能力，我们同样需要使用 Flutter 插件工程来进行封装。关于这部分内容，我在第<a href="./132818.md">31</a>和<a href="./141164.md">39</a>篇文章中，已经分别为你演示了推送插件和数据上报插件的封装方法，你也可以再回过头来复习下相关内容。所以，今天我就不再与你过多介绍通用的流程和固定的代码声明部分了，而是重点与你讲述与接口相关的实现细节。</p>
<p><strong>首先，我们来看看 Dart 代码部分。</strong></p>
<p>对于插件工程的 Dart 层代码而言，由于它仅仅是原生工程的代码宿主代理，所以这一层的接口设计比较简单，只需要提供一个可以接收请求 URL 和参数，并返回接口响应数据的方法 doRequest 即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class FlutterPluginNetwork {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  static Future&lt;String&gt; doRequest(url,params)  async {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 使用方法通道调用原生接口 doRequest，传入 URL 和 param 两个参数
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    final String result = await _channel.invokeMethod(&#39;doRequest&#39;, {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;url&#34;: url,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;param&#34;: params,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    });
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return result;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Dart 层接口封装搞定了，我们再来看看<strong>接管真实网络调用的 Android 和 iOS 代码宿主如何响应 Dart 层的接口调用</strong>。</p>
<p>我刚刚与你提到过，原生代码宿主提供的基础通信能力是基于 AFNetworking（iOS）和 OkHttp（Android）做的封装，所以为了在原生代码中使用它们，我们<strong>首先</strong>需要分别在 flutter_plugin_network.podspec 和 build.gradle 文件中将工程对它们的依赖显式地声明出来：</p>
<p>在 flutter_plugin_network.podspec 文件中，声明工程对 AFNetworking 的依赖：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Pod::Spec.new do |s|
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  s.dependency &#39;AFNetworking&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">end
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 build.gradle 文件中，声明工程对 OkHttp 的依赖：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">dependencies {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    implementation &#34;com.squareup.okhttp3:okhttp:4.2.0&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>然后</strong>，我们需要在原生接口 FlutterPluginNetworkPlugin 类中，完成例行的初始化插件实例、绑定方法通道工作。</p>
<p>最后，我们还需要在方法通道中取出对应的 URL 和 query 参数，为 doRequest 分别提供 AFNetworking 和 OkHttp 的实现版本。</p>
<p>对于 iOS 的调用而言，由于 AFNetworking 的网络调用对象是 AFHTTPSessionManager 类，所以我们需要这个类进行实例化，并定义其接口返回的序列化方式（本例中为字符串）。然后剩下的工作就是用它去发起网络请求，使用方法通道通知 Dart 层执行结果了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">@implementation FlutterPluginNetworkPlugin
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 方法通道回调
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">- (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 响应 doRequest 方法调用
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if ([@&#34;doRequest&#34; isEqualToString:call.method]) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 取出 query 参数和 URL
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        NSDictionary *arguments = call.arguments[@&#34;param&#34;];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        NSString *url = call.arguments[@&#34;url&#34;];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        [self doRequest:url withParams:arguments andResult:result];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 其他方法未实现
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        result(FlutterMethodNotImplemented);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 处理网络调用
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">- (void)doRequest:(NSString *)url withParams:(NSDictionary *)params andResult:(FlutterResult)result {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 初始化网络调用实例
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 定义数据序列化方式为字符串
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    manager.responseSerializer = [AFHTTPResponseSerializer serializer];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    NSMutableDictionary *newParams = [params mutableCopy];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 增加自定义参数
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    newParams[@&#34;ppp&#34;] = @&#34;yyyy&#34;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 发起网络调用
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    [manager GET:url parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 取出响应数据，响应 Dart 调用
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        NSString *string = [[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        result(string);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 通知 Dart 调用失败
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        result([FlutterError errorWithCode:@&#34;Error&#34; message:error.localizedDescription details:nil]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">@end
</span></span></code></pre></td></tr></table>
</div>
</div><p>Android 的调用也类似，OkHttp 的网络调用对象是 OkHttpClient 类，所以我们同样需要这个类进行实例化。OkHttp 的默认序列化方式已经是字符串了，所以我们什么都不用做，只需要 URL 参数加工成 OkHttp 期望的格式，然后就是用它去发起网络请求，使用方法通道通知 Dart 层执行结果了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class FlutterPluginNetworkPlugin implements MethodCallHandler {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  @Override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 方法通道回调
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  public void onMethodCall(MethodCall call, Result result) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 响应 doRequest 方法调用
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (call.method.equals(&#34;doRequest&#34;)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      // 取出 query 参数和 URL
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      HashMap param = call.argument(&#34;param&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      String url = call.argument(&#34;url&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      doRequest(url,param,result);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      // 其他方法未实现
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      result.notImplemented();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 处理网络调用
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  void doRequest(String url, HashMap&lt;String, String&gt; param, final Result result) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 初始化网络调用实例
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    OkHttpClient client = new OkHttpClient();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 加工 URL 及 query 参数
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    HttpUrl.Builder urlBuilder = HttpUrl.parse(url).newBuilder();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (String key : param.keySet()) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      String value = param.get(key);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      urlBuilder.addQueryParameter(key,value);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 加入自定义通用参数
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    urlBuilder.addQueryParameter(&#34;ppp&#34;, &#34;yyyy&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    String requestUrl = urlBuilder.build().toString();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     // 发起网络调用
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    final Request request = new Request.Builder().url(requestUrl).build();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    client.newCall(request).enqueue(new Callback() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      @Override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      public void onFailure(Call call, final IOException e) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 切换至主线程，通知 Dart 调用失败
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        registrar.activity().runOnUiThread(new Runnable() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          @Override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          public void run() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            result.error(&#34;Error&#34;, e.toString(), null);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        });
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            @Override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      public void onResponse(Call call, final Response response) throws IOException {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 取出响应数据
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        final String content = response.body().string();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 切换至主线程，响应 Dart 调用
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        registrar.activity().runOnUiThread(new Runnable() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            @Override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            public void run() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              result.success(content);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        });
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    });
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是，**由于方法通道是非线程安全的，所以原生代码与 Flutter 之间所有的接口调用必须发生在主线程。**而 OktHtp 在处理网络请求时，由于涉及非主线程切换，所以需要调用 runOnUiThread 方法以确保回调过程是在 UI 线程中执行的，否则应用可能会出现奇怪的 Bug，甚至是 Crash。</p>
<p>有些同学可能会比较好奇，**为什么 doRequest 的 Android 实现需要手动切回 UI 线程，而 iOS 实现则不需要呢？**这其实是因为 doRequest 的 iOS 实现背后依赖的 AFNetworking，已经在数据回调接口时为我们主动切换了 UI 线程，所以我们自然不需要重复再做一次了。</p>
<p>在完成了原生接口封装之后，Flutter 工程所需的网络通信功能的接口实现，就全部搞定了。</p>
<h2 id="flutter-模块工程依赖管理">Flutter 模块工程依赖管理</h2>
<p>通过上面这些步骤，我们以插件的形式提供了原生网络功能的封装。接下来，我们就需要在 Flutter 模块工程中使用这个插件，并提供对应的构建产物封装，提供给原生工程使用了。这部分内容主要包括以下 3 大部分：</p>
<ul>
<li>第一，如何使用 FlutterPluginNetworkPlugin 插件，也就是模块工程功能如何实现；</li>
<li>第二，模块工程的 iOS 构建产物应该如何封装，也就是原生 iOS 工程如何管理 Flutter 模块工程的依赖；</li>
<li>第三，模块工程的 Android 构建产物应该如何封装，也就是原生 Android 工程如何管理 Flutter 模块工程的依赖。</li>
</ul>
<p>接下来，我们具体看看每部分应该如何实现。</p>
<h2 id="模块工程功能实现">模块工程功能实现</h2>
<p>为了使用 FlutterPluginNetworkPlugin 插件实现与服务端的数据交换能力，我们首先需要在 pubspec.yaml 文件中，将工程对它的依赖显示地声明出来：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">flutter_plugin_network:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    git:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      url: https://github.com/cyndibaby905/44_flutter_plugin_network.git
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，我们还得在 main.dart 文件中为它提供一个触发入口。在下面的代码中，我们在界面上展示了一个 RaisedButton 按钮，并在其点击回调函数时，使用 FlutterPluginNetwork 插件发起了一次网络接口调用，并把网络返回的数据打印到了控制台上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">RaisedButton(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  child: Text(&#34;doRequest&#34;),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 点击按钮发起网络请求，打印数据
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  onPressed:()=&gt;FlutterPluginNetwork.doRequest(&#34;https://jsonplaceholder.typicode.com/posts&#34;, {&#39;userId&#39;:&#39;2&#39;}).then((s)=&gt;print(&#39;Result:$s&#39;)),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">)
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行这段代码，点击 doRequest 按钮，观察控制台输出，可以看到，接口返回的数据信息能够被正常打印，证明 Flutter 模块的功能表现是完全符合预期的。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/e4763ca6f5ead17a5cfe0d5051f60bf6.png" alt=""></p>
<p>图 1 Flutter 模块工程运行示例</p>
<h2 id="构建产物应该如何封装">构建产物应该如何封装？</h2>
<p>我们都知道，模块工程的 Android 构建产物是 aar，iOS 构建产物是 Framework。而在第<a href="./129754.md">28</a>和<a href="./144156.md">42</a>篇文章中，我与你介绍了不带插件依赖的模块工程构建产物的两种封装方案，即手动封装方案与自动化封装方案。这两种封装方案，最终都会输出同样的组织形式（Android 是 aar，iOS 则是带 podspec 的 Framework 封装组件）。</p>
<p>如果你已经不熟悉这两种封装方式的具体操作步骤了，可以再复习下这两篇文章的相关内容。接下来，我重点与你讲述的问题是：<strong>如果我们的模块工程存在插件依赖，封装过程是否有区别呢？</strong></p>
<p>答案是，对于模块工程本身而言，这个过程没有区别；但对于模块工程的插件依赖来说，我们需要主动告诉原生工程，哪些依赖是需要它去管理的。</p>
<p>由于 Flutter 模块工程把所有原生的依赖都交给了原生工程去管理，因此其构建产物并不会携带任何原生插件的封装实现，所以我们需要遍历模块工程所使用的原生依赖组件们，为它们逐一生成插件代码对应的原生组件封装。</p>
<p>在第 18 篇文章“<a href="./114180.md">依赖管理（二）：第三方组件库在 Flutter 中要如何管理？</a>”中，我与你介绍了 Flutter 工程管理第三方依赖的实现机制，其中.packages 文件存储的是依赖的包名与系统缓存中的包文件路径。</p>
<p>类似的，插件依赖也有一个类似的文件进行统一管理，即**.flutter-plugins**。我们可以通过这个文件，找到对应的插件名字（本例中即为 flutter_plugin_network）及缓存路径：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">flutter_plugin_network=/Users/hangchen/Documents/flutter/.pub-cache/git/44_flutter_plugin_network-9b4472aa46cf20c318b088573a30bc32c6961777/
</span></span></code></pre></td></tr></table>
</div>
</div><p>插件缓存本身也可以被视为一个 Flutter 模块工程，所以我们可以采用与模块工程类似的办法，为它生成对应的原生组件封装。</p>
<p>对于 iOS 而言，这个过程相对简单些，所以我们先来看看模块工程的 iOS 构建产物封装过程。</p>
<h3 id="ios-构建产物应该如何封装">iOS 构建产物应该如何封装？</h3>
<p>在插件工程的 ios 目录下，为我们提供了带 podspec 文件的源码组件，podspec 文件提供了组件的声明（及其依赖），因此我们可以把这个目录下的文件拷贝出来，连同 Flutter 模块组件一起放到原生工程中的专用目录，并写到 Podfile 文件里。</p>
<p>原生工程会识别出组件本身及其依赖，并按照声明的依赖关系依次遍历，自动安装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#Podfile
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">target &#39;iOSDemo&#39; do
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  pod &#39;Flutter&#39;, :path =&gt; &#39;Flutter&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  pod &#39;flutter_plugin_network&#39;, :path =&gt; &#39;flutter_plugin_network&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">end
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，我们就可以像使用不带插件依赖的模块工程一样，把它引入到原生工程中，为其设置入口，在 FlutterViewController 中展示 Flutter 模块的页面了。</p>
<p>不过需要注意的是，由于 FlutterViewController 并不感知这个过程，因此不会主动初始化项目中的插件，所以我们还需要在入口处手动将工程里所有的插件依次声明出来：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//AppDelegate.m:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">@implementation AppDelegate
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 初始化 Flutter 入口
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    FlutterViewController *vc = [[FlutterViewController alloc]init];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 初始化插件
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    [FlutterPluginNetworkPlugin registerWithRegistrar:[vc registrarForPlugin:@&#34;FlutterPluginNetworkPlugin&#34;]];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 设置路由标识符
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    [vc setInitialRoute:@&#34;defaultRoute&#34;]; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    self.window.rootViewController = vc;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    [self.window makeKeyAndVisible];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return YES;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 Xcode 中运行这段代码，点击 doRequest 按钮，可以看到，接口返回的数据信息能够被正常打印，证明我们已经可以在原生 iOS 工程中顺利的使用 Flutter 模块了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/3173e85643a87dd61f8e05968ffa66d7.png" alt=""></p>
<p>图 2 原生 iOS 工程运行示例</p>
<p>我们再来看看模块工程的 Android 构建产物应该如何封装。</p>
<h3 id="android-构建产物应该如何封装">Android 构建产物应该如何封装？</h3>
<p>与 iOS 的插件工程组件在 ios 目录类似，Android 的插件工程组件在 android 目录。对于 iOS 的插件工程，我们可以直接将源码组件提供给原生工程，但对于 Andriod 的插件工程来说，我们只能将 aar 组件提供给原生工程，所以我们不仅需要像 iOS 操作步骤那样进入插件的组件目录，还需要借助构建命令，为插件工程生成 aar：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">cd android
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">./gradlew flutter_plugin_network:assRel
</span></span></code></pre></td></tr></table>
</div>
</div><p>命令执行完成之后，aar 就生成好了。aar 位于 android/build/outputs/aar 目录下，我们打开插件缓存对应的路径，提取出对应的 aar（本例中为 flutter_plugin_network-debug.aar）就可以了。</p>
<p>我们把生成的插件 aar，连同 Flutter 模块 aar 一起放到原生工程的 libs 目录下，最后在 build.gradle 文件里将它显式地声明出来，就完成了插件工程的引入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//build.gradle
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">dependencies {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    implementation(name: &#39;flutter-debug&#39;, ext: &#39;aar&#39;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    implementation(name: &#39;flutter_plugin_network-debug&#39;, ext: &#39;aar&#39;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    implementation &#34;com.squareup.okhttp3:okhttp:4.2.0&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，我们就可以在原生工程中为其设置入口，在 FlutterView 中展示 Flutter 页面，愉快地使用 Flutter 模块带来的高效开发和高性能渲染能力了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//MainActivity.java
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class MainActivity extends AppCompatActivity {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected void onCreate(Bundle savedInstanceState) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        super.onCreate(savedInstanceState);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        View FlutterView = Flutter.createView(this, getLifecycle(), &#34;defaultRoute&#34;); 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        setContentView(FlutterView);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过<strong>需要注意的是</strong>，与 iOS 插件工程的 podspec 能够携带组件依赖不同，Android 插件工程的封装产物 aar 本身不携带任何配置信息。所以，如果插件工程本身存在原生依赖（像 flutter_plugin_network 依赖 OkHttp 这样），我们是无法通过 aar 去告诉原生工程其所需的原生依赖的。</p>
<p>面对这种情况，我们需要在原生工程中的 build.gradle 文件里手动地将插件工程的依赖（即 OkHttp）显示地声明出来。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//build.gradle
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">dependencies {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    implementation(name: &#39;flutter-debug&#39;, ext: &#39;aar&#39;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    implementation(name: &#39;flutter_plugin_network-debug&#39;, ext: &#39;aar&#39;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    implementation &#34;com.squareup.okhttp3:okhttp:4.2.0&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>至此，将模块工程及其插件依赖封装成原生组件的全部工作就完成了，原生工程可以像使用一个普通的原生组件一样，去使用 Flutter 模块组件的功能了。</strong></p>
<p>在 Android Studio 中运行这段代码，并点击 doRequest 按钮，可以看到，我们可以在原生 Android 工程中正常使用 Flutter 封装的页面组件了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/a3d46939f8b260c62545b23ba0263995.png" alt=""></p>
<p>图 3 原生 Android 工程运行示例</p>
<p>当然，考虑到手动封装模块工程及其构建产物的过程，繁琐且容易出错，我们可以把这些步骤抽象成命令行脚本，并把它部署到 Travis 上。这样在 Travis 检测到代码变更之后，就会自动将 Flutter 模块的构建产物封装成原生工程期望的组件格式了。</p>
<p>关于这部分内容，你可以参考我在<a href="./44%5Fflutter%5Fmodule%5Fdemo.md">flutter_module_demo</a>里的<a href="./generate%5Faars.sh.md">generate_aars.sh</a>与<a href="./generate%5Fpods.sh.md">generate_pods.sh</a>实现。如果关于这部分内容有任何问题，都可以直接留言给我。</p>
<h2 id="总结">总结</h2>
<p>好了，关于 Flutter 混合开发框架的依赖管理部分我们就讲到这里。接下来，我们一起总结下今天的主要内容吧。</p>
<p>Flutter 模块工程的原生组件封装形式是 aar（Android）和 Framework（Pod）。与纯 Flutter 应用工程能够自动管理插件的原生依赖不同，这部分工作在模块工程中是完全交给原生工程去管理的。因此，我们需要查找记录了插件名称及缓存路径映射关系的.flutter-plugins 文件，提取出每个插件所对应的原生组件封装，集成到原生工程中。</p>
<p>从今天的分享可以看出，对于有着插件依赖的 Android 组件封装来说，由于 aar 本身并不携带任何配置信息，因此其操作以手工为主：我们不仅要执行构建命令依次生成插件对应的 aar，还需要将插件自身的原生依赖拷贝至原生工程，其步骤相对 iOS 组件封装来说要繁琐一些。</p>
<p>为了解决这一问题，业界出现了一种名为<a href="./android-fat-aar.md">fat-aar</a>的打包手段，它能够将模块工程本身，及其相关的插件依赖统一打包成一个大的 aar，从而省去了依赖遍历和依赖声明的过程，实现了更好的功能自治性。但这种解决方案存在一些较为明显的不足：</p>
<ul>
<li>依赖冲突问题。如果原生工程与插件工程都引用了同样的原生依赖组件（OkHttp），则原生工程的组件引用其依赖时会产生合并冲突，因此在发布时必须手动去掉原生工程的组件依赖。</li>
<li>嵌套依赖问题。fat-aar 只会处理 embedded 关键字指向的这层一级依赖，而不会处理再下一层的依赖。因此，对于依赖关系复杂的插件支持，我们仍需要手动处理依赖问题。</li>
<li>Gradle 版本限制问题。fat-aar 方案对 Gradle 插件版本有限制，且实现方式并不是官方设计考虑的点，加之 Gradle API 变更较快，所以存在后续难以维护的问题。</li>
<li>其他未知问题。fat-aar 项目已经不再维护了，最近一次更新还是 2 年前，在实际项目中使用“年久失修”的项目存在较大的风险。</li>
</ul>
<p>考虑到这些因素，fat-aar 并不是管理插件工程依赖的好的解决方案，所以<strong>我们最好还是得老老实实地去遍历插件依赖，以持续交付的方式自动化生成 aar。</strong></p>
<p>我把今天分享涉及知识点打包上传到了 GitHub 中，你可以把<a href="./44%5Fflutter%5Fplugin%5Fnetwork.md">插件工程</a>、<a href="./44%5Fflutter%5Fmodule%5Fdemo.md">Flutter 模块工程</a>、<a href="./44%5FAndroidDemo.md">原生 Android</a>和<a href="./44%5FiOSDemo.md">iOS 工程</a>下载下来，查看其 Travis 持续交付配置文件的构建执行命令，体会在混合框架中如何管理跨技术栈的组件依赖。</p>
<h2 id="思考题">思考题</h2>
<p>最后，我给你留一道思考题吧。</p>
<p>原生插件的开发是一个需要 Dart 层代码封装，以及原生 Android、iOS 代码层实现的长链路过程。如果需要支持的基础能力较多，开发插件的过程就会变得繁琐且容易出错。我们都知道 Dart 是不支持反射的，但是原生代码可以。我们是否可以利用原生的反射去实现插件定义的标准化呢？</p>
<p>提示：在 Dart 层调用不存在的接口（或未实现的接口），可以通过 noSuchMethod 方法进行统一处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="n">FlutterPluginDemo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">//</span> <span class="err">方法通道</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">const</span> <span class="n">MethodChannel</span> <span class="n">_channel</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">MethodChannel</span><span class="p">(</span><span class="s1">&#39;flutter_plugin_demo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">//</span> <span class="err">当调用不存在接口时，</span><span class="n">Dart</span> <span class="err">会交由该方法进行统一处理</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Future</span><span class="o">&lt;</span><span class="n">dynamic</span><span class="o">&gt;</span> <span class="n">noSuchMethod</span><span class="p">(</span><span class="n">Invocation</span> <span class="n">invocation</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">从字符串</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&#34;methodName&#34;</span><span class="p">)</span> <span class="err">中取出方法名</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="ne">String</span> <span class="n">methodName</span> <span class="o">=</span> <span class="n">invocation</span><span class="o">.</span><span class="n">memberName</span><span class="o">.</span><span class="n">toString</span><span class="p">()</span><span class="o">.</span><span class="n">substring</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">string</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">参数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">dynamic</span> <span class="n">args</span> <span class="o">=</span> <span class="n">invocation</span><span class="o">.</span><span class="n">positionalArguments</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;methodName:$methodName&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;args:$args&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">methodTemplate</span><span class="p">(</span><span class="n">methodName</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">某未实现的方法</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Future</span><span class="o">&lt;</span><span class="n">dynamic</span><span class="o">&gt;</span> <span class="n">someMethodNotImplemented</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">//</span> <span class="err">某未实现的带参数方法</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Future</span><span class="o">&lt;</span><span class="n">dynamic</span><span class="o">&gt;</span> <span class="n">someMethodNotImplementedWithParameter</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>欢迎你在评论区给我留言分享你的观点，我会在下一篇文章中等待你！感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/c35b0beb65ba6c713724c0b53ee1b6d3.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/">Flutter核心技术与实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/44__%E7%90%86%E8%A7%A3io_waiti_o%E6%80%A7%E8%83%BD%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%E5%84%BF/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">44__理解IO_WAIT：I_O性能到底是怎么回事儿？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/44__%E5%AE%9E%E6%88%98%E5%9B%9B%E7%94%BB%E5%9B%BE%E7%A8%8B%E5%BA%8F%E5%90%8E%E7%AB%AF%E5%AE%9E%E6%88%98/">
            <span class="next-text nav-default">44__实战（四）：“画图”程序后端实战</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
