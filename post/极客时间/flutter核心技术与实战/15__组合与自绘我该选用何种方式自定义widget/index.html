<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>15__组合与自绘，我该选用何种方式自定义Widget？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是陈航。
在上一次分享中，我们认识了 Flutter 中最常用也最经典的布局 Widget，即单子容器 Container、多子容器 Row/Column，以及层叠容器 Stack 与 Positioned，也学习了这些不同容器之间的摆放子 Widget 的布局规则，我们可以通过它们，来实现子控件的对齐、嵌套、层叠等，它们也是构建一个界面精美的 App 所必须的布局概念。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/15__%E7%BB%84%E5%90%88%E4%B8%8E%E8%87%AA%E7%BB%98%E6%88%91%E8%AF%A5%E9%80%89%E7%94%A8%E4%BD%95%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%87%AA%E5%AE%9A%E4%B9%89widget/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/15__%E7%BB%84%E5%90%88%E4%B8%8E%E8%87%AA%E7%BB%98%E6%88%91%E8%AF%A5%E9%80%89%E7%94%A8%E4%BD%95%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%87%AA%E5%AE%9A%E4%B9%89widget/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="15__组合与自绘，我该选用何种方式自定义Widget？">
  <meta property="og:description" content="你好，我是陈航。
在上一次分享中，我们认识了 Flutter 中最常用也最经典的布局 Widget，即单子容器 Container、多子容器 Row/Column，以及层叠容器 Stack 与 Positioned，也学习了这些不同容器之间的摆放子 Widget 的布局规则，我们可以通过它们，来实现子控件的对齐、嵌套、层叠等，它们也是构建一个界面精美的 App 所必须的布局概念。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Flutter核心技术与实战">

  <meta itemprop="name" content="15__组合与自绘，我该选用何种方式自定义Widget？">
  <meta itemprop="description" content="你好，我是陈航。
在上一次分享中，我们认识了 Flutter 中最常用也最经典的布局 Widget，即单子容器 Container、多子容器 Row/Column，以及层叠容器 Stack 与 Positioned，也学习了这些不同容器之间的摆放子 Widget 的布局规则，我们可以通过它们，来实现子控件的对齐、嵌套、层叠等，它们也是构建一个界面精美的 App 所必须的布局概念。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4516">
  <meta itemprop="keywords" content="Flutter核心技术与实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="15__组合与自绘，我该选用何种方式自定义Widget？">
  <meta name="twitter:description" content="你好，我是陈航。
在上一次分享中，我们认识了 Flutter 中最常用也最经典的布局 Widget，即单子容器 Container、多子容器 Row/Column，以及层叠容器 Stack 与 Positioned，也学习了这些不同容器之间的摆放子 Widget 的布局规则，我们可以通过它们，来实现子控件的对齐、嵌套、层叠等，它们也是构建一个界面精美的 App 所必须的布局概念。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">15__组合与自绘，我该选用何种方式自定义Widget？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4516 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#组装">组装</a></li>
        <li><a href="#自绘">自绘</a></li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是陈航。</p>
<p>在上一次分享中，我们认识了 Flutter 中最常用也最经典的布局 Widget，即单子容器 Container、多子容器 Row/Column，以及层叠容器 Stack 与 Positioned，也学习了这些不同容器之间的摆放子 Widget 的布局规则，我们可以通过它们，来实现子控件的对齐、嵌套、层叠等，它们也是构建一个界面精美的 App 所必须的布局概念。</p>
<p>在实际开发中，我们会经常遇到一些复杂的 UI 需求，往往无法通过使用 Flutter 的基本 Widget，通过设置其属性参数来满足。这个时候，我们就需要针对特定的场景自定义 Widget 了。</p>
<p>在 Flutter 中，自定义 Widget 与其他平台类似：可以使用基本 Widget 组装成一个高级别的 Widget，也可以自己在画板上根据特殊需求来画界面。</p>
<p>接下来，我会分别与你介绍组合和自绘这两种自定义 Widget 的方式。</p>
<h2 id="组装">组装</h2>
<p>使用组合的方式自定义 Widget，即通过我们之前介绍的布局方式，摆放项目所需要的基础 Widget，并在控件内部设置这些基础 Widget 的样式，从而组合成一个更高级的控件。</p>
<p>这种方式，对外暴露的接口比较少，减少了上层使用成本，但也因此增强了控件的复用性。在 Flutter 中，<strong>组合的思想始终贯穿在框架设计之中</strong>，这也是 Flutter 提供了如此丰富的控件库的原因之一。</p>
<p>比如，在新闻类应用中，我们经常需要将新闻 Icon、标题、简介与日期组合成一个单独的控件，作为一个整体去响应用户的点击事件。面对这类需求，我们可以把现有的 Image、Text 及各类布局，组合成一个更高级的新闻 Item 控件，对外暴露设置 model 和点击回调的属性即可。</p>
<p>接下来，我通过一个例子为你说明如何通过组装去自定义控件。</p>
<p>下图是 App Store 的升级项 UI 示意图，图里的每一项，都有应用 Icon、名称、更新日期、更新简介、应用版本、应用大小以及更新 / 打开按钮。可以看到，这里面的 UI 元素还是相对较多的，现在我们希望将升级项 UI 封装成一个单独的控件，节省使用成本，以及后续的维护成本。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/bb0aaf2bbe1c59ba54edde2670607385.png" alt=""></p>
<p>图 1 App Store 升级项 UI</p>
<p>在分析这个升级项 UI 的整体结构之前，我们先定义一个数据结构 UpdateItemModel 来存储升级信息。在这里为了方便讨论，我把所有的属性都定义为了字符串类型，你在实际使用中可以根据需要将属性定义得更规范（比如，将 appDate 定义为 DateTime 类型）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class UpdateItemModel {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  String appIcon;//App 图标
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  String appName;//App 名称
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  String appSize;//App 大小
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  String appDate;//App 更新日期
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  String appDescription;//App 更新文案
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  String appVersion;//App 版本
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 构造函数语法糖，为属性赋值
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  UpdateItemModel({this.appIcon, this.appName, this.appSize, this.appDate, this.appDescription, this.appVersion});
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，我以 Google Map 为例，和你一起分析下这个升级项 UI 的整体结构。</p>
<p>按照子 Widget 的摆放方向，布局方式只有水平和垂直两种，因此我们也按照这两个维度对 UI 结构进行拆解。</p>
<p>按垂直方向，我们用绿色的框把这个 UI 拆解为上半部分与下半部分，如图 2 所示。下半部分比较简单，是两个文本控件的组合；上半部分稍微复杂一点，我们先将其包装为一个水平布局的 Row 控件。</p>
<p>接下来，我们再一起看看水平方向应该如何布局。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/a211d740f58003d74aa93c67752da6a7.png" alt=""></p>
<p>图 2 升级项 UI 整体结构示意图</p>
<p>我们先把升级项的上半部分拆解成对应的 UI 元素：</p>
<ul>
<li>左边的应用图标拆解为 Image；</li>
<li>右边的按钮拆解为 FlatButton；</li>
<li>中间部分是两个文本在垂直方向上的组合，因此拆解为 Column，Column 内部则是两个 Text。</li>
</ul>
<p>拆解示意图，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/e7a436ff3ac6bb73abb6ed5feab7900a.png" alt=""></p>
<p>图 3 上半部分 UI 结构示意图</p>
<p>通过与拆解前的 UI 对比，你就会发现还有 3 个问题待解决：即控件间的边距如何设置、中间部分的伸缩（截断）规则又是怎样、图片圆角怎么实现。接下来，我们分别来看看。</p>
<p>Image、FlatButton，以及 Column 这三个控件，与父容器 Row 之间存在一定的间距，因此我们还需要在最左边的 Image 与最右边的 FlatButton 上包装一层 Padding，用以留白填充。</p>
<p>另一方面，考虑到需要适配不同尺寸的屏幕，中间部分的两个文本应该是变长可伸缩的，但也不能无限制地伸缩，太长了还是需要截断的，否则就会挤压到右边按钮的固定空间了。</p>
<p>因此，我们需要在 Column 的外层用 Expanded 控件再包装一层，让 Image 与 FlatButton 之间的空间全留给 Column。不过，通常情况下这两个文本并不能完全填满中间的空间，因此我们还需要设置对齐格式，按照垂直方向上居中，水平方向上居左的方式排列。</p>
<p>最后一项需要注意的是，升级项 UI 的 App Icon 是圆角的，但普通的 Image 并不支持圆角。这时，我们可以使用 ClipRRect 控件来解决这个问题。ClipRRect 可以将其子 Widget 按照圆角矩形的规则进行裁剪，所以用 ClipRRect 将 Image 包装起来，就可以实现图片圆角的功能了。</p>
<p>下面的代码，就是控件上半部分的关键代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Widget buildTopRow(BuildContext context) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  return Row(//Row 控件，用来水平摆放子 Widget
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    children: &lt;Widget&gt;[
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      Padding(//Paddng 控件，用来设置 Image 控件边距
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        padding: EdgeInsets.all(10),// 上下左右边距均为 10
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        child: ClipRRect(// 圆角矩形裁剪控件
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          borderRadius: BorderRadius.circular(8.0),// 圆角半径为 8
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          child: Image.asset(model.appIcon, width: 80,height:80) 图片控件 //
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        )
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      Expanded(//Expanded 控件，用来拉伸中间区域
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        child: Column(//Column 控件，用来垂直摆放子 Widget
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          mainAxisAlignment: MainAxisAlignment.center,// 垂直方向居中对齐
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          crossAxisAlignment: CrossAxisAlignment.start,// 水平方向居左对齐
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          children: &lt;Widget&gt;[
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            Text(model.appName,maxLines: 1),//App 名字
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            Text(model.appDate,maxLines: 1),//App 更新日期
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          ],
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      Padding(//Paddng 控件，用来设置 Widget 间边距
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        padding: EdgeInsets.fromLTRB(0,0,10,0),// 右边距为 10，其余均为 0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        child: FlatButton(// 按钮控件
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          child: Text(&#34;OPEN&#34;),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          onPressed: onPressed,// 点击回调
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        )
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      )
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>升级项 UI 的下半部分比较简单，是两个文本控件的组合。与上半部分的拆解类似，我们用一个 Column 控件将它俩装起来，如图 4 所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/69c3db1c9c5f4acaa5c32a5033e15b82.png" alt=""></p>
<p>图 4 下半部分 UI 结构示意图</p>
<p>与上半部分类似，这两个文本与父容器之间存在些间距，因此在 Column 的最外层还需要用 Padding 控件给包装起来，设置父容器间距。</p>
<p>另一方面，Column 的两个文本控件间也存在间距，因此我们仍然使用 Padding 控件将下面的文本包装起来，单独设置这两个文本之间的间距。</p>
<p>同样地，通常情况下这两个文本并不能完全填满下部空间，因此我们还需要设置对齐格式，即按照水平方向上居左的方式对齐。</p>
<p>控件下半部分的关键代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Widget buildBottomRow(BuildContext context) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  return Padding(//Padding 控件用来设置整体边距
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    padding: EdgeInsets.fromLTRB(15,0,15,0),// 左边距和右边距为 15
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    child: Column(//Column 控件用来垂直摆放子 Widget
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      crossAxisAlignment: CrossAxisAlignment.start,// 水平方向距左对齐
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      children: &lt;Widget&gt;[
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        Text(model.appDescription),// 更新文案
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        Padding(//Padding 控件用来设置边距
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          padding: EdgeInsets.fromLTRB(0,10,0,0),// 上边距为 10
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          child: Text(&#34;${model.appVersion} • ${model.appSize} MB&#34;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        )
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后，我们将上下两部分控件通过 Column 包装起来，这次升级项 UI 定制就完成了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class UpdatedItem extends StatelessWidget {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  final UpdatedItemModel model;// 数据模型
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 构造函数语法糖，用来给 model 赋值
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  UpdatedItem({Key key,this.model, this.onPressed}) : super(key: key);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  final VoidCallback onPressed;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   @override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Widget build(BuildContext context) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return Column(// 用 Column 将上下两部分合体
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        children: &lt;Widget&gt;[
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          buildTopRow(context),// 上半部分
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          buildBottomRow(context)// 下半部分
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Widget buildBottomRow(BuildContext context) {...}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Widget buildTopRow(BuildContext context) {...}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>试着运行一下，效果如下所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/4887999ee7d3c4a57e66be5ba6e59b62.png" alt=""></p>
<p>图 5 升级项 UI 运行示例</p>
<p>搞定！</p>
<p><strong>按照从上到下、从左到右去拆解 UI 的布局结构，把复杂的 UI 分解成各个小 UI 元素，在以组装的方式去自定义 UI 中非常有用，请一定记住这样的拆解方法。</strong></p>
<h2 id="自绘">自绘</h2>
<p>Flutter 提供了非常丰富的控件和布局方式，使得我们可以通过组合去构建一个新的视图。但对于一些不规则的视图，用 SDK 提供的现有 Widget 组合可能无法实现，比如饼图，k 线图等，这个时候我们就需要自己用画笔去绘制了。</p>
<p>在原生 iOS 和 Android 开发中，我们可以继承 UIView/View，在 drawRect/onDraw 方法里进行绘制操作。其实，在 Flutter 中也有类似的方案，那就是 CustomPaint。</p>
<p><strong>CustomPaint 是用以承接自绘控件的容器，并不负责真正的绘制</strong>。既然是绘制，那就需要用到画布与画笔。</p>
<p>在 Flutter 中，画布是 Canvas，画笔则是 Paint，而画成什么样子，则由定义了绘制逻辑的 CustomPainter 来控制。将 CustomPainter 设置给容器 CustomPaint 的 painter 属性，我们就完成了一个自绘控件的封装。</p>
<p>对于画笔 Paint，我们可以配置它的各种属性，比如颜色、样式、粗细等；而画布 Canvas，则提供了各种常见的绘制方法，比如画线 drawLine、画矩形 drawRect、画点 DrawPoint、画路径 drawPath、画圆 drawCircle、画圆弧 drawArc 等。</p>
<p>这样，我们就可以在 CustomPainter 的 paint 方法里，通过 Canvas 与 Paint 的配合，实现定制化的绘制逻辑。</p>
<p>接下来，我们看一个例子。</p>
<p>在下面的代码中，我们继承了 CustomPainter，在定义了绘制逻辑的 paint 方法中，通过 Canvas 的 drawArc 方法，用 6 种不同颜色的画笔依次画了 6 个 1/6 圆弧，拼成了一张饼图。最后，我们使用 CustomPaint 容器，将 painter 进行封装，就完成了饼图控件 Cake 的定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class WheelPainter extends CustomPainter {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 设置画笔颜色 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Paint getColoredPaint(Color color) {// 根据颜色返回不同的画笔
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Paint paint = Paint();// 生成画笔
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    paint.color = color;// 设置画笔颜色
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return paint;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   @override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  void paint(Canvas canvas, Size size) {// 绘制逻辑
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    double wheelSize = min(size.width,size.height)/2;// 饼图的尺寸
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    double nbElem = 6;// 分成 6 份
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    double radius = (2 * pi) / nbElem;//1/6 圆
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 包裹饼图这个圆形的矩形框
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Rect boundingRect = Rect.fromCircle(center: Offset(wheelSize, wheelSize), radius: wheelSize);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 每次画 1/6 个圆弧
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    canvas.drawArc(boundingRect, 0, radius, true, getColoredPaint(Colors.orange));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    canvas.drawArc(boundingRect, radius, radius, true, getColoredPaint(Colors.black38));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    canvas.drawArc(boundingRect, radius * 2, radius, true, getColoredPaint(Colors.green));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    canvas.drawArc(boundingRect, radius * 3, radius, true, getColoredPaint(Colors.red));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    canvas.drawArc(boundingRect, radius * 4, radius, true, getColoredPaint(Colors.blue));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    canvas.drawArc(boundingRect, radius * 5, radius, true, getColoredPaint(Colors.pink));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 判断是否需要重绘，这里我们简单的做下比较即可
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  @override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  bool shouldRepaint(CustomPainter oldDelegate) =&gt; oldDelegate != this;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 将饼图包装成一个新的控件
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Cake extends StatelessWidget {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  @override
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Widget build(BuildContext context) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return CustomPaint(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        size: Size(200, 200),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        painter: WheelPainter(),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      );
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>试着运行一下，效果如下所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/f6b1d1df0890c50f4ec1747331c4b3e2.png" alt=""></p>
<p>图 6 自绘控件示例</p>
<p>可以看到，使用 CustomPainter 进行自绘控件并不算复杂。这里，我建议你试着用画笔和画布，去实现更丰富的功能。</p>
<p>**在实现视觉需求上，自绘需要自己亲自处理绘制逻辑，而组合则是通过子 Widget 的拼接来实现绘制意图。**因此从渲染逻辑处理上，自绘方案可以进行深度的渲染定制，从而实现少数通过组合很难实现的需求（比如饼图、k 线图）。不过，当视觉效果需要调整时，采用自绘的方案可能需要大量修改绘制代码，而组合方案则相对简单：只要布局拆分设计合理，可以通过更换子 Widget 类型来轻松搞定。</p>
<h2 id="总结">总结</h2>
<p>在面对一些复杂的 UI 视图时，Flutter 提供的单一功能类控件往往不能直接满足我们的需求。于是，我们需要自定义 Widget。Flutter 提供了组装与自绘两种自定义 Widget 的方式，来满足我们对视图的自定义需求。</p>
<p>以组装的方式构建 UI，我们需要将目标视图分解成各个 UI 小元素。通常，我们可以按照从上到下、从左到右的布局顺序去对控件层次结构进行拆解，将基本视觉元素封装到 Column、Row 中。对于有着固定间距的视觉元素，我们可以通过 Padding 对其进行包装，而对于大小伸缩可变的视觉元素，我们可以通过 Expanded 控件让其填充父容器的空白区域。</p>
<p>而以自绘的方式定义控件，则需要借助于 CustomPaint 容器，以及最终承接真实绘制逻辑的 CustomPainter。CustomPainter 是绘制逻辑的封装，在其 paint 方法中，我们可以使用不同类型的画笔 Paint，利用画布 Canvas 提供的不同类型的绘制图形能力，实现控件自定义绘制。</p>
<p>无论是组合还是自绘，在自定义 UI 时，有了目标视图整体印象后，我们首先需要考虑的事情应该是如何将它化繁为简，把视觉元素拆解细分，变成自己立即可以着手去实现的一个小控件，然后再思考如何将这些小控件串联起来。把大问题拆成小问题后，实现目标也逐渐清晰，落地方案就自然浮出水面了。</p>
<p>这其实就和我们学习新知识的过程是一样的，在对整体知识概念有了初步认知之后，也需要具备将复杂的知识化繁为简的能力：先理清楚其逻辑脉络，然后再把不懂的知识拆成小点，最后逐个攻破。</p>
<p>我把今天分享讲的两个例子放到了<a href="./15%5Fcustom%5Fui%5Fdemo.md">GitHub</a>上，你可以下载后在工程中实际运行，并对照着今天的知识点进行学习，体会在不同场景下，组合和自绘这两种自定义 Widget 的具体使用方法。</p>
<h2 id="思考题">思考题</h2>
<p>最后，我给你留下两道作业题吧。</p>
<ul>
<li>请扩展 UpdatedItem 控件，使其能自动折叠过长的更新文案，并能支持点击后展开的功能。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/d76a6c278903036c28e2c35be779c98f.png" alt=""></p>
<ul>
<li>请扩展 Cake 控件，使其能够根据传入的 double 数组（最多 10 个元素）中数值的大小，定义饼图的圆弧大小。</li>
</ul>
<p>欢迎你在评论区给我留言分享你的观点，我会在下一篇文章中等待你！感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/c35b0beb65ba6c713724c0b53ee1b6d3.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/">Flutter核心技术与实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/15__%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B%E5%A4%A7%E5%B7%A7%E4%B8%8D%E5%B7%A5javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">15__重剑无锋，大巧不工：JavaScript面向对象</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%E6%A0%B8%E5%BF%8320%E8%AE%B2/15__%E6%9C%80%E8%BF%91%E9%82%BB%E6%A3%80%E7%B4%A2%E4%B8%8A%E5%A6%82%E4%BD%95%E7%94%A8%E5%B1%80%E9%83%A8%E6%95%8F%E6%84%9F%E5%93%88%E5%B8%8C%E5%BF%AB%E9%80%9F%E8%BF%87%E6%BB%A4%E7%9B%B8%E4%BC%BC%E6%96%87%E7%AB%A0/">
            <span class="next-text nav-default">15__最近邻检索（上）：如何用局部敏感哈希快速过滤相似文章？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
