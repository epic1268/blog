<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>06_中间代码：不是只有一副面孔 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是宫文学。今天这一讲，我来带你认识一下中间代码（IR）。
IR，也就是中间代码（Intermediate Representation，有时也称 Intermediate Code，IC），它是编译器中很重要的一种数据结构。编译器在做完前端工作以后，首先就是生成 IR，并在此基础上执行各种优化算法，最后再生成目标代码。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/06_%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E4%B8%8D%E6%98%AF%E5%8F%AA%E6%9C%89%E4%B8%80%E5%89%AF%E9%9D%A2%E5%AD%94/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/06_%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E4%B8%8D%E6%98%AF%E5%8F%AA%E6%9C%89%E4%B8%80%E5%89%AF%E9%9D%A2%E5%AD%94/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="06_中间代码：不是只有一副面孔">
  <meta property="og:description" content="你好，我是宫文学。今天这一讲，我来带你认识一下中间代码（IR）。
IR，也就是中间代码（Intermediate Representation，有时也称 Intermediate Code，IC），它是编译器中很重要的一种数据结构。编译器在做完前端工作以后，首先就是生成 IR，并在此基础上执行各种优化算法，最后再生成目标代码。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="编译原理实战课">

  <meta itemprop="name" content="06_中间代码：不是只有一副面孔">
  <meta itemprop="description" content="你好，我是宫文学。今天这一讲，我来带你认识一下中间代码（IR）。
IR，也就是中间代码（Intermediate Representation，有时也称 Intermediate Code，IC），它是编译器中很重要的一种数据结构。编译器在做完前端工作以后，首先就是生成 IR，并在此基础上执行各种优化算法，最后再生成目标代码。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5393">
  <meta itemprop="keywords" content="编译原理实战课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="06_中间代码：不是只有一副面孔">
  <meta name="twitter:description" content="你好，我是宫文学。今天这一讲，我来带你认识一下中间代码（IR）。
IR，也就是中间代码（Intermediate Representation，有时也称 Intermediate Code，IC），它是编译器中很重要的一种数据结构。编译器在做完前端工作以后，首先就是生成 IR，并在此基础上执行各种优化算法，最后再生成目标代码。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">06_中间代码：不是只有一副面孔</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5393 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#ir-的用途和层次">IR 的用途和层次</a>
          <ul>
            <li><a href="#hir基于源语言做一些分析和变换">HIR：基于源语言做一些分析和变换</a></li>
            <li><a href="#mir独立于源语言和-cpu-架构做分析和优化">MIR：独立于源语言和 CPU 架构做分析和优化</a></li>
            <li><a href="#lir依赖于-cpu-架构做优化和代码生成">LIR：依赖于 CPU 架构做优化和代码生成</a></li>
          </ul>
        </li>
        <li><a href="#p-code用于解释执行的-ir">P-code：用于解释执行的 IR</a></li>
        <li><a href="#ir-的呈现格式">IR 的呈现格式</a></li>
        <li><a href="#ir-的数据结构">IR 的数据结构</a>
          <ul>
            <li><a href="#第一种类似-tac-的线性结构linear-form">第一种：类似 TAC 的线性结构（Linear Form）</a></li>
            <li><a href="#第二种树结构">第二种：树结构</a></li>
            <li><a href="#第三种有向无环图directed-acyclic-graphdag">第三种：有向无环图（Directed Acyclic Graph，DAG）</a></li>
            <li><a href="#第四种程序依赖图program-dependence-graphpdg">第四种：程序依赖图（Program Dependence Graph，PDG）</a></li>
          </ul>
        </li>
        <li><a href="#ssa-格式的-ir">SSA 格式的 IR</a></li>
        <li><a href="#课程小结">课程小结</a>
          <ul>
            <li><a href="#一课一思">一课一思</a></li>
            <li><a href="#参考资料">参考资料</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是宫文学。今天这一讲，我来带你认识一下中间代码（IR）。</p>
<p>IR，也就是中间代码（Intermediate Representation，有时也称 Intermediate Code，IC），它是编译器中很重要的一种数据结构。编译器在做完前端工作以后，首先就是生成 IR，并在此基础上执行各种优化算法，最后再生成目标代码。</p>
<p>所以说，编译技术的 IR 非常重要，它是运行各种优化算法、代码生成算法的基础。不过，鉴于 IR 的设计一般与编译器密切相关，而一些教科书可能更侧重于讲理论，所以对 IR 的介绍就不那么具体。这就导致我们对 IR 有非常多的疑问，比如：</p>
<ol>
<li><strong>IR 都有哪些不同的设计，可以分成什么类型？</strong></li>
<li><strong>IR 有像高级语言和汇编代码那样的标准书写格式吗？</strong></li>
<li><strong>IR 可以采用什么数据结构来实现？</strong></li>
</ol>
<p>为了帮助你把对 IR 的认识从抽象变得具体，我今天就从全局的视角和你一起梳理下 IR 有关的认知。</p>
<p>首先，我们来了解一下 IR 的用途，并一起看看由于用途不同导致 IR 分成的多个层次。</p>
<h2 id="ir-的用途和层次">IR 的用途和层次</h2>
<p>设计 IR 的目的，是要满足编译器中的各种需求。需求的不同，就会导致 IR 的设计不同。通常情况下，IR 有两种用途，一种是用来做分析和变换的，一种是直接用于解释执行的。我们先来看第一种。</p>
<p>编译器中，基于 IR 的分析和处理工作，一开始可以基于一些抽象层次比较高的语义，这时所需要的 IR 更接近源代码。而在后面，则会使用低层次的、更加接近目标代码的语义。</p>
<p>基于这种从高到低的抽象层次，IR 可以归结为 HIR、MIR 和 LIR 三类。</p>
<h3 id="hir基于源语言做一些分析和变换">HIR：基于源语言做一些分析和变换</h3>
<p>假设你要开发一款 IDE，那最主要的功能包括：发现语法错误、分析符号之间的依赖关系（以便进行跳转、判断方法的重载等）、根据需要自动生成或修改一些代码（提供重构能力）。</p>
<p>这个时候，你对 IR 的需求，是能够准确表达源语言的语义就行了。这种类型的 IR，可以叫做 High IR，简称 HIR。</p>
<p>其实，AST 和符号表就可以满足这个需求。也就是说，AST 也可以算作一种 IR。如果你要开发 IDE、代码翻译工具（从一门语言翻译到另一门语言）、代码生成工具、代码统计工具等，使用 AST（加上符号表）就够了。</p>
<p>当然，有些 HIR 并不是树状结构（比如可以采用线性结构），但一般会保留诸如条件判断、循环、数组等抽象层次比较高的语法结构。</p>
<p>基于 HIR，可以做一些高层次的代码优化，比如常数折叠、内联等。在 Java 和 Go 的编译器中，你可以看到不少基于 AST 做的优化工作。</p>
<h3 id="mir独立于源语言和-cpu-架构做分析和优化">MIR：独立于源语言和 CPU 架构做分析和优化</h3>
<p>大量的优化算法是可以通用的，没有必要依赖源语言的语法和语义，也没有必要依赖具体的 CPU 架构。</p>
<p>这些优化包括部分算术优化、常量和变量传播、死代码删除等，我会在下一讲和你介绍。实现这类分析和优化功能的 IR 可以叫做 Middle IR，简称 MIR。</p>
<p>因为 MIR 跟源代码和目标代码都无关，所以在讲解优化算法时，通常是基于 MIR，比如三地址代码（Three Address Code，TAC）。</p>
<p>TAC 的特点是，最多有三个地址（也就是变量），其中赋值符号的左边是用来写入的，而右边最多可以有两个地址和一个操作符，用于读取数据并计算。</p>
<p>我们来看一个例子，示例函数 foo：</p>
<p>int foo (int a){<br>
int b = 0;<br>
if (a &gt; 10)<br>
b = a;<br>
else<br>
b = 10;<br>
return b;<br>
}</p>
<p>对应的 TAC 可能是：</p>
<p>BB1:<br>
b := 0<br>
if a&gt;10 goto BB3   //如果 t 是 false(0),转到 BB3<br>
BB2:<br>
b := 10<br>
goto BB4<br>
BB3:<br>
b := a<br>
BB4:<br>
return b</p>
<p>可以看到，TAC 用 goto 语句取代了 if 语句、循环语句这种比较高级的语句，当然也不会有类、继承这些高层的语言结构。但是，它又没有涉及数据如何在内存读写等细节，书写格式也不像汇编代码，与具体的目标代码也是独立的。</p>
<p>所以，它的抽象程度算是不高不低。</p>
<h3 id="lir依赖于-cpu-架构做优化和代码生成">LIR：依赖于 CPU 架构做优化和代码生成</h3>
<p>最后一类 IR 就是 Low IR，简称 LIR。</p>
<p>这类 IR 的特点，是它的指令通常可以与机器指令一一对应，比较容易翻译成机器指令（或汇编代码）。因为 LIR 体现了 CPU 架构的底层特征，因此可以做一些与具体 CPU 架构相关的优化。</p>
<p>比如，下面是 Java 的 JIT 编译器输出的 LIR 信息，里面的指令名称已经跟汇编代码很像了，并且会直接使用 AMD64 架构的寄存器名称。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/1b31408ea88c902bc56b2044bb37660e.png" alt=""></p>
<p>图 1：Java 的 JIT 编译器的 LIR</p>
<p>好了，以上就是根据不同的使用目的和抽象层次，所划分出来的不同 IR 的关键知识点了。</p>
<p>HIR、MIR 和 LIR 这种划分方法，主要是参考“鲸书（Advanced Compiler Design and Implementation）”的提法。对此有兴趣的话，你可以参考一下这本书。</p>
<p>在实际操作时，有时候 IR 的划分标准不一定跟鲸书一致。在有的编译器里（比如 Graal 编译器），把相对高层次的 IR 叫做 HIR，相对低层次的叫做 LIR，而没有 MIR。你只要知道它们代表了不同的抽象层次就足够了。</p>
<p>其实，在一个编译器里，有时候会使用抽象层次从高到低的多种 IR，从便于“人”理解到便于“机器”理解。而编译过程可以理解为，抽象层次高的 IR 一直 lower 到抽象层次低的 IR 的过程，并且在每种 IR 上都会做一些适合这种 IR 的分析和处理工作，直到最后生成了优化的目标代码。</p>
<p>扩展：lower 这个词的意思，就是把对计算机程序的表示，从抽象层次比较高的、便于人理解的格式，转化为抽象层次比较低的、便于机器理解的格式。</p>
<p>有些 IR 的设计，本身就混合了多个抽象层次的元素，比如 Java 的 Graal 编译器里就采用了这种设计。Graal 的 IR 采用的是一种图结构，但随着优化阶段的进展，图中的一些节点会逐步从语义比较抽象的节点，lower 到体现具体架构特征的节点。</p>
<h2 id="p-code用于解释执行的-ir">P-code：用于解释执行的 IR</h2>
<p>好了，前 3 类 IR 是从抽象层次来划分的，它们都是用来做分析和变换的。我们继续看看第二种直接用于解释执行的 IR。这类 IR 还有一个名称，叫做 P-code，也就是 Portable Code 的意思。由于它与具体机器无关，因此可以很容易地运行在多种电脑上。这类 IR 对编译器来说，就是做编译的目标代码。</p>
<p>到这里，你一下子就会想到，Java 的字节码就是这种 IR。除此之外，Python、Erlang 也有自己的字节码，.NET 平台、Visual Basic 程序也不例外。</p>
<p>其实，你也完全可以基于 AST 实现一个全功能的解释器，只不过性能会差一些。对于专门用来解释执行 IR，通常会有一些特别的设计，跟虚拟机配合来尽量提升运行速度。</p>
<p>需要注意的是，P-code 也可能被进一步编译，形成可以直接执行的机器码。Java 的字节码就是这样的例子。因此，在这门课程里，我会带你探究 Java 的两个编译器，一个把源代码编译成字节码，一个把字节码编译成目标代码（支持 JIT 和 AOT 两种方式）。</p>
<p>好了，通过了解 IR 的不同用途，你应该会对 IR 的概念更清晰一些。用途不同，对 IR 的需求也就不同，IR 的设计自然也就会不同。这跟软件设计是由需求决定的，是同一个道理。</p>
<p>接下来的一个问题是，<strong>IR 是怎样书写的呢？</strong></p>
<h2 id="ir-的呈现格式">IR 的呈现格式</h2>
<p>虽然说是中间代码，但总得有一个书写格式吧，就像源代码和汇编代码那样。</p>
<p>其实 IR 通常是没有书写格式的。一方面，大多数的 IR 跟 AST 一样，只是编译过程中的一个数据结构而已，或者说只有内存格式。比如，LLVM 的 IR 在内存里是一些对象和接口。</p>
<p>另一方面，为了调试的需要，你可以把 IR 以文本的方式输出，用于显示和分析。在这门课里，你也会看到很多 IR 的输出格式。比如，下面是 Julia 的 IR：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/bc683880b3166ca203410e740094e46b.png" alt=""></p>
<p>图 2：Julia 语言输出的 IR 信息</p>
<p>在少量情况下，IR 有比较严格的输出格式，不仅用于显示和分析，还可以作为结果保存，并可以重新读入编译器中。比如，LLVM 的 bitcode，可以保存成文本和二进制两种格式，这两种格式间还可以相互转换。</p>
<p>我们以 C 语言为例，来看下 fun1 函数，及其对应的 LLVM IR 的文本格式和二进制格式：</p>
<p>//fun1.c<br>
int fun1(int a, int b){<br>
int c = 10;<br>
return a+b+c;<br>
}</p>
<p>LLVM IR 的文本格式（用“clang -emit-llvm -S fun1.c -o fun1.ll”命令生成，这里只节选了主要部分）：</p>
<p>; ModuleID = &lsquo;fun1.c&rsquo;<br>
source_filename = &ldquo;function-call1.c&rdquo;<br>
target datalayout = &ldquo;e-m:o-i64:64-f80:128-n8:16:32:64-S128&rdquo;<br>
target triple = &ldquo;x86_64-apple-macosx10.14.0&rdquo;</p>
<p>; Function Attrs: noinline nounwind optnone ssp uwtable<br>
define i32 @fun1(i32, i32) #0 {<br>
%3 = alloca i32, align 4<br>
%4 = alloca i32, align 4<br>
%5 = alloca i32, align 4<br>
store i32 %0, i32* %3, align 4<br>
store i32 %1, i32* %4, align 4<br>
store i32 10, i32* %5, align 4<br>
%6 = load i32, i32* %3, align 4<br>
%7 = load i32, i32* %4, align 4<br>
%8 = add nsw i32 %6, %7<br>
%9 = load i32, i32* %5, align 4<br>
%10 = add nsw i32 %8, %9<br>
ret i32 %10<br>
}</p>
<p>二进制格式（用“clang -emit-llvm -c fun1.c -o fun1.bc”命令生成，用“hexdump -C fun1.bc”命令显示）：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/f8de9f64b26f599004d0e0f48491e976.png" alt=""></p>
<p>图 3：LLVM IR 的二进制格式</p>
<h2 id="ir-的数据结构">IR 的数据结构</h2>
<p>既然我们一直说 IR 会表现为内存中的数据结构，那它到底是什么结构呢？</p>
<p>在实际的实现中，有线性结构、树结构、有向无环图（DAG）、程序依赖图（PDG）等多种格式。编译器会根据需要，选择合适的数据结构。在运行某些算法的时候，采用某个数据结构可能会更顺畅，而采用另一些结构可能会带来内在的阻滞。所以，<strong>我们一定要根据具体要处理的工作的特点，来选择合适的数据结构。</strong></p>
<p>那我们接下来，就具体看看每种格式的特点。</p>
<h3 id="第一种类似-tac-的线性结构linear-form">第一种：类似 TAC 的线性结构（Linear Form）</h3>
<p>你可以把代码表示成一行行的指令或语句，用数组或者列表保存就行了。其中的符号，需要引用符号表，来提供类型等信息。</p>
<p>这种线性结构有时候也被称作 goto 格式。因为高级语言里的条件语句、循环语句，要变成用 goto 语句跳转的方式。</p>
<h3 id="第二种树结构">第二种：树结构</h3>
<p>树结构当然可以用作 IR，AST 就是一种树结构。</p>
<p>很多资料中讲指令选择的时候，也会用到一种树状的结构，便于执行树覆盖算法。这个树结构，就属于一种 LIR。</p>
<p>树结构的缺点是，可能有冗余的子树。比如，语句“<code>a=5; b=(2+a)+a*3;</code> ”形成的 AST 就有冗余。如果基于这个树结构生成代码，可能会做两次从内存中读取 a 的值的操作，并存到两个临时变量中。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/99545b73d0cf1b44828207a0970a0488.png" alt=""></p>
<p>图 4：冗余的子树</p>
<h3 id="第三种有向无环图directed-acyclic-graphdag">第三种：有向无环图（Directed Acyclic Graph，DAG）</h3>
<p>DAG 结构，是在树结构的基础上，消除了冗余的子树。比如，上面的例子转化成 DAG 以后，对 a 的内存访问只做一次就行了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/3ea5275bbf22fbda3f541c123c579310.png" alt=""></p>
<p>图 5：DAG 结构消除了冗余的子树</p>
<p>在 LLVM 的目标代码生成环节，就使用了 DAG 来表示基本块内的代码。</p>
<h3 id="第四种程序依赖图program-dependence-graphpdg">第四种：程序依赖图（Program Dependence Graph，PDG）</h3>
<p>程序依赖图，是显式地把程序中的数据依赖和控制依赖表示出来，形成一个图状的数据结构。基于这个数据结构，我们再做一些优化算法的时候，会更容易实现。</p>
<p>所以现在，有很多编译器在运行优化算法的时候，都基于类似 PDG 的数据结构，比如我在课程后面会分析的 Java 的 JIT 编译器和 JavaScript 的编译器。</p>
<p>这种数据结构里，因为会有很多图节点，又被形象地称为“<strong>节点之海（Sea of Nodes）</strong>”。你在很多文章中，都会看到这个词。</p>
<p>以上就是常用于 IR 的数据结构了。接下来，我再介绍一个重要的 IR 设计范式：SSA 格式。</p>
<h2 id="ssa-格式的-ir">SSA 格式的 IR</h2>
<p>SSA 是 Static Single Assignment 的缩写，也就是静态单赋值。这是 IR 的一种设计范式，它要求一个变量只能被赋值一次。我们来看个例子。</p>
<p>“y = x1 + x2 + x3 + x4”的普通 TAC 如下：</p>
<p>y := x1 + x2;<br>
y := y + x3;<br>
y := y + x4;</p>
<p>其中，y 被赋值了三次，如果我们写成 SSA 的形式，就只能写成下面的样子：</p>
<p>t1 := x1 + x2;<br>
t2 := t1 + x3;<br>
y  := t2 + x4;</p>
<p><strong>那我们为什么要费力写成这种形式呢，还要为此多添加 t1 和 t2 两个临时变量？</strong></p>
<p>原因是，使用 SSA 的形式，体现了精确的“<strong>使用 - 定义（Use-def）</strong>”关系。并且由于变量的值定义出来以后就不再变化，使得基于 SSA 更容易运行一些优化算法。在后面的课程中，我会通过实际的例子带你体会这一点。</p>
<p>在 SSA 格式的 IR 中，还会涉及一个你经常会碰到的，但有些特别的指令，叫做 <strong>phi 指令</strong>。它是什么意思呢？我们看一个例子。</p>
<p>同样对于示例代码 foo：</p>
<p>int foo (int a){<br>
int b = 0;<br>
if (a &gt; 10)<br>
b = a;<br>
else<br>
b = 10;<br>
return b;<br>
}</p>
<p>它对应的 SSA 格式的 IR 可以写成：</p>
<p>BB1:<br>
b1 := 0<br>
if a&gt;10 goto BB3<br>
BB2:<br>
b2 := 10<br>
goto BB4<br>
BB3:<br>
b3 := a<br>
BB4:<br>
b4 := phi(BB2, BB3, b2, b3)<br>
return b4</p>
<p>其中，变量 b 有 4 个版本：b1 是初始值，b2 是 else 块（BB2）的取值，b3 是 if 块（BB3）的取值，最后一个基本块（BB4）要把 b 的最后取值作为函数返回值。很明显，b 的取值有可能是 b2，也有可能是 b3。这时候，就需要 phi 指令了。</p>
<p>phi 指令，会根据控制流的实际情况确定 b4 的值。如果 BB4 的前序节点是 BB2，那么 b4 的取值是 b2；而如果 BB4 的前序节点是 BB3，那么 b4 的取值就是 b3。所以你会看到，如果要满足 SSA 的要求，也就是一个变量只能赋值一次，那么在遇到有程序分支的情况下，就必须引入 phi 指令。关于这一点，你也会在课程后面经常见到它。</p>
<p>最后我要指出的是，**由于 SSA 格式的优点，现代语言用于优化的 IR，很多都是基于 SSA 的了，包括我们本课程涉及的 Java 的 JIT 编译器、JavaScript 的 V8 编译器、Go 语言的 gc 编译器、Julia 编译器，以及 LLVM 工具等。**所以，你一定要高度重视 SSA。</p>
<h2 id="课程小结">课程小结</h2>
<p>今天这一讲，我希望你能记住关于 IR 的几个重要概念：</p>
<ol>
<li><strong>根据抽象层次和使用目的不同，可以设计不同的 IR；</strong></li>
<li><strong>IR 可能采取多种数据结构，每种结构适合不同的处理工作；</strong></li>
<li><strong>由于 SSA 格式的优点，主流的编译器都在采用这种范式来设计 IR。</strong></li>
</ol>
<p>通过学习 IR，你会形成看待编译过程的一个新视角：整个编译过程，就是生成从高抽象度到低抽象度的一系列 IR，以及发生在这些 IR 上的分析与处理过程。</p>
<p>我还展示了三地址代码、LLVM IR 等一些具体的 IR 设计，希望能给你增加一些直观印象。在有的教科书里，还会有三元式、四元式、逆波兰格式等不同的设计，你也可以参考。而在后面的课程里，你会接触到每门编译器的 IR，从而对 IR 的理解更加具体和丰满。</p>
<p>本讲的思维导图如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/899d82611b63e110d85a47f066be2d13.png" alt=""></p>
<h3 id="一课一思">一课一思</h3>
<p>你能试着把下面这段简单的程序，改写成 TAC 和 SSA 格式吗？</p>
<p>int bar(a){<br>
int sum = 0;<br>
for (int i = 0; i&lt; a; i++){<br>
sum = sum+i;<br>
}<br>
return sum;<br>
}</p>
<p>欢迎在留言区分享你的见解，也欢迎你把今天的内容分享给更多的朋友。</p>
<h3 id="参考资料">参考资料</h3>
<ol>
<li>关于程序依赖图的论文参考：The Program Dependence Graph and its Use in Optimization。</li>
<li>更多的关于 LLVM IR 的介绍，你可以参考《编译原理之美》的第25、26讲，以及LLVM 官方文档。</li>
<li>对 Java 字节码的介绍，你可以参考《编译原理之美》的第 32 讲，还可以参考Java Language Specification。</li>
<li>鲸书（Advanced Compiler Design and Implementation）第 4 章。</li>
</ol>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/">编译原理实战课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/06_%E8%99%9A%E5%B9%BB%E4%B8%8E%E7%9C%9F%E5%AE%9E%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">06_虚幻与真实：程序中的地址如何转换？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2/06-mysql%E5%AE%9E%E6%88%9845%E8%AE%B2/">
            <span class="next-text nav-default">06-MySQL实战45讲</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
