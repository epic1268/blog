<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>09_Java编译器（一）：手写的编译器有什么优势？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是宫文学。
从今天开始呢，我会带着你去考察实际编译器的具体实现机制，你可以从中学习和印证编译原理的基础知识，进而加深你对编译原理的理解。
我们探险的第一站，是很多同学都很熟悉的 Java 语言，我们一起来看看它的编译器里都有什么奥秘。我从 97 年就开始用它，算是比较早了。当时，我就对它的“一次编译，到处运行”留下了很深的印象，我在 Windows 下写的程序，编译完毕以后放到 Solaris 上就能跑。现在看起来这可能不算什么，但在当年，我在 Windows 和 Unix 下写程序用的工具可是完全不同的。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/09_java%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%80%E6%89%8B%E5%86%99%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/09_java%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%80%E6%89%8B%E5%86%99%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="09_Java编译器（一）：手写的编译器有什么优势？">
  <meta property="og:description" content="你好，我是宫文学。
从今天开始呢，我会带着你去考察实际编译器的具体实现机制，你可以从中学习和印证编译原理的基础知识，进而加深你对编译原理的理解。
我们探险的第一站，是很多同学都很熟悉的 Java 语言，我们一起来看看它的编译器里都有什么奥秘。我从 97 年就开始用它，算是比较早了。当时，我就对它的“一次编译，到处运行”留下了很深的印象，我在 Windows 下写的程序，编译完毕以后放到 Solaris 上就能跑。现在看起来这可能不算什么，但在当年，我在 Windows 和 Unix 下写程序用的工具可是完全不同的。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="编译原理实战课">

  <meta itemprop="name" content="09_Java编译器（一）：手写的编译器有什么优势？">
  <meta itemprop="description" content="你好，我是宫文学。
从今天开始呢，我会带着你去考察实际编译器的具体实现机制，你可以从中学习和印证编译原理的基础知识，进而加深你对编译原理的理解。
我们探险的第一站，是很多同学都很熟悉的 Java 语言，我们一起来看看它的编译器里都有什么奥秘。我从 97 年就开始用它，算是比较早了。当时，我就对它的“一次编译，到处运行”留下了很深的印象，我在 Windows 下写的程序，编译完毕以后放到 Solaris 上就能跑。现在看起来这可能不算什么，但在当年，我在 Windows 和 Unix 下写程序用的工具可是完全不同的。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6946">
  <meta itemprop="keywords" content="编译原理实战课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="09_Java编译器（一）：手写的编译器有什么优势？">
  <meta name="twitter:description" content="你好，我是宫文学。
从今天开始呢，我会带着你去考察实际编译器的具体实现机制，你可以从中学习和印证编译原理的基础知识，进而加深你对编译原理的理解。
我们探险的第一站，是很多同学都很熟悉的 Java 语言，我们一起来看看它的编译器里都有什么奥秘。我从 97 年就开始用它，算是比较早了。当时，我就对它的“一次编译，到处运行”留下了很深的印象，我在 Windows 下写的程序，编译完毕以后放到 Solaris 上就能跑。现在看起来这可能不算什么，但在当年，我在 Windows 和 Unix 下写程序用的工具可是完全不同的。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">09_Java编译器（一）：手写的编译器有什么优势？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6946 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#初步了解-java-的编译器">初步了解 Java 的编译器</a></li>
        <li><a href="#词法分析器也是构造了一个有限自动机吗">词法分析器也是构造了一个有限自动机吗？</a></li>
        <li><a href="#语法分析器采用的是什么算法">语法分析器采用的是什么算法？</a></li>
        <li><a href="#课程小结">课程小结</a></li>
        <li><a href="#一课一思">一课一思</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是宫文学。</p>
<p>从今天开始呢，我会带着你去考察实际编译器的具体实现机制，你可以从中学习和印证编译原理的基础知识，进而加深你对编译原理的理解。</p>
<p>我们探险的第一站，是很多同学都很熟悉的 Java 语言，我们一起来看看它的编译器里都有什么奥秘。我从 97 年就开始用它，算是比较早了。当时，我就对它的“一次编译，到处运行”留下了很深的印象，我在 Windows 下写的程序，编译完毕以后放到 Solaris 上就能跑。现在看起来这可能不算什么，但在当年，我在 Windows 和 Unix 下写程序用的工具可是完全不同的。</p>
<p>到现在，Java 已经是一门非常成熟的语言了，而且它也在不断进化，与时俱进，泛型、函数式编程、模块化等特性陆续都增加了进来。在服务端编程领域，它也变得非常普及。</p>
<p>与此同时，Java 的编译器和虚拟机中所采用的技术，也比 20 年前发生了天翻地覆的变化。对于这么一门成熟的、广泛普及的、又不断焕发新生机的语言来说，研究它的编译技术会带来两个好处：一方面，Java 编译器所采用的技术肯定是比较成熟的、靠谱的，你在实现自己的编译功能时，完全可以去参考和借鉴；另一方面，你可以借此深入了解 Java 的编译过程，借此去实现一些高级的功能，比方说，按需生成字节码，就像 Spring 这类工具一样。</p>
<p>因此，我会花 4 讲的时间，跟你一起探索 Java 的前端编译器（javac）。然后再花 4 讲的时间在 Java 的 JIT 编译器上。</p>
<p>那么，针对 Java 编译器，你可能会提出下面的问题：</p>
<ol>
<li><strong>Java 的编译器是用什么语言编写的？</strong></li>
<li><strong>Java 的词法分析器和语法分析器，是工具生成的，还是手工编写的？为什么会这样选择？</strong></li>
<li><strong>语法分析的算法分为自顶向下和自底向上的。那么 Java 的选择是什么呢？有什么道理吗？</strong></li>
<li><strong>如何自己动手修改 Java 编译器？</strong></li>
</ol>
<p>这些问题，在今天的旅程结束后，你都会获得解答。并且，你还会获得一些额外的启发：噢，原来这个功能是可以这样做的呀！这是对你探险精神的奖励。</p>
<p>好吧，让我们开始吧。</p>
<p>第一步，我们先初步了解一下 Java 的编译器。</p>
<h2 id="初步了解-java-的编译器">初步了解 Java 的编译器</h2>
<p>大多数 Java 工程师是通过 javac 命令来初次接触 Java 编译器的。假设你写了一个 MyClass 类：</p>
<p>public class MyClass {<br>
public int a = 2+3;<br>
public int foo(){<br>
int b = a + 10;<br>
return b;<br>
}<br>
}</p>
<p>你可以用 javac 命令把 MyClass.java 文件编译成字节码文件：</p>
<p>javac MyClass.java</p>
<p>那这个 javac 的可执行文件就是 Java 的编译器吗？并不是。javac 只是启动了一个 Java 虚拟机，执行了一个 Java 程序，跟我们平常用“java”命令运行一个程序是一样的。换句话说，Java 编译器本身也是用 Java 写的。</p>
<p>这就很有趣了。我们知道，计算机语言是用来编写软件的，而编译器也是一种软件。所以，一门语言的编译器，竟然可以用自己来实现。这种现象，叫做“<strong>自举</strong>”(Bootstrapping)，这就好像一个人抓着自己的头发，要把自己提起来一样，多么神奇！实际上，一门语言的编译器，一开始肯定是要用其他语言来实现的。但等它成熟了以后，就会尝试实现自举。</p>
<p>既然 Java 编译器是用 Java 实现的，那意味着你自己也可以写一个程序，来调用 Java 的编译器。比如，运行下面的示例代码，也同样可以编译 MyClass.java 文件，生成 MyClass.class 文件：</p>
<p>import javax.tools.JavaCompiler;<br>
import javax.tools.ToolProvider;</p>
<p>public class CompileMyClass {<br>
public static void main(String[] args) {<br>
JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();<br>
int result = compiler.run(null, null, null, &ldquo;MyClass.java&rdquo;);<br>
System.out.println(&ldquo;Compile result code = &quot; + result);<br>
}<br>
}</p>
<p>其中，javax.tools.JavaCompiler 就是 Java 编译器的入口，属于 <strong>java.compiler 模块</strong>。这个模块包含了 Java 语言的模型、注解的处理工具，以及 Java 编译器的 API。</p>
<p>javax.tools.JavaCompiler 的实现是 com.sun.tools.javac.main.JavaCompiler。它在 <strong>jdk.compiler 模块中</strong>，这个模块里才是 Java 编译器的具体实现。</p>
<p>不过，在探索 Java 编译器的实现原理之前，你还需要从 openjdk.java.net 下载 JDK 的源代码，我使用的版本是 JDK14。在 IDE 中跟踪 JavaCompiler 的执行过程，你就会看到它一步一步地都是使用了哪个类的哪个方法。Java 的 IDE 工具一般都比较友好，给我们的探索提供了很多便利。</p>
<p>不仅如此，你还可以根据 openjdk 的文档，从源代码构建出 JDK。你还可以修改源代码并构建你自己的版本。</p>
<p>获得了源代码以后，我建议你重点关注这几个地方的源代码，这能帮助你迅速熟悉 Java 编译器的源代码结构。</p>
<p>**首先是 com.sun.source.tree 包，**这个包里面是 Java 语言的 AST 模型。我们在写一个编译器的时候，肯定要设计一个数据结构来保存 AST，那你就可以去参考一下 Java 是怎么做的。接下来，我就挑其中几个比较常用的节点，给你解释一下：</p>
<ol>
<li>ExpressionTree 指的是表达式，各种不同的表达式继承了这个接口，比如 BinaryTree 代表了所有的二元表达式；</li>
<li>StatementTree 代表了语句，它的下面又细分了各种不同的语句，比如，IfTree 代表了 If 语句，而 BlockTree 代表的是一个语句块。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/2ab8fdf81d1d4061994ad627299726c9.png" alt=""></p>
<p>图 1：com.sun.source.tree 包里的 Java 语言的 AST 模型</p>
<p><strong>然后是 com.sun.tools.javac.parser.Lexer（词法解析器接口）</strong>，它可以把字符流变成一个个的 Token，具体的实现在 Scanner 和 JavaTokenizer 类中。</p>
<p><strong>接下来是 com.sun.tools.javac.parser.Parser（语法解析器接口）</strong>，它能够解析类型、语句和表达式，具体的实现在 JavacParser 类中。</p>
<p>总结起来，Java 语言中与编译有关的功能放在了两个模块中：其中，java.compiler 模块主要是对外的接口，而 jdk.compiler 中有具体的实现。**不过你要注意，**像 com.sun.tools.javac.parser 包中的类，不是 Java 语言标准的组成部分，如果你直接使用这些类，可能导致代码在不同的 JDK 版本中不兼容。</p>
<p>现在，我们已经熟悉了 Java 编译器的概要信息。在浏览这两个模块的代码时，我们会发现里面的内容非常多。为了让自己不会迷失在其中，我们需要找到一个方法。你已经知道，编译器的前端分为词法分析、语法分析、语义分析等阶段，那么我们就可以按照这个阶段一块一块地去探索。</p>
<p>首先，我们看看 Java 的词法分析器。</p>
<h2 id="词法分析器也是构造了一个有限自动机吗">词法分析器也是构造了一个有限自动机吗？</h2>
<p>通过跟踪执行，你会发现词法分析器的具体实现在 JavaTokenizer 类中。你可以先找到这个类，在 readToken() 方法里打个断点，让程序运行到这里，然后查看词法分析的执行过程。</p>
<p>在学词法分析的时候，你肯定知道要构造一个有限自动机，而且当输入的字符发生变化的时候，自动机的状态也会产生变化。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/888a29772c38c232b125fd2997e5d81c.png" alt=""></p>
<p>图 2：一个有限自动机，能够区分数字字面量（状态 1）和标识符（状态 2）</p>
<p>**那么实战中，Java 做词法分析的逻辑是什么呢？**你可以先研究一下 readToken() 方法，这个方法实现了主干的词法分析逻辑，它能够从字符流中识别出一个个的 Token 来。</p>
<p>readToken 的逻辑变成伪代码是这样的：</p>
<p>循环读取字符<br>
case 空白字符<br>
处理，并继续循环<br>
case 行结束符<br>
处理，并继续循环<br>
case A-Za-z$_<br>
调用 scanIden() 识别标识符和关键字，并结束循环<br>
case 0 之后是 X 或 x，或者 1-9<br>
调用 scanNumber() 识别数字，并结束循环  <br>
case , ; ( ) [ ] 等字符<br>
返回代表这些符号的 Token，并结束循环<br>
case isSpectial()，也就是% * + - | 等特殊字符<br>
调用 scanOperator() 识别操作符<br>
&hellip;</p>
<p>如果画成有限自动机，大致是这样的：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/a51f3b00010fd5071e3fc0c41821855e.png" alt=""></p>
<p>图 3：Java 词法分析器的有限自动机</p>
<p>在第 2 讲中我提到过，关键字和标识符的规则是冲突的：</p>
<ol>
<li>标识符的规则是以<code>A-Za-z$_</code>开头，后续字符可以是<code>A-Za-z$_</code>、数字和其他的合法字符；</li>
<li>关键字（比如 if）也符合标识符的规则，可以说是标识符的子集。</li>
</ol>
<p>这种冲突是词法分析的一个技术点，因为不到最后你不知道读入的是一个关键字，还是一个普通的标识符。如果单纯按照有限自动机的算法去做词法分析，想要区分 int 关键字和其他标识符的话，你就会得到图 4 那样的一个有限自动机。</p>
<p>当输入的字符串是“int”的时候，它会进入状态 4。如果这个时候遇到结束字符，就会提取出 int 关键字。除此之外，“i”（状态 2）、“in”（状态 3）和“intA”（状态 5）都属于标识符。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/1c36c70e858696c104fa63ea78a58521.png" alt=""></p>
<p>图 4：能够处理 int 和标识符语法的有限自动机</p>
<p>但是关键字有很多，if、else、int、long、class…如果按照这个方式构造有限自动机，就会很啰嗦。那么 java 是怎么处理这个问题的呢？</p>
<p>Java 编译器的处理方式比较简单，分成了两步：首先把所有的关键字和标识符都作为标识符识别出来，然后再从里面把所有预定义的关键字挑出来。这比构造一个复杂的有限自动机实现起来更简单！</p>
<p>通过这样的代码分析，你可以发现：Java 的词法解析程序在主干上是遵循有限自动机的算法的，但在很多局部的地方，为了让词法分析的过程更简单高效，采用了手写的算法。</p>
<p>我建议你在 IDE 中，采用调试模式跟踪执行，看看每一步的执行结果，这样你能对 Java 词法分析的过程和结果有更直观的理解。另外，你还可以写一个程序，直接使用词法分析器做解析，并打印出一个个 Token。这会很有趣，你可以试试看！</p>
<p>接下来，我们进一步研究一下 Java 的语法分析器。</p>
<h2 id="语法分析器采用的是什么算法">语法分析器采用的是什么算法？</h2>
<p>跟所有的语法分析器一样，Java 的语法分析器会把词法分析器生成的 Token 流，生成一棵 AST。</p>
<p>下面的 AST 就是 MyClass.java 示例代码对应的 AST（其中的 JCXXX 节点都是实现了 com.sun.source.tree 中的接口，比如 JCBinary 实现了 BinaryTree 接口，而 JCLiteral 实现了 LiteralTree 接口）。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/49ebc5861fb7c00813f87a87aee494e2.png" alt=""></p>
<p>图 5：MyClass.java 对应的 AST</p>
<p>我想你应该知道，语法分析的算法分为自顶向下和自底向上两种：</p>
<ol>
<li>以 LL 算法为代表的自顶向下的算法，比较直观、容易理解，但需要解决左递归问题；</li>
<li>以 LR 算法为代表的自底向上算法，能够避免左递归问题，但不那么直观，不太容易理解。</li>
</ol>
<p><strong>那么，Java 编译器用的是什么算法呢？</strong></p>
<p>你可以打开 com.sun.tools.javac.parser.JavacParser 这个类看一下代码。比如，你首先查看一下 parseExpression() 方法（也就是解析一个表达式）。阅读代码，你会看到这样的调用层次：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/71f0f76109f8ec92434afaf142f032a5.png" alt=""></p>
<p>图 6：解析表达式时的调用层次</p>
<p>我们以解析“2+3”这样一个表达式，来一层一层地理解下这个解析过程。</p>
<p><strong>第 1 步，需要匹配一个 term。</strong></p>
<p>term 是什么呢？其实，它就是赋值表达式，比如“a=2”或“b=3”等。算法里把这样一个匹配过程又分为两部分，赋值符号左边的部分是 term1，其他部分是 termRest。其中，term1 是必须匹配上的，termRest 是可选的。如果匹配上了 termRest，那么证明这是个赋值表达式；否则就只是左边部分，也就是 term1。</p>
<p>如果你比较敏感的话，那仅仅分析第一步，你差不多就能知道这是什么算法了。</p>
<p>另外，你可能还会对 Rest 这个单词特别敏感。你还记得我们在什么地方提到过 Rest 这个词汇吗？是的，在第 3 讲中，我把左递归改写成右递归的时候，那个右递归的部分，我们一般就叫做 XXXRest 或 XXXTail。</p>
<p>不过没关系，你可以先保留着疑问，我们继续往下看，来印证一下看法是不是对的。</p>
<p><strong>第 2 步，匹配 term1。</strong></p>
<p>term1 又是什么呢？term1 是一个三元表达式，比如 a &gt; 3 ? 1 : 2。其中，比较操作符左边的部分是 term2，剩下的部分叫做 term1Rest。其中 term2 是必须匹配的，term1Rest 是可选的。</p>
<p><strong>第 3 步，匹配 term2。</strong></p>
<p>term2 代表了所有的二元表达式。它再次分为 term3 和 term2Rest 两部分，前者是必须匹配的，后者是可选的。</p>
<p><strong>第 4 步，匹配 term3。</strong></p>
<p>term3 往下我就不深究了，总之，是返回一个字面量 2。</p>
<p><strong>第 5 步，匹配 term2Rest。</strong></p>
<p>首先匹配“+”操作符；然后匹配一个 term3()，这里是返回一个字面量 3。</p>
<p><strong>第 6 步，回到 term1() 方法，试图匹配 term1Rest，没有匹配上。</strong></p>
<p><strong>第 7 步，回到 term() 方法，试图匹配 termRest，也没有匹配上。</strong></p>
<p><strong>第 8 步，从 term() 方法返回一个代表“2+3”的 AST</strong>，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/9ed1eea71a9e54e7dca028b6f3d6be23.png" alt=""></p>
<p>图 7：“2+3”对应的 AST</p>
<p>讲到这儿，我想问问你：你从这样的分析中，得到了什么信息？</p>
<p>**第一，这是一个递归下降算法。**因为它是通过逐级下降的方法来解析，从 term 到 term1、term2、term3，直到最后是字面量这样最基础的表达式。</p>
<p>在第 3 讲里我说过，递归下降算法是每个程序员都应该掌握的语法分析算法。<strong>你看，像 Java 这么成熟的语言，其实采用的也是递归下降算法。</strong></p>
<p>**第二，Java 采用了典型的消除左递归的算法。**我带你回忆一下，对于：</p>
<p>add -&gt; add + mul</p>
<p>这样的左递归的文法，它可以改成下面的非左递归文法：</p>
<p>add -&gt; mul add&rsquo;<br>
add&rsquo; -&gt; + add&rsquo; | ε</p>
<p>如果我再换一下表达方式，就会变成 Java 语法解释器里的代码逻辑：</p>
<p>term2 -&gt; term3 term2Rest<br>
term2Rest -&gt; + term3 | ε</p>
<p><strong>第三，Java 编译器对优先级和结合性的处理，值得深究。</strong></p>
<p>首先看看优先级。我们通常是通过语法逐级嵌套的方式来表达优先级的。比如，按照下面的语法规则生成的 AST，乘法节点会在加法节点下面，因此先于加法节点计算，从而优先级更高。实际上，Java 做语法分析的时候，term1-&gt;term2-&gt;term3 的过程，也是优先级逐步提高的过程。</p>
<p>add -&gt; mul add&rsquo;<br>
add&rsquo; -&gt; + mul add&rsquo; | ε<br>
mul -&gt; pri mul&rsquo;<br>
mul&rsquo; -&gt; * pri mul&rsquo; | ε</p>
<p>可是，在 term2 中，实际上它解析了所有的二元表达式，在语法规则上，它把使用“&amp;&amp;”“ &gt;”“+”“*”这些不同优先级的操作符的表达式，都同等看待了。</p>
<p>term2 -&gt; term3 term2Rest<br>
term2Rest -&gt; (&amp;&amp; | &gt; | + | * |&hellip;) term3 | ε</p>
<p>不过，这里面包含了多个优先级的运算符，却并没有拆成很多个级别，这是怎么实现的呢？</p>
<p>我们再来看看结合性。对于“2+3+4”这样一个表达式，我在第 3 讲，是把右递归调用转换成一个循环，让新建立的节点成为父节点，从而维护正确的结合性。</p>
<p>如果你阅读 term2Rest 的代码，就会发现它的处理逻辑跟第 3 讲是相同的，也就是说，它们都是用循环的方式，来处理连续加法或者连续乘法，并生成结合性正确的 AST。</p>
<p>不过，Java 编译器的算法更厉害。它不仅能用一个循环处理连续的加法和连续的乘法，对于“2+3*5”这样采用了多种不同优先级的操作符的表达式，也能通过一个循环就处理掉了，并且还保证了优先级的正确性。</p>
<p>在 term2Rest 中，可以使用多个优先级的操作符，从低到高的顺序如下：</p>
<p>&ldquo;||&rdquo;<br>
&ldquo;&amp;&amp;&rdquo;<br>
&ldquo;|&rdquo;<br>
&ldquo;^&rdquo;<br>
&ldquo;&amp;&rdquo;<br>
&ldquo;==&rdquo; | &ldquo;!=&rdquo;<br>
&ldquo;&lt;&rdquo; | &ldquo;&gt;&rdquo; | &ldquo;&lt;=&rdquo; | &ldquo;&gt;=&rdquo;<br>
&ldquo;&laquo;&rdquo; | &ldquo;&raquo;&rdquo; | &ldquo;&raquo;&gt;&rdquo;<br>
&ldquo;+&rdquo; | &ldquo;-&rdquo;<br>
&ldquo;*&rdquo; | &ldquo;/&rdquo; | &ldquo;%&rdquo;</p>
<p>如果按照常规的写法，我们处理上面 10 级优先级的操作符，需要写 10 级嵌套的结构。而 Java 用一级就解决了。这个秘密就在 term2Rest() 的实现中。我们以“<code>2*3+4*5</code>”为例分析一下。</p>
<p>term2Rest() 算法维护了一个操作数的栈（odStack）和操作符的栈（opStack），作为工作区。算法会根据 odStack、opStack 和后续操作符这三个信息，决定如何生成优先级正确的 AST。我把解析“<code>2*3+4*5</code>”时栈的变化，画成了一张图。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/0ffb804af6cfb20585be60c731917c12.png" alt=""></p>
<p>图 8：解析“2*3+4*5”的时候，odStack、opStack 和后续操作符的变化</p>
<p>在一步一步解析的过程中，当 opStack 的栈顶运算符的优先级大于等于后续运算符的优先级时，就会基于 odStack 栈顶的两个元素创建一棵二元表达式的子树，就像第 2 步那样。</p>
<p>反过来的话，栈顶运算符的优先级小于后续运算符的优先级（像第 4 步那样），就会继续把操作数和操作符入栈，而不是创建二元表达式。</p>
<p>这就可以保证，优先级高的操作符形成的子树，总会在最后的 AST 的下层，从而优先级更高。</p>
<p>再仔细研究一下这个算法，你会发现，它是借助一个工作区，自底向上地组装 AST。**是不是觉得很眼熟？是不是想到了 LR 算法？**没错，这就是一个简单 LR 算法。操作数栈和操作符栈是工作区，然后要向后预读一个运算符，决定是否做规约。只不过做规约的规则比较简单，依据相邻的操作符的优先级就可以了。</p>
<p>其实，这种处理表达式优先级的解析方法，有一个专有的名字，就叫做**“运算符优先级解析器（Operator-Precedence Parser）”**。Java 编译器用这一个算法处理了 10 个优先级的二元表达式的解析，同时又不用担心左递归问题，确实很棒！</p>
<h2 id="课程小结">课程小结</h2>
<p>本节课，我带你揭秘了 Java 编译器的一角，我想强调这样几个重点。</p>
<p>第一，你要大致熟悉一下 Java 语言中与编译有关的模块、包和类。这样，在你需要的时候，可以通过编程来调用编译器的功能，在运行时动态编译 Java 程序，并动态加载运行。</p>
<p>第二，Java 的词法分析总体上是遵循有限自动机的原理，但也引入了不少的灵活性。比如，在处理标识符和关键字的词法规则重叠的问题上，是先都作为标识符识别出来，然后再把其中的关键词挑出来。</p>
<p>第三，Java 的语法分析总体上是<strong>自顶向下</strong>的递归下降算法。在解决左递归问题时，也采用了标准的改写文法的方法。但是，在处理二元表达式时，局部采用了<strong>自底向上</strong>的<strong>运算符优先级解析器</strong>，使得算法更简洁。</p>
<p>当然了，我没有覆盖所有的词法解析和语法解析的细节。但你按照今天这一讲的分析思路，完全能看懂其他部分的代码。通过我帮你开的这个头，我期待你继续钻研下去，搞清楚 Java 的词法和语法解析功能的每个细节。</p>
<p>比如，递归下降算法中最重要的是要减少试错次数，一下子就能精准地知道应该采用哪个产生式。**而你通过阅读代码，会了解 Java 的编译器是如何解决这个问题的：**它在一些语法上会预读一个 Token，在另外的语法上会预读两个、三个 Token，以及加上一些与上下文有关的代码，通过种种方式来减少回溯，提高编译性能。这，实际上就是采用了 LL(k) 算法的思路，而 k 值是根据需要来增加的。</p>
<p>通过今天的分析，你会发现 Java 编译器在做词法和语法分析的时候，总体上遵循了编译原理中的知识点，比如构造有限自动机、改写左递归文法等等，但又巧妙地引入了不少的变化，包括解决词法规则冲突、融合了自顶向下算法和自底向上算法、根据情况灵活地预读 1 到多个 Token 等。我相信对你会大有启发！像这样的实战知识，恐怕只有分析实际编译器才能获得！更进一步地，你以后也可以用这样漂亮的方法解决问题。这就是对你这次探险的奖励。</p>
<p>我把这一讲的知识点用思维导图整理出来了，供你参考：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/958a7c0012c3ee9134ad5746ed49511e.png" alt=""></p>
<h2 id="一课一思">一课一思</h2>
<p>运算符优先级解析器非常实用，我们通过练习巩固一下对它的认识。你能推导一下解析“a&gt;b*2+3”的时候，odStack、opStack 和后续运算符都是什么吗？你也可以跟踪 Java 编译器的执行过程，验证一下你的推导结果。</p>
<p>你可以在留言区交一下作业。比如像这样：</p>
<p>step1: a<br>
step2: a,b  &gt;  *     //用逗号分隔栈里的多个元素<br>
&hellip;</p>
<p>我会在下一讲的留言区，通过置顶的方式公布标准答案。好了，这节课就到这里，感谢你的阅读，欢迎你把今天的内容分享给更多的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/">编译原理实战课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/09_cap%E5%AE%9A%E7%90%86%E4%B8%89%E9%80%89%E4%BA%8C%E6%9E%B6%E6%9E%84%E5%B8%88%E5%BF%85%E9%A1%BB%E5%AD%A6%E4%BC%9A%E7%9A%84%E5%8F%96%E8%88%8D/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">09_CAP定理：三选二，架构师必须学会的取舍</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%88%90%E4%B8%BAai%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/09_k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E5%BF%85%E5%AD%A6%E7%AE%97%E6%B3%95/">
            <span class="next-text nav-default">09_K近邻算法：机器学习入门必学算法</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
