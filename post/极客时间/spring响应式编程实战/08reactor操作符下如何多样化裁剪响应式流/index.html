<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>08Reactor操作符（下）：如何多样化裁剪响应式流？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="通过前两讲的内容可以知道，Reactor 框架为我们提供了各种操作符，使用这些操作符可以高效地操作 Flux 和 Mono 对象。Reactor 中的操作符可以分成不同的类型，上一讲我们关注转换、过滤和组合类的操作符，而今天我将继续为你介绍剩余的条件、裁剪、工具类的操作符。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/08reactor%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8B%E5%A6%82%E4%BD%95%E5%A4%9A%E6%A0%B7%E5%8C%96%E8%A3%81%E5%89%AA%E5%93%8D%E5%BA%94%E5%BC%8F%E6%B5%81/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/08reactor%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8B%E5%A6%82%E4%BD%95%E5%A4%9A%E6%A0%B7%E5%8C%96%E8%A3%81%E5%89%AA%E5%93%8D%E5%BA%94%E5%BC%8F%E6%B5%81/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="08Reactor操作符（下）：如何多样化裁剪响应式流？">
  <meta property="og:description" content="通过前两讲的内容可以知道，Reactor 框架为我们提供了各种操作符，使用这些操作符可以高效地操作 Flux 和 Mono 对象。Reactor 中的操作符可以分成不同的类型，上一讲我们关注转换、过滤和组合类的操作符，而今天我将继续为你介绍剩余的条件、裁剪、工具类的操作符。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Spring响应式编程实战">

  <meta itemprop="name" content="08Reactor操作符（下）：如何多样化裁剪响应式流？">
  <meta itemprop="description" content="通过前两讲的内容可以知道，Reactor 框架为我们提供了各种操作符，使用这些操作符可以高效地操作 Flux 和 Mono 对象。Reactor 中的操作符可以分成不同的类型，上一讲我们关注转换、过滤和组合类的操作符，而今天我将继续为你介绍剩余的条件、裁剪、工具类的操作符。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4421">
  <meta itemprop="keywords" content="Spring响应式编程实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="08Reactor操作符（下）：如何多样化裁剪响应式流？">
  <meta name="twitter:description" content="通过前两讲的内容可以知道，Reactor 框架为我们提供了各种操作符，使用这些操作符可以高效地操作 Flux 和 Mono 对象。Reactor 中的操作符可以分成不同的类型，上一讲我们关注转换、过滤和组合类的操作符，而今天我将继续为你介绍剩余的条件、裁剪、工具类的操作符。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">08Reactor操作符（下）：如何多样化裁剪响应式流？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4421 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>通过前两讲的内容可以知道，Reactor 框架为我们提供了各种操作符，使用这些操作符可以高效地操作 Flux 和 Mono 对象。Reactor 中的操作符可以分成不同的类型，上一讲我们关注转换、过滤和组合类的操作符，而今天我将继续为你介绍剩余的条件、裁剪、工具类的操作符。</p>
<p>条件操作符</p>
<p>所谓条件操作符，本质上就是提供了一个判断的依据来确定是否处理流中的元素。Reactor 中常用的条件操作符有 defaultIfEmpty、takeUntil、takeWhile、skipUntil 和 skipWhile 等，下面我将分别介绍。</p>
<p>defaultIfEmpty 操作符</p>
<p>defaultIfEmpty 操作符针对空数据流提供了一个简单而有用的处理方法。该操作符用来返回来自原始数据流的元素，如果原始数据流中没有元素，则返回一个默认元素。</p>
<p>defaultIfEmpty 操作符在实际开发过程中应用广泛，通常用在对方法返回值的处理上。如下所示的就是在 Controller 层中对 Service 层返回结果的一种常见处理方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@GetMapping(&#34;/orders/{id}&#34;)
</span></span><span class="line"><span class="cl">public Mono&lt;ResponseEntity&lt;Order&gt;&gt; findOrderById(@PathVariable 
</span></span><span class="line"><span class="cl">	String id) {
</span></span><span class="line"><span class="cl">     return orderService.findOrderById(id)
</span></span><span class="line"><span class="cl">         .map(ResponseEntity::ok)
</span></span><span class="line"><span class="cl">         .defaultIfEmpty(ResponseEntity
</span></span><span class="line"><span class="cl">	.status(404).body(null));
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，这里使用 defaultIfEmpty 操作符实现默认返回值。在示例代码所展示的 HTTP 端点中，当找不到指定的数据时，我们可以通过 defaultIfEmpty 方法返回一个空对象以及 404 状态码。</p>
<p>takeUntil/takeWhile 操作符</p>
<p>takeUntil 操作符的基本用法是 takeUntil (Predicate&lt;? super T&gt; predicate)，其中 Predicate 代表一种断言条件，该操作符将从数据流中提取元素直到断言条件返回 true。takeUntil 的示例代码如下所示，我们希望从一个包含 100 个连续元素的序列中获取 1~10 个元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Flux.range(1, 100).takeUntil(i -&gt; i == 10)
</span></span><span class="line"><span class="cl">	.subscribe(System.out::println);
</span></span></code></pre></td></tr></table>
</div>
</div><p>类似的，takeWhile 操作符的基本用法是 takeWhile (Predicate&lt;? super T&gt; continuePredicate)，其中 continuePredicate 代表的也是一种断言条件。与 takeUntil 不同的是，takeWhile 会在 continuePredicate 条件返回 true 时才进行元素的提取。takeWhile 的示例代码如下所示，这段代码的执行效果与 takeUntil 的示例代码一致。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Flux.range(1, 100).takeWhile(i -&gt; i &lt;= 10)
</span></span><span class="line"><span class="cl">	.subscribe(System.out::println);
</span></span></code></pre></td></tr></table>
</div>
</div><p>讲到这里，让我们回顾上一讲介绍的第一个转换操作符 buffer。事实上，Reactor 框架中同样也提供了 bufferUntil 和 bufferWhile 操作符来实现数据收集，这两个操作符用到了和 takeUntil/takeWhile 完全一样的断言机制，如下代码演示了 bufferUntil 的使用方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Flux.range(1, 10).bufferUntil(i -&gt; i % 2 == 0)
</span></span><span class="line"><span class="cl">	.subscribe(System.out::println);
</span></span></code></pre></td></tr></table>
</div>
</div><p>以上代码的执行结果如下所示，这里所设置的断言就是“i % 2 == 0”这一条件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[1, 2]
</span></span><span class="line"><span class="cl">[3, 4]
</span></span><span class="line"><span class="cl">[5, 6]
</span></span><span class="line"><span class="cl">[7, 8]
</span></span><span class="line"><span class="cl">[9, 10]
</span></span></code></pre></td></tr></table>
</div>
</div><p>对应的，bufferWhile 的使用方法和执行结果分别如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Flux.range(1, 10).bufferWhile(i -&gt; i % 2 == 0)
</span></span><span class="line"><span class="cl">	.subscribe(System.out::println);
</span></span></code></pre></td></tr></table>
</div>
</div><p>[2]
[4]
[6]
[8]
[10]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">skipUntil/skipWhile 操作符
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">与 takeUntil 相对应，skipUntil 操作符的基本用法是 skipUntil (Predicate&lt;? super T&gt; predicate)。skipUntil 将丢弃原始数据流中的元素直到 Predicate 返回 true。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">同样，与 takeWhile 相对应，skipWhile 操作符的基本用法是 skipWhile (Predicate&lt;? super T&gt; continuePredicate)，当 continuePredicate 返回 true 时才进行元素的丢弃。这两个操作符都很简单，就不具体展开讨论了。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">下面来说说裁剪操作符。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">裁剪操作符
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">裁剪操作符通常用于统计流中的元素数量，或者检查元素是否具有一定的属性。在 Reactor 中，常用的裁剪操作符有 any 、concat、count 和 reduce 等。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">any 操作符
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">any 操作符用于检查是否至少有一个元素具有所指定的属性，示例代码如下。
</span></span></code></pre></td></tr></table>
</div>
</div><p>Flux.just(3, 5, 7, 9, 11, 15, 16, 17)
        .any(e -&gt; e % 2 == 0)
        .subscribe(isExisted -&gt; System.out.println(isExisted));</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">在这个 Flux 流中存在一个元素 16 可以被 2 除尽，所以控制台将输出“true”。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">类似的，Reactor 中还存在一个 all 操作符，用来检查流中元素是否都满足同一属性，示例代码如下所示。
</span></span></code></pre></td></tr></table>
</div>
</div><p>Flux.just(&ldquo;abc&rdquo;, &ldquo;ela&rdquo;, &ldquo;ade&rdquo;, &ldquo;pqa&rdquo;, &ldquo;kang&rdquo;)
        .all(a -&gt; a.contains(&ldquo;a&rdquo;))
        .subscribe(isAllContained -&gt; System.out.println(isAllContained));</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">显然，在这个 Flux 流中所有元素都包含了字符“a”，所以控制台也将输出“true”。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">concat 操作符
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">concat 操作符用来合并来自不同 Flux 的数据。与上一讲中所介绍的 merge 操作符不同，这种合并采用的是顺序的方式，所以严格意义上并不是一种合并操作，所以我们把它归到裁剪操作符类别中。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">例如，如果执行下面这段代码，我们将在控制台中依次看到 1 到 10 这 10 个数字。
</span></span></code></pre></td></tr></table>
</div>
</div><p>Flux.concat(
            Flux.range(1, 3),
            Flux.range(4, 2),
            Flux.range(6, 5)
        ).subscribe(System.out::println);
};</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">reduce 操作符
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">裁剪操作符中最经典的就是这个 reduce 操作符。reduce 操作符对来自 Flux 序列中的所有元素进行累积操作并得到一个 Mono 序列，该 Mono 序列中包含了最终的计算结果。reduce 操作符示意图如下所示。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">reduce 操作符示意图（来自 Reactor 官网）
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">在上图中，具体的累积计算很简单，我们也可以通过一个 BiFunction 来实现任何自定义的复杂计算逻辑。reduce 操作符的示例代码如下所示，这里的 BiFunction 就是一个求和函数，用来对 1 到 10 的数字进行求和，运行结果为 55。
</span></span></code></pre></td></tr></table>
</div>
</div><p>Flux.range(1, 10).reduce((x, y) -&gt; x + y)
.subscribe(System.out::println);</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">与 reduce 操作符类似的还有一个 reduceWith 操作符，用来在 reduce 操作时指定一个初始值。reduceWith 操作符的代码示例如下所示，我们使用 5 来初始化求和过程，显然得到的结果将是 60。
</span></span></code></pre></td></tr></table>
</div>
</div><p>Flux.range(1, 10).reduceWith(() -&gt; 5, (x, y) -&gt; x + y)
.subscribe(System.out::println);</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">以上就是三种裁剪操作符的介绍，应该很好理解，下面我们来看看工具操作符。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">工具操作符
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Reactor 中常用的工具操作符有 subscribe、timeout、block、log 和 debug 等。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">subscribe 操作符
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">说起 subscribe 操作符，我已经在“06 | 流式操作：如何使用 Flux 和 Mono 高效构建响应式数据流”中讲到订阅响应式流时介绍过很多，这里再带你回顾一下通过该操作符订阅序列的最通用方式，如下所示。
</span></span></code></pre></td></tr></table>
</div>
</div><p>//订阅序列的最通用方式，可以为我们的Subscriber实现提供所需的任意行为
subscribe(Subscriber<T> subscriber);</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">基于这种方式，如果默认的 subscribe() 方法没有提供所需的功能，我们可以实现自己的 Subscriber。一般而言，我们总是可以直接实现响应式流规范所提供的 Subscriber 接口，并将其订阅到流。实现一个自定义的 Subscriber 并没有想象中那么困难，这里我给你演示一个简单的实现示例。
</span></span></code></pre></td></tr></table>
</div>
</div><p>Subscriber<String> subscriber = new Subscriber<String>() {
            volatile Subscription subscription;</p>
<p>            public void onSubscribe(Subscription s) {
                subscription = s;
                System.out.println(&ldquo;initialization&rdquo;);
                subscription.request(1);
            }</p>
<p>            public void onNext(String s) {
                System.out.println(&ldquo;onNext:&rdquo; + s);
                subscription.request(1);
            }</p>
<p>            public void onComplete() {
                System.out.println(&ldquo;onComplete&rdquo;);
            }</p>
<p>            public void onError(Throwable t) {
                System.out.println(&ldquo;onError:&rdquo; + t.getMessage());
            }
};</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">在这个自定义 Subscriber 实现中，我们首先持有对订阅令牌 Subscription 的引用。由于订阅和数据处理可能发生在不同的线程中，因此我们使用 volatile 关键字来确保所有线程都具有对 Subscription 实例的正确引用。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">当订阅到达时，我们会通过 onSubscribe 回调通知 Subscriber。在这里，我们保存订阅令牌并初始化请求。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">你应该注意到，在 onNext 回调中，我们打印接收到的数据并请求下一个元素。在这种情况下，我们执行 subscription.request(1) 方法，也就是说使用简单的拉模型来管理背压。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">剩下的 onComplete 和 onError 方法我们都只是打印了一下日志。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">现在，让我们通过 subscribe() 方法来使用这个 Subscriber，如下所示。
</span></span></code></pre></td></tr></table>
</div>
</div><p>Flux<String> flux = Flux.just(&ldquo;12&rdquo;, &ldquo;23&rdquo;, &ldquo;34&rdquo;);
        flux.subscribe(subscriber);</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">上述代码应该产生以下控制台输出的结果。
</span></span></code></pre></td></tr></table>
</div>
</div><p>initialization
onNext:12
onNext:23
onNext:34
onComplete</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">前面构建的自定义 Subscriber 虽然能够正常运作，但因为过于偏底层，因此并不推荐你使用。我们推荐的方法是扩展 Project Reactor 提供的 BaseSubscriber 类。在这种情况下，订阅者可能如下所示。
</span></span></code></pre></td></tr></table>
</div>
</div><p>class MySubscriber<T> extends BaseSubscriber<T> {
            public void hookOnSubscribe(Subscription subscription) {
                System.out.println(&ldquo;initialization&rdquo;);
                request(1);
            }
 
            public void hookOnNext(T value) {
                System.out.println(&ldquo;onNext:&rdquo; + value);
                request(1);
            }
}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">可以看到这里使用了两个钩子方法：hookOnSubscribe(Subscription) 和 hookOnNext(T)。和这两个方法一起，我们可以重载诸如 hookOnError(Throwable)、hookOnCancel()、hookOnComplete() 等方法。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">timeout 操作符
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">timeout 操作符非常简单，保持原始的流发布者，当特定时间段内没有产生任何事件时，将生成一个异常。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">block 操作符
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">顾名思义，block 操作符在接收到下一个元素之前会一直阻塞。block 操作符常用来把响应式数据流转换为传统数据流。例如，使用如下方法将分别把 Flux 数据流和 Mono 数据流转变成普通的 List
</span></span><span class="line"><span class="cl">&lt;Order&gt;
</span></span><span class="line"><span class="cl"> 对象和单个的 Order 对象，我们同样可以设置 block 操作的等待时间。
</span></span></code></pre></td></tr></table>
</div>
</div><p>public List<Order> getAllOrders() {
        return orderservice.getAllOrders()
.block(Duration.ofSecond(5));
}
 
public Order getOrderById(Long orderId) {
  return orderservice.getOrderById(orderId)
.block(Duration.ofSecond(2));
}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">log 操作符
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Reactor 中专门提供了针对日志的工具操作符 log，它会观察所有的数据并使用日志工具进行跟踪。我们可以通过如下代码演示 log 操作符的使用方法，在 Flux.just() 方法后直接添加 log() 函数。
</span></span></code></pre></td></tr></table>
</div>
</div><p>Flux.just(1, 2).log().subscribe(System.out::println);</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">以上代码的执行结果如下所示（为了显示简洁，部分内容和格式做了调整）。通常，我们也可以在 log() 方法中添加参数来指定日志分类的名称。
</span></span></code></pre></td></tr></table>
</div>
</div><p>Info: | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)
Info: | request(unbounded)
Info: | onNext(1)
1
Info: | onNext(2)
2
Info: | onComplete()</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">debug 操作符
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">在“01 | 追本溯源：响应式编程究竟是一种什么样的技术体系”中，我们已经提到基于回调和异步的实现方式比较难以调整。响应式编程也是一样，这也是它与传统编程方式之间一个很大的差异点。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">为此，Reactor 框架的设计者也考虑到了普通开发人员的诉求，并开发了专门用于 debug 的操作符。要想启动调试模式，我们需要在程序开始的地方添加如下代码。
</span></span></code></pre></td></tr></table>
</div>
</div><p>Hooks.onOperator(providedHook -&gt;
providedHook.operatorStacktrace())</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">现在，所有的操作符在执行时都会保存与执行过程相关的附加信息。而当系统出现异常时，这些附加信息就相当于系统异常堆栈信息的一部分，方便开发人员进行问题的分析和排查。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">上述做法是全局性的，如果你只想观察某个特定的流，那么就可以使用检查点（checkpoint）这一调试功能。例如以下代码演示了如何通过检查点来捕获 0 被用作除数的场景，我们在代码中添加了一个名为“debug”的检查点。
</span></span></code></pre></td></tr></table>
</div>
</div><p>Mono.just(0).map(x -&gt; 1 / x)
.checkpoint(&ldquo;debug&rdquo;).subscribe(System.out::println);</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">以上代码的执行结果如下所示。
</span></span></code></pre></td></tr></table>
</div>
</div><p>Exception in thread &ldquo;main&rdquo; reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.ArithmeticException: / by zero
Caused by: java.lang.ArithmeticException: / by zero
…
 
Assembly trace from producer [reactor.core.publisher.MonoMap] :
    reactor.core.publisher.Mono.map(Mono.java:2029)
    com.jianxiang.reactor.demo.Debug.main(Debug.java:10)
Error has been observed by the following operator(s):
    |_  Mono.map(Debug.java:10)
    |_  Mono.checkpoint(Debug.java:10)
 
    Suppressed: reactor.core.publisher.FluxOnAssembly$AssemblySnapshotException: zero
        at reactor.core.publisher.MonoOnAssembly.<init>(MonoOnAssembly.java:55)
        at reactor.core.publisher.Mono.checkpoint(Mono.java:1304)
        &hellip; 1 more</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">可以看到，这个检查点信息会包含在异常堆栈中。根据需要在系统的关键位置上添加自定义的检查点，也是我们日常开发过程中的一种最佳实践。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">小结与预告
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">好了，这一讲内容就介绍到这。承接上一讲的 Reactor 框架所提供的操作符，这一讲我分别就条件操作符、裁剪操作符以及各种工具操作符展开了详细的说明。在日常开发过程中，这些操作符都比较常见，能够加速我们开发响应式系统的开发过程。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这里依然给你留一道思考题：在 Reactor 中，如何自己实现一个 Subscriber？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">那么介绍完 Spring 内置的 Reactor 框架之后，从下一讲开始，我们要讨论在 Spring 中使用这一框架来实现响应式组件的具体过程，首先要说的就是全新的 WebFlux 组件。下一讲，我们将详细分析 WebFlux 与传统 WebMVC 之间的区别，希望会带给你新的思路，我们到时见。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">点击链接，获取课程相关代码↓↓↓https://github.com/lagoueduCol/ReactiveProgramming-jianxiang.git
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">\--- ### 精选评论 ##### \*\*风： &gt; 博主，能否帮助大家理解一下它的实现，因为如果只是说这些个api的使用的话，看看文档也就会了，个人觉得，reactiveStream难的是理解，不是这些api的使用。从一个简单的数据流开始，订阅，推，拉，背压，什么情况下切换了线程。 ######     讲师回复： &gt;     这门课还是比较面向入门的，通过案例来理解框架的应用方式，至于框架的实现原理规划上不会讲得太多 ##### \*\*敏： &gt; 这些调试手段，生产环境发布时，是不是就要去掉才好 ##### \*\*明： &gt; 老师的react是哪个版本的？我的只有Hooks.onOperatorDebug()方法，没有Hooks.onOperator，而且加了checkpoint后异常输出也没有具体发生在哪个操作符，我的是3.4.4版本的。reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.ArithmeticException: / by zeroCaused by: java.lang.ArithmeticException: / by zero at react.FluxDemo3.lambda$main$7(FluxDemo3.java:93) Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:Error has been observed at the following site(s): |\_ checkpoint ⇢ debugStack trace: at react.FluxDemo3.lambda$main$7(FluxDemo3.java:93) at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:113) ######     讲师回复： &gt;     我用的Spring Boot是2.1.13.RELEASE，对应的Reactor版本好像是3.3.X版本的
</span></span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/spring%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">Spring响应式编程实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90mybatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/08mapper%E6%96%87%E4%BB%B6%E4%B8%8Ejava%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BC%98%E9%9B%85%E6%98%A0%E5%B0%84%E4%B9%8B%E9%81%93/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">08Mapper文件与Java接口的优雅映射之道</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/0805%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8spark%E8%A7%A3%E5%86%B3%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/">
            <span class="next-text nav-default">0805｜特征处理如何利用Spark解决特征处理问题</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
