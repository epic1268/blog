<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>02__App_启动速度怎么做优化与监控？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是戴铭。
我已经在专栏的第一篇文章中，和你梳理了一份 iOS 开发的知识体系框架图。今天，我们就正式从基础出发，开始自己的 iOS 开发知识体系构建之路吧。接下来，我就先和你聊聊与 App 启动速度密切相关的那些事儿。希望你听我说完启动速度的事儿之后，在专栏里的学习状态也能够快速地启动起来。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/ios%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/02__app_%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E6%80%8E%E4%B9%88%E5%81%9A%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%91%E6%8E%A7/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/ios%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/02__app_%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E6%80%8E%E4%B9%88%E5%81%9A%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%91%E6%8E%A7/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="02__App_启动速度怎么做优化与监控？">
  <meta property="og:description" content="你好，我是戴铭。
我已经在专栏的第一篇文章中，和你梳理了一份 iOS 开发的知识体系框架图。今天，我们就正式从基础出发，开始自己的 iOS 开发知识体系构建之路吧。接下来，我就先和你聊聊与 App 启动速度密切相关的那些事儿。希望你听我说完启动速度的事儿之后，在专栏里的学习状态也能够快速地启动起来。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="IOS开发高手课">

  <meta itemprop="name" content="02__App_启动速度怎么做优化与监控？">
  <meta itemprop="description" content="你好，我是戴铭。
我已经在专栏的第一篇文章中，和你梳理了一份 iOS 开发的知识体系框架图。今天，我们就正式从基础出发，开始自己的 iOS 开发知识体系构建之路吧。接下来，我就先和你聊聊与 App 启动速度密切相关的那些事儿。希望你听我说完启动速度的事儿之后，在专栏里的学习状态也能够快速地启动起来。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7330">
  <meta itemprop="keywords" content="IOS开发高手课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="02__App_启动速度怎么做优化与监控？">
  <meta name="twitter:description" content="你好，我是戴铭。
我已经在专栏的第一篇文章中，和你梳理了一份 iOS 开发的知识体系框架图。今天，我们就正式从基础出发，开始自己的 iOS 开发知识体系构建之路吧。接下来，我就先和你聊聊与 App 启动速度密切相关的那些事儿。希望你听我说完启动速度的事儿之后，在专栏里的学习状态也能够快速地启动起来。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">02__App_启动速度怎么做优化与监控？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7330 字 </span>
          <span class="more-meta"> 预计阅读 15 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#app-启动时都干了些什么事儿">App 启动时都干了些什么事儿？</a>
          <ul>
            <li><a href="#main-函数执行前">main() 函数执行前</a></li>
            <li><a href="#main-函数执行后">main() 函数执行后</a></li>
            <li><a href="#首屏渲染完成后">首屏渲染完成后</a></li>
          </ul>
        </li>
        <li><a href="#功能级别的启动优化">功能级别的启动优化</a></li>
        <li><a href="#方法级别的启动优化">方法级别的启动优化</a></li>
        <li><a href="#如何做一个方法级别启动耗时检查工具来辅助分析和监控">如何做一个方法级别启动耗时检查工具来辅助分析和监控？</a></li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#课后作业">课后作业</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是戴铭。</p>
<p>我已经在专栏的第一篇文章中，和你梳理了一份 iOS 开发的知识体系框架图。今天，我们就正式从基础出发，开始自己的 iOS 开发知识体系构建之路吧。接下来，我就先和你聊聊与 App 启动速度密切相关的那些事儿。希望你听我说完启动速度的事儿之后，在专栏里的学习状态也能够快速地启动起来。</p>
<p>在文章开始前，我们先设想这么一个场景：假设你在排队结账时，掏出手机打开 App 甲准备扫码支付，结果半天进不去，后面排队的人给你压力够大吧。然后，你又打开 App 乙，秒进，支付完成。试想一下，以后再支付时你会选择哪个 App 呢。</p>
<p>不难想象，在提供的功能和服务相似的情况下，一款 App 的启动速度，不单单是用户体验的事情，往往还决定了它能否获取更多的用户。这就好像陌生人第一次碰面，第一感觉往往决定了他们接下来是否会继续交往。</p>
<p>由此可见，启动速度的优化必然就是 App 开发过程中，不可或缺的一个环节。接下来，我就先和你一起分析下 App 在启动时都做了哪些事儿。</p>
<h2 id="app-启动时都干了些什么事儿">App 启动时都干了些什么事儿？</h2>
<p>一般情况下，App 的启动分为冷启动和热启动。</p>
<ul>
<li>冷启动是指，App 点击启动前，它的进程不在系统里，需要系统新创建一个进程分配给它启动的情况。这是一次完整的启动过程。</li>
<li>热启动是指，App 在冷启动后用户将 App 退后台，在 App 的进程还在系统里的情况下，用户重新启动进入 App 的过程，这个过程做的事情非常少。</li>
</ul>
<p>所以，今天这篇文章，我们就只展开讲 App 冷启动的优化。</p>
<p>用户能感知到的启动慢，其实都发生在主线程上。而主线程慢的原因有很多，比如在主线程上执行了大文件读写操作、在渲染周期中执行了大量计算等。但是，有时你会发现即使你把首屏显示之前的这些主线程的耗时问题都解决了，还是比竞品启动得慢。</p>
<p>那么，<strong>究竟如何才能把启动时的所有耗时都找出来呢？解决这个问题，你首先需要弄清楚 App 在启动时都干了哪些事儿。</strong></p>
<p>一般而言，App 的启动时间，指的是从用户点击 App 开始，到用户看到第一个界面之间的时间。总结来说，App 的启动主要包括三个阶段：</p>
<ol>
<li>main() 函数执行前；</li>
<li>main() 函数执行后；</li>
<li>首屏渲染完成后。</li>
</ol>
<p>整个启动过程的示意图，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/1d35110c1f5b0d13794a4b455e4ae411.png" alt=""></p>
<p>图 1 App 的整个启动过程</p>
<h3 id="main-函数执行前">main() 函数执行前</h3>
<p>在 main() 函数执行前，系统主要会做下面几件事情：</p>
<ul>
<li>加载可执行文件（App 的.o 文件的集合）；</li>
<li>加载动态链接库，进行 rebase 指针调整和 bind 符号绑定；</li>
<li>Objc 运行时的初始处理，包括 Objc 相关类的注册、category 注册、selector 唯一性检查等；</li>
<li>初始化，包括了执行 +load() 方法、attribute((constructor)) 修饰的函数的调用、创建 C++ 静态全局变量。</li>
</ul>
<p>相应地，这个阶段对于启动速度优化来说，可以做的事情包括：</p>
<ul>
<li>减少动态库加载。每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，苹果公司最多可以支持 6 个非系统动态库合并为一个。</li>
<li>减少加载启动后不会去使用的类或者方法。</li>
<li>+load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 方法替换掉。因为，在一个 +load() 方法里，进行运行时方法替换操作会带来 4 毫秒的消耗。不要小看这 4 毫秒，积少成多，执行 +load() 方法对启动速度的影响会越来越大。</li>
<li>控制 C++ 全局变量的数量。</li>
</ul>
<h3 id="main-函数执行后">main() 函数执行后</h3>
<p>main() 函数执行后的阶段，指的是从 main() 函数执行开始，到 appDelegate 的 didFinishLaunchingWithOptions 方法里首屏渲染相关方法执行完成。</p>
<p>首页的业务代码都是要在这个阶段，也就是首屏渲染前执行的，主要包括了：</p>
<ul>
<li>首屏初始化所需配置文件的读写操作；</li>
<li>首屏列表大数据的读取；</li>
<li>首屏渲染的大量计算等。</li>
</ul>
<p>很多时候，开发者会把各种初始化工作都放到这个阶段执行，导致渲染完成滞后。<strong>更加优化的开发方式，应该是</strong>从功能上梳理出哪些是首屏渲染必要的初始化功能，哪些是 App 启动必要的初始化功能，而哪些是只需要在对应功能开始使用时才需要初始化的。梳理完之后，将这些初始化功能分别放到合适的阶段进行。</p>
<h3 id="首屏渲染完成后">首屏渲染完成后</h3>
<p>首屏渲染后的这个阶段，主要完成的是，非首屏其他业务服务模块的初始化、监听的注册、配置文件的读取等。从函数上来看，这个阶段指的就是截止到 didFinishLaunchingWithOptions 方法作用域内执行首屏渲染之后的所有方法执行完成。简单说的话，这个阶段就是从渲染完成时开始，到 didFinishLaunchingWithOptions 方法作用域结束时结束。</p>
<p>这个阶段用户已经能够看到 App 的首页信息了，所以优化的优先级排在最后。但是，那些会卡住主线程的方法还是需要最优先处理的，不然还是会影响到用户后面的交互操作。</p>
<p>明白了 App 启动阶段需要完成的工作后，我们就可以有的放矢地进行启动速度的优化了。这些优化，包括了功能级别和方法级别的启动优化。接下来，我们就从这两个角度展开看看。</p>
<h2 id="功能级别的启动优化">功能级别的启动优化</h2>
<p>我想，你所在的团队一定面临过启动阶段的代码功能堆积、无规范、难维护的问题吧。在 App 项目开发初期，开发人员不多、代码量也没那么大时，这种情况比较少见。但到了后期，App 业务规模扩大，团队人员水平参差不齐，各种代码问题就会爆发出来，终归需要来次全面治理。</p>
<p>而全面治理过程中的手段、方法和碰到的问题，对于后面的规范制定以及启动速度监控都有着重要的意义。那么，我们要怎样从功能级别来进行全面的启动优化治理呢？</p>
<p>功能级别的启动优化，就是要从 main() 函数执行后这个阶段下手。</p>
<p>优化的思路是：main() 函数开始执行后到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/c24723e0bd96dcfb237b9bc3fbe59c0a.png" alt=""></p>
<p>图 2 功能级别的启动优化示意图</p>
<h2 id="方法级别的启动优化">方法级别的启动优化</h2>
<p>经过功能级别的启动优化，也就是将非首屏业务所需的功能滞后以后，从用户点击 App 到看到首屏的时间将会有很大程度的缩短，也就达到了优化 App 启动速度的目的。</p>
<p>在这之后，我们需要进一步做的，是检查首屏渲染完成前主线程上有哪些耗时方法，将没必要的耗时方法滞后或者异步执行。通常情况下，耗时较长的方法主要发生在计算大量数据的情况下，具体的表现就是加载、编辑、存储图片和文件等资源。</p>
<p>那么，你觉得<strong>是不是只需要优化对资源的操作就可以了呢？</strong></p>
<p>当然不是。就像 +load() 方法，一个耗时 4 毫秒，100 个就是 400 毫秒，这种耗时用户也是能明显感知到的。</p>
<p>比如，我以前使用的 ReactiveCocoa 框架（这是一个 iOS 上的响应式编程框架），每创建一个信号都有 6 毫秒的耗时。这样，稍不注意各种信号的创建就都被放在了首屏渲染完成前，进而导致 App 的启动速度大幅变慢。</p>
<p>类似这样单个方法耗时不多，但是由于堆积导致 App 启动速度大幅变慢的方法数不胜数。所以，你需要一个能够对启动方法耗时进行全面、精确检查的手段。</p>
<p>那么问题来了，有哪些监控手段？这些监控手段各有什么优缺点？你又该如何选择呢？</p>
<p>目前来看，对 App 启动速度的监控，主要有两种手段。</p>
<p><strong>第一种方法是，定时抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时</strong>。Xcode 工具套件里自带的 Time Profiler，采用的就是这种方式。</p>
<p>这种方式的优点是，开发类似工具成本不高，能够快速开发后集成到你的 App 中，以便在真实环境中进行检查。</p>
<p>说到定时抓取，就会涉及到定时间隔的长短问题。</p>
<ul>
<li>定时间隔设置得长了，会漏掉一些方法，从而导致检查出来的耗时不精确；</li>
<li>而定时间隔设置得短了，抓取堆栈这个方法本身调用过多也会影响整体耗时，导致结果不准确。</li>
</ul>
<p>这个定时间隔如果小于所有方法执行的时间（比如 0.002 秒），那么基本就能监控到所有方法。但这样做的话，整体的耗时时间就不够准确。一般将这个定时间隔设置为 0.01 秒。这样设置，对整体耗时的影响小，不过很多方法耗时就不精确了。但因为整体耗时的数据更加重要些，单个方法耗时精度不高也是可以接受的，所以这个设置也是没问题的。</p>
<p>总结来说，定时抓取主线程调用栈的方式虽然精准度不够高，但也是够用的。</p>
<p><strong>第二种方法是，对 objc_msgSend 方法进行 hook 来掌握所有方法的执行耗时。</strong></p>
<p>hook 方法的意思是，在原方法开始执行时换成执行其他你指定的方法，或者在原有方法执行前后执行你指定的方法，来达到掌握和改变指定方法的目的。</p>
<p>hook objc_msgSend 这种方式的优点是非常精确，而缺点是只能针对 Objective-C 的方法。当然，对于 c 方法和 block 也不是没有办法，你可以使用 libffi 的 ffi_call 来达成 hook，但缺点就是编写维护相关工具门槛高。</p>
<p>关于，libffi 相关的内容，我会在后面的第 35 篇文章“libffi：动态调用和定义 C 函数”里和你详细说明。</p>
<p>综上，如果对于检查结果精准度要求高的话，我比较推荐你使用 hook objc_msgSend 方式来检查启动方法的执行耗时。</p>
<h2 id="如何做一个方法级别启动耗时检查工具来辅助分析和监控">如何做一个方法级别启动耗时检查工具来辅助分析和监控？</h2>
<p>使用 hook objc_msgSend 方式来检查启动方法的执行耗时时，我们需要实现一个称手的启动时间检查工具。那么，我们应该如何实现这个工具呢？</p>
<p>现在，我就一步一步地和你说说具体怎么做。</p>
<p>首先，你要了解<strong>为什么 hook 了 objc_msgSend 方法，就可以 hook 全部 Objective-C 的方法？</strong></p>
<p>Objective-C 里每个对象都会指向一个类，每个类都会有一个方法列表，方法列表里的每个方法都是由 selector、函数指针和 metadata 组成的。</p>
<p>objc_msgSend 方法干的活儿，就是在运行时根据对象和方法的 selector 去找到对应的函数指针，然后执行。也就是说，objc_msgSend 是 Objective-C 里方法执行的必经之路，能够控制所有的 Objective-C 的方法。</p>
<p>objc_msgSend 本身是用汇编语言写的，这样做的原因主要有两个：</p>
<ul>
<li>一个原因是，objc_msgSend 的调用频次最高，在它上面进行的性能优化能够提升整个 App 生命周期的性能。而汇编语言在性能优化上属于原子级优化，能够把优化做到极致。所以，这种投入产出比无疑是最大的。</li>
<li>另一个原因是，其他语言难以实现未知参数跳转到任意函数指针的功能。</li>
</ul>
<p>现在，苹果公司已经开源了 Objective-C 的运行时代码。你可以在<a href="./Messengers.subproj.md">苹果公司的开源网站</a>，找到 objc_msgSend 的源码。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/eb0e22c195235df497e7698edc504569.png" alt=""></p>
<p>图 3 objc_msgSend 全架构实现源代码文件列表</p>
<p>上图列出的是所有架构的实现，包括 x86_64 等。objc_msgSend 是 iOS 方式执行最核心的部分，编程领域的宝藏，值得你深入探究和细细品味。</p>
<p>objc_msgSend 方法执行的逻辑是：先获取对象对应类的信息，再获取方法的缓存，根据方法的 selector 查找函数指针，经过异常错误处理后，最后跳到对应函数的实现。</p>
<p>按照这个逻辑去看源码会更加清晰，更容易注意到实现细节。阅读 objc_msgSend 源码是编写方法级耗时工具的一个必要的环节，后面还需要编写一些对应的汇编代码。</p>
<p><strong>接下来，我们再看看怎么 hook objc_msgSend 方法？</strong></p>
<p>Facebook 开源了一个库，可以在 iOS 上运行的 Mach-O 二进制文件中动态地重新绑定符号，这个库叫 fishhook。你可以在 GitHub 上，查看<a href="./fishhook.md">fishhook 的代码</a>。</p>
<p>fishhook 实现的大致思路是，通过重新绑定符号，可以实现对 c 方法的 hook。dyld 是通过更新 Mach-O 二进制的 __DATA segment 特定的部分中的指针来绑定 lazy 和 non-lazy 符号，通过确认传递给 rebind_symbol 里每个符号名称更新的位置，就可以找出对应替换来重新绑定这些符号。</p>
<p>下面，我针对 fishhook 里的关键代码，和你具体说下 fishhook 的实现原理。</p>
<p><strong>首先</strong>，遍历 dyld 里的所有 image，取出 image header 和 slide。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if (!_rebindings_head-&gt;next) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    _dyld_register_func_for_add_image(_rebind_symbols_for_image);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    uint32_t c = _dyld_image_count();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 遍历所有 image
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (uint32_t i = 0; i &lt; c; i++) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 读取 image header 和 slider
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>接下来</strong>，找到符号表相关的 command，包括 linkedit segment command、symtab command 和 dysymtab command。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">segment_command_t *cur_seg_cmd;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">segment_command_t *linkedit_segment = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct symtab_command* symtab_cmd = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct dysymtab_command* dysymtab_cmd = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cur_seg_cmd = (segment_command_t *)cur;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == 0) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            // linkedit segment command
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            linkedit_segment = cur_seg_cmd;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    } else if (cur_seg_cmd-&gt;cmd == LC_SYMTAB) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // symtab command
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        symtab_cmd = (struct symtab_command*)cur_seg_cmd;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    } else if (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // dysymtab command
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>**然后，**获得 base 和 indirect 符号表。实现代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 找到 base 符号表的地址
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">char *strtab = (char *)(linkedit_base + symtab_cmd-&gt;stroff);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 找到 indirect 符号表
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);
</span></span></code></pre></td></tr></table>
</div>
</div><p>**最后，**有了符号表和传入的方法替换数组，就可以进行符号表访问指针地址的替换了，具体实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">uint32_t *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section-&gt;addr);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">for (uint i = 0; i &lt; section-&gt;size / sizeof(void *); i++) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    uint32_t symtab_index = indirect_symbol_indices[i];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        continue;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    char *symbol_name = strtab + strtab_offset;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (strnlen(symbol_name, 2) &lt; 2) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        continue;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct rebindings_entry *cur = rebindings;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while (cur) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        for (uint j = 0; j &lt; cur-&gt;rebindings_nel; j++) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            if (strcmp(&amp;symbol_name[1], cur-&gt;rebindings[j].name) == 0) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // 符号表访问指针地址的替换
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                goto symbol_loop;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        cur = cur-&gt;next;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">symbol_loop:;
</span></span></code></pre></td></tr></table>
</div>
</div><p>以上，就是 fishhook 的实现原理了。fishhook 是对底层的操作，其中查找符号表的过程和堆栈符号化实现原理基本类似，了解了其中原理对于理解可执行文件 Mach-O 内部结构会有很大的帮助。</p>
<p>接下来，我们再看一个问题：<strong>只靠 fishhook 就能够搞定 objc_msgSend 的 hook 了吗？</strong></p>
<p>当然还不够。我前面也说了，objc_msgSend 是用汇编语言实现的，所以我们还需要从汇编层面多加点料。</p>
<p>你需要先实现两个方法 pushCallRecord 和 popCallRecord，来分别记录 objc_msgSend 方法调用前后的时间，然后相减就能够得到方法的执行耗时。</p>
<p>下面我针对 arm64 架构，编写一个可保留未知参数并跳转到 c 中任意函数指针的汇编代码，实现对 objc_msgSend 的 Hook。</p>
<p>arm64 有 31 个 64 bit 的整数型寄存器，分别用 x0 到 x30 表示。主要的实现思路是：</p>
<ol>
<li>入栈参数，参数寄存器是 x0~ x7。对于 objc_msgSend 方法来说，x0 第一个参数是传入对象，x1 第二个参数是选择器 _cmd。syscall 的 number 会放到 x8 里。</li>
<li>交换寄存器中保存的参数，将用于返回的寄存器 lr 中的数据移到 x1 里。</li>
<li>使用 bl label 语法调用 pushCallRecord 函数。</li>
<li>执行原始的 objc_msgSend，保存返回值。</li>
<li>使用 bl label 语法调用 popCallRecord 函数。</li>
</ol>
<p>具体的汇编代码，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static void replacementObjc_msgSend() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  __asm__ volatile (
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // sp 是堆栈寄存器，存放栈的偏移地址，每次都指向栈顶。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 保存 {q0-q7} 偏移地址到 sp 寄存器
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp q6, q7, [sp, #-32]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp q4, q5, [sp, #-32]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp q2, q3, [sp, #-32]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp q0, q1, [sp, #-32]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 保存 {x0-x8, lr}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp x8, lr, [sp, #-16]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp x6, x7, [sp, #-16]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp x4, x5, [sp, #-16]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp x2, x3, [sp, #-16]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp x0, x1, [sp, #-16]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 交换参数.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;mov x2, x1\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;mov x1, lr\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;mov x3, sp\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 调用 preObjc_msgSend，使用 bl label 语法。bl 执行一个分支链接操作，label 是无条件分支的，是和本指令的地址偏移，范围是 -128MB 到 +128MB
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;bl __Z15preObjc_msgSendP11objc_objectmP13objc_selectorP9RegState_\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;mov x9, x0\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;mov x10, x1\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;tst x10, x10\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 读取 {x0-x8, lr} 从保存到 sp 栈顶的偏移地址读起
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp x0, x1, [sp], #16\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp x2, x3, [sp], #16\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp x4, x5, [sp], #16\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp x6, x7, [sp], #16\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp x8, lr, [sp], #16\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 读取 {q0-q7}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp q0, q1, [sp], #32\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp q2, q3, [sp], #32\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp q4, q5, [sp], #32\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp q6, q7, [sp], #32\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;b.eq Lpassthrough\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 调用原始 objc_msgSend。使用 blr xn 语法。blr 除了从指定寄存器读取新的 PC 值外效果和 bl 一样。xn 是通用寄存器的 64 位名称分支地址，范围是 0 到 31
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;blr x9\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 保存 {x0-x9}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp x0, x1, [sp, #-16]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp x2, x3, [sp, #-16]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp x4, x5, [sp, #-16]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp x6, x7, [sp, #-16]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp x8, x9, [sp, #-16]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 保存 {q0-q7}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp q0, q1, [sp, #-32]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp q2, q3, [sp, #-32]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp q4, q5, [sp, #-32]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;stp q6, q7, [sp, #-32]!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 调用 postObjc_msgSend hook.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;bl __Z16postObjc_msgSendv\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;mov lr, x0\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 读取 {q0-q7}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp q6, q7, [sp], #32\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp q4, q5, [sp], #32\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp q2, q3, [sp], #32\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp q0, q1, [sp], #32\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 读取 {x0-x9}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp x8, x9, [sp], #16\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp x6, x7, [sp], #16\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp x4, x5, [sp], #16\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp x2, x3, [sp], #16\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ldp x0, x1, [sp], #16\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;ret\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;Lpassthrough:\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // br 无条件分支到寄存器中的地址
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      &#34;br x9&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    );
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在，你就可以得到每个 Objective-C 方法的耗时了。接下来，我们再看看<strong>怎样才能够做到像下图那样记录和展示方法调用的层级关系和顺序呢？</strong></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/7b362d113908ccf45b221ce82d7ae3c4.png" alt=""></p>
<p>图 4 方法调用层级和顺序</p>
<p>不要着急，我来一步一步地跟你说。</p>
<p>**第一步，**设计两个结构体：CallRecord 记录调用方法详细信息，包括 obj 和 SEL 等；ThreadCallStack 里面，需要用 index 记录当前调用方法树的深度。</p>
<p>有了 SEL 再通过 NSStringFromSelector 就能够取得方法名，有了 obj 通过 object_getClass 能够得到 Class，再用 NSStringFromClass 就能够获得类名。结构的完整代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// Shared structures.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">typedef struct CallRecord_ {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  id obj;   // 通过 object_getClass 能够得到 Class 再通过 NSStringFromClass 能够得到类名
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  SEL _cmd; // 通过 NSStringFromSelector 方法能够得到方法名
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  uintptr_t lr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  int prevHitIndex;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  char isWatchHit;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} CallRecord;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">typedef struct ThreadCallStack_ {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  FILE *file;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  char *spacesStr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  CallRecord *stack;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  int allocatedLength;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  int index; //index 记录当前调用方法树的深度
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  int numWatchHits;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  int lastPrintedIndex;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  int lastHitIndex;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  char isLoggingEnabled;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  char isCompleteLoggingEnabled;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} ThreadCallStack;
</span></span></code></pre></td></tr></table>
</div>
</div><p>**第二步，**pthread_setspecific() 可以将私有数据设置在指定线程上，pthread_getspecific() 用来读取这个私有数据。利用这个特性，我们就可以将 ThreadCallStack 的数据和该线程绑定在一起，随时进行数据存取。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static inline ThreadCallStack * getThreadCallStack() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ThreadCallStack *cs = (ThreadCallStack *)pthread_getspecific(threadKey); // 读取
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  if (cs == NULL) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cs = (ThreadCallStack *)malloc(sizeof(ThreadCallStack));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#ifdef MAIN_THREAD_ONLY
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cs-&gt;file = (pthread_main_np()) ? newFileForThread() : NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#else
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cs-&gt;file = newFileForThread();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#endif
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cs-&gt;isLoggingEnabled = (cs-&gt;file != NULL);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cs-&gt;isCompleteLoggingEnabled = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cs-&gt;spacesStr = (char *)malloc(DEFAULT_CALLSTACK_DEPTH + 1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    memset(cs-&gt;spacesStr, &#39; &#39;, DEFAULT_CALLSTACK_DEPTH);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cs-&gt;spacesStr[DEFAULT_CALLSTACK_DEPTH] = &#39;\0&#39;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cs-&gt;stack = (CallRecord *)calloc(DEFAULT_CALLSTACK_DEPTH, sizeof(CallRecord)); // 分配 CallRecord 默认空间
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cs-&gt;allocatedLength = DEFAULT_CALLSTACK_DEPTH;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cs-&gt;index = cs-&gt;lastPrintedIndex = cs-&gt;lastHitIndex = -1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cs-&gt;numWatchHits = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    pthread_setspecific(threadKey, cs); // 保存数据
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  return cs;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>**第三步，**因为要记录深度，而一个方法的调用里会有更多的方法调用，所以我们可以在方法的调用里增加两个方法 pushCallRecord 和 popCallRecord，分别记录方法调用的开始时间和结束时间，这样才能够在开始时对深度加一、在结束时减一。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 开始时
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static inline void pushCallRecord(id obj, uintptr_t lr, SEL _cmd, ThreadCallStack *cs) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  int nextIndex = (++cs-&gt;index); // 增加深度
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  if (nextIndex &gt;= cs-&gt;allocatedLength) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cs-&gt;allocatedLength += CALLSTACK_DEPTH_INCREMENT;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cs-&gt;stack = (CallRecord *)realloc(cs-&gt;stack, cs-&gt;allocatedLength * sizeof(CallRecord));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cs-&gt;spacesStr = (char *)realloc(cs-&gt;spacesStr, cs-&gt;allocatedLength + 1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    memset(cs-&gt;spacesStr, &#39; &#39;, cs-&gt;allocatedLength);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cs-&gt;spacesStr[cs-&gt;allocatedLength] = &#39;\0&#39;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  CallRecord *newRecord = &amp;cs-&gt;stack[nextIndex];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  newRecord-&gt;obj = obj;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  newRecord-&gt;_cmd = _cmd;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  newRecord-&gt;lr = lr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  newRecord-&gt;isWatchHit = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 结束时
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static inline CallRecord * popCallRecord(ThreadCallStack *cs) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  return &amp;cs-&gt;stack[cs-&gt;index--]; // 减少深度
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>耗时检查的完整代码，你可以在<a href="./GCDFetchFeed.md">我的开源项目</a>里查看。在需要检测耗时时间的地方调用 [SMCallTrace start]，结束时调用 stop 和 save 就可以打印出方法的调用层级和耗时了。你还可以设置最大深度和最小耗时检测，来过滤不需要看到的信息。</p>
<p>有了这样一个检查方法耗时的工具，你就可以在每个版本开发结束后执行一次检查，统计总耗时以及启动阶段每个方法的耗时，有针对性地观察启动速度慢的问题。如果你在线上做个灰度开关，还可以监控线上启动慢的一些特殊情况。</p>
<h2 id="小结">小结</h2>
<p>启动速度优化和监控的重要性不言而喻，加快 App 的启动速度对用户的体验提升是最大的。</p>
<p>启动速度的优化也有粗有细：粗上来讲，这需要对启动阶段功能进行分类整理，合理地将和首屏无关的功能滞后，放到首屏渲染完成之后，保证大头儿没有问题；细的来讲，这就需要些匠人精神，使用合适的工具，针对每个方法进行逐个分析、优化，每个阶段都做到极致。</p>
<h2 id="课后作业">课后作业</h2>
<p>按照今天文中提到的 Time Profiler 工具检查方法耗时的原理，你来动手实现一个方法耗时检查工具吧。</p>
<p>感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎把它分享给更多的朋友一起阅读。</p>
<p>最近，我收到一些同学的反馈，说这门课的一些内容比较深，一时难以琢磨透。如果你也有这样的感受，推荐你学习极客时间刚刚上新的另一门视频课程：由腾讯高级工程师朱德权，主讲的《从 0 开发一款 iOS App》。</p>
<p>朱德权老师将会基于最新技术，从实践出发，手把手带你构建类今日头条的 App。要知道，那些很牛的 iOS 开发者，往往都具备独立开发一款 App 的能力。</p>
<p>这门课正在上新优惠，欢迎点击<a href="./169_utm%5Fterm=zeusKHUZ0&amp;utm%5Fsource=app&amp;utm%5Fmedium=geektime&amp;utm%5Fcampaign=169-presell&amp;utm%5Fcontent=daiming.md">这里</a>试看。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/0e2ff493da248888e66ed0aa4e0251a2.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/ios%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/">iOS开发高手课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/01%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">01追本溯源：响应式编程究竟是一种什么样的技术体系？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%9C%B1%E8%B5%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E8%AF%BE/02__bug%E5%BC%95%E5%8F%91%E4%BA%8B%E6%95%85%E8%AF%A5%E4%B8%8D%E8%AF%A5%E8%BF%BD%E7%A9%B6%E8%B4%A3%E4%BB%BB/">
            <span class="next-text nav-default">02__Bug引发事故，该不该追究责任？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
