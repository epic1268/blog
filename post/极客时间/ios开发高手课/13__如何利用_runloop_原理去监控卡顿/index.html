<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>13__如何利用_RunLoop_原理去监控卡顿？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是戴铭。今天，我来和你说说如何监控卡顿。
卡顿问题，就是在主线程上无法响应用户交互的问题。如果一个 App 时不时地就给你卡一下，有时还长时间无响应，这时你还愿意继续用它吗？所以说，卡顿问题对 App 的伤害是巨大的，也是我们必须要重点解决的一个问题。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/ios%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/13__%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8_runloop_%E5%8E%9F%E7%90%86%E5%8E%BB%E7%9B%91%E6%8E%A7%E5%8D%A1%E9%A1%BF/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/ios%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/13__%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8_runloop_%E5%8E%9F%E7%90%86%E5%8E%BB%E7%9B%91%E6%8E%A7%E5%8D%A1%E9%A1%BF/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="13__如何利用_RunLoop_原理去监控卡顿？">
  <meta property="og:description" content="你好，我是戴铭。今天，我来和你说说如何监控卡顿。
卡顿问题，就是在主线程上无法响应用户交互的问题。如果一个 App 时不时地就给你卡一下，有时还长时间无响应，这时你还愿意继续用它吗？所以说，卡顿问题对 App 的伤害是巨大的，也是我们必须要重点解决的一个问题。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="IOS开发高手课">

  <meta itemprop="name" content="13__如何利用_RunLoop_原理去监控卡顿？">
  <meta itemprop="description" content="你好，我是戴铭。今天，我来和你说说如何监控卡顿。
卡顿问题，就是在主线程上无法响应用户交互的问题。如果一个 App 时不时地就给你卡一下，有时还长时间无响应，这时你还愿意继续用它吗？所以说，卡顿问题对 App 的伤害是巨大的，也是我们必须要重点解决的一个问题。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4429">
  <meta itemprop="keywords" content="IOS开发高手课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="13__如何利用_RunLoop_原理去监控卡顿？">
  <meta name="twitter:description" content="你好，我是戴铭。今天，我来和你说说如何监控卡顿。
卡顿问题，就是在主线程上无法响应用户交互的问题。如果一个 App 时不时地就给你卡一下，有时还长时间无响应，这时你还愿意继续用它吗？所以说，卡顿问题对 App 的伤害是巨大的，也是我们必须要重点解决的一个问题。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">13__如何利用_RunLoop_原理去监控卡顿？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4429 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#runloop-原理">RunLoop 原理</a>
          <ul>
            <li><a href="#第一步">第一步</a></li>
            <li><a href="#第二步">第二步</a></li>
            <li><a href="#第三步">第三步</a></li>
            <li><a href="#第四步">第四步</a></li>
            <li><a href="#第五步">第五步</a></li>
            <li><a href="#第六步">第六步</a></li>
            <li><a href="#第七步">第七步</a></li>
            <li><a href="#loop-的六个状态">loop 的六个状态</a></li>
          </ul>
        </li>
        <li><a href="#如何检查卡顿">如何检查卡顿？</a></li>
        <li><a href="#如何获取卡顿的方法堆栈信息">如何获取卡顿的方法堆栈信息？</a></li>
        <li><a href="#小结">小结</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是戴铭。今天，我来和你说说如何监控卡顿。</p>
<p>卡顿问题，就是在主线程上无法响应用户交互的问题。如果一个 App 时不时地就给你卡一下，有时还长时间无响应，这时你还愿意继续用它吗？所以说，卡顿问题对 App 的伤害是巨大的，也是我们必须要重点解决的一个问题。</p>
<p>现在，我们先来看一下导致卡顿问题的几种原因：</p>
<ul>
<li>复杂 UI、图文混排的绘制量过大；</li>
<li>在主线程上做网络同步请求；</li>
<li>在主线程做大量的 IO 操作；</li>
<li>运算量过大，CPU 持续高占用；</li>
<li>死锁和主子线程抢锁。</li>
</ul>
<p>那么，我们如何监控到什么时候会出现卡顿呢？是要监视 FPS 吗？</p>
<p>以前，我特别喜欢一本叫作《24 格》的杂志，它主要介绍的是动画片制作的相关内容。那么，它为啥叫 24 格呢？这是因为，动画片中 1 秒钟会用到 24 张图片，这样肉眼看起来就是流畅的。</p>
<p>FPS 是一秒显示的帧数，也就是一秒内画面变化数量。如果按照动画片来说，动画片的 FPS 就是 24，是达不到 60 满帧的。也就是说，对于动画片来说，24 帧时虽然没有 60 帧时流畅，但也已经是连贯的了，所以并不能说 24 帧时就算是卡住了。</p>
<p>由此可见，简单地通过监视 FPS 是很难确定是否会出现卡顿问题了，所以我就果断弃了通过监视 FPS 来监控卡顿的方案。</p>
<p>那么，我们到底应该使用什么方案来监控卡顿呢？</p>
<h2 id="runloop-原理">RunLoop 原理</h2>
<p>对于 iOS 开发来说，监控卡顿就是要去找到主线程上都做了哪些事儿。我们都知道，线程的消息事件是依赖于 NSRunLoop 的，所以从 NSRunLoop 入手，就可以知道主线程上都调用了哪些方法。我们通过监听 NSRunLoop 的状态，就能够发现调用方法是否执行时间过长，从而判断出是否会出现卡顿。</p>
<p>所以，我推荐的监控卡顿的方案是：通过监控 RunLoop 的状态来判断是否会出现卡顿。</p>
<p>RunLoop 是 iOS 开发中的一个基础概念，为了帮助你理解并用好这个对象，接下来我会先和你介绍一下它可以做哪些事儿，以及它为什么可以做成这些事儿。</p>
<p>RunLoop 这个对象，在 iOS 里由 CFRunLoop 实现。简单来说，RunLoop 是用来监听输入源，进行调度处理的。这里的输入源可以是输入设备、网络、周期性或者延迟时间、异步回调。RunLoop 会接收两种类型的输入源：一种是来自另一个线程或者来自不同应用的异步消息；另一种是来自预订时间或者重复间隔的同步事件。</p>
<p>RunLoop 的目的是，当有事件要去处理时保持线程忙，当没有事件要处理时让线程进入休眠。所以，了解 RunLoop 原理不光能够运用到监控卡顿上，还可以提高用户的交互体验。通过将那些繁重而不紧急会大量占用 CPU 的任务（比如图片加载），放到空闲的 RunLoop 模式里执行，就可以避开在 UITrackingRunLoopMode 这个 RunLoop 模式时是执行。UITrackingRunLoopMode 是用户进行滚动操作时会切换到的 RunLoop 模式，避免在这个 RunLoop 模式执行繁重的 CPU 任务，就能避免影响用户交互操作上体验。</p>
<p>接下来，我就通过 CFRunLoop 的源码来跟你分享下 RunLoop 的原理吧。</p>
<h3 id="第一步">第一步</h3>
<p>通知 observers：RunLoop 要开始进入 loop 了。紧接着就进入 loop。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 通知 observers
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 进入 loop
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="第二步">第二步</h3>
<p>开启一个 do while 来保活线程。通知 Observers：RunLoop 会触发 Timer 回调、Source0 回调，接着执行加入的 block。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 通知 Observers RunLoop 会触发 Timer 回调
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 通知 Observers RunLoop 会触发 Source0 回调
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeSources)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 执行 block
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">__CFRunLoopDoBlocks(runloop, currentMode);
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，触发 Source0 回调，如果有 Source1 是 ready 状态的话，就会跳转到 handle_msg 去处理消息。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if (MACH_PORT_NULL != dispatchPort ) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (hasMsg) goto handle_msg;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="第三步">第三步</h3>
<p>回调触发后，通知 Observers：RunLoop 的线程将进入休眠（sleep）状态。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if (!poll &amp;&amp; (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="第四步">第四步</h3>
<p>进入休眠后，会等待 mach_port 的消息，以再次唤醒。只有在下面四个事件出现时才会被再次唤醒：</p>
<ul>
<li>基于 port 的 Source 事件；</li>
<li>Timer 时间到；</li>
<li>RunLoop 超时；</li>
<li>被调用者唤醒。</li>
</ul>
<p>等待唤醒的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">do {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 基于 port 的 Source 事件、调用者唤醒
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // Timer 时间到、RunLoop 超时
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (currentMode-&gt;_timerFired) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} while (1);
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="第五步">第五步</h3>
<p>唤醒时通知 Observer：RunLoop 的线程刚刚被唤醒了。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if (!poll &amp;&amp; (currentMode-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="第六步">第六步</h3>
<p>RunLoop 被唤醒后就要开始处理消息了：</p>
<ul>
<li>如果是 Timer 时间到的话，就触发 Timer 的回调；</li>
<li>如果是 dispatch 的话，就执行 block；</li>
<li>如果是 source1 事件的话，就处理这个事件。</li>
</ul>
<p>消息执行完后，就执行加到 loop 里的 block。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">handle_msg:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 如果 Timer 时间到，就触发 Timer 回调
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if (msg-is-timer) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 如果 dispatch 就执行 block
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">else if (msg_is_dispatch) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // Source1 事件的话，就处理这个事件
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (sourceHandledThisLoop) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        mach_msg(reply, MACH_SEND_MSG, reply);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="第七步">第七步</h3>
<p>根据当前 RunLoop 的状态来判断是否需要走下一个 loop。当被外部强制停止或 loop 超时时，就不继续下一个 loop 了，否则继续走下一个 loop。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     // 事件已处理完
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    retVal = kCFRunLoopRunHandledSource;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} else if (timeout) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 超时
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    retVal = kCFRunLoopRunTimedOut;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} else if (__CFRunLoopIsStopped(runloop)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 外部调用者强制停止
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    retVal = kCFRunLoopRunStopped;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // mode 为空，RunLoop 结束
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    retVal = kCFRunLoopRunFinished;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>整个 RunLoop 过程，我们可以总结为如下所示的一张图片。<br>
<img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/44e7e7a15b5e0cd293567f92e82f2994.png" alt=""></p>
<p>这里只列出了 CFRunLoop 的关键代码，你可以点击<a href="./CFRunLoop.c.auto.md">这个链接</a>查看完整代码。</p>
<h3 id="loop-的六个状态">loop 的六个状态</h3>
<p>通过对 RunLoop 原理的分析，我们可以看出在整个过程中，loop 的状态包括 6 个，其代码定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    kCFRunLoopEntry , // 进入 loop
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    kCFRunLoopBeforeTimers , // 触发 Timer 回调
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    kCFRunLoopBeforeSources , // 触发 Source0 回调
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    kCFRunLoopBeforeWaiting , // 等待 mach_port 消息
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    kCFRunLoopAfterWaiting ), // 接收 mach_port 消息
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    kCFRunLoopExit , // 退出 loop
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    kCFRunLoopAllActivities  // loop 所有状态改变
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果 RunLoop 的线程，进入睡眠前方法的执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步的话，就可以认为是线程受阻了。如果这个线程是主线程的话，表现出来的就是出现了卡顿。</p>
<p>所以，如果我们要利用 RunLoop 原理来监控卡顿的话，就是要关注这两个阶段。RunLoop 在进入睡眠之前和唤醒后的两个 loop 状态定义的值，分别是 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting，也就是要触发 Source0 回调和接收 mach_port 消息两个状态。</p>
<p>接下来，我们就一起分析一下，如何对 loop 的这两个状态进行监听，以及监控的时间值如何设置才合理。</p>
<h2 id="如何检查卡顿">如何检查卡顿？</h2>
<p>要想监听 RunLoop，你就首先需要创建一个 CFRunLoopObserverContext 观察者，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">runLoopObserver = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities,YES,0,&amp;runLoopObserverCallBack,&amp;context);
</span></span></code></pre></td></tr></table>
</div>
</div><p>将创建好的观察者 runLoopObserver 添加到主线程 RunLoop 的 common 模式下观察。然后，创建一个持续的子线程专门用来监控主线程的 RunLoop 状态。</p>
<p>一旦发现进入睡眠前的 kCFRunLoopBeforeSources 状态，或者唤醒后的状态 kCFRunLoopAfterWaiting，在设置的时间阈值内一直没有变化，即可判定为卡顿。接下来，我们就可以 dump 出堆栈的信息，从而进一步分析出具体是哪个方法的执行时间过长。</p>
<p>开启一个子线程监控的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 创建子线程监控
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 子线程开启一个持续的 loop 用来进行监控
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while (YES) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        long semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (semaphoreWait != 0) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            if (!runLoopObserver) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                timeoutCount = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                dispatchSemaphore = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                runLoopActivity = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                return;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            //BeforeSources 和 AfterWaiting 这两个状态能够检测到是否卡顿
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            if (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // 将堆栈信息上报服务器的代码放到这里
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            } //end activity
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }// end semaphore wait
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        timeoutCount = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }// end while
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">});
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码中的 NSEC_PER_SEC，代表的是触发卡顿的时间阈值，单位是秒。可以看到，我们把这个阈值设置成了 3 秒。那么，这个 3 秒的阈值是从何而来呢？这样设置合理吗？</p>
<p>其实，触发卡顿的时间阈值，我们可以根据 WatchDog 机制来设置。WatchDog 在不同状态下设置的不同时间，如下所示：</p>
<ul>
<li>启动（Launch）：20s；</li>
<li>恢复（Resume）：10s；</li>
<li>挂起（Suspend）：10s；</li>
<li>退出（Quit）：6s；</li>
<li>后台（Background）：3min（在 iOS 7 之前，每次申请 10min；之后改为每次申请 3min，可连续申请，最多申请到 10min）。</li>
</ul>
<p>通过 WatchDog 设置的时间，我认为可以把启动的阈值设置为 10 秒，其他状态则都默认设置为 3 秒。总的原则就是，要小于 WatchDog 的限制时间。当然了，这个阈值也不用小得太多，原则就是要优先解决用户感知最明显的体验问题。</p>
<h2 id="如何获取卡顿的方法堆栈信息">如何获取卡顿的方法堆栈信息？</h2>
<p>子线程监控发现卡顿后，还需要记录当前出现卡顿的方法堆栈信息，并适时推送到服务端供开发者分析，从而解决卡顿问题。那么，在这个过程中，如何获取卡顿的方法堆栈信息呢？</p>
<p>**获取堆栈信息的一种方法是直接调用系统函数。**这种方法的优点在于，性能消耗小。但是，它只能够获取简单的信息，也没有办法配合 dSYM 来获取具体是哪行代码出了问题，而且能够获取的信息类型也有限。这种方法，因为性能比较好，所以适用于观察大盘统计卡顿情况，而不是想要找到卡顿原因的场景。</p>
<p>直接调用系统函数方法的主要思路是：用 signal 进行错误信息的获取。具体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="ne">int</span> <span class="n">s_fatal_signals</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">SIGABRT</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">SIGBUS</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">SIGFPE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">SIGILL</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">SIGSEGV</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">SIGTRAP</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">SIGTERM</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">SIGKILL</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">static</span> <span class="ne">int</span> <span class="n">s_fatal_signal_num</span> <span class="o">=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">s_fatal_signals</span><span class="p">)</span> <span class="o">/</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">s_fatal_signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="n">void</span> <span class="n">UncaughtExceptionHandler</span><span class="p">(</span><span class="n">NSException</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">NSArray</span> <span class="o">*</span><span class="n">exceptionArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">exception</span> <span class="n">callStackSymbols</span><span class="p">];</span> <span class="o">//</span> <span class="err">得到当前调用栈信息</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">NSString</span> <span class="o">*</span><span class="n">exceptionReason</span> <span class="o">=</span> <span class="p">[</span><span class="n">exception</span> <span class="n">reason</span><span class="p">];</span>       <span class="o">//</span> <span class="err">非常重要，就是崩溃的原因</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">NSString</span> <span class="o">*</span><span class="n">exceptionName</span> <span class="o">=</span> <span class="p">[</span><span class="n">exception</span> <span class="n">name</span><span class="p">];</span>           <span class="o">//</span> <span class="err">异常类型</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="n">void</span> <span class="n">SignalHandler</span><span class="p">(</span><span class="ne">int</span> <span class="n">code</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s2">&#34;signal handler = </span><span class="si">%d</span><span class="s2">&#34;</span><span class="p">,</span><span class="n">code</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="n">void</span> <span class="n">InitCrashReport</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">系统错误信号捕获</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="ne">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s_fatal_signal_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">signal</span><span class="p">(</span><span class="n">s_fatal_signals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">SignalHandler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">//</span><span class="n">oc</span> <span class="err">未捕获异常的捕获</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">NSSetUncaughtExceptionHandler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">UncaughtExceptionHandler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="ne">int</span> <span class="n">main</span><span class="p">(</span><span class="ne">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="err">@</span><span class="n">autoreleasepool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">InitCrashReport</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">UIApplicationMain</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">nil</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">AppDelegate</span> <span class="k">class</span><span class="p">]));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>另一种方法是，直接用</strong> <a href="./browse.md"><strong>PLCrashReporter</strong></a>**这个开源的第三方库来获取堆栈信息。**这种方法的特点是，能够定位到问题代码的具体位置，而且性能消耗也不大。所以，也是我推荐的获取堆栈信息的方法。</p>
<p>具体如何使用 PLCrashReporter 来获取堆栈信息，代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 获取数据
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NSData *lagData = [[[PLCrashReporter alloc]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                          initWithConfiguration:[[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll]] generateLiveReport];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 转换成 PLCrashReport 对象
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PLCrashReport *lagReport = [[PLCrashReport alloc] initWithData:lagData error:NULL];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 进行字符串格式化处理
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NSString *lagReportString = [PLCrashReportTextFormatter stringValueForCrashReport:lagReport withTextFormat:PLCrashReportTextFormatiOS];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 将字符串上传服务器
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NSLog(@&#34;lag happen, detail below: \n %@&#34;,lagReportString);
</span></span></code></pre></td></tr></table>
</div>
</div><p>搜集到卡顿的方法堆栈信息以后，就是由开发者来分析并解决卡顿问题了。</p>
<p>在今天这篇文章中，我们用到的从监控卡顿到收集卡顿问题信息的完整代码，你都可以点击<a href="./SMLagMonitor.m.md">这个链接</a>查看。</p>
<h2 id="小结">小结</h2>
<p>今天我给你介绍了使用 RunLoop 监控卡顿的方案，我还跟你说了下 RunLoop 的原理，希望能够帮助你更好地理解 RunLoop 监控卡顿的方案。</p>
<p>读到这里你可能会想，为什么要将卡顿监控放到线上做呢？其实这样做主要是为了能够更大范围的收集问题，如果仅仅通过线下收集卡顿的话，场景无法被全面覆盖。因为，总有一些卡顿问题，是由于少数用户的数据异常导致的。</p>
<p>而用户反馈的卡顿问题往往都是说在哪个页面卡住了，而具体是执行哪个方法时卡主了，我们是无从得知的。在碰到这样问题时，你一定会感觉手足无措，心中反问一百遍：“我怎么在这个页面不卡，测试也不卡，就你卡”。而且，通过日志我们也很难查出个端倪。这时候，线上监控卡顿的重要性就凸显出来了。</p>
<p>有时，某个问题看似对 App 的影响不大，但如果这个问题在某个版本中爆发出来了就会变得难以收场。所以，你需要对这样的问题进行有预见性的监控，一方面可以早发现、早解决，另一方面在遇到问题时能够快速定位原因，不至于过于被动。要知道，面对问题的响应速度往往是评判基础建设优劣的一个重要的标准。</p>
<p>以上就是我们今天的内容了。接下来，我想请你回顾一下你都碰到过哪些卡顿问题，又是如何解决的呢？</p>
<p>感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎把它分享给更多的朋友一起阅读。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/0e2ff493da248888e66ed0aa4e0251a2.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/ios%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/">iOS开发高手课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/13__%E5%A6%82%E4%BD%95%E7%BB%99%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E6%A1%88%E6%B7%BB%E5%8A%A0%E7%BA%B9%E7%90%86%E5%92%8C%E5%A4%8D%E6%9D%82%E6%BB%A4%E9%95%9C/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">13__如何给简单的图案添加纹理和复杂滤镜？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%87%8D%E5%AD%A6%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/13__%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%9C%89%E9%99%90%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%E5%8A%A0%E6%8C%81%E7%9A%84%E5%B8%8C%E5%B0%94%E5%AF%86%E7%A0%81%E6%8F%90%E9%AB%98%E5%AF%86%E7%A0%81%E8%A2%AB%E7%A0%B4%E8%AF%91%E7%9A%84%E9%9A%BE%E5%BA%A6/">
            <span class="next-text nav-default">13__如何通过有限向量空间加持的希尔密码，提高密码被破译的难度？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
