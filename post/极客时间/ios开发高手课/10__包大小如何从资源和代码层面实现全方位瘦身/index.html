<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>10__包大小：如何从资源和代码层面实现全方位瘦身？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是戴铭。今天我来跟你说下如何对 App 包大小做优化。
对 App 包大小做优化的目的，就是节省用户流量，提高用户下载速度。当初，我在主持滴滴客户端的瘦身时，就是奔着对包大小进行最大化优化的目标，3 个月内将包大小从 106MB 降到了最低 64MB，半年内稳定在了 70MB。当时业务还没有停，从 106MB 降到 64MB 的这 3 个月里如履薄冰，不同团队各显神威，几乎用到了所有手段，也做了很多创新，最终达成了目标。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/ios%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/10__%E5%8C%85%E5%A4%A7%E5%B0%8F%E5%A6%82%E4%BD%95%E4%BB%8E%E8%B5%84%E6%BA%90%E5%92%8C%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E5%AE%9E%E7%8E%B0%E5%85%A8%E6%96%B9%E4%BD%8D%E7%98%A6%E8%BA%AB/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/ios%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/10__%E5%8C%85%E5%A4%A7%E5%B0%8F%E5%A6%82%E4%BD%95%E4%BB%8E%E8%B5%84%E6%BA%90%E5%92%8C%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E5%AE%9E%E7%8E%B0%E5%85%A8%E6%96%B9%E4%BD%8D%E7%98%A6%E8%BA%AB/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="10__包大小：如何从资源和代码层面实现全方位瘦身？">
  <meta property="og:description" content="你好，我是戴铭。今天我来跟你说下如何对 App 包大小做优化。
对 App 包大小做优化的目的，就是节省用户流量，提高用户下载速度。当初，我在主持滴滴客户端的瘦身时，就是奔着对包大小进行最大化优化的目标，3 个月内将包大小从 106MB 降到了最低 64MB，半年内稳定在了 70MB。当时业务还没有停，从 106MB 降到 64MB 的这 3 个月里如履薄冰，不同团队各显神威，几乎用到了所有手段，也做了很多创新，最终达成了目标。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="IOS开发高手课">

  <meta itemprop="name" content="10__包大小：如何从资源和代码层面实现全方位瘦身？">
  <meta itemprop="description" content="你好，我是戴铭。今天我来跟你说下如何对 App 包大小做优化。
对 App 包大小做优化的目的，就是节省用户流量，提高用户下载速度。当初，我在主持滴滴客户端的瘦身时，就是奔着对包大小进行最大化优化的目标，3 个月内将包大小从 106MB 降到了最低 64MB，半年内稳定在了 70MB。当时业务还没有停，从 106MB 降到 64MB 的这 3 个月里如履薄冰，不同团队各显神威，几乎用到了所有手段，也做了很多创新，最终达成了目标。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6810">
  <meta itemprop="keywords" content="IOS开发高手课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="10__包大小：如何从资源和代码层面实现全方位瘦身？">
  <meta name="twitter:description" content="你好，我是戴铭。今天我来跟你说下如何对 App 包大小做优化。
对 App 包大小做优化的目的，就是节省用户流量，提高用户下载速度。当初，我在主持滴滴客户端的瘦身时，就是奔着对包大小进行最大化优化的目标，3 个月内将包大小从 106MB 降到了最低 64MB，半年内稳定在了 70MB。当时业务还没有停，从 106MB 降到 64MB 的这 3 个月里如履薄冰，不同团队各显神威，几乎用到了所有手段，也做了很多创新，最终达成了目标。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">10__包大小：如何从资源和代码层面实现全方位瘦身？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6810 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#官方-app-thinning">官方 App Thinning</a></li>
        <li><a href="#无用图片资源">无用图片资源</a></li>
        <li><a href="#图片资源压缩">图片资源压缩</a></li>
        <li><a href="#代码瘦身">代码瘦身</a>
          <ul>
            <li><a href="#linkmap-结合-mach-o-找无用代码">LinkMap 结合 Mach-O 找无用代码</a></li>
            <li><a href="#通过-appcode-找出无用代码">通过 AppCode 找出无用代码</a></li>
            <li><a href="#运行时检查类是否真正被使用过">运行时检查类是否真正被使用过</a></li>
          </ul>
        </li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#课后小作业">课后小作业</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是戴铭。今天我来跟你说下如何对 App 包大小做优化。</p>
<p>对 App 包大小做优化的目的，就是节省用户流量，提高用户下载速度。当初，我在主持滴滴客户端的瘦身时，就是奔着对包大小进行最大化优化的目标，3 个月内将包大小从 106MB 降到了最低 64MB，半年内稳定在了 70MB。当时业务还没有停，从 106MB 降到 64MB 的这 3 个月里如履薄冰，不同团队各显神威，几乎用到了所有手段，也做了很多创新，最终达成了目标。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/597a2ea077ab48223405d7162c525f11.png" alt=""></p>
<p>图 1 瘦身背景</p>
<p>上图就是当时主流 App 的大小，可以看到最大的百度和淘宝，分别是 131MB 和 115MB，滴滴是 106MB，最小的是微信 87MB。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/62e97e76baf16ab55224723f986608f5.png" alt=""></p>
<p>图 2 主流 App 安装包半年内的大小变化</p>
<p>可以看到，经过半年的时间，除了滴滴外每个 App 的安装包都增大了不少，先前最小的微信也从 87MB 增加到了 116MB。</p>
<p>相信你的团队也曾遇到过或正在经历着对包大小进行优化的任务，特别是 App Store 规定了安装包大小超过 150MB 的 App 不能使用 OTA（over-the-air）环境下载，也就是只能在 WiFi 环境下下载。所以，150MB 就成了 App 的生死线，一旦超越了这条线就很有可能会失去大量用户。</p>
<p>如果你的 App 要再兼容 iOS7 和 iOS8 的话，苹果<a href="./app-store-connect.md#/dev611e0a21f">官方还规定</a>主二进制 text 段的大小不能超过 60MB。如果没有达到这个标准，你甚至都没法提交 App Store。</p>
<p>而实际情况是，业务复杂的 App 轻轻松松就超过了 60MB。虽然我们可以通过静态库转动态库的方式来快速避免这个限制，但是静态库转动态库后，动态库的大小差不多会增加一倍，这样 150MB 的限制就更难守住。</p>
<p>另外，App 包体积过大，对用户更新升级率也会有很大影响。</p>
<p>综上所述，App 包过大既损害用户体验，影响升级率，还会导致无法提交 App Store 的情况和非 WiFi 环境无法下载这样可能影响到 App 生死的问题。那么，怎样对包大小进行瘦身和控制包大小的不合理增长就成了重中之重。</p>
<p>接下来，我就把我用过的包大小瘦身方法一个个地都说给你听。</p>
<h2 id="官方-app-thinning">官方 App Thinning</h2>
<p>App Thinning 是由苹果公司推出的一项可以改善 App 下载进程的新技术，主要是为了解决用户下载 App 耗费过高流量的问题，同时还可以节省用户 iOS 设备的存储空间。</p>
<p>现在的 iOS 设备屏幕尺寸、分辨率越来越多样化，这样也就需要更多资源来匹配不同的尺寸和分辨率。同时，App 也会有 32 位、64 位不同芯片架构的优化版本。如果这些都在一个包里，那么用户下载包的大小势必就会变大。</p>
<p>App Thinning 会专门针对不同的设备来选择只适用于当前设备的内容以供下载。比如，iPhone 6 只会下载 2x 分辨率的图片资源，iPhone 6plus 则只会下载 3x 分辨率的图片资源。</p>
<p>在苹果公司使用 App Thinning 之前，每个 App 包会包含多个芯片的指令集架构文件。以 Reveal.framework 为例，使用 du 命令查看到主文件在 Reveal.framework/Versions/A 目录下，大小有 21MB。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ming$ du -h Reveal.framework/*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  0B  Reveal.framework/Headers
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  0B  Reveal.framework/Reveal
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 16K  Reveal.framework/Versions/A/Headers
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 21M  Reveal.framework/Versions/A
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 21M  Reveal.framework/Versions
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，我们可以再使用 file 命令，查看 Version 目录下的 Reveal 文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ming$ file Reveal.framework/Versions/A/Reveal 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Reveal.framework/Versions/A/Reveal: Mach-O universal binary with 5 architectures: [i386:current ar archive] [arm64]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Reveal.framework/Versions/A/Reveal (for architecture i386): current ar archive
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Reveal.framework/Versions/A/Reveal (for architecture armv7):  current ar archive
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Reveal.framework/Versions/A/Reveal (for architecture armv7s): current ar archive
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Reveal.framework/Versions/A/Reveal (for architecture x86_64): current ar archive
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Reveal.framework/Versions/A/Reveal (for architecture arm64):  current ar archive
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，Reveal 文件里还有 5 个文件：</p>
<ul>
<li>x86_64 和 i386，是用于模拟器的芯片指令集架构文件；</li>
<li>arm64、armv7、armv7s，是真机的芯片指令集架构文件。</li>
</ul>
<p>下图来自<a href="./iossupportmatrix.com.md">iOS Support Matrix</a>，列出来的是历来各个 iOS 设备的指令集详细矩阵分布。从中，我们可以一窥所有设备的芯片指令集以及支持的最高和最低 iOS 版本。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/d438749bc365205aeeb1d46d53f1efe7.png" alt=""></p>
<p>图 3 各个 iOS 设备的指令集详细矩阵分布</p>
<p>使用 App Thinning 后，用户下载时就只会下载一个适合自己设备的芯片指令集架构文件。</p>
<p>App Thinning 有三种方式，包括：App Slicing、Bitcode、On-Demand Resources。</p>
<ul>
<li>App Slicing，会在你向 iTunes Connect 上传 App 后，对 App 做切割，创建不同的变体，这样就可以适用到不同的设备。</li>
<li>On-Demand Resources，主要是为游戏多关卡场景服务的。它会根据用户的关卡进度下载随后几个关卡的资源，并且已经过关的资源也会被删掉，这样就可以减少初装 App 的包大小。</li>
<li>Bitcode，是针对特定设备进行包大小优化，优化不明显。</li>
</ul>
<p>那么，如何在你项目里使用 App Thinning 呢？</p>
<p>其实，这里的大部分工作都是由 Xcode 和 App Store 来帮你完成的，你只需要通过 Xcode 添加 xcassets 目录，然后将图片添加进来即可。</p>
<p>首先，新建一个文件选择 Asset Catalog 模板，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/ccf8f166468456510aaa0b4195177b4d.png" alt=""></p>
<p>图 4 选择使用 Asset Catalog 模板</p>
<p>然后，按照 Asset Catalog 的模板添加图片资源即可，添加的 2x 分辨率的图片和 3x 分辨率的图片，会在上传到 App Store 后被创建成不同的变体以减小 App 安装包的大小。而芯片指令集架构文件只需要按照默认的设置，App Store 就会根据设备创建不同的变体，每个变体里只有当前设备需要的那个芯片指令集架构文件。</p>
<p>使用 App Thining 后，你可以将 2x 图和 3x 图区分开，从而达到减小 App 安装包体积的目的。如果我们要进一步减小 App 包体积的话，还需要在图片和代码上继续做优化。接下来，我就跟你说说，为了减小 App 安装包的体积，我们还能在图片上做些什么？</p>
<h2 id="无用图片资源">无用图片资源</h2>
<p>图片资源的优化空间，主要体现在删除无用图片和图片资源压缩这两方面。而删除无用图片，又是其中最容易、最应该先做的。像代码瘦身这样难啃的骨头，我们就留在后面吧。那么，我们是如何找到并删除这些无用图片资源的呢？</p>
<p>删除无用图片的过程，可以概括为下面这 6 大步。</p>
<ol>
<li>通过 find 命令获取 App 安装包中的所有资源文件，比如 find /Users/daiming/Project/ -name。</li>
<li>设置用到的资源的类型，比如 jpg、gif、png、webp。</li>
<li>使用正则匹配在源码中找出使用到的资源名，比如 pattern = @&quot;@&quot;(.+?)&quot;&quot;。</li>
<li>使用 find 命令找到的所有资源文件，再去掉代码中使用到的资源文件，剩下的就是无用资源了。</li>
<li>对于按照规则设置的资源名，我们需要在匹配使用资源的正则表达式里添加相应的规则，比如 @“image_%d”。</li>
<li>确认无用资源后，就可以对这些无用资源执行删除操作了。这个删除操作，你可以使用 NSFileManger 系统类提供的功能来完成。</li>
</ol>
<p>整个过程如下图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/d3570d0ce08969c02d69f8138fd7fc2a.png" alt=""></p>
<p>图 5 删除无用图片资源的过程</p>
<p>如果你不想自己重新写一个工具的话，可以选择开源的工具直接使用。我觉得目前最好用的是 <a href="./LSUnusedResources.md">LSUnusedResources</a>，特别是对于使用编号规则的图片来说，可以通过直接添加规则来处理。使用方式也很简单，你可以参看下面的动画演示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/398bd21355334ac4f6dd1a94bebb53e3.png" alt=""></p>
<p>图 6 LSUnusedResources 使用示例</p>
<h2 id="图片资源压缩">图片资源压缩</h2>
<p>无用图片资源处理完了，那么有用的图片还有瘦身的空间吗？</p>
<p>答案是有的。</p>
<p>对于 App 来说，图片资源总会在安装包里占个大头儿。对它们最好的处理，就是在不损失图片质量的前提下尽可能地作压缩。目前比较好的压缩方案是，将图片转成 WebP。<a href="./webp.md">WebP</a> 是 Google 公司的一个开源项目。</p>
<p>首先，我们一起看看<strong>选择 WebP 的理由</strong>：</p>
<ul>
<li>WebP 压缩率高，而且肉眼看不出差异，同时支持有损和无损两种压缩模式。比如，将 Gif 图转为 Animated WebP，有损压缩模式下可减少 64% 大小，无损压缩模式下可减少 19% 大小。</li>
<li>WebP 支持 Alpha 透明和 24-bit 颜色数，不会像 PNG8 那样因为色彩不够而出现毛边。</li>
</ul>
<p>接下来，我们再看看<strong>怎么把图片转成 WebP</strong>？</p>
<p>Google 公司在开源 WebP 的同时，还提供了一个图片压缩工具 <a href="./precompiled.md">cwebp</a>来将其他图片转成 WebP。cwebp 使用起来也很简单，只要根据图片情况设置好参数就行。</p>
<p>cwebp 语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">cwebp [options] input_file -o output_file.webp
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如，你要选择无损压缩模式的话，可以使用如下所示的命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">cwebp -lossless original.png -o new.webp
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，-lossless 表示的是，要对输入的 png 图像进行无损编码，转成 WebP 图片。不使用 -lossless，则表示有损压缩。</p>
<p>在 cwebp 语法中，还有一个比较关键的参数 -q float。</p>
<p>图片色值在不同情况下，可以选择用 -q 参数来进行设置，在不损失图片质量情况下进行最大化压缩：</p>
<ul>
<li>小于 256 色适合无损压缩，压缩率高，参数使用 -lossless -q 100；</li>
<li>大于 256 色使用 75% 有损压缩，参数使用 -q 75；</li>
<li>远大于 256 色使用 75% 以下压缩率，参数 -q 50 -m 6。</li>
</ul>
<p>除了 cwebp 工具外，你还可以选择由腾讯公司开发的<a href="./isparta.github.io.md">iSparta</a>。iSpart 是一个 GUI 工具，操作方便快捷，可以实现 PNG 格式转 WebP，同时提供批量处理和记录操作配置的功能。如果是其他格式的图片要转成 WebP 格式的话，需要先将其转成 PNG 格式，再转成 WebP 格式。它的 GUI 界面如下图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/b159195f4035d8507319ad8817141cb7.png" alt=""></p>
<p>图 7 iSparta 将 PNG 转 WebP 使用示例</p>
<p>图片压缩完了并不是结束，我们还需要在显示图片时使用 libwebp 进行解析。这里有一个 iOS 工程使用 libwebp 的范例，你可以点击<a href="./WebP-iOS-example.md">这个链接</a>查看。</p>
<p>不过，WebP 在 CPU 消耗和解码时间上会比 PNG 高两倍。所以，我们有时候还需要在性能和体积上做取舍。</p>
<p><strong>我的建议是，如果图片大小超过了 100KB，你可以考虑使用 WebP；而小于 100KB 时，你可以使用网页工具 <a href="./tinypng.com.md">TinyPng</a>或者 GUI 工具<a href="./mac.md">ImageOptim</a>进行图片压缩</strong>。这两个工具的压缩率没有 WebP 那么高，不会改变图片压缩方式，所以解析时对性能损耗也不会增加。</p>
<h2 id="代码瘦身">代码瘦身</h2>
<p>App 的安装包主要是由资源和可执行文件组成的，所以我们在掌握了对图片资源的处理方式后，需要再一起来看看对可执行文件的瘦身方法。</p>
<p>可执行文件就是 Mach-O 文件，其大小是由代码量决定的。通常情况下，**对可执行文件进行瘦身，就是找到并删除无用代码的过程。**而查找无用代码时，我们可以按照找无用图片的思路，即：</p>
<ul>
<li>首先，找出方法和类的全集；</li>
<li>然后，找到使用过的方法和类；</li>
<li>接下来，取二者的差集得到无用代码；</li>
<li>最后，由人工确认无用代码可删除后，进行删除即可。</li>
</ul>
<p>接下来，我们就看看具体的代码瘦身方法吧。</p>
<h3 id="linkmap-结合-mach-o-找无用代码">LinkMap 结合 Mach-O 找无用代码</h3>
<p>我先和你说下怎么快速找到方法和类的全集。</p>
<p>**我们可以通过分析 LinkMap 来获得所有的代码类和方法的信息。**获取 LinkMap 可以通过将 Build Setting 里的 Write Link Map File 设置为 Yes，然后指定 Path to Link Map File 的路径就可以得到每次编译后的 LinkMap 文件了。设置选项如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/3efa0e47328b57c12b9307dedeec0d89.png" alt=""></p>
<p>图 8 LinkMap 文件获取方法</p>
<p>LinkMap 文件分为三部分：Object File、Section 和 Symbols。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/eb365b7b34fe34ec55cf871f81741e9d.png" alt=""></p>
<p>图 9 LinkMap 文件主要组成</p>
<p>其中：</p>
<ul>
<li>Object File 包含了代码工程的所有文件；</li>
<li>Section 描述了代码段在生成的 Mach-O 里的偏移位置和大小；</li>
<li>Symbols 会列出每个方法、类、block，以及它们的大小。</li>
</ul>
<p>通过 LinkMap，你不光可以统计出所有的方法和类，还能够清晰地看到代码所占包大小的具体分布，进而有针对性地进行代码优化。</p>
<p>得到了代码的全集信息以后，我们还需要找到已使用的方法和类，这样才能获取到差集，找出无用代码。所以接下来，我就先和你说说<strong>怎么通过 Mach-O 取到使用过的方法和类</strong>。</p>
<p>我在第 2 篇文章“<a href="./85331.md">APP 启动速度怎么做优化与监控？</a>”中，和你提到过 iOS 的方法都会通过 objc_msgSend 来调用。而，objc_msgSend 在 Mach-O 文件里是通过 __objc_selrefs 这个 section 来获取 selector 这个参数的。</p>
<p>所以，__objc_selrefs 里的方法一定是被调用了的。__objc_classrefs 里是被调用过的类，__objc_superrefs 是调用过 super 的类。通过 __objc_classrefs 和 __objc_superrefs，我们就可以找出使用过的类和子类。</p>
<p>那么，Mach-O 文件的 __objc_selrefs、__objc_classrefs 和 __objc_superrefs 怎么查看呢？</p>
<p>我们可以使用 <a href="./machoview.md">MachOView 这个软件</a>来查看 Mach-O 文件里的信息。MachOView 同时也是一款开源软件，如果你对源码感兴趣的话，可以点击<a href="./MachOView.md">这个地址</a>查看。</p>
<p>具体的查看方法，我将通过一个案例和你展开。</p>
<ul>
<li>首先，我们需要编译一个 App。在这里，我 clone 了<a href="./GCDFetchFeed.md">一个 GitHub 上的示例</a> 下来编译。</li>
<li>然后，将生成的 GCDFetchFeed.app 包解开，取出 GCDFetchFeed。</li>
<li>最后，我们就可以使用 MachOView 来查看 Mach-O 里的信息了。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/5a7eeb3204e922a53a2b4d26ce9295c9.png" alt=""></p>
<p>图 10 使用 MachOView 查看 GCDFetchFeed</p>
<p>如图上所示，我们可以看到 __objc_selrefs、__objc_classrefs 和、__objc_superrefs 这三个 section。</p>
<p>但是，这种查看方法并不是完美的，还会有些问题。原因在于，Objective-C 是门动态语言，方法调用可以写成在运行时动态调用，这样就无法收集全所有调用的方法和类。所以，我们通过这种方法找出的无用方法和类就只能作为参考，还需要二次确认。</p>
<h3 id="通过-appcode-找出无用代码">通过 AppCode 找出无用代码</h3>
<p>那么，有什么好的工具能够找出无用的代码吗？</p>
<p>我用过不少工具，但效果其实都不是很好，都卡在了各种运用运行时调用方法的写法上。即使是大名鼎鼎的 AppCode 在这方面也做得不是很好，当代码量过百万行时 AppCode 的静态分析会“歇菜”。</p>
<p>但是，**如果工程量不是很大的话，我还是建议你直接使用 AppCode 来做分析。**毕竟代码量达到百万行的工程并不多。而，那些代码量达到百万行的团队，则会自己通过 Clang 静态分析来开发工具，去检查无用的方法和类。</p>
<p>用 AppCode 做分析的方法很简单，直接在 AppCode 里选择 Code-&gt;Inspect Code 就可以进行静态分析。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/342ea400b34a3e146e9b273d27f3bdb5.png" alt=""></p>
<p>图 11 使用 AppCode 来做静态分析</p>
<p>静态分析完以后，我们可以在 Unused code 里看到所有的无用代码，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/62f4c1e3ec7695196cd86e991d1d2c39.png" alt=""></p>
<p>图 12 Unused code 里看到所有无用代码</p>
<p>接下来，我和你说一下这些无用代码的主要类型。</p>
<ul>
<li>无用类：Unused class 是无用类，Unused import statement 是无用类引入声明，Unused property 是无用的属性；</li>
<li>无用方法：Unused method 是无用的方法，Unused parameter 是无用参数，Unused instance variable 是无用的实例变量，Unused local variable 是无用的局部变量，Unused value 是无用的值；</li>
<li>无用宏：Unused macro 是无用的宏。</li>
<li>无用全局：Unused global declaration 是无用全局声明。</li>
</ul>
<p>看似 AppCode 已经把所有工作都完成了，其实不然。下面，我再和你列举下 AppCode 静态检查的问题：</p>
<ul>
<li>JSONModel 里定义了未使用的协议会被判定为无用协议；</li>
<li>如果子类使用了父类的方法，父类的这个方法不会被认为使用了；</li>
<li>通过点的方式使用属性，该属性会被认为没有使用；</li>
<li>使用 performSelector 方式调用的方法也检查不出来，比如 self performSelector:@selector(arrivalRefreshTime)；</li>
<li>运行时声明类的情况检查不出来。比如通过 NSClassFromString 方式调用的类会被查出为没有使用的类，比如 layerClass = NSClassFromString(@“SMFloatLayer”)。还有以 [[self class] accessToken] 这样不指定类名的方式使用的类，会被认为该类没有被使用。像 UITableView 的自定义的 Cell 使用 registerClass，这样的情况也会认为这个 Cell 没有被使用。</li>
</ul>
<p>基于以上种种原因，使用 AppCode 检查出来的无用代码，还需要人工二次确认才能够安全删除掉。</p>
<h3 id="运行时检查类是否真正被使用过">运行时检查类是否真正被使用过</h3>
<p>即使你使用 LinkMap 结合 Mach-O 或者 AppCode 的方式，通过静态检查已经找到并删除了无用的代码，那么就能说包里完全没有无用的代码了吗？</p>
<p>实际上，在 App 的不断迭代过程中，新人不断接手、业务功能需求不断替换，会留下很多无用代码。这些代码在执行静态检查时会被用到，但是线上可能连这些老功能的入口都没有了，更是没有机会被用户用到。也就是说，这些无用功能相关的代码也是可以删除的。</p>
<p>那么，<strong>我们要怎么检查出这些无用代码呢？</strong></p>
<p>通过 ObjC 的 runtime 源码，我们可以找到怎么判断一个类是否初始化过的函数，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define RW_INITIALIZED (1&lt;&lt;29)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">bool isInitialized() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>isInitialized 的结果会保存到元类的 class_rw_t 结构体的 flags 信息里，flags 的 1&laquo;29 位记录的就是这个类是否初始化了的信息。而 flags 的其他位记录的信息，你可以参看 objc runtime 的源码，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="err">类的方法列表已修复</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#define RW_METHODIZED         (1&lt;&lt;30)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">//</span> <span class="err">类已经初始化了</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#define RW_INITIALIZED        (1&lt;&lt;29)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">//</span> <span class="err">类在初始化过程中</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#define RW_INITIALIZING       (1&lt;&lt;28)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">//</span> <span class="n">class_rw_t</span><span class="o">-&gt;</span><span class="n">ro</span> <span class="err">是</span> <span class="n">class_ro_t</span> <span class="err">的堆副本</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#define RW_COPIED_RO          (1&lt;&lt;27)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">//</span> <span class="err">类分配了内存，但没有注册</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#define RW_CONSTRUCTING       (1&lt;&lt;26)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">//</span> <span class="err">类分配了内存也注册了</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#define RW_CONSTRUCTED        (1&lt;&lt;25)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">//</span> <span class="n">GC</span><span class="err">：</span><span class="k">class</span> <span class="err">有不安全的</span> <span class="n">finalize</span> <span class="err">方法</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#define RW_FINALIZE_ON_MAIN_THREAD (1&lt;&lt;24)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">//</span> <span class="err">类的</span> <span class="o">+</span><span class="nb">load</span> <span class="err">被调用了</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#define RW_LOADED             (1&lt;&lt;23)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>flags 采用位方式记录布尔值的方式，易于扩展、所用存储空间小、检索性能也好。所以，经常阅读优秀代码，特别有助于提高我们自己的代码质量。</p>
<p>这里，我插一句题外话。**我面试应聘者的时候，常常会问他们“苹果公司为什么要设计元类”这样的开放问题。**结果呢，就是我所见的大部分应聘者，都只能说出元类是什么。</p>
<p>因为很多人都只是奔着学习 runtime 这个知识点而学习，并没有在学习过程中多想想为什么。比如，为什么类结构要这么设计，为什么一个类要设计两个结构体等等类似的问题。在我看来，没有经过深入思考的学习是不够的，是学不到精髓的，很多优秀的代码可能就会被错过。</p>
<p>好了，现在继续回到我们的正文内容中。既然能够在运行中看到类是否初始化了，那么我们就能够找出有哪些类是没有初始化的，即找到在真实环境中没有用到的类并清理掉。</p>
<p>具体编写运行时无用类检查工具时，我们可以在线下测试环节去检查所有类，先查出哪些类没有初始化，然后上线后针对那些没有初始化的类进行多版本监测观察，看看哪些是在主流程外个别情况下会用到的，判断合理性后进行二次确认，最终得到真正没有用到的类并删掉。</p>
<h2 id="小结">小结</h2>
<p>今天这篇文章，我主要和你分享的是 App 安装包的一些瘦身方案。</p>
<p>在我看来，可以把包瘦身方案根据 App 的代码量等因素，划分为两种。</p>
<p>对于上线时间不长的新 App 和那些代码量不大的 App 来说，做些资源上的优化，再结合使用 AppCode 就能够有很好的收益。而且把这些流程加入工作流后，日常工作量也不会太大。</p>
<p>但是，对于代码量大，而且业务需求迭代时间很长的 App 来说，包大小的瘦身之路依然任道重远，这个领域的研究还有待继续完善。LinkMap 加 Mach-O 取差集的结果也只能作为参考，每次人工确认的成本是非常大的，只适合突击和应急清理时使用。最后日常采用的方案，可能还是用运行时检查类的方式，这种大粒度检查的方式精度虽然不高，但是人工工作量会小很多。</p>
<h2 id="课后小作业">课后小作业</h2>
<p>今天我提到了运行时检查类是否被使用的方案，那么你来写个使用这种方案的小工具来检查下你的 App 里有哪些类实际上是没有被初始化用到的吧。</p>
<p>感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎把它分享给更多的朋友一起阅读。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/0e2ff493da248888e66ed0aa4e0251a2.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/ios%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/">iOS开发高手课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/10__%E6%A1%88%E4%BE%8B%E7%AF%87%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%ADcpu%E4%BD%BF%E7%94%A8%E7%8E%87%E5%8D%87%E9%AB%98%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">10__案例篇：系统的软中断CPU使用率升高，我该怎么办？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/10__%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%B5%8B%E5%80%BC%E5%88%86%E7%A6%BB%E6%99%AE%E9%80%9A%E7%9A%84%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%80%8E%E4%B9%88%E4%B9%9F%E6%9C%89%E5%9D%8F%E5%91%B3%E9%81%93/">
            <span class="next-text nav-default">10__变量声明与赋值分离：普通的变量声明，怎么也有坏味道？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
