<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>13_继承和多态：面向对象运行期的动态特性 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="面向对象是一个比较大的话题。在“09 | 面向对象：实现数据和方法的封装”中，我们了解了面向对象的封装特性，也探讨了对象成员的作用域和生存期特征等内容。本节课，我们再来了解一下面向对象的另外两个重要特征：继承和多态。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/13_%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%9A%84%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/13_%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%9A%84%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="13_继承和多态：面向对象运行期的动态特性">
  <meta property="og:description" content="面向对象是一个比较大的话题。在“09 | 面向对象：实现数据和方法的封装”中，我们了解了面向对象的封装特性，也探讨了对象成员的作用域和生存期特征等内容。本节课，我们再来了解一下面向对象的另外两个重要特征：继承和多态。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="编译原理之美">

  <meta itemprop="name" content="13_继承和多态：面向对象运行期的动态特性">
  <meta itemprop="description" content="面向对象是一个比较大的话题。在“09 | 面向对象：实现数据和方法的封装”中，我们了解了面向对象的封装特性，也探讨了对象成员的作用域和生存期特征等内容。本节课，我们再来了解一下面向对象的另外两个重要特征：继承和多态。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5779">
  <meta itemprop="keywords" content="编译原理之美">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="13_继承和多态：面向对象运行期的动态特性">
  <meta name="twitter:description" content="面向对象是一个比较大的话题。在“09 | 面向对象：实现数据和方法的封装”中，我们了解了面向对象的封装特性，也探讨了对象成员的作用域和生存期特征等内容。本节课，我们再来了解一下面向对象的另外两个重要特征：继承和多态。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">13_继承和多态：面向对象运行期的动态特性</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5779 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#从类型体系的角度理解继承和多态">从类型体系的角度理解继承和多态</a></li>
        <li><a href="#如何对继承和多态的特性做语义分析">如何对继承和多态的特性做语义分析</a></li>
        <li><a href="#如何在运行期实现方法的动态绑定">如何在运行期实现方法的动态绑定</a></li>
        <li><a href="#继承情况下对象的实例化">继承情况下对象的实例化</a></li>
        <li><a href="#如何实现-this-和-super">如何实现 this 和 super</a></li>
        <li><a href="#课程小结">课程小结</a></li>
        <li><a href="#一课一思">一课一思</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>面向对象是一个比较大的话题。在“<a href="./130422.md">09 | 面向对象：实现数据和方法的封装</a>”中，我们了解了面向对象的封装特性，也探讨了对象成员的作用域和生存期特征等内容。本节课，我们再来了解一下面向对象的另外两个重要特征：<strong>继承和多态。</strong></p>
<p>你也许会问，为什么没有在封装特性之后，马上讲继承和多态呢？那是因为继承和多态涉及的语义分析阶段的知识点比较多，特别是它对类型系统提出了新的概念和挑战，所以我们先掌握语义分析，再了解这部分内容，才是最好的选择。</p>
<p>继承和多态对类型系统提出的新概念，就是子类型。我们之前接触的类型往往是并列关系，你是整型，我是字符串型，都是平等的。而现在，一个类型可以是另一个类型的子类型，比如我是一只羊，又属于哺乳动物。这会导致我们在编译期无法准确计算出所有的类型，从而无法对方法和属性的调用做完全正确的消解（或者说绑定）。这部分工作要留到运行期去做，也因此，面向对象编程会具备非常好的优势，因为它会导致多态性。这个特性会让面向对象语言在处理某些类型的问题时，更加优雅。</p>
<p>而我们要想深刻理解面向对象的特征，就必须了解子类型的原理和运行期的机制。所以，接下来，我们从类型体系的角度理解继承和多态，然后看看在编译期需要做哪些语义分析，再考察继承和多态的运行期特征。</p>
<h2 id="从类型体系的角度理解继承和多态">从类型体系的角度理解继承和多态</h2>
<p>**继承的意思是一个类的子类，自动具备了父类的属性和方法，除非被父类声明为私有的。**比如一个类是哺乳动物，它有体重（weight）的属性，还会做叫 (speak) 的操作。如果基于哺乳动物这个父类创建牛和羊两个子类，那么牛和羊就自动继承了哺乳动物的属性，有体重，还会叫。</p>
<p>所以继承的强大之处，就在于重用。也就是有些逻辑，如果在父类中实现，在子类中就不必重复实现。</p>
<p>**多态的意思是同一个类的不同子类，在调用同一个方法时会执行不同的动作。**这是因为每个子类都可以重载掉父类的某个方法，提供一个不同的实现。哺乳动物会“叫”，而牛和羊重载了这个方法，发出“哞~”和“咩~”的声音。这似乎很普通，但如果创建一个哺乳动物的数组，并在里面存了各种动物对象，遍历这个数组并调用每个对象“叫”的方法时，就会发出“哞~”“咩~”“喵~”等各种声音，这就有点儿意思了。</p>
<p>下面这段示例代码，演示了继承和多态的特性，a 的 speak() 方法和 b 的 speak() 方法会分别打印出牛叫和羊叫，调用的是子类的方法，而不是父类的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">mammal.play 演示面向对象编程：继承和多态。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">*/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Mammal{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int weight = 20;  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    boolean canSpeak(){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        return true;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     void speak(){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        println(&#34;mammal speaking...&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> class Cow extends Mammal{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void speak(){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        println(&#34;moo~~ moo~~&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> class Sheep extends Mammal{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void speak(){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        println(&#34;mee~~ mee~~&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        println(&#34;My weight is: &#34; + weight); //weight 的作用域覆盖子类
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 将子类的实例赋给父类的变量
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Mammal a = Cow();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Mammal b = Sheep();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> //canSpeak() 方法是继承的
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">println(&#34;a.canSpeak() : &#34; + a.canSpeak());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">println(&#34;b.canSpeak() : &#34; + b.canSpeak());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 下面两个的叫声会不同，在运行期动态绑定方法
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">a.speak();  // 打印牛叫
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b.speak();  // 打印羊叫
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以，多态的强大之处，在于虽然每个子类不同，但我们仍然可以按照统一的方式使用它们，做到求同存异。<strong>以前端工程师天天打交道的前端框架为例，这是最能体现面向对象编程优势的领域之一。</strong></p>
<p>前端界面往往会用到各种各样的小组件，比如静态文本、可编辑文本、按钮等等。如果我们想刷新组件的显示，没必要针对每种组件调用一个方法，把所有组件的类型枚举一遍，可以直接调用父类中统一定义的方法 redraw()，非常简洁。即便将来添加新的前端组件，代码也不需要修改，程序也会更容易维护。</p>
<p>**总结一下：**面向对象编程时，我们可以给某个类创建不同的子类，实现一些个性化的功能；写程序时，我们可以站在抽象度更高的层次上，不去管具体的差异。</p>
<p>如果把上面的结论抽象成一般意义上的类型理论，就是<strong>子类型（subtype）。</strong></p>
<p>子类型（或者动名词：子类型化），是对我们前面讲的类型体系的一个补充。</p>
<p>子类型的核心是提供了 is-a 的操作。也就是对某个类型所做的所有操作都可以用子类型替代。因为子类型 is a 父类型，也就是能够兼容父类型，比如一只牛是哺乳动物。</p>
<p>这意味着只要对哺乳动物可以做的操作，都可以对牛来做，这就是子类型的好处。它可以放宽对类型的检查，从而导致多态。你可以粗略地把面向对象的继承看做是子类型化的一个体现，它的结果就是能用子类代替父类，从而导致多态。</p>
<p>子类型有两种实现方式：一种就是像 Java 和 C++ 语言，需要显式声明继承了什么类，或者实现了什么接口。这种叫做名义子类型（Nominal Subtyping）。</p>
<p>另一种是结构化子类型（Structural Subtyping），又叫鸭子类型（Duck Type）。也就是一个类不需要显式地说自己是什么类型，只要它实现了某个类型的所有方法，那就属于这个类型。鸭子类型是个直观的比喻，如果我们定义鸭子的特征是能够呱呱叫，那么只要能呱呱叫的，就都是鸭子。</p>
<p>了解了继承和多态之后，我们看看在编译期如何对继承和多态的特性做语义分析。</p>
<h2 id="如何对继承和多态的特性做语义分析">如何对继承和多态的特性做语义分析</h2>
<p>针对哺乳动物的例子，我们用前面语义分析的知识，看看如何在编译期针对继承和多态做语义分析，也算对语义分析的知识点进行应用和复盘。</p>
<p>首先，从类型处理的角度出发，我们要识别出新的类型：Mammal、Cow 和 Sheep。之后，就可以用它们声明变量了。</p>
<p>第二，我们要设置正确的作用域。</p>
<p>从作用域的角度来看，一个类的属性（或者说成员变量），是可以规定能否被子类访问的。以 Java 为例，除了声明为 private 的属性以外，其他属性在子类中都是可见的。所以父类的属性的作用域，可以说是以树状的形式覆盖到了各级子类：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/96d0fe2bafcfbf03c38c8a48cae8a1f6.png" alt=""></p>
<p>第三，要对变量和函数做类型的引用消解。</p>
<p>也就是要分析出 a 和 b 这两个变量的类型。那么 a 和 b 的类型是什么呢？是父类 Mammal？还是 Cow 或 Sheep？</p>
<p>注意，代码里是用 Mammal 来声明这两个变量的。按照类型推导的算法，a 和 b 都是 Mammal，这是个 I 属性计算的过程。也就是说，在编译期，我们无法知道变量被赋值的对象确切是哪个子类型，只知道声明变量时，它们是哺乳动物类型，至于是牛还是羊，就不清楚了。</p>
<p>你可能会说：“不对呀，我在编译的时候能知道 a 和 b 的准确类型啊，因为我看到了 a 是一个 Cow 对象，而 b 是一个 Sheep，代码里有这两个对象的创建过程，我可以推导出 a 和 b 的实际类型呀。”</p>
<p>没错，语言的确有自动类型推导的特性，但你忽略了限制条件。比如，强类型机制要求变量的类型一旦确定，在运行过程就不能再改，所以要让 a 和 b 能够重新指向其他的对象，并保持类型不变。从这个角度出发，a 和 b 的类型只能是父类 Mammal。</p>
<p>所以说，编译期无法知道变量的真实类型，可能只知道它的父类型，也就是知道它是一个哺乳动物，但不知道它具体是牛还是羊。这会导致我们没法正确地给 speak() 方法做引用消解。正确的消解，是要指向 Cow 和 Sheep 的 speak 方法，而我们只能到运行期再解决这个问题。</p>
<p>所以接下来，我们就讨论一下如何在运行期实现方法的动态绑定。</p>
<h2 id="如何在运行期实现方法的动态绑定">如何在运行期实现方法的动态绑定</h2>
<p>在运行期，我们能知道 a 和 b 这两个变量具体指向的是哪个对象，对象里是保存了真实类型信息的。具体来说，在 playscript 中，ClassObject 的 type 属性会指向一个正确的 Class，这个类型信息是在创建对象的时候被正确赋值的：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/081e4ac65c72b4c5c79d6eadfdd02ed3.png" alt=""></p>
<p>在调用类的属性和方法时，我们可以根据运行时获得的，确定的类型信息进行动态绑定。下面这段代码是从本级开始，逐级查找某个方法的实现，如果本级和父类都有这个方法，那么本级的就会覆盖掉父类的，<strong>这样就实现了多态：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">protected Function getFunction(String name, List&lt;Type&gt; paramTypes){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 在本级查找这个这个方法
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Function rtn = super.getFunction(name, paramTypes);  //TODO 是否要检查 visibility
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     // 如果在本级找不到，那么递归的从父类中查找
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (rtn == null &amp;&amp; parentClass != null){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        rtn = parentClass.getFunction(name,paramTypes);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     return rtn;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果当前类里面没有实现这个方法，它可以直接复用某一级的父类中的实现，<strong>这实际上就是继承机制在运行期的原理。</strong></p>
<p>你看，只有了解运行期都发生了什么，才能知道继承和多态是怎么发生的吧。</p>
<p>这里延伸一下。我们刚刚谈到，在运行时可以获取类型信息，这种机制就叫做运行时类型信息（Run Time Type Information, RTTI）。C++、Java 等都有这种机制，比如 Java 的 instanceof 操作，就能检测某个对象是不是某个类或者其子类的实例。</p>
<p>汇编语言是无类型的，所以一般高级语言在编译成目标语言之后，这些高层的语义就会丢失。如果要在运行期获取类型信息，需要专门实现 RTTI 的功能，这就要花费额外的存储开销和计算开销。就像在 playscript 中，我们要在 ClassObject 中专门拿出一个字段来存 type 信息。</p>
<p>现在，我们已经了解如何在运行期获得类型信息，实现方法的动态绑定。接下来，我带你了解一下运行期的对象的逐级初始化机制。</p>
<h2 id="继承情况下对象的实例化">继承情况下对象的实例化</h2>
<p>在存在继承关系的情况下，创建对象时，不仅要初始化自己这一级的属性变量，还要把各级父类的属性变量也都初始化。比如，在实例化 Cow 的时候，还要对 Mammal 的成员变量 weight 做初始化。</p>
<p>所以我们要修改 playscript 中对象实例化的代码，从最顶层的祖先起，对所有的祖先层层初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 从父类到子类层层执行缺省的初始化方法，即不带参数的初始化方法
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">protected ClassObject createAndInitClassObject(Class theClass) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ClassObject obj = new ClassObject();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    obj.type = theClass;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     Stack&lt;Class&gt; ancestorChain = new Stack&lt;Class&gt;();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     // 从上到下执行缺省的初始化方法
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ancestorChain.push(theClass);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while (theClass.getParentClass() != null) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ancestorChain.push(theClass.getParentClass());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        theClass = theClass.getParentClass();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     // 执行缺省的初始化方法
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    StackFrame frame = new StackFrame(obj);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    pushStack(frame);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while (ancestorChain.size() &gt; 0) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        Class c = ancestorChain.pop();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        defaultObjectInit(c, obj);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    popStack();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     return obj;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在逐级初始化的过程中，我们要先执行缺省的成员变量初始化，也就是变量声明时所带的初始化部分，然后调用这一级的构造方法。如果不显式指定哪个构造方法，就会执行不带参数的构造方法。不过有的时候，子类会选择性地调用父类某一个构造方法，就像 Java 可以在构造方法里通过 super() 来显式地调用父类某个具体构造方法。</p>
<h2 id="如何实现-this-和-super">如何实现 this 和 super</h2>
<p>现在，我们已经了解了继承和多态在编译期和运行期的特性。接下来，我们通过一个示例程序，把本节课的所有知识复盘检验一下，加深对它们的理解，也加深对 this 和 super 机制的理解。</p>
<p>这个示例程序是用 Java 写的，在 Java 语言中，为面向对象编程专门提供了两个关键字：this 和 super，这两个关键字特别容易引起混乱。</p>
<p>比如在下面的 ThisSuperTest.Java 代码中，Mammal 和它的子类 Cow 都有 speak() 方法。如果我们要创建一个 Cow 对象，会调用 Mammal 的构造方法 Mammal(int weight)，而在这个构造方法里调用的 this.speak() 方法，是 Mammal 的，还是 Cow 的呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">package play;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> public class ThisSuperTest {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     public static void main(String args[]){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 创建 Cow 对象的时候，会在 Mammal 的构造方法里调用 this.reportWeight()，这里会显示什么
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        Cow cow = new Cow();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         System.out.println();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         // 这里调用，会显示什么
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        cow.speak();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> class Mammal{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int weight;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     Mammal(){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;Mammal() called&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        this.weight = 100;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     Mammal(int weight){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        this();   // 调用自己的另一个构造函数
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;Mammal(int weight) called&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        this.weight = weight;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         // 这里访问属性，是自己的 weight
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;this.weight in Mammal : &#34; + this.weight);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         // 这里的 speak() 调用的是谁，会显示什么数值
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        this.speak();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     void speak(){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;Mammal&#39;s weight is : &#34; + this.weight);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  class Cow extends Mammal{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int weight = 300;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     Cow(){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        super(200);   // 调用父类的构造函数
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     void speak(){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;Cow&#39;s weight is : &#34; + this.weight);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;super.weight is : &#34; + super.weight);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Mammal() called
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Mammal(int weight) called
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">this.weight in Mammal : 200
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Cow&#39;s weight is : 0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">super.weight is : 200
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> Cow&#39;s weight is : 300
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">super.weight is : 200
</span></span></code></pre></td></tr></table>
</div>
</div><p>答案是 Cow 的 speak() 方法，而不是 Mammal 的。怎么回事？代码里不是调用的 this.speak() 吗？怎么这个 this 不是 Mammal，却变成了它的子类 Cow 呢？</p>
<p>其实，在这段代码中，this 用在了三个地方：</p>
<ul>
<li>this.weight 是访问自己的成员变量，因为成员变量的作用域是这个类本身，以及子类。</li>
<li>this() 是调用自己的另一个构造方法，因为这是构造方法，肯定是做自身的初始化。换句话说，构造方法不存在多态问题。</li>
<li>this.speak() 是调用一个普通的方法。这时，多态仍会起作用。运行时会根据对象的实际类型，来绑定到 Cow 的 speak() 方法上。</li>
</ul>
<p>只不过，在 Mammal 的构造方法中调用 this.speak() 时，虽然访问的是 Cow 的 speak() 方法，打印的是 Cow 中定义的 weight 成员变量，但它的值却是 0，而不是成员变量声明时“int weight = 300;”的 300。为什么呢？</p>
<p>要想知道这个答案，我们需要理解多层继承情况下对象的初始化过程。在 Mammal 的构造方法中调用 speak() 的时候，Cow 的初始化过程还没有开始呢，所以“int weight = 300;”还没有执行，Cow 的 weight 属性还是缺省值 0。</p>
<p>怎么样？一个小小的例子，却需要用到三个方面的知识：面向对象的成员变量的作用域、多态、对象初始化。<strong>Java 程序员可以拿这个例子跟同事讨论一下，看看是不是很好玩。</strong></p>
<p>讨论完 this，super 就比较简单了，它的语义要比 this 简单，不会出现歧义。super 的调用，也是分成三种情况：</p>
<ul>
<li>super.weight。这是调用父类或更高的祖先的 weight 属性，而不是 Cow 这一级的 weight 属性。不一定非是直接父类，也可以是祖父类中的。根据变量作用域的覆盖关系，只要是比 Cow 这一级高的就行。</li>
<li>super(200)。这是调用父类的构造方法，必须是直接父类的。</li>
<li>super.speak()。跟访问属性的逻辑一样，是调用父类或更高的祖先的 speak() 方法。</li>
</ul>
<h2 id="课程小结">课程小结</h2>
<p>这节课我带你实现了面向对象中的另两个重要特性：继承和多态。在这节课中，我建议你掌握的重点内容是：</p>
<ul>
<li>从类型的角度，面向对象的继承和多态是一种叫做子类型的现象，子类型能够放宽对类型的检查，从而支持多态。</li>
<li>在编译期，无法准确地完成对象方法和属性的消解，因为无法确切知道对象的子类型。</li>
<li>在运行期，我们能够获得对象的确切的子类型信息，从而绑定正确的方法和属性，实现继承和多态。另一个需要注意的运行期的特征，是对象的逐级初始化过程。</li>
</ul>
<p>面向对象涉及了这么多精彩的知识点，拿它作为前端技术原理篇的最后一讲，是正确的选择。到目前为止，我们已经讲完了前端技术的原理篇，也如约拥有了一门具备丰富特性的脚本语言，甚至还支持面向对象编程、闭包、函数式编程这些很高级的特性。一般的应用项目所需要的语言特性，很难超过这个范围了。接下来的两节，我们就通过两个具体的应用案例，来检验一下学到的编译原理前端技术，看看它的威力！</p>
<h2 id="一课一思">一课一思</h2>
<p>本节课我们深入讨论了面向对象的继承和多态特征。那么你所熟悉的框架，有没有充分利用继承和多态的特点实现一些很有威力的功能？或者，你有没有利用多态的特点，写过一些比较有用的类库或框架呢？欢迎在留言区分享你的经验。</p>
<p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p>
<p>本节课的示例代码我放在了文末，供你参考。</p>
<ul>
<li>playscript-java（项目目录）： <a href="./playscript-java.md">码云</a> <a href="./playscript-java.md">GitHub</a></li>
<li>ASTEvaluator.java（解释器，请找一下运行期方法和属性动态绑定，以及对象实例逐级初始化的代码）： <a href="./ASTEvaluator.java.md">码云</a> <a href="./ASTEvaluator.java.md">GitHub</a></li>
<li>ThisSuperTest.java（测试 Java 的 this 和 super 特性）：<a href="./ThisSuperTest.java.md">码云</a> <a href="./ThisSuperTest.java.md">GitHub</a></li>
<li>this-and-super.play (playscript 的 this 和 super 特性)：<a href="./this-and-super.play.md">码云</a> <a href="./this-and-super.play.md">GitHub</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/77577e606d183349707a8a62717dc60c.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/">编译原理之美</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80%E8%AF%BE/13_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0__%E4%B8%89%E4%B8%AA%E8%87%AD%E7%9A%AE%E5%8C%A0%E8%B5%9B%E8%BF%87%E8%AF%B8%E8%91%9B%E4%BA%AE%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">13_机器学习__三个臭皮匠，赛过诸葛亮：集成学习</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/13_%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E8%AF%A6%E7%BB%86%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/">
            <span class="next-text nav-default">13_架构设计流程：详细方案设计</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
