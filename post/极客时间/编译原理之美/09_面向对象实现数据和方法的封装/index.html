<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>09_面向对象：实现数据和方法的封装 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="在现代计算机语言中，面向对象是非常重要的特性，似乎常用的语言都支持面向对象特性，比如 Swift、C&#43;&#43;、Java……不支持的反倒是异类了。
而它重要的特点就是封装。也就是说，对象可以把数据和对数据的操作封装在一起，构成一个不可分割的整体，尽可能地隐藏内部的细节，只保留一些接口与外部发生联系。在对象的外部只能通过这些接口与对象进行交互，无需知道对象内部的细节。这样能降低系统的耦合，实现内部机制的隐藏，不用担心对外界的影响。那么它们是怎样实现的呢？
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/09_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%B0%81%E8%A3%85/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/09_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%B0%81%E8%A3%85/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="09_面向对象：实现数据和方法的封装">
  <meta property="og:description" content="在现代计算机语言中，面向对象是非常重要的特性，似乎常用的语言都支持面向对象特性，比如 Swift、C&#43;&#43;、Java……不支持的反倒是异类了。
而它重要的特点就是封装。也就是说，对象可以把数据和对数据的操作封装在一起，构成一个不可分割的整体，尽可能地隐藏内部的细节，只保留一些接口与外部发生联系。在对象的外部只能通过这些接口与对象进行交互，无需知道对象内部的细节。这样能降低系统的耦合，实现内部机制的隐藏，不用担心对外界的影响。那么它们是怎样实现的呢？">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="编译原理之美">

  <meta itemprop="name" content="09_面向对象：实现数据和方法的封装">
  <meta itemprop="description" content="在现代计算机语言中，面向对象是非常重要的特性，似乎常用的语言都支持面向对象特性，比如 Swift、C&#43;&#43;、Java……不支持的反倒是异类了。
而它重要的特点就是封装。也就是说，对象可以把数据和对数据的操作封装在一起，构成一个不可分割的整体，尽可能地隐藏内部的细节，只保留一些接口与外部发生联系。在对象的外部只能通过这些接口与对象进行交互，无需知道对象内部的细节。这样能降低系统的耦合，实现内部机制的隐藏，不用担心对外界的影响。那么它们是怎样实现的呢？">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5516">
  <meta itemprop="keywords" content="编译原理之美">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="09_面向对象：实现数据和方法的封装">
  <meta name="twitter:description" content="在现代计算机语言中，面向对象是非常重要的特性，似乎常用的语言都支持面向对象特性，比如 Swift、C&#43;&#43;、Java……不支持的反倒是异类了。
而它重要的特点就是封装。也就是说，对象可以把数据和对数据的操作封装在一起，构成一个不可分割的整体，尽可能地隐藏内部的细节，只保留一些接口与外部发生联系。在对象的外部只能通过这些接口与对象进行交互，无需知道对象内部的细节。这样能降低系统的耦合，实现内部机制的隐藏，不用担心对外界的影响。那么它们是怎样实现的呢？">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">09_面向对象：实现数据和方法的封装</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5516 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#面向对象的语义特征">面向对象的语义特征</a></li>
        <li><a href="#设计类的语法并解析它">设计类的语法，并解析它</a></li>
        <li><a href="#对象是怎么实例化的">对象是怎么实例化的</a></li>
        <li><a href="#如何在内存里管理对象的数据">如何在内存里管理对象的数据</a></li>
        <li><a href="#访问对象的属性和方法">访问对象的属性和方法</a></li>
        <li><a href="#课程小结">课程小结</a></li>
        <li><a href="#一课一思">一课一思</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>在现代计算机语言中，面向对象是非常重要的特性，似乎常用的语言都支持面向对象特性，比如 Swift、C++、Java……不支持的反倒是异类了。</p>
<p>而它重要的特点就是封装。也就是说，对象可以把数据和对数据的操作封装在一起，构成一个不可分割的整体，尽可能地隐藏内部的细节，只保留一些接口与外部发生联系。在对象的外部只能通过这些接口与对象进行交互，无需知道对象内部的细节。这样能降低系统的耦合，实现内部机制的隐藏，不用担心对外界的影响。那么它们是怎样实现的呢？</p>
<p>本节课，我将从语义设计和运行时机制的角度剖析面向对象的特性，带你深入理解面向对象的实现机制，让你能在日常编程工作中更好地运用面向对象的特性。比如，在学完这讲之后，你会对对象的作用域和生存期、对象初始化过程等有更清晰的了解。而且你不会因为学习了 Java 或 C++ 的面向对象机制，在学习 JavaScript 和 Ruby 的面向对象机制时觉得别扭，因为它们的本质是一样的。</p>
<p>接下来，我们先简单地聊一下什么是面向对象。</p>
<h2 id="面向对象的语义特征">面向对象的语义特征</h2>
<p>我的一个朋友，在 10 多年前做过培训师，为了吸引学员的注意力，他在讲“什么是面向对象”时说：“面向对象是世界观，是方法论。”</p>
<p>虽然有点儿语不惊人死不休的意思，但我必须承认，所有的计算机语言都是对世界进行建模的方式，只不过建模的视角不同罢了。面向对象的设计思想，在上世纪 90 年代被推崇，几乎被视为最好的编程模式。实际上，各种不同的编程思想，都会表现为这门语言的语义特征，所以，我就从语义角度，利用类型、作用域、生存期这样的概念带你深入剖析一下面向对象的封装特性，其他特性在后面的课程中再去讨论。</p>
<ul>
<li><strong>从类型角度</strong></li>
</ul>
<p>类型处理是语义分析时的重要工作。现代计算机语言可以用自定义的类来声明变量，这是一个巨大的进步。因为早期的计算机语言只支持一些基础的数据类型，比如各种长短不一的整型和浮点型，像字符串这种我们编程时离不开的类型，往往是在基础数据类型上封装和抽象出来的。所以，我们要扩展语言的类型机制，让程序员可以创建自己的类型。</p>
<ul>
<li><strong>从作用域角度</strong></li>
</ul>
<p>首先是类的可见性。作为一种类型，它通常在整个程序的范围内都是可见的，可以用它声明变量。当然，一些像 Java 的语言，也能限制某些类型的使用范围，比如只能在某个命名空间内，或者在某个类内部。</p>
<p>对象的成员的作用域是怎样的呢？我们知道，对象的属性（“属性”这里指的是类的成员变量）可以在整个对象内部访问，无论在哪个位置声明。也就是说，对象属性的作用域是整个对象的内部，方法也是一样。这跟函数和块中的本地变量不一样，它们对声明顺序有要求，像 C 和 Java 这样的语言，在使用变量之前必须声明它。</p>
<ul>
<li><strong>从生存期的角度</strong></li>
</ul>
<p>对象的成员变量的生存期，一般跟对象的生存期是一样的。在创建对象的时候，就对所有成员变量做初始化，在销毁对象的时候，所有成员变量也随着一起销毁。当然，如果某个成员引用了从堆中申请的内存，这些内存需要手动释放，或者由垃圾收集机制释放。</p>
<p>但还有一些成员，不是与对象绑定的，而是与类型绑定的，比如 Java 中的静态成员。静态成员跟普通成员的区别，就是作用域和生存期不同，它的作用域是类型的所有对象实例，被所有实例共享。生存期是在任何一个对象实例创建之前就存在，在最后一个对象销毁之前不会消失。</p>
<p>你看，我们用这三个语义概念，就把面向对象的封装特性解释清楚了，无论语言在顶层怎么设计，在底层都是这么实现的。</p>
<p>了解了面向对象在语义上的原理之后，我们来实际动手解析一下代码中的类，这样能更深刻地体会这些原理。</p>
<h2 id="设计类的语法并解析它">设计类的语法，并解析它</h2>
<p>我们要在语言中支持类的定义，在 PlayScript.g4 中，可以这样定义类的语法规则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">classDeclaration
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    : CLASS IDENTIFIER
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      (EXTENDS typeType)?
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      (IMPLEMENTS typeList)?
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      classBody
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> classBody
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    : &#39;{&#39; classBodyDeclaration* &#39;}&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> classBodyDeclaration
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    : &#39;;&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    | memberDeclaration
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> memberDeclaration
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    : functionDeclaration
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    | fieldDeclaration
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> functionDeclaration
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    : typeTypeOrVoid IDENTIFIER formalParameters (&#39;[&#39; &#39;]&#39;)*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      (THROWS qualifiedNameList)?
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      functionBody
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ;
</span></span></code></pre></td></tr></table>
</div>
</div><p>我来简单地讲一下这个语法规则：</p>
<ul>
<li>类声明以 class 关键字开头，有一个标识符是类型名称，后面跟着类的主体。</li>
<li>类的主体里要声明类的成员。在简化的情况下，可以只关注类的属性和方法两种成员。我们故意把类的方法也叫做 function，而不是 method，是想把对象方法和函数做一些统一的设计。</li>
<li>函数声明现在的角色是类的方法。</li>
<li>类的成员变量的声明和普通变量声明在语法上没什么区别。</li>
</ul>
<p>你能看到，我们构造像 class 这样高级别的结构时，越来越得心应手了，之前形成的一些基础的语法模块都可以复用，比如变量声明、代码块（block）等。</p>
<p>用上面的语法写出来的 playscript 脚本的效果如下，在示例代码里也有，你可以运行它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ClassTest.play 简单的面向对象特性。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">*/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Mammal{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 类属性
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  string name = &#34;&#34;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   // 构造方法
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Mammal(string str){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    name = str;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   // 方法
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  void speak(){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    println(&#34;mammal &#34; + name +&#34; speaking...&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> Mammal mammal = Mammal(&#34;dog&#34;); //playscript 特别的构造方法，不需要 new 关键字
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">mammal.speak();                          // 访问对象方法
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">println(&#34;mammal.name = &#34; + mammal.name); // 访问对象的属性
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 没有构造方法，创建的时候用缺省构造方法
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Bird{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  int speed = 50;    // 在缺省构造方法里初始化
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   void fly(){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    println(&#34;bird flying...&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> Bird bird = Bird();              // 采用缺省构造方法
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">println(&#34;bird.speed : &#34; + bird.speed + &#34;km/h&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">bird.fly();
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，我们让 playscript 解释器处理这些看上去非常现代化的代码，怎么处理呢？</p>
<p>做完词法分析和语法分析之后，playscript 会在语义分析阶段扫描 AST，识别出所有自定义的类型，以便在其他地方引用这些类型来声明变量。因为类型的声明可以在代码中的任何位置，所以最好用单独的一次遍历来识别和记录类型（类型扫描的代码在 TypeAndScopeScanner.java 里）。</p>
<p>接着，我们在声明变量时，就可以引用这个类型了。语义分析的另一个工作，就是做变量类型的消解。当我们声明“Bird bird = Bird(); ”时，需要知道 Bird 对象的定义在哪里，以便正确地访问它的成员（变量类型的消解在 TypeResolver.java 里）。</p>
<p>在做语义分析时，要把类型的定义保存在一个数据结构中，我们来实现一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class Class extends Scope implements Type{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> public abstract class Scope extends Symbol{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 该 Scope 中的成员，包括变量、方法、类等。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected List&lt;Symbol&gt; symbols = new LinkedList&lt;Symbol&gt;(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> public interface Type {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getName();    // 类型名称
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     public Scope getEnclosingScope();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个设计中，我们看到 Class 就是一个 Scope，Scope 里面原来就能保存各种成员，现在可以直接复用，用来保存类的属性和方法，画成类图如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/3216a7f09a0e8e071e26e007b8ee579f.png" alt=""></p>
<p>图里有几个类，比如 Symbol、Variable、Scope、Function 和 BlockScope，它们是我们的符号体系的主要成员。在做词法分析时，我们会解析出很多标识符，这些标识符出现在不同的语法规则里，包括变量声明、表达式，以及作为类名、方法名等出现。</p>
<p>在语义分析阶段，我们要把这些标识符一一识别出来，这个是一个变量，指的是一个本地变量；那个是一个方法名等。</p>
<p>变量、类和函数的名称，我们都叫做符号，比如示例程序中的 Mammal、Bird、mammal、bird、name、speed 等。编译过程中的一项重要工作就是建立符号表，它帮助我们进一步地编译或执行程序，而符号表就用上面几个类来保存信息。</p>
<p>在符号表里，我们保存它的名称、类型、作用域等信息。对于类和函数，我们也有相应的地方来保存类变量、方法、参数、返回值等信息。你可以看一看示例代码里面是如何解析和记录这些符号的。</p>
<p>解析完这些语义信息以后，我们来看运行期如何执行具有面向对象特征的程序，比如如何实例化一个对象？如何在内存里管理对象的数据？以及如何访问对象的属性和方法？</p>
<h2 id="对象是怎么实例化的">对象是怎么实例化的</h2>
<p>首先通过构造方法来创建对象。</p>
<p>在语法中，我们没有用 new 这个关键字来表示对象的创建，而是省略掉了 new，直接调用一个跟类名称相同的函数，这是我们独特的设计，示例代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Mammal mammal = Mammal(&#34;dog&#34;); //playscript 特别的构造方法，不需要 new 关键字
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Bird bird = Bird();            // 采用缺省构造方法
</span></span></code></pre></td></tr></table>
</div>
</div><p>但在语义检查的时候，在当前作用域中是肯定找不到这样一个函数的，因为类的初始化方法是在类的内部定义的，我们只要检查一下，Mammal 和 Bird 是不是一个类名就可以了。</p>
<p>再进一步，Mammal 类中确实有个构造方法 Mammal()，而 Bird 类中其实没有一个显式定义的构造方法，但这并不意味着变量成员不会被初始化。我们借鉴了 Java 的初始化机制，就是提供缺省初始化方法，在缺省初始化方法里，会执行对象成员声明时所做的初始化工作。所以，上面的代码里，我们调用 Bird()，实际上就是调用了这个缺省的初始化方法。无论有没有显式声明的构造方法，声明对象的成员变量时的初始化部分，一定会执行。对于 Bird 类，实际上就会执行“int speed = 50;”这个语句。</p>
<p>在 RefResolver.java 中做语义分析的时候，下面的代码能够检测出某个函数调用其实是类的构造方法，或者是缺省构造方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="err">看看是不是类的构建函数，用相同的名称查找一个</span> <span class="k">class</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Class</span> <span class="n">theClass</span> <span class="o">=</span> <span class="n">at</span><span class="o">.</span><span class="n">lookupClass</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">idName</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">theClass</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">function</span> <span class="o">=</span> <span class="n">theClass</span><span class="o">.</span><span class="n">findConstructor</span><span class="p">(</span><span class="n">paramTypes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">function</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">at</span><span class="o">.</span><span class="n">symbolOfNode</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">function</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">如果是与类名相同的方法，并且没有参数，那么就是缺省构造方法</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">expressionList</span><span class="p">()</span> <span class="o">==</span> <span class="n">null</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">at</span><span class="o">.</span><span class="n">symbolOfNode</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">theClass</span><span class="p">);</span> <span class="o">//</span> <span class="n">TODO</span> <span class="err">直接赋予</span> <span class="k">class</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">at</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&#34;unknown class constructor: &#34;</span> <span class="o">+</span> <span class="n">ctx</span><span class="o">.</span><span class="n">getText</span><span class="p">(),</span> <span class="n">ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">at</span><span class="o">.</span><span class="n">typeOfNode</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">theClass</span><span class="p">);</span> <span class="o">//</span> <span class="err">这次函数调用是返回一个对象</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然，类的构造方法跟普通函数还是有所不同的，例如我们不允许构造方法定义返回值，因为它的返回值一定是这个类的一个实例对象。</p>
<p>对象做了缺省初始化以后，再去调用显式定义的构造方法，这样才能完善整个对象实例化的过程。不过问题来了，我们可以把普通的本地变量的数据保存在栈里，那么如何保存对象的数据呢？</p>
<h2 id="如何在内存里管理对象的数据">如何在内存里管理对象的数据</h2>
<p>其实，我们也可以把对象的数据像其他数据一样，保存在栈里。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/e3ef9557e21a8cc6b4d239c582409d53.png" alt=""></p>
<p>C 语言的结构体 struct 和 C++ 语言的对象，都可以保存在栈里。保存在栈里的对象是直接声明并实例化的，而不是用 new 关键字来创建的。如果用 new 关键字来创建，实际上是在堆里申请了一块内存，并赋值给一个指针变量，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/6f17c51576a3dc1ead89ff1d64bf17d2.png" alt=""></p>
<p>当对象保存在堆里的时候，可以有多个变量都引用同一个对象，比如图中的变量 a 和变量 b 就可以引用同一个对象 object1。类的成员变量也可以引用别的对象，比如 object1 中的类成员引用了 object2 对象。对象的生存期可以超越创建它的栈桢的生存期。</p>
<p>我们可以对比一下这两种方式的优缺点。如果对象保存在栈里，那么它的生存期与作用域是一样的，可以自动的创建和销毁，因此不需要额外的内存管理。缺点是对象没办法长期存在并共享。而在堆里创建的对象虽然可以被共享使用，却增加了内存管理的负担。</p>
<p>所以在 C 语言和 C++ 语言中，要小心管理从堆中申请的内存，在合适的时候释放掉这些内存。在 Java 语言和其他一些语言中，采用的是垃圾收集机制，也就是说当一个对象不再被引用时，就把内存收集回来。</p>
<p>分析到这儿的时候，我们其实可以帮 Java 语言优化一下内存管理。比如我们在分析代码时，如果发现某个对象的创建和使用都局限在某个块作用域中，并没有跟其他作用域共享，那么这个对象的生存期与当前栈桢是一致的，可以在栈里申请内存，而不是在堆里。这样可以免除后期的垃圾收集工作。</p>
<p>分析完对象的内存管理方式之后，回到 playscript 的实现。在 playscrip 的 Java 版本里，我们用一个 ClassObject 对象来保存对象数据，而 ClassObject 是 PlayObject 的子类。上一讲，我们已经讲过 PlayObject，它被栈桢用来保存本地变量，可以通过传入 Variable 来访问对象的属性值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="err">类的实例</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">public</span> <span class="k">class</span> <span class="n">ClassObject</span> <span class="k">extends</span> <span class="n">PlayObject</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="o">//</span> <span class="err">类型</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">protected</span> <span class="n">Class</span> <span class="n">type</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">...</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">//</span> <span class="err">保存对象数据</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">public</span> <span class="k">class</span> <span class="n">PlayObject</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">成员变量</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">protected</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Variable</span><span class="p">,</span> <span class="ne">Object</span><span class="o">&gt;</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Variable</span><span class="p">,</span> <span class="ne">Object</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">public</span> <span class="ne">Object</span> <span class="n">getValue</span><span class="p">(</span><span class="n">Variable</span> <span class="n">variable</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="ne">Object</span> <span class="n">rtn</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">variable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">rtn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">public</span> <span class="n">void</span> <span class="n">setValue</span><span class="p">(</span><span class="n">Variable</span> <span class="n">variable</span><span class="p">,</span> <span class="ne">Object</span> <span class="n">value</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">fields</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在运行期，当需要访问一个对象时，我们也会用 ClassObject 来做一个栈桢，这样就可以像访问本地变量一样访问对象的属性了。而不需要访问这个对象的时候，就把它从栈中移除，如果没有其他对象引用这个对象，那么它会被 Java 的垃圾收集机制回收。</p>
<h2 id="访问对象的属性和方法">访问对象的属性和方法</h2>
<p>在示例代码中，我们用点操作符来访问对象的属性和方法，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">mammal.speak();                          // 访问对象方法
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">println(&#34;mammal.name = &#34; + mammal.name); // 访问对象的属性
</span></span></code></pre></td></tr></table>
</div>
</div><p>属性和方法的引用也是一种表达式，语法定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">expression
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    : ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    | expression bop=&#39;.&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ( IDENTIFIER       // 对象属性
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      | functionCall     // 对象方法
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      )
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     ;
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意，点符号的操作可以是级联的，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">obj1.obj2.field1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">obj1.getObject2().field1;
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以，对表达式的求值，要能够获得正确的对象引用，你可以运行一下 ClassTest.play 脚本，或者去看看我的参考实现。</p>
<p>另外，对象成员还可以设置可见性。也就是说，有些成员只有对象内部才能用，有些可以由外部访问。这个怎么实现呢？这只是个语义问题，是在编译阶段做语义检查的时候，不允许私有的成员被外部访问，报编译错误就可以了，在其他方面，并没有什么不同。</p>
<h2 id="课程小结">课程小结</h2>
<p>我们针对面向对象的封装特性，从类型、作用域和生存期的角度进行了重新解读，这样能够更好地把握面向对象的本质特征。我们还设计了与面向对象的相关的语法并做了解析，然后讨论了面向对象程序的运行期机制，例如如何实例化一个对象，如何在内存里管理对象的数据，以及如何访问对象的属性和方法。</p>
<p>通过对类的语法和语义的剖析和运行机制的落地，我相信你会对面向对象的机制有更加本质的认识，也能更好地使用语言的面向对象特性了。</p>
<h2 id="一课一思">一课一思</h2>
<p>我们用比较熟悉的语法实现了面向对象的基础特性，像 Ruby、Go 这样的语言，还有另外的机制来实现面向对象。思考一下，你所熟悉的语言的面向对象机制，在底层是如何实现的？它们在类型、作用域和生存期三个方面的特点是什么？欢迎在留言区分享你的发现。</p>
<p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p>
<p>我将本节课相关代码的链接放在了文末，供你参考。</p>
<ul>
<li>playscript-java（项目目录）： <a href="./playscript-java.md">码云</a> <a href="./playscript-java.md">GitHub</a></li>
<li>PlayScript.java（入口程序）： <a href="./PlayScript.java.md">码云</a> <a href="./PlayScript.java.md">GitHub</a></li>
<li>PlayScript.g4（语法规则）： <a href="./PlayScript.g4.md">码云</a> <a href="./PlayScript.g4.md">GitHub</a></li>
<li>ASTEvaluator.java（解释器）： <a href="./ASTEvaluator.java.md">码云</a> <a href="./ASTEvaluator.java.md">GitHub</a></li>
<li>TypeAndScopeScanner.java（识别对象声明）： <a href="./TypeAndScopeScanner.java.md">码云</a> <a href="./TypeAndScopeScanner.java.md">GitHub</a></li>
<li>TypeResolver.java（消解变量声明中引用的类型）： <a href="./TypeResolver.java.md">码云</a> <a href="./TypeResolver.java.md">GitHub</a></li>
<li>RefResolver.java（消解变量引用和函数调用）： <a href="./RefResolver.java.md">码云</a> <a href="./RefResolver.java.md">GitHub</a></li>
<li>ClassTest.play（演示面向对象的基本特征）： <a href="./ClassTest.play.md">码云</a> <a href="./ClassTest.play.md">GitHub</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/77577e606d183349707a8a62717dc60c.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/">编译原理之美</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/09_%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E6%A1%88%E4%BE%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">09_架构设计原则案例</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/10x%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B3%95/09_%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%95%B0%E5%AD%97%E8%A1%A1%E9%87%8F%E5%90%97/">
            <span class="next-text nav-default">09_你的工作可以用数字衡量吗？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
