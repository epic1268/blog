<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>22_生成汇编代码（一）：汇编语言其实不难学 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content=" 敲黑板：课程用的是 GNU 汇编器，macOS 和 Linux 已内置，本文的汇编语言的写法是 GNU 汇编器规定的写法。Windows 系统可安装 MinGW 或 Linux 虚拟机。
对于静态编译型语言，比如 C 语言和 Go 语言，编译器后端的任务就是生成汇编代码，然后再由汇编器生成机器码，生成的文件叫目标文件，最后再使用链接器就能生成可执行文件或库文件了。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/22_%E7%94%9F%E6%88%90%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E4%B8%80%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%B6%E5%AE%9E%E4%B8%8D%E9%9A%BE%E5%AD%A6/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/22_%E7%94%9F%E6%88%90%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E4%B8%80%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%B6%E5%AE%9E%E4%B8%8D%E9%9A%BE%E5%AD%A6/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="22_生成汇编代码（一）：汇编语言其实不难学">
  <meta property="og:description" content="敲黑板：课程用的是 GNU 汇编器，macOS 和 Linux 已内置，本文的汇编语言的写法是 GNU 汇编器规定的写法。Windows 系统可安装 MinGW 或 Linux 虚拟机。
对于静态编译型语言，比如 C 语言和 Go 语言，编译器后端的任务就是生成汇编代码，然后再由汇编器生成机器码，生成的文件叫目标文件，最后再使用链接器就能生成可执行文件或库文件了。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="编译原理之美">

  <meta itemprop="name" content="22_生成汇编代码（一）：汇编语言其实不难学">
  <meta itemprop="description" content="敲黑板：课程用的是 GNU 汇编器，macOS 和 Linux 已内置，本文的汇编语言的写法是 GNU 汇编器规定的写法。Windows 系统可安装 MinGW 或 Linux 虚拟机。
对于静态编译型语言，比如 C 语言和 Go 语言，编译器后端的任务就是生成汇编代码，然后再由汇编器生成机器码，生成的文件叫目标文件，最后再使用链接器就能生成可执行文件或库文件了。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4805">
  <meta itemprop="keywords" content="编译原理之美">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="22_生成汇编代码（一）：汇编语言其实不难学">
  <meta name="twitter:description" content="敲黑板：课程用的是 GNU 汇编器，macOS 和 Linux 已内置，本文的汇编语言的写法是 GNU 汇编器规定的写法。Windows 系统可安装 MinGW 或 Linux 虚拟机。
对于静态编译型语言，比如 C 语言和 Go 语言，编译器后端的任务就是生成汇编代码，然后再由汇编器生成机器码，生成的文件叫目标文件，最后再使用链接器就能生成可执行文件或库文件了。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">22_生成汇编代码（一）：汇编语言其实不难学</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4805 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#了解汇编语言">了解汇编语言</a>
          <ul>
            <li></li>
          </ul>
        </li>
        <li><a href="#x86-64-架构的寄存器">x86-64 架构的寄存器</a></li>
        <li><a href="#课程小结">课程小结</a></li>
        <li><a href="#一课一思">一课一思</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<p>敲黑板：课程用的是 GNU 汇编器，macOS 和 Linux 已内置，本文的汇编语言的写法是 GNU 汇编器规定的写法。Windows 系统可安装 MinGW 或 Linux 虚拟机。</p>
</blockquote>
<p>对于静态编译型语言，比如 C 语言和 Go 语言，编译器后端的任务就是生成汇编代码，然后再由汇编器生成机器码，生成的文件叫目标文件，最后再使用链接器就能生成可执行文件或库文件了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/f5c087ea4cf3ba4c2e189d521b9c3d56.png" alt=""></p>
<p>就算像 JavaScript 这样的解释执行的语言，也要在运行时利用类似的机制生成机器码，以便调高执行的速度。Java 的字节码，在运行时通常也会通过 JIT 机制编译成机器码。<strong>而汇编语言是完成这些工作的基础。</strong></p>
<p>对你来说，掌握汇编语言是十分有益的，因为哪怕掌握一小点儿汇编技能，就能应用到某项工作中，比如，在 C 语言里嵌入汇编，实现某个特殊功能；或者读懂某些底层类库或驱动程序的代码，因为它可能是用汇编写的。</p>
<p>本节课，我先带你了解一下汇编语言，来个破冰之旅。然后在接下来的课程中再带你基于 AST 手工生成汇编代码，破除你对汇编代码的恐惧，了解编译期后端生成汇编代码的原理。</p>
<p>以后，当你看到高级语言的代码，以及 IR 时，就可以想象出来它对应的汇编代码是什么样子，实现从上层到底层认知的贯通。</p>
<h2 id="了解汇编语言">了解汇编语言</h2>
<p>机器语言都是 0101 的二进制的数据，不适合我们阅读。而汇编语言，简单来说，是可读性更好的机器语言，基本上每条指令都可以直接翻译成一条机器码。</p>
<p>跟你日常使用的高级语言相比，汇编语言的语法特别简单，但它要跟硬件（CPU 和内存）打交道，我们来体会一下。</p>
<p>计算机的处理器有很多不同的架构，比如 x86-64、ARM、Power 等，每种处理器的指令集都不相同，那也就意味着汇编语言不同。我们目前用的电脑，CPU 一般是 x86-64 架构，是 64 位机。（如不做特别说明，本课程都是以 x86-64 架构作为例子的）。</p>
<p>说了半天，汇编代码长什么样子呢？我用 C 语言写的例子来生成一下汇编代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char* argv[]){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    printf(&#34;Hello %s!\n&#34;, &#34;Richard&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 macOS 中输入下面的命令，其中的 -S 参数就是告诉编译器把源代码编译成汇编代码，而 -O2 参数告诉编译器进行 2 级优化，这样生成的汇编代码会短一些：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">clang -S -O2 hello.c -o hello.s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">或者：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">gcc -S -O2 hello.c -o hello.s
</span></span></code></pre></td></tr></table>
</div>
</div><p>生成的汇编代码是下面的样子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> .section    __TEXT,__text,regular,pure_instructions
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    .build_version macos, 10, 14    sdk_version 10, 14
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    .globl  _main                   ## -- Begin function main
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    .p2align    4, 0x90
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">_main:                                  ## @main
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    .cfi_startproc
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">## %bb.0:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    pushq   %rbp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    .cfi_def_cfa_offset 16
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    .cfi_offset %rbp, -16
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    movq    %rsp, %rbp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    .cfi_def_cfa_register %rbp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    leaq    L_.str(%rip), %rdi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    leaq    L_.str.1(%rip), %rsi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    xorl    %eax, %eax
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    callq   _printf
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    xorl    %eax, %eax
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    popq    %rbp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    retq
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    .cfi_endproc
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                        ## -- End function 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    .section    __TEXT,__cstring,cstring_literals
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">L_.str:                                 ## @.str
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    .asciz  &#34;Hello %s!\n&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> L_.str.1:                               ## @.str.1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    .asciz  &#34;Richard&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> .subsections_via_symbols
</span></span></code></pre></td></tr></table>
</div>
</div><p>你如果再打下面的命令，就会把这段汇编代码编译成可执行文件（在 macOS 或 Linux 执行 as 命令，就是调用了 GNU 的汇编器）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">as hello.s -o hello
</span></span></code></pre></td></tr></table>
</div>
</div><p>以上面的代码为例，来看一下汇编语言的组成元素。**这是汇编语言入门的基础，也是重点内容，在阅读时，你不需要死记硬背，而是要灵活掌握，**比如 CPU 的指令特别多，我们记住常用的就行了，不太常用的可以去查手册。</p>
<h4 id="1-汇编语言的组成元素">1. 汇编语言的组成元素</h4>
<p>这段代码里有<strong>指令、伪指令、标签和注释</strong>四种元素，每个元素单独占一行。</p>
<p>**指令（instruction）是直接由 CPU 进行处理的命令，**例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pushq   %rbp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">movq    %rsp, %rbp
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，开头的一个单词是助记符（mnemonic），后面跟着的是操作数（operand），有多个操作数时以逗号分隔。第二行代码的意思是把数据从这里（源）拷贝到那里（目的），这跟“请倒杯咖啡给我”这样的自然语句是一样的，先是动词（倒），然后是动词的作用对象（咖啡），再就是目的地（给我）。</p>
<p><strong>伪指令以“.”开头，末尾没有冒号“：”。</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">.section    __TEXT,__text,regular,pure_instructions
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">.globl  _main        
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">.asciz  &#34;Hello %s!\n&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>伪指令是是辅助性的，汇编器在生成目标文件时会用到这些信息，但伪指令不是真正的 CPU 指令，就是写给汇编器的。每种汇编器的伪指令也不同，要查阅相应的手册。</p>
<p>**标签以冒号“:”结尾，用于对伪指令生成的数据或指令做标记。**例如 L_.str: 标签是对一个字符串做了标记。其他代码可以访问标签，例如跳转到这个标签所标记的指令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">L_.str:                                 ## @.str
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    .asciz  &#34;Hello %s!\n&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>标签很有用，它可以代表一段代码或者常量的地址（也就是在代码区或静态数据区中的位置）。可一开始，我们没法知道这个地址的具体值，必须生成目标文件后，才能算出来。所以，标签会简化汇编代码的编写。</p>
<p><strong>第四种元素，注释，以“#”号开头，这跟 C 语言中以 // 表示注释语句是一样的。</strong></p>
<p>因为指令是汇编代码的主要部分，所以我们再把与指令有关的知识点展开讲解一下。</p>
<h4 id="2-详细了解指令这个元素">2. 详细了解指令这个元素</h4>
<p>在代码中，助记符“movq”“xorl”中的“mov”和“xor”是指令，而“q”和“l”叫做后缀，表示操作数的位数。后缀一共有 b, w, l, q 四种，分别代表 8 位、16 位、32 位和 64 位。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/77dc9fa3ff61273f8ffd2ea3d16e64fb.png" alt=""></p>
<p>比如，movq 中的 q 代表操作数是 8 个字节，也就是 64 位的。movq 就是把 8 字节从一个地方拷贝到另一个地方，而 movl 则是拷贝 4 个字节。</p>
<p>而在指令中使用操作数，可以使用四种格式，它们分别是：<strong>立即数、寄存器、直接内存访问和间接内存访问。</strong></p>
<p><strong>立即数以 $ 开头，</strong> <strong>比如 $40</strong>。（下面这行代码是把 40 这个数字拷贝到 %eax 寄存器）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">movl $40, %eax
</span></span></code></pre></td></tr></table>
</div>
</div><p>除此之外，我们在指令中最常见到的就是对寄存器的访问，GNU 的汇编器规定寄存器一定要以 % 开头。</p>
<p>**直接内存访问：**当我们在代码中看到操作数是一个数字时，它其实指的是内存地址。不要误以为它是一个数字，因为数字立即数必须以 $ 开头。另外，汇编代码里的标签，也会被翻译成直接内存访问的地址。比如“callq _printf”中的“_printf”是一个函数入口的地址。汇编器帮我们计算出程序装载在内存时，每个字面量和过程的地址。</p>
<p>**间接内存访问：**带有括号，比如（%rbp），它是指 %rbp 寄存器的值所指向的地址。</p>
<p>间接内存访问的完整形式是：</p>
<blockquote>
<p>偏移量（基址，索引值，字节数）这样的格式。</p>
</blockquote>
<p>其地址是：</p>
<blockquote>
<p>基址 + 索引值 * 字节数 + 偏移量</p>
</blockquote>
<p>举例来说：</p>
<blockquote>
<p>8(%rbp)，是比 %rbp 寄存器的值加 8。<br>
-8(%rbp)，是比 %rbp 寄存器的值减 8。<br>
（%rbp, %eax, 4）的值，等于 %rbp + %eax*4。这个地址格式相当于访问 C 语言中的数组中的元素，数组元素是 32 位的整数，其索引值是 %eax，而数组的起始位置是 %rbp。其中字节数只能取 1,2,4,8 四个值。</p>
</blockquote>
<p>你现在应该对指令的格式有所了解了，接下来，我们再学几个常用的指令：</p>
<p><strong>mov 指令</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">mov 寄存器 | 内存 | 立即数， 寄存器 | 内存
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个指令最常用到，用于在寄存器或内存之间传递数据，或者把立即数加载到内存或寄存器。mov 指令的第一个参数是源，可以是寄存器、内存或立即数。第二个参数是目的地，可以是寄存器或内存。</p>
<p><strong>lea 指令，lea 是“load effective address”的意思，装载有效地址。</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">lea 源，目的
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如前面例子代码中的 leaq 指令，是把字符串的地址加载到 %rdi 寄存器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">leaq    L_.str(%rip), %rdi
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>add 指令是做加法运算，它可以采取下面的格式：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">add 立即数， 寄存器 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">add 寄存器， 寄存器 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">add 内存， 寄存器 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">add 立即数， 内存 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">add 寄存器， 内存
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如，典型的 c=a+b 这样一个算术运算可能是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">movl -4(%rbp), %eax    # 把 %rbp-4 的值拷贝到 %eax
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">addl -8(%rbp), %eax   # 把 %rbp-8 地址的值加到 %eax 上
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">movl %eax, -12(%rbp)   # 把 %eax 的值写到内存地址 %rbp-12
</span></span></code></pre></td></tr></table>
</div>
</div><p>这三行代码，分别是操作 a、b、c 三个变量的地址。它们的地址分别比 %rbp 的值减 4、减 8、减 12，因此 a、b、c 三个变量每个都是 4 个字节长，也就是 32 位，它们是紧挨着存放的，并且是从高地址向低地址延伸的，这是栈的特征。</p>
<p><strong>除了 add 以外，其他算术运算的指令：</strong></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/ce083dff8a0a5dc8bdf655d8708f503f.png" alt=""></p>
<p><strong>与栈有关的操作：</strong></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/c237cb231ddef2b4516062ef6121327c.png" alt=""></p>
<p><strong>跳转类：</strong></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/cac4a1b381758525a3b82112758678b2.png" alt=""></p>
<p><strong>过程调用：</strong></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/8d88493461c1e85f5ca5a21b051c501c.png" alt=""></p>
<p><strong>比较操作：</strong></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/cb283d1d9afcb065e111326e9494b11a.png" alt=""></p>
<p>以上我列举的指令，是你在编写汇编代码时，经常会用到的，比较重要，会满足你编写简单汇编程序的需求，所以你需要重点关注。</p>
<p>x86-64 是复杂指令集的处理器，有非常多的指令，差不多有上千条，全部记住是比较难的。更好的办法，是记住主要的指令，其他指令在使用时去查<a href="./intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.md">Intel 公司的手册</a>，在这里我就不举例了。</p>
<h2 id="x86-64-架构的寄存器">x86-64 架构的寄存器</h2>
<p>在汇编代码中，我们经常要使用各种以 % 开头的寄存器的符号。初学者阅读这些代码时，通常会有一些疑问：有几个寄存器可以用？我可以随便用它们吗？使用不当会不会造成错误？等等。所以，有必要让你熟悉一下这些寄存器，了解它们的使用方法。</p>
<p>x86-64 架构的 CPU 里有很多寄存器，我们在代码里最常用的是 16 个 64 位的通用寄存器，分别是：</p>
<blockquote>
<p>%rax，%rbx，%rcx，%rdx，%rsi，%rdi，%rbp，%rsp， %r8，%r9，%r10，%r11，%r12，%r13，%r14，%r15。</p>
</blockquote>
<p>这些寄存器在历史上有各自的用途，比如，rax 中的“a”，是 Accumulator(累加器) 的意思，这个寄存器是累加寄存器。</p>
<p>但随着技术的发展，这些寄存器基本上都成为了通用的寄存器，不限于某种特定的用途。但是，为了方便软件的编写，我们还是做了一些约定，给这些寄存器划分了用途。针对 x86-64 架构有多个调用约定（Calling Convention），包括微软的 x64 调用约定（Windows 系统）、System V AMD64 ABI（Unix 和 Linux 系统）等，下面的内容属于后者：</p>
<ul>
<li>%rax 除了其他用途外，通常在函数返回的时候，把返回值放在这里。</li>
<li>%rsp 作为栈指针寄存器，指向栈顶。</li>
<li>%rdi，%rsi，%rdx，%rcx，%r8，%r9 给函数传整型参数，依次对应第 1 参数到第 6 参数。超过 6 个参数怎么办？放在栈桢里，我们<a href="./146635.md">21 讲</a>已经讲过了。</li>
<li>如果程序要使用 %rbx，%rbp，%r12，%r13，%r14，%r15 这几个寄存器，是由被调用者（Callee）负责保护的，也就是写到栈里，在返回的时候要恢复这些寄存器中原来的内容。其他寄存器的内容，则是由调用者（Caller）负责保护，如果不想这些寄存器中的内容被破坏，那么要自己保护起来。</li>
</ul>
<p>上面这些寄存器的名字都是 64 位的名字，对于每个寄存器，我们还可以只使用它的一部分，并且另起一个名字。比如对于 %rax，如果使用它的前 32 位，就叫做 %eax，前 16 位叫 %ax，前 8 位（0 到 7 位）叫 %al，8 到 15 位叫 %ah。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/d615bc4449a916b3282f66f4297ee2ce.png" alt=""></p>
<p>其他的寄存器也有这样的使用方式，当你在汇编代码中看到这些名称的时候，你就知道其实它们有可能在物理上是同一个寄存器。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/7ed074afcc220a665cdc30c6279f72c3.png" alt=""></p>
<p>除了通用寄存器以外，有可能的话，还要了解下面的寄存器和它们的用途，我们写汇编代码时也经常跟它们发生关联：</p>
<ul>
<li>8 个 80 位的 x87 寄存器，用于做浮点计算；</li>
<li>8 个 64 位的 MMX 寄存器，用于 MMX 指令（即多媒体指令），这 8 个跟 x87 寄存器在物理上是相同的寄存器。在传递浮点数参数的时候，要用 mmx 寄存器。</li>
<li>16 个 128 位的 SSE 寄存器，用于 SSE 指令。我们将在应用篇里使用 SSE 指令，讲解 SIMD 的概念。</li>
<li>指令寄存器，rip，保存指令地址。CPU 总是根据这个寄存器来读取指令。</li>
<li>flags（64 位：rflags, 32 位：eflags）寄存器：每个位用来标识一个状态。比如，它们会用于比较和跳转的指令，比如 if 语句翻译成的汇编代码，就会用它们来保存 if 条件的计算结果。</li>
</ul>
<p>总的来说，我们的汇编代码处处要跟寄存器打交道，正确和高效使用寄存器，是编译期后端的重要任务之一。</p>
<h2 id="课程小结">课程小结</h2>
<p>本节课，我讲解了汇编语言的一些基础知识，由于汇编语言的特点，涉及的知识点和细节比较多，在这个过程中，你无需死记硬背，只需要掌握几个重点内容：</p>
<p>1. 汇编语言是由指令、标签、伪指令和注释构成的。其中主要内容都是指令。指令包含一个该指令的助记符和操作数。操作数可以使用直接数、寄存器，以及用两种方式访问内存地址。</p>
<p>2. 汇编指令中会用到一些通用寄存器。这些寄存器除了用于计算以外，还可以根据调用约定帮助传递参数和返回值。使用寄存器时，要区分由调用者还是被调用者负责保护寄存器中原来的内容。</p>
<p>另外，我们还要注意按照一定的规则维护和使用栈桢，<strong>这个知识点会在后面的加餐中展开来讲一个例子。</strong></p>
<p>鉴于你可能是第一次使用汇编语言，所以我<strong>提供两个建议，让你快速上手汇编语言：</strong></p>
<p>1. 你可以用 C 语言写一些示例代码，然后用编译器生成汇编代码，看看能否看懂。</p>
<p>2. 模仿文稿中的例子，自己改写并运行你自己的汇编程序，这个过程中，你会发现真的没那么难。</p>
<h2 id="一课一思">一课一思</h2>
<p>你之前学习过或者在项目中使用过汇编语言吗？感受是什么呢？有什么经验和体会呢？欢迎在留言区分享你的经验与感受。</p>
<p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/77577e606d183349707a8a62717dc60c.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/">编译原理之美</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80%E8%AF%BE/22_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0__%E7%A9%BA%E5%B1%B1%E9%B8%A3%E5%93%8D%E9%9D%99%E6%B0%B4%E6%B5%81%E6%B7%B1%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">22_深度学习__空山鸣响，静水流深：深度学习概述</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/22_%E6%83%B3%E6%88%90%E4%B8%BA%E6%9E%B6%E6%9E%84%E5%B8%88%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93cap%E7%90%86%E8%AE%BA/">
            <span class="next-text nav-default">22_想成为架构师，你必须知道CAP理论</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
