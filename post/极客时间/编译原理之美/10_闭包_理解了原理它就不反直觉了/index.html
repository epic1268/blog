<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>10_闭包：_理解了原理，它就不反直觉了 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="在讲作用域和生存期时，我提到函数里的本地变量只能在函数内部访问，函数退出之后，作用域就没用了，它对应的栈桢被弹出，作用域中的所有变量所占用的内存也会被收回。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/10_%E9%97%AD%E5%8C%85_%E7%90%86%E8%A7%A3%E4%BA%86%E5%8E%9F%E7%90%86%E5%AE%83%E5%B0%B1%E4%B8%8D%E5%8F%8D%E7%9B%B4%E8%A7%89%E4%BA%86/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/10_%E9%97%AD%E5%8C%85_%E7%90%86%E8%A7%A3%E4%BA%86%E5%8E%9F%E7%90%86%E5%AE%83%E5%B0%B1%E4%B8%8D%E5%8F%8D%E7%9B%B4%E8%A7%89%E4%BA%86/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="10_闭包：_理解了原理，它就不反直觉了">
  <meta property="og:description" content="在讲作用域和生存期时，我提到函数里的本地变量只能在函数内部访问，函数退出之后，作用域就没用了，它对应的栈桢被弹出，作用域中的所有变量所占用的内存也会被收回。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="编译原理之美">

  <meta itemprop="name" content="10_闭包：_理解了原理，它就不反直觉了">
  <meta itemprop="description" content="在讲作用域和生存期时，我提到函数里的本地变量只能在函数内部访问，函数退出之后，作用域就没用了，它对应的栈桢被弹出，作用域中的所有变量所占用的内存也会被收回。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6105">
  <meta itemprop="keywords" content="编译原理之美">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="10_闭包：_理解了原理，它就不反直觉了">
  <meta name="twitter:description" content="在讲作用域和生存期时，我提到函数里的本地变量只能在函数内部访问，函数退出之后，作用域就没用了，它对应的栈桢被弹出，作用域中的所有变量所占用的内存也会被收回。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">10_闭包：_理解了原理，它就不反直觉了</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6105 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#闭包的内在矛盾">闭包的内在矛盾</a></li>
        <li><a href="#函数作为一等公民">函数作为一等公民</a></li>
        <li><a href="#实现我们自己的闭包机制">实现我们自己的闭包机制</a></li>
        <li><a href="#体验一下函数式编程">体验一下函数式编程</a></li>
        <li><a href="#课程小结">课程小结</a></li>
        <li><a href="#一课一思">一课一思</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>在讲作用域和生存期时，我提到函数里的本地变量只能在函数内部访问，函数退出之后，作用域就没用了，它对应的栈桢被弹出，作用域中的所有变量所占用的内存也会被收回。</p>
<p>但偏偏跑出来**闭包（Closure）**这个怪物。</p>
<p>在 JavaScript 中，用外层函数返回一个内层函数之后，这个内层函数能一直访问外层函数中的本地变量。按理说，这个时候外层函数已经退出了，它里面的变量也该作废了。可闭包却非常执着，即使外层函数已经退出，但内层函数仿佛不知道这个事实一样，还继续访问外层函数中声明的变量，并且还真的能够正常访问。</p>
<p>不过，闭包是很有用的，对库的编写者来讲，它能隐藏内部实现细节；对面试者来讲，它几乎是前端面试必问的一个问题，比如如何用闭包特性实现面向对象编程？等等。</p>
<p>本节课，我会带你研究闭包的实现机制，让你深入理解作用域和生存期，更好地使用闭包特性。为此，要解决两个问题：</p>
<ul>
<li>**函数要变成 playscript 的一等公民。**也就是要能把函数像普通数值一样赋值给变量，可以作为参数传递给其他函数，可以作为函数的返回值。</li>
<li><strong>要让内层函数一直访问它环境中的变量，不管外层函数退出与否。</strong></li>
</ul>
<p>我们先通过一个例子，研究一下闭包的特性，看看它另类在哪里。</p>
<h2 id="闭包的内在矛盾">闭包的内在矛盾</h2>
<p>来测试一下 JavaScript 的闭包特性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">/**</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="n">clojure</span><span class="o">.</span><span class="n">js</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="err">测试闭包特性</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="err">作者：宫文学</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">var</span> <span class="n">fun1</span> <span class="o">=</span> <span class="n">function</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                <span class="o">//</span> <span class="err">函数内的局部变量</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="k">var</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">function</span><span class="p">(){</span>   <span class="o">//</span> <span class="err">内部的一个函数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">b</span><span class="p">;</span>             <span class="o">//</span> <span class="err">返回内部的成员</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="n">inner</span><span class="p">;</span>             <span class="o">//</span> <span class="err">返回一个函数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&#34;outside:  a=</span><span class="si">%d</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">var</span> <span class="n">fun2</span> <span class="o">=</span> <span class="n">fun1</span><span class="p">();</span>                            <span class="o">//</span> <span class="err">生成闭包</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&#34;fun2: b=</span><span class="si">%d</span><span class="s2"> a=</span><span class="si">%d</span><span class="s2">&#34;</span><span class="p">,</span><span class="n">fun2</span><span class="p">(),</span> <span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="err">通过</span> <span class="n">fun2</span><span class="p">()</span> <span class="err">来访问</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">var</span> <span class="n">fun3</span> <span class="o">=</span> <span class="n">fun1</span><span class="p">();</span>                            <span class="o">//</span> <span class="err">生成第二个闭包</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&#34;fun3: b=</span><span class="si">%d</span><span class="s2"> a=</span><span class="si">%d</span><span class="s2">&#34;</span><span class="p">,</span><span class="n">fun3</span><span class="p">(),</span> <span class="n">a</span><span class="p">);</span> <span class="o">//</span> <span class="n">b</span> <span class="err">等于</span> <span class="mi">1</span><span class="err">，重新开始</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 Node.js 环境下运行上面这段代码的结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">outside:  a=0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">fun2: b=1 a=1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">fun2: b=2 a=2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">fun3: b=1 a=3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">fun3: b=2 a=4
</span></span></code></pre></td></tr></table>
</div>
</div><p>观察这个结果，可以得出两点：</p>
<ul>
<li>内层的函数能访问它“看得见”的变量，包括自己的本地变量、外层函数的变量 b 和全局变量 a。</li>
<li>内层函数作为返回值赋值给其他变量以后，外层函数就结束了，但内层函数仍能访问原来外层函数的变量 b，也能访问全局变量 a。</li>
</ul>
<p>这样似乎让人感到困惑：站在外层函数的角度看，明明这个函数已经退出了，变量 b 应该失效了，为什么还可以继续访问？但是如果换个立场，站在 inner 这个函数的角度来看，声明 inner 函数的时候，告诉它可以访问 b，不能因为把 inner 函数赋值给了其他变量，inner 函数里原本正确的语句就不能用了啊。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/905804756493ee781f46d200be8d9aaf.png" alt="图片：https://uploader.shimo.im/f/ZmhV8tamLjo5KkP4.png"></p>
<p>其实，只要函数能作为值传来传去，就一定会产生作用域不匹配的情况，这样的内在矛盾是语言设计时就决定了的。**我认为，闭包是为了让函数能够在这种情况下继续运行所提供的一个方案。**这个方案有一些不错的特点，比如隐藏函数所使用的数据，歪打正着反倒成了一个优点了！</p>
<p>在这里，我想补充一下**静态作用域（Static Scope）**这个知识点，如果一门语言的作用域是静态作用域，那么符号之间的引用关系能够根据程序代码在编译时就确定清楚，在运行时不会变。某个函数是在哪声明的，就具有它所在位置的作用域。它能够访问哪些变量，那么就跟这些变量绑定了，在运行时就一直能访问这些变量。</p>
<p>看一看下面的代码，对于静态作用域而言，无论在哪里调用 foo() 函数，访问的变量 i 都是全局变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int i = 1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void foo(){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  println(i); // 访问全局变量
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> foo();        // 访问全局变量
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> void bar(){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  int i = 2; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  foo();      // 在这里调用 foo()，访问的仍然是全局变量
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们目前使用的大多数语言都是采用静态作用域的。playscript 语言也是在编译时就形成一个 Scope 的树，变量的引用也是在编译时就做了消解，不再改变，所以也是采用了静态作用域。</p>
<p>反过来讲，如果在 bar() 里调用 foo() 时，foo() 访问的是 bar() 函数中的本地变量 i，那就说明这门语言使用的是<strong>动态作用域（Dynamic Scope）</strong>。也就是说，变量引用跟变量声明不是在编译时就绑定死了的。在运行时，它是在运行环境中动态地找一个相同名称的变量。在 macOS 或 Linux 中用的 bash 脚本语言，就是动态作用域的。</p>
<p>静态作用域可以由程序代码决定，在编译时就能完全确定，所以又叫做词法作用域（Lexcical Scope）。不过这个词法跟我们做词法分析时说的词法不大一样。这里，跟 Lexical 相对应的词汇可以认为是 Runtime，一个是编写时，一个是运行时。</p>
<p>用静态作用域的概念描述一下闭包，我们可以这样说：因为我们的语言是静态作用域的，它能够访问的变量，需要一直都能访问，为此，需要把某些变量的生存期延长。</p>
<p>当然了，闭包的产生还有另一个条件，就是让函数成为一等公民。这是什么意思？我们又怎样实现呢？</p>
<h2 id="函数作为一等公民">函数作为一等公民</h2>
<p>在 JavaScript 和 Python 等语言里，函数可以像数值一样使用，比如给变量赋值、作为参数传递给其他函数，作为函数返回值等等。<strong>这时，我们就说函数是一等公民。</strong></p>
<p>作为一等公民的函数很有用，比如它能处理数组等集合。我们给数组的 map 方法传入一个回调函数，结果会生成一个新的数组。整个过程很简洁，没有出现啰嗦的循环语句，这也是很多人提倡函数式编程的原因之一：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">newArray</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;1&#34;</span><span class="p">,</span><span class="s2">&#34;2&#34;</span><span class="p">,</span><span class="s2">&#34;3&#34;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">fucntion</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">array</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="n">parseInt</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么在 playscript 中，怎么把函数作为一等公民呢？</p>
<p>我们需要支持函数作为基础类型，这样就可以用这种类型声明变量。但问题来了，如何声明一个函数类型的变量呢？</p>
<p>在 JavaScript 这种动态类型的语言里，我们可以把函数赋值给任何一个变量，就像前面示例代码里的那样：inner 函数作为返回值，被赋给了 fun2 和 fun3 两个变量。</p>
<p>然而在 Go 语言这样要求严格类型匹配的语言里，就比较复杂了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">type</span> <span class="n">funcType</span> <span class="k">func</span><span class="p">(</span><span class="ne">int</span><span class="p">)</span> <span class="ne">int</span> <span class="o">//</span> <span class="n">Go</span> <span class="err">语言，声明了一个函数类型</span> <span class="n">funcType</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">myFun</span> <span class="n">funType</span>          <span class="o">//</span> <span class="err">用这个函数类型声明了一个变量</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它对函数的原型有比较严格的要求：函数必须有一个 int 型的参数，返回值也必须是 int 型的。</p>
<p>而 C 语言中函数指针的声明也是比较严格的，在下面的代码中，myFun 指针能够指向一个函数，这个函数也是有一个 int 类型的参数，返回值也是 int：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int (*myFun) (int);        //C 语言，声明一个函数指针
</span></span></code></pre></td></tr></table>
</div>
</div><p>playscript 也采用这种比较严格的声明方式，因为我们想实现一个静态类型的语言：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">function int (int) myFun;  //playscript 中声明一个函数型的变量
</span></span></code></pre></td></tr></table>
</div>
</div><p>写成上面这样是因为我个人喜欢把变量名称左边的部分看做类型的描述，不像 Go 语言把类型放在变量名称后面。最难读的就是 C 语言那种声明方式了，竟然把变量名放在了中间。当然，这只是个人喜好。</p>
<p>把上面描述函数类型的语法写成 Antlr 的规则如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">functionType
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    : FUNCTION typeTypeOrVoid &#39;(&#39; typeList? &#39;)&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> typeList
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    : typeType (&#39;,&#39; typeType)*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ;
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 playscript 中，我们用 FuntionType 接口代表一个函数类型，通过这个接口可以获得返回值类型、参数类型这两个信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">package play;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">import java.util.List;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * 函数类型
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public interface FunctionType extends Type {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Type getReturnType();        // 返回值类型
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public List&lt;Type&gt; getParamTypes();  // 参数类型
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>试一下实际使用效果如何，用 Antlr 解析下面这句的语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">function int(long, float) fun2 = fun1();
</span></span></code></pre></td></tr></table>
</div>
</div><p>它的意思是：调用 fun1() 函数会返回另一个函数，这个函数有两个参数，返回值是 int 型的。</p>
<p>我们用 grun 显示一下 AST，你可以看到，它已经把 functionType 正确地解析出来了：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/4bb6ceec7fdf0efb2c57ba377c5ae891.png" alt="图片：https://uploader.shimo.im/f/812ANkYxJU8Xc6Kp.png"></p>
<p>目前，我们只是设计完了语法，还要实现运行期的功能，让函数真的能像数值一样传来传去，就像下面的测试代码，它把 foo() 作为值赋给了 bar()：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">FirstClassFunction.play 函数作为一等公民。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">也就是函数可以数值，赋给别的变量。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">支持函数类型，即 FunctionType。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">*/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int foo(int a){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    println(&#34;in foo, a = &#34; + a);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return a;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> int bar (function int(int) fun){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int b = fun(6);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    println(&#34;in bar, b = &#34; + b);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return b;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> function int(int) a = foo;  // 函数作为变量初始化值
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">a(4);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> function int(int) b;        
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b = foo;                    // 函数用于赋值语句
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b(5);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> bar(foo);                   // 函数做为参数
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">in foo, a = 4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">in foo, a = 5
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">in foo, a = 6
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">in bar, b = 6
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行这段代码，你会发现它实现了用函数来赋值，而实现这个功能的重点，是做好语义分析。比如编译程序要能识别赋值语句中的 foo 是一个函数，而不是一个传统的值。在调用 a() 和 b() 的时候，它也要正确地调用 foo() 的代码，而不是报“找不到 a() 函数的定义”这样的错误。</p>
<p>实现了一等公民函数的功能以后，我们进入本讲最重要的一环：<strong>实现闭包功能。</strong></p>
<h2 id="实现我们自己的闭包机制">实现我们自己的闭包机制</h2>
<p>在这之前，我想先设计好测试用例，所以先把一开始提到的那个 JavaScript 的例子用 playscript 的语法重写一遍，来测试闭包功能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * clojure.play
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * 测试闭包特性
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int a = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> function int() fun1(){        // 函数的返回值是一个函数
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int b = 0;                // 函数内的局部变量
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     int inner(){              // 内部的一个函数
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        a = a+1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        b = b+1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        return b;             // 返回内部的成员
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     return inner;             // 返回一个函数
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> function int() fun2 = fun1();  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">for (int i = 0; i&lt; 3; i++){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    println(&#34;b = &#34; + fun2() + &#34;, a = &#34;+a);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> function int() fun3 = fun1();  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">for (int i = 0; i&lt; 3; i++){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    println(&#34;b = &#34; + fun3() + &#34;, a = &#34;+a);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码的运行效果跟 JavaScript 版本的程序是一样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b = 1, a = 1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b = 2, a = 2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b = 3, a = 3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b = 1, a = 4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b = 2, a = 5
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b = 3, a = 6
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码的 AST 我也让 grun 显示出来了，并截了一部分图，你可以直观地看一下外层函数和内层函数的关系：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/3ecee0bf1ab530e94132655b197b2c25.png" alt="图片：https://uploader.shimo.im/f/vaWRcnserakKhNWs.png"></p>
<p>现在，测试用例准备好了，我们着手实现一下闭包的机制。</p>
<p>前面提到，闭包的内在矛盾是运行时的环境和定义时的作用域之间的矛盾。那么我们把内部环境中需要的变量，打包交给闭包函数，它就可以随时访问这些变量了。</p>
<p>在 AST 上做一下图形化的分析，看看给 fun2 这个变量赋值的时候，发生了什么事情：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/363b508f5130354563cdfcaf7144ddbd.png" alt=""></p>
<p>简单地描述一下给 fun2 赋值时的执行过程：</p>
<ul>
<li>先执行 fun1() 函数，内部的 inner() 函数作为返回值返回给调用者。这时，程序能访问两层作用域，最近一层是 fun1()，里面有变量 b；外层还有一层，里面有全局变量 a。这时是把环境变量打包的最后的机会，否则退出 fun1() 函数以后，变量 b 就消失了。</li>
<li>然后把内部函数连同打包好的环境变量的值，创建一个 FunctionObject 对象，作为 fun1() 的返回值，给到调用者。</li>
<li>给 fun2 这个变量赋值。</li>
<li>调用 fun2() 函数。函数执行时，有一个私有的闭包环境可以访问 b 的值，这个环境就是第二步所创建的 FunctionObject 对象。</li>
</ul>
<p><strong>最终，我们实现了闭包的功能。</strong></p>
<p>在这个过程中，我们要提前记录下 inner() 函数都引用了哪些外部变量，以便对这些变量打包。这是在对程序做语义分析时完成的，你可以参考一下 ClosureAnalyzer.java 中的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">/**</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="err">为某个函数计算闭包变量，也就是它所引用的外部环境变量。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="err">算法：计算所有的变量引用，去掉内部声明的变量，剩下的就是外部的。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="err">@</span><span class="n">param</span> <span class="n">function</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="err">@</span><span class="k">return</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="o">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">private</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Variable</span><span class="o">&gt;</span> <span class="n">calcClosureVariables</span><span class="p">(</span><span class="n">Function</span> <span class="n">function</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Variable</span><span class="o">&gt;</span> <span class="n">refered</span> <span class="o">=</span> <span class="n">variablesReferedByScope</span><span class="p">(</span><span class="n">function</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Variable</span><span class="o">&gt;</span> <span class="n">declared</span> <span class="o">=</span> <span class="n">variablesDeclaredUnderScope</span><span class="p">(</span><span class="n">function</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">refered</span><span class="o">.</span><span class="n">removeAll</span><span class="p">(</span><span class="n">declared</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">refered</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面是 ASTEvaluator.java 中把环境变量打包进闭包中的代码片段，它是在当前的栈里获取数据的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">/**</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="err">为闭包获取环境变量的值</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="err">@</span><span class="n">param</span> <span class="n">function</span> <span class="err">闭包所关联的函数。这个函数会访问一些环境变量。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="err">@</span><span class="n">param</span> <span class="n">valueContainer</span>  <span class="err">存放环境变量的值的容器</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">private</span> <span class="n">void</span> <span class="n">getClosureValues</span><span class="p">(</span><span class="n">Function</span> <span class="n">function</span><span class="p">,</span> <span class="n">PlayObject</span> <span class="n">valueContainer</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">closureVariables</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">Variable</span> <span class="k">var</span> <span class="p">:</span> <span class="n">function</span><span class="o">.</span><span class="n">closureVariables</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="o">//</span> <span class="err">现在还可以从栈里取，退出函数以后就不行了</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">LValue</span> <span class="n">lValue</span> <span class="o">=</span> <span class="n">getLValue</span><span class="p">(</span><span class="k">var</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="ne">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">lValue</span><span class="o">.</span><span class="n">getValue</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">valueContainer</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="k">var</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>你可以把测试用例跑一跑，修改一下，试试其他闭包特性。</p>
<h2 id="体验一下函数式编程">体验一下函数式编程</h2>
<p>现在，我们已经实现了闭包的机制，函数也变成了一等公民。不经意间，我们似乎在一定程度上支持了函数式编程（functional programming）。</p>
<p>它是一种语言风格，有很多优点，比如简洁、安全等。备受很多程序员推崇的 LISP 语言就具备函数式编程特征，Java 等语言也增加了函数式编程的特点。</p>
<p>函数式编程的一个典型特点就是高阶函数（High-order function）功能，高阶函数是这样一种函数，它能够接受其他函数作为自己的参数，javascript 中数组的 map 方法，就是一个高阶函数。我们通过下面的例子测试一下高阶函数功能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">LinkedList.play
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">实现了一个简单的链表，并演示了高阶函数的功能，比如在 javascript 中常用的 map 功能，
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">它能根据遍历列表中的每个元素，执行一个函数，并返回一个新的列表。给它传不同的函数，会返回不同的列表。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">*/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 链表的节点
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class ListNode{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int value;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ListNode next; // 下一个节点
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     ListNode (int v){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        value = v;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 链表
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class LinkedList{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ListNode start;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ListNode end;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     // 添加新节点
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void add(int value){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ListNode node = ListNode(value);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (start == null){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            start = node;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            end = node;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        else{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            end.next = node;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            end = node;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     // 打印所有节点内容
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void dump(){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ListNode node = start;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        while (node != null){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            println(node.value);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            node = node.next;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     // 高阶函数功能，参数是一个函数，对每个成员做一个计算，形成一个新的 LinkedList
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    LinkedList map(function int(int) fun){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ListNode node = start;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        LinkedList newList = LinkedList();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        while (node != null){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            int newValue = fun(node.value);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            newList.add(newValue);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            node = node.next;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        return newList;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 函数：平方值
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int square(int value){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return value * value;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 函数：加 1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int addOne(int value){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return value + 1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> LinkedList list = LinkedList();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">list.add(2);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">list.add(3);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">list.add(5);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> println(&#34;original list:&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">list.dump();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> println();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">println(&#34;add 1 to each element:&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">LinkedList list2 = list.map(addOne);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">list2.dump();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> println();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">println(&#34;square of each element:&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">LinkedList list3 = list.map(square);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">list3.dump();
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行后得到的结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">original list:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">5
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> add 1 to each element:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">6
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> square of each element:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">9
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">25
</span></span></code></pre></td></tr></table>
</div>
</div><p>高阶函数功能很好玩，你可以修改程序，好好玩一下。</p>
<h2 id="课程小结">课程小结</h2>
<p>闭包这个概念，对于初学者来讲是一个挑战。其实，闭包就是把函数在静态作用域中所访问的变量的生存期拉长，形成一份可以由这个函数单独访问的数据。正因为这些数据只能被闭包函数访问，所以也就具备了对信息进行封装、隐藏内部细节的特性。</p>
<p>听上去是不是有点儿耳熟？封装，把数据和对数据的操作封在一起，这不就是面向对象编程嘛！一个闭包可以看做是一个对象。反过来看，一个对象是不是也可以看做一个闭包呢？对象的属性，也可以看做被方法所独占的环境变量，其生存期也必须保证能够被方法一直正常的访问。</p>
<p>你看，两个不相干的概念，在用作用域和生存期这样的话语体系去解读之后，就会很相似，在内部实现上也可以当成一回事。现在，你应该更清楚了吧？</p>
<h2 id="一课一思">一课一思</h2>
<p>思考一下我在开头提到的那个面试题：如何用闭包做类似面向对象的编程？</p>
<p>其实，我在课程中提供了一个 closure-mammal.play 的示例代码，它完全用闭包的概念实现了面向对象编程的多态特征。而这个闭包的实现，是一种更高级的闭包，比普通的函数闭包还多了一点有用的特性，更像对象了。我希望你能发现它到底不同在哪里，也能在代码中找到实现这些特性的位置。</p>
<p>你能发现，我一直在讲作用域和生存期，不要嫌我啰嗦，把它们吃透，会对你使用语言有很大帮助。比如，有同学非常困扰 JavaScript 的 this，我负责任地讲，只要对作用域有清晰的了解，你就能很容易地掌握 this。</p>
<p>那么，关于作用域跟 this 之间的关联，如果你有什么想法，也欢迎在留言区分享。</p>
<p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友，特别是分享给那些还没搞清楚闭包的朋友。</p>
<p>本节课的示例代码放在了文末，供你参考。</p>
<ul>
<li>playscript-java（项目目录）： <a href="./playscript-java.md">码云</a> <a href="./playscript-java.md">GitHub</a></li>
<li>PlayScript.java（入口程序）： <a href="./PlayScript.java.md">码云</a> <a href="./PlayScript.java.md">GitHub</a></li>
<li>PlayScript.g4（语法规则）： <a href="./PlayScript.g4.md">码云</a> <a href="./PlayScript.g4.md">GitHub</a></li>
<li>ASTEvaluator.java（解释器，找找闭包运行期时怎么实现的）： <a href="./ASTEvaluator.java.md">码云</a> <a href="./ASTEvaluator.java.md">GitHub</a></li>
<li>ClosureAnalyzer.java（分析闭包所引用的环境变量）：<a href="./ClosureAnalyzer.java.md">码云</a> <a href="./ClosureAnalyzer.java.md">GitHub</a></li>
<li>RefResolver.java（在这里看看函数型变量是怎么消解的）： <a href="./RefResolver.java.md">码云</a> <a href="./RefResolver.java.md">GitHub</a></li>
<li>closure.play（演示基本的闭包特征）： <a href="./closure.play.md">码云</a> <a href="./closure.play.md">GitHub</a></li>
<li>closure-fibonacci.play（用闭包实现了斐波那契数列计算）：<a href="./closure-fibonacci.play.md">码云</a> <a href="./closure-fibonacci.play.md">GitHub</a></li>
<li>closure-mammal.play（用闭包实现了面向对象特性，请找找它比普通闭包强在哪里）：<a href="./closure-mammal.play.md">码云</a> <a href="./closure-mammal.play.md">GitHub</a></li>
<li>FirstClassFunction.play（演示一等公民函数的特征）：<a href="./FirstClassFunction.play.md">码云</a> <a href="./FirstClassFunction.play.md">GitHub</a></li>
<li>LinkedList.play（演示了高阶函数 map）：<a href="./LinkedList.play.md">码云</a> <a href="./LinkedList.play.md">GitHub</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/77577e606d183349707a8a62717dc60c.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/">编译原理之美</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/10_webrtc_nat%E7%A9%BF%E8%B6%8A%E5%8E%9F%E7%90%86/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">10_WebRTC_NAT穿越原理</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%88%B1%E4%B8%8A%E8%B7%91%E6%AD%A5/10_%E5%8F%82%E5%8A%A0%E4%BA%8620%E5%9C%BA%E9%A9%AC%E6%8B%89%E6%9D%BE%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E7%9A%84/">
            <span class="next-text nav-default">10_参加了20场马拉松，我是如何准备的？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
