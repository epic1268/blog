<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>26_生成IR：实现静态编译的语言 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="目前来讲，你已经初步了解了 LLVM 和它的 IR，也能够使用它的命令行工具。**不过，我们还是要通过程序生成 LLVM 的 IR，**这样才能复用 LLVM 的功能，从而实现一门完整的语言。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/26_%E7%94%9F%E6%88%90ir%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E7%9A%84%E8%AF%AD%E8%A8%80/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/26_%E7%94%9F%E6%88%90ir%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E7%9A%84%E8%AF%AD%E8%A8%80/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="26_生成IR：实现静态编译的语言">
  <meta property="og:description" content="目前来讲，你已经初步了解了 LLVM 和它的 IR，也能够使用它的命令行工具。**不过，我们还是要通过程序生成 LLVM 的 IR，**这样才能复用 LLVM 的功能，从而实现一门完整的语言。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="编译原理之美">

  <meta itemprop="name" content="26_生成IR：实现静态编译的语言">
  <meta itemprop="description" content="目前来讲，你已经初步了解了 LLVM 和它的 IR，也能够使用它的命令行工具。**不过，我们还是要通过程序生成 LLVM 的 IR，**这样才能复用 LLVM 的功能，从而实现一门完整的语言。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5401">
  <meta itemprop="keywords" content="编译原理之美">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="26_生成IR：实现静态编译的语言">
  <meta name="twitter:description" content="目前来讲，你已经初步了解了 LLVM 和它的 IR，也能够使用它的命令行工具。**不过，我们还是要通过程序生成 LLVM 的 IR，**这样才能复用 LLVM 的功能，从而实现一门完整的语言。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">26_生成IR：实现静态编译的语言</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5401 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#llvm-ir-的对象模型">LLVM IR 的对象模型</a></li>
        <li><a href="#尝试生成-llvm-ir">尝试生成 LLVM IR</a></li>
        <li><a href="#支持-if-语句">支持 if 语句</a></li>
        <li><a href="#支持本地变量">支持本地变量</a></li>
        <li><a href="#编译并运行程序">编译并运行程序</a></li>
        <li><a href="#课程小结">课程小结</a></li>
        <li><a href="#一课一思">一课一思</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>目前来讲，你已经初步了解了 LLVM 和它的 IR，也能够使用它的命令行工具。**不过，我们还是要通过程序生成 LLVM 的 IR，**这样才能复用 LLVM 的功能，从而实现一门完整的语言。</p>
<p>不过，如果我们要像前面生成汇编语言那样，通过字符串拼接来生成 LLVM 的 IR，除了要了解 LLVM IR 的很多细节之外，代码一定比较啰嗦和复杂，因为字符串拼接不是结构化的方法，所以，最好用一个定义良好的数据结构来表示 IR。</p>
<p>好在 LLVM 项目已经帮我们考虑到了这一点，它提供了代表 LLVM IR 的一组对象模型，我们只要生成这些对象，就相当于生成了 IR，这个难度就低多了。而且，LLVM 还提供了一个工具类，IRBuilder，我们可以利用它，进一步提升创建 LLVM IR 的对象模型的效率，让生成 IR 的过程变得更加简单！</p>
<p>接下来，就让我们先来了解 LLVM IR 的对象模型。</p>
<h2 id="llvm-ir-的对象模型">LLVM IR 的对象模型</h2>
<p>LLVM 在内部有用 C++ 实现的对象模型，能够完整表示 LLVM IR，当我们把字节码读入内存时，LLVM 就会在内存中构建出这个模型。只有基于这个对象模型，我们才可以做进一步的工作，包括代码优化，实现即时编译和运行，以及静态编译生成目标文件。<strong>所以说，这个对象模型是 LLVM 运行时的核心。</strong></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/f381c27865ae0cf1ebf54ee537c909d2.png" alt=""></p>
<p>IR 对象模型的头文件在include/llvm/IR目录下，其中最重要的类包括：</p>
<ol>
<li>Module（模块）</li>
</ol>
<p>Module 类聚合了一个模块中的所有数据，它可以包含多个函数。你可以通过 Model::iterator 来遍历模块中所有的函数。它也包含了一个模块的全局变量。</p>
<ol>
<li>Function（函数）</li>
</ol>
<p>Function 包含了与函数定义（definition）或声明（declaration）有关的所有对象。函数定义包含了函数体，而函数声明，则仅仅包含了函数的原型，它是在其他模块中定义的，在本模块中使用。</p>
<p>你可以通过 getArgumentList() 方法来获得函数参数的列表，也可以遍历函数体中的所有基本块，这些基本块会形成一个 CFG（控制流图）。</p>
<p>// 函数声明，没有函数体。这个函数是在其他模块中定义的，在本模块中使用<br>
declare void @foo(i32)</p>
<p>// 函数定义，包含函数体<br>
define i32 @fun3(i32 %a) {<br>
%calltmp1 = call void @foo(i32 %a)  // 调用外部函数<br>
ret i32 10<br>
}</p>
<ol>
<li>BasicBlock（基本块）</li>
</ol>
<p>BasicBlock 封装了一系列的 LLVM 指令，你可以借助 bigin()/end() 模式遍历这些指令，还可以通过 getTerminator() 方法获得最后一条指令（也就是终结指令）。你还可以用到几个辅助方法在 CFG 中导航，比如获得某个基本块的前序基本块。</p>
<ol>
<li>Instruction（指令）</li>
</ol>
<p>Instruction 类代表了 LLVM IR 的原子操作（也就是一条指令），你可以通过 getOpcode() 来获得它代表的操作码，它是一个 llvm::Instruction 枚举值，你可以通过 op_begin() 和 op_end() 方法对获得这个指令的操作数。</p>
<ol>
<li>Value（值）</li>
</ol>
<p>Value 类代表一个值。在 LLVM 的内存 IR 中，如果一个类是从 Value 继承的，意味着它定义了一个值，其他方可以去使用。函数、基本块和指令都继承了 Value。</p>
<ol>
<li>LLVMContext（上下文）</li>
</ol>
<p>这个类代表了 LLVM 做编译工作时的一个上下文，包含了编译工作中的一些全局数据，比如各个模块用到的常量和类型。</p>
<p>这些内容是 LLVM IR 对象模型的主要部分，我们生成 IR 的过程，就是跟这些类打交道，其他一些次要的类，你可以在阅读和编写代码的过程中逐渐熟悉起来。</p>
<p>接下来，就让我们用程序来生成 LLVM 的 IR。</p>
<h2 id="尝试生成-llvm-ir">尝试生成 LLVM IR</h2>
<p>我刚刚提到的每个 LLVM IR 类，都可以通过程序来构建。那么，为下面这个 fun1() 函数生成 IR，应该怎么办呢？</p>
<p>int fun1(int a, int b){<br>
return a+b;<br>
}</p>
<p>**第一步，**我们可以来生成一个 LLVM 模块，也就是顶层的 IR 对象。</p>
<p>Module *mod = new Module(&ldquo;fun1.ll&rdquo;, TheModule);</p>
<p>**第二步，**我们继续在模块中定义函数 fun1，因为模块最主要的构成要素就是各个函数。</p>
<p>不过在定义函数之前，要先定义函数的原型（或者叫函数的类型）。函数的类型，我们在前端讲过：如果两个函数的返回值相同，并且参数也相同，这两个函数的类型是相同的，这样就可以做函数指针或函数型变量的赋值。示例代码的函数原型是：返回值是 32 位整数，参数是两个 32 位整数。</p>
<p>有了函数原型以后，就可以使用这个函数原型定义一个函数。我们还可以为每个参数设置一个名称，便于后面引用这个参数。</p>
<p>// 函数原型<br>
vector&lt;Type *&gt; argTypes(2, Type::getInt32Ty(TheContext));<br>
FunctionType *fun1Type = FunctionType::get(Type::getInt32Ty(TheContext), // 返回值是整数<br>
argTypes, // 两个整型参数<br>
false);   // 不是变长参数</p>
<p>// 函数对象<br>
Function *fun = Function::Create(fun1Type,<br>
Function::ExternalLinkage,   // 链接类型<br>
&ldquo;fun2&rdquo;,                      // 函数名称<br>
TheModule.get());            // 所在模块</p>
<p>// 设置参数名称<br>
string argNames[2] = {&ldquo;a&rdquo;, &ldquo;b&rdquo;};<br>
unsigned i = 0;<br>
for (auto &amp;arg : fun-&gt;args()){<br>
arg.setName(argNames[i++]);<br>
}</p>
<p>**这里你需要注意，代码中是如何使用变量类型的。**所有的基础类型都是提前定义好的，可以通过 Type 类的 getXXXTy() 方法获得（我们使用的是 Int32 类型，你还可以获得其他类型）。</p>
<p>**第三步，**创建一个基本块。</p>
<p>这个函数只有一个基本块，你可以把它命名为“entry”，也可以不给它命名。在创建了基本块之后，我们用了一个辅助类 IRBuilder，设置了一个插入点，后序生成的指令会插入到这个基本块中（IRBuilder 是 LLVM 为了简化 IR 生成过程所提供的一个辅助类）。</p>
<p>// 创建一个基本块<br>
BasicBlock *BB = BasicBlock::Create(TheContext,// 上下文<br>
&ldquo;&rdquo;,     // 基本块名称<br>
fun);  // 所在函数<br>
Builder.SetInsertPoint(BB);   // 设置指令的插入点</p>
<p>**第四步，**生成&quot;a+b&quot;表达式所对应的 IR，插入到基本块中。</p>
<p>a 和 b 都是函数 fun 的参数，我们把它取出来，分别赋值给 L 和 R（L 和 R 是 Value）。然后用 IRBuilder 的 CreateAdd() 方法，生成一条 add 指令。这个指令的计算结果存放在 addtemp 中。</p>
<p>// 把参数变量存到 NamedValues 里面备用<br>
NamedValues.clear();<br>
for (auto &amp;Arg : fun-&gt;args())<br>
NamedValues[Arg.getName()] = &amp;Arg;</p>
<p>// 做加法<br>
Value *L = NamedValues[&ldquo;a&rdquo;];<br>
Value *R = NamedValues[&ldquo;b&rdquo;];<br>
Value *addtmp = Builder.CreateAdd(L, R);</p>
<p>**第五步，**利用刚才获得的 addtmp 创建一个返回值。</p>
<p>// 返回值<br>
Builder.CreateRet(addtmp);</p>
<p>**最后一步，**检查这个函数的正确性。这相当于是做语义检查，比如，基本块的最后一个语句就必须是一个正确的返回指令。</p>
<p>// 验证函数的正确性<br>
verifyFunction(*fun);</p>
<p>完整的代码我也提供给你，放在codegen_fun1()里了，你可以看一下。我们可以调用这个方法，然后打印输出生成的 IR：</p>
<p>Function *fun1 = codegen_fun1();     // 在模块中生成 Function 对象<br>
TheModule-&gt;print(errs(), nullptr);   // 在终端输出 IR</p>
<p>生成的 IR 如下：</p>
<p>; ModuleID = &rsquo;llvmdemo&rsquo;<br>
source_filename = &ldquo;llvmdemo&rdquo;<br>
define i32 @fun1(i32 %a, i32 %b) {<br>
%1 = add i32 %a, %b<br>
ret i32 %1<br>
}</p>
<p>这个例子简单，过程直观，只有一个加法运算，而我建议你在这个过程中注意每个 IR 对象都是怎样被创建的，在大脑中想象出整个对象结构。</p>
<p>为了熟悉更多的 API，接下来，我再带你生成一个稍微复杂一点儿的，带有 if 语句的 IR。然后来看一看，函数中包含多个基本块的情况。</p>
<h2 id="支持-if-语句">支持 if 语句</h2>
<p>具体说，我们要为下面的一个函数生成 IR（函数有一个参数 a，当 a 大于 2 的时候，返回 2；否则返回 3）。</p>
<p>int fun_ifstmt(int a)<br>
if (a &gt; 2)<br>
return 2;<br>
else<br>
return 3；<br>
}</p>
<p>这样的一个函数，需要包含 4 个基本块：**入口基本块、Then 基本块、Else 基本块和 Merge 基本块。**控制流图（CFG）是先分开，再合并，像下面这样：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/08da46864cff0f26b6b964583bbdb8c1.png" alt=""></p>
<p>**在入口基本块中，**我们要计算“a&gt;2”的值，并根据这个值，分别跳转到 ThenBB 和 ElseBB。这里，我们用到了 IRBuilder 的 CreateICmpUGE() 方法（UGE 的意思，是”不大于等于“，也就是小于）。这个指令的返回值是一个 1 位的整型，也就是 int1。</p>
<p>// 计算 a&gt;2<br>
Value * L = NamedValues[&ldquo;a&rdquo;];<br>
Value * R = ConstantInt::get(TheContext, APInt(32, 2, true));<br>
Value * cond = Builder.CreateICmpUGE(L, R, &ldquo;cmptmp&rdquo;);</p>
<p>接下来，我们创建另外 3 个基本块，并用 IRBuilder 的 CreateCondBr() 方法创建条件跳转指令：当 cond 是 1 的时候，跳转到 ThenBB，0 的时候跳转到 ElseBB。</p>
<p>BasicBlock *ThenBB =BasicBlock::Create(TheContext, &ldquo;then&rdquo;, fun);<br>
BasicBlock *ElseBB = BasicBlock::Create(TheContext, &ldquo;else&rdquo;);<br>
BasicBlock *MergeBB = BasicBlock::Create(TheContext, &ldquo;ifcont&rdquo;);<br>
Builder.CreateCondBr(cond, ThenBB, ElseBB);</p>
<p>**如果你细心的话，**可能会发现，在创建 ThenBB 的时候，指定了其所在函数是 fun，而其他两个基本块没有指定。这是因为，我们接下来就要为 ThenBB 生成指令，所以先加到 fun 中。之后，再顺序添加 ElseBB 和 MergeBB 到 fun 中。</p>
<p>//ThenBB<br>
Builder.SetInsertPoint(ThenBB);<br>
Value *ThenV = ConstantInt::get(TheContext, APInt(32, 2, true));<br>
Builder.CreateBr(MergeBB);</p>
<p>//ElseBB<br>
fun-&gt;getBasicBlockList().push_back(ElseBB);  // 把基本块加入到函数中<br>
Builder.SetInsertPoint(ElseBB);<br>
Value *ElseV = ConstantInt::get(TheContext, APInt(32, 3, true));<br>
Builder.CreateBr(MergeBB);</p>
<p><strong>在 ThenBB 和 ElseBB</strong>这两个基本块的代码中，我们分别计算出了两个值：ThenV 和 ElseV。它们都可能是最后的返回值，但具体采用哪个，还要看实际运行时，控制流走的是 ThenBB 还是 ElseBB。这就需要用到 phi 指令，它完成了根据控制流来选择合适的值的任务。</p>
<p>//MergeBB<br>
fun-&gt;getBasicBlockList().push_back(MergeBB);<br>
Builder.SetInsertPoint(MergeBB);<br>
//PHI 节点：整型，两个候选值<br>
PHINode *PN = Builder.CreatePHI(Type::getInt32Ty(TheContext), 2);<br>
PN-&gt;addIncoming(ThenV, ThenBB);  // 前序基本块是 ThenBB 时，采用 ThenV<br>
PN-&gt;addIncoming(ElseV, ElseBB);  // 前序基本块是 ElseBB 时，采用 ElseV</p>
<p>// 返回值<br>
Builder.CreateRet(PN);</p>
<p>从上面这段代码中你能看出，**在 if 语句中，phi 指令是关键。**因为当程序的控制流经过多个基本块，每个基本块都可能改变某个值的时候，通过 phi 指令可以知道运行时实际走的是哪条路径，从而获得正确的值。</p>
<p>最后生成的 IR 如下，其中的 phi 指令指出，如果前序基本块是 then，取值为 2，是 else 的时候取值为 3。</p>
<p>define i32 @fun_ifstmt(i32 %a) {<br>
%cmptmp = icmp uge i32 %a, 2<br>
br i1 %cmptmp, label %then, label %else</p>
<p>then:                                             ; preds = %0<br>
br label %ifcont</p>
<p>else:                                             ; preds = %0<br>
br label %ifcont</p>
<p>ifcont:                                           ; preds = %else, %then<br>
%1 = phi i32 [ 2, %then ], [ 3, %else ]<br>
ret i32 %1<br>
}</p>
<p>其实循环语句也跟 if 语句差不多，因为它们都是要涉及到多个基本块，要用到 phi 指令，<strong>所以一旦你会写 if 语句，肯定就会写循环语句的。</strong></p>
<h2 id="支持本地变量">支持本地变量</h2>
<p>在写程序的时候，本地变量是必不可少的一个元素，所以，我们趁热打铁，把刚才的示例程序变化一下，用本地变量 b 保存 ThenBB 和 ElseBB 中计算的值，借此学习一下 LLVM IR 是如何支持本地变量的。</p>
<p>改变后的示例程序如下：</p>
<p>int fun_localvar(int a)<br>
int b = 0;<br>
if (a &gt; 2)<br>
b = 2;<br>
else<br>
b = 3;<br>
return b;<br>
}</p>
<p>其中，函数有一个参数 a，一个本地变量 b：如果 a 大于 2，那么给 b 赋值 2；否则，给 b 赋值 3。最后的返回值是 b。</p>
<p>**现在挑战来了，**在这段代码中，b 被声明了一次，赋值了 3 次。我们知道，LLVM IR 采用的是 SSA 形式，也就是每个变量只允许被赋值一次，那么对于多次赋值的情况，我们该如何生成 IR 呢？</p>
<p>其实，LLVM 规定了对寄存器只能做单次赋值，而对内存中的变量，是可以多次赋值的。对于“int b = 0;”，我们用下面几条语句生成 IR：</p>
<p>// 本地变量 b<br>
AllocaInst <em>b = Builder.CreateAlloca(Type::getInt32Ty(TheContext), nullptr, &ldquo;b&rdquo;);<br>
Value</em> initValue = ConstantInt::get(TheContext, APInt(32, 0, true));</p>
<p>Builder.CreateStore(initValue, b);</p>
<p>上面这段代码的含义是：首先用 CreateAlloca() 方法，在栈中申请一块内存，用于保存一个 32 位的整型，接着，用 CreateStore() 方法生成一条 store 指令，给 b 赋予初始值。</p>
<p>上面几句生成的 IR 如下：</p>
<p>%b = alloca i32<br>
store i32 0, i32* %b</p>
<p>接着，我们可以在 ThenBB 和 ElseBB 中，分别对内存中的 b 赋值：</p>
<p>//ThenBB<br>
Builder.SetInsertPoint(ThenBB);<br>
Value *ThenV = ConstantInt::get(TheContext, APInt(32, 2, true));<br>
Builder.CreateStore(ThenV, b);<br>
Builder.CreateBr(MergeBB);</p>
<p>//ElseBB<br>
fun-&gt;getBasicBlockList().push_back(ElseBB);<br>
Builder.SetInsertPoint(ElseBB);<br>
Value *ElseV = ConstantInt::get(TheContext, APInt(32, 3, true));<br>
Builder.CreateStore(ElseV, b);<br>
Builder.CreateBr(MergeBB);</p>
<p>最后，在 MergeBB 中，我们只需要返回 b 就可以了：</p>
<p>//MergeBB<br>
fun-&gt;getBasicBlockList().push_back(MergeBB);<br>
Builder.SetInsertPoint(MergeBB);</p>
<p>// 返回值<br>
Builder.CreateRet(b);</p>
<p>最后生成的 IR 如下：</p>
<p>define i32 @fun_ifstmt.1(i32 %a) {<br>
%b = alloca i32<br>
store i32 0, i32* %b<br>
%cmptmp = icmp uge i32 %a, 2<br>
br i1 %cmptmp, label %then, label %else</p>
<p>then:                                             ; preds = %0<br>
store i32 2, i32* %b<br>
br label %ifcont</p>
<p>else:                                             ; preds = %0<br>
store i32 3, i32* %b<br>
br label %ifcont</p>
<p>ifcont:                                           ; preds = %else, %then<br>
ret i32* %b<br>
}</p>
<p>当然，使用内存保存临时变量的性能比较低，但我们可以很容易通过优化算法，把上述代码从使用内存的版本，优化成使用寄存器的版本。</p>
<p>通过上面几个示例，现在你已经学会了生成基本的 IR，包括能够支持本地变量、加法运算、if 语句。那么这样生成的 IR 能否正常工作呢？我们需要把这些 IR 编译和运行一下才知道。</p>
<h2 id="编译并运行程序">编译并运行程序</h2>
<p>现在已经能够在内存中建立 LLVM 的 IR 对象了，包括模块、函数、基本块和各种指令。LLVM 可以即时编译并执行这个 IR 模型。</p>
<p>我们先创建一个不带参数的 __main() 函数作为入口。同时，我会借这个例子延伸讲一下函数的调用。我们在前面声明了函数 fun1，现在在 __main() 函数中演示如何调用它。</p>
<p>Function * codegen_main(){<br>
// 创建 main 函数<br>
FunctionType *mainType = FunctionType::get(Type::getInt32Ty(TheContext), false);<br>
Function *main = Function::Create(mainType, Function::ExternalLinkage, &ldquo;__main&rdquo;, TheModule.get());</p>
<pre><code>// 创建一个基本块  
BasicBlock *BB = BasicBlock::Create(TheContext, &quot;&quot;, main);  
Builder.SetInsertPoint(BB);  

// 设置参数的值  
int argValues[2] = {2, 3};  
std::vector&lt;Value *&gt; ArgsV;  
for (unsigned i = 0; i&lt;2; ++i) {  
    Value * value = ConstantInt::get(TheContext, APInt(32,argValues[i],true));  
    ArgsV.push_back(value);  
    if (!ArgsV.back())  
        return nullptr;  
}  

// 调用函数 fun1  
Function *callee = TheModule-&gt;getFunction(&quot;fun1&quot;);  
Value * rtn = Builder.CreateCall(callee, ArgsV, &quot;calltmp&quot;);  
  
// 返回值  
Builder.CreateRet(rtn);  
return main;  
</code></pre>
<p>}</p>
<p>调用函数时，我们首先从模块中查找出名称为 fun1 的函数，准备好参数值，然后通过 IRBuilder 的 CreateCall() 方法来生成函数调用指令。最后生成的 IR 如下：</p>
<p>define i32 @__main() {<br>
%calltmp = call i32 @fun1(i32 2, i32 3)<br>
ret i32 %calltmp3<br>
}</p>
<p>接下来，我们调用即时编译的引擎来运行 __main 函数（与 JIT 引擎有关的代码，放到了 DemoJIT.h 中，你现在可以暂时不关心它的细节，留到以后再去了解）。使用这个 JIT 引擎，我们需要做几件事情：</p>
<p>1. 初始化与目标硬件平台有关的设置。</p>
<p>InitializeNativeTarget();<br>
InitializeNativeTargetAsmPrinter();<br>
InitializeNativeTargetAsmParser();</p>
<p>2. 把创建的模型加入到 JIT 引擎中，找到 __main() 函数的地址（整个过程跟 C 语言中使用函数指针来执行一个函数没有太大区别）。</p>
<p>auto H = TheJIT-&gt;addModule(std::move(TheModule));</p>
<p>// 查找 __main 函数<br>
auto main = TheJIT-&gt;findSymbol(&quot;__main&quot;);</p>
<p>// 获得函数指针  <br>
int32_t (<em>FP)() = (int32_t (</em>)())(intptr_t)cantFail(main.getAddress());</p>
<p>// 执行函数<br>
int rtn = FP();</p>
<p>// 打印执行结果<br>
fprintf(stderr, &ldquo;__main: %d\n&rdquo;, rtn);</p>
<p>3. 程序可以成功执行，并打印 __main 函数的返回值。</p>
<p>**既然已经演示了如何调用函数，在这里，我给你揭示 LLVM 的一个惊人的特性：**我们可以在 LLVM IR 里，调用本地编写的函数，比如编写一个 foo() 函数，用来打印输出一些信息：</p>
<p>void foo(int a){<br>
printf(&ldquo;in foo: %d\n&rdquo;,a);<br>
}</p>
<p>然后我们就可以在 __main 里直接调用这个 foo 函数，就像调用 fun1 函数一样：</p>
<p>// 调用一个外部函数 foo<br>
vector&lt;Type *&gt; argTypes(1, Type::getInt32Ty(TheContext));<br>
FunctionType *fooType = FunctionType::get(Type::getVoidTy(TheContext), argTypes, false);</p>
<p>Function *foo = Function::Create(fooType, Function::ExternalLinkage, &ldquo;foo&rdquo;, TheModule.get());</p>
<p>std::vector&lt;Value *&gt; ArgsV2;<br>
ArgsV2.push_back(rtn);<br>
if (!ArgsV2.back())<br>
return nullptr;</p>
<p>Builder.CreateCall(foo, ArgsV2, &ldquo;calltmp2&rdquo;);</p>
<p>注意，我们在这里只对 foo 函数做了声明，并没有定义它的函数体，这时 LLVM 会在外部寻找 foo 的定义，它会找到用 C++ 编写的 foo 函数，然后调用并执行；如果 foo 函数在另一个目标文件中，它也可以找到。</p>
<p>刚才讲的是即时编译和运行，你也可以生成目标文件，然后再去链接和执行。生成目标文件的代码参见emitObject()方法，基本上就是打开一个文件，然后写入生成的二进制目标代码。针对目标机器生成目标代码的大量工作，就用这么简单的几行代码就实现了，是不是帮了你的大忙了？</p>
<h2 id="课程小结">课程小结</h2>
<p>本节课，我们我们完成了从生成 IR 到编译执行的完整过程，同时，也初步熟悉了 LLVM 的接口。当然了，完全熟悉 LLVM 的接口还需要多做练习，掌握更多的细节。就本节课而言，我希望你掌握的重点如下：</p>
<ol>
<li>LLVM 用一套对象模型在内存中表示 IR，包括模块、函数、基本块和指令，你可以通过 API 来生成这些对象。这些对象一旦生成，就可以编译和执行。</li>
<li>对于 if 语句和循环语句，需要生成多个基本块，并通过跳转指令形成正确的控制流图（CFG）。当存在多个前序节点可能改变某个变量的值的时候，使用 phi 指令来确定正确的值。</li>
<li>存储在内存中的本地变量，可以多次赋值。</li>
<li>LLVM 能够把外部函数和 IR 模型中的函数等价对待。</li>
</ol>
<p>另外，为了降低学习难度，本节课，我没有做从 AST 翻译成 IR 的工作，而是针对一个目标功能（比如一个 C 语言的函数），硬编码调用 API 来生成 IR。你理解各种功能是如何生成 IR 以后，再从 AST 来翻译，就更加容易了。</p>
<h2 id="一课一思">一课一思</h2>
<p>既然我带你演示了 if 语句如何生成 IR，那么你能思考一下，对于 for 循环和 while 循环语句，它对应的 CFG 应该是什么样的？应该如何生成 IR？欢迎你在留言区分享你的看法。</p>
<p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/77577e606d183349707a8a62717dc60c.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/">编译原理之美</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80%E8%AF%BE/26_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0__%E7%A9%BA%E7%AB%B9%E9%87%8C%E7%9A%84%E7%A7%98%E5%AF%86%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">26_深度学习__空竹里的秘密：自编码器</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/26_%E6%97%B6%E9%97%B4%E5%A1%91%E9%80%A0%E5%9F%BA%E7%9F%B3%E4%B9%A0%E6%83%AF%E4%B8%8B%E5%88%87%E5%89%B2%E4%B8%8E%E6%9E%84%E5%BB%BA/">
            <span class="next-text nav-default">26_时间：塑造基石习惯（下）——切割与构建</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
