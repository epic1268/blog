<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>14_前端技术应用（一）：如何透明地支持数据库分库分表？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="从今天开始，我们正式进入了应用篇，我会用两节课的时间，带你应用编译器的前端技术。这样，你会把学到的编译技术和应用领域更好地结合起来，学以致用，让技术发挥应有的价值。还能通过实践加深对原理的理解，形成一个良好的循环。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/14_%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8%E4%B8%80%E5%A6%82%E4%BD%95%E9%80%8F%E6%98%8E%E5%9C%B0%E6%94%AF%E6%8C%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/14_%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8%E4%B8%80%E5%A6%82%E4%BD%95%E9%80%8F%E6%98%8E%E5%9C%B0%E6%94%AF%E6%8C%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="14_前端技术应用（一）：如何透明地支持数据库分库分表？">
  <meta property="og:description" content="从今天开始，我们正式进入了应用篇，我会用两节课的时间，带你应用编译器的前端技术。这样，你会把学到的编译技术和应用领域更好地结合起来，学以致用，让技术发挥应有的价值。还能通过实践加深对原理的理解，形成一个良好的循环。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="编译原理之美">

  <meta itemprop="name" content="14_前端技术应用（一）：如何透明地支持数据库分库分表？">
  <meta itemprop="description" content="从今天开始，我们正式进入了应用篇，我会用两节课的时间，带你应用编译器的前端技术。这样，你会把学到的编译技术和应用领域更好地结合起来，学以致用，让技术发挥应有的价值。还能通过实践加深对原理的理解，形成一个良好的循环。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5510">
  <meta itemprop="keywords" content="编译原理之美">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="14_前端技术应用（一）：如何透明地支持数据库分库分表？">
  <meta name="twitter:description" content="从今天开始，我们正式进入了应用篇，我会用两节课的时间，带你应用编译器的前端技术。这样，你会把学到的编译技术和应用领域更好地结合起来，学以致用，让技术发挥应有的价值。还能通过实践加深对原理的理解，形成一个良好的循环。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">14_前端技术应用（一）：如何透明地支持数据库分库分表？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5510 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#分布式数据库解决了什么问题又带来了哪些挑战">分布式数据库解决了什么问题，又带来了哪些挑战</a></li>
        <li><a href="#解析-sql-语句判断访问哪个数据库">解析 SQL 语句，判断访问哪个数据库</a></li>
        <li><a href="#我们的示例离实用还有多大差距">我们的示例离实用还有多大差距？</a></li>
        <li><a href="#课程小结">课程小结</a></li>
        <li><a href="#一课一思">一课一思</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>从今天开始，我们正式进入了应用篇，我会用两节课的时间，带你应用编译器的前端技术。这样，你会把学到的编译技术和应用领域更好地结合起来，学以致用，让技术发挥应有的价值。还能通过实践加深对原理的理解，形成一个良好的循环。</p>
<p>这节课，我们主要讨论，一个分布式数据库领域的需求。我会带你设计一个中间层，让应用逻辑不必关心数据库的物理分布。这样，无论把数据库拆成多少个分库，编程时都会像面对一个物理库似的没什么区别。</p>
<p>接下来，我们先了解一下分布式数据库的需求和带来的挑战。</p>
<h2 id="分布式数据库解决了什么问题又带来了哪些挑战">分布式数据库解决了什么问题，又带来了哪些挑战</h2>
<p>随着技术的进步，我们编写的应用所采集、处理的数据越来越多，处理的访问请求也越来越多。而单一数据库服务器的处理能力是有限的，当数据量和访问量超过一定级别以后，就要开始做分库分表的操作。比如，把一个数据库的大表拆成几张表，把一个库拆成几个库，把读和写的操作分离开等等。<strong>我们把这类技术统称为分布式数据库技术。</strong></p>
<p>分库分表（Sharding）有时也翻译成“数据库分片”。分片可以依据各种不同的策略，比如我开发过一个与社区有关的应用系统，这个系统的很多业务逻辑都是围绕小区展开的。对于这样的系统，按照<strong>地理分布的维度</strong>来分片就很合适，因为每次对数据库的操作基本上只会涉及其中一个分库。</p>
<p>假设我们有一个订单表，那么就可以依据一定的规则对订单或客户进行编号，编号中就包含地理编码。比如 SDYT 代表山东烟台，BJHD 代表北京海淀，不同区域的数据放在不同的分库中：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/bc2a790f3aa092d5815332e1ff7155f4.png" alt=""></p>
<p>通过数据库分片，我们可以提高数据库服务的性能和可伸缩性。当数据量和访问量增加时，增加数据库节点的数量就行了。不过，虽然数据库的分片带来了性能和伸缩性的好处，但它也带来了一些挑战。</p>
<p>**最明显的一个挑战，是数据库分片逻辑侵入到业务逻辑中。**过去，应用逻辑只访问一个数据库，现在需要根据分片的规则，判断要去访问哪个数据库，再去跟这个数据库服务器连接。如果增加数据库分片，或者对分片策略进行调整，访问数据库的所有应用模块都要修改。这会让软件的维护变得更复杂，显然也不太符合软件工程中模块低耦合、把变化隔离的理念。</p>
<p>所以如果有一种技术，能让我们访问很多数据库分片时，像访问一个数据库那样就好了。<strong>数据库的物理分布，对应用是透明的。</strong></p>
<p>可是，“理想很吸引人，现实很骨感”。要实现这个技术，需要解决很多问题：</p>
<p>**首先是跨库查询的难题。**如果 SQL 操作都针对一个库还好，但如果某个业务需求恰好要跨多个库，比如上面的例子中，如果要查询多个小区的住户信息，那么就要在多个库中都执行查询，然后把查询结果合并，一般还要排序。</p>
<p>如果我们前端显示的时候需要分页，每页显示一百行，那就更麻烦了。我们不可能从 10 个分库中各查出 10 行，合并成 100 行，这 100 行不一定排在前面，最差的情况，可能这 100 行恰好都在其中一个分库里。所以，你可能要从每个分库查出 100 行来，合并、排序后，再取出前 100 行。如果涉及数据库表跨库做连接，你想象一下，那就更麻烦了。</p>
<p>**其次就是跨库做写入的难题。**如果对数据库写入时遇到了跨库的情况，那么就必须实现分布式事务。所以，虽然分布式数据库的愿景很吸引人，但我们必须解决一系列技术问题。</p>
<p>这一讲，我们先解决最简单的问题，**也就是当每次数据操作仅针对一个分库的时候，能否自动确定是哪个分库的问题。**解决这个问题我们不需要依据别的信息，只需要提供 SQL 就行了。这就涉及对 SQL 语句的解析了，自然要用到编译技术。</p>
<h2 id="解析-sql-语句判断访问哪个数据库">解析 SQL 语句，判断访问哪个数据库</h2>
<p>我画了一张简化版的示意图：假设有两张表，分别是订单表和客户表，它们的主键是 order_id 和 cust_id：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/ad4462c6b45194b331444c39d8a68fb7.png" alt=""></p>
<p>我们采用的分片策略，是依据这两个主键的前 4 位的编码来确定数据库分片的逻辑，比如：前四位是 SDYT，那就使用山东烟台的分片，如果是 BJHD，就使用北京海淀的分片，等等。</p>
<p>在我们的应用中，会对订单表进行一些增删改查的操作，比如会执行下面的 SQL 语句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 查询
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">select * from orders where order_id = &#39;SDYT20190805XXXX&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">select * from orders where cust_id = &#39;SDYT987645&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 插入
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">insert into orders (order_id，... 其他字段) values( &#34;BJHD20190805XXXX&#34;,...)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 修改
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">update orders set price=298.00 where order_id=&#39;FJXM20190805XXXX&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 删除
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">delete from orders where order_id=&#39;SZLG20190805XXXX&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们要能够解析这样的 SQL 语句，根据主键字段的值，决定去访问哪个分库或者分表。这就需要用到编译器前端技术，包括<strong>词法分析、语法分析和语义分析。</strong></p>
<p>听到这儿，你可能会质疑：“解析 SQL 语句？是在开玩笑吗？”你可能觉得这个任务太棘手，犹豫着是否要忍受业务逻辑和技术逻辑混杂的缺陷，把判断分片的逻辑写到应用代码里，或者想解决这个问题，又或者想自己写一个开源项目，帮到更多的人。</p>
<p>无论你的内心活动如何，应用编译技术，能让你有更强的信心解决这个问题。那么如何去做呢？要想完成解析 SQL 的任务，在词法分析和语法分析这两个阶段，我建议你采用工具快速落地，比如 Antlr。你要找一个现成的 SQL 语句的语法规则文件。</p>
<p>GitHub 中，那个收集了很多示例 Antlr 规则文件的<a href="./grammars-v4.md">项目</a>里，<a href="./grammars-v4.md">有两个可以参考的规则</a>：一个是<a href="./plsql.md">PLSQL</a>的（它是 Oracle 数据库的 SQL 语法）；一个是<a href="./sqlite.md">SQLite</a>的（这是一个嵌入式数据库）。</p>
<p>实际上，我还找到 MySQL workbench 所使用的一个产品级的<a href="./grammars.md">规则文件</a>。MySQL workbench 是一个图形化工具，用于管理和访问 MySQL。这个规则文件还是很靠谱的，不过它里面嵌了很多属性计算规则，而且是 C++ 语言写的，我嫌处理起来麻烦，就先弃之不用，<strong>暂且采用 SQLite 的规则文件来做示范。</strong></p>
<p>先来看一下这个文件里的一些规则，例如 select 语句相关的语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">factored_select_stmt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> : ( K_WITH K_RECURSIVE? common_table_expression ( &#39;,&#39; common_table_expression )* )?
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   select_core ( compound_operator select_core )*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   ( K_ORDER K_BY ordering_term ( &#39;,&#39; ordering_term )* )?
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   ( K_LIMIT expr ( ( K_OFFSET | &#39;,&#39; ) expr )? )?
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> common_table_expression
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> : table_name ( &#39;(&#39; column_name ( &#39;,&#39; column_name )* &#39;)&#39; )? K_AS &#39;(&#39; select_stmt &#39;)&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> select_core
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> : K_SELECT ( K_DISTINCT | K_ALL )? result_column ( &#39;,&#39; result_column )*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   ( K_FROM ( table_or_subquery ( &#39;,&#39; table_or_subquery )* | join_clause ) )?
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   ( K_WHERE expr )?
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   ( K_GROUP K_BY expr ( &#39;,&#39; expr )* ( K_HAVING expr )? )?
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | K_VALUES &#39;(&#39; expr ( &#39;,&#39; expr )* &#39;)&#39; ( &#39;,&#39; &#39;(&#39; expr ( &#39;,&#39; expr )* &#39;)&#39; )*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> result_column
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> : &#39;*&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | table_name &#39;.&#39; &#39;*&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | expr ( K_AS? column_alias )?
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> ;
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以一边看这个语法规则，一边想几个 select 语句做一做验证。你可以思考一下，这个规则是怎么把 select 语句拆成不同的部分的。</p>
<p>SQL 里面也有表达式，我们研究一下它的表达式的规则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">expr
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> : literal_value
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | BIND_PARAMETER
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | ( ( database_name &#39;.&#39; )? table_name &#39;.&#39; )? column_name
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | unary_operator expr
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | expr &#39;||&#39; expr
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | expr ( &#39;*&#39; | &#39;/&#39; | &#39;%&#39; ) expr
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | expr ( &#39;+&#39; | &#39;-&#39; ) expr
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | expr ( &#39;&lt;&lt;&#39; | &#39;&gt;&gt;&#39; | &#39;&amp;&#39; | &#39;|&#39; ) expr
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | expr ( &#39;&lt;&#39; | &#39;&lt;=&#39; | &#39;&gt;&#39; | &#39;&gt;=&#39; ) expr
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | expr ( &#39;=&#39; | &#39;==&#39; | &#39;!=&#39; | &#39;&lt;&gt;&#39; | K_IS | K_IS K_NOT | K_IN | K_LIKE | K_GLOB | K_MATCH | K_REGEXP ) expr
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | expr K_AND expr
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | expr K_OR expr
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | function_name &#39;(&#39; ( K_DISTINCT? expr ( &#39;,&#39; expr )* | &#39;*&#39; )? &#39;)&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | &#39;(&#39; expr &#39;)&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | K_CAST &#39;(&#39; expr K_AS type_name &#39;)&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | expr K_COLLATE collation_name
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | expr K_NOT? ( K_LIKE | K_GLOB | K_REGEXP | K_MATCH ) expr ( K_ESCAPE expr )?
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | expr ( K_ISNULL | K_NOTNULL | K_NOT K_NULL )
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | expr K_IS K_NOT? expr
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | expr K_NOT? K_BETWEEN expr K_AND expr
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | expr K_NOT? K_IN ( &#39;(&#39; ( select_stmt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                          | expr ( &#39;,&#39; expr )*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                          )? 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                      &#39;)&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    | ( database_name &#39;.&#39; )? table_name )
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | ( ( K_NOT )? K_EXISTS )? &#39;(&#39; select_stmt &#39;)&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | K_CASE expr? ( K_WHEN expr K_THEN expr )+ ( K_ELSE expr )? K_END
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> | raise_function
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> ;
</span></span></code></pre></td></tr></table>
</div>
</div><p>你可能会觉得 SQL 的表达式的规则跟其他语言的表达式规则很像。比如都支持加减乘除、关系比较、逻辑运算等等。而且从这个规则文件里，你一下子就能看出各种运算的优先级，比如你会注意到，字符串连接操作“||”比乘法和除法的优先级更高。<strong>所以，研究一门语言时积累的经验，在研究下一门语言时仍然有用。</strong></p>
<p>有了规则文件之后，接下来，我们用 Antlr 生成词法分析器和语法分析器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">antlr -visitor -package dsql.parser SQLite.g4
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个命令里，我用 -package 参数指定了生成的 Java 代码的包是 dsql.parser。dsql 是分布式 SQL 的意思。接着，我们可以写一点儿程序测试一下所生成的词法分析器和语法分析器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">String sql = &#34;select order_id from orders where cust_id = &#39;SDYT987645&#39;&#34;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 词法分析
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">SQLiteLexer lexer = new SQLiteLexer(CharStreams.fromString(sql));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">CommonTokenStream tokens = new CommonTokenStream(lexer);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 语法分析
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">SQLiteParser parser = new SQLiteParser(tokens);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ParseTree tree = parser.sql_stmt();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 输出 lisp 格式的 AST
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">System.out.println(tree.toStringTree(parser));
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段程序的输出是 LISP 格式的 AST，我调整了一下缩进，让它显得更像一棵树：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">(sql_stmt 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  (factored_select_stmt 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    (select_core select 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      (result_column 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        (expr 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          (column_name 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            (any_name order_id)))) 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      from (table_or_subquery 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              (table_name 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                (any_name orders)))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      where (expr 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              (expr 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                (column_name 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                  (any_name cust_id))) 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              = 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                (expr 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                  (literal_value 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    (&#39;SDYT987645&#39;))))))
</span></span></code></pre></td></tr></table>
</div>
</div><p>从 AST 中，我们可以清晰地看出这个 select 语句是如何被解析成结构化数据的，再继续写点儿代码，就能获得想要的信息了。</p>
<p>接下来的任务是：对于访问订单表的 select 语句，要在 where 子句里找出 cust_id=&ldquo;客户编号&quot;或 order_id=&ldquo;订单编号&quot;这样的条件，从而能够根据客户编号或订单编号确定采用哪个分库。</p>
<p>怎么实现呢？很简单，我们用 visitor 模式遍历一下 AST 就可以了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public String getDBName(String sql) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 词法解析
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    SQLiteLexer lexer = new SQLiteLexer(CharStreams.fromString(sql));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    CommonTokenStream tokens = new CommonTokenStream(lexer);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 语法解析
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    SQLiteParser parser = new SQLiteParser(tokens);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ParseTree tree = parser.sql_stmt();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     // 以 lisp 格式打印 AST
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    System.out.println(tree.toStringTree(parser));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     // 获得 select 语句的要素， 包括表名和 where 条件
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    SQLVisitor visitor = new SQLVisitor();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    SelectStmt select = (SelectStmt) visitor.visit(tree);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     String dbName = null;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (select.tableName.equals(&#34;orders&#34;)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (select.whereExprs != null) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            for (WhereExpr expr : select.whereExprs) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // 根据 cust_id 或 order_id 来确定库的名称
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                if (expr.columnName.equals(&#34;cust_id&#34;) || expr.columnName.equals(&#34;order_id&#34;)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    // 取编号的前 4 位，即区域编码
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    String region = expr.value.substring(1, 5);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    // 根据区域编码，获取库名称
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    dbName = region2DB.get(region);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return dbName;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>获取表名和 where 子句条件的代码在 SQLVisitor.java 中。因为已经有了 AST，抽取这些信息是不难的。你可以点开我在文稿中提供的链接，查看示例代码。</p>
<h2 id="我们的示例离实用还有多大差距">我们的示例离实用还有多大差距？</h2>
<p>目前，我们已经初步解决了数据库访问透明化的问题。当然，这只是一个示例，如果要做得严密、实用，我们还要补充一些工作。</p>
<p>**我们需要做一些语义分析工作，确保 SQL 语句的合法性。**语法分析并不能保证程序代码完全合法，我们必须进行很多语义的检查才行。</p>
<p>我给订单表起的名字，是 orders。如果你把表名称改为 order，那么必须用引号引起来，写成’order’，不带引号的 order 会被认为是一个关键字。因为在 SQL 中我们可以使用 order by 这样的子句，这时候，order 这个表名就会被混淆，进而被解析错误。这个语法解析程序会在表名的地方出现一个 order 节点，这在语义上是不合法的，需要被检查出来并报错。</p>
<p>**如果要检查语义的正确性，我们还必须了解数据库的元数据。**否则，就没有办法判断在 SQL 语句中是否使用了正确的字段，以及正确的数据类型。除此之外，我们还需要扩展到能够识别跨库操作，比如下面这样一个 where 条件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">order_id = &#39;FJXM20190805XXXX&#39; or order_id = &#39;SZLG20190805XXXX&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><p>分析这个查询条件，可以知道数据是存在两个不同的数据库中的。但是我们要让解析程序分析出这个结果，甚至让它针对更加复杂的条件，也能分析出来。这就需要更加深入的语义分析功能了。</p>
<p>**最后，解析器的速度也是一个需要考虑的因素。**因为执行每个 SQL 都需要做一次解析，而这个时间就加在了每一次数据库访问上。所以，SQL 解析的时间越少越好。因此，有的项目就会尽量提升解析效率。**阿里有一个开源项目 Druid，是一个数据库连接池。**这个项目强调性能，因此他们纯手写了一个 SQL 解析器，尽可能地提升性能。</p>
<p>总之，要实现一个完善的工具，让工具达到产品级的质量，有不少工作要做。如果要支持更强的分布式数据库功能，还要做更多的工作。不过，你应该不会觉得这事儿有多么难办了吧？至少在编译技术这部分你是有信心的。</p>
<p>在这里，我还想讲一讲 SQL 防注入这个问题。SQL 注入攻击是一种常见的攻击手段。你向服务器请求一个 url 的时候，可以把恶意的 SQL 嵌入到参数里面，这样形成的 SQL 就是不安全的。</p>
<p>以前面的 SQL 语句为例，这个 select 语句本来只是查询一个订单，订单编号“SDYT20190805XXXX”作为参数传递给服务端的一个接口，服务端收到参数以后，用单引号把这个参数引起来，并加上其他部分，就组装成下面的 SQL 并执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 原来的 SQL
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">select * from orders where order_id = &#39;SDYT20190805XXXX&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们遇到了一个恶意攻击者，他可能把参数写成“SDYT20190805XXXX’；drop table customers; &ndash;”。服务器接到这个参数以后，仍然把它拿单引号引起来，并组装成 SQL，组装完毕以后就是下面的语句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 被注入恶意 SQL 后
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">select * from orders where order_id = &#39;SDYT20190805XXXX&#39;; drop table customers; --&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你看不清楚，我分行写一下，这样你就知道它是怎么把你宝贵的客户信息全都删掉的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 被注入恶意 SQL 后
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">select * from orders where order_id = &#39;SDYT20190805XXXX&#39;; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">drop table customers;  // 把顾客表给删了
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--&#39;                    // 把你加的单引号变成了注释，这样 SQL 不会出错
</span></span></code></pre></td></tr></table>
</div>
</div><p>**所以 SQL 注入有很大的危害。**而我们一般用检查客户端传过来的参数的方法，看看有没有 SQL 语句中的关键字，来防止 SQL 注入。不过这是比较浅的防御，有时还会漏过一些非法参数，所以要在 SQL 执行之前，做最后一遍检查。而这个时候，就要运用编译器前端技术来做 SQL 的解析了。借此，我们能检查出来异常：<strong>明明这个功能是做查询的，为什么形成的 SQL 会有删除表的操作？</strong></p>
<p>通过这个例子，我们又分析了一种场景：开发一个安全可靠的系统，用编译技术做 SQL 分析是必须做的一件事情。</p>
<h2 id="课程小结">课程小结</h2>
<p>今天，我带你利用学到的编译器前端技术，解析了 SQL 语句，并针对分布式数据库透明查询的功能做了一次概念证明。</p>
<p>SQL 是程序员经常打交道的语言。有时，我们会遇到需要解析 SQL 语言的需求，除了分布式数据库场景的需求以外，Hibernate 对 HQL 的解析，也跟解析 SQL 差不多。而且，最近有一种技术，能够通过 RESTful 这样的接口做通用的查询，其实也是一种类 SQL 的子语言。</p>
<p>当然了，今天我们只是基于工具做解析。一方面，有时候我们就是需要做个原型系统或者最小的能用的系统，有时间有资源了，再追求完美也不为过，比如追求编译速度的提升。另一方面，你能看到 MySQL workbench 也是用 Antlr 来作帮手的，在很多情况下，Antlr 这样的工具生成的解析器足够用，甚至比你手写的还要好，所以，我们大可以节省时间，用工具做解析。</p>
<p>可能你会觉得，实际应用的难度似乎要低于学习原理的难度。如果你有这个感觉，那就对了，这说明你已经掌握了原理篇的内容，所以日常的一些应用根本不是问题，你可以找出更多的应用场景来练练手。</p>
<h2 id="一课一思">一课一思</h2>
<p>你在工作中，是否遇到过其他需要解析 SQL 的场景？另外，当你阅读了 SQL 的规则文件之后，是否发现了它跟 Java 这样的语言规则的不同之处？是更加简单还是更复杂？欢迎在留言区写下你的发现。</p>
<p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/77577e606d183349707a8a62717dc60c.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/">编译原理之美</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1/14_%E5%BC%80%E6%BA%90rpc%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">14_开源RPC框架如何选型？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/14_%E5%A6%82%E4%BD%95%E6%89%93%E5%BC%80_%E5%85%B3%E9%97%AD%E9%9F%B3%E8%A7%86%E9%A2%91/">
            <span class="next-text nav-default">14_如何打开_关闭音视频？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
