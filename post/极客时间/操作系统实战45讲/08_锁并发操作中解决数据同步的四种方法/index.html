<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>08_锁：并发操作中，解决数据同步的四种方法 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是 LMOS。
我们在前面的课程中探索了，开发操作系统要了解的最核心的硬件——CPU、MMU、Cache、内存，知道了它们的工作原理。在程序运行中，它们起到了至关重要的作用。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/08_%E9%94%81%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E4%B8%AD%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/08_%E9%94%81%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E4%B8%AD%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="08_锁：并发操作中，解决数据同步的四种方法">
  <meta property="og:description" content="你好，我是 LMOS。
我们在前面的课程中探索了，开发操作系统要了解的最核心的硬件——CPU、MMU、Cache、内存，知道了它们的工作原理。在程序运行中，它们起到了至关重要的作用。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="操作系统实战45讲">

  <meta itemprop="name" content="08_锁：并发操作中，解决数据同步的四种方法">
  <meta itemprop="description" content="你好，我是 LMOS。
我们在前面的课程中探索了，开发操作系统要了解的最核心的硬件——CPU、MMU、Cache、内存，知道了它们的工作原理。在程序运行中，它们起到了至关重要的作用。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7016">
  <meta itemprop="keywords" content="操作系统实战45讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="08_锁：并发操作中，解决数据同步的四种方法">
  <meta name="twitter:description" content="你好，我是 LMOS。
我们在前面的课程中探索了，开发操作系统要了解的最核心的硬件——CPU、MMU、Cache、内存，知道了它们的工作原理。在程序运行中，它们起到了至关重要的作用。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">08_锁：并发操作中，解决数据同步的四种方法</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7016 字 </span>
          <span class="more-meta"> 预计阅读 15 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#非预期结果的全局变量">非预期结果的全局变量</a></li>
        <li><a href="#方法一原子操作-拿下单体变量">方法一：原子操作 拿下单体变量</a></li>
        <li><a href="#方法二中断控制-搞定复杂变量">方法二：中断控制 搞定复杂变量</a></li>
        <li><a href="#方法三自旋锁-协调多核心-cpu">方法三：自旋锁 协调多核心 CPU</a></li>
        <li><a href="#方法四信号量-cpu-时间管理大师">方法四：信号量 CPU 时间管理大师</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是 LMOS。</p>
<p>我们在前面的课程中探索了，开发操作系统要了解的最核心的硬件——CPU、MMU、Cache、内存，知道了它们的工作原理。在程序运行中，它们起到了至关重要的作用。</p>
<p>在开发我们自己的操作系统以前，还不能一开始就把机器跑起来，而是先要弄清楚数据同步的问题。如果不解决掉数据同步的问题，后面机器跑起来，就会出现很多不可预知的结果。</p>
<p>通过这节课，我会给你讲清楚为什么在并发操作里，很可能得不到预期的访问数据，还会带你分析这个问题的原因以及解决方法。有了这样一个研究、解决问题的过程，对最重要的几种锁（<strong>原子变量，关中断，信号量，自旋锁</strong>），你就能做到心中有数了。</p>
<h2 id="非预期结果的全局变量">非预期结果的全局变量</h2>
<p>来看看下面的代码，描述的是一个线程中的函数和中断处理函数，它们分别对一个全局变量执行加 1 操作，代码如下。</p>
<p>int a = 0;<br>
void interrupt_handle()<br>
{<br>
a++;<br>
}<br>
void thread_func()<br>
{<br>
a++;<br>
}</p>
<p>首先我们梳理一下编译器的翻译过程，通常编译器会把 a++ 语句翻译成这 3 条指令。</p>
<p>1. 把 a 加载某个寄存器中。</p>
<p>2. 这个寄存器加 1。</p>
<p>3. 把这个寄存器写回内存。</p>
<p>那么不难推断，可能导致结果不确定的情况是这样的：thread_func 函数还没运行完第 2 条指令时，中断就来了。</p>
<p>因此，CPU 转而处理中断，也就是开始运行 interrupt_handle 函数，这个函数运行完 a=1，CPU 还会回去继续运行第 3 条指令，此时 a 依然是 1，这显然是错的。</p>
<p>下面来看一下表格，你就明白了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/e6cb8b9f14ee345fcf4325a71f094954.png" alt=""></p>
<p>显然在 t2 时刻发生了中断，导致了 t2 到 t4 运行了 interrupt_handle 函数，t5 时刻 thread_func 又恢复运行，导致 interrupt_handle 函数中 a 的操作丢失，因此出错。</p>
<h2 id="方法一原子操作-拿下单体变量">方法一：原子操作 拿下单体变量</h2>
<p>要解决上述场景中的问题，有这样两种思路。一种是<strong>把 a++ 变成原子操作</strong>，这里的原子是不可分隔的，也就是说要 a++ 这个操作不可分隔，即 a++ 要么不执行，要么一口气执行完；另一种就是<strong>控制中断</strong>，比如在执行 a++ 之前关掉中断，执行完了之后打开中断。</p>
<p>我们先来看看原子操作，显然靠编译器自动生成原子操作不太可能。第一，编译器没有这么智能，能检测哪个变量需要原子操作；第二，编译器必须要考虑代码的移植性，例如有些硬件平台支持原子操作的机器指令，有的硬件平台不支持原子操作。</p>
<p>既然实现原子操作无法依赖于具体编译器，那就需要我们自己动手，x86 平台支持很多原子指令，我们只需要直接应用这些指令，比如原子加、原子减，原子读写等，用汇编代码写出对应的原子操作函数就行了。</p>
<p>好在现代 C 语言已经支持嵌入汇编代码，可以<strong>在 C 函数中按照特定的方式嵌入汇编代码</strong>了，实现原子操作就更方便了，代码如下。</p>
<p>//定义一个原子类型<br>
typedef struct s_ATOMIC{<br>
volatile s32_t a_count; //在变量前加上 volatile，是为了禁止编译器优化，使其每次都从内存中加载变量<br>
}atomic_t;<br>
//原子读<br>
static inline s32_t atomic_read(const atomic_t <em>v)<br>
{       <br>
//x86 平台取地址处是原子<br>
return (</em>(volatile u32_t*)&amp;(v)-&gt;a_count);<br>
}<br>
//原子写<br>
static inline void atomic_write(atomic_t *v, int i)<br>
{<br>
//x86 平台把一个值写入一个地址处也是原子的<br>
v-&gt;a_count = i;<br>
}<br>
//原子加上一个整数<br>
static inline void atomic_add(int i, atomic_t *v)<br>
{<br>
<strong>asm</strong> <strong>volatile</strong>(&ldquo;lock;&rdquo; &ldquo;addl %1,%0&rdquo;<br>
: &ldquo;+m&rdquo; (v-&gt;a_count)<br>
: &ldquo;ir&rdquo; (i));<br>
}<br>
//原子减去一个整数<br>
static inline void atomic_sub(int i, atomic_t *v)<br>
{<br>
<strong>asm</strong> <strong>volatile</strong>(&ldquo;lock;&rdquo; &ldquo;subl %1,%0&rdquo;<br>
: &ldquo;+m&rdquo; (v-&gt;a_count)<br>
: &ldquo;ir&rdquo; (i));<br>
}<br>
//原子加 1<br>
static inline void atomic_inc(atomic_t *v)<br>
{<br>
<strong>asm</strong> <strong>volatile</strong>(&ldquo;lock;&rdquo; &ldquo;incl %0&rdquo;<br>
: &ldquo;+m&rdquo; (v-&gt;a_count));<br>
}<br>
//原子减 1<br>
static inline void atomic_dec(atomic_t *v)<br>
{<br>
<strong>asm</strong> <strong>volatile</strong>(&ldquo;lock;&rdquo; &ldquo;decl %0&rdquo;<br>
: &ldquo;+m&rdquo; (v-&gt;a_count));<br>
}</p>
<p><strong>以上代码中，加上 lock 前缀的 addl、subl、incl、decl 指令都是原子操作，lock 前缀表示锁定总线。</strong></p>
<p>我们还是来看看 GCC 支持嵌入汇编代码的模板，不同于其它 C 编译器支持嵌入汇编代码的方式，为了优化用户代码，GCC 设计了一种特有的嵌入方式，它规定了汇编代码嵌入的形式和嵌入汇编代码需要由哪几个部分组成，如下面代码所示。</p>
<p><strong>asm</strong> <strong>volatile</strong>(代码部分：输出部分列表：输入部分列表：损坏部分列表);</p>
<p>可以看到代码模板从 __asm__ 开始（当然也可以是 asm），紧跟着 __volatile__，然后是跟着一对括号，最后以分号结束。括号里大致分为 4 个部分：</p>
<p>1. 汇编代码部分，这里是实际嵌入的汇编代码。</p>
<p>2. 输出列表部分，让 GCC 能够处理 C 语言左值表达式与汇编代码的结合。</p>
<p>3. 输入列表部分，也是让 GCC 能够处理 C 语言表达式、变量、常量，让它们能够输入到汇编代码中去。</p>
<p>4. 损坏列表部分，告诉 GCC 汇编代码中用到了哪些寄存器，以便 GCC 在汇编代码运行前，生成保存它们的代码，并且在生成的汇编代码运行后，恢复它们（寄存器）的代码。</p>
<p>它们之间用冒号隔开，如果只有汇编代码部分，后面的冒号可以省略。但是有输入列表部分而没有输出列表部分的时候，输出列表部分的冒号就必须要写，否则 GCC 没办法判断，同样的道理对于其它部分也一样。</p>
<p>这里不会过多展开讲这个技术，详情可参阅GCC 手册。你可以重点看 GAS 相关的章节。</p>
<p>下面将用上面一个函数 atomic_add 为例子说一下，如下所示。</p>
<p>static inline void atomic_add(int i, atomic_t *v)<br>
{<br>
<strong>asm</strong> <strong>volatile</strong>(&ldquo;lock;&rdquo; &ldquo;addl %1,%0&rdquo;<br>
: &ldquo;+m&rdquo; (v-&gt;a_count)<br>
: &ldquo;ir&rdquo; (i));<br>
}<br>
//&ldquo;lock;&rdquo; &ldquo;addl %1,%0&rdquo; 是汇编指令部分，%1,%0是占位符，它表示输出、输入列表中变量或表态式，占位符的数字从输出部分开始依次增加，这些变量或者表态式会被 GCC 处理成寄存器、内存、立即数放在指令中。<br>
//: &ldquo;+m&rdquo; (v-&gt;a_count) 是输出列表部分，“+m”表示 (v-&gt;a_count) 和内存地址关联<br>
//: &ldquo;ir&rdquo; (i) 是输入列表部分，“ir”表示 i 是和立即数或者寄存器关联</p>
<p>有了这些原子操作函数之后，前面场景中的代码就变成下面这样了：无论有没有中断，或者什么时间来中断，都不会出错。</p>
<p>atomic_t a = {0};<br>
void interrupt_handle()<br>
{<br>
atomic_inc(&amp;a);<br>
}<br>
void thread_func()<br>
{<br>
atomic_inc(&amp;a);<br>
}</p>
<p>好，说完了原子操作，我们再看看怎么用中断控制的思路解决数据并发访问的问题。</p>
<h2 id="方法二中断控制-搞定复杂变量">方法二：中断控制 搞定复杂变量</h2>
<p>中断是 CPU 响应外部事件的重要机制，时钟、键盘、硬盘等 IO 设备都是通过发出中断来请求 CPU 执行相关操作的（即执行相应的中断处理代码），比如下一个时钟到来、用户按下了键盘上的某个按键、硬盘已经准备好了数据。</p>
<p>但是中断处理代码中如果操作了其它代码的数据，这就需要相应的控制机制了，这样才能保证在操作数据过程中不发生中断。</p>
<p>你或许在想，可以用原子操作啊？不过，<strong>原子操作只适合于单体变量</strong>，如整数。操作系统的数据结构有的可能有几百字节大小，其中可能包含多种不同的基本数据类型。这显然用原子操作无法解决。</p>
<p>下面，我们就要写代码实现关闭开启、中断了，x86 CPU 上关闭、开启中断有专门的指令，即 cli、sti 指令，它们主要是对 CPU 的 eflags 寄存器的 <strong>IF 位</strong>（第 9 位）进行清除和设置，CPU 正是通过此位来决定是否响应中断信号。这两条指令只能 Ring0 权限才能执行，代码如下。</p>
<p>//关闭中断<br>
void hal_cli()<br>
{<br>
<strong>asm</strong> <strong>volatile</strong>(&ldquo;cli&rdquo;: : :&ldquo;memory&rdquo;);<br>
}<br>
//开启中断<br>
void hal_sti()<br>
{<br>
<strong>asm</strong> <strong>volatile</strong>(&ldquo;sti&rdquo;: : :&ldquo;memory&rdquo;);<br>
}<br>
//使用场景<br>
void foo()<br>
{<br>
hal_cli();<br>
//操作数据……<br>
hal_sti();<br>
}<br>
void bar()<br>
{<br>
hal_cli();<br>
//操作数据……<br>
hal_sti();<br>
}</p>
<p>你可以自己思考一下，前面这段代码效果如何？</p>
<p>它看似完美地解决了问题，其实有重大缺陷，hal_cli()，hal_sti()，<strong>无法嵌套使用</strong>，看一个例子你就明白了，代码如下。</p>
<p>void foo()<br>
{<br>
hal_cli();<br>
//操作数据第一步……<br>
hal_sti();<br>
}<br>
void bar()<br>
{<br>
hal_cli();<br>
foo();<br>
//操作数据第二步……<br>
hal_sti();<br>
}</p>
<p>上面代码的关键问题在 bar 函数在关中断下调用了 foo 函数，foo 函数中先关掉中断，处理好数据然后开启中断，回到 bar 函数中，bar 函数还天真地以为中断是关闭的，接着处理数据，以为不会被中断抢占。</p>
<p>那么怎么解决上面的问题呢？我们只要修改一下开启、关闭中断的函数就行了。</p>
<p>我们可以这样操作：在关闭中断函数中先保存 eflags 寄存器，然后执行 cli 指令，在开启中断函数中直接恢复之前保存的 eflags 寄存器就行了，具体代码如下。</p>
<p>typedef u32_t cpuflg_t;<br>
static inline void hal_save_flags_cli(cpuflg_t* flags)<br>
{<br>
<strong>asm</strong> <strong>volatile</strong>(<br>
&ldquo;pushfl \t\n&rdquo; //把 eflags 寄存器压入当前栈顶<br>
&ldquo;cli    \t\n&rdquo; //关闭中断<br>
&ldquo;popl %0 \t\n&rdquo;//把当前栈顶弹出到 flags 为地址的内存中       <br>
: &ldquo;=m&rdquo;(<em>flags)<br>
:<br>
: &ldquo;memory&rdquo;<br>
);<br>
}<br>
static inline void hal_restore_flags_sti(cpuflg_t</em> flags)<br>
{<br>
<strong>asm</strong> <strong>volatile</strong>(<br>
&ldquo;pushl %0 \t\n&rdquo;//把 flags 为地址处的值寄存器压入当前栈顶<br>
&ldquo;popfl \t\n&rdquo;   //把当前栈顶弹出到 flags 寄存器中<br>
:<br>
: &ldquo;m&rdquo;(*flags)<br>
: &ldquo;memory&rdquo;<br>
);<br>
}</p>
<p>从上面的代码中不难发现，硬件工程师早就想到了如何解决在嵌套函数中关闭、开启中断的问题：pushfl 指令把 eflags 寄存器压入当前栈顶，popfl 把当前栈顶的数据弹出到 eflags 寄存器中。</p>
<p>hal_restore_flags_sti() 函数的执行，是否开启中断完全取决于上一次 eflags 寄存器中的值，并且 popfl 指令只会影响 eflags 寄存器中的 IF 位。这样，无论函数嵌套调用多少层都没有问题。</p>
<h2 id="方法三自旋锁-协调多核心-cpu">方法三：自旋锁 协调多核心 CPU</h2>
<p>前面说的控制中断，看似解决了问题，那是因为以前是单 CPU，同一时刻只有一条代码执行流，除了中断会中止当前代码执行流，转而运行另一条代码执行流（中断处理程序），再无其它代码执行流。这种情况下只要控制了中断，就能安全地操作全局数据。</p>
<p>但是我们都知道，现在情况发生了改变，CPU 变成了多核心，或者主板上安装了多颗 CPU，同一时刻下系统中存在多条代码执行流，控制中断只能控制本地 CPU 的中断，无法控制其它 CPU 核心的中断。</p>
<p>所以，原先通过控制中断来维护全局数据安全的方案失效了，这就需要全新的机制来处理这样的情况，于是就轮到自旋锁登场了。</p>
<p>我们先看看自旋锁的原理，它是这样的：首先读取锁变量，判断其值是否已经加锁，如果未加锁则执行加锁，然后返回，表示加锁成功；如果已经加锁了，就要返回第一步继续执行后续步骤，因而得名自旋锁。为了让你更好理解，下面来画一个图描述这个算法。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/54f7207dc94cab4f173f95f4a4da4490.png" alt=""></p>
<p>自旋锁原理示意图</p>
<p>这个算法看似很好，但是想要正确执行它，就**必须保证读取锁变量和判断并加锁的操作是原子执行的。**否则，CPU0 在读取了锁变量之后，CPU1 读取锁变量判断未加锁执行加锁，然后 CPU0 也判断未加锁执行加锁，这时就会发现两个 CPU 都加锁成功，因此这个算法出错了。</p>
<p>怎么解决这个问题呢？这就要找硬件要解决方案了，x86 CPU 给我们提供了一个原子交换指令，xchg，它可以让寄存器里的一个值跟内存空间中的一个值做交换。例如，让 eax=memlock，memlock=eax 这个动作是原子的，不受其它 CPU 干扰。</p>
<p>下面我们就去实现自旋锁，代码如下所示。</p>
<p>//自旋锁结构<br>
typedef struct<br>
{<br>
volatile u32_t lock;//volatile 可以防止编译器优化，保证其它代码始终从内存加载 lock 变量的值<br>
} spinlock_t;<br>
//锁初始化函数<br>
static inline void x86_spin_lock_init(spinlock_t * lock)<br>
{<br>
lock-&gt;lock = 0;//锁值初始化为 0 是未加锁状态<br>
}<br>
//加锁函数<br>
static inline void x86_spin_lock(spinlock_t * lock)<br>
{<br>
<strong>asm</strong> <strong>volatile</strong> (<br>
&ldquo;1: \n&rdquo;<br>
&ldquo;lock; xchg  %0, %1 \n&rdquo;//把值为 1 的寄存器和 lock 内存中的值进行交换<br>
&ldquo;cmpl   $0, %0 \n&rdquo; //用 0 和交换回来的值进行比较<br>
&ldquo;jnz    2f \n&rdquo;  //不等于 0 则跳转后面 2 标号处运行<br>
&ldquo;jmp 3f \n&rdquo;     //若等于 0 则跳转后面 3 标号处返回<br>
&ldquo;2:         \n&rdquo;<br>
&ldquo;cmpl   $0, %1  \n&rdquo;//用 0 和 lock 内存中的值进行比较<br>
&ldquo;jne    2b      \n&rdquo;//若不等于 0 则跳转到前面 2 标号处运行继续比较 <br>
&ldquo;jmp    1b      \n&rdquo;//若等于 0 则跳转到前面 1 标号处运行，交换并加锁<br>
&ldquo;3:  \n&rdquo;     :<br>
: &ldquo;r&rdquo;(1), &ldquo;m&rdquo;(*lock));<br>
}<br>
//解锁函数<br>
static inline void x86_spin_unlock(spinlock_t * lock)<br>
{<br>
<strong>asm</strong> <strong>volatile</strong>(<br>
&ldquo;movl   $0, %0\n&rdquo;//解锁把 lock 内存中的值设为 0 就行<br>
:<br>
: &ldquo;m&rdquo;(*lock));<br>
}</p>
<p>上述代码的中注释已经很清楚了，关键点在于 xchg 指令，xchg %0, %1。</p>
<p>其中，%0 对应 &ldquo;r&rdquo;(1)，表示由编译器自动分配一个通用寄存器，并填入值 1，例如 mov eax，1。而 %1 对应&quot;m&quot;(*lock)，表示 lock 是内存地址。把 1 和内存中的值进行交换，若内存中是 1，则不会影响；因为本身写入就是 1，若内存中是 0，一交换，内存中就变成了 1，即加锁成功。</p>
<p>自旋锁依然有中断嵌套的问题，也就是说，在使用自旋锁的时候我们仍然要注意中断。</p>
<p>在中断处理程序访问某个自旋锁保护的某个资源时，依然有问题，所以我们要写的自旋锁函数必须适应这样的中断环境，也就是说，它需要在处理中断的过程中也能使用，如下所示。</p>
<p>static inline void x86_spin_lock_disable_irq(spinlock_t * lock,cpuflg_t* flags)<br>
{<br>
<strong>asm</strong> <strong>volatile</strong>(<br>
&ldquo;pushfq                 \n\t&rdquo;<br>
&ldquo;cli                    \n\t&rdquo;<br>
&ldquo;popq %0                \n\t&rdquo;<br>
&ldquo;1:         \n\t&rdquo;<br>
&ldquo;lock; xchg  %1, %2 \n\t&rdquo;<br>
&ldquo;cmpl   $0,%1       \n\t&rdquo;<br>
&ldquo;jnz    2f      \n\t&rdquo;<br>
&ldquo;jmp    3f      \n&rdquo; <br>
&ldquo;2:         \n\t&rdquo;<br>
&ldquo;cmpl   $0,%2       \n\t&rdquo;<br>
&ldquo;jne    2b      \n\t&rdquo;<br>
&ldquo;jmp    1b      \n\t&rdquo;<br>
&ldquo;3:     \n&rdquo;    <br>
:&quot;=m&quot;(<em>flags)<br>
: &ldquo;r&rdquo;(1), &ldquo;m&rdquo;(<em>lock));<br>
}<br>
static inline void x86_spin_unlock_enabled_irq(spinlock_t</em> lock,cpuflg_t</em> flags)<br>
{<br>
<strong>asm</strong> <strong>volatile</strong>(<br>
&ldquo;movl   $0, %0\n\t&rdquo;<br>
&ldquo;pushq %1 \n\t&rdquo;<br>
&ldquo;popfq \n\t&rdquo;<br>
:<br>
: &ldquo;m&rdquo;(*lock), &ldquo;m&rdquo;(*flags));<br>
}</p>
<p>以上代码实现了关中断下获取自旋锁，以及恢复中断状态释放自旋锁。在中断环境下也完美地解决了问题。</p>
<h2 id="方法四信号量-cpu-时间管理大师">方法四：信号量 CPU 时间管理大师</h2>
<p>无论是原子操作，还是自旋锁，都不适合长时间等待的情况，因为有很多资源（数据）它有一定的时间性，你想去获取它，CPU 并不能立即返回给你，而是要等待一段时间，才能把数据返回给你。这种情况，你用自旋锁来同步访问这种资源，你会发现这是对 CPU 时间的巨大浪费。</p>
<p>下面我们看看另一种同步机制，既能对资源数据进行保护（同一时刻只有一个代码执行流访问），又能在资源无法满足的情况下，让 CPU 可以执行其它任务。</p>
<p>如果你翻过操作系统的理论书，应该对信号量这个词并不陌生。信号量是 1965 年荷兰学者 Edsger Dijkstra 提出的，是一种用于资源互斥或者进程间同步的机制。这里我们就来看看如何实现这一机制。</p>
<p>你不妨想象这样一个情境：微信等待你从键盘上的输入信息，然后把这个信息发送出去。</p>
<p>这个功能我们怎么实现呢？下面我们就来说说实现它的一般方法，当然具体实现中可能不同，但是原理是相通的，具体如下。</p>
<p>1. 一块内存，相当于缓冲区，用于保存键盘的按键码。</p>
<p>2. 需要一套控制机制，比如微信读取这个缓冲区，而该缓冲区为空时怎么处理；该缓冲区中有了按键码，却没有代码执行流来读取，又该怎么处理。</p>
<p>我们期望是这样的，一共有三点。</p>
<p>1. 当微信获取键盘输入信息时，发现键盘缓冲区中是空的，就进入等待状态。</p>
<p>2. 同一时刻，只能有一个代码执行流操作键盘缓冲区。</p>
<p>3. 当用户按下键盘时，我们有能力把按键码写入缓冲区中，并且能看一看微信或者其它程序是否在等待该缓冲区，如果是就重新激活微信和其它的程序，让它们重新竞争读取键盘缓冲区，如果竞争失败依然进入等待状态。</p>
<p>其实以上所述无非是三个问题：<strong>等待、互斥、唤醒（即重新激活等待的代码执行流）。</strong></p>
<p>这就需要一种全新的数据结构来解决这些问题。根据上面的问题，这个数据结构至少需要一个变量来表示互斥，比如大于 0 则代码执行流可以继续运行，等于 0 则让代码执行流进入等待状态。还需要一个等待链，用于保存等待的代码执行流。</p>
<p>这个数据结构的实现代码如下所示。</p>
<p>#define SEM_FLG_MUTEX 0<br>
#define SEM_FLG_MULTI 1<br>
#define SEM_MUTEX_ONE_LOCK 1<br>
#define SEM_MULTI_LOCK 0<br>
//等待链数据结构，用于挂载等待代码执行流（线程）的结构，里面有用于挂载代码执行流的链表和计数器变量，这里我们先不深入研究这个数据结构。<br>
typedef struct s_KWLST<br>
{  <br>
spinlock_t wl_lock;<br>
uint_t   wl_tdnr;<br>
list_h_t wl_list;<br>
}kwlst_t;<br>
//信号量数据结构<br>
typedef struct s_SEM<br>
{<br>
spinlock_t sem_lock;//维护 sem_t 自身数据的自旋锁<br>
uint_t sem_flg;//信号量相关的标志<br>
sint_t sem_count;//信号量计数值<br>
kwlst_t sem_waitlst;//用于挂载等待代码执行流（线程）结构<br>
}sem_t;</p>
<p>搞懂了信号量的结构，我们再来看看信号量的一般用法，注意信号量在使用之前需要<strong>先进行初始化</strong>。这里假定信号量数据结构中的 sem_count 初始化为 1，sem_waitlst 等待链初始化为空。</p>
<p>使用信号量的步骤，我已经给你列好了。</p>
<p><strong>第一步，获取信号量。</strong></p>
<p>1. 首先对用于保护信号量自身的自旋锁 sem_lock 进行加锁。</p>
<p>2. 对信号值 sem_count 执行“减 1”操作，并检查其值是否小于 0。</p>
<p>3. 上步中检查 sem_count 如果小于 0，就让进程进入等待状态并且将其挂入 sem_waitlst 中，然后调度其它进程运行。否则表示获取信号量成功。当然最后别忘了对自旋锁 sem_lock 进行解锁。</p>
<p><strong>第二步，代码执行流开始执行相关操作，例如读取键盘缓冲区。</strong></p>
<p><strong>第三步，释放信号量。</strong></p>
<p>1. 首先对用于保护信号量自身的自旋锁 sem_lock 进行加锁。</p>
<p>2. 对信号值 sem_count 执行“加 1”操作，并检查其值是否大于 0。</p>
<p>3. 上步中检查 sem_count 值如果大于 0，就执行唤醒 sem_waitlst 中进程的操作，并且需要调度进程时就执行进程调度操作，不管 sem_count 是否大于 0（通常会大于 0）都标记信号量释放成功。当然最后别忘了对自旋锁 sem_lock 进行解锁。</p>
<p>这里我给你额外分享一个小技巧，<strong>写代码之前我们常常需要先想清楚算法步骤，建议你像我这样分条列出，因为串联很容易含糊其辞，不利于后面顺畅编码。</strong></p>
<p>好，下面我们来看看实现上述这些功能的代码，按照理论书籍上说，信号量有两个操作：down，up，代码如下。</p>
<p>//获取信号量<br>
void krlsem_down(sem_t* sem)<br>
{<br>
cpuflg_t cpufg;<br>
start_step:   <br>
krlspinlock_cli(&amp;sem-&gt;sem_lock,&amp;cpufg);<br>
if(sem-&gt;sem_count&lt;1)<br>
{//如果信号量值小于 1，则让代码执行流（线程）睡眠<br>
krlwlst_wait(&amp;sem-&gt;sem_waitlst);<br>
krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);<br>
krlschedul();//切换代码执行流，下次恢复执行时依然从下一行开始执行，所以要 goto 开始处重新获取信号量<br>
goto start_step;<br>
}<br>
sem-&gt;sem_count&ndash;;//信号量值减 1，表示成功获取信号量<br>
krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);<br>
return;<br>
}<br>
//释放信号量<br>
void krlsem_up(sem_t* sem)<br>
{<br>
cpuflg_t cpufg;<br>
krlspinlock_cli(&amp;sem-&gt;sem_lock,&amp;cpufg);<br>
sem-&gt;sem_count++;//释放信号量<br>
if(sem-&gt;sem_count&lt;1)<br>
{//如果小于 1，则说数据结构出错了，挂起系统<br>
krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);<br>
hal_sysdie(&ldquo;sem up err&rdquo;);<br>
}<br>
//唤醒该信号量上所有等待的代码执行流（线程）<br>
krlwlst_allup(&amp;sem-&gt;sem_waitlst);<br>
krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);<br>
krlsched_set_schedflgs();<br>
return;<br>
}</p>
<p>上述代码中的 krlspinlock_cli，krlspinunlock_sti 两个函数，只是对前面自旋锁函数的一个<strong>封装</strong>，krlschedul、krlwlst_wait、krlwlst_allup、krlsched_set_schedflgs 这几个函数会在进程相关课程进行探讨。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>又到了这节课结束的时候，我们回顾一下今天都讲了什么。我把这节课的内容为你梳理一下，要点如下。</p>
<p>1. 原子变量，在只有<strong>单个变量全局数据</strong>的情况下，这种变量非常实用，如全局计数器、状态标志变量等。我们利用了 CPU 的原子指令实现了一组操作原子变量的函数。</p>
<p>2. 中断的控制。当要操作的数据很多的情况下，用原子变量就不适合了。但是我们发现在单核心的 CPU，同一时刻只有一个代码执行流，除了响应中断导致代码执行流切换，不会有其它条件会干扰全局数据的操作，所以我们只要在操作全局数据时关闭或者开启中断就行了，为此我们开发了控制中断的函数。</p>
<p>3. 自旋锁。由于多核心的 CPU 出现，控制中断已经失效了，因为<strong>系统中同时有多个代码执行流</strong>，为了解决这个问题，我们开发了自旋锁，自旋锁要么一下子获取锁，要么循环等待最终获取锁。</p>
<p>4. 信号量。如果长时间等待后才能获取数据，在这样的情况下，前面中断控制和自旋锁都不能很好地解决，于是我们开发了信号量。信号量由一套数据结构和函数组成，它能使获取数据的代码执行流进入睡眠，然后在相关条件满足时被唤醒，这样就能让 CPU 能有时间处理其它任务。所以信号量同时解决了三个问题：<strong>等待、互斥、唤醒。</strong></p>
<h2 id="思考题">思考题</h2>
<p>请用代码展示一下自旋锁或者信号量，可能的使用形式是什么样的？</p>
<p>期待你在留言区的分享，也欢迎你把这节课的内容分享给身边的朋友，跟他一起学习交流。</p>
<p>我是 LMOS，我们下节课见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/">操作系统实战45讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%88%90%E4%B8%BAai%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/08_%E7%AE%97%E6%B3%95%E5%85%A8%E6%99%AF%E5%9B%BEai%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E5%BF%85%E9%A1%BB%E8%A6%81%E6%87%82%E7%9A%84%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">08_算法全景图：AI产品经理必须要懂的算法有哪些？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/10x%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B3%95/08_%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%81%9A%E4%BA%8B%E4%B9%8B%E5%89%8D%E8%A6%81%E5%85%88%E8%BF%9B%E8%A1%8C%E6%8E%A8%E6%BC%94/">
            <span class="next-text nav-default">08_为什么说做事之前要先进行推演？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
