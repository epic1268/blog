<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>12_设置工作模式与环境（下）：探查和收集信息 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是 LMOS。
上节课我们动手实现了自己的二级引导器。今天这节课我们将进入二级引导器，完成具体工作的环节。
在二级引导器中，我们要检查 CPU 是否支持 64 位的工作模式、收集内存布局信息，看看是不是合乎我们操作系统的最低运行要求，还要设置操作系统需要的 MMU 页表、设置显卡模式、释放中文字体文件。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/12_%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%8E%A2%E6%9F%A5%E5%92%8C%E6%94%B6%E9%9B%86%E4%BF%A1%E6%81%AF/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/12_%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%8E%A2%E6%9F%A5%E5%92%8C%E6%94%B6%E9%9B%86%E4%BF%A1%E6%81%AF/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="12_设置工作模式与环境（下）：探查和收集信息">
  <meta property="og:description" content="你好，我是 LMOS。
上节课我们动手实现了自己的二级引导器。今天这节课我们将进入二级引导器，完成具体工作的环节。
在二级引导器中，我们要检查 CPU 是否支持 64 位的工作模式、收集内存布局信息，看看是不是合乎我们操作系统的最低运行要求，还要设置操作系统需要的 MMU 页表、设置显卡模式、释放中文字体文件。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="操作系统实战45讲">

  <meta itemprop="name" content="12_设置工作模式与环境（下）：探查和收集信息">
  <meta itemprop="description" content="你好，我是 LMOS。
上节课我们动手实现了自己的二级引导器。今天这节课我们将进入二级引导器，完成具体工作的环节。
在二级引导器中，我们要检查 CPU 是否支持 64 位的工作模式、收集内存布局信息，看看是不是合乎我们操作系统的最低运行要求，还要设置操作系统需要的 MMU 页表、设置显卡模式、释放中文字体文件。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6403">
  <meta itemprop="keywords" content="操作系统实战45讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="12_设置工作模式与环境（下）：探查和收集信息">
  <meta name="twitter:description" content="你好，我是 LMOS。
上节课我们动手实现了自己的二级引导器。今天这节课我们将进入二级引导器，完成具体工作的环节。
在二级引导器中，我们要检查 CPU 是否支持 64 位的工作模式、收集内存布局信息，看看是不是合乎我们操作系统的最低运行要求，还要设置操作系统需要的 MMU 页表、设置显卡模式、释放中文字体文件。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">12_设置工作模式与环境（下）：探查和收集信息</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6403 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#检查与收集机器信息">检查与收集机器信息</a>
          <ul>
            <li><a href="#检查-cpu">检查 CPU</a></li>
            <li><a href="#获取内存布局">获取内存布局</a></li>
            <li><a href="#初始化内核栈">初始化内核栈</a></li>
            <li><a href="#放置内核文件与字库文件">放置内核文件与字库文件</a></li>
            <li><a href="#建立-mmu-页表数据">建立 MMU 页表数据</a></li>
            <li><a href="#设置图形模式">设置图形模式</a></li>
            <li><a href="#串联">串联</a></li>
          </ul>
        </li>
        <li><a href="#显示-logo">显示 Logo</a></li>
        <li><a href="#进入-cosmos">进入 Cosmos</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是 LMOS。</p>
<p>上节课我们动手实现了自己的二级引导器。今天这节课我们将进入二级引导器，完成具体工作的环节。</p>
<p>在二级引导器中，我们要检查 CPU 是否支持 64 位的工作模式、收集内存布局信息，看看是不是合乎我们操作系统的最低运行要求，还要设置操作系统需要的 MMU 页表、设置显卡模式、释放中文字体文件。</p>
<p>今天课程的配套代码，你可以点击这里，自行下载。</p>
<h2 id="检查与收集机器信息">检查与收集机器信息</h2>
<p>如果 ldrkrl_entry() 函数是总裁，那么 init_bstartparm() 函数则是经理，它负责管理检查 CPU 模式、收集内存信息，设置内核栈，设置内核字体、建立内核 MMU 页表数据。</p>
<p>为了使代码更加清晰，我们并不直接在 ldrkrl_entry() 函数中搞事情，而是准备在另一个 bstartparm.c 文件中实现一个 init_bstartparm()。</p>
<p>下面我们就来动手实现它，如下所示。</p>
<p>//初始化 machbstart_t 结构体，清 0，并设置一个标志<br>
void machbstart_t_init(machbstart_t* initp)<br>
{<br>
memset(initp,0,sizeof(machbstart_t));<br>
initp-&gt;mb_migc=MBS_MIGC;<br>
return;<br>
}<br>
void init_bstartparm()<br>
{<br>
machbstart_t* mbsp = MBSPADR;//1MB 的内存地址<br>
machbstart_t_init(mbsp);<br>
return;<br>
}</p>
<p>目前我们的经理 init_bstartparm() 函数只是调用了一个 machbstart_t_init() 函数，在 1MB 内存地址处初始化了一个机器信息结构 machbstart_t，后面随着干活越来越多，还会调用更多的函数的。</p>
<h3 id="检查-cpu">检查 CPU</h3>
<p>首先要检查我们的 CPU，因为它是执行程序的关键。我们要搞清楚它能执行什么形式的代码，支持 64 位长模式吗？</p>
<p>这个工作我们交给 init_chkcpu() 函数来干，由于我们要 CPUID 指令来检查 CPU 是否支持 64 位长模式，所以这个函数中需要找两个帮工：<strong>chk_cpuid、chk_cpu_longmode</strong> 来干两件事，一个是检查 CPU 否支持 CPUID 指令，然后另一个用 CPUID 指令检查 CPU 支持 64 位长模式。</p>
<p>下面我们去写好它们，如下所示。</p>
<p>//通过改写 Eflags 寄存器的第 21 位，观察其位的变化判断是否支持 CPUID<br>
int chk_cpuid()<br>
{<br>
int rets = 0;<br>
<strong>asm</strong> <strong>volatile</strong>(<br>
&ldquo;pushfl \n\t&rdquo;<br>
&ldquo;popl %%eax \n\t&rdquo;<br>
&ldquo;movl %%eax,%%ebx \n\t&rdquo;<br>
&ldquo;xorl $0x0200000,%%eax \n\t&rdquo;<br>
&ldquo;pushl %%eax \n\t&rdquo;<br>
&ldquo;popfl \n\t&rdquo;<br>
&ldquo;pushfl \n\t&rdquo;<br>
&ldquo;popl %%eax \n\t&rdquo;<br>
&ldquo;xorl %%ebx,%%eax \n\t&rdquo;<br>
&ldquo;jz 1f \n\t&rdquo;<br>
&ldquo;movl $1,%0 \n\t&rdquo;<br>
&ldquo;jmp 2f \n\t&rdquo;<br>
&ldquo;1: movl $0,%0 \n\t&rdquo;<br>
&ldquo;2: \n\t&rdquo;<br>
: &ldquo;=c&rdquo;(rets)<br>
:<br>
:);<br>
return rets;<br>
}<br>
//检查 CPU 是否支持长模式<br>
int chk_cpu_longmode()<br>
{<br>
int rets = 0;<br>
<strong>asm</strong> <strong>volatile</strong>(<br>
&ldquo;movl $0x80000000,%%eax \n\t&rdquo;<br>
&ldquo;cpuid \n\t&rdquo; //把 eax 中放入 0x80000000 调用 CPUID 指令<br>
&ldquo;cmpl $0x80000001,%%eax \n\t&rdquo;//看 eax 中返回结果<br>
&ldquo;setnb %%al \n\t&rdquo; //不为 0x80000001，则不支持 0x80000001 号功能<br>
&ldquo;jb 1f \n\t&rdquo;<br>
&ldquo;movl $0x80000001,%%eax \n\t&rdquo;<br>
&ldquo;cpuid \n\t&rdquo;//把 eax 中放入 0x800000001 调用 CPUID 指令，检查 edx 中的返回数据<br>
&ldquo;bt $29,%%edx  \n\t&rdquo; //长模式 支持位  是否为 1<br>
&ldquo;setcb %%al \n\t&rdquo;<br>
&ldquo;1: \n\t&rdquo;<br>
&ldquo;movzx %%al,%%eax \n\t&rdquo;<br>
: &ldquo;=a&rdquo;(rets)<br>
:<br>
:);<br>
return rets;<br>
}<br>
//检查 CPU 主函数<br>
void init_chkcpu(machbstart_t *mbsp)<br>
{<br>
if (!chk_cpuid())<br>
{<br>
kerror(&ldquo;Your CPU is not support CPUID sys is die!&rdquo;);<br>
CLI_HALT();<br>
}<br>
if (!chk_cpu_longmode())<br>
{<br>
kerror(&ldquo;Your CPU is not support 64bits mode sys is die!&rdquo;);<br>
CLI_HALT();<br>
}<br>
mbsp-&gt;mb_cpumode = 0x40;//如果成功则设置机器信息结构的 cpu 模式为 64 位<br>
return;<br>
}</p>
<p>上述代码中，检查 CPU 是否支持 CPUID 指令和检查 CPU 是否支持长模式，只要其中一步检查失败，我们就打印一条相应的提示信息，然后主动死机。<strong>这里需要你留意的是，最后设置机器信息结构中的 mb_cpumode 字段为 64,mbsp 正是传递进来的机器信息 machbstart_t 结构体的指针。</strong></p>
<h3 id="获取内存布局">获取内存布局</h3>
<p>好了，CPU 已经检查完成，合乎我们的要求。下面就要获取内存布局信息了，物理内存在物理地址空间中是一段一段的，描述一段内存有一个数据结构，如下所示。</p>
<p>#define RAM_USABLE 1 //可用内存<br>
#define RAM_RESERV 2 //保留内存不可使用<br>
#define RAM_ACPIREC 3 //ACPI 表相关的<br>
#define RAM_ACPINVS 4 //ACPI NVS 空间<br>
#define RAM_AREACON 5 //包含坏内存<br>
typedef struct s_e820{<br>
u64_t saddr;    /* 内存开始地址 <em>/<br>
u64_t lsize;    /</em> 内存大小 <em>/<br>
u32_t type;    /</em> 内存类型 */<br>
}e820map_t;</p>
<p>获取内存布局信息就是获取这个结构体的数组，这个工作我们交给 init_mem 函数来干，这个函数需要完成两件事：一是获取上述这个结构体数组，二是检查内存大小，因为我们的内核对内存容量有要求，不能太小。</p>
<p>下面我们来动手实现这个 init_mem 函数。</p>
<p>#define ETYBAK_ADR 0x2000<br>
#define PM32_EIP_OFF (ETYBAK_ADR)<br>
#define PM32_ESP_OFF (ETYBAK_ADR+4)<br>
#define E80MAP_NR (ETYBAK_ADR+64)//保存 e820map_t 结构数组元素个数的地址<br>
#define E80MAP_ADRADR (ETYBAK_ADR+68) //保存 e820map_t 结构数组的开始地址<br>
void init_mem(machbstart_t *mbsp)<br>
{<br>
e820map_t *retemp;<br>
u32_t retemnr = 0;<br>
mmap(&amp;retemp, &amp;retemnr);<br>
if (retemnr == 0)<br>
{<br>
kerror(&ldquo;no e820map\n&rdquo;);<br>
}<br>
//根据 e820map_t 结构数据检查内存大小<br>
if (chk_memsize(retemp, retemnr, 0x100000, 0x8000000) == NULL)<br>
{<br>
kerror(&ldquo;Your computer is low on memory, the memory cannot be less than 128MB!&rdquo;);<br>
}<br>
mbsp-&gt;mb_e820padr = (u64_t)((u32_t)(retemp));//把 e820map_t 结构数组的首地址传给 mbsp-&gt;mb_e820padr<br>
mbsp-&gt;mb_e820nr = (u64_t)retemnr;//把 e820map_t 结构数组元素个数传给 mbsp-&gt;mb_e820nr<br>
mbsp-&gt;mb_e820sz = retemnr * (sizeof(e820map_t));//把 e820map_t 结构数组大小传给 mbsp-&gt;mb_e820sz<br>
mbsp-&gt;mb_memsz = get_memsize(retemp, retemnr);//根据 e820map_t 结构数据计算内存大小。<br>
return;<br>
}</p>
<p>上面最难写的是 mmap 函数。不过，我们还是有办法破解的。如果你理解了前面调用 BIOS 的机制，就会发现，<strong>只要调用了 BIOS 中断，就能获取 e820map 结构数组</strong>。</p>
<p>为了验证这个结论，我们来看一下 mmap 的函数调用关系：</p>
<p>void mmap(e820map_t **retemp, u32_t *retemnr)<br>
{<br>
realadr_call_entry(RLINTNR(0), 0, 0);<br>
*retemnr = *((u32_t *)(E80MAP_NR));<br>
*retemp = (e820map_t <em>)(</em>((u32_t *)(E80MAP_ADRADR)));<br>
return;<br>
}</p>
<p>可以看到，mmap 函数正是通过前面讲的 <strong>realadr_call_entry 函数</strong>，来调用实模式下的 _getmmap 函数的，并且在 _getmmap 函数中调用 BIOS 中断的。</p>
<p>_getmmap:<br>
push ds<br>
push es<br>
push ss<br>
mov esi,0<br>
mov dword[E80MAP_NR],esi<br>
mov dword[E80MAP_ADRADR],E80MAP_ADR ;e820map 结构体开始地址<br>
xor ebx,ebx<br>
mov edi,E80MAP_ADR<br>
loop:<br>
mov eax,0e820h ;获取 e820map 结构参数<br>
mov ecx,20    ;e820map 结构大小<br>
mov edx,0534d4150h ;获取 e820map 结构参数必须是这个数据<br>
int 15h  ;BIOS 的 15h 中断<br>
jc .1<br>
add edi,20<br>
cmp edi,E80MAP_ADR+0x1000<br>
jg .1<br>
inc esi<br>
cmp ebx,0<br>
jne loop ;循环获取 e820map 结构<br>
jmp .2<br>
.1:<br>
mov esi,0    ;出错处理，e820map 结构数组元素个数为 0<br>
.2:<br>
mov dword[E80MAP_NR],esi ;e820map 结构数组元素个数<br>
pop ss<br>
pop es<br>
pop ds<br>
ret</p>
<p>如果你不明白上面代码的原理，请回到“Cache 与内存：程序放在哪儿”那节课，看一下获取内存视图相关的知识点。</p>
<p>init_mem 函数在调用 mmap 函数后，就会得到 e820map 结构数组，其首地址和数组元素个数由 retemp，retemnr 两个变量分别提供。</p>
<h3 id="初始化内核栈">初始化内核栈</h3>
<p>因为我们的操作系统是 C 语言写的，所以需要有栈，下面我们就来给即将运行的内核初始化一个栈。这个操作非常简单，就是在机器信息结构 machbstart_t 中，记录一下栈地址和栈大小，供内核在启动时使用。</p>
<p>不过，就算操作再简单，我们也要封装成函数来使用。让我们动手来写出这个函数吧，如下所示。</p>
<p>#define IKSTACK_PHYADR (0x90000-0x10)<br>
#define IKSTACK_SIZE 0x1000<br>
//初始化内核栈<br>
void init_krlinitstack(machbstart_t *mbsp)<br>
{<br>
if (1 &gt; move_krlimg(mbsp, (u64_t)(0x8f000), 0x1001))<br>
{<br>
kerror(&ldquo;iks_moveimg err&rdquo;);<br>
}<br>
mbsp-&gt;mb_krlinitstack = IKSTACK_PHYADR;//栈顶地址<br>
mbsp-&gt;mb_krlitstacksz = IKSTACK_SIZE; //栈大小是 4KB<br>
return;<br>
}</p>
<p>init_krlinitstack 函数非常简单，但是其中调用了一个 move_krlimg 函数你要注意，这个我已经帮你写好啦，它主要负责判断一个地址空间是否和内存中存放的内容有冲突。</p>
<p>因为我们的内存中已经放置了机器信息结构、内存视图结构数组、二级引导器、内核映像文件，所以在处理内存空间时不能和内存中已经存在的他们冲突，否则就要覆盖他们的数据。0x8f000～（0x8f000+0x1001），正是我们的内核栈空间，我们需要检测它是否和其它空间有冲突。</p>
<h3 id="放置内核文件与字库文件">放置内核文件与字库文件</h3>
<p>放置内核文件和字库文件这一步，也非常简单，甚至放置其它文件也一样。</p>
<p>因为我们的内核已经编译成了一个独立的二进制程序，和其它文件一起被打包到映像文件中了。所以我们必须要从映像中把它解包出来，将其放在特定的物理内存空间中才可以，放置字库文件和放置内核文件的原理一样，所以我们来一起实现。</p>
<p>//放置内核文件<br>
void init_krlfile(machbstart_t *mbsp)<br>
{<br>
//在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找 kernel.bin 文件<br>
u64_t sz = r_file_to_padr(mbsp, IMGKRNL_PHYADR, &ldquo;kernel.bin&rdquo;);<br>
if (0 == sz)<br>
{<br>
kerror(&ldquo;r_file_to_padr err&rdquo;);<br>
}<br>
//放置完成后更新机器信息结构中的数据<br>
mbsp-&gt;mb_krlimgpadr = IMGKRNL_PHYADR;<br>
mbsp-&gt;mb_krlsz = sz;<br>
//mbsp-&gt;mb_nextwtpadr 始终要保持指向下一段空闲内存的首地址<br>
mbsp-&gt;mb_nextwtpadr = P4K_ALIGN(mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz);<br>
mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz;<br>
return;<br>
}<br>
//放置字库文件<br>
void init_defutfont(machbstart_t *mbsp)<br>
{<br>
u64_t sz = 0;<br>
//获取下一段空闲内存空间的首地址<br>
u32_t dfadr = (u32_t)mbsp-&gt;mb_nextwtpadr;<br>
//在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找 font.fnt 文件<br>
sz = r_file_to_padr(mbsp, dfadr, &ldquo;font.fnt&rdquo;);<br>
if (0 == sz)<br>
{<br>
kerror(&ldquo;r_file_to_padr err&rdquo;);<br>
}<br>
//放置完成后更新机器信息结构中的数据<br>
mbsp-&gt;mb_bfontpadr = (u64_t)(dfadr);<br>
mbsp-&gt;mb_bfontsz = sz;<br>
//更新机器信息结构中下一段空闲内存的首地址 <br>
mbsp-&gt;mb_nextwtpadr = P4K_ALIGN((u32_t)(dfadr) + sz);<br>
mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_bfontpadr + mbsp-&gt;mb_bfontsz;<br>
return;<br>
}</p>
<p>以上代码的注释已经很清楚了，都是调用 r_file_to_padr 函数在映像中查找 kernel.bin 和 font.fnt 文件，并复制到对应的空闲内存空间中。</p>
<p>请注意，由于内核是代码数据，所以必须要复制到指定的内存空间中。r_file_to_padr 函数我已经帮你写好了，其中的原理在前面的内容里已经做了说明，这里不再展开。</p>
<h3 id="建立-mmu-页表数据">建立 MMU 页表数据</h3>
<p>前面解决了文件放置问题，我们还要解决另一个问题——建立 MMU 页表。</p>
<p>我们在二级引导器中建立 MMU 页表数据，目的就是要在内核加载运行之初开启长模式时，MMU 需要的页表数据已经准备好了。</p>
<p>由于我们的内核虚拟地址空间从 0xffff800000000000 开始，所以我们这个虚拟地址映射到从物理地址 0 开始，大小都是 0x400000000 即 16GB，也就是说我们要虚拟地址空间：0xffff800000000000～0xffff800400000000 映射到物理地址空间 0～0x400000000。</p>
<p>我们为了简化编程，使用<strong>长模式下的 2MB 分页方式</strong>，下面我们用代码实现它，如下所示。</p>
<p>#define KINITPAGE_PHYADR 0x1000000<br>
void init_bstartpages(machbstart_t *mbsp)<br>
{<br>
//顶级页目录<br>
u64_t *p = (u64_t *)(KINITPAGE_PHYADR);//16MB 地址处<br>
//页目录指针<br>
u64_t *pdpte = (u64_t *)(KINITPAGE_PHYADR + 0x1000);<br>
//页目录<br>
u64_t *pde = (u64_t *)(KINITPAGE_PHYADR + 0x2000);<br>
//物理地址从 0 开始<br>
u64_t adr = 0;<br>
if (1 &gt; move_krlimg(mbsp, (u64_t)(KINITPAGE_PHYADR), (0x1000 * 16 + 0x2000)))<br>
{<br>
kerror(&ldquo;move_krlimg err&rdquo;);<br>
}<br>
//将顶级页目录、页目录指针的空间清 0<br>
for (uint_t mi = 0; mi &lt; PGENTY_SIZE; mi++)<br>
{<br>
p[mi] = 0;<br>
pdpte[mi] = 0;<br>
}<br>
//映射<br>
for (uint_t pdei = 0; pdei &lt; 16; pdei++)<br>
{<br>
pdpte[pdei] = (u64_t)((u32_t)pde | KPDPTE_RW | KPDPTE_P);<br>
for (uint_t pdeii = 0; pdeii &lt; PGENTY_SIZE; pdeii++)<br>
{//大页 KPDE_PS 2MB，可读写 KPDE_RW，存在 KPDE_P<br>
pde[pdeii] = 0 | adr | KPDE_PS | KPDE_RW | KPDE_P;<br>
adr += 0x200000;<br>
}<br>
pde = (u64_t *)((u32_t)pde + 0x1000);<br>
}<br>
//让顶级页目录中第 0 项和第 ((KRNL_VIRTUAL_ADDRESS_START) &raquo; KPML4_SHIFT) &amp; 0x1ff 项，指向同一个页目录指针页 <br>
p[((KRNL_VIRTUAL_ADDRESS_START) &raquo; KPML4_SHIFT) &amp; 0x1ff] = (u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P);<br>
p[0] = (u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P);<br>
//把页表首地址保存在机器信息结构中<br>
mbsp-&gt;mb_pml4padr = (u64_t)(KINITPAGE_PHYADR);<br>
mbsp-&gt;mb_subpageslen = (u64_t)(0x1000 * 16 + 0x2000);<br>
mbsp-&gt;mb_kpmapphymemsz = (u64_t)(0x400000000);<br>
return;<br>
}</p>
<p>这个函数的代码写得非常简单，<strong>映射的核心逻辑由两重循环控制</strong>，外层循环控制页目录指针顶，只有 16 项，其中每一项都指向一个页目录，每个页目录中有 512 个物理页地址。</p>
<p>物理地址每次增加 2MB，这是由 26～30 行的内层循环控制，每执行一次外层循环就要执行 512 次内层循环。</p>
<p>最后，顶级页目录中第 0 项和第 ((KRNL_VIRTUAL_ADDRESS_START) &raquo; KPML4_SHIFT) &amp; 0x1ff 项，指向同一个页目录指针页，这样的话就能让虚拟地址：0xffff800000000000～0xffff800400000000 和虚拟地址：0～0x400000000，访问到同一个物理地址空间 0～0x400000000，这样做是有目的，<strong>内核在启动初期，虚拟地址和物理地址要保持相同。</strong></p>
<h3 id="设置图形模式">设置图形模式</h3>
<p>在计算机加电启动时，计算机上显卡会自动进入文本模式，文本模式只能显示 ASCII 字符，不能显示汉字和图形，所以我们要让显卡切换到图形模式。</p>
<p>切换显卡模式依然要用 BIOS 中断，这个调用原理我们前面已经了如指掌。在实模式切换显卡模式的汇编代码，我已经帮你写好了，下面我们只要写个 C 函数调用它们就好了，代码如下所示。</p>
<p>void init_graph(machbstart_t* mbsp)<br>
{<br>
//初始化图形数据结构<br>
graph_t_init(&amp;mbsp-&gt;mb_ghparm);<br>
//获取 VBE 模式，通过 BIOS 中断<br>
get_vbemode(mbsp);<br>
//获取一个具体 VBE 模式的信息，通过 BIOS 中断<br>
get_vbemodeinfo(mbsp);<br>
//设置 VBE 模式，通过 BIOS 中断<br>
set_vbemodeinfo();<br>
return;<br>
}</p>
<p>上面 init_graph 函数中的这些处理 VBE 模式的代码，我已经帮你写好，你可以自己在 graph.c 文件查看。</p>
<p>什么？你不懂 VBE，其实我开始也不懂，后来通过搜寻资料才知道。</p>
<p>其实 VBE 是显卡的一个图形规范标准，它定义了显卡的几种图形模式，每个模式包括屏幕分辨率，像素格式与大小，显存大小。调用 BIOS 10h 中断可以返回这些数据结构。如果你实在对 VBE 感兴趣，可以自行阅读其规范 。</p>
<p>这里我们选择使用了 VBE 的 118h 模式，该模式下屏幕分辨率为 1024x768，显存大小是 16.8MB。显存开始地址一般为 0xe0000000。</p>
<p>屏幕分辨率为 1024x768，即把屏幕分成 768 行，每行 1024 个像素点，但每个像素点占用显存的 32 位数据（4 字节，红、绿、蓝、透明各占 8 位）。我们只要往对应的显存地址写入相应的像素数据，屏幕对应的位置就能显示了。</p>
<p>每个像素点，我们可以用如下数据结构表示：</p>
<p>typedef struct s_PIXCL<br>
{<br>
u8_t cl_b; //蓝<br>
u8_t cl_g; //绿<br>
u8_t cl_r; //红<br>
u8_t cl_a; //透明<br>
}<strong>attribute</strong>((packed)) pixcl_t;</p>
<p>#define BGRA(r,g,b) ((0|(r&laquo;16)|(g&laquo;8)|b))<br>
//通常情况下用 pixl_t 和 BGRA 宏<br>
typedef u32_t pixl_t;</p>
<p>我们再来看看屏幕像素点和显存位置对应的计算方式：</p>
<p>u32_t* dispmem = (u32_t*)mbsp-&gt;mb_ghparm.gh_framphyadr;<br>
dispmem[x + (y * 1024)] = pix;<br>
//x，y 是像素的位置</p>
<h3 id="串联">串联</h3>
<p>好了，所有的实施工作的函数已经完成了，现在我们需要在 init_bstartparm() 函数中把它们串联起来，即按照事情的先后顺序，依次调用它们完成相应的工作，实现检查、收集机器信息，设置工作环境。</p>
<p>void init_bstartparm()<br>
{<br>
machbstart_t *mbsp = MBSPADR;<br>
machbstart_t_init(mbsp);<br>
//检查 CPU<br>
init_chkcpu(mbsp);<br>
//获取内存布局<br>
init_mem(mbsp);<br>
//初始化内核栈<br>
init_krlinitstack(mbsp);<br>
//放置内核文件<br>
init_krlfile(mbsp);<br>
//放置字库文件<br>
init_defutfont(mbsp);<br>
init_meme820(mbsp);<br>
//建立 MMU 页表<br>
init_bstartpages(mbsp);<br>
//设置图形模式<br>
init_graph(mbsp);<br>
return;<br>
}</p>
<p>到这里，init_bstartparm() 函数就成功完成了它的使命。</p>
<h2 id="显示-logo">显示 Logo</h2>
<p>前面我们已经设置了图形模式，也应该要展示一下了，检查一下工作成果。</p>
<p>我们来显示一下我们内核的 logo。其实在二级引导器中，我已经帮你写好了显示 logo 函数，而 logo 文件是个 <strong>24 位的位图文件</strong>，目前为了简单起见，我们<strong>只支持这种格式的图片文件</strong>。下面我们去调用这个函数。</p>
<p>void logo(machbstart_t* mbsp)<br>
{<br>
u32_t retadr=0,sz=0;<br>
//在映像文件中获取 logo.bmp 文件<br>
get_file_rpadrandsz(&ldquo;logo.bmp&rdquo;,mbsp,&amp;retadr,&amp;sz);<br>
if(0==retadr)<br>
{<br>
kerror(&ldquo;logo getfilerpadrsz err&rdquo;);<br>
}<br>
//显示 logo 文件中的图像数据<br>
bmp_print((void*)retadr,mbsp);<br>
return;<br>
}<br>
void init_graph(machbstart_t* mbsp)<br>
{   <br>
//……前面代码省略<br>
//显示<br>
logo(mbsp);<br>
return;<br>
}</p>
<p>在图格式的文件中，除了文件头的数据就是图形像素点的数据，只不过 24 位的位图每个像素占用 3 字节，并且位置是倒排的，即第一个像素的数据是在文件的最后，依次类推。我们只要依次将位图文件的数据，按照倒排次序写入显存中，这样就可以显示了。</p>
<p>我们需要把二级引导器的文件和 logo 文件打包成映像文件，然后放在虚拟硬盘中。</p>
<p>复制文件到虚拟硬盘中得先 mount，然后复制，最后转换成 VDI 格式的虚拟硬盘，再挂载到虚拟机上启动就行了。这也是为什么要手动建立硬盘的原因，打包命令如下。</p>
<p>lmoskrlimg -m k -lhf initldrimh.bin -o Cosmos.eki -f initldrsve.bin initldrkrl.bin font.fnt logo.bmp</p>
<p>如果手动打命令对你来说还是比较难，也别担心，我已经帮你写好了 make 脚本，你只需要进入代码目录中 make vboxtest 就行了，运行结果如下。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/8d8988ed257eed3fb56809ddde97f291.png" alt=""></p>
<p>代码运行结果示意图</p>
<p>啊哈！终于显示了 logo。是不是挺有成就感的？这至少证明我们辛苦写的代码是正确的。</p>
<p>但是目前我们的代码执行流还在二级引导器中，我们的目的是开发自己的操作系统，不，我们是要开发 Cosmos。</p>
<p>**后面，我们正式用 Cosmos 命名我们的操作系统。**Cosmos 可以翻译成宇宙，尽管它刚刚诞生，但我对它充满期待，所以用了这样一个能够“包括万物，包罗万象”的名字。</p>
<h2 id="进入-cosmos">进入 Cosmos</h2>
<p>我们在调用 Cosmos 第一个 C 函数之前，我们依然要写一小段汇编代码，切换 CPU 到长模式，初始化 CPU 寄存器和 C 语言要用的栈。因为目前代码执行流在二级引导器中，进入到 Cosmos 中这样在二级引导器中初始过的东西都不能用了。</p>
<p>因为 CPU 进入了长模式，寄存器的位宽都变了，所以需要重新初始化。让我们一起来写这段汇编代码吧，我们先在 Cosmos/hal/x86/ 下建立一个 init_entry.asm 文件，写上后面这段代码。</p>
<p>[section .start.text]<br>
[BITS 32]<br>
_start:<br>
cli<br>
mov ax,0x10<br>
mov ds,ax<br>
mov es,ax<br>
mov ss,ax<br>
mov fs,ax<br>
mov gs,ax<br>
lgdt [eGdtPtr]       <br>
;开启 PAE<br>
mov eax, cr4<br>
bts eax, 5                      ; CR4.PAE = 1<br>
mov cr4, eax<br>
mov eax, PML4T_BADR             ;加载 MMU 顶级页目录<br>
mov cr3, eax <br>
;开启 64bits long-mode<br>
mov ecx, IA32_EFER<br>
rdmsr<br>
bts eax, 8                      ; IA32_EFER.LME =1<br>
wrmsr<br>
;开启 PE 和 paging<br>
mov eax, cr0<br>
bts eax, 0                      ; CR0.PE =1<br>
bts eax, 31<br>
;开启 CACHE      <br>
btr eax,29                    ; CR0.NW=0<br>
btr eax,30                    ; CR0.CD=0  CACHE<br>
mov cr0, eax                    ; IA32_EFER.LMA = 1<br>
jmp 08:entry64<br>
[BITS 64]<br>
entry64:<br>
mov ax,0x10<br>
mov ds,ax<br>
mov es,ax<br>
mov ss,ax<br>
mov fs,ax<br>
mov gs,ax<br>
xor rax,rax<br>
xor rbx,rbx<br>
xor rbp,rbp<br>
xor rcx,rcx<br>
xor rdx,rdx<br>
xor rdi,rdi<br>
xor rsi,rsi<br>
xor r8,r8<br>
xor r9,r9<br>
xor r10,r10<br>
xor r11,r11<br>
xor r12,r12<br>
xor r13,r13<br>
xor r14,r14<br>
xor r15,r15<br>
mov rbx,MBSP_ADR<br>
mov rax,KRLVIRADR<br>
mov rcx,[rbx+KINITSTACK_OFF]<br>
add rax,rcx<br>
xor rcx,rcx<br>
xor rbx,rbx<br>
mov rsp,rax<br>
push 0<br>
push 0x8<br>
mov rax,hal_start                 ;调用内核主函数<br>
push rax<br>
dw 0xcb48<br>
jmp $<br>
[section .start.data]<br>
[BITS 32]<br>
x64_GDT:<br>
enull_x64_dsc:  dq 0 <br>
ekrnl_c64_dsc:  dq 0x0020980000000000   ; 64-bit 内核代码段<br>
ekrnl_d64_dsc:  dq 0x0000920000000000   ; 64-bit 内核数据段<br>
euser_c64_dsc:  dq 0x0020f80000000000   ; 64-bit 用户代码段<br>
euser_d64_dsc:  dq 0x0000f20000000000   ; 64-bit 用户数据段<br>
eGdtLen      equ  $ - enull_x64_dsc   ; GDT 长度<br>
eGdtPtr:    dw eGdtLen - 1      ; GDT 界限<br>
dq ex64_GDT</p>
<p>上述代码中，1～11 行表示加载 70～75 行的 GDT，13～17 行是设置 MMU 并加载在二级引导器中准备好的 MMU 页表，19～30 行是开启长模式并打开 Cache，34～54 行则是初始化长模式下的寄存器，55～61 行是读取二级引导器准备的机器信息结构中的栈地址，并用这个数据设置 RSP 寄存器。</p>
<p>最关键的是 63～66 行，它开始把 8 和 hal_start 函数的地址压入栈中。dw 0xcb48 是直接写一条指令的机器码——0xcb48，这是一条返回指令。这个返回指令有点特殊，它会把栈中的数据分别弹出到 RIP，CS 寄存器，这正是为了调用我们 Cosmos 的<strong>第一个 C 函数 hal_start</strong>。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>这是我们设置工作模式与环境的最后一课，到此为止我们的二级引导器已经建立起来了，成功从 GRUB 手中接过了权柄，开始了它自己的一系列工作，二级引导器完成的工作不算少，我来帮你梳理一下，重点如下。</p>
<p>1. 二级引导器彻底摆脱了 GRUB 的控制之后，就开始检查 CPU，获取内存布局信息，确认是不是我们要求的 CPU 和内存大小，接着初始化内核栈、放置好内核文件和字库文件，建立 MMU 页表数据和设置好图形模式，为后面运行内核做好准备。</p>
<p>2. 当二级引导器完成了上述功能后，就会显示我们操作系统的 logo，这标志着二级引导器所有的工作一切正常。</p>
<p>3. 进入 Cosmos，我们的二级引导器通过跳转到 Cosmos 的入口，结束了自己光荣使命，Cosmos 的入口是一小段汇编代码，主要是开启 CPU 的长模式，最后调用了 Cosmos 的第一个 C 函数 hal_start。</p>
<p>你想过吗？我们的二级引导器还可以做更多的事情，其实还可以在二级引导器中获取 ACPI 表，进而获取 CPU 数量和其它设备信息，期待你的实现。</p>
<h2 id="思考题">思考题</h2>
<p>请你想一下，init_bstartparm() 函数中的 init_mem820() 函数，这个函数到底干了什么？</p>
<p>欢迎你在留言区跟我互动。如果你身边有朋友对手写操作系统有热情，也欢迎你把这节课转发给他。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/">操作系统实战45讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1/12_%E5%A6%82%E4%BD%95%E5%B0%86%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%90%BD%E5%9C%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">12_如何将注册中心落地？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E8%AF%BE/12_%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E4%B8%8B%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E9%AB%98%E6%95%88%E7%8E%87%E5%9C%B0%E6%9F%A5%E5%AD%97%E5%85%B8/">
            <span class="next-text nav-default">12_树的深度优先搜索（下）：如何才能高效率地查字典？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
