<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>21_土地需求扩大与保障：如何分配和释放虚拟内存？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是 LMOS。
今天，我们继续研究操作系统如何实现虚拟内存。在上节课，我们已经建立了虚拟内存的初始流程，这节课我们来实现虚拟内存的核心功能：写出分配、释放虚拟地址空间的代码，最后实现虚拟地址空间到物理地址空间的映射。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/21_%E5%9C%9F%E5%9C%B0%E9%9C%80%E6%B1%82%E6%89%A9%E5%A4%A7%E4%B8%8E%E4%BF%9D%E9%9A%9C%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%92%8C%E9%87%8A%E6%94%BE%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/21_%E5%9C%9F%E5%9C%B0%E9%9C%80%E6%B1%82%E6%89%A9%E5%A4%A7%E4%B8%8E%E4%BF%9D%E9%9A%9C%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%92%8C%E9%87%8A%E6%94%BE%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="21_土地需求扩大与保障：如何分配和释放虚拟内存？">
  <meta property="og:description" content="你好，我是 LMOS。
今天，我们继续研究操作系统如何实现虚拟内存。在上节课，我们已经建立了虚拟内存的初始流程，这节课我们来实现虚拟内存的核心功能：写出分配、释放虚拟地址空间的代码，最后实现虚拟地址空间到物理地址空间的映射。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="操作系统实战45讲">

  <meta itemprop="name" content="21_土地需求扩大与保障：如何分配和释放虚拟内存？">
  <meta itemprop="description" content="你好，我是 LMOS。
今天，我们继续研究操作系统如何实现虚拟内存。在上节课，我们已经建立了虚拟内存的初始流程，这节课我们来实现虚拟内存的核心功能：写出分配、释放虚拟地址空间的代码，最后实现虚拟地址空间到物理地址空间的映射。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6913">
  <meta itemprop="keywords" content="操作系统实战45讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="21_土地需求扩大与保障：如何分配和释放虚拟内存？">
  <meta name="twitter:description" content="你好，我是 LMOS。
今天，我们继续研究操作系统如何实现虚拟内存。在上节课，我们已经建立了虚拟内存的初始流程，这节课我们来实现虚拟内存的核心功能：写出分配、释放虚拟地址空间的代码，最后实现虚拟地址空间到物理地址空间的映射。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">21_土地需求扩大与保障：如何分配和释放虚拟内存？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6913 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#虚拟地址的空间的分配与释放">虚拟地址的空间的分配与释放</a>
          <ul>
            <li><a href="#虚拟地址空间分配接口">虚拟地址空间分配接口</a></li>
            <li><a href="#分配时查找虚拟地址区间">分配时查找虚拟地址区间</a></li>
            <li><a href="#虚拟地址空间释放接口">虚拟地址空间释放接口</a></li>
            <li><a href="#释放时查找虚拟地址区间">释放时查找虚拟地址区间</a></li>
          </ul>
        </li>
        <li><a href="#测试环节虚拟空间能正常访问么">测试环节：虚拟空间能正常访问么？</a>
          <ul>
            <li><a href="#准备工作">准备工作</a></li>
            <li><a href="#异常情况与原因分析">异常情况与原因分析</a></li>
            <li><a href="#开始处理缺页异常">开始处理缺页异常</a></li>
            <li><a href="#处理缺页异常的核心">处理缺页异常的核心</a></li>
            <li><a href="#缺页地址是否合法">缺页地址是否合法</a></li>
            <li><a href="#建立-kvmemcbox_t-结构">建立 kvmemcbox_t 结构</a></li>
            <li><a href="#映射物理内存页面">映射物理内存页面</a></li>
          </ul>
        </li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是 LMOS。</p>
<p>今天，我们继续研究操作系统如何实现虚拟内存。在上节课，我们已经建立了虚拟内存的初始流程，这节课我们来实现虚拟内存的核心功能：写出分配、释放虚拟地址空间的代码，最后实现虚拟地址空间到物理地址空间的映射。</p>
<p>这节课的配套代码，你可以点击这里下载。</p>
<h2 id="虚拟地址的空间的分配与释放">虚拟地址的空间的分配与释放</h2>
<p>通过上节课的学习，我们知道整个虚拟地址空间就是由一个个虚拟地址区间组成的。那么不难猜到，分配一个虚拟地址空间就是在整个虚拟地址空间分割出一个区域，而释放一块虚拟地址空间，就是把这个区域合并到整个虚拟地址空间中去。</p>
<h3 id="虚拟地址空间分配接口">虚拟地址空间分配接口</h3>
<p>我们先来研究地址的分配，依然从虚拟地址空间的分配接口开始实现，一步步带着你完成虚拟 空间的分配。</p>
<p>在我们的想像中，分配虚拟地址空间应该有大小、有类型、有相关标志，还有从哪里开始分配等信息。根据这些信息，我们在 krlvadrsmem.c 文件中设计好分配虚拟地址空间的接口，如下所示。</p>
<p>adr_t vma_new_vadrs_core(mmadrsdsc_t *mm, adr_t start, size_t vassize, u64_t vaslimits, u32_t vastype)<br>
{<br>
adr_t retadrs = NULL;<br>
kmvarsdsc_t *newkmvd = NULL, *currkmvd = NULL;<br>
virmemadrs_t *vma = &amp;mm-&gt;msd_virmemadrs;<br>
knl_spinlock(&amp;vma-&gt;vs_lock);<br>
//查找虚拟地址区间<br>
currkmvd = vma_find_kmvarsdsc(vma, start, vassize);<br>
if (NULL == currkmvd)<br>
{<br>
retadrs = NULL;<br>
goto out;<br>
}<br>
//进行虚拟地址区间进行检查看能否复用这个数据结构<br>
if (((NULL == start) || (start == currkmvd-&gt;kva_end)) &amp;&amp; (vaslimits == currkmvd-&gt;kva_limits) &amp;&amp; (vastype == currkmvd-&gt;kva_maptype))<br>
{//能复用的话，当前虚拟地址区间的结束地址返回<br>
retadrs = currkmvd-&gt;kva_end;<br>
//扩展当前虚拟地址区间的结束地址为分配虚拟地址区间的大小<br>
currkmvd-&gt;kva_end += vassize;<br>
vma-&gt;vs_currkmvdsc = currkmvd;<br>
goto out;<br>
}<br>
//建立一个新的 kmvarsdsc_t 虚拟地址区间结构<br>
newkmvd = new_kmvarsdsc();<br>
if (NULL == newkmvd)<br>
{<br>
retadrs = NULL;<br>
goto out;<br>
}<br>
//如果分配的开始地址为 NULL 就由系统动态决定<br>
if (NULL == start)<br>
{//当然是接着当前虚拟地址区间之后开始<br>
newkmvd-&gt;kva_start = currkmvd-&gt;kva_end;<br>
}<br>
else<br>
{//否则这个新的虚拟地址区间的开始就是请求分配的开始地址<br>
newkmvd-&gt;kva_start = start;<br>
}<br>
//设置新的虚拟地址区间的结束地址<br>
newkmvd-&gt;kva_end = newkmvd-&gt;kva_start + vassize;<br>
newkmvd-&gt;kva_limits = vaslimits;<br>
newkmvd-&gt;kva_maptype = vastype;<br>
newkmvd-&gt;kva_mcstruct = vma;<br>
vma-&gt;vs_currkmvdsc = newkmvd;<br>
//将新的虚拟地址区间加入到 virmemadrs_t 结构中<br>
list_add(&amp;newkmvd-&gt;kva_list, &amp;currkmvd-&gt;kva_list);<br>
//看看新的虚拟地址区间是否是最后一个<br>
if (list_is_last(&amp;newkmvd-&gt;kva_list, &amp;vma-&gt;vs_list) == TRUE)<br>
{<br>
vma-&gt;vs_endkmvdsc = newkmvd;<br>
}<br>
//返回新的虚拟地址区间的开始地址<br>
retadrs = newkmvd-&gt;kva_start;<br>
out:<br>
knl_spinunlock(&amp;vma-&gt;vs_lock);<br>
return retadrs;<br>
}<br>
//分配虚拟地址空间的接口<br>
adr_t vma_new_vadrs(mmadrsdsc_t *mm, adr_t start, size_t vassize, u64_t vaslimits, u32_t vastype)<br>
{<br>
if (NULL == mm || 1 &gt; vassize)<br>
{<br>
return NULL;<br>
}<br>
if (NULL != start)<br>
{//进行参数检查，开始地址要和页面（1KB）对齐，结束地址不能超过整个虚拟地址空间<br>
if (((start &amp; 0xfff) != 0) || (0x1000 &gt; start) || (USER_VIRTUAL_ADDRESS_END &lt; (start + vassize)))<br>
{<br>
return NULL;<br>
}<br>
}<br>
//调用虚拟地址空间分配的核心函数<br>
return vma_new_vadrs_core(mm, start, VADSZ_ALIGN(vassize), vaslimits, vastype);<br>
}</p>
<p>上述代码中依然是接口函数进行参数检查，然后调用核心函数完成实际的工作。在核心函数中，会调用 vma_find_kmvarsdsc 函数去查找 virmemadrs_t 结构中的所有 kmvarsdsc_t 结构，找出合适的虚拟地址区间。</p>
<p>需要注意的是，<strong>我们允许应用程序指定分配虚拟地址空间的开始地址，也可以由系统决定，但是应用程序指定的话，分配更容易失败，因为很可能指定的开始地址已经被占用了。</strong></p>
<p>接口的实现并不是很难，接下来我们继续完成核心实现。</p>
<h3 id="分配时查找虚拟地址区间">分配时查找虚拟地址区间</h3>
<p>在前面的核心函数中我写上了 vma_find_kmvarsdsc 函数，但是我们并没有实现它，现在我们就来完成这项工作，主要是根据分配的开始地址和大小，在 virmemadrs_t 结构中查找相应的 kmvarsdsc_t 结构。</p>
<p>它是如何查找的呢？举个例子吧，比如 virmemadrs_t 结构中有两个 kmvarsdsc_t 结构，A_kmvarsdsc_t 结构表示 0x1000～0x4000 的虚拟地址空间，B_kmvarsdsc_t 结构表示 0x7000～0x9000 的虚拟地址空间。</p>
<p>这时，我们分配 2KB 的虚拟地址空间，vma_find_kmvarsdsc 函数查找发现 A_kmvarsdsc_t 结构和 B_kmvarsdsc_t 结构之间正好有 0x4000～0x7000 的空间，刚好放得下 0x2000 大小的空间，于是这个函数就会返回 A_kmvarsdsc_t 结构，否则就会继续向后查找。</p>
<p>明白了原理，我们就来写代码。</p>
<p>//检查 kmvarsdsc_t 结构<br>
kmvarsdsc_t *vma_find_kmvarsdsc_is_ok(virmemadrs_t *vmalocked, kmvarsdsc_t *curr, adr_t start, size_t vassize)<br>
{<br>
kmvarsdsc_t *nextkmvd = NULL;<br>
adr_t newend = start + (adr_t)vassize;<br>
//如果 curr 不是最后一个先检查当前 kmvarsdsc_t 结构<br>
if (list_is_last(&amp;curr-&gt;kva_list, &amp;vmalocked-&gt;vs_list) == FALSE)<br>
{//就获取 curr 的下一个 kmvarsdsc_t 结构<br>
nextkmvd = list_next_entry(curr, kmvarsdsc_t, kva_list);<br>
//由系统动态决定分配虚拟空间的开始地址<br>
if (NULL == start)<br>
{//如果 curr 的结束地址加上分配的大小小于等于下一个 kmvarsdsc_t 结构的开始地址就返回 curr<br>
if ((curr-&gt;kva_end + (adr_t)vassize) &lt;= nextkmvd-&gt;kva_start)<br>
{<br>
return curr;<br>
}<br>
}<br>
else<br>
{//否则比较应用指定分配的开始、结束地址是不是在 curr 和下一个 kmvarsdsc_t 结构之间<br>
if ((curr-&gt;kva_end &lt;= start) &amp;&amp; (newend &lt;= nextkmvd-&gt;kva_start))<br>
{<br>
return curr;<br>
}<br>
}<br>
}<br>
else<br>
{//否则 curr 为最后一个 kmvarsdsc_t 结构<br>
if (NULL == start)<br>
{//curr 的结束地址加上分配空间的大小是不是小于整个虚拟地址空间<br>
if ((curr-&gt;kva_end + (adr_t)vassize) &lt; vmalocked-&gt;vs_isalcend)<br>
{<br>
return curr;<br>
}<br>
}<br>
else<br>
{//否则比较应用指定分配的开始、结束地址是不是在 curr 的结束地址和整个虚拟地址空间的结束地址之间<br>
if ((curr-&gt;kva_end &lt;= start) &amp;&amp; (newend &lt; vmalocked-&gt;vs_isalcend))<br>
{<br>
return curr;<br>
}<br>
}<br>
}<br>
return NULL;<br>
}<br>
//查找 kmvarsdsc_t 结构<br>
kmvarsdsc_t *vma_find_kmvarsdsc(virmemadrs_t *vmalocked, adr_t start, size_t vassize)<br>
{<br>
kmvarsdsc_t *kmvdcurrent = NULL, *curr = vmalocked-&gt;vs_currkmvdsc;<br>
adr_t newend = start + vassize;<br>
list_h_t *listpos = NULL;<br>
//分配的虚拟空间大小小于 4KB 不行<br>
if (0x1000 &gt; vassize)<br>
{<br>
return NULL;<br>
}<br>
//将要分配虚拟地址空间的结束地址大于整个虚拟地址空间 不行<br>
if (newend &gt; vmalocked-&gt;vs_isalcend)<br>
{<br>
return NULL;<br>
}</p>
<pre><code>if (NULL != curr)  
{//先检查当前 kmvarsdsc_t 结构行不行  
    kmvdcurrent = vma_find_kmvarsdsc_is_ok(vmalocked, curr, start, vassize);  
    if (NULL != kmvdcurrent)  
    {  
        return kmvdcurrent;  
    }  
}  
//遍历 virmemadrs_t 中的所有的 kmvarsdsc_t 结构  
list_for_each(listpos, &amp;vmalocked-&gt;vs_list)  
{  
    curr = list_entry(listpos, kmvarsdsc_t, kva_list);  
    //检查每个 kmvarsdsc_t 结构  
    kmvdcurrent = vma_find_kmvarsdsc_is_ok(vmalocked, curr, start, vassize);  
    if (NULL != kmvdcurrent)  
    {//如果符合要求就返回  
        return kmvdcurrent;  
    }  
}  
return NULL;  
</code></pre>
<p>}</p>
<p>结合前面的描述和代码注释，我们发现 <strong>vma_find_kmvarsdsc 函数才是这个分配虚拟地址空间算法的核心实现</strong>，真的这么简单？是的，对分配虚拟地址空间，真的结束了。</p>
<p>不过，这个分配的虚拟地址空间可以使用吗？这个问题，等我们解决了虚拟地址空间的释放，再来处理。</p>
<h3 id="虚拟地址空间释放接口">虚拟地址空间释放接口</h3>
<p>有分配就要有释放，否则再大的虚拟地址空间也会用完，下面我们就来研究如何释放一个虚拟地址空间。我们依然从设计接口开始，这次我们只需要释放的虚拟空间的开始地址和大小就行了。我们来写代码实现吧，如下所示。</p>
<p>//释放虚拟地址空间的核心函数<br>
bool_t vma_del_vadrs_core(mmadrsdsc_t *mm, adr_t start, size_t vassize)<br>
{<br>
bool_t rets = FALSE;<br>
kmvarsdsc_t *newkmvd = NULL, *delkmvd = NULL;<br>
virmemadrs_t *vma = &amp;mm-&gt;msd_virmemadrs;<br>
knl_spinlock(&amp;vma-&gt;vs_lock);<br>
//查找要释放虚拟地址空间的 kmvarsdsc_t 结构<br>
delkmvd = vma_del_find_kmvarsdsc(vma, start, vassize);<br>
if (NULL == delkmvd)<br>
{<br>
rets = FALSE;<br>
goto out;<br>
}<br>
//第一种情况要释放的虚拟地址空间正好等于查找的 kmvarsdsc_t 结构<br>
if ((delkmvd-&gt;kva_start == start) &amp;&amp; (delkmvd-&gt;kva_end == (start + (adr_t)vassize)))<br>
{<br>
//脱链<br>
list_del(&amp;delkmvd-&gt;kva_list);<br>
//删除 kmvarsdsc_t 结构<br>
del_kmvarsdsc(delkmvd);<br>
vma-&gt;vs_kmvdscnr&ndash;;<br>
rets = TRUE;<br>
goto out;<br>
}<br>
//第二种情况要释放的虚拟地址空间是在查找的 kmvarsdsc_t 结构的上半部分<br>
if ((delkmvd-&gt;kva_start == start) &amp;&amp; (delkmvd-&gt;kva_end &gt; (start + (adr_t)vassize)))<br>
{    //所以直接把查找的 kmvarsdsc_t 结构的开始地址设置为释放虚拟地址空间的结束地址<br>
delkmvd-&gt;kva_start = start + (adr_t)vassize;<br>
rets = TRUE;<br>
goto out;<br>
}<br>
//第三种情况要释放的虚拟地址空间是在查找的 kmvarsdsc_t 结构的下半部分<br>
if ((delkmvd-&gt;kva_start &lt; start) &amp;&amp; (delkmvd-&gt;kva_end == (start + (adr_t)vassize)))<br>
{//所以直接把查找的 kmvarsdsc_t 结构的结束地址设置为释放虚拟地址空间的开始地址<br>
delkmvd-&gt;kva_end = start;<br>
rets = TRUE;<br>
goto out;<br>
}<br>
//第四种情况要释放的虚拟地址空间是在查找的 kmvarsdsc_t 结构的中间<br>
if ((delkmvd-&gt;kva_start &lt; start) &amp;&amp; (delkmvd-&gt;kva_end &gt; (start + (adr_t)vassize)))<br>
{//所以要再新建一个 kmvarsdsc_t 结构来处理释放虚拟地址空间之后的下半虚拟部分地址空间<br>
newkmvd = new_kmvarsdsc();<br>
if (NULL == newkmvd)<br>
{<br>
rets = FALSE;<br>
goto out;<br>
}<br>
//让新的 kmvarsdsc_t 结构指向查找的 kmvarsdsc_t 结构的后半部分虚拟地址空间<br>
newkmvd-&gt;kva_end = delkmvd-&gt;kva_end;<br>
newkmvd-&gt;kva_start = start + (adr_t)vassize;<br>
//和查找到的 kmvarsdsc_t 结构保持一致<br>
newkmvd-&gt;kva_limits = delkmvd-&gt;kva_limits;<br>
newkmvd-&gt;kva_maptype = delkmvd-&gt;kva_maptype;<br>
newkmvd-&gt;kva_mcstruct = vma;<br>
delkmvd-&gt;kva_end = start;<br>
//加入链表<br>
list_add(&amp;newkmvd-&gt;kva_list, &amp;delkmvd-&gt;kva_list);<br>
vma-&gt;vs_kmvdscnr++;<br>
//是否为最后一个 kmvarsdsc_t 结构<br>
if (list_is_last(&amp;newkmvd-&gt;kva_list, &amp;vma-&gt;vs_list) == TRUE)<br>
{<br>
vma-&gt;vs_endkmvdsc = newkmvd;<br>
vma-&gt;vs_currkmvdsc = newkmvd;<br>
}<br>
else<br>
{<br>
vma-&gt;vs_currkmvdsc = newkmvd;<br>
}<br>
rets = TRUE;<br>
goto out;<br>
}<br>
rets = FALSE;<br>
out:<br>
knl_spinunlock(&amp;vma-&gt;vs_lock);<br>
return rets;<br>
}<br>
//释放虚拟地址空间的接口<br>
bool_t vma_del_vadrs(mmadrsdsc_t *mm, adr_t start, size_t vassize)<br>
{    //对参数进行检查<br>
if (NULL == mm || 1 &gt; vassize || NULL == start)<br>
{<br>
return FALSE;<br>
}<br>
//调用核心处理函数<br>
return vma_del_vadrs_core(mm, start, VADSZ_ALIGN(vassize));<br>
}</p>
<p>结合上面的代码和注释，我相信你能够看懂。需要注意的是，处理释放虚拟地址空间的四种情况。</p>
<p>因为分配虚拟地址空间时，我们<strong>为了节约 kmvarsdsc_t 结构占用的内存空间</strong>，规定只要分配的虚拟地址空间上一个虚拟地址空间是连续且类型相同的，我们就<strong>借用</strong>上一个 kmvarsdsc_t 结构，而不是重新分配一个 kmvarsdsc_t 结构表示新分配的虚拟地址空间。</p>
<p>你可以想像一下，一个应用每次分配一个页面的虚拟地址空间，不停地分配，而每个新分配的虚拟地址空间都有一个 kmvarsdsc_t 结构对应，这样物理内存将很快被耗尽。</p>
<h3 id="释放时查找虚拟地址区间">释放时查找虚拟地址区间</h3>
<p>上面释放虚拟地址空间的核心处理函数 vma_del_vadrs_core 函数中，调用了 vma_del_find_kmvarsdsc 函数，用于查找要释放虚拟地址空间的 kmvarsdsc_t 结构，可是为什么不用分配虚拟地址空间时那个查找函数（vma_find_kmvarsdsc）呢？</p>
<p>这是因为释放时查找的要求不一样。释放时仅仅需要保证，释放的虚拟地址空间的开始地址和结束地址，他们落在某一个 kmvarsdsc_t 结构表示的虚拟地址区间就行，所以我们还是另写一个函数，代码如下。</p>
<p>kmvarsdsc_t *vma_del_find_kmvarsdsc(virmemadrs_t *vmalocked, adr_t start, size_t vassize)<br>
{<br>
kmvarsdsc_t *curr = vmalocked-&gt;vs_currkmvdsc;<br>
adr_t newend = start + (adr_t)vassize;<br>
list_h_t *listpos = NULL;</p>
<pre><code>if (NULL != curr)  
{//释放的虚拟地址空间落在了当前 kmvarsdsc_t 结构表示的虚拟地址区间  
    if ((curr-&gt;kva_start) &lt;= start &amp;&amp; (newend &lt;= curr-&gt;kva_end))  
    {  
        return curr;  
    }  
}  
//遍历所有的 kmvarsdsc_t 结构  
list_for_each(listpos, &amp;vmalocked-&gt;vs_list)  
{  
    curr = list_entry(listpos, kmvarsdsc_t, kva_list);  
    //释放的虚拟地址空间是否落在了其中的某个 kmvarsdsc_t 结构表示的虚拟地址区间  
    if ((start &gt;= curr-&gt;kva_start) &amp;&amp; (newend &lt;= curr-&gt;kva_end))  
    {  
        return curr;  
    }  
}  
return NULL;  
</code></pre>
<p>}</p>
<p>释放时，查找虚拟地址区间的函数非常简单，仅仅是检查释放的虚拟地址空间是否落在查找 kmvarsdsc_t 结构表示的虚拟地址区间中，而可能的四种变换形式，交给核心释放函数处理。到这里，我们释放虚拟地址空间的功能就实现了。</p>
<h2 id="测试环节虚拟空间能正常访问么">测试环节：虚拟空间能正常访问么？</h2>
<p>我们已经实现了虚拟地址空间的分配和释放，但是我们从未访问过分配的虚拟地址空间，也不知道能不能访问，会有什么我们没有预想到的结果。保险起见，我们这就进入测试环节，试一试访问一下分配的虚拟地址空间。</p>
<h3 id="准备工作">准备工作</h3>
<p>想要访问一个虚拟地址空间，当然需要先分配一个虚拟地址空间，所以我们要做点准备工作，写点测试代码，分配一个虚拟地址空间并访问它，代码如下。</p>
<p>//测试函数<br>
void test_vadr()<br>
{<br>
//分配一个 0x1000 大小的虚拟地址空间<br>
adr_t vadr = vma_new_vadrs(&amp;initmmadrsdsc, NULL, 0x1000, 0, 0);<br>
//返回 NULL 表示分配失败<br>
if(NULL == vadr)<br>
{<br>
kprint(&ldquo;分配虚拟地址空间失败\n&rdquo;);<br>
}<br>
//在刷屏幕上打印分配虚拟地址空间的开始地址<br>
kprint(&ldquo;分配虚拟地址空间地址:%x\n&rdquo;, vadr);<br>
kprint(&ldquo;开始写入分配虚拟地址空间\n&rdquo;);<br>
//访问虚拟地址空间，把这空间全部设置为 0<br>
hal_memset((void*)vadr, 0, 0x1000);<br>
kprint(&ldquo;结束写入分配虚拟地址空间\n&rdquo;);<br>
return;<br>
}<br>
void init_kvirmemadrs()<br>
{<br>
//……<br>
//调用测试函数<br>
test_vadr();<br>
return;<br>
}</p>
<p>你大概已经猜到，这个在 init_kvirmemadrs 函数的最后调用的 test_vadr 函数，一旦执行，一定会发生异常。为了显示这个异常，我们要在异常分发器函数中写点代码。代码如下所示。</p>
<p>//cosmos/hal/x86/halintupt.c<br>
void hal_fault_allocator(uint_t faultnumb, void *krnlsframp)<br>
{<br>
//打印异常号<br>
kprint(&ldquo;faultnumb is :%d\n&rdquo;, faultnumb);<br>
//如果异常号等于 14 则是内存缺页异常<br>
if (faultnumb == 14)<br>
{//打印缺页地址，这地址保存在 CPU 的 CR2 寄存器中<br>
kprint(&ldquo;异常地址:%x，此地址禁止访问\n&rdquo;, read_cr2());<br>
}<br>
//死机，不让这个函数返回了<br>
die(0);<br>
return;<br>
}</p>
<p>上述代码非常简单，下面我们来测试一下，看看最终结果。</p>
<h3 id="异常情况与原因分析">异常情况与原因分析</h3>
<p>所有的代码已经准备好了，我们进入 Cosmos 目录下执行 make vboxtest 指令，等 Cosmos 跑起来的时候，你会看到如下所示的情况。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/42b9fcf73d6b5522aba11fff526f1706.png" alt=""></p>
<p>访问虚拟地址异常截图</p>
<p>上图中，显示我们分配了 0x1000 大小的虚拟地址空间，其虚拟地址是 0x5000，接着对这个地址进行访问，最后产生了缺页异常，缺页的地址正是我们分配的虚拟空间的开始地址。</p>
<p>为什么会发生这个缺页异常呢？因为我们访问了一个虚拟地址，这个虚拟地址由 CPU 发送给 MMU，而 MMU 无法把它转换成对应的物理地址，CPU 的那条访存指令无法执行了，因此就产生一个缺页异常。于是，CPU 跳转到缺页异常处理的入口地址（kernel.asm 文件中的 exc_page_fault 标号处）开始执行代码，处理这个缺页异常。</p>
<p>因为我们仅仅是分配了一个虚拟地址空间，就对它进行访问，所以才会缺页。既然我们并没有为这个虚拟地址空间分配任何物理内存页面，建立对应的 MMU 页表，那我们可不可以分配虚拟地址空间时，就分配物理内存页面并建立好对应的 MMU 页表呢？</p>
<p>这当然可以解决问题，但是现实中往往是等到发生缺页异常了，才分配物理内存页面，建立对应的 MMU 页表。**这种延迟内存分配技术在系统工程中非常有用，因为它能最大限度的节约物理内存。**分配的虚拟地址空间，只有实际访问到了才分配对应的物理内存页面。</p>
<h3 id="开始处理缺页异常">开始处理缺页异常</h3>
<p>准确地说，缺页异常是从 kernel.asm 文件中的 exc_page_fault 标号处开始，但它只是保存了 CPU 的上下文，然后调用了内核的通用异常分发器函数，最后由异常分发器函数调用不同的异常处理函数，如果是缺页异常，就要调用缺页异常处理的接口函数。</p>
<p>这个函数之前还没有写呢，下面我们一起来实现它，代码如下所示。</p>
<p>//缺页异常处理接口<br>
sint_t vma_map_fairvadrs(mmadrsdsc_t <em>mm, adr_t vadrs)<br>
{//对参数进行检查<br>
if ((0x1000 &gt; vadrs) || (USER_VIRTUAL_ADDRESS_END &lt; vadrs) || (NULL == mm))<br>
{<br>
return -EPARAM;<br>
}<br>
//进行缺页异常的核心处理<br>
return vma_map_fairvadrs_core(mm, vadrs);<br>
}<br>
//由异常分发器调用的接口<br>
sint_t krluserspace_accessfailed(adr_t fairvadrs)<br>
{//这里应该获取当前进程的 mm，但是现在我们没有进程，才 initmmadrsdsc 代替<br>
mmadrsdsc_t</em> mm = &amp;initmmadrsdsc;<br>
//应用程序的虚拟地址不可能大于 USER_VIRTUAL_ADDRESS_END<br>
if(USER_VIRTUAL_ADDRESS_END &lt; fairvadrs)<br>
{<br>
return -EACCES;<br>
}<br>
return vma_map_fairvadrs(mm, fairvadrs);<br>
}</p>
<p>上面的接口函数非常简单，不过我们要在 cosmos/hal/x86/halintupt.c 文件的异常分发器函数中来调用它，代码如下所示。</p>
<p>void hal_fault_allocator(uint_t faultnumb, void *krnlsframp)<br>
{<br>
adr_t fairvadrs;<br>
kprint(&ldquo;faultnumb is :%d\n&rdquo;, faultnumb);<br>
if (faultnumb == 14)<br>
{    //获取缺页的地址<br>
fairvadrs = (adr_t)read_cr2();<br>
kprint(&ldquo;异常地址:%x，此地址禁止访问\n&rdquo;, fairvadrs);<br>
if (krluserspace_accessfailed(fairvadrs) != 0)<br>
{//处理缺页失败就死机<br>
system_error(&ldquo;缺页处理失败\n&rdquo;);<br>
}<br>
//成功就返回<br>
return;<br>
}<br>
die(0);<br>
return;<br>
}</p>
<p>接口函数和调用流程已经写好了，下面就要真正开始处理缺页了。</p>
<h3 id="处理缺页异常的核心">处理缺页异常的核心</h3>
<p>在前面缺页异常处理接口时，调用了 vma_map_fairvadrs_core 函数，来进行缺页异常的核心处理、那缺页异常处理究竟有哪些操作呢？</p>
<p>这里给你留个悬念，我先来写个函数，你可以结合自己的观察，想想它做了什么，代码如下所示。</p>
<p>sint_t vma_map_fairvadrs_core(mmadrsdsc_t *mm, adr_t vadrs)<br>
{<br>
sint_t rets = FALSE;<br>
adr_t phyadrs = NULL;<br>
virmemadrs_t *vma = &amp;mm-&gt;msd_virmemadrs;<br>
kmvarsdsc_t *kmvd = NULL;<br>
kvmemcbox_t *kmbox = NULL;<br>
knl_spinlock(&amp;vma-&gt;vs_lock);<br>
//查找对应的 kmvarsdsc_t 结构<br>
kmvd = vma_map_find_kmvarsdsc(vma, vadrs);<br>
if (NULL == kmvd)<br>
{<br>
rets = -EFAULT;<br>
goto out;<br>
}<br>
//返回 kmvarsdsc_t 结构下对应 kvmemcbox_t 结构<br>
kmbox = vma_map_retn_kvmemcbox(kmvd);<br>
if (NULL == kmbox)<br>
{<br>
rets = -ENOMEM;<br>
goto out;<br>
}<br>
//分配物理内存页面并建立 MMU 页表<br>
phyadrs = vma_map_phyadrs(mm, kmvd, vadrs, (0 | PML4E_US | PML4E_RW | PML4E_P));<br>
if (NULL == phyadrs)<br>
{<br>
rets = -ENOMEM;<br>
goto out;<br>
}<br>
rets = EOK;<br>
out:<br>
knl_spinunlock(&amp;vma-&gt;vs_lock);<br>
return rets;<br>
}</p>
<p>通过对上述代码的观察，你就能发现，以上代码中做了三件事。</p>
<p>首先，查找缺页地址对应的 kmvarsdsc_t 结构，没找到说明没有分配该虚拟地址空间，那属于非法访问不予处理；然后，查找 kmvarsdsc_t 结构下面的对应 kvmemcbox_t 结构，它是用来挂载物理内存页面的；最后，分配物理内存页面并建立 MMU 页表映射关系。</p>
<p>下面我们分别来实现这三个步骤。</p>
<h3 id="缺页地址是否合法">缺页地址是否合法</h3>
<p>要想判断一个缺页地址是否合法，我们就要确定它是不是已经分配的虚拟地址，也就是看这个虚拟地址是不是会落在某个 kmvarsdsc_t 结构表示的虚拟地址区间。</p>
<p>因此，我们要去查找相应的 kmvarsdsc_t 结构，如果没有找到则虚拟地址没有分配，即这个缺页地址不合法。这个查找 kmvarsdsc_t 结构的函数可以这样写。</p>
<p>kmvarsdsc_t *vma_map_find_kmvarsdsc(virmemadrs_t *vmalocked, adr_t vadrs)<br>
{<br>
list_h_t *pos = NULL;<br>
kmvarsdsc_t *curr = vmalocked-&gt;vs_currkmvdsc;<br>
//看看上一次刚刚被操作的 kmvarsdsc_t 结构<br>
if (NULL != curr)<br>
{//虚拟地址是否落在 kmvarsdsc_t 结构表示的虚拟地址区间<br>
if ((vadrs &gt;= curr-&gt;kva_start) &amp;&amp; (vadrs &lt; curr-&gt;kva_end))<br>
{<br>
return curr;<br>
}<br>
}<br>
//遍历每个 kmvarsdsc_t 结构<br>
list_for_each(pos, &amp;vmalocked-&gt;vs_list)<br>
{<br>
curr = list_entry(pos, kmvarsdsc_t, kva_list);<br>
//虚拟地址是否落在 kmvarsdsc_t 结构表示的虚拟地址区间<br>
if ((vadrs &gt;= curr-&gt;kva_start) &amp;&amp; (vadrs &lt; curr-&gt;kva_end))<br>
{<br>
return curr;<br>
}<br>
}<br>
return NULL;<br>
}</p>
<p>这个函数非常简单，核心逻辑就是用虚拟地址和 kmvarsdsc_t 结构中的数据做比较，大于等于 kmvarsdsc_t 结构的开始地址并且小于 kmvarsdsc_t 结构的结束地址，就行了。</p>
<h3 id="建立-kvmemcbox_t-结构">建立 kvmemcbox_t 结构</h3>
<p>kvmemcbox_t 结构可以用来挂载物理内存页面 msadsc_t 结构，而这个 msadsc_t 结构是由虚拟地址区间 kmvarsdsc_t 结构代表的虚拟空间所映射的物理内存页面。一个 kmvarsdsc_t 结构，必须要有一个 kvmemcbox_t 结构，才能分配物理内存。除了这个功能，kvmemcbox_t 结构还可以在内存共享的时候使用。</p>
<p>现在我们一起来写个函数，实现建立 kvmemcbox_t 结构，代码如下所示。</p>
<p>kvmemcbox_t *vma_map_retn_kvmemcbox(kmvarsdsc_t *kmvd)<br>
{<br>
kvmemcbox_t *kmbox = NULL;<br>
//如果 kmvarsdsc_t 结构中已经存在了 kvmemcbox_t 结构，则直接返回<br>
if (NULL != kmvd-&gt;kva_kvmbox)<br>
{<br>
return kmvd-&gt;kva_kvmbox;<br>
}<br>
//新建一个 kvmemcbox_t 结构<br>
kmbox = knl_get_kvmemcbox();<br>
if (NULL == kmbox)<br>
{<br>
return NULL;<br>
}<br>
//指向这个新建的 kvmemcbox_t 结构<br>
kmvd-&gt;kva_kvmbox = kmbox;<br>
return kmvd-&gt;kva_kvmbox;<br>
}</p>
<p>上述代码非常简单，knl_get_kvmemcbox 函数就是调用 kmsob_new 函数分配一个 kvmemcbox_t 结构大小的内存空间对象，然后其中实例化 kvmemcbox_t 结构的变量。</p>
<h3 id="映射物理内存页面">映射物理内存页面</h3>
<p>好，现在我们正式给虚拟地址分配对应的物理内存页面，建立对应的 MMU 页表，使虚拟地址到物理地址可以转换成功，数据终于能写入到物理内存之中了。</p>
<p>这个步骤完成，就意味着缺页处理完成了，我们来写代码吧。</p>
<p>adr_t vma_map_msa_fault(mmadrsdsc_t *mm, kvmemcbox_t *kmbox, adr_t vadrs, u64_t flags)<br>
{<br>
msadsc_t *usermsa;<br>
adr_t phyadrs = NULL;<br>
//分配一个物理内存页面，挂载到 kvmemcbox_t 中，并返回对应的 msadsc_t 结构<br>
usermsa = vma_new_usermsa(mm, kmbox);<br>
if (NULL == usermsa)<br>
{//没有物理内存页面返回 NULL 表示失败<br>
return NULL;<br>
}<br>
//获取 msadsc_t 对应的内存页面的物理地址<br>
phyadrs = msadsc_ret_addr(usermsa);<br>
//建立 MMU 页表完成虚拟地址到物理地址的映射<br>
if (hal_mmu_transform(&amp;mm-&gt;msd_mmu, vadrs, phyadrs, flags) == TRUE)<br>
{//映射成功则返回物理地址<br>
return phyadrs;<br>
}<br>
//映射失败就要先释放分配的物理内存页面<br>
vma_del_usermsa(mm, kmbox, usermsa, phyadrs);<br>
return NULL;<br>
}<br>
//接口函数<br>
adr_t vma_map_phyadrs(mmadrsdsc_t *mm, kmvarsdsc_t *kmvd, adr_t vadrs, u64_t flags)<br>
{<br>
kvmemcbox_t *kmbox = kmvd-&gt;kva_kvmbox;<br>
if (NULL == kmbox)<br>
{<br>
return NULL;<br>
}<br>
//调用核心函数，flags 表示页表条目中的相关权限、存在、类型等位段<br>
return vma_map_msa_fault(mm, kmbox, vadrs, flags);<br>
}</p>
<p>上述代码中，调用 vma_map_msa_fault 函数做实际的工作。首先，它会调用 vma_new_usermsa 函数，在 vma_new_usermsa 函数内部调用了我们前面学过的页面内存管理接口，分配一个物理内存页面并把对应的 msadsc_t 结构挂载到 kvmemcbox_t 结构上。</p>
<p>接着获取 msadsc_t 结构对应内存页面的物理地址，最后是调用 hal_mmu_transform 函数完成虚拟地址到物理地址的映射工作，它主要是建立 MMU 页表，在 cosmos/hal/x86/halmmu.c 文件中，我已经帮你写好了代码，我相信你结合前面 MMU 相关的课程，你一定能看懂。</p>
<p>vma_map_phyadrs 函数一旦成功返回，就会随着原有的代码路径层层返回。至此，处理缺页异常就结束了。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>今天这节课我们学习了如何实现虚拟内存的分配与释放，现在我把重点为你梳理一下。</p>
<p>首先，我们实现了虚拟地址空间的分配与释放。这是虚拟内存管理的核心功能，通过查找地址区间结构来确定哪些虚拟地址空间已经分配或者空闲。</p>
<p>然后我们解决了缺页异常处理问题。我们分配一段虚拟地址空间，并没有分配对应的物理内存页面，而是等到真正访问虚拟地址空间时，才触发了缺页异常。这时，我们再来处理缺页异常中分配物理内存页面的工作，建立对应的 MMU 页表映射关系。<strong>这种延迟分配技术可以有效节约物理内存。</strong></p>
<p>至此，从物理内存页面管理到内存对象管理再到虚拟内存管理，我们一层一层地建好了 Cosmos 的内存管理组件。内存可以说是专栏的重中之重，以后 Cosmos 内核的其它组件，也都要依赖于内存管理组件。</p>
<h2 id="思考题">思考题</h2>
<p>请问，x86 CPU 的缺页异常，是第几号异常？缺页的地址保存在哪个寄存器中？</p>
<p>欢迎你在留言区跟我交流互动，也感谢你坚持不懈跟我学习，如果你身边有对内存管理感兴趣的朋友，记得把今天这节课分享给他。</p>
<p>好，我是 LMOS，我们下节课见。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/">操作系统实战45讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/21_%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94spark%E4%B8%8Eflink%E5%B8%AE%E4%BD%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%A4%E5%BC%80%E8%8A%B1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">21_深入对比Spark与Flink：帮你系统设计两开花</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/21_%E4%BF%A1%E6%81%AF%E8%BF%87%E8%BD%BD%E4%B8%8E%E6%9C%89%E6%95%88/">
            <span class="next-text nav-default">21_信息：过载与有效</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
