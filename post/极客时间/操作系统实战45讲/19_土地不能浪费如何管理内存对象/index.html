<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>19_土地不能浪费：如何管理内存对象？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是 LMOS。
在前面的课程中，我们建立了物理内存页面管理器，它既可以分配单个页面，也可以分配多个连续的页面，还能指定在特殊内存地址区域中分配页面。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/19_%E5%9C%9F%E5%9C%B0%E4%B8%8D%E8%83%BD%E6%B5%AA%E8%B4%B9%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E5%AF%B9%E8%B1%A1/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/19_%E5%9C%9F%E5%9C%B0%E4%B8%8D%E8%83%BD%E6%B5%AA%E8%B4%B9%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E5%AF%B9%E8%B1%A1/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="19_土地不能浪费：如何管理内存对象？">
  <meta property="og:description" content="你好，我是 LMOS。
在前面的课程中，我们建立了物理内存页面管理器，它既可以分配单个页面，也可以分配多个连续的页面，还能指定在特殊内存地址区域中分配页面。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="操作系统实战45讲">

  <meta itemprop="name" content="19_土地不能浪费：如何管理内存对象？">
  <meta itemprop="description" content="你好，我是 LMOS。
在前面的课程中，我们建立了物理内存页面管理器，它既可以分配单个页面，也可以分配多个连续的页面，还能指定在特殊内存地址区域中分配页面。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="8368">
  <meta itemprop="keywords" content="操作系统实战45讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="19_土地不能浪费：如何管理内存对象？">
  <meta name="twitter:description" content="你好，我是 LMOS。
在前面的课程中，我们建立了物理内存页面管理器，它既可以分配单个页面，也可以分配多个连续的页面，还能指定在特殊内存地址区域中分配页面。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">19_土地不能浪费：如何管理内存对象？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 8368 字 </span>
          <span class="more-meta"> 预计阅读 17 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#malloc-给我们的启发">malloc 给我们的启发</a></li>
        <li><a href="#页还能细分吗">页还能细分吗</a></li>
        <li><a href="#如何表示一个内存对象">如何表示一个内存对象</a></li>
        <li><a href="#内存对象容器">内存对象容器</a></li>
        <li><a href="#初始化">初始化</a></li>
        <li><a href="#分配内存对象">分配内存对象</a>
          <ul>
            <li><a href="#分配内存对象的接口">分配内存对象的接口</a></li>
            <li><a href="#查找内存对象容器">查找内存对象容器</a></li>
            <li><a href="#建立内存对象容器">建立内存对象容器</a></li>
            <li><a href="#扩容内存对象容器">扩容内存对象容器</a></li>
            <li><a href="#分配内存对象-1">分配内存对象</a></li>
          </ul>
        </li>
        <li><a href="#释放内存对象">释放内存对象</a>
          <ul>
            <li><a href="#释放内存对象的接口">释放内存对象的接口</a></li>
            <li><a href="#查找内存对象容器-1">查找内存对象容器</a></li>
            <li><a href="#释放内存对象-1">释放内存对象</a></li>
            <li><a href="#销毁内存对象容器">销毁内存对象容器</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是 LMOS。</p>
<p>在前面的课程中，我们建立了物理内存页面管理器，它既可以分配单个页面，也可以分配多个连续的页面，还能指定在特殊内存地址区域中分配页面。</p>
<p>但你发现没有，物理内存页面管理器一次分配至少是一个页面，而我们对内存分页是一个页面 4KB，即 4096 字节。对于小于一个页面的内存分配请求，它无能为力。如果要实现小于一个页面的内存分配请求，又该怎么做呢？</p>
<p>这节课我们就一起来解决这个问题。课程配套代码，你可以从这里获得。</p>
<h2 id="malloc-给我们的启发">malloc 给我们的启发</h2>
<p>首先，我想和你说说，为什么小于一个页面的内存我们也要格外珍惜？</p>
<p>如果你在大学学过 C 程序设计语言的话，相信你对 C 库中的 malloc 函数也不会陌生，它负责完成分配一块内存空间的功能。</p>
<p>下面的代码。我相信你也写过，或者写过类似的，不用多介绍你也可以明白。</p>
<p>#include &lt;stdio.h&gt;<br>
#include &lt;string.h&gt;<br>
#include &lt;stdlib.h&gt;  <br>
int main() {   <br>
char *str;     <br>
//内存分配 存放 15 个 char 字符类型  <br>
str = (char *) malloc(15);<br>
if (str == NULL) {<br>
printf(&ldquo;mem alloc err\n&rdquo;);<br>
return -1;<br>
}<br>
//把 hello world 字符串复制到 str 开始的内存地址空间中<br>
strcpy(str, &ldquo;hello world&rdquo;);<br>
//打印 hello world 字符串和它的地址   <br>
printf(&ldquo;String = %s,  Address = %u\n&rdquo;, str, str);<br>
//释放分配的内存<br>
free(str);     <br>
return(0);<br>
}</p>
<p>这个代码流程很简单，就是分配一块 15 字节大小的内存空间，然后把字符串复制到分配的内存空间中，最后用字符串的形式打印了那个块内存，最后释放该内存空间。</p>
<p>但我们并不是要了解 malloc、free 函数的工作原理，而是要清楚，像这样分配几个字节内存空间的操作，这在内核中比比皆是。</p>
<h2 id="页还能细分吗">页还能细分吗</h2>
<p>是的，单从内存角度来看，页最小是以字节为单位的。但是从 MMU 角度看，内存是以页为单位的，所以我们的 Cosmos 的物理内存分配器也以页为单位。现在的问题是，内核中有大量远小于一个页面的内存分配请求，如果对此还是分配一个页面，就会浪费内存。</p>
<p>要想解决这个问题，<strong>就要细分“页”这个单位</strong>。虽然从 MMU 角度来看，页不能细分，但是从软件逻辑层面页可以细分，但是如何分，则十分讲究。</p>
<p>结合历史经验和硬件特性（Cache 行大小）来看，我们可以把一个页面或者连续的多个页面，分成 32 字节、64 字节、128 字节、256 字节、512 字节、1024 字节、2048 字节、4096 字节（一个页）。这些都是 Cache 行大小的倍数。我们给这些小块内存取个名字，叫<strong>内存对象</strong>。</p>
<p>我们可以这样设计：**把一个或者多个内存页面分配出来，作为一个内存对象的容器，在这个容器中容纳相同的内存对象，即同等大小的内存块。**你可以把这个容器，想像成一个内存对象数组。为了让你更好理解，我还给你画了张图解释。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/a336ba3eb93d2e261da3f09416e0c1da.png" alt=""></p>
<p>内存对象视图</p>
<h2 id="如何表示一个内存对象">如何表示一个内存对象</h2>
<p>前面只是进行了理论上的设计和构想，下面我们就通过代码来实现这些构想，真正把想法变成现实。</p>
<p>我们从内存对象开始入手。如何表示一个内存对象呢？当然是要设计一个表示内存对象的数据结构，代码如下所示：</p>
<p>typedef struct s_FREOBJH<br>
{<br>
list_h_t oh_list;     //链表<br>
uint_t oh_stus;       //对象状态<br>
void* oh_stat;        //对象的开始地址<br>
}freobjh_t;</p>
<p>我们在后面的代码中就用 freobjh_t 结构表示一个对象，其中的链表是为了找到这个对象。是不是很简单？没错，表示一个内存对象就是如此简单。</p>
<h2 id="内存对象容器">内存对象容器</h2>
<p>光有内存对象还不够，如何放置内存对象是很重要的。根据前面的构想，为了把多个同等大小的内存对象放在一个内存对象容器中，我们需要设计出表示内存对象容器的数据结构。内存容器要占用内存页面，需要内存对象计数信息、内存对象大小信息，还要能扩展容量。</p>
<p>把上述功能综合起来，代码如下所示。</p>
<p>//管理内存对象容器占用的内存页面所对应的 msadsc_t 结构<br>
typedef struct s_MSCLST<br>
{<br>
uint_t ml_msanr;  //多少个 msadsc_t<br>
uint_t ml_ompnr;  //一个 msadsc_t 对应的连续的物理内存页面数<br>
list_h_t ml_list; //挂载 msadsc_t 的链表<br>
}msclst_t;<br>
//管理内存对象容器占用的内存<br>
typedef struct s_MSOMDC<br>
{<br>
//msclst_t 结构数组 mc_lst[0]=1 个连续页面的 msadsc_t<br>
//               mc_lst[1]=2 个连续页面的 msadsc_t<br>
//               mc_lst[2]=4 个连续页面的 msadsc_t<br>
//               mc_lst[3]=8 个连续页面的 msadsc_t<br>
//               mc_lst[4]=16 个连续页面的 msadsc_t<br>
msclst_t mc_lst[MSCLST_MAX];<br>
uint_t mc_msanr;   //总共多个 msadsc_t 结构<br>
list_h_t mc_list;<br>
//内存对象容器第一个占用 msadsc_t<br>
list_h_t mc_kmobinlst;<br>
//内存对象容器第一个占用 msadsc_t 对应的连续的物理内存页面数<br>
uint_t mc_kmobinpnr;<br>
}msomdc_t;<br>
//管理内存对象容器扩展容量<br>
typedef struct s_KMBEXT<br>
{<br>
list_h_t mt_list;        //链表<br>
adr_t mt_vstat;          //内存对象容器扩展容量开始地址<br>
adr_t mt_vend;           //内存对象容器扩展容量结束地址<br>
kmsob_t* mt_kmsb;        //指向内存对象容器结构<br>
uint_t mt_mobjnr;        //内存对象容器扩展容量的内存中有多少对象<br>
}kmbext_t;<br>
//内存对象容器<br>
typedef struct s_KMSOB<br>
{<br>
list_h_t so_list;        //链表<br>
spinlock_t so_lock;      //保护结构自身的自旋锁<br>
uint_t so_stus;          //状态与标志<br>
uint_t so_flgs;<br>
adr_t so_vstat;          //内存对象容器的开始地址<br>
adr_t so_vend;           //内存对象容器的结束地址<br>
size_t so_objsz;         //内存对象大小<br>
size_t so_objrelsz;      //内存对象实际大小<br>
uint_t so_mobjnr;        //内存对象容器中总共的对象个数<br>
uint_t so_fobjnr;        //内存对象容器中空闲的对象个数<br>
list_h_t so_frelst;      //内存对象容器中空闲的对象链表头<br>
list_h_t so_alclst;      //内存对象容器中分配的对象链表头<br>
list_h_t so_mextlst;     //内存对象容器扩展 kmbext_t 结构链表头<br>
uint_t so_mextnr;        //内存对象容器扩展 kmbext_t 结构个数<br>
msomdc_t so_mc;          //内存对象容器占用内存页面管理结构<br>
void* so_privp;          //本结构私有数据指针<br>
void* so_extdp;          //本结构扩展数据指针<br>
}kmsob_t;</p>
<p>这段代码中设计了四个数据结构：kmsob_t 用于表示内存对象容器，kmbext_t 用于表示内存对象容器的扩展内存，msomdc_t 和 msclst_t 用于管理内存对象容器占用的物理内存页面。</p>
<p>你可能很难理解它们之间的关系，所以我为你准备了一幅图，如下所示。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/ba8afed6b72252b5f3a9a8eb84ca0bb2.png" alt=""></p>
<p>内存对象容器关系</p>
<p>结合图示我们可以发现，在一组连续物理内存页面（用来存放内存对象）的开始地址那里，就存放着我们 kmsob_t 和 kmbext_t 的实例变量，它们占用了几十字节的空间。</p>
<h2 id="初始化">初始化</h2>
<p>因为 kmsob_t、kmbext_t、freobjh_t 结构的实例变量，它们是建立内存对象容器时创建并初始化的，这个过程是伴随着分配内存对象而进行的，所以内存对象管理器的初始化很简单。</p>
<p>但是有一点还是要初始化的，那就是<strong>管理 kmsob_t 结构的数据结构</strong>，它用于挂载不同大小的内存容器。现在我们就在 cosmos/hal/x86/ 目录下建立一个 kmsob.c 文件，来实现这个数据结构并初始化，代码如下所示。</p>
<p>#define KOBLST_MAX (64)<br>
//挂载 kmsob_t 结构<br>
typedef struct s_KOBLST<br>
{<br>
list_h_t ol_emplst; //挂载 kmsob_t 结构的链表<br>
kmsob_t* ol_cahe;   //最近一次查找的 kmsob_t 结构<br>
uint_t ol_emnr;     //挂载 kmsob_t 结构的数量<br>
size_t ol_sz;       //kmsob_t 结构中内存对象的大小<br>
}koblst_t;<br>
//管理 kmsob_t 结构的数据结构<br>
typedef struct s_KMSOBMGRHED<br>
{<br>
spinlock_t ks_lock;  //保护自身的自旋锁<br>
list_h_t ks_tclst;   //链表<br>
uint_t ks_tcnr;<br>
uint_t ks_msobnr;    //总共多少个 kmsob_t 结构<br>
kmsob_t* ks_msobche; //最近分配内存对象的 kmsob_t 结构<br>
koblst_t ks_msoblst[KOBLST_MAX]; //koblst_t 结构数组<br>
}kmsobmgrhed_t;<br>
//初始化 koblst_t 结构体<br>
void koblst_t_init(koblst_t *initp, size_t koblsz)<br>
{<br>
list_init(&amp;initp-&gt;ol_emplst);<br>
initp-&gt;ol_cahe = NULL;<br>
initp-&gt;ol_emnr = 0;<br>
initp-&gt;ol_sz = koblsz;<br>
return;<br>
}<br>
//初始化 kmsobmgrhed_t 结构体<br>
void kmsobmgrhed_t_init(kmsobmgrhed_t *initp)<br>
{<br>
size_t koblsz = 32;<br>
knl_spinlock_init(&amp;initp-&gt;ks_lock);<br>
list_init(&amp;initp-&gt;ks_tclst);<br>
initp-&gt;ks_tcnr = 0;<br>
initp-&gt;ks_msobnr = 0;<br>
initp-&gt;ks_msobche = NULL;<br>
for (uint_t i = 0; i &lt; KOBLST_MAX; i++)<br>
{<br>
koblst_t_init(&amp;initp-&gt;ks_msoblst[i], koblsz);<br>
koblsz += 32;//这里并不是按照开始的图形分类的而是每次增加 32 字节，所以是 32，64,96,128,160,192,224，256，&hellip;&hellip;.<br>
}<br>
return;<br>
}<br>
//初始化 kmsob<br>
void init_kmsob()<br>
{<br>
kmsobmgrhed_t_init(&amp;memmgrob.mo_kmsobmgr);<br>
return;<br>
}</p>
<p>上面的代码注释已经很清楚了，就是 init_kmsob 函数调用 kmsobmgrhed_t_init 函数，在其中循环初始化 koblst_t 结构体数组，不多做解释。</p>
<p>但是有一点我们要搞清楚：<strong>kmsobmgrhed_t 结构的实例变量是放在哪里的，它其实放在我们之前的 memmgrob_t 结构中了</strong>，代码如下所示。</p>
<p>//cosmos/include/halinc/halglobal.c<br>
HAL_DEFGLOB_VARIABLE(memmgrob_t,memmgrob);</p>
<p>typedef struct s_MEMMGROB<br>
{<br>
list_h_t mo_list;<br>
spinlock_t mo_lock;<br>
uint_t mo_stus;<br>
uint_t mo_flgs;<br>
//略去很多字段<br>
//管理 kmsob_t 结构的数据结构<br>
kmsobmgrhed_t mo_kmsobmgr;<br>
void* mo_privp;<br>
void* mo_extp;<br>
}memmgrob_t;<br>
//cosmos/hal/x86/memmgrinit.c<br>
void init_memmgr()<br>
{<br>
//初始化内存页结构<br>
init_msadsc();<br>
//初始化内存区结构<br>
init_memarea();<br>
//处理内存占用<br>
init_search_krloccupymm(&amp;kmachbsp);<br>
//合并内存页到内存区中<br>
init_memmgrob();<br>
//初始化 kmsob<br>
init_kmsob();<br>
return;<br>
}</p>
<p>这并没有那么难，是不是？到这里，我们在内存管理初始化 init_memmgr 函数中调用了 init_kmsob 函数，对管理内存对象容器的结构进行了初始化，这样后面我们就能分配内存对象了。</p>
<h2 id="分配内存对象">分配内存对象</h2>
<p>根据前面的初始化过程，我们只是初始化了 kmsobmgrhed_t 结构，却没初始化任何 kmsob_t 结构，而这个结构就是存放内存对象的容器，没有它是不能进行任何分配内存对象的操作的。</p>
<p>下面我们一起在分配内存对象的过程中探索，应该如何查找、建立 kmsob_t 结构，然后在 kmsob_t 结构中建立 freobjh_t 结构，最后在内存对象容器的容量不足时，一起来扩展容器的内存。</p>
<h3 id="分配内存对象的接口">分配内存对象的接口</h3>
<p>分配内存对象的流程，仍然要从分配接口开始。分配内存对象的接口很简单，只有一个内存对象大小的参数，然后返回内存对象的首地址。下面我们先在 kmsob.c 文件中写好这个函数，代码如下所示。</p>
<p>//分配内存对象的核心函数<br>
void *kmsob_new_core(size_t msz)<br>
{<br>
//获取 kmsobmgrhed_t 结构的地址<br>
kmsobmgrhed_t *kmobmgrp = &amp;memmgrob.mo_kmsobmgr;<br>
void *retptr = NULL;<br>
koblst_t *koblp = NULL;<br>
kmsob_t *kmsp = NULL;<br>
cpuflg_t cpuflg;<br>
//对 kmsobmgrhed_t 结构加锁<br>
knl_spinlock_cli(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);<br>
koblp = onmsz_retn_koblst(kmobmgrp, msz);<br>
if (NULL == koblp)<br>
{<br>
retptr = NULL;<br>
goto ret_step;<br>
}<br>
kmsp = onkoblst_retn_newkmsob(koblp, msz);<br>
if (NULL == kmsp)<br>
{<br>
kmsp = _create_kmsob(kmobmgrp, koblp, koblp-&gt;ol_sz);<br>
if (NULL == kmsp)<br>
{<br>
retptr = NULL;<br>
goto ret_step;<br>
}<br>
}<br>
retptr = kmsob_new_onkmsob(kmsp, msz);<br>
if (NULL == retptr)<br>
{<br>
retptr = NULL;<br>
goto ret_step;<br>
}<br>
//更新 kmsobmgrhed_t 结构的信息<br>
kmsob_updata_cache(kmobmgrp, koblp, kmsp, KUC_NEWFLG);<br>
ret_step:<br>
//解锁 kmsobmgrhed_t 结构<br>
knl_spinunlock_sti(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);<br>
return retptr;<br>
}<br>
//内存对象分配接口<br>
void *kmsob_new(size_t msz)<br>
{<br>
//对于小于 1 或者 大于 2048 字节的大小不支持 直接返回 NULL 表示失败<br>
if (1 &gt; msz || 2048 &lt; msz)<br>
{<br>
return NULL;<br>
}<br>
//调用核心函数<br>
return kmsob_new_core(msz);<br>
}</p>
<p>上面代码中，内存对象分配接口很简单，只是对分配内存对象的大小进行检查，然后调用分配内存对象的核心函数，在这个核心函数中，就是围绕我们之前定义的几个数据结构，去进行一系列操作了。</p>
<p>但是究竟做了哪些操作呢，别急，我们继续往下看。</p>
<h3 id="查找内存对象容器">查找内存对象容器</h3>
<p>根据前面的设计，我们已经知道内存对象是放在内存对象容器中的，所以要分配内存对象，必须要先根据要分配的内存对象大小，找到内存对象容器。</p>
<p>同时，我们还知道，内存对象容器数据结构 kmsob_t 就挂载在 kmsobmgrhed_t 数据结构中的 ks_msoblst 数组中，所以我们要遍历 ks_msoblst 数组，我们来写一个 onmsz_retn_koblst 函数，它返回 ks_msoblst 数组元素的指针，表示先根据内存对象的大小找到挂载 kmsob_t 结构对应的 koblst_t 结构。</p>
<p>//看看内存对象容器是不是合乎要求<br>
kmsob_t *scan_newkmsob_isok(kmsob_t *kmsp, size_t msz)<br>
{   <br>
//只要内存对象大小小于等于内存对象容器的对象大小就行<br>
if (msz &lt;= kmsp-&gt;so_objsz)<br>
{<br>
return kmsp;<br>
}<br>
return NULL;<br>
}</p>
<p>koblst_t *onmsz_retn_koblst(kmsobmgrhed_t *kmmgrhlokp, size_t msz)<br>
{<br>
//遍历 ks_msoblst 数组<br>
for (uint_t kli = 0; kli &lt; KOBLST_MAX; kli++)<br>
{<br>
//只要大小合适就返回      <br>
if (kmmgrhlokp-&gt;ks_msoblst[kli].ol_sz &gt;= msz)<br>
{<br>
return &amp;kmmgrhlokp-&gt;ks_msoblst[kli];<br>
}<br>
}<br>
return NULL;<br>
}</p>
<p>kmsob_t *onkoblst_retn_newkmsob(koblst_t *koblp, size_t msz)<br>
{<br>
kmsob_t *kmsp = NULL, *tkmsp = NULL;<br>
list_h_t *tmplst = NULL;<br>
//先看看上次分配所用到的 koblst_t 是不是正好是这次需要的<br>
kmsp = scan_newkmsob_isok(koblp-&gt;ol_cahe, msz);<br>
if (NULL != kmsp)<br>
{<br>
return kmsp;<br>
}<br>
//如果 koblst_t 中挂载的 kmsob_t 大于 0<br>
if (0 &lt; koblp-&gt;ol_emnr)<br>
{<br>
//开始遍历 koblst_t 中挂载的 kmsob_t<br>
list_for_each(tmplst, &amp;koblp-&gt;ol_emplst)<br>
{<br>
tkmsp = list_entry(tmplst, kmsob_t, so_list);<br>
//检查当前 kmsob_t 是否合乎要求<br>
kmsp = scan_newkmsob_isok(tkmsp, msz);<br>
if (NULL != kmsp)<br>
{<br>
return kmsp;<br>
}<br>
}<br>
}<br>
return NULL;<br>
}</p>
<p>上述代码非常好理解，就是通过 onmsz_retn_koblst 函数，它根据内存对象大小查找并返回 ks_msoblst 数组元素的指针，这个数组元素中就挂载着相应的内存对象容器，然后由 onkoblst_retn_newkmsob 函数查询其中的内存对象容器并返回。</p>
<h3 id="建立内存对象容器">建立内存对象容器</h3>
<p>不知道你发现没有，有一种情况必然会发生，那就是第一次分配内存对象时调用 onkoblst_retn_newkmsob 函数，它肯定会返回一个 NULL。因为第一次分配时肯定没有 kmsob_t 结构，所以我们在这个时候建立一个 kmsob_t 结构，即<strong>建立内存对象容器</strong>。</p>
<p>下面我们写一个 _create_kmsob 函数来创建 kmsob_t 结构，并执行一些初始化工作，代码如下所示。</p>
<p>//初始化内存对象数据结构<br>
void freobjh_t_init(freobjh_t *initp, uint_t stus, void *stat)<br>
{<br>
list_init(&amp;initp-&gt;oh_list);<br>
initp-&gt;oh_stus = stus;<br>
initp-&gt;oh_stat = stat;<br>
return;<br>
}<br>
//初始化内存对象容器数据结构<br>
void kmsob_t_init(kmsob_t *initp)<br>
{<br>
list_init(&amp;initp-&gt;so_list);<br>
knl_spinlock_init(&amp;initp-&gt;so_lock);<br>
initp-&gt;so_stus = 0;<br>
initp-&gt;so_flgs = 0;<br>
initp-&gt;so_vstat = NULL;<br>
initp-&gt;so_vend = NULL;<br>
initp-&gt;so_objsz = 0;<br>
initp-&gt;so_objrelsz = 0;<br>
initp-&gt;so_mobjnr = 0;<br>
initp-&gt;so_fobjnr = 0;<br>
list_init(&amp;initp-&gt;so_frelst);<br>
list_init(&amp;initp-&gt;so_alclst);<br>
list_init(&amp;initp-&gt;so_mextlst);<br>
initp-&gt;so_mextnr = 0;<br>
msomdc_t_init(&amp;initp-&gt;so_mc);<br>
initp-&gt;so_privp = NULL;<br>
initp-&gt;so_extdp = NULL;<br>
return;<br>
}<br>
//把内存对象容器数据结构，挂载到对应的 koblst_t 结构中去<br>
bool_t kmsob_add_koblst(koblst_t *koblp, kmsob_t *kmsp)<br>
{<br>
list_add(&amp;kmsp-&gt;so_list, &amp;koblp-&gt;ol_emplst);<br>
koblp-&gt;ol_emnr++;<br>
return TRUE;<br>
}<br>
//初始化内存对象容器<br>
kmsob_t *_create_init_kmsob(kmsob_t *kmsp, size_t objsz, adr_t cvadrs, adr_t cvadre, msadsc_t *msa, uint_t relpnr)<br>
{<br>
//初始化 kmsob 结构体<br>
kmsob_t_init(kmsp);<br>
//设置内存对象容器的开始、结束地址，内存对象大小<br>
kmsp-&gt;so_vstat = cvadrs;<br>
kmsp-&gt;so_vend = cvadre;<br>
kmsp-&gt;so_objsz = objsz;<br>
//把物理内存页面对应的 msadsc_t 结构加入到 kmsob_t 中的 so_mc.mc_kmobinlst 链表上<br>
list_add(&amp;msa-&gt;md_list, &amp;kmsp-&gt;so_mc.mc_kmobinlst);<br>
kmsp-&gt;so_mc.mc_kmobinpnr = (uint_t)relpnr;<br>
//设置内存对象的开始地址为 kmsob_t 结构之后，结束地址为内存对象容器的结束地址<br>
freobjh_t *fohstat = (freobjh_t *)(kmsp + 1), *fohend = (freobjh_t *)cvadre;</p>
<pre><code>uint_t ap = (uint_t)((uint_t)fohstat);  
freobjh_t *tmpfoh = (freobjh_t *)((uint_t)ap);  
for (; tmpfoh &lt; fohend;)  
{//相当在 kmsob_t 结构体之后建立一个 freobjh_t 结构体数组  
    if ((ap + (uint_t)kmsp-&gt;so_objsz) &lt;= (uint_t)cvadre)  
    {//初始化每个 freobjh_t 结构体  
        freobjh_t_init(tmpfoh, 0, (void *)tmpfoh);  
        //把每个 freobjh_t 结构体加入到 kmsob_t 结构体中的 so_frelst 中  
       list_add(&amp;tmpfoh-&gt;oh_list, &amp;kmsp-&gt;so_frelst);  
        kmsp-&gt;so_mobjnr++;  
        kmsp-&gt;so_fobjnr++;  
    }  
    ap += (uint_t)kmsp-&gt;so_objsz;  
    tmpfoh = (freobjh_t *)((uint_t)ap);  
}  
return kmsp;  
</code></pre>
<p>}</p>
<p>//建立一个内存对象容器<br>
kmsob_t *_create_kmsob(kmsobmgrhed_t *kmmgrlokp, koblst_t *koblp, size_t objsz)<br>
{<br>
kmsob_t *kmsp = NULL;<br>
msadsc_t *msa = NULL;<br>
uint_t relpnr = 0;<br>
uint_t pages = 1;<br>
if (128 &lt; objsz)<br>
{<br>
pages = 2;<br>
}<br>
if (512 &lt; objsz)<br>
{<br>
pages = 4;<br>
}<br>
//为内存对象容器分配物理内存空间，这是我们之前实现的物理内存页面管理器<br>
msa = mm_division_pages(&amp;memmgrob, pages, &amp;relpnr, MA_TYPE_KRNL, DMF_RELDIV);<br>
if (NULL == msa)<br>
{<br>
return NULL;<br>
}<br>
u64_t phyadr = msa-&gt;md_phyadrs.paf_padrs &laquo; PSHRSIZE;<br>
u64_t phyade = phyadr + (relpnr &laquo; PSHRSIZE) - 1;<br>
//计算它们的虚拟地址<br>
adr_t vadrs = phyadr_to_viradr((adr_t)phyadr);<br>
adr_t vadre = phyadr_to_viradr((adr_t)phyade);<br>
//初始化 kmsob_t 并建立内存对象<br>
kmsp = _create_init_kmsob((kmsob_t *)vadrs, koblp-&gt;ol_sz, vadrs, vadre, msa, relpnr);<br>
//把 kmsob_t 结构，挂载到对应的 koblst_t 结构中去<br>
if (kmsob_add_koblst(koblp, kmsp) == FALSE)<br>
{<br>
system_error(&quot; _create_kmsob kmsob_add_koblst FALSE\n&quot;);<br>
}<br>
//增加计数<br>
kmmgrlokp-&gt;ks_msobnr++;<br>
return kmsp;</p>
<p>_create_kmsob 函数就是根据分配内存对象大小，建立一个内存对象容器。</p>
<p>首先，这个函数会找物理内存页面管理器申请一块连续内存页面。然后，在其中的开始部分建立 kmsob_t 结构的实例变量，又在 kmsob_t 结构的后面建立 freobjh_t 结构数组，并把每个 freobjh_t 结构挂载到 kmsob_t 结构体中的 so_frelst 中。最后再把 kmsob_t 结构，挂载到 kmsobmgrhed_t 结构对应的 koblst_t 结构中去。</p>
<p>上面的注释已经很清楚了，我相信你看得懂。</p>
<h3 id="扩容内存对象容器">扩容内存对象容器</h3>
<p>如果我们不断重复分配同一大小的内存对象，那么那个内存对象容器中的内存对象，迟早要分配完的。一旦内存对象分配完，内存对象容器就没有空闲的内存空间产生内存对象了。这时，我们就要为内存对象容器扩展内存空间了。</p>
<p>下面我们来写代码实现，如下所示。</p>
<p>//初始化 kmbext_t 结构<br>
void kmbext_t_init(kmbext_t *initp, adr_t vstat, adr_t vend, kmsob_t *kmsp)<br>
{<br>
list_init(&amp;initp-&gt;mt_list);<br>
initp-&gt;mt_vstat = vstat;<br>
initp-&gt;mt_vend = vend;<br>
initp-&gt;mt_kmsb = kmsp;<br>
initp-&gt;mt_mobjnr = 0;<br>
return;<br>
}<br>
//扩展内存页面<br>
bool_t kmsob_extn_pages(kmsob_t *kmsp)<br>
{<br>
msadsc_t *msa = NULL;<br>
uint_t relpnr = 0;<br>
uint_t pages = 1;<br>
if (128 &lt; kmsp-&gt;so_objsz)<br>
{<br>
pages = 2;<br>
}<br>
if (512 &lt; kmsp-&gt;so_objsz)<br>
{<br>
pages = 4;<br>
}<br>
//找物理内存页面管理器分配 2 或者 4 个连续的页面<br>
msa = mm_division_pages(&amp;memmgrob, pages, &amp;relpnr, MA_TYPE_KRNL, DMF_RELDIV);<br>
if (NULL == msa)<br>
{<br>
return FALSE;<br>
}<br>
u64_t phyadr = msa-&gt;md_phyadrs.paf_padrs &laquo; PSHRSIZE;<br>
u64_t phyade = phyadr + (relpnr &laquo; PSHRSIZE) - 1;<br>
adr_t vadrs = phyadr_to_viradr((adr_t)phyadr);<br>
adr_t vadre = phyadr_to_viradr((adr_t)phyade);<br>
//求出物理内存页面数对应在 kmsob_t 的 so_mc.mc_lst 数组中下标<br>
sint_t mscidx = retn_mscidx(relpnr);<br>
//把物理内存页面对应的 msadsc_t 结构加入到 kmsob_t 的 so_mc.mc_lst 数组中<br>
list_add(&amp;msa-&gt;md_list, &amp;kmsp-&gt;so_mc.mc_lst[mscidx].ml_list);<br>
kmsp-&gt;so_mc.mc_lst[mscidx].ml_msanr++;</p>
<pre><code>kmbext_t *bextp = (kmbext_t *)vadrs;  
//初始化 kmbext_t 数据结构  
kmbext_t_init(bextp, vadrs, vadre, kmsp);  
</code></pre>
<p>//设置内存对象的开始地址为 kmbext_t 结构之后，结束地址为扩展内存页面的结束地址<br>
freobjh_t *fohstat = (freobjh_t *)(bextp + 1), *fohend = (freobjh_t *)vadre;</p>
<pre><code>uint_t ap = (uint_t)((uint_t)fohstat);  
freobjh_t *tmpfoh = (freobjh_t *)((uint_t)ap);  
for (; tmpfoh &lt; fohend;)  
{  
    if ((ap + (uint_t)kmsp-&gt;so_objsz) &lt;= (uint_t)vadre)  
    {//在扩展的内存空间中建立内存对象  
        freobjh_t_init(tmpfoh, 0, (void *)tmpfoh);  
        list_add(&amp;tmpfoh-&gt;oh_list, &amp;kmsp-&gt;so_frelst);  
        kmsp-&gt;so_mobjnr++;  
        kmsp-&gt;so_fobjnr++;  
        bextp-&gt;mt_mobjnr++;  
    }  
    ap += (uint_t)kmsp-&gt;so_objsz;  
    tmpfoh = (freobjh_t *)((uint_t)ap);  
}  
list_add(&amp;bextp-&gt;mt_list, &amp;kmsp-&gt;so_mextlst);  
kmsp-&gt;so_mextnr++;  
return TRUE;  
</code></pre>
<p>}</p>
<p>有了前面建立内存对象容器的经验，加上这里的注释，我们理解上述代码并不难：不过是分配了另一块连续的内存空间，作为空闲的内存对象，并且把这块内存空间加内存对象容器中统一管理。</p>
<h3 id="分配内存对象-1">分配内存对象</h3>
<p>有了内存对象容器，就可以分配内存对象了。由于我们前面精心设计了内存对象容器、内存对象等数据结构，这使得我们的内存对象分配代码时极其简单，而且性能极高。</p>
<p>下面我们来实现它吧！代码如下所示。</p>
<p>//判断内存对象容器中有没有内存对象<br>
uint_t scan_kmob_objnr(kmsob_t *kmsp)<br>
{<br>
if (0 &lt; kmsp-&gt;so_fobjnr)<br>
{<br>
return kmsp-&gt;so_fobjnr;<br>
}<br>
return 0;<br>
}<br>
//实际分配内存对象<br>
void *kmsob_new_opkmsob(kmsob_t *kmsp, size_t msz)<br>
{<br>
//获取 kmsob_t 中的 so_frelst 链表头的第一个空闲内存对象<br>
freobjh_t *fobh = list_entry(kmsp-&gt;so_frelst.next, freobjh_t, oh_list);<br>
//从链表中脱链<br>
list_del(&amp;fobh-&gt;oh_list);<br>
//kmsob_t 中的空闲对象计数减一<br>
kmsp-&gt;so_fobjnr&ndash;;<br>
//返回内存对象首地址<br>
return (void *)(fobh);<br>
}</p>
<p>void *kmsob_new_onkmsob(kmsob_t *kmsp, size_t msz)<br>
{<br>
void *retptr = NULL;<br>
cpuflg_t cpuflg;<br>
knl_spinlock_cli(&amp;kmsp-&gt;so_lock, &amp;cpuflg);<br>
//如果内存对象容器中没有空闲的内存对象了就需要扩展内存对象容器的内存了<br>
if (scan_kmsob_objnr(kmsp) &lt; 1)<br>
{//扩展内存对象容器的内存<br>
if (kmsob_extn_pages(kmsp) == FALSE)<br>
{<br>
retptr = NULL;<br>
goto ret_step;<br>
}<br>
}<br>
//实际分配内存对象<br>
retptr = kmsob_new_opkmsob(kmsp, msz);<br>
ret_step:<br>
knl_spinunlock_sti(&amp;kmsp-&gt;so_lock, &amp;cpuflg);<br>
return retptr;<br>
}</p>
<p>分配内存对象的核心操作就是，<strong>kmsob_new_opkmsob 函数从空闲内存对象链表头中取出第一个内存对象，返回它的首地址</strong>。这个算法非常高效，无论内存对象容器中的内存对象有多少，kmsob_new_opkmsob 函数的操作始终是固定的，而如此高效的算法得益于我们先进的数据结构设计。</p>
<p>好了，到这里内存对象的分配就已经完成了，下面我们去实现内存对象的释放。</p>
<h2 id="释放内存对象">释放内存对象</h2>
<p>释放内存对象，就是要把内存对象还给它所归属的内存对象容器。其逻辑就是根据释放内存对象的地址和大小，找到对应的内存对象容器，然后把该内存对象加入到对应内存对象容器的空闲链表上，最后看一看要不要释放内存对象容器占用的物理内存页面。</p>
<h3 id="释放内存对象的接口">释放内存对象的接口</h3>
<p>这里我们依然要从释放内存对象的接口开始实现，下面我们在 kmsob.c 文中写下这个函数，代码如下所示。</p>
<p>bool_t kmsob_delete_core(void *fadrs, size_t fsz)<br>
{<br>
kmsobmgrhed_t *kmobmgrp = &amp;memmgrob.mo_kmsobmgr;<br>
bool_t rets = FALSE;<br>
koblst_t *koblp = NULL;<br>
kmsob_t *kmsp = NULL;<br>
cpuflg_t cpuflg;<br>
knl_spinlock_cli(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);<br>
//根据释放内存对象的大小在 kmsobmgrhed_t 中查找并返回 koblst_t，在其中挂载着对应的 kmsob_t，这个在前面已经写好了<br>
koblp = onmsz_retn_koblst(kmobmgrp, fsz);<br>
if (NULL == koblp)<br>
{<br>
rets = FALSE;<br>
goto ret_step;<br>
}<br>
kmsp = onkoblst_retn_delkmsob(koblp, fadrs, fsz);<br>
if (NULL == kmsp)<br>
{<br>
rets = FALSE;<br>
goto ret_step;<br>
}<br>
rets = kmsob_delete_onkmsob(kmsp, fadrs, fsz);<br>
if (FALSE == rets)<br>
{<br>
rets = FALSE;<br>
goto ret_step;<br>
}<br>
if (_destroy_kmsob(kmobmgrp, koblp, kmsp) == FALSE)<br>
{<br>
rets = FALSE;<br>
goto ret_step;<br>
}<br>
rets = TRUE;<br>
ret_step:<br>
knl_spinunlock_sti(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);<br>
return rets;<br>
}<br>
//释放内存对象接口<br>
bool_t kmsob_delete(void *fadrs, size_t fsz)<br>
{<br>
//对参数进行检查，但是多了对内存对象地址的检查<br>
if (NULL == fadrs || 1 &gt; fsz || 2048 &lt; fsz)<br>
{<br>
return FALSE;<br>
}<br>
//调用释放内存对象的核心函数<br>
return kmsob_delete_core(fadrs, fsz);<br>
}</p>
<p>上述代码中，等到 kmsob_delete 函数检查参数通过之后，就调用释放内存对象的核心函数 kmsob_delete_core，在这个函数中，一开始根据释放内存对象大小，找到挂载其 kmsob_t 结构的 koblst_t 结构，接着又做了一系列的操作，这些操作正是我们接下来要实现的。</p>
<h3 id="查找内存对象容器-1">查找内存对象容器</h3>
<p>释放内存对象，首先要找到这个将要释放的内存对象所属的内存对象容器。释放时的查找和分配时的查找不一样，因为要检查<strong>释放的内存对象是不是属于该内存对象容器。</strong></p>
<p>下面我们一起来实现这个函数，代码如下所示。</p>
<p>//检查释放的内存对象是不是在 kmsob_t 结构中<br>
kmsob_t *scan_delkmsob_isok(kmsob_t *kmsp, void *fadrs, size_t fsz)<br>
{//检查释放内存对象的地址是否落在 kmsob_t 结构的地址区间<br>
if ((adr_t)fadrs &gt;= (kmsp-&gt;so_vstat + sizeof(kmsob_t)) &amp;&amp; ((adr_t)fadrs + (adr_t)fsz) &lt;= kmsp-&gt;so_vend)<br>
{    //检查释放内存对象的大小是否小于等于 kmsob_t 内存对象容器的对象大小<br>
if (fsz &lt;= kmsp-&gt;so_objsz)<br>
{<br>
return kmsp;<br>
}<br>
}<br>
if (1 &gt; kmsp-&gt;so_mextnr)<br>
{//如果 kmsob_t 结构没有扩展空间，直接返回<br>
return NULL;<br>
}<br>
kmbext_t *bexp = NULL;<br>
list_h_t *tmplst = NULL;<br>
//遍历 kmsob_t 结构中的每个扩展空间<br>
list_for_each(tmplst, &amp;kmsp-&gt;so_mextlst)<br>
{<br>
bexp = list_entry(tmplst, kmbext_t, mt_list);<br>
//检查释放内存对象的地址是否落在扩展空间的地址区间<br>
if ((adr_t)fadrs &gt;= (bexp-&gt;mt_vstat + sizeof(kmbext_t)) &amp;&amp; ((adr_t)fadrs + (adr_t)fsz) &lt;= bexp-&gt;mt_vend)<br>
{//同样的要检查大小<br>
if (fsz &lt;= kmsp-&gt;so_objsz)<br>
{<br>
return kmsp;<br>
}<br>
}<br>
}<br>
return NULL;<br>
}<br>
//查找释放内存对象所属的 kmsob_t 结构<br>
kmsob_t *onkoblst_retn_delkmsob(koblst_t *koblp, void *fadrs, size_t fsz)<br>
{<br>
v *kmsp = NULL, *tkmsp = NULL;<br>
list_h_t *tmplst = NULL;<br>
//看看上次刚刚操作的 kmsob_t 结构<br>
kmsp = scan_delkmsob_isok(koblp-&gt;ol_cahe, fadrs, fsz);<br>
if (NULL != kmsp)<br>
{<br>
return kmsp;<br>
}<br>
if (0 &lt; koblp-&gt;ol_emnr)<br>
{    //遍历挂载 koblp-&gt;ol_emplst 链表上的每个 kmsob_t 结构<br>
list_for_each(tmplst, &amp;koblp-&gt;ol_emplst)<br>
{<br>
tkmsp = list_entry(tmplst, kmsob_t, so_list);<br>
//检查释放的内存对象是不是属于这个 kmsob_t 结构<br>
kmsp = scan_delkmsob_isok(tkmsp, fadrs, fsz);<br>
if (NULL != kmsp)<br>
{<br>
return kmsp;<br>
}<br>
}<br>
}<br>
return NULL;<br>
}</p>
<p>上面的代码注释已经很明白了，搜索对应 koblst_t 结构中的每个 kmsob_t 结构体，随后进行检查，检查了 kmsob_t 结构的自身内存区域和扩展内存区域。即比较释放内存对象的地址是不是落在它们的内存区间中，其大小是否合乎要求。</p>
<h3 id="释放内存对象-1">释放内存对象</h3>
<p>如果不出意外，会找到释放内存对象的 kmsob_t 结构，这样就可以释放内存对象了，就是把这块内存空间还给内存对象容器，这个过程的具体代码实现如下所示。</p>
<p>bool_t kmsob_del_opkmsob(kmsob_t *kmsp, void *fadrs, size_t fsz)<br>
{<br>
if ((kmsp-&gt;so_fobjnr + 1) &gt; kmsp-&gt;so_mobjnr)<br>
{<br>
return FALSE;<br>
}<br>
//让 freobjh_t 结构重新指向要释放的内存空间<br>
freobjh_t *obhp = (freobjh_t *)fadrs;<br>
//重新初始化块内存空间<br>
freobjh_t_init(obhp, 0, obhp);<br>
//加入 kmsob_t 结构的空闲链表<br>
list_add(&amp;obhp-&gt;oh_list, &amp;kmsp-&gt;so_frelst);<br>
//kmsob_t 结构的空闲对象计数加一<br>
kmsp-&gt;so_fobjnr++;<br>
return TRUE;<br>
}<br>
//释放内存对象<br>
bool_t kmsob_delete_onkmsob(kmsob_t *kmsp, void *fadrs, size_t fsz)<br>
{<br>
bool_t rets = FALSE;<br>
cpuflg_t cpuflg;<br>
//对 kmsob_t 结构加锁<br>
knl_spinlock_cli(&amp;kmsp-&gt;so_lock, &amp;cpuflg);<br>
//实际完成内存对象释放<br>
if (kmsob_del_opkmsob(kmsp, fadrs, fsz) == FALSE)<br>
{<br>
rets = FALSE;<br>
goto ret_step;<br>
}<br>
rets = TRUE;<br>
ret_step:<br>
//对 kmsob_t 结构解锁<br>
knl_spinunlock_sti(&amp;kmsp-&gt;so_lock, &amp;cpuflg);<br>
return rets;<br>
}</p>
<p>结合上述代码和注释，我们现在明白了 kmsob_delete_onkmsob 函数调用 kmsob_del_opkmsob 函数。其核心机制就是<strong>把要释放内存对象的空间，重新初始化，变成一个 freobjh_t 结构的实例变量，最后把这个 freobjh_t 结构加入到 kmsob_t 结构中空闲链表中</strong>，这就实现了内存对象的释放。</p>
<h3 id="销毁内存对象容器">销毁内存对象容器</h3>
<p>如果我们释放了所有的内存对象，就会出现空的内存对象容器。如果下一次请求同样大小的内存对象，那么这个空的内存对象容器还能继续复用，提高性能。</p>
<p>但是你有没有想到，频繁请求的是不同大小的内存对象，那么空的内存对象容器会越来越多，这会占用大量内存，所以我们必须要把空的内存对象容器销毁。</p>
<p>下面我们写代码实现销毁内存对象容器。</p>
<p>uint_t scan_freekmsob_isok(kmsob_t *kmsp)<br>
{<br>
//当内存对象容器的总对象个数等于空闲对象个数时，说明这内存对象容器空闲<br>
if (kmsp-&gt;so_mobjnr == kmsp-&gt;so_fobjnr)<br>
{<br>
return 2;<br>
}<br>
return 1;<br>
}</p>
<p>bool_t _destroy_kmsob_core(kmsobmgrhed_t *kmobmgrp, koblst_t *koblp, kmsob_t *kmsp)<br>
{<br>
list_h_t *tmplst = NULL;<br>
msadsc_t *msa = NULL;<br>
msclst_t *mscp = kmsp-&gt;so_mc.mc_lst;<br>
list_del(&amp;kmsp-&gt;so_list);<br>
koblp-&gt;ol_emnr&ndash;;<br>
kmobmgrp-&gt;ks_msobnr&ndash;;<br>
//释放内存对象容器扩展空间的物理内存页面<br>
//遍历 kmsob_t 结构中的 so_mc.mc_lst 数组<br>
for (uint_t j = 0; j &lt; MSCLST_MAX; j++)<br>
{<br>
if (0 &lt; mscp[j].ml_msanr)<br>
{//遍历每个 so_mc.mc_lst 数组中的 msadsc_t 结构<br>
list_for_each_head_dell(tmplst, &amp;mscp[j].ml_list)<br>
{<br>
msa = list_entry(tmplst, msadsc_t, md_list);<br>
list_del(&amp;msa-&gt;md_list);<br>
//msadsc_t 脱链<br>
//释放 msadsc_t 对应的物理内存页面<br>
if (mm_merge_pages(&amp;memmgrob, msa, (uint_t)mscp[j].ml_ompnr) == FALSE)<br>
{<br>
system_error(&quot;_destroy_kmsob_core mm_merge_pages FALSE2\n&quot;);<br>
}<br>
}<br>
}<br>
}<br>
//释放内存对象容器本身占用的物理内存页面<br>
//遍历每个 so_mc.mc_kmobinlst 中的 msadsc_t 结构。它只会遍历一次<br>
list_for_each_head_dell(tmplst, &amp;kmsp-&gt;so_mc.mc_kmobinlst)<br>
{<br>
msa = list_entry(tmplst, msadsc_t, md_list);<br>
list_del(&amp;msa-&gt;md_list);<br>
//msadsc_t 脱链<br>
//释放 msadsc_t 对应的物理内存页面<br>
if (mm_merge_pages(&amp;memmgrob, msa, (uint_t)kmsp-&gt;so_mc.mc_kmobinpnr) == FALSE)<br>
{<br>
system_error(&quot;_destroy_kmsob_core mm_merge_pages FALSE2\n&quot;);<br>
}<br>
}<br>
return TRUE;<br>
}<br>
//</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">bool_t _destroy_kmsob(kmsobmgrhed_t *kmobmgrp, koblst_t *koblp, kmsob_t *kmsp)  
</span></span><span class="line"><span class="cl">{  
</span></span><span class="line"><span class="cl">    //看看能不能销毁  
</span></span><span class="line"><span class="cl">    uint_t screts = scan_freekmsob_isok(kmsp);  
</span></span><span class="line"><span class="cl">    if (2 == screts)  
</span></span><span class="line"><span class="cl">    {//调用销毁内存对象容器的核心函数  
</span></span><span class="line"><span class="cl">        return _destroy_kmsob_core(kmobmgrp, koblp, kmsp);  
</span></span><span class="line"><span class="cl">    }  
</span></span><span class="line"><span class="cl">    return FALSE;  
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">上述代码中，首先会检查一下内存对象容器是不是空闲的，如果空闲，就调用**销毁内存对象容器的核心函数 \_destroy\_kmsob\_core**。在 \_destroy\_kmsob\_core 函数中，首先要释放内存对象容器的扩展空间所占用的物理内存页面，最后才可以释放内存对象容器自身占用物理内存页面。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">请注意。**这个顺序不能前后颠倒**，这是因为扩展空间的物理内存页面对应的 msadsc\_t 结构，它就挂载在 kmsob\_t 结构的 so\_mc.mc\_lst 数组中。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">好了，到这里我们内存对象释放的流程就完成了，这意味着我们整个内存对象管理也告一段落了。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">## 重点回顾
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">今天我们从 malloc 函数入手，思考内核要怎样分配大量小块内存。我们把物理内存页面进一步细分成内存对象，为了表示和管理内存对象，又设计了内存对象、内存对象容器等一系列数据结构，随后写代码把它们初始化，最后我们依赖这些数据结构实现了内存对象管理算法。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">下面我们来回顾一下这节课的重点。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">1\. 我们发现，在应用程序中可以使用 malloc 函数动态分配一些小块内存，其实这样的场景在内核中也是比比皆是。比如，内核经常要动态创建数据结构的实例变量，就需要分配小块的内存空间。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2\. 为了实现内存对象的表示、分配和释放功能，我们定义了内存对象和内存对象容器的数据结构 freobjh\_t、kmsob\_t，并为了管理 kmsob\_t 结构又定义了 kmsobmgrhed\_t 结构。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">3\. 我们写好了初始化 kmsobmgrhed\_t 结构的函数，并在 init\_kmsob 中调用了它，进而又被 init\_memmgr 函数调用，由于 kmsobmgrhed\_t 结构是为了管理 kmsob\_t 结构的所以在一开始就要被初始化。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">4\. 我们基于这些数据结构实现了内存对象的分配和释放。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">## 思考题
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">为什么我们在分配内存对象大小时要按照 Cache 行大小的倍数分配呢？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">欢迎你在留言区分享你的思考或疑问。如果这节课对你有帮助，也欢迎你分享给自己的同事、朋友，跟他一起交流讨论。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">好，我是 LMOS，我们下节课见！
</span></span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/">操作系统实战45讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/10x%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B3%95/19_%E5%A6%82%E4%BD%95%E7%94%A8%E6%9C%80%E5%B0%8F%E7%9A%84%E4%BB%A3%E4%BB%B7%E5%81%9A%E4%BA%A7%E5%93%81/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">19_如何用最小的代价做产品？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/19_%E9%9A%9C%E7%A2%8D%E4%BB%8E%E8%AE%A1%E5%88%92%E5%88%B0%E5%9D%9A%E6%8C%81%E5%86%8D%E5%88%B0%E5%9D%9A%E6%8C%81%E4%B8%8D%E4%B8%8B%E5%8E%BB%E7%9A%84%E6%97%B6%E5%80%99/">
            <span class="next-text nav-default">19_障碍：从计划到坚持，再到坚持不下去的时候</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
