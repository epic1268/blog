<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>40_瞧一瞧Linux：详解socket的接口实现 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是 LMOS。
上节课，我们一起了解了套接字的工作机制和数据结构，但套接字有哪些基本接口实现呢？相信学完这节课，你就能够解决这个问题了。
今天我会和你探讨套接字从创建、协议接口注册与初始化过程，还会为你深入分析套接字系统，是怎样调用各个功能函数的。通过这节课，相信你可以学会基于套接字来编写网络应用程序。有了之前的基础，想理解这节课并不难，让我们正式开始吧。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/40_%E7%9E%A7%E4%B8%80%E7%9E%A7linux%E8%AF%A6%E8%A7%A3socket%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/40_%E7%9E%A7%E4%B8%80%E7%9E%A7linux%E8%AF%A6%E8%A7%A3socket%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="40_瞧一瞧Linux：详解socket的接口实现">
  <meta property="og:description" content="你好，我是 LMOS。
上节课，我们一起了解了套接字的工作机制和数据结构，但套接字有哪些基本接口实现呢？相信学完这节课，你就能够解决这个问题了。
今天我会和你探讨套接字从创建、协议接口注册与初始化过程，还会为你深入分析套接字系统，是怎样调用各个功能函数的。通过这节课，相信你可以学会基于套接字来编写网络应用程序。有了之前的基础，想理解这节课并不难，让我们正式开始吧。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="操作系统实战45讲">

  <meta itemprop="name" content="40_瞧一瞧Linux：详解socket的接口实现">
  <meta itemprop="description" content="你好，我是 LMOS。
上节课，我们一起了解了套接字的工作机制和数据结构，但套接字有哪些基本接口实现呢？相信学完这节课，你就能够解决这个问题了。
今天我会和你探讨套接字从创建、协议接口注册与初始化过程，还会为你深入分析套接字系统，是怎样调用各个功能函数的。通过这节课，相信你可以学会基于套接字来编写网络应用程序。有了之前的基础，想理解这节课并不难，让我们正式开始吧。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4549">
  <meta itemprop="keywords" content="操作系统实战45讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="40_瞧一瞧Linux：详解socket的接口实现">
  <meta name="twitter:description" content="你好，我是 LMOS。
上节课，我们一起了解了套接字的工作机制和数据结构，但套接字有哪些基本接口实现呢？相信学完这节课，你就能够解决这个问题了。
今天我会和你探讨套接字从创建、协议接口注册与初始化过程，还会为你深入分析套接字系统，是怎样调用各个功能函数的。通过这节课，相信你可以学会基于套接字来编写网络应用程序。有了之前的基础，想理解这节课并不难，让我们正式开始吧。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">40_瞧一瞧Linux：详解socket的接口实现</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4549 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#套接字接口">套接字接口</a>
          <ul>
            <li><a href="#套接字的创建">套接字的创建</a></li>
            <li><a href="#套接字的绑定">套接字的绑定</a></li>
            <li><a href="#主动连接">主动连接</a></li>
            <li><a href="#监听套接字">监听套接字</a></li>
            <li><a href="#被动接收连接">被动接收连接</a></li>
            <li><a href="#发送数据">发送数据</a></li>
            <li><a href="#接收数据">接收数据</a></li>
            <li><a href="#关闭连接">关闭连接</a></li>
          </ul>
        </li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是 LMOS。</p>
<p>上节课，我们一起了解了套接字的工作机制和数据结构，但套接字有哪些基本接口实现呢？相信学完这节课，你就能够解决这个问题了。</p>
<p>今天我会和你探讨套接字从创建、协议接口注册与初始化过程，还会为你深入分析套接字系统，是怎样调用各个功能函数的。通过这节课，相信你可以学会基于套接字来编写网络应用程序。有了之前的基础，想理解这节课并不难，让我们正式开始吧。</p>
<h2 id="套接字接口">套接字接口</h2>
<p>套接字接口最初是 BSD 操作系统的一部分，在应用层与 TCP/IP 协议栈之间接供了一套标准的独立于协议的接口。</p>
<p>Linux 内核实现的套接字接口，将 UNIX 的“一切都是文件操作”的概念应用在了网络连接访问上，让应用程序可以用常规文件操作 API 访问网络连接。</p>
<p>从 TCP/IP 协议栈的角度来看，传输层以上的都是应用程序的一部分，Linux 与传统的 UNIX 类似，TCP/IP 协议栈驻留在内核中，与内核的其他组件共享内存。传输层以上执行的网络功能，都是在用户地址空间完成的。</p>
<p>Linux 使用内核套接字概念与用户空间套接字通信，这样可以让实现和操作变得更简单。Linux 提供了一套 API 和套接字数据结构，这些服务向下与内核接口，向上与用户空间接口，应用程序正是使用这一套 API 访问内核中的网络功能。</p>
<h3 id="套接字的创建">套接字的创建</h3>
<p>在应用程序使用 TCP/IP 协议栈的功能之前，我们必须调用套接字库函数 API 创建一个新的套接字，创建好以后，对库函数创建套接字的调用，就会转换为内核套接字创建函数的系统调用。</p>
<p>这时，完成的是通用套接字创建的初始化功能，跟具体的协议族并不相关。</p>
<p>这个过程具体是这样的，在应用程序中执行 socket 函数，socket 产生系统调用中断执行内核的套接字分路函数 sys_socketcall，在 sys_socketcall 套接字函数分路器中将调用传送到 sys_socket 函数，由 sys_socket 函数调用套接字的通用创建函数 sock_create。</p>
<p>sock_create 函数完成通用套接字创建、初始化任务后，再调用特定协议族的套接字创建函数。</p>
<p>这样描述你可能还没有直观感受，我特意画了图，帮你梳理 socket 创建的流程，你可以对照图片仔细体会调用过程。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/ce3de01010d6223678f59d1026f4b005.png" alt=""></p>
<p>socket 创建示意图</p>
<p>结合图解，我再用一个具体例子帮你加深理解，比如由 AF_INET 协议族的 inet_create 函数完成套接字与特定协议族的关联。</p>
<p>一个新的 struct socket 数据结构起始由 sock_create 函数创建，<strong>该函数直接调用 __sock_create 函数，__sock_create 函数的任务是为套接字预留需要的内存空间，由 sock_alloc 函数完成这项功能。</strong></p>
<p>这个 sock_alloc 函数不仅会为 struct socket 数据结构实例预留空间，也会为 struct inode 数据结构实例分配需要的内存空间，这样可以使两个数据结构的实例相关联。__sock_create 函数代码如下。</p>
<p>static int __sock_create(struct net *net, int family, int type, int protocol,<br>
struct socket **res, int kern)<br>
{<br>
int err;<br>
struct socket *sock;<br>
const struct net_proto_family <em>pf;<br>
// 首先检验是否支持协议族<br>
/</em></p>
<ul>
<li>检查是否在内核支持的 socket 范围内<br>
<em>/<br>
if (family &lt; 0 || family &gt;= NPROTO)<br>
return -EAFNOSUPPORT;<br>
if (type &lt; 0 || type &gt;= SOCK_MAX)<br>
return -EINVAL;<br>
/</em></li>
<li>为新的套接字分配内存空间，分配成功后返回新的指针<br>
*/</li>
</ul>
<p>sock = sock_alloc();<br>
}</p>
<p>sock_alloc 函数如下所示。</p>
<p>static struct socket *sock_alloc(void) {<br>
struct inode *inode;<br>
struct socket *sock;<br>
// 初始化一个可用的 inode 节点，在 fs/inode.c 中<br>
inode = new_inode(sock_mnt-&gt;mnt_sb);<br>
if (!inode)<br>
return NULL;<br>
// 实际创建的是 socket_alloc 复合对象，因此要使用 SOCKET_I 宏从 inode 中取出关联的 socket 对象用于返回<br>
sock = SOCKET_I(inode);</p>
<pre><code>kmemcheck_annotate_bitfield(sock, type);  
// 文件类型为套接字  
inode-&gt;i_mode = S_IFSOCK | S_IRWXUGO;  
inode-&gt;i_uid = current_fsuid();  
inode-&gt;i_gid = current_fsgid();  

percpu_add(sockets_in_use, 1);  
</code></pre>
<p>return sock;<br>
}</p>
<p>当具体的协议与新套接字相连时，其内部状态的管理由协议自身维护。</p>
<p>现在，函数将 struct socket 数据结构的 struct proto_ops *ops 设置为 NULL。随后，当某个协议族中的协议成员的套接字创建函数被调用时，ops 将指向协议实例的操作函数。这时将 struct socket 数据结构的 flags 数据域设置为 0，创建时还没有任何标志需要设置。</p>
<p>在之后的调用中，应用程序调用 send 或 receive 套接字库函数时会设置 flags 数据域。最后将其他两个数据域 sk 和 file 初始化为 NULL。sk 数据域随后会把由协议特有的套接字创建函数设置为指向内部套接字结构。file 将在调用 sock_ma_fd 函数时设置为分配的文件返回的指针。</p>
<p>文件指针用于访问打开套接字的虚拟文件系统的文件状态。在 sock_alloc 函数返回后，sock_create 函数调用协议族的套接字创建函数 err =pf-&gt;create(net, sock, protocol)，它通过访问 net_families 数组获取协议族的创建函数，对于 TCP/IP 协议栈，协议族将设置为 AF_INET。</p>
<h3 id="套接字的绑定">套接字的绑定</h3>
<p>创建完套接字后，应用程序需要调用 sys_bind 函数把套接字和地址绑定起来，代码如下所示。</p>
<p>asmlinkage long sysbind (bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)<br>
{<br>
struct socket *sock;<br>
struct sockaddr_storage address;<br>
int err, fput_needed;</p>
<p>/*</p>
<ul>
<li>获取 socket 实例。<br>
*/<br>
sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);<br>
if (sock) {<br>
err = move_addr_to_kernel(umyaddr, addrlen, (struct sockaddr *)&amp;address);<br>
if (err &gt;= 0) {<br>
err = security_socket_bind(sock,<br>
(struct sockaddr <em>)&amp;address,<br>
addrlen);<br>
/</em>
<ul>
<li>如果是 TCP 套接字，sock-&gt;ops 指向的是 inet_stream_ops，</li>
<li>sock-&gt;ops 是在 inet_create() 函数中初始化，所以 bind 接口</li>
<li>调用的是 inet_bind() 函数。<br>
*/<br>
if (!err)<br>
err = sock-&gt;ops-&gt;bind(sock,<br>
(struct sockaddr *)<br>
&amp;address, addrlen);<br>
}<br>
fput_light(sock-&gt;file, fput_needed);<br>
}<br>
return err;<br>
}</li>
</ul>
</li>
</ul>
<p>结合代码，我们可以看到，sys_bind 函数首先会查找套接字对应的 socket 实例，调用 <strong>sockfd_lookup_light</strong>。在绑定之前，将用户空间的地址拷贝到内核空间的缓冲区中，在拷贝过程中会检查用户传入的地址是否正确。</p>
<p>等上述的准备工作完成后，就会调用 <strong>inet_bind 函数</strong>来完成绑定操作。<strong>inet_bind</strong> 函数代码如下所示。</p>
<p>int inet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)<br>
{<br>
struct sockaddr_in *addr = (struct sockaddr_in *)uaddr;<br>
struct sock *sk = sock-&gt;sk; <br>
struct inet_sock *inet = inet_sk(sk);<br>
unsigned short snum;<br>
int chk_addr_ret;<br>
int err;</p>
<pre><code>if (sk-&gt;sk_prot-&gt;bind) {/* 如果传输层接口上实现了 bind 调用，则回调它。目前只有 SOCK_RAW 类型的传输层实现了该接口 raw_bind */  
    err = sk-&gt;sk_prot-&gt;bind(sk, uaddr, addr_len);  
    goto out;  
}  
err = -EINVAL;  
if (addr_len &lt; sizeof(struct sockaddr_in))  
    goto out;  
err = -EADDRNOTAVAIL;  
if (!sysctl_ip_nonlocal_bind &amp;&amp;/* 必须绑定到本地接口的地址 */  
    !inet-&gt;freebind &amp;&amp;  
    addr-&gt;sin_addr.s_addr != INADDR_ANY &amp;&amp;/* 绑定地址不合法 */  
    chk_addr_ret != RTN_LOCAL &amp;&amp;  
    chk_addr_ret != RTN_MULTICAST &amp;&amp;  
    chk_addr_ret != RTN_BROADCAST)  
    goto out;  

snum = ntohs(addr-&gt;sin_port);  
err = -EACCES;  
if (snum &amp;&amp; snum &lt; PROT_SOCK &amp;&amp; !capable(CAP_NET_BIND_SERVICE))  
    goto out;  

lock_sock(sk);/* 对套接口进行加锁，因为后面要对其状态进行判断 */  

/* Check these errors (active socket, double bind). */  
err = -EINVAL;  
/**  
 * 如果状态不为 CLOSE，表示套接口已经处于活动状态，不能再绑定  
 * 或者已经指定了本地端口号，也不能再绑定  
 */  
if (sk-&gt;sk_state != TCP_CLOSE || inet-&gt;num)  
    goto out_release_sock;  

/* 设置地址到传输控制块中 */  
inet-&gt;rcv_saddr = inet-&gt;saddr = addr-&gt;sin_addr.s_addr;  
/* 如果是广播或者多播地址，则源地址使用设备地址。 */  
if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)  
    inet-&gt;saddr = 0;  /* Use device */  

/* 调用传输层的 get_port 来进行地址绑定。如 tcp_v4_get_port 或 udp_v4_get_port */  
if (sk-&gt;sk_prot-&gt;get_port(sk, snum)) {  
    …  
}  

/* 设置标志，表示已经绑定了本地地址和端口 */  
if (inet-&gt;rcv_saddr)  
    sk-&gt;sk_userlocks |= SOCK_BINDADDR_LOCK;  
if (snum)  
    sk-&gt;sk_userlocks |= SOCK_BINDPORT_LOCK;  
inet-&gt;sport = htons(inet-&gt;num);  
/* 还没有连接到对方，清除远端地址和端口 */  
inet-&gt;daddr = 0;  
inet-&gt;dport = 0;  
/* 清除路由缓存 */  
sk_dst_reset(sk);  
err = 0;  
</code></pre>
<p>out_release_sock:<br>
release_sock(sk);<br>
out:<br>
return err;<br>
}</p>
<h3 id="主动连接">主动连接</h3>
<p>因为应用程序处理的是面向连接的网络服务（SOCK_STREAM 或 SOCK_SEQPACKET），所以在交换数据之前，需要在请求连接服务的进程（客户）与提供服务的进程（服务器）之间建立连接。</p>
<p>当应用程序调用 <strong>connect</strong> 函数发出连接请求时，内核会启动函数 <strong>sys_connect</strong>，详细代码如下。</p>
<p>int __sys_connect(int fd, struct sockaddr __user *uservaddr, int addrlen)<br>
{<br>
int ret = -EBADF;<br>
struct fd f;<br>
f = fdget(fd);<br>
if (f.file) {<br>
struct sockaddr_storage address;<br>
ret = move_addr_to_kernel(uservaddr, addrlen, &amp;address);<br>
if (!ret)<br>
// 调用__sys_connect_file<br>
ret = __sys_connect_file(f.file, &amp;address, addrlen, 0);<br>
fdput(f);<br>
}<br>
return ret;<br>
}</p>
<p>连接成功会返回 socket 的描述符，否则会返回一个错误码。</p>
<h3 id="监听套接字">监听套接字</h3>
<p>调用 listen 函数时，应用程序触发内核的 <strong>sys_listen</strong> 函数，把套接字描述符 fd 对应的套接字设置为监听模式，观察连接请求。详细代码你可以看看后面的内容。</p>
<p>int __sys_listen(int fd, int backlog)<br>
{<br>
struct socket *sock;<br>
int err, fput_needed;<br>
int somaxconn;<br>
// 通过套接字描述符找到 struct socket<br>
sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);<br>
if (sock) {<br>
somaxconn = sock_net(sock-&gt;sk)-&gt;core.sysctl_somaxconn;<br>
if ((unsigned int)backlog &gt; somaxconn)<br>
backlog = somaxconn;<br>
err = security_socket_listen(sock, backlog);<br>
if (!err)<br>
// 根据套接字类型调用监听函数<br>
err = sock-&gt;ops-&gt;listen(sock, backlog);<br>
fput_light(sock-&gt;file, fput_needed);<br>
}<br>
return err;<br>
}</p>
<h3 id="被动接收连接">被动接收连接</h3>
<p>前面说过主动连接，我们再来看看被动接受连接的情况。接受一个客户端的连接请求会调用 accept 函数，应用程序触发内核函数 sys_accept，等待接收连接请求。如果允许连接，则重新创建一个代表该连接的套接字，并返回其套接字描述符，代码如下。</p>
<p>int __sys_accept4_file(struct file *file, unsigned file_flags,<br>
struct sockaddr __user *upeer_sockaddr,<br>
int __user *upeer_addrlen, int flags,<br>
unsigned long nofile)<br>
{<br>
struct socket *sock, *newsock;<br>
struct file *newfile;<br>
int err, len, newfd;<br>
struct sockaddr_storage address;<br>
if (flags &amp; ~(SOCK_CLOEXEC | SOCK_NONBLOCK))<br>
return -EINVAL;<br>
if (SOCK_NONBLOCK != O_NONBLOCK &amp;&amp; (flags &amp; SOCK_NONBLOCK))<br>
flags = (flags &amp; ~SOCK_NONBLOCK) | O_NONBLOCK;<br>
sock = sock_from_file(file, &amp;err);<br>
if (!sock)<br>
goto out;<br>
err = -ENFILE;<br>
// 创建一个新套接字<br>
newsock = sock_alloc();<br>
if (!newsock)<br>
goto out;<br>
newsock-&gt;type = sock-&gt;type;<br>
newsock-&gt;ops = sock-&gt;ops;<br>
__module_get(newsock-&gt;ops-&gt;owner);<br>
newfd = __get_unused_fd_flags(flags, nofile);<br>
if (unlikely(newfd &lt; 0)) {<br>
err = newfd;<br>
sock_release(newsock);<br>
goto out;<br>
}<br>
newfile = sock_alloc_file(newsock, flags, sock-&gt;sk-&gt;sk_prot_creator-&gt;name);<br>
if (IS_ERR(newfile)) {<br>
err = PTR_ERR(newfile);<br>
put_unused_fd(newfd);<br>
goto out;<br>
}<br>
err = security_socket_accept(sock, newsock);<br>
if (err)<br>
goto out_fd;<br>
// 根据套接字类型调用不同的函数 inet_accept<br>
err = sock-&gt;ops-&gt;accept(sock, newsock, sock-&gt;file-&gt;f_flags | file_flags,<br>
false);<br>
if (err &lt; 0)<br>
goto out_fd;<br>
if (upeer_sockaddr) {<br>
len = newsock-&gt;ops-&gt;getname(newsock,<br>
(struct sockaddr <em>)&amp;address, 2);<br>
if (len &lt; 0) {<br>
err = -ECONNABORTED;<br>
goto out_fd;<br>
}<br>
// 从内核复制到用户空间<br>
err = move_addr_to_user(&amp;address,<br>
len, upeer_sockaddr, upeer_addrlen);<br>
if (err &lt; 0)<br>
goto out_fd;<br>
}<br>
/</em> File flags are not inherited via accept() unlike another OSes. */<br>
fd_install(newfd, newfile);<br>
err = newfd;<br>
out:<br>
return err;<br>
out_fd:<br>
fput(newfile);<br>
put_unused_fd(newfd);<br>
goto out;<br>
}</p>
<p>这个新的套接字描述符与最初创建套接字时，设置的套接字地址族与套接字类型、使用的协议一样。原来创建的套接字不与连接关联，它继续在原套接字上侦听，以便接收其他连接请求。</p>
<h3 id="发送数据">发送数据</h3>
<p>套接字应用中最简单的传送函数是 <strong>send</strong>，send 函数的作用类似于 write，但 send 函数允许应用程序指定标志，规定如何对待传送数据。调用 send 函数时，会触发内核的 <strong>sys_send</strong> 函数，把发送缓冲区的数据发送出去。</p>
<p><strong>sys_send</strong> 函数具体调用流程如下。</p>
<p>1. 应用程序的数据被复制到内核后，sys_send 函数调用 <strong>sock_sendmsg</strong>，依据协议族类型来执行发送操作。</p>
<p>2. 如果是 INET 协议族套接字，sock_sendmsg 将调用 inet_sendmsg 函数。</p>
<p>3. 如果采用 TCP 协议，inet_sendmsg 函数将调用 tcp_sendmsg，并按照 TCP 协议规则来发送数据包。</p>
<p>send 函数返回发送成功，并不意味着在连接的另一端的进程可以收到数据，这里只能保证发送 send 函数执行成功，发送给网络设备驱动程序的数据没有出错。</p>
<h3 id="接收数据">接收数据</h3>
<p><strong>recv</strong> 函数与文件读 read 函数类似，recv 函数中可以指定标志来控制如何接收数据，调用 recv 函数时，应用程序会触发内核的 sys_recv 函数，把网络中的数据递交到应用程序。当然，read、recvfrom 函数也会触发 sys_recv 函数。具体流程如下。</p>
<p>1. 为把内核的网络数据转入应用程序的接收缓冲区，sys_recv 函数依次调用 <strong>sys_recvfrom、sock_recvfrom 和 __sock_recvmsg</strong>，并依据协议族类型来执行具体的接收操作。</p>
<p>2. 如果是 INET 协议族套接字，__sock_recvmsg 将调用 sock_common_recvmsg 函数。</p>
<p>3. 如果采用 TCP 协议，sock_common_recvmsg 函数将调用 tcp_recvmsg，按照 TCP 协议规则来接收数据包</p>
<p>如果接收方想获取数据包发送端的标识符，应用程序可以调用 <strong>sys_recvfrom</strong> 函数来获取数据包发送方的源地址，下面是 <strong>sys_recvfrom</strong> 函数的实现。</p>
<p>int __sys_recvfrom(int fd, void __user *ubuf, size_t size, unsigned int flags,<br>
struct sockaddr __user *addr, int __user *addr_len)<br>
{<br>
struct socket <em>sock;<br>
struct iovec iov;<br>
struct msghdr msg;<br>
struct sockaddr_storage address;<br>
int err, err2;<br>
int fput_needed;<br>
err = import_single_range(READ, ubuf, size, &amp;iov, &amp;msg.msg_iter);<br>
if (unlikely(err))<br>
return err;<br>
// 通过套接字描述符找到 struct socket<br>
sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);<br>
if (!sock)<br>
goto out;<br>
msg.msg_control = NULL;<br>
msg.msg_controllen = 0;<br>
/</em> Save some cycles and don&rsquo;t copy the address if not needed */<br>
msg.msg_name = addr ? (struct sockaddr <em>)&amp;address : NULL;<br>
/</em> We assume all kernel code knows the size of sockaddr_storage */<br>
msg.msg_namelen = 0;<br>
msg.msg_iocb = NULL;<br>
msg.msg_flags = 0;<br>
if (sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK)<br>
flags |= MSG_DONTWAIT;<br>
// sock_recvmsg 为具体的接收函数<br>
err = sock_recvmsg(sock, &amp;msg, flags);<br>
if (err &gt;= 0 &amp;&amp; addr != NULL) {<br>
// 从内核复制到用户空间<br>
err2 = move_addr_to_user(&amp;address,<br>
msg.msg_namelen, addr, addr_len);<br>
if (err2 &lt; 0)<br>
err = err2;<br>
}<br>
fput_light(sock-&gt;file, fput_needed);<br>
out:<br>
return err;<br>
}</p>
<h3 id="关闭连接">关闭连接</h3>
<p>最后，我们来看看如何关闭连接。当应用程序调用 shutdown 函数关闭连接时，内核会启动函数 sys_shutdown，代码如下。</p>
<p>int __sys_shutdown(int fd, int how)<br>
{<br>
int err, fput_needed;<br>
struct socket <em>sock;<br>
sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);/</em> 通过套接字，描述符找到对应的结构*/<br>
if (sock != NULL) {<br>
err = security_socket_shutdown(sock, how);<br>
if (!err)<br>
/* 根据套接字协议族调用关闭函数*/<br>
err = sock-&gt;ops-&gt;shutdown(sock, how);<br>
fput_light(sock-&gt;file, fput_needed);<br>
}<br>
return err;<br>
}</p>
<h2 id="重点回顾">重点回顾</h2>
<p>好，这节课的内容告一段落了，我来给你做个总结。这节课我们继续研究了套接字在 Linux 内核中的实现。</p>
<p>套接字是 UNIX 兼容系统的一大特色，Linux 在此基础上实现了内核套接字与应用程序套接字接口，在用户地址空间与内核地址空间之间提供了一套标准接口，实现应用套接字库函数与内核功能之间的一一对应，简化了用户地址空间与内核地址空间交换数据的过程。</p>
<p>通过应用套接字 API 编写网络应用程序，我们可以利用 Linux 内核 TCP/IP 协议栈提供的网络通信服务，在网络上实现应用数据快速、有效的传送。除此之外，套接字编程还可以使我们获取网络、主机的各种管理、统计信息。</p>
<p>创建套接字应用程序一般要经过后面这 6 个步骤。</p>
<p>1. 创建套接字。</p>
<p>2. 将套接字与地址绑定，设置套接字选项。</p>
<p>3. 建立套接字之间的连接。</p>
<p>4. 监听套接字</p>
<p>5. 接收、发送数据。</p>
<p>6. 关闭、释放套接字。</p>
<h2 id="思考题">思考题</h2>
<p>我们了解的 TCP 三次握手，发生在 socket 的哪几个函数中呢？</p>
<p>欢迎你在留言区跟我交流，也推荐你把这节课转发给有需要的朋友。</p>
<p>我是 LMOS，我们下节课见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/">操作系统实战45讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B42%E8%AE%B2/40_%E4%B9%B0%E5%8D%96%E6%88%BF%E5%B1%8B%E7%BB%BC%E5%90%88%E6%B3%95%E5%AE%9D/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">40_买卖房屋综合法宝</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/40_%E5%AE%9E%E6%88%98%E5%9B%9B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B03d%E5%9C%B0%E7%90%83%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%8A/">
            <span class="next-text nav-default">40_实战（四）：如何实现3D地球可视化（上）？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
