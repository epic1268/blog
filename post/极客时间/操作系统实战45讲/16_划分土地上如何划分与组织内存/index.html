<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>16_划分土地（上）：如何划分与组织内存？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是 LMOS。
内存跟操作系统的关系，就像土地和政府的关系一样。政府必须合理规划这个国家的土地，才能让人民安居乐业。为了发展，政府还要进而建立工厂、学校，发展工业和教育，规划城镇，国家才能繁荣富强。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/16_%E5%88%92%E5%88%86%E5%9C%9F%E5%9C%B0%E4%B8%8A%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E4%B8%8E%E7%BB%84%E7%BB%87%E5%86%85%E5%AD%98/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/16_%E5%88%92%E5%88%86%E5%9C%9F%E5%9C%B0%E4%B8%8A%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E4%B8%8E%E7%BB%84%E7%BB%87%E5%86%85%E5%AD%98/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="16_划分土地（上）：如何划分与组织内存？">
  <meta property="og:description" content="你好，我是 LMOS。
内存跟操作系统的关系，就像土地和政府的关系一样。政府必须合理规划这个国家的土地，才能让人民安居乐业。为了发展，政府还要进而建立工厂、学校，发展工业和教育，规划城镇，国家才能繁荣富强。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="操作系统实战45讲">

  <meta itemprop="name" content="16_划分土地（上）：如何划分与组织内存？">
  <meta itemprop="description" content="你好，我是 LMOS。
内存跟操作系统的关系，就像土地和政府的关系一样。政府必须合理规划这个国家的土地，才能让人民安居乐业。为了发展，政府还要进而建立工厂、学校，发展工业和教育，规划城镇，国家才能繁荣富强。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5243">
  <meta itemprop="keywords" content="操作系统实战45讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="16_划分土地（上）：如何划分与组织内存？">
  <meta name="twitter:description" content="你好，我是 LMOS。
内存跟操作系统的关系，就像土地和政府的关系一样。政府必须合理规划这个国家的土地，才能让人民安居乐业。为了发展，政府还要进而建立工厂、学校，发展工业和教育，规划城镇，国家才能繁荣富强。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">16_划分土地（上）：如何划分与组织内存？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5243 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#分段还是分页">分段还是分页</a></li>
        <li><a href="#如何表示一个页">如何表示一个页</a></li>
        <li><a href="#内存区">内存区</a></li>
        <li><a href="#组织内存页">组织内存页</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是 LMOS。</p>
<p>内存跟操作系统的关系，就像土地和政府的关系一样。政府必须合理规划这个国家的土地，才能让人民安居乐业。为了发展，政府还要进而建立工厂、学校，发展工业和教育，规划城镇，国家才能繁荣富强。</p>
<p>而作为计算机的实际掌权者，操作系统必须科学合理地管理好内存，应用程序才能高效稳定地运行。</p>
<p>内存管理是一项复杂的工作，我会用三节课带你搞定它。</p>
<p>具体我是这么安排的：这节课，我们先解决内存的划分方式和内存页的表示、组织问题，设计好数据结构。下一节课，我会带你在内存中建立数据结构对应的实例变量，搞定内存页的初始化问题。最后一节课，我们会依赖前面建好的数据结构，实现内存页面管理算法。</p>
<p>好，今天我们先从内存的划分单位讲起，一步步为内存管理工作做好准备。</p>
<p>今天课程的配套代码，你可以点击这里，自行下载。</p>
<h2 id="分段还是分页">分段还是分页</h2>
<p>要划分内存，我们就要先确定划分的单位是按段还是按页，就像你划分土地要选择按亩还是按平方分割一样。</p>
<p>其实分段与分页的优缺点，前面 MMU 相关的课程已经介绍过了。这里我们从内存管理角度，理一理分段与分页的问题。</p>
<p>**第一点，从表示方式和状态确定角度考虑。**段的长度大小不一，用什么数据结构表示一个段，如何确定一个段已经分配还是空闲呢？而页的大小固定，我们只需用位图就能表示页的分配与释放。</p>
<p>比方说，位图中第 1 位为 1，表示第一个页已经分配；位图中第 2 位为 0，表示第二个页是空闲，每个页的开始地址和大小都是固定的。</p>
<p>**第二点，从内存碎片的利用看，**由于段的长度大小不一，更容易产生内存碎片，例如内存中有 A 段（内存地址：0～5000）、B 段（内存地址：5001～8000）、C 段（内存地址：8001～9000），这时释放了 B 段，然后需要给 D 段分配内存空间，且 D 段长度为 5000。</p>
<p>你立马就会发现 A 段和 C 段之间的空间（B 段）不能满足，只能从 C 段之后的内存空间开始分配，随着程序运行，这些情况会越来越多。段与段之间存在着不大不小的空闲空间，内存总的空闲空间很多，但是放不下一个新段。</p>
<p>而页的大小固定，分配最小单位是页，页也会产生碎片，比如我需要请求分配 4 个页，但在内存中从第 1～3 个页是空闲的，第 4 个页是分配出去了，第 5 个页是空闲的。这种情况下，我们通过修改页表的方式，就能让连续的虚拟页面映射到非连续的物理页面。</p>
<p>**第三点，从内存和硬盘的数据交换效率考虑，**当内存不足时，操作系统希望把内存中的一部分数据写回硬盘，来释放内存。这就涉及到内存和硬盘交换数据，交换单位是段还是页？</p>
<p>如果是段的话，其大小不一，A 段有 50MB，B 段有 1KB，A、B 段写回硬盘的时间也不同，有的段需要时间长，有的段需要时间短，硬盘的空间分配也会有上面第二点同样的问题，这样会导致系统性能抖动。如果每次交换一个页，则没有这些问题。</p>
<p>还有最后一点，<strong>段最大的问题是使得虚拟内存地址空间，难于实施。</strong>（后面的课还会展开讲）</p>
<p>综上，我们自然选择分页模式来管理内存，其实现在所有的商用操作系统都使用了分页模式管理内存。我们用 4KB 作为页大小，这也正好对应 x86 CPU 长模式下 MMU 4KB 的分页方式。</p>
<h2 id="如何表示一个页">如何表示一个页</h2>
<p>我们使用分页模型来管理内存。首先是把物理内存空间分成 4KB 大小页，这页表示从地址 x 开始到 x+0xFFF 这一段的物理内存空间，x 必须是 0x1000 对齐的。这一段 x+0xFFF 的内存空间，称为<strong>内存页</strong>。</p>
<p>在逻辑上的结构图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/7d1286231a41931385afb6e50424f755.png" alt=""></p>
<p>物理内存分页结构图</p>
<p>上图这是一个接近真实机器的情况，不过一定不要忘记前面的内存布局示图，真实的物理内存地址空间不是连续的，这中间可能有空洞，可能是显存，也可能是外设的寄存器。</p>
<p>真正的物理内存空间布局信息来源于 <strong>e820map_t 结构数组</strong>，之前的初始化中，我们已经将其转换成 phymmarge_t 结构数组了，由 kmachbsp-&gt;mb_e820expadr 指向。</p>
<p>那问题来了，现在我们已经搞清楚了什么是页，但如何表示一个页呢？</p>
<p>你可能会想到位图或者整型变量数组，用其中一个位代表一个页，位值为 0 时表示页空闲，位值为 1 时表示页已分配；或者用整型数组中一个元素表示一个页，用具体数组元素的数值代表页的状态。</p>
<p>如果这样的话，分配、释放内存页的算法就确定了，就是扫描位图或者扫描数组。这样确实可以做出最简单的内存页管理器，但这也是最低效的。</p>
<p>上面的方案之所以低效，是因为我们仅仅只是保存了内存页的空闲和已分配的信息，这是不够的。我们的 Cosmos 当然不能这么做，我们需要页的状态、页的地址、页的分配记数、页的类型、页的链表，你自然就会想到，这些信息可以用一个 <strong>C 语言结构体</strong>封装起来。</p>
<p>让我们马上就来实现这个结构体，在 cosmos/include/halinc/ 下建立一个 msadsc_t.h 文件，在其中实现这个结构体，代码如下所示。</p>
<p>//内存空间地址描述符标志<br>
typedef struct s_MSADFLGS<br>
{<br>
u32_t mf_olkty:2;    //挂入链表的类型<br>
u32_t mf_lstty:1;    //是否挂入链表<br>
u32_t mf_mocty:2;    //分配类型，被谁占用了，内核还是应用或者空闲<br>
u32_t mf_marty:3;    //属于哪个区<br>
u32_t mf_uindx:24;   //分配计数<br>
}<strong>attribute</strong>((packed)) msadflgs_t;<br>
//物理地址和标志 <br>
typedef struct s_PHYADRFLGS<br>
{<br>
u64_t paf_alloc:1;     //分配位<br>
u64_t paf_shared:1;    //共享位<br>
u64_t paf_swap:1;      //交换位<br>
u64_t paf_cache:1;     //缓存位<br>
u64_t paf_kmap:1;      //映射位<br>
u64_t paf_lock:1;      //锁定位<br>
u64_t paf_dirty:1;     //脏位<br>
u64_t paf_busy:1;      //忙位<br>
u64_t paf_rv2:4;       //保留位<br>
u64_t paf_padrs:52;    //页物理地址位<br>
}<strong>attribute</strong>((packed)) phyadrflgs_t;<br>
//内存空间地址描述符<br>
typedef struct s_MSADSC<br>
{<br>
list_h_t md_list;           //链表<br>
spinlock_t md_lock;         //保护自身的自旋锁<br>
msadflgs_t md_indxflgs;     //内存空间地址描述符标志<br>
phyadrflgs_t md_phyadrs;    //物理地址和标志<br>
void* md_odlink;            //相邻且相同大小 msadsc 的指针<br>
}<strong>attribute</strong>((packed)) msadsc_t;</p>
<p>msadsc_t 结构看似很大，实则很小，也必须要小，因为它表示一个页面，物理内存页有多少就需要有多少个 msadsc_t 结构。正是因为页面地址总是按 4KB 对齐，所以 phyadrflgs_t 结构的低 12 位才可以另作它用。</p>
<p>msadsc_t 结构里的链表，可以方便它挂入到其他数据结构中。除了分配计数，msadflgs_t 结构中的其他部分都是用来描述 msadsc_t 结构本身信息的。</p>
<h2 id="内存区">内存区</h2>
<p>就像规划城市一样，一个城市常常会划分成多个不同的小区，我们 Cosmos 的内存管理器不仅仅是将内存划分成页面，还会把多个页面分成几个内存区，方便我们对内存更加合理地管理，进一步做精细化的控制。</p>
<p>我想提醒你的是，内存区和内存页不同，内存区只是一个逻辑上的概念，并不是硬件上必需的，就是说就算没有内存区，也毫不影响硬件正常工作；但是没有内存页是绝对不行的。</p>
<p>那么内存区到底是什么？我们一起看一幅图就明白了，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/3bb4469517a640a8c8b4d445d639f961.png" alt=""></p>
<p>内存区</p>
<p>根据前面的图片，我们发现把物理内存分成三个区，分别为硬件区，内核区，应用区。那它们有什么作用呢？我们分别来看看。</p>
<p>首先来看<strong>硬件区</strong>，它占用物理内存低端区域，地址区间为 0~32MB。从名字就能看出来，这个内存区域是给硬件使用的，我们不是使用虚拟地址吗？虚拟地址不是和物理地址无关吗，一个虚拟可以映射到任一合法的物理地址。</p>
<p>但凡事总有例外，虚拟地址主要依赖于 CPU 中的 MMU，但有很多外部硬件能直接和内存交换数据，常见的有 DMA，并且它只能访问低于 24MB 的物理内存。这就导致了我们很多内存页不能随便分配给这些设备，但是我们只要规定硬件区分配内存页就好，这就是硬件区的作用。</p>
<p>接着是<strong>内核区</strong>，内核也要使用内存，但是内核同样也是运行在虚拟地址空间，就需要有一段物理内存空间和内核的虚拟地址空间是线性映射关系。</p>
<p>再者，很多时候，内核使用内存需要大的、且连续的物理内存空间，比如一个进程的内核栈要 16KB 连续的物理内存、显卡驱动可能需要更大的连续物理内存来存放图形图像数据。这时，我们就需要在这个内核区中分配内存了。</p>
<p>最后我们来看下<strong>应用区</strong>，这个区域主是给应用用户态程序使用。应用程序使用虚拟地址空间，一开始并不会为应用一次性分配完所需的所有物理内存，而是按需分配，即应用用到一页就分配一个页。</p>
<p>如果访问到一个没有与物理内存页建立映射关系的虚拟内存页，这时候 CPU 就会产生缺页异常。最终这个缺页异常由操作系统处理，操作系统会分配一个物理内存页，并建好映射关系。</p>
<p>这是因为这种情况往往分配的是单个页面，所以为了给单个页面提供快捷的内存请求服务，就需要<strong>把离散的单页、或者是内核自身需要建好页表才可以访问的页面，统统收归到用户区。</strong></p>
<p>但是我们要如何表示一个内存区呢？和先前物理内存页面一样，我们需要定义一个数据结构，来表示一个内存区的开始地址和结束地址，里面有多少个物理页面，已经分配了多少个物理页面，剩下多少等等。</p>
<p>我们一起来写出这个数据结构，代码如下所示。</p>
<p>#define MA_TYPE_HWAD 1<br>
#define MA_TYPE_KRNL 2<br>
#define MA_TYPE_PROC 3<br>
#define MA_HWAD_LSTART 0<br>
#define MA_HWAD_LSZ 0x2000000<br>
#define MA_HWAD_LEND (MA_HWAD_LSTART+MA_HWAD_LSZ-1)<br>
#define MA_KRNL_LSTART 0x2000000<br>
#define MA_KRNL_LSZ (0x40000000-0x2000000)<br>
#define MA_KRNL_LEND (MA_KRNL_LSTART+MA_KRNL_LSZ-1)<br>
#define MA_PROC_LSTART 0x40000000<br>
#define MA_PROC_LSZ (0xffffffff-0x40000000)<br>
#define MA_PROC_LEND (MA_PROC_LSTART+MA_PROC_LSZ)</p>
<p>typedef struct s_MEMAREA<br>
{<br>
list_h_t ma_list;             //内存区自身的链表<br>
spinlock_t ma_lock;           //保护内存区的自旋锁<br>
uint_t ma_stus;               //内存区的状态<br>
uint_t ma_flgs;               //内存区的标志<br>
uint_t ma_type;               //内存区的类型<br>
sem_t ma_sem;                 //内存区的信号量<br>
wait_l_head_t ma_waitlst;     //内存区的等待队列<br>
uint_t ma_maxpages;           //内存区总的页面数<br>
uint_t ma_allocpages;         //内存区分配的页面数<br>
uint_t ma_freepages;          //内存区空闲的页面数<br>
uint_t ma_resvpages;          //内存区保留的页面数<br>
uint_t ma_horizline;          //内存区分配时的水位线<br>
adr_t ma_logicstart;          //内存区开始地址<br>
adr_t ma_logicend;            //内存区结束地址<br>
uint_t ma_logicsz;            //内存区大小<br>
//还有一些结构我们这里不关心。后面才会用到<br>
}memarea_t；</p>
<p>好了，关于内存区的数据结构我们就设计好了，但是这仍然不能让我们高效地分配内存，因为我们没有把内存区数据结构和内存页面数据结构关联起来，如果我们现在要分配内存页依然要遍历扫描 msadsc_t 结构数组，这和扫描位图没有本质的区别。</p>
<p>下面我们就把它们之间关联起来，也就是组织内存页。</p>
<h2 id="组织内存页">组织内存页</h2>
<p>如何组织内存页呢？按照我们之前对 msadsc_t 结构的定义，组织内存页就是组织 msadsc_t 结构，而 msadsc_t 结构中就有一个链表，你大概已经猜到了，我们组织 msadsc_t 结构正是通过另一个数据结构中的链表，将 msadsc_t 结构串连在其中的。</p>
<p>如果仅仅是这样，那我们将扫描这个链表，而这和之前扫描 msadsc_t 结构数组没有任何区别。</p>
<p>所以，我们需要更加科学合理地组织 msadsc_t 结构，下面我们来定义一个挂载 msadsc_t 结构的数据结构，它其中需要锁、状态、msadsc_t 结构数量，挂载 msadsc_t 结构的链表、和一些统计数据。</p>
<p>typedef struct s_BAFHLST<br>
{<br>
spinlock_t af_lock;    //保护自身结构的自旋锁<br>
u32_t af_stus;         //状态<br>
uint_t af_oder;        //页面数的位移量<br>
uint_t af_oderpnr;     //oder 对应的页面数比如 oder 为 2 那就是 1&laquo;2=4<br>
uint_t af_fobjnr;      //多少个空闲 msadsc_t 结构，即空闲页面<br>
uint_t af_mobjnr;      //此结构的 msadsc_t 结构总数，即此结构总页面<br>
uint_t af_alcindx;     //此结构的分配计数<br>
uint_t af_freindx;     //此结构的释放计数<br>
list_h_t af_frelst;    //挂载此结构的空闲 msadsc_t 结构<br>
list_h_t af_alclst;    //挂载此结构已经分配的 msadsc_t 结构<br>
}bafhlst_t;</p>
<p>有了 bafhlst_t 数据结构，我们只是有了挂载 msadsc_t 结构的地方，这并没有做到科学合理。</p>
<p>但是，如果我们把多个 bafhlst_t 数据结构组织起来，形成一个 bafhlst_t 结构数组，并且把这个 bafhlst_t 结构数组放在一个更高的数据结构中，这个数据结构就是内存分割合并数据结构——memdivmer_t，那情况就不一样了。</p>
<p>有何不一样呢？请往下看。</p>
<p>#define MDIVMER_ARR_LMAX 52<br>
typedef struct s_MEMDIVMER<br>
{<br>
spinlock_t dm_lock;      //保护自身结构的自旋锁<br>
u32_t dm_stus;           //状态<br>
uint_t dm_divnr;         //内存分配次数<br>
uint_t dm_mernr;         //内存合并次数<br>
bafhlst_t dm_mdmlielst[MDIVMER_ARR_LMAX];//bafhlst_t 结构数组<br>
bafhlst_t dm_onemsalst;  //单个的 bafhlst_t 结构<br>
}memdivmer_t;</p>
<p>那问题来了，内存不是只有两个标准操作吗，这里我们为什么要用分割和合并呢？这其实取意于我们的内存分配、释放算法，对这个算法而言分配内存就是分割内存，而释放内存就是合并内存。</p>
<p>如果 memdivmer_t 结构中 dm_mdmlielst 数组只是一个数组，那是没有意义的。我们正是要通过 dm_mdmlielst 数组，来划分物理内存地址不连续的 msadsc_t 结构。</p>
<p>dm_mdmlielst 数组中第 0 个元素挂载单个 msadsc_t 结构，它们的物理内存地址可能对应于 0x1000，0x3000，0x5000。</p>
<p>dm_mdmlielst 数组中第 1 个元素挂载两个连续的 msadsc_t 结构，它们的物理内存地址可能对应于 0x8000～0x9FFF，0xA000～0xBFFF；dm_mdmlielst 数组中第 2 个元素挂载 4 个连续的 msadsc_t 结构，它们的物理内存地址可能对应于 0x100000～0x103FFF，0x104000～0x107FFF……</p>
<p>依次类推，dm_mdmlielst 数组挂载连续 msadsc_t 结构的数量等于用 1 左移其数组下标，如数组下标为 3，那结果就是 8（1&laquo;3）个连续的 msadsc_t 结构。</p>
<p>需要注意的是，<strong>我们并不在意其中第一个 msadsc_t 结构对应的内存物理地址从哪里开始，但是第一个 msadsc_t 结构与最后一个 msadsc_t 结构，它们之间的内存物理地址是连续的。</strong></p>
<p>如果还是不明白，我们来画个图就清楚了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/c54bb426b897b180799cab8ee68f9830.png" alt=""></p>
<p>页面组织结构示意图</p>
<p>从上图上我们可以看出，每个内存区 memarea_t 结构中包含一个内存分割合并 memdivmer_t 结构，而在 memdivmer_t 结构中又包含 dm_mdmlielst 数组。在 dm_mdmlielst 数组中挂载了多个 msadsc_t 结构。</p>
<p>那么为什么要这么组织呢？后面我们在分配内存的时候，你就会明白了。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>今天我们从比对分段与分页的区别开始思考，确定了使用分页方式，设计了内存页、内存区等一系列数据结构，下面我们来回顾一下本课程的重点。</p>
<p>1. 我们探讨了<strong>分段与分页的区别</strong>，发现段长度不一，容易产生内存碎片、不容易和硬盘换入换出数据，更不能实现扁平化的虚拟内存地址空间，由于这些不足我们选择了分页模式来管理内存，其实现在所有的商用操作系统都使用了分页模式管理内存。</p>
<p>2. 为了实现分页管理，首先是解决<strong>如何表示一个物理内存页</strong>，我们想到过位图和字节数组，但是它们遍历扫描，性能太差，于是设计了更复杂的 <strong>msadsc_t 结构</strong>，一个 msadsc_t 结构对应一个可用的物理内存页面。</p>
<p>3. 为了适应不同的物理地址空间的要求，比如有些设备需要低端的物理地址，而有的需要大而连续地址空间，我们对内存进行分区，<strong>设计了 memarea_t 结构</strong>。</p>
<p>每个 memarea_t 结构表示一个内存区，memarea_t 结构中包含一个内存分割合并 memdivmer_t 结构，而在 memdivmer_t 结构中又包含了 bafhlst_t 结构类型 dm_mdmlielst 数组。在 dm_mdmlielst 数组中挂载了多个 msadsc_t 结构。</p>
<h2 id="思考题">思考题</h2>
<p>我们为什么要以 2 的（0～52）次方为页面数来组织页面呢？</p>
<p>欢迎你在留言区跟我交流互动，也欢迎你把这节课分享给你的同事、朋友。</p>
<p>我是 LMOS，我们下节课见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/">操作系统实战45讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%9836%E8%AE%B2/16_%E6%9E%84%E5%BB%BA%E8%B5%84%E6%BA%90%E7%9A%84%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">16_构建资源的弹性伸缩</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B42%E8%AE%B2/16_%E9%AA%97%E6%9C%AF%E5%8D%87%E7%BA%A7%E5%81%87%E7%BB%93%E5%A9%9A%E5%81%87%E7%A6%BB%E5%A9%9A%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/">
            <span class="next-text nav-default">16_骗术升级？假结婚、假离婚的那些事儿</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
