<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>34_仓库管理：如何实现文件的六大基本操作？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是 LMOS。
我们在上一节课中，已经建立了仓库，并对仓库进行了划分，就是文件系统的格式化。有了仓库就需要往里面存取东西，对于我们的仓库来说，就是存取应用程序的文件。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/34_%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%AD%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/34_%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%AD%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="34_仓库管理：如何实现文件的六大基本操作？">
  <meta property="og:description" content="你好，我是 LMOS。
我们在上一节课中，已经建立了仓库，并对仓库进行了划分，就是文件系统的格式化。有了仓库就需要往里面存取东西，对于我们的仓库来说，就是存取应用程序的文件。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="操作系统实战45讲">

  <meta itemprop="name" content="34_仓库管理：如何实现文件的六大基本操作？">
  <meta itemprop="description" content="你好，我是 LMOS。
我们在上一节课中，已经建立了仓库，并对仓库进行了划分，就是文件系统的格式化。有了仓库就需要往里面存取东西，对于我们的仓库来说，就是存取应用程序的文件。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="10262">
  <meta itemprop="keywords" content="操作系统实战45讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="34_仓库管理：如何实现文件的六大基本操作？">
  <meta name="twitter:description" content="你好，我是 LMOS。
我们在上一节课中，已经建立了仓库，并对仓库进行了划分，就是文件系统的格式化。有了仓库就需要往里面存取东西，对于我们的仓库来说，就是存取应用程序的文件。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">34_仓库管理：如何实现文件的六大基本操作？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 10262 字 </span>
          <span class="more-meta"> 预计阅读 21 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#辅助操作">辅助操作</a>
          <ul>
            <li><a href="#操作根目录文件">操作根目录文件</a></li>
            <li><a href="#获取文件名">获取文件名</a></li>
            <li><a href="#判断文件是否存在">判断文件是否存在</a></li>
          </ul>
        </li>
        <li><a href="#文件相关的操作">文件相关的操作</a>
          <ul>
            <li><a href="#新建文件">新建文件</a></li>
            <li><a href="#删除文件">删除文件</a></li>
            <li><a href="#打开文件">打开文件</a></li>
            <li><a href="#读写文件">读写文件</a></li>
            <li><a href="#关闭文件">关闭文件</a></li>
          </ul>
        </li>
        <li><a href="#串联整合">串联整合</a></li>
        <li><a href="#测试">测试</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是 LMOS。</p>
<p>我们在上一节课中，已经建立了仓库，并对仓库进行了划分，就是文件系统的格式化。有了仓库就需要往里面存取东西，对于我们的仓库来说，就是存取应用程序的文件。</p>
<p>所以今天我们要给仓库增加一些相关的操作，这些操作主要用于新建、打开、关闭、读写文件，它们也是文件系统的标准功能，自然即使我们这个最小的文件系统，也必须要支持。</p>
<p>好了，话不多说，我们开始吧。这节课的配套代码，你可以从这里下载。</p>
<h2 id="辅助操作">辅助操作</h2>
<p>通过上一节课的学习，我们了解了文件系统格式化操作，不难发现文件系统格式化并不复杂，但是它们需要大量的辅助函数。同样的，完成文件相关的操作，我们也需要大量的辅助函数。为了让你更加清楚每个实现细节，这里我们先来实现文件操作相关的辅助函数。</p>
<h3 id="操作根目录文件">操作根目录文件</h3>
<p>根据我们文件系统的设计，不管是新建、删除、打开一个文件，首先都要找到与该文件对应的 rfsdir_t 结构。</p>
<p>在我们的文件系统中，一个文件的 rfsdir_t 结构就储存在根目录文件中，所以想要读取文件对应的 rfsdir_t 结构，首先就要获取和释放根目录文件。</p>
<p>下面我们来实现获取和释放根目录文件的函数，代码如下所示。</p>
<p>//获取根目录文件<br>
void* get_rootdirfile_blk(device_t* devp)<br>
{<br>
void* retptr = NULL; <br>
rfsdir_t* rtdir = get_rootdir(devp);//获取根目录文件的 rfsdir_t 结构<br>
//分配 4KB 大小的缓冲区并清零<br>
void* buf = new_buf(FSYS_ALCBLKSZ);<br>
hal_memset(buf, FSYS_ALCBLKSZ, 0);<br>
//读取根目录文件的逻辑储存块到缓冲区中<br>
read_rfsdevblk(devp, buf, rtdir-&gt;rdr_blknr)<br>
retptr = buf;//设置缓冲区的首地址为返回值<br>
goto errl1;<br>
errl:<br>
del_buf(buf, FSYS_ALCBLKSZ);<br>
errl1:<br>
del_rootdir(devp, rtdir);//释放根目录文件的 rfsdir_t 结构<br>
return retptr;<br>
}<br>
//释放根目录文件<br>
void del_rootdirfile_blk(device_t* devp,void* blkp)<br>
{<br>
//因为逻辑储存块的头 512 字节的空间中，保存的就是 fimgrhd_t 结构<br>
fimgrhd_t* fmp = (fimgrhd_t*)blkp;<br>
//把根目录文件回写到储存设备中去，块号为 fimgrhd_t 结构自身所在的块号<br>
write_rfsdevblk(devp, blkp, fmp-&gt;fmd_sfblk)<br>
//释放缓冲区<br>
del_buf(blkp, FSYS_ALCBLKSZ);<br>
return;<br>
}</p>
<p>上述代码中，get_rootdir 函数的作用就是读取文件系统超级块中 rfsdir_t 结构到一个缓冲区中，del_rootdir 函数则是用来释放这个缓冲区，其代码非常简单，我已经帮你写好了。</p>
<p>获取根目录文件的方法也很容易，根据超级块中的 rfsdir_t 结构中的信息，读取根目录文件的逻辑储存块就行了。而释放根目录文件，就是把根目录文件的储存块回写到储存设备中去，最后释放对应的缓冲区就可以了。</p>
<h3 id="获取文件名">获取文件名</h3>
<p>下面我们来实现获取文件名，在我们的印象中，一个完整的文件名应该是这样的“/cosmos/drivers/drvrfs.c”，这样的文件名包含了完整目录路径。</p>
<p>除了第一个“/”是根目录外，其它的“/”只是一个目录路径分隔符。然而，在很多情况下，我们通常需要把目录路径分隔符去除，提取其中的目录名称或者文件名称。为了简化问题，我们对文件系统来点限制，我们的文件名只能是“/xxxx”这种类型的。</p>
<p>下面我们就来实现去除路径分隔符提取文件名称的函数，代码如下所示。</p>
<p>//检查文件路径名<br>
sint_t rfs_chkfilepath(char_t* fname)<br>
{<br>
char_t* chp = fname;<br>
//检查文件路径名的第一个字符是否为“/”，不是则返回 2<br>
if(chp[0] != &lsquo;/&rsquo;) { return 2; }<br>
for(uint_t i = 1; ; i++)<br>
{<br>
//检查除第 1 个字符外其它字符中还有没有为“/”的，有就返回 3<br>
if(chp[i] == &lsquo;/&rsquo;) { return 3; }<br>
//如果这里 i 大于等于文件名称的最大长度，就返回 4<br>
if(i &gt;= DR_NM_MAX) { return 4; }<br>
//到文件路径字符串的末尾就跳出循环<br>
if(chp[i] == 0 &amp;&amp; i &gt; 1) { break; }<br>
}<br>
//返回 0 表示正确<br>
return 0;<br>
}<br>
//提取纯文件名<br>
sint_t rfs_ret_fname(char_t* buf,char_t* fpath)<br>
{<br>
//检查文件路径名是不是“/xxxx”的形式<br>
sint_t stus = rfs_chkfilepath(fpath);<br>
//如果不为 0 就直接返回这个状态值表示错误<br>
if(stus != 0) { return stus; }<br>
//从路径名字符串的第 2 个字符开始复制字符到 buf 中<br>
rfs_strcpy(&amp;fpath[1], buf);<br>
return 0;<br>
}</p>
<p>上述代码中，完成获取文件名的是 rfs_ret_fname 函数，这个函数可以把 fpath 指向的路径名中的文件名提取出来，放到 buf 指向的缓冲区中，但在这之前，需要先调用 rfs_chkfilepath 函数检查路径名是不是“/xxxx”的形式，这是这个功能正常实现的必要条件。</p>
<h3 id="判断文件是否存在">判断文件是否存在</h3>
<p>获取了文件名称，我们还需要实现这样一个功能：判断一个文件是否存在。因为新建和删除文件，要先判断储存设备里是不是存在着这个文件。具体来说，新建文件时，无法新建相同文件名的文件；删除文件时，不能删除不存在的文件。</p>
<p>我们一起通过后面这个函数还完成这个功能，代码如下所示。</p>
<p>sint_t rfs_chkfileisindev(device_t* devp,char_t* fname)<br>
{<br>
sint_t rets = 6;<br>
sint_t ch = rfs_strlen(fname);//获取文件名的长度，注意不是文件路径名<br>
//检查文件名的长度是不是合乎要求<br>
if(ch &lt; 1 || ch &gt;= (sint_t)DR_NM_MAX) { return 4; }<br>
void* rdblkp = get_rootdirfile_blk(devp);<br>
fimgrhd_t* fmp = (fimgrhd_t*)rdblkp;<br>
//检查该 fimgrhd_t 结构的类型是不是 FMD_DIR_TYPE，即这个文件是不是目录文件<br>
if(fmp-&gt;fmd_type != FMD_DIR_TYPE) { rets = 3; goto err; }<br>
//检查根目录文件是不是为空，即没有写入任何数据，所以返回 0，表示根目录下没有对应的文件<br>
if(fmp-&gt;fmd_curfwritebk == fmp-&gt;fmd_fleblk[0].fb_blkstart &amp;&amp;<br>
fmp-&gt;fmd_curfinwbkoff == fmp-&gt;fmd_fileifstbkoff) {<br>
rets = 0; goto err;<br>
}<br>
rfsdir_t* dirp = (rfsdir_t*)((uint_t)(fmp) + fmp-&gt;fmd_fileifstbkoff);//指向根目录文件的第一个字节<br>
//指向根目录文件的结束地址<br>
void* maxchkp = (void*)((uint_t)rdblkp + FSYS_ALCBLKSZ - 1);<br>
//当前的 rfsdir_t 结构的指针比根目录文件的结束地址小，就继续循环   <br>
for(;(void*)dirp &lt; maxchkp;) {<br>
//如果这个 rfsdir_t 结构的类型是 RDR_FIL_TYPE，说明它对应的是文件而不是目录，所以下面就继续比较其文件名<br>
if(dirp-&gt;rdr_type == RDR_FIL_TYPE) {<br>
if(rfs_strcmp(dirp-&gt;rdr_name,fname) == 1) {//比较其文件名<br>
rets = 1; goto err;<br>
}<br>
}<br>
dirp++;<br>
}<br>
rets = 0; //到了这里说明没有找到相同的文件<br>
err:<br>
del_rootdirfile_blk(devp,rdblkp);//释放根目录文件<br>
return rets;<br>
}</p>
<p>上述代码中，rfs_chkfileisindev 函数逻辑很简单。首先是检查文件名的长度，接着获取了根目录文件，然后遍历根其中的所有 rfsdir_t 结构并比较文件名是否相同，相同就返回 1，不同就返回其它值，最后释放了根目录文件。</p>
<p>因为 get_rootdirfile_blk 函数已经把根目录文件读取到内存里了，所以可以用 dirp 指针和 maxchkp 指针操作其中的数据。</p>
<p>好了，操作根目录文件、获取文件名、判断一个文件是否存在的三大函数就实现了，有了它们，再去实现文件相关的其它操作就方便多了，我们接着探索。</p>
<h2 id="文件相关的操作">文件相关的操作</h2>
<p>直到现在，我们还没对任何文件进行操作，而我们实现文件系统，就是为了应用程序更好地存放自己的“劳动成果”——文件，因此一个文件系统必须要支持一些文件操作。</p>
<p>下面我们将依次实现新建、删除、打开、读写以及关闭文件，这几大文件操作，这也是文件系统需要提供的最基本的功能。</p>
<h3 id="新建文件">新建文件</h3>
<p>在没有文件之前，对任何文件本身的操作都是无效的，所以我们首先就要实现新建文件这个功能。</p>
<p>在写代码之前，我们还是先来看一看如何新建一个文件，一共可以分成后面这 4 步。</p>
<p>1. 从文件路径名中提取出纯文件名，检查储存设备上是否已经存在这个文件。</p>
<p>2. 分配一个空闲的逻辑储存块，并在根目录文件的末尾写入这个新建文件对应的 rfsdir_t 结构。</p>
<p>3. 在一个新的 4KB 大小的缓冲区中，初始化新建文件对应的 fimgrhd_t 结构。</p>
<p>4. 把第 3 步对应的缓冲区里的数据，写入到先前分配的空闲逻辑储存块中。</p>
<p>下面我们先来写好新建文件的接口函数。</p>
<p>//新建文件的接口函数<br>
drvstus_t rfs_new_file(device_t* devp, char_t* fname, uint_t flg)<br>
{<br>
//在栈中分配一个字符缓冲区并清零<br>
char_t fne[DR_NM_MAX];<br>
hal_memset((void*)fne, DR_NM_MAX, 0);<br>
//从文件路径名中提取出纯文件名<br>
if(rfs_ret_fname(fne, fname) != 0) { return DFCERRSTUS; }<br>
//检查储存介质上是否已经存在这个新建的文件，如果是则返回错误<br>
if(rfs_chkfileisindev(devp, fne) != 0) {return DFCERRSTUS; }<br>
//调用实际建立文件的函数<br>
return rfs_new_dirfileblk(devp, fne, RDR_FIL_TYPE, 0);<br>
}</p>
<p>我们在新建文件的接口函数中，就实现了前面第一步，完成了提取文件名和检查文件是否在储存设备中存在的工作。接着我们来实现真正新建文件的函数，就是上述代码中 rfs_new_dirfileblk 函数，代码如下所示。</p>
<p>drvstus_t rfs_new_dirfileblk(device_t* devp,char_t* fname,uint_t flgtype,uint_t val)<br>
{<br>
drvstus_t rets = DFCERRSTUS;<br>
void* buf = new_buf(FSYS_ALCBLKSZ);//分配一个 4KB 大小的缓冲区   <br>
hal_memset(buf, FSYS_ALCBLKSZ, 0);//清零该缓冲区<br>
uint_t fblk = rfs_new_blk(devp);//分配一个新的空闲逻辑储存块<br>
void* rdirblk = get_rootdirfile_blk(devp);//获取根目录文件<br>
fimgrhd_t* fmp = (fimgrhd_t*)rdirblk;<br>
//指向文件当前的写入地址，因为根目录文件已经被读取到内存中了<br>
rfsdir_t* wrdirp = (rfsdir_t*)((uint_t)rdirblk + fmp-&gt;fmd_curfinwbkoff);<br>
//对文件当前的写入地址进行检查<br>
if(((uint_t)wrdirp) &gt;= ((uint_t)rdirblk + FSYS_ALCBLKSZ)) {<br>
rets=DFCERRSTUS; goto err;<br>
}<br>
wrdirp-&gt;rdr_stus = 0;<br>
wrdirp-&gt;rdr_type = flgtype;//设为文件类型<br>
wrdirp-&gt;rdr_blknr = fblk;//设为刚刚分配的空闲逻辑储存块<br>
rfs_strcpy(fname, wrdirp-&gt;rdr_name);//把文件名复制到 rfsdir_t 结构<br>
fmp-&gt;fmd_filesz += (uint_t)(sizeof(rfsdir_t));//增加根目录文件的大小<br>
//增加根目录文件当前的写入地址，保证下次不被覆盖<br>
fmp-&gt;fmd_curfinwbkoff += (uint_t)(sizeof(rfsdir_t));<br>
fimgrhd_t* ffmp = (fimgrhd_t*)buf;//指向新分配的缓冲区<br>
fimgrhd_t_init(ffmp);//调用 fimgrhd_t 结构默认的初始化函数<br>
ffmp-&gt;fmd_type = FMD_FIL_TYPE;//因为建立的是文件，所以设为文件类型<br>
ffmp-&gt;fmd_sfblk = fblk;//把自身所在的块，设为分配的逻辑储存块<br>
ffmp-&gt;fmd_curfwritebk = fblk;//把当前写入的块，设为分配的逻辑储存块<br>
ffmp-&gt;fmd_curfinwbkoff = 0x200;//把当前写入块的写入偏移量设为 512<br>
//把文件储存块数组的第 1 个元素的开始块，设为刚刚分配的空闲逻辑储存块<br>
ffmp-&gt;fmd_fleblk[0].fb_blkstart = fblk;<br>
//因为只分配了一个逻辑储存块，所以设为 1<br>
ffmp-&gt;fmd_fleblk[0].fb_blknr = 1;<br>
//把缓冲区中的数据写入到刚刚分配的空闲逻辑储存块中<br>
if(write_rfsdevblk(devp, buf, fblk) == DFCERRSTUS) {      <br>
rets = DFCERRSTUS; goto err;<br>
}<br>
rets = DFCOKSTUS;<br>
err:<br>
del_rootdirfile_blk(devp, rdirblk);//释放根目录文件<br>
err1:<br>
del_buf(buf, FSYS_ALCBLKSZ);//释放缓冲区<br>
return rets;<br>
}</p>
<p>看完上述代码，我想提醒你，在 rfs_new_dirfileblk 函数中有两点很关键。</p>
<p>第一，前面反复提到的目录文件中存放的就是<strong>一系列的 rfsdir_t 结构</strong>。</p>
<p>第二，fmp 和 ffmp 这两个指针很重要。fmp 指针指向的是根目录文件的 fimgrhd_t 结构，因为要写入一个新的 rfsdir_t 结构，所以要获取并改写根目录文件的 fimgrhd_t 结构中的数据。而 ffmp 指针指向的是新建文件的 fimgrhd_t 结构，并且初始化了其中的一些数据。最后，该函数把这个缓冲区中的数据写入到分配的空闲逻辑储存块中，同时释放了根目录文件和缓冲区。</p>
<h3 id="删除文件">删除文件</h3>
<p>新建文件的操作完成了，下面我们来实现删除文件的操作。</p>
<p>如果只能新建文件而不能删除文件，那么储存设备的空间最终会耗尽，所以文件系统就必须支持删除文件的操作。</p>
<p>同样的，还是先来了解删除文件的方法。删除文件可以通过后面这 4 步来实现。</p>
<p>1. 从文件路径名中提取出纯文件名。</p>
<p>2. 获取根目录文件，从根目录文件中查找待删除文件的 rfsdir_t 结构，然后释放该文件占用的逻辑储存块。</p>
<p>3. 初始化与待删除文件相对应的 rfsdir_t 结构，并设置 rfsdir_t 结构的类型为 RDR_DEL_TYPE。</p>
<p>4. 释放根目录文件。</p>
<p>这次我们用三个函数来实现这些步骤，删除文件的接口函数的代码如下。</p>
<p>//文件删除的接口函数<br>
drvstus_t rfs_del_file(device_t* devp, char_t* fname, uint_t flg)<br>
{<br>
if(flg != 0) {<br>
return DFCERRSTUS;<br>
}<br>
return rfs_del_dirfileblk(devp, fname, RDR_FIL_TYPE, 0);<br>
}</p>
<p>删除文件的接口函数非常之简单，就是判断一下标志，接着调用了 rfs_del_dirfileblk 函数，下面我们就来写好这个 rfs_del_dirfileblk 函数。</p>
<p>drvstus_t rfs_del_dirfileblk(device_t* devp, char_t* fname, uint_t flgtype, uint_t val)<br>
{<br>
if(flgtype != RDR_FIL_TYPE || val != 0) { return DFCERRSTUS; }<br>
char_t fne[DR_NM_MAX];<br>
hal_memset((void*)fne, DR_NM_MAX, 0);<br>
//提取纯文件名<br>
if(rfs_ret_fname(fne,fname) != 0) { return DFCERRSTUS; }<br>
//调用删除文件的核心函数<br>
if(del_dirfileblk_core(devp, fne) != 0) { return DFCERRSTUS; }<br>
return DFCOKSTUS;<br>
}</p>
<p>rfs_del_dirfileblk 函数只是提取了文件名，然后调用了一个删除文件的核心函数，这个核心函数就是 del_dirfileblk_core 函数，它的实现代码如下所示。</p>
<p>//删除文件的核心函数<br>
sint_t del_dirfileblk_core(device_t* devp, char_t* fname)<br>
{<br>
sint_t rets = 6;<br>
void* rblkp=get_rootdirfile_blk(devp);//获取根目录文件<br>
fimgrhd_t* fmp = (fimgrhd_t*)rblkp;<br>
if(fmp-&gt;fmd_type!=FMD_DIR_TYPE) { //检查根目录文件的类型<br>
rets=4; goto err;<br>
}<br>
if(fmp-&gt;fmd_curfwritebk == fmp-&gt;fmd_fleblk[0].fb_blkstart &amp;&amp; fmp-&gt;fmd_curfinwbkoff == fmp-&gt;fmd_fileifstbkoff) { //检查根目录文件中有没有数据<br>
rets = 3; goto err;<br>
}<br>
rfsdir_t* dirp = (rfsdir_t*)((uint_t)(fmp) + fmp-&gt;fmd_fileifstbkoff);<br>
void* maxchkp = (void*)((uint_t)rblkp + FSYS_ALCBLKSZ-1);<br>
for(;(void*)dirp &lt; maxchkp;) {<br>
if(dirp-&gt;rdr_type == RDR_FIL_TYPE) {//检查其类型是否为文件类型<br>
//如果文件名相同，就执行以下删除动作<br>
if(rfs_strcmp(dirp-&gt;rdr_name, fname) == 1) {<br>
//释放 rfsdir_t 结构的 rdr_blknr 中指向的逻辑储存块<br>
rfs_del_blk(devp, dirp-&gt;rdr_blknr);<br>
//初始化 rfsdir_t 结构，实际上是清除其中的数据<br>
rfsdir_t_init(dirp);<br>
//设置 rfsdir_t 结构的类型为删除类型，表示它已经删除<br>
dirp-&gt;rdr_type = RDR_DEL_TYPE;<br>
rets = 0; goto err;<br>
}<br>
}<br>
dirp++;//下一个 rfsdir_t<br>
}<br>
rets=1;<br>
err:<br>
del_rootdirfile_blk(devp,rblkp);//释放根目录文件<br>
return rets;<br>
}</p>
<p>上述代码中的 del_dirfileblk_core 函数，它主要是遍历根目录文件中所有的 rfsdir_t 结构，并比较其文件名，看看删除的文件名称是否相同，相同就释放该 rfsdir_t 结构的 rdr_blknr 字段对应的逻辑储存块，清除该 rfsdir_t 结构中的数据，同时设置该 rfsdir_t 结构的类型为删除类型。</p>
<p>你可以这样理解：删除一个文件，就是把这个文件对应的 rfsdir_t 结构中的数据清空，这样就无法查找到这个文件了。同时，也要释放该文件占用的逻辑储存块。因为没有清空文件数据，所以可以通过反删除软件找回文件。</p>
<h3 id="打开文件">打开文件</h3>
<p>接下来，我们就要实现打开文件操作了。一个已经存在的文件，要对它进行读写操作，首先就应该打开这个文件。</p>
<p>在实现这个打开文件操作之前，我们不妨先回忆一下前面课程里提到的objnode_t 结构。</p>
<p>Cosmos 内核上层组件调用设备驱动程序时，都需要建立一个相应的 objnode_t 结构，把这个 I/O 包发送给相应的驱动程序，但是 objnode_t 结构不仅仅是用于驱动程序，它还用于表示进程使用了哪些资源，例如打开了哪些设备或者文件，而每打开一个设备或者文件就建立一个 objnode_t 结构，放在特定进程的资源表中。</p>
<p>为了适应文件系统设备驱动程序，在 cosmos/include/krlinc/krlobjnode_t.h 文件中，需要在 objnode_t 结构中增加一些东西，代码如下所示。</p>
<p>#define OBJN_TY_DEV 1//设备类型<br>
#define OBJN_TY_FIL 2//文件类型<br>
#define OBJN_TY_NUL 0//默认类型<br>
typedef struct s_OBJNODE<br>
{<br>
spinlock_t  on_lock;<br>
list_h_t    on_list;<br>
sem_t       on_complesem;<br>
uint_t      on_flgs;<br>
uint_t      on_stus;<br>
//……<br>
void*       on_fname;//文件路径名指针<br>
void*       on_finode;//文件对应的 fimgrhd_t 结构指针<br>
void*       on_extp;//扩展所用<br>
}objnode_t;</p>
<p>上述代码中 objnode_t 结构里增加了两个字段，一个是指向文件路径名的指针，表示打开哪个文件。因为要知道一个文件的所有信息，所以增加了指向对应文件的 fimgrhd_t 结构指针，也就是我们增加的第二个字段。</p>
<p>现在我们来看看打开一个文件的流程。一共也是 4 步。</p>
<p>1. 从 objnode_t 结构的文件路径提取文件名。</p>
<p>2. 获取根目录文件，在该文件中搜索对应的 rfsdir_t 结构，看看文件是否存在。</p>
<p>3. 分配一个 4KB 缓存区，把该文件对应的 rfsdir_t 结构中指向的逻辑储存块读取到缓存区中，然后释放根目录文件。</p>
<p>4. 把缓冲区中的 fimgrhd_t 结构的地址，保存到 objnode_t 结构的 on_finode 域中。</p>
<p>下面来写两个函数实现这些流程，同样我们需要先写好接口函数，代码如下所示。</p>
<p>//打开文件的接口函数<br>
drvstus_t rfs_open_file(device_t* devp, void* iopack)<br>
{<br>
objnode_t* obp = (objnode_t*)iopack;<br>
//检查 objnode_t 中的文件路径名<br>
if(obp-&gt;on_fname == NULL) {<br>
return DFCERRSTUS;<br>
}<br>
//调用打开文件的核心函数<br>
void* fmdp = rfs_openfileblk(devp, (char_t*)obp-&gt;on_fname);<br>
if(fmdp == NULL) {<br>
return DFCERRSTUS;<br>
}<br>
//把返回的 fimgrhd_t 结构的地址保存到 objnode_t 中的 on_finode 字段中<br>
obp-&gt;on_finode = fmdp;<br>
return DFCOKSTUS;<br>
}</p>
<p>接口函数 rfs_open_file 中只是对参数进行了检查。然后调用了核心函数，这个函数就是 rfs_openfileblk，它的代码实现如下所示。</p>
<p>//打开文件的核心函数<br>
void* rfs_openfileblk(device_t <em>devp, char_t</em> fname)<br>
{<br>
char_t fne[DR_NM_MAX]; void* rets = NULL,<em>buf = NULL;<br>
hal_memset((void</em>)fne,DR_NM_MAX,0);<br>
if(rfs_ret_fname(fne, fname) != 0) {//从文件路径名中提取纯文件名<br>
return NULL;<br>
}<br>
void* rblkp = get_rootdirfile_blk(devp); //获取根目录文件<br>
fimgrhd_t* fmp = (fimgrhd_t*)rblkp;<br>
if(fmp-&gt;fmd_type != FMD_DIR_TYPE) {//判断根目录文件的类型是否合理<br>
rets = NULL; goto err;<br>
}<br>
//判断根目录文件里有没有数据<br>
if(fmp-&gt;fmd_curfwritebk == fmp-&gt;fmd_fleblk[0].fb_blkstart &amp;&amp;<br>
fmp-&gt;fmd_curfinwbkoff == fmp-&gt;fmd_fileifstbkoff) {<br>
rets = NULL; goto err;<br>
}<br>
rfsdir_t* dirp = (rfsdir_t*)((uint_t)(fmp) + fmp-&gt;fmd_fileifstbkoff);<br>
void* maxchkp = (void*)((uint_t)rblkp + FSYS_ALCBLKSZ - 1);<br>
for(;(void*)dirp &lt; maxchkp;) {//开始遍历文件对应的 rfsdir_t 结构<br>
if(dirp-&gt;rdr_type == RDR_FIL_TYPE) {<br>
//如果文件名相同就跳转到 opfblk 标号处运行<br>
if(rfs_strcmp(dirp-&gt;rdr_name, fne) == 1) {<br>
goto opfblk;<br>
}<br>
}<br>
dirp++;<br>
}<br>
//如果到这里说明没有找到该文件对应的 rfsdir_t 结构，所以设置返回值为 NULL<br>
rets = NULL; goto err;<br>
opfblk:<br>
buf = new_buf(FSYS_ALCBLKSZ);//分配 4KB 大小的缓冲区<br>
//读取该文件占用的逻辑储存块<br>
if(read_rfsdevblk(devp, buf, dirp-&gt;rdr_blknr) == DFCERRSTUS) {<br>
rets = NULL; goto err1;<br>
}<br>
fimgrhd_t* ffmp = (fimgrhd_t*)buf;<br>
if(ffmp-&gt;fmd_type == FMD_NUL_TYPE || ffmp-&gt;fmd_fileifstbkoff != 0x200) {//判断将要打开的文件是否合法<br>
rets = NULL; goto err1;<br>
}<br>
rets = buf; goto err;//设置缓冲区首地址为返回值<br>
err1:<br>
del_buf(buf, FSYS_ALCBLKSZ); //上面的步骤若出现问题就要释放缓冲区<br>
err:<br>
del_rootdirfile_blk(devp, rblkp); //释放根目录文件<br>
return rets;<br>
}</p>
<p>结合上面的代码我们能够看到，通过 rfs_openfileblk 函数中的 for 循环，可以遍历要打开的文件在根目录文件中对应的 rfsdir_t 结构，然后把对应文件占用的逻辑储存块读取到缓冲区中，最后返回这个缓冲区的首地址。</p>
<p>因为这个缓冲区开始的空间中，就存放着其文件对应的 fimgrhd_t 结构，所以返回 fimgrhd_t 结构的地址，整个打开文件的流程就结束了。</p>
<h3 id="读写文件">读写文件</h3>
<p>刚才我们已经实现了打开文件，而打开一个文件，就是为了对这个文件进行读写。</p>
<p>其实对文件的读写包含两个操作，一个是从储存设备中读取文件的数据，另一个是把文件的数据写入到储存设备中。</p>
<p>咱们先来看看如何读取已经打开的文件中的数据，大致的流程如下。</p>
<p>1. 检查 objnode_t 结构中用于存放文件数据的缓冲区及其大小。</p>
<p>2. 检查 imgrhd_t 结构中文件相关的信息。</p>
<p>3. 把文件的数据读取到 objnode_t 结构中指向的缓冲区中。</p>
<p>通过后面的代码，我们把读文件的接口函数跟核心函数一起实现。</p>
<p>//读取文件数据的接口函数<br>
drvstus_t rfs_read_file(device_t* devp,void* iopack)<br>
{<br>
objnode_t* obp = (objnode_t*)iopack;<br>
//检查文件是否已经打开，以及用于存放文件数据的缓冲区和它的大小是否合理<br>
if(obp-&gt;on_finode == NULL || obp-&gt;on_buf == NULL || obp-&gt;on_bufsz != FSYS_ALCBLKSZ) {<br>
return DFCERRSTUS;<br>
}<br>
return rfs_readfileblk(devp, (fimgrhd_t*)obp-&gt;on_finode, obp-&gt;on_buf, obp-&gt;on_len);<br>
}<br>
//实际读取文件数据的函数<br>
drvstus_t rfs_readfileblk(device_t* devp, fimgrhd_t* fmp, void* buf, uint_t len)<br>
{<br>
//检查文件的相关信息是否合理<br>
if(fmp-&gt;fmd_sfblk != fmp-&gt;fmd_curfwritebk || fmp-&gt;fmd_curfwritebk != fmp-&gt;fmd_fleblk[0].fb_blkstart) {<br>
return DFCERRSTUS;<br>
}<br>
//检查读取文件数据的长度是否大于（4096-512）<br>
if(len &gt; (FSYS_ALCBLKSZ - fmp-&gt;fmd_fileifstbkoff)) {<br>
return DFCERRSTUS;<br>
}<br>
//指向文件数据的开始地址<br>
void* wrp = (void*)((uint_t)fmp + fmp-&gt;fmd_fileifstbkoff);<br>
//把文件开始处的数据复制 len 个字节到 buf 指向的缓冲区中<br>
hal_memcpy(wrp, buf, len);<br>
return DFCOKSTUS;<br>
}</p>
<p>上述代码中读取文件数据的函数很简单，关键是要明白前面那个打开文件的函数，因为在那里它已经把文件数据复制到一个缓冲区中了，rfs_readfileblk 函数中的参数 buf、len 都是接口函数 rfs_read_file 从 objnode_t 结构中提取出来的，其它的部分我已经通过注释已经说明了。</p>
<p>好了，我们下面就来实现怎么向文件中写入数据，和读取文件的流程一样，只不过要将要写入的数据复制到打开文件时为其分配的缓冲区中，最后还要把打开文件时为其分配的缓冲区中的数据，写入到相应的逻辑储存块中。</p>
<p>我们还是把写文件的接口函数和核心函数一起实现，代码如下所示。</p>
<p>//写入文件数据的接口函数<br>
drvstus_t rfs_write_file(device_t* devp, void* iopack)<br>
{<br>
objnode_t* obp = (objnode_t*)iopack;<br>
//检查文件是否已经打开，以及用于存放文件数据的缓冲区和它的大小是否合理<br>
if(obp-&gt;on_finode == NULL || obp-&gt;on_buf == NULL || obp-&gt;on_bufsz != FSYS_ALCBLKSZ) {<br>
return DFCERRSTUS;<br>
}<br>
return rfs_writefileblk(devp, (fimgrhd_t*)obp-&gt;on_finode, obp-&gt;on_buf, obp-&gt;on_len);<br>
}<br>
//实际写入文件数据的函数<br>
drvstus_t rfs_writefileblk(device_t* devp, fimgrhd_t* fmp, void* buf, uint_t len)<br>
{<br>
//检查文件的相关信息是否合理<br>
if(fmp-&gt;fmd_sfblk != fmp-&gt;fmd_curfwritebk || fmp-&gt;fmd_curfwritebk != fmp-&gt;fmd_fleblk[0].fb_blkstart) {<br>
return DFCERRSTUS;<br>
}<br>
//检查当前将要写入数据的偏移量加上写入数据的长度，是否大于等于 4KB<br>
if((fmp-&gt;fmd_curfinwbkoff + len) &gt;= FSYS_ALCBLKSZ) {<br>
return DFCERRSTUS;<br>
}<br>
//指向将要写入数据的内存空间<br>
void* wrp = (void*)((uint_t)fmp + fmp-&gt;fmd_curfinwbkoff);<br>
//把 buf 缓冲区中的数据复制 len 个字节到 wrp 指向的内存空间中去<br>
hal_memcpy(buf, wrp, len);<br>
fmp-&gt;fmd_filesz += len;//增加文件大小<br>
//使 fmd_curfinwbkoff 指向下一次将要写入数据的位置<br>
fmp-&gt;fmd_curfinwbkoff += len;<br>
//把文件数据写入到相应的逻辑储存块中，完成数据同步<br>
write_rfsdevblk(devp, (void*)fmp, fmp-&gt;fmd_curfwritebk);<br>
return DFCOKSTUS;<br>
}</p>
<p>上述代码中，你要注意的是，<strong>rfs_writefileblk 函数永远都是从 fimgrhd_t 结构的 fmd_curfinwbkoff 字段中的偏移量开始写入文件数据的</strong>，比如向空文件中写入 2 个字节，那么其 fmd_curfinwbkoff 字段的值就是 2，因为第 0、1 个字节空间已经被占用了，这就是<strong>追加写入数据</strong>的方式。</p>
<p>rfs_writefileblk 函数最后调用 write_rfsdevblk 函数把文件数据写入到相应的逻辑储存块中，完成数据同步。我们发现只要打开文件了，读写文件还是很简单的，最后还要实现关闭文件的操作。</p>
<h3 id="关闭文件">关闭文件</h3>
<p>有打开文件的操作，就需要有关闭文件的操作，因为打开一个文件，会为此分配一个缓冲区，这些都是系统资源，所以需要一个关闭文件的操作来释放这些资源，以防止系统资源泄漏。</p>
<p>关闭文件的流程很简单，首先检查文件是否已经打开。然后把文件写入到对应的逻辑储存块中，完成数据的同步。最后释放文件数据占用的缓冲区。下面我们开始写代码实现，我们依然把接口和核心函数放在一起实现，代码如下所示。</p>
<p>//关闭文件的接口函数<br>
drvstus_t rfs_close_file(device_t* devp, void* iopack)<br>
{<br>
objnode_t* obp = (objnode_t*)iopack;<br>
//检查文件是否已经打开了<br>
if(obp-&gt;on_finode == NULL) {<br>
return DFCERRSTUS;<br>
}<br>
return rfs_closefileblk(devp, obp-&gt;on_finode);<br>
}<br>
//关闭文件的核心函数<br>
drvstus_t rfs_closefileblk(device_t <em>devp, void</em> fblkp)<br>
{<br>
//指向文件的 fimgrhd_t 结构<br>
fimgrhd_t* fmp = (fimgrhd_t*)fblkp;<br>
//完成文件数据的同步<br>
write_rfsdevblk(devp, fblkp, fmp-&gt;fmd_sfblk);<br>
//释放缓冲区<br>
del_buf(fblkp, FSYS_ALCBLKSZ);<br>
return DFCOKSTUS;<br>
}</p>
<p>上述代码是非常简单的，但在目前的情况下，rfs_closefileblk 函数中是没有必要调用 write_rfsdevblk 函数的，因为前面在写入文件数据的同时，就已经把文件的数据写入到逻辑储存块中去了。最后释放了先前打开文件时分配的缓冲区，而 objnode_t 结构不应该在此释放，它是由 Cosmos 内核上层组件进行释放的。</p>
<h2 id="串联整合">串联整合</h2>
<p>到目前为止，我们实现了文件相关的操作，并且提供了接口函数，但是我们的文件系统是以设备的形式存在的，所以文件操作的接口，必须要串联整合到文件系统设备驱动程序之中，文件系统才能真正工作。</p>
<p>下面我们就去整合联串文件系统设备驱动程序。首先来串联整合文件系统的打开文件操作和新建文件操作，代码如下所示。</p>
<p>drvstus_t rfs_open(device_t* devp, void* iopack)<br>
{<br>
objnode_t* obp=(objnode_t*)iopack;<br>
//根据 objnode_t 结构中的访问标志进行判断<br>
if(obp-&gt;on_acsflgs == FSDEV_OPENFLG_OPEFILE) {<br>
return rfs_open_file(devp, iopack);<br>
}<br>
if(obp-&gt;on_acsflgs == FSDEV_OPENFLG_NEWFILE) {<br>
return rfs_new_file(devp, obp-&gt;on_fname, 0);<br>
}<br>
return DFCERRSTUS;<br>
}</p>
<p>上述代码中 rfs_open 函数对应于设备驱动程序的打开功能派发函数，但没有相应的新建功能派发函数，于是我们就根据 objnode_t 结构中访问标志域设置不同的编码，来进行判断。</p>
<p>接着我们来串联整合关闭文件的操作。这次要简单一些，因为设备驱动程序有对应的关闭功能派发函数，直接调用关闭文件操作的接口函数就可以了，代码如下所示。</p>
<p>drvstus_t rfs_close(device_t* devp, void* iopack)<br>
{<br>
return rfs_close_file(devp, iopack);<br>
}</p>
<p>然后是文件读写操作的串联整合，设备驱动程序也有对应的读写功能派发函数，同样也是直接调用文件读写操作的接口函数即可，代码如下所示。</p>
<p>drvstus_t rfs_read(device_t* devp, void* iopack)<br>
{<br>
//调用读文件操作的接口函数<br>
return rfs_read_file(devp, iopack);<br>
}<br>
drvstus_t rfs_write(device_t* devp, void* iopack)<br>
{<br>
//调用写文件操作的接口函数<br>
return rfs_write_file(devp, iopack);<br>
}</p>
<p>最后，来串联整合稍微有点复杂的删除文件操作，这是因为设备驱动程序没有对应的功能派发函数，所以我们需要用到设备驱动程序的控制功能派发函数，代码如下所示。</p>
<p>drvstus_t rfs_ioctrl(device_t* devp, void* iopack)<br>
{<br>
objnode_t* obp = (objnode_t*)iopack;<br>
//根据 objnode_t 结构中的控制码进行判断<br>
if(obp-&gt;on_ioctrd == FSDEV_IOCTRCD_DELFILE)<br>
{<br>
//调用删除文件操作的接口函数<br>
return rfs_del_file(devp, obp-&gt;on_fname, 0);<br>
}<br>
return DFCERRSTUS;<br>
}</p>
<p>上述代码中，我们给文件系统设备分配了一个 FSDEV_IOCTRCD_DELFILE（一个整数）控制码，Cosmos 内核上层组件的代码就可以根据需要，设置 objnode_t 结构中的控制码就能达到相应的目的了。</p>
<p>现在，文件相关的操作已经串联整合好了。</p>
<h2 id="测试">测试</h2>
<p>前面实现了文件系统的 6 种最常用的文件操作，并且已经整合到文件系统设备驱动程序框架代码中去了，可是这些代码究竟对不对，测试运行了才知道。</p>
<p>下面来写好测试代码。要注意的是，Cosmos 下的任何设备驱动程序<strong>都必须要有 objnode_t 结构才能运行</strong>。所以，在这里我们需要手动建立一个 objnode_t 结构并设置好其中的字段，模拟一下 Cosmos 上层组件调用设备驱动程序的过程。</p>
<p>这一过程我们可以写个 test_fsys 函数来实现，代码如下所示。</p>
<p>void test_fsys(device_t *devp)<br>
{<br>
kprint(&ldquo;开始文件操作测试\n&rdquo;);<br>
void *rwbuf = new_buf(FSYS_ALCBLKSZ);//分配缓冲区<br>
//把缓冲区中的所有字节都置为 0xff<br>
hal_memset(rwbuf, 0xff, FSYS_ALCBLKSZ);<br>
objnode_t *ondp = krlnew_objnode();//新建一个 objnode_t 结构<br>
ondp-&gt;on_acsflgs = FSDEV_OPENFLG_NEWFILE;//设置新建文件标志<br>
ondp-&gt;on_fname = &ldquo;/testfile&rdquo;;//设置新建文件名<br>
ondp-&gt;on_buf = rwbuf;//设置缓冲区<br>
ondp-&gt;on_bufsz = FSYS_ALCBLKSZ;//设置缓冲区大小<br>
ondp-&gt;on_len = 512;//设置读写多少字节<br>
ondp-&gt;on_ioctrd = FSDEV_IOCTRCD_DELFILE;//设置控制码<br>
if (rfs_open(devp, ondp) == DFCERRSTUS) {//新建文件<br>
hal_sysdie(&ldquo;新建文件错误&rdquo;);<br>
}<br>
ondp-&gt;on_acsflgs = FSDEV_OPENFLG_OPEFILE;//设置打开文件标志<br>
if (rfs_open(devp, ondp) == DFCERRSTUS) {//打开文件<br>
hal_sysdie(&ldquo;打开文件错误&rdquo;);<br>
}<br>
if (rfs_write(devp, ondp) == DFCERRSTUS) {//把数据写入文件<br>
hal_sysdie(&ldquo;写入文件错误&rdquo;);<br>
}<br>
hal_memset(rwbuf, 0, FSYS_ALCBLKSZ);//清零缓冲区<br>
if (rfs_read(devp, ondp) == DFCERRSTUS) {//读取文件数据<br>
hal_sysdie(&ldquo;读取文件错误&rdquo;);<br>
}<br>
if (rfs_close(devp, ondp) == DFCERRSTUS) {//关闭文件<br>
hal_sysdie(&ldquo;关闭文件错误&rdquo;);<br>
}<br>
u8_t *cb = (u8_t *)rwbuf;//指向缓冲区<br>
for (uint_t i = 0; i &lt; 512; i++) {//检查缓冲区空间中的头 512 个字节的数据，是否为 0xff<br>
if (cb[i] != 0xff) {//如果不等于 0xff 就死机<br>
hal_sysdie(&ldquo;检查文件内容错误&rdquo;);<br>
}<br>
kprint(&ldquo;testfile 文件第 [%x] 个字节数据:%x\n&rdquo;, i, (uint_t)cb[i]);//打印文件内容<br>
}<br>
if (rfs_ioctrl(devp, ondp) == DFCERRSTUS){//删除文件<br>
hal_sysdie(&ldquo;删除文件错误&rdquo;);<br>
}<br>
ondp-&gt;on_acsflgs = FSDEV_OPENFLG_OPEFILE;//再次设置打开文件标志<br>
if (rfs_open(devp, ondp) == DFCERRSTUS) {//再次打开文件<br>
hal_sysdie(&ldquo;再次打开文件失败&rdquo;);<br>
}<br>
hal_sysdie(&ldquo;结束文件操作测试&rdquo;);<br>
return;<br>
}</p>
<p>上述代码虽然有点长，因为我们一下子测试了关于文件的 6 大操作。每个文件操作失败后都会死机，不会继续向下运行。</p>
<p>测试逻辑很简单：开始会建立并打开一个文件，接着写入数据，然后读取文件中数据进行比较，看看是不是和之前写入的数据相等，最后删除这个文件并再次打开，看是否会出错。因为文件已经删除了，打开一个已经删除的文件自然要出错，出错就说明测试成功。</p>
<p>现在我们把 test_fsys 函数放在 rfs_entry 函数的最后调用，然后打开终端切换到 cosmos 目录下执行 make vboxtest 命令，最后不出意外的话，你会看到如下图所示的情况。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/e7f04cc4ce42c2283a90817cee2abfad.png" alt=""></p>
<p>文件操作测试示意图</p>
<p>从图里我们能看到，文件中的数据和最后重新打开已经删除文件时出现的错误，这说明了我们的代码是正确无误的。</p>
<p>至此，测试了文件相关的 6 大操作的代码，代码质量都是相当高的，都达到了我们的预期，一个简单、有诸多限制但却五脏俱全的文件系统就实现了。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>这节课告一段落，恭喜你坚持到这里。</p>
<p>文件系统虽然复杂，但我们发现只要做得足够“小”，就能大大降低了实现的难度。虽然降低了实现的难度，但我们的 rfs 文件系统依然包含了一个正常文件系统所具有的功能特性，现在我来为你梳理一下本节课的重点：</p>
<p>1. 首先是文件系统的辅助操作，因为文件系统的复杂性，所以必须要实现一些如获取与释放根目录文件、获取文件名、判断文件是否存在等基础辅助操作函数。</p>
<p>2. 然后实现了文件系统必须要提供的 6 大文件操作：<strong>新建文件、删除文件、打开文件、读写文件、关闭文件</strong>。</p>
<ol>
<li>最后把这些文件操作全部串联整合到文件系统设备驱动程序之中，并且进行了测试，确认代码正确无误。</li>
</ol>
<p>今天这节课，我们又实现了 Cosmos 内核的一个基础组件，即文件系统，不过它是以<strong>设备的形式</strong>存在的，这样做是为了方便以后的扩展和移植。</p>
<p>现在文件系统是实现了，不过还不够完善。你可能在想，我们文件系统在内存中，一断电数据就全完了。是的，不过你可以尝试写好硬盘驱动，然后把内存中的逻辑储存块写入到硬盘中就行了，期待你的实现。</p>
<h2 id="思考题">思考题</h2>
<p>请你想一想，我们这个简单的、小的，却五脏俱全的文件系统有哪些限制？</p>
<p>欢迎你在留言区记录你的收获或疑问，也鼓励你边学边练，多多动手实践。同时我推荐你把这节课分享给身边的朋友，跟他一起学习进步。</p>
<p>好，我是 LMOS，我们下节课见。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/">操作系统实战45讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98%E8%AF%BE/34_%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E4%BA%8C%E5%A6%82%E4%BD%95%E4%BB%8E%E8%AF%AD%E8%A8%80%E5%B1%82%E9%9D%A2%E6%94%AF%E6%8C%81%E5%8D%8F%E7%A8%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">34_并发中的编译技术（二）：如何从语言层面支持协程？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/34_%E6%99%8B%E5%8D%87%E8%AF%84%E5%AE%9A%E4%B8%8E%E5%8D%9A%E5%BC%88/">
            <span class="next-text nav-default">34_晋升：评定与博弈</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
