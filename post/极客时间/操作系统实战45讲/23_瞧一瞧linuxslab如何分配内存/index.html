<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>23_瞧一瞧Linux：SLAB如何分配内存？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是 LMOS。
上节课我们学习了伙伴系统，了解了它是怎样管理物理内存页面的。那么你自然会想到这个问题：Linux 系统中，比页更小的内存对象要怎样分配呢？
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/23_%E7%9E%A7%E4%B8%80%E7%9E%A7linuxslab%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/23_%E7%9E%A7%E4%B8%80%E7%9E%A7linuxslab%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="23_瞧一瞧Linux：SLAB如何分配内存？">
  <meta property="og:description" content="你好，我是 LMOS。
上节课我们学习了伙伴系统，了解了它是怎样管理物理内存页面的。那么你自然会想到这个问题：Linux 系统中，比页更小的内存对象要怎样分配呢？">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="操作系统实战45讲">

  <meta itemprop="name" content="23_瞧一瞧Linux：SLAB如何分配内存？">
  <meta itemprop="description" content="你好，我是 LMOS。
上节课我们学习了伙伴系统，了解了它是怎样管理物理内存页面的。那么你自然会想到这个问题：Linux 系统中，比页更小的内存对象要怎样分配呢？">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4840">
  <meta itemprop="keywords" content="操作系统实战45讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="23_瞧一瞧Linux：SLAB如何分配内存？">
  <meta name="twitter:description" content="你好，我是 LMOS。
上节课我们学习了伙伴系统，了解了它是怎样管理物理内存页面的。那么你自然会想到这个问题：Linux 系统中，比页更小的内存对象要怎样分配呢？">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">23_瞧一瞧Linux：SLAB如何分配内存？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4840 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#slab">SLAB</a>
          <ul>
            <li><a href="#走进-slab-对象">走进 SLAB 对象</a></li>
            <li><a href="#第一个-kmem_cache">第一个 kmem_cache</a></li>
            <li><a href="#管理-kmem_cache">管理 kmem_cache</a></li>
          </ul>
        </li>
        <li><a href="#slab-分配对象的过程">SLAB 分配对象的过程</a>
          <ul>
            <li><a href="#slab-分配接口">SLAB 分配接口</a></li>
            <li><a href="#如何查找-kmem_cache-结构">如何查找 kmem_cache 结构</a></li>
            <li><a href="#分配对象">分配对象</a></li>
          </ul>
        </li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是 LMOS。</p>
<p>上节课我们学习了伙伴系统，了解了它是怎样管理物理内存页面的。那么你自然会想到这个问题：Linux 系统中，比页更小的内存对象要怎样分配呢？</p>
<p>带着这个问题，我们来一起看看 **SLAB 分配器的原理和实现。**在学习过程中，你也可以对照一下我们 Cosmos 的内存管理组件，看看两者的内存管理有哪些异同。</p>
<h2 id="slab">SLAB</h2>
<p>与 Cosmos 物理内存页面管理器一样，Linux 中的伙伴系统是以页面为最小单位分配的，现实更多要以内核对象为单位分配内存，其实更具体一点说，就是根据内核对象的实例变量大小来申请和释放内存空间，这些数据结构实例变量的大小通常从几十字节到几百字节不等，远远小于一个页面的大小。</p>
<p>如果一个几十字节大小的数据结构实例变量，就要为此分配一个页面，这无疑是对宝贵物理内存的一种巨大浪费，因此一个更好的技术方案应运而生，就是 <strong>Slab 分配器</strong>（由 Sun 公司的雇员 Jeff Bonwick 在 Solaris 2.4 中设计并实现）。</p>
<p>由于作者公开了实现方法，后来被 Linux 所借鉴，用于实现内核中更小粒度的内存分配。看看吧，你以为 Linux 很强大，真的强大吗？不过是站在巨人的肩膀上飞翔的。</p>
<h3 id="走进-slab-对象">走进 SLAB 对象</h3>
<p>何为 SLAB 对象？在 SLAB 分配器中，它把一个内存页面或者一组连续的内存页面，划分成大小相同的块，其中这一个小的内存块就是 SLAB 对象，但是这一组连续的内存页面中不只是 SLAB 对象，还有 SLAB 管理头和着色区。</p>
<p>我画个图你就明白了，如下所示。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/5a31ffabf1f035ee23a6a05933336e35.png" alt=""></p>
<p>SLAB 对象示意图</p>
<p>上图中有一个内存页面和两个内存页面的 SLAB，你可能对着色区有点陌生，我来给你讲解一下。</p>
<p>这个着色区也是一块动态的内存块，建立 SLAB 时才会设置它的大小，目的是为了错开不同 SLAB 中的对象地址，降低硬件 Cache 行中的地址争用，以免导致 Cache 抖动效应，整个系统性能下降。</p>
<p>SLAB 头其实是一个数据结构，但是它不一定放在保存对象内存页面的开始。通常会有一个保存 SLAB 管理头的 SLAB，在 Linux 中，SLAB 管理头用 kmem_cache 结构来表示，代码如下。</p>
<p>struct array_cache {<br>
unsigned int avail;<br>
unsigned int limit;<br>
void *entry[];<br>
};<br>
struct kmem_cache {<br>
//是每个 CPU 一个 array_cache 类型的变量，cpu_cache 是用于管理空闲对象的<br>
struct array_cache __percpu *cpu_cache;<br>
unsigned int size; //cache 大小<br>
slab_flags_t flags;//slab 标志<br>
unsigned int num;//对象个数<br>
unsigned int gfporder;//分配内存页面的 order<br>
gfp_t allocflags;<br>
size_t colour;//着色区大小<br>
unsigned int colour_off;//着色区的开始偏移<br>
const char *name;//本 SLAB 的名字<br>
struct list_head list;//所有的 SLAB 都要链接起来<br>
int refcount;//引用计数<br>
int object_size;//对象大小<br>
int align;//对齐大小<br>
struct kmem_cache_node *node[MAX_NUMNODES];//指向管理 kmemcache 的上层结构<br>
};</p>
<p>上述代码中，有多少个 CPU，就会有多少个 array_cache 类型的变量。这种为每个 CPU 构造一个变量副本的同步机制，就是<strong>每 CPU 变量</strong>（per-cpu-variable）。array_cache 结构中&quot;entry[]&ldquo;表示了一个遵循 LIFO 顺序的数组，&ldquo;avail&quot;和&quot;limit&quot;分别指定了当前可用对象的数目和允许容纳对象的最大数目。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/612382cdb8c1474a1720fbce845259ed.png" alt=""></p>
<p>kmem_cache 结构图解</p>
<h3 id="第一个-kmem_cache">第一个 kmem_cache</h3>
<p>第一个 kmem_cache 是哪里来的呢？其实它是静态定义在代码中的，如下所示。</p>
<p>static struct kmem_cache kmem_cache_boot = {<br>
.batchcount = 1,<br>
.limit = BOOT_CPUCACHE_ENTRIES,<br>
.shared = 1,<br>
.size = sizeof(struct kmem_cache),<br>
.name = &ldquo;kmem_cache&rdquo;,<br>
};</p>
<p>void __init kmem_cache_init(void)<br>
{<br>
int i;<br>
//指向静态定义的 kmem_cache_boot<br>
kmem_cache = &amp;kmem_cache_boot;</p>
<pre><code>for (i = 0; i &lt; NUM_INIT_LISTS; i++)  
    kmem_cache_node_init(&amp;init_kmem_cache_node[i]);  
//建立保存 kmem_cache 结构的 kmem_cache  
create_boot_cache(kmem_cache, &quot;kmem_cache&quot;,  
    offsetof(struct kmem_cache, node) +  
              nr_node_ids * sizeof(struct kmem_cache_node *),  
              SLAB_HWCACHE_ALIGN, 0, 0);  
//加入全局 slab_caches 链表中  
list_add(&amp;kmem_cache-&gt;list, &amp;slab_caches);  
{  
    int nid;  
    for_each_online_node(nid) {  
        init_list(kmem_cache, &amp;init_kmem_cache_node[CACHE_CACHE + nid], nid);  
        init_list(kmalloc_caches[KMALLOC_NORMAL][INDEX_NODE],                      &amp;init_kmem_cache_node[SIZE_NODE + nid], nid);  
    }  
}  
//建立 kmalloc 函数使用的的 kmem_cache  
create_kmalloc_caches(ARCH_KMALLOC_FLAGS);  
</code></pre>
<p>}</p>
<h3 id="管理-kmem_cache">管理 kmem_cache</h3>
<p>我们建好了第一个 kmem_cache，以后 kmem_cache 越来越多，而且我们并没有看到 kmem_cache 结构中有任何指向内存页面的字段，但在 kmem_cache 结构中有个保存 kmem_cache_node 结构的指针数组。</p>
<p>kmem_cache_node 结构是每个内存节点对应一个，它就是用来管理 kmem_cache 结构的，它开始是静态定义的，初始化时建立了第一个 kmem_cache 结构之后，init_list 函数负责一个个分配内存空间，代码如下所示。</p>
<p>#define NUM_INIT_LISTS (2 * MAX_NUMNODES)<br>
//定义的 kmem_cache_node 结构数组<br>
static struct kmem_cache_node __initdata init_kmem_cache_node[NUM_INIT_LISTS];</p>
<p>struct kmem_cache_node {<br>
spinlock_t list_lock;//自旋锁<br>
struct list_head slabs_partial;//有一部分空闲对象的 kmem_cache 结构<br>
struct list_head slabs_full;//没有空闲对象的 kmem_cache 结构<br>
struct list_head slabs_free;//对象全部空闲 kmem_cache 结构<br>
unsigned long total_slabs; //一共多少 kmem_cache 结构<br>
unsigned long free_slabs;  //空闲的 kmem_cache 结构<br>
unsigned long free_objects;//空闲的对象<br>
unsigned int free_limit;<br>
};<br>
static void __init init_list(struct kmem_cache *cachep, struct kmem_cache_node *list,<br>
int nodeid)<br>
{<br>
struct kmem_cache_node *ptr;<br>
//分配新的 kmem_cache_node 结构的空间<br>
ptr = kmalloc_node(sizeof(struct kmem_cache_node), GFP_NOWAIT, nodeid);<br>
BUG_ON(!ptr);<br>
//复制初始时的静态 kmem_cache_node 结构<br>
memcpy(ptr, list, sizeof(struct kmem_cache_node));<br>
spin_lock_init(&amp;ptr-&gt;list_lock);<br>
MAKE_ALL_LISTS(cachep, ptr, nodeid);<br>
//设置 kmem_cache_node 的地址<br>
cachep-&gt;node[nodeid] = ptr;<br>
}</p>
<p>我们第一次分配对象时，肯定没有对应的内存页面存放对象，那么 SLAB 模块就会调用 <strong>cache_grow_begin 函数</strong>获取内存页面，然后用获取的页面来存放对象，我们一起来看看代码。</p>
<p>static void slab_map_pages(struct kmem_cache *cache, struct page *page,void *freelist)<br>
{<br>
//页面结构指向 kmem_cache 结构<br>
page-&gt;slab_cache = cache;<br>
//指向空闲对象的链表<br>
page-&gt;freelist = freelist;<br>
}<br>
static struct page *cache_grow_begin(struct kmem_cache *cachep,<br>
gfp_t flags, int nodeid)<br>
{<br>
void *freelist;<br>
size_t offset;<br>
gfp_t local_flags;<br>
int page_node;<br>
struct kmem_cache_node *n;<br>
struct page *page;</p>
<pre><code>WARN_ON_ONCE(cachep-&gt;ctor &amp;&amp; (flags &amp; __GFP_ZERO));  
local_flags = flags &amp; (GFP_CONSTRAINT_MASK|GFP_RECLAIM_MASK);  
//获取页面  
page = kmem_getpages(cachep, local_flags, nodeid);  
//获取页面所在的内存节点号  
page_node = page_to_nid(page);  
//根据内存节点获取对应 kmem_cache_node 结构  
n = get_node(cachep, page_node);  
//分配管理空闲对象的数据结构  
freelist = alloc_slabmgmt(cachep, page, offset,  
        local_flags &amp; ~GFP_CONSTRAINT_MASK, page_node);  
//让页面中相关的字段指向 kmem_cache 和空闲对象  
slab_map_pages(cachep, page, freelist);  
//初始化空闲对象管理数据  
cache_init_objs(cachep, page);  
return page;  
</code></pre>
<p>}</p>
<p>static void cache_grow_end(struct kmem_cache *cachep, struct page *page)<br>
{<br>
struct kmem_cache_node *n;<br>
void *list = NULL;<br>
if (!page)<br>
return;<br>
//初始化结 page 构的 slab_list 链表<br>
INIT_LIST_HEAD(&amp;page-&gt;slab_list);<br>
//根据内存节点获取对应 kmem_cache_node 结构.<br>
n = get_node(cachep, page_to_nid(page));<br>
spin_lock(&amp;n-&gt;list_lock);<br>
//slab 计数增加<br>
n-&gt;total_slabs++;<br>
if (!page-&gt;active) {<br>
//把这个 page 结构加入到 kmem_cache_node 结构的空闲链表中<br>
list_add_tail(&amp;page-&gt;slab_list, &amp;n-&gt;slabs_free);<br>
n-&gt;free_slabs++;<br>
}<br>
spin_unlock(&amp;n-&gt;list_lock);<br>
}</p>
<p>上述代码中的注释已经很清楚了，cache_grow_begin 函数会为 kmem_cache 结构分配用来存放对象的页面，随后会调用与之对应的 cache_grow_end 函数，把这页面挂载到 kmem_cache_node 结构的链表中，并让页面指向 kmem_cache 结构。</p>
<p>这样 kmem_cache_node，kmem_cache，page 这三者之间就联系起来了。你再看一下后面的图，就更加清楚了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/ce2a15270b0c008001f2d9f2a33b5e58.png" alt=""></p>
<p>SLAB 全局结构示意图</p>
<p>上图中 page 可能是一组连续的 pages，但是只会把第一个 page 挂载到 kmem_cache_node 中，同时，在 slab_map_pages 函数中又让 page 指向了 kmem_cache。</p>
<p>但你要特别留意 kmem_cache_node 中的三个链表，它们分别挂载的 pages，有一部分是空闲对象的 page、还有对象全部都已经分配的 page，以及全部都为空闲对象的 page。这是为了提高分配时查找 kmem_cache 的性能。</p>
<h2 id="slab-分配对象的过程">SLAB 分配对象的过程</h2>
<p>有了前面对 SLAB 数据结构的了解，SLAB 分配对象的过程你自己也能推导出来，无非是根据请求分配对象的大小，查找对应的 kmem_cache 结构，接着从这个结构中获取 arry_cache 结构，然后分配对象。</p>
<p>如果没有空闲对象了，就需要在 kmem_cache 对应的 kmem_cache_node 结构中查找有空闲对象的 kmem_cache。如果还是没找到，最后就要分配内存页面新增 kmem_cache 结构了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/ac0cddaca111f8ee9d6f347696028575.png" alt=""></p>
<p>SLAB 分配对象的过程图解</p>
<p>下面我们从接口开始了解这些过程。</p>
<h3 id="slab-分配接口">SLAB 分配接口</h3>
<p>其实在 Linux 内核中，用的最多的是 kmalloc 函数，经常用于分配小的缓冲区，或者数据结构分配实例空间，这个函数就是 SLAB 分配接口，它是用来分配对象的，这个对象就是一小块内存空间。</p>
<p>下面一起来看看代码。</p>
<p>static __always_inline void *__do_kmalloc(size_t size, gfp_t flags,unsigned long caller)<br>
{<br>
struct kmem_cache *cachep;<br>
void *ret;<br>
if (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE))<br>
return NULL;<br>
//查找 size 对应的 kmem_cache<br>
cachep = kmalloc_slab(size, flags);<br>
if (unlikely(ZERO_OR_NULL_PTR(cachep)))<br>
return cachep;<br>
//分配对象<br>
ret = slab_alloc(cachep, flags, caller);<br>
return ret;<br>
}</p>
<p>void *__kmalloc(size_t size, gfp_t flags)<br>
{<br>
return __do_kmalloc(size, flags, <em>RET_IP</em>);<br>
}<br>
static __always_inline void *kmalloc(size_t size, gfp_t flags)<br>
{<br>
return __kmalloc(size, flags);<br>
}</p>
<p>上面代码的流程很简单，就是在 __do_kmalloc 函数中，查找出分配大小对应的 kmem_cache 结构，然后调用 slab_alloc 函数进行分配。可以说，slab_alloc 函数才是 SLAB 的接口函数，但是它的参数中<strong>必须要有 kmem_cache 结构</strong>。</p>
<p>具体是如何查找的呢？我们这就来看看。</p>
<h3 id="如何查找-kmem_cache-结构">如何查找 kmem_cache 结构</h3>
<p>由于 SLAB 的接口函数 slab_alloc，它的参数中必须要有 kmem_cache 结构指针，指定从哪个 kmem_cache 结构分配对象，所以在调用 slab_alloc 函数之前必须给出 kmem_cache 结构。</p>
<p>我们怎么查找到它呢？这就需要调用 kmalloc_slab 函数了，代码如下所示。</p>
<p>enum kmalloc_cache_type {<br>
KMALLOC_NORMAL = 0,<br>
KMALLOC_RECLAIM,<br>
#ifdef CONFIG_ZONE_DMA<br>
KMALLOC_DMA,<br>
#endif<br>
NR_KMALLOC_TYPES<br>
};<br>
struct kmem_cache <em>kmalloc_caches[NR_KMALLOC_TYPES][KMALLOC_SHIFT_HIGH + 1] __ro_after_init ={ static u8 size_index[24] __ro_after_init = {<br>
3,  /</em> 8 <em>/<br>
4,  /</em> 16 <em>/<br>
5,  /</em> 24 <em>/<br>
5,  /</em> 32 <em>/<br>
6,  /</em> 40 <em>/<br>
6,  /</em> 48 <em>/<br>
6,  /</em> 56 <em>/<br>
6,  /</em> 64 <em>/<br>
1,  /</em> 72 <em>/<br>
1,  /</em> 80 <em>/<br>
1,  /</em> 88 <em>/<br>
1,  /</em> 96 <em>/<br>
7,  /</em> 104 <em>/<br>
7,  /</em> 112 <em>/<br>
7,  /</em> 120 <em>/<br>
7,  /</em> 128 <em>/<br>
2,  /</em> 136 <em>/<br>
2,  /</em> 144 <em>/<br>
2,  /</em> 152 <em>/<br>
2,  /</em> 160 <em>/<br>
2,  /</em> 168 <em>/<br>
2,  /</em> 176 <em>/<br>
2,  /</em> 184 <em>/<br>
2   /</em> 192 */<br>
};<br>
//根据分配标志返回枚举类型，其实是 0、1、2 其中之一<br>
static __always_inline enum kmalloc_cache_type kmalloc_type(gfp_t flags)<br>
{<br>
#ifdef CONFIG_ZONE_DMA<br>
if (likely((flags &amp; (__GFP_DMA | __GFP_RECLAIMABLE)) == 0))<br>
return KMALLOC_NORMAL;<br>
return flags &amp; __GFP_DMA ? KMALLOC_DMA : KMALLOC_RECLAIM;<br>
#else<br>
return flags &amp; __GFP_RECLAIMABLE ? KMALLOC_RECLAIM : KMALLOC_NORMAL;<br>
#endif<br>
}<br>
struct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)<br>
{<br>
unsigned int index;<br>
//计算出 index<br>
if (size &lt;= 192) {<br>
if (!size)<br>
return ZERO_SIZE_PTR;<br>
index = size_index[size_index_elem(size)];<br>
} else {<br>
if (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))<br>
return NULL;<br>
index = fls(size - 1);<br>
}<br>
return kmalloc_caches[kmalloc_type(flags)][index];<br>
}</p>
<p>从上述代码，不难发现 kmalloc_caches 就是个全局的二维数组，kmalloc_slab 函数只是根据分配大小和分配标志计算出了数组下标，最后取出其中 kmem_cache 结构指针。</p>
<p>那么 kmalloc_caches 中的 kmem_cache，它又是谁建立的呢？我们还是接着看代码。</p>
<p>struct kmem_cache *__init create_kmalloc_cache(const char *name,<br>
unsigned int size, slab_flags_t flags,<br>
unsigned int useroffset, unsigned int usersize)<br>
{<br>
//从第一个 kmem_cache 中分配一个对象放 kmem_cache<br>
struct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);</p>
<pre><code>if (!s)  
    panic(&quot;Out of memory when creating slab %s\n&quot;, name);  
//设置 s 的对齐参数，处理 s 的 freelist 就是 arr_cache  
create_boot_cache(s, name, size, flags, useroffset, usersize);  
list_add(&amp;s-&gt;list, &amp;slab_caches);  
s-&gt;refcount = 1;  
return s;  
</code></pre>
<p>}<br>
//新建一个 kmem_cache<br>
static void __init new_kmalloc_cache(int idx, enum kmalloc_cache_type type, slab_flags_t flags)<br>
{<br>
if (type == KMALLOC_RECLAIM)<br>
flags |= SLAB_RECLAIM_ACCOUNT;<br>
//根据 kmalloc_info 中信息建立一个 kmem_cache<br>
kmalloc_caches[type][idx] = create_kmalloc_cache(<br>
kmalloc_info[idx].name[type],<br>
kmalloc_info[idx].size, flags, 0,<br>
kmalloc_info[idx].size);<br>
}<br>
//建立所有的 kmalloc_caches 中的 kmem_cache<br>
void __init create_kmalloc_caches(slab_flags_t flags)<br>
{<br>
int i;<br>
enum kmalloc_cache_type type;<br>
for (type = KMALLOC_NORMAL; type &lt;= KMALLOC_RECLAIM; type++) {<br>
for (i = KMALLOC_SHIFT_LOW; i &lt;= KMALLOC_SHIFT_HIGH; i++) {<br>
if (!kmalloc_caches[type][i])<br>
//建立一个新的 kmem_cache<br>
new_kmalloc_cache(i, type, flags);<br>
if (KMALLOC_MIN_SIZE &lt;= 32 &amp;&amp; i == 6 &amp;&amp;<br>
!kmalloc_caches[type][1])<br>
new_kmalloc_cache(1, type, flags);<br>
if (KMALLOC_MIN_SIZE &lt;= 64 &amp;&amp; i == 7 &amp;&amp;<br>
!kmalloc_caches[type][2])<br>
new_kmalloc_cache(2, type, flags);<br>
}<br>
}<br>
}</p>
<p>到这里，__do_kmalloc 函数中根据分配对象大小查找的所有 kmem_cache 结构，我们就建立好了，保存在 kmalloc_caches 数组中。下面我们再去看看对象是如何分配的。</p>
<h3 id="分配对象">分配对象</h3>
<p>下面我们从 slab_alloc 函数开始探索对象的分配过程，slab_alloc 函数的第一个参数就 kmem_cache 结构的指针，表示从该 kmem_cache 结构中分配对象。</p>
<p>static __always_inline void *slab_alloc(struct kmem_cache *cachep, gfp_t flags, unsigned long caller)<br>
{<br>
unsigned long save_flags;<br>
void *objp;<br>
//关中断<br>
local_irq_save(save_flags);<br>
//分配对象<br>
objp = __do_cache_alloc(cachep, flags);<br>
//恢复中断<br>
local_irq_restore(save_flags);<br>
return objp;<br>
}</p>
<p>接口函数总是简单的，真正干活的是 __do_cache_alloc 函数，下面我们就来看看这个函数。</p>
<p>static inline void *____cache_alloc(struct kmem_cache *cachep, gfp_t flags)<br>
{<br>
void *objp;<br>
struct array_cache *ac;<br>
//获取当前 cpu 在 cachep 结构中的 array_cache 结构的指针<br>
ac = cpu_cache_get(cachep);<br>
//如果 ac 中的 avail 不为 0，说明当前 kmem_cache 结构中 freelist 是有空闲对象<br>
if (likely(ac-&gt;avail)) {<br>
ac-&gt;touched = 1;<br>
//空间对象的地址保存在 ac-&gt;entry<br>
objp = ac-&gt;entry[&ndash;ac-&gt;avail];<br>
goto out;<br>
}<br>
objp = cache_alloc_refill(cachep, flags);<br>
out:<br>
return objp;<br>
}<br>
static __always_inline void *__do_cache_alloc(struct kmem_cache *cachep, gfp_t flags)<br>
{<br>
return ____cache_alloc(cachep, flags);<br>
}</p>
<p>上述代码中真正做事的函数是 <strong>____cache_alloc 函数</strong>，它首先获取了当前 kmem_cache 结构中指向 array_cache 结构的指针，找到它里面空闲对象的地址（如果你不懂 array_cache 结构，请回到 SLAB 对象那一小节复习），然后在 array_cache 结构中取出一个空闲对象地址返回，这样就分配成功了。</p>
<p>这个速度是很快的，如果 array_cache 结构中没有空闲对象了，就会调用 cache_alloc_refill 函数。那这个函数又干了什么呢？我们接着往下看。代码如下所示。</p>
<p>static struct page *get_first_slab(struct kmem_cache_node *n, bool pfmemalloc)<br>
{<br>
struct page *page;<br>
assert_spin_locked(&amp;n-&gt;list_lock);<br>
//首先从 kmem_cache_node 结构中的 slabs_partial 链表上查看有没有 page<br>
page = list_first_entry_or_null(&amp;n-&gt;slabs_partial, struct page,slab_list);<br>
if (!page) {<br>
//如果没有<br>
n-&gt;free_touched = 1;<br>
//从 kmem_cache_node 结构中的 slabs_free 链表上查看有没有 page<br>
page = list_first_entry_or_null(&amp;n-&gt;slabs_free, struct page,slab_list);<br>
if (page)<br>
n-&gt;free_slabs&ndash;; //空闲 slab 计数减一<br>
}<br>
//返回 page<br>
return page;<br>
}<br>
static void *cache_alloc_refill(struct kmem_cache *cachep, gfp_t flags)<br>
{<br>
int batchcount;<br>
struct kmem_cache_node *n;<br>
struct array_cache *ac, *shared;<br>
int node;<br>
void *list = NULL;<br>
struct page *page;<br>
//获取内存节点<br>
node = numa_mem_id();<br>
ac = cpu_cache_get(cachep);<br>
batchcount = ac-&gt;batchcount;<br>
//获取 cachep 所属的 kmem_cache_node<br>
n = get_node(cachep, node);<br>
shared = READ_ONCE(n-&gt;shared);<br>
if (!n-&gt;free_objects &amp;&amp; (!shared || !shared-&gt;avail))<br>
goto direct_grow;<br>
while (batchcount &gt; 0) {<br>
//获取 kmem_cache_node 结构中其它 kmem_cache，返回的是 page，而 page 会指向 kmem_cache<br>
page = get_first_slab(n, false);<br>
if (!page)<br>
goto must_grow;<br>
batchcount = alloc_block(cachep, ac, page, batchcount);<br>
}<br>
must_grow:<br>
n-&gt;free_objects -= ac-&gt;avail;<br>
direct_grow:<br>
if (unlikely(!ac-&gt;avail)) {<br>
//分配新的 kmem_cache 并初始化<br>
page = cache_grow_begin(cachep, gfp_exact_node(flags), node);<br>
ac = cpu_cache_get(cachep);<br>
if (!ac-&gt;avail &amp;&amp; page)<br>
alloc_block(cachep, ac, page, batchcount);<br>
//让 page 挂载到 kmem_cache_node 结构的 slabs_list 链表上<br>
cache_grow_end(cachep, page);<br>
if (!ac-&gt;avail)<br>
return NULL;<br>
}<br>
ac-&gt;touched = 1;<br>
//重新分配<br>
return ac-&gt;entry[&ndash;ac-&gt;avail];<br>
}</p>
<p>调用 cache_alloc_refill 函数的过程，主要的工作都有哪些呢？我给你梳理一下。</p>
<p>首先，获取了 cachep 所属的 kmem_cache_node。</p>
<p>然后调用 get_first_slab，获取 kmem_cache_node 结构还有没有包含空闲对象的 kmem_cache。但是请注意，这里返回的是 page，因为 page 会指向 kmem_cache 结构，page 所代表的物理内存页面，也保存着 kmem_cache 结构中的对象。</p>
<p>最后，如果 kmem_cache_node 结构没有包含空闲对象的 kmem_cache 了，就必须调用 cache_grow_begin 函数，找伙伴系统分配新的内存页面，而且还要找第一个 kmem_cache 分配新的对象，来存放 kmem_cache 结构的实例变量，并进行必要的初始化。</p>
<p>这些步骤完成之后，再调用 cache_grow_end 函数，把刚刚分配的 page 挂载到 kmem_cache_node 结构的 slabs_list 链表上。因为 cache_grow_begin 和 cache_grow_end 函数在前面已经分析过了，这里不再赘述。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>今天的内容讲完了，我来帮你梳理一下本课程的重点。</p>
<p>1. 为了分配小于 1 个 page 的小块内存，Linux 实现了 SLAB，用 kmem_cache 结构管理 page 对应内存页面上小块内存对象，然后让该 page 指向 kmem_cache，由 kmem_cache_node 结构管理多个 page。</p>
<p>2. 我们从 Linux 内核中使用的 kmalloc 函数入手，了解了 SLAB 下整个内存对象的分配过程。</p>
<p>到此为止，我们对 SLAB 的研究就告一段落了，是不是感觉和 Cosmos 内存管理有些相像而又不同呢？甚至我们 Cosmos 内存管理要更为简洁和高效。</p>
<h2 id="思考题">思考题</h2>
<p>Linux 的 SLAB，使用 kmalloc 函数能分配多大的内存对象呢？</p>
<p>欢迎你在留言区跟我交流互动，也欢迎你把这节课分享给你的同事、朋友，跟他一起研究 SLAB 相关的内容。</p>
<p>我是 LMOS，我们下节课见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/">操作系统实战45讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%88%90%E4%B8%BAai%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/23_%E6%A8%A1%E5%9E%8B%E7%9B%91%E6%8E%A7%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E5%A6%82%E4%BD%95%E5%BB%BA%E8%AE%BE%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">23_模型监控：产品经理如何建设算法模型监控指标体系？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1/23_%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%B9%B3%E5%8F%B0/">
            <span class="next-text nav-default">23_如何搭建微服务治理平台？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
