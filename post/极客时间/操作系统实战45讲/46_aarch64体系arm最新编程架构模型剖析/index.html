<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>46_AArch64体系：ARM最新编程架构模型剖析 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是 LMOS。
在今天，Andriod&#43;ARM 已经成了移动领域的霸主，这与当年的 Windows&#43;Intel 何其相似。之前我们已经在 Intel 的 x86 CPU 上实现了 Cosmos，今天我会给你讲讲 ARM 的 AArch64 体系结构，带你扩展一下视野。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/46_aarch64%E4%BD%93%E7%B3%BBarm%E6%9C%80%E6%96%B0%E7%BC%96%E7%A8%8B%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/46_aarch64%E4%BD%93%E7%B3%BBarm%E6%9C%80%E6%96%B0%E7%BC%96%E7%A8%8B%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B%E5%89%96%E6%9E%90/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="46_AArch64体系：ARM最新编程架构模型剖析">
  <meta property="og:description" content="你好，我是 LMOS。
在今天，Andriod&#43;ARM 已经成了移动领域的霸主，这与当年的 Windows&#43;Intel 何其相似。之前我们已经在 Intel 的 x86 CPU 上实现了 Cosmos，今天我会给你讲讲 ARM 的 AArch64 体系结构，带你扩展一下视野。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="操作系统实战45讲">

  <meta itemprop="name" content="46_AArch64体系：ARM最新编程架构模型剖析">
  <meta itemprop="description" content="你好，我是 LMOS。
在今天，Andriod&#43;ARM 已经成了移动领域的霸主，这与当年的 Windows&#43;Intel 何其相似。之前我们已经在 Intel 的 x86 CPU 上实现了 Cosmos，今天我会给你讲讲 ARM 的 AArch64 体系结构，带你扩展一下视野。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7599">
  <meta itemprop="keywords" content="操作系统实战45讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="46_AArch64体系：ARM最新编程架构模型剖析">
  <meta name="twitter:description" content="你好，我是 LMOS。
在今天，Andriod&#43;ARM 已经成了移动领域的霸主，这与当年的 Windows&#43;Intel 何其相似。之前我们已经在 Intel 的 x86 CPU 上实现了 Cosmos，今天我会给你讲讲 ARM 的 AArch64 体系结构，带你扩展一下视野。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">46_AArch64体系：ARM最新编程架构模型剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7599 字 </span>
          <span class="more-meta"> 预计阅读 16 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#什么是-aarch64-体系">什么是 AArch64 体系</a></li>
        <li><a href="#aarch64-体系的寄存器">AArch64 体系的寄存器</a>
          <ul>
            <li><a href="#通用寄存器-r0-r30">通用寄存器 R0-R30</a></li>
            <li><a href="#特殊寄存器">特殊寄存器</a></li>
            <li><a href="#系统寄存器">系统寄存器</a></li>
          </ul>
        </li>
        <li><a href="#arm-a-arch64-体系下-cpu-的工作模式">ARM-A Arch64 体系下 CPU 的工作模式</a>
          <ul>
            <li><a href="#工作模式分类">工作模式分类</a></li>
            <li><a href="#处理器如何切换工作模式">处理器如何切换工作模式</a></li>
          </ul>
        </li>
        <li><a href="#aarch64-体系如何处理中断">AArch64 体系如何处理中断</a>
          <ul>
            <li><a href="#异常和中断">异常和中断</a></li>
            <li><a href="#中断处理">中断处理</a></li>
            <li><a href="#中断向量表">中断向量表</a></li>
          </ul>
        </li>
        <li><a href="#aarch64-体系如何访问内存">AArch64 体系如何访问内存</a>
          <ul>
            <li><a href="#aarch64-体系下的地址空间">AArch64 体系下的地址空间</a></li>
            <li><a href="#aarch64-体系下地址映射和转换">AArch64 体系下地址映射和转换</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是 LMOS。</p>
<p>在今天，Andriod+ARM 已经成了移动领域的霸主，这与当年的 Windows+Intel 何其相似。之前我们已经在 Intel 的 x86 CPU 上实现了 Cosmos，今天我会给你讲讲 ARM 的 AArch64 体系结构，带你扩展一下视野。</p>
<p>首先，我们来看看什么是 AArch64 体系，然后分析一下 AArch64 体系有什么特点，最后了解一下 AArch64 体系下运行程序的基础，包括 AArch64 体系下的寄存器、运行模式、异常与中断处理，以及 AArch64 体系的地址空间与内存模型。</p>
<p>话不多说，下面我们进入正题。</p>
<h2 id="什么是-aarch64-体系">什么是 AArch64 体系</h2>
<p>ARM 架构在不断发展，现在它在各个领域都得到了非常广泛地应用。</p>
<p>自从 Acorn 公司于 1983 年开始发布第一个版本，到目前为止，有九个主要版本，版本号由 1 到 9 表示。2011 年，Acorn 公司发布了 ARMv8 版本。</p>
<p>ARMv8 是首款支持 64 位指令集的 ARM 处理器架构，它兼容了 ARMv7 与之前处理器的技术基础，同样它也兼容现有的 A32（ARM 32bit）指令集，还扩充了基于 64bit 的 AArch64 架构。</p>
<p>下面我们一起来看看 ARMv8 一共定义了哪几种架构，一共有三种。</p>
<p>1.<strong>ARMv8-A（Application）架构</strong>，支持基于内存管理的虚拟内存系统体系结构（VMSA），支持 A64、A32 和 T32 指令集，主打高性能，在我们的移动智能设备中广泛应用。</p>
<p>2.<strong>ARMv8-R（Real-time）架构</strong>，支持基于内存保护的受保护内存系统架构（PMSA），支持 A32 和 T32 指令集，一般用于实时计算系统。</p>
<p>3.<strong>ARMv8-M（Microcontroller 架构）</strong>，是一个压缩成本的嵌入式架构，而且需要极低延迟中断处理。它支持 T32 指令集的变体，主打低功耗，一般用于物联网设备。</p>
<p>今天我们要讨论的 AArch64，它只是 ARMv8-A 架构下的一种执行状态，“64”表示内存或者数据都保存在 64 位的寄存器中，并且它的基本指令集可以用 64 位寄存器进行数据运算处理。</p>
<h2 id="aarch64-体系的寄存器">AArch64 体系的寄存器</h2>
<p>一款处理器要运行程序和处理数据，必须要有一定数量的寄存器。特别是基于 RISC（精简指令集）架构的 ARM 处理器，寄存器数量非常之多，因为大量的指令操作的就是寄存器。</p>
<p>ARMv8-AArch64 体系下的寄存器简单可以分为以下几类。</p>
<p>1. 通用寄存器</p>
<p>2. 特殊寄存器</p>
<p>3. 系统寄存器</p>
<p>下面我们分别来看看这三类寄存器。</p>
<h3 id="通用寄存器-r0-r30">通用寄存器 R0-R30</h3>
<p>首先来看通用寄存器（general-purpose registers），通用寄存器一共为 31 个，从 R0 到 R30，这个 31 个寄存器可以作为全 64 位使用，也可以只使用其中的低 32 位。</p>
<p>全 64 位的寄存器以 x0 到 x30 名称进行引用，用于 32 位或者 64 位的整数运算或者 64 位的寻址；低 32 位寄存器以 W0 到 W30 名称进行引用，只能用于 32 位的整数运算或者 32 位的寻址。为了帮你理解，我还在后面画了示意图。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/3267859294c7c38d5c0e003f820b80fe.png" alt=""></p>
<p>register_common</p>
<p>通用寄存器中还有 32 个向量寄存器（SIMD），编号从 V0 到 V31。因为向量计算依然是数据运算类的，所以要把它们归纳到通用寄存器中。每个向量寄存器都是 128 位的，但是它们可以单独使用其中的 8 位、16 位、32 位、64 位，它们的访问方式和索引名称如下所示。</p>
<ol>
<li>Q0 到 Q31 为一个 128-bit 的向量寄存器；</li>
<li>D0 到 D31 为一个 64-bit 的向量寄存器；</li>
<li>S0 到 S31 为一个 32-bit 的向量寄存器；</li>
<li>H0 到 H31 为一个 16-bit 的向量寄存器；</li>
<li>B0 到 B31 为一个 8-bit 的向量寄存器；</li>
</ol>
<p>register_simd</p>
<h3 id="特殊寄存器">特殊寄存器</h3>
<p><strong>特殊寄存器</strong>（spseical registers）比通用寄存器稍微复杂一些，它还可以细分，包括程序计数寄存器（PC），栈指针寄存器（SP），异常链接寄存器（ELR_ELx），程序状态寄存器（PSTATE、SPSR_ELx）等。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/95fc589e214651fdd1adbf3d3f53cbdf.png" alt=""></p>
<p>special_registers</p>
<p><strong>PC 寄存器</strong></p>
<p>PC 寄存器，保存当前指令地址的 64 位程序计数器，指向即将要执行的下一条指令，CPU 正是在这个寄存器的指引下，一条一条地运行代码指令。在 ARMv7 上，PC 寄存器就是通用寄存器 R15，而在 ARMv8 上，PC 寄存器不再是通用寄存器，不能直接被修改，只可以通过隐式的指令来改变，例如 PC-relative load。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/3c83f955a9befaac1f222a6e9614f882.png" alt=""></p>
<p>PC 寄存器</p>
<p><strong>SP 寄存器</strong></p>
<p>SP 是 64 位的栈指针寄存器，可以通过 <strong>WSP</strong> 寄存器访问低 32 位，在指令中使用 SP 作为操作数，表示使用当前栈指针。C 语言调用函数和分配局部变量都需要用栈，栈是一种后进先出的内存空间，而 SP 寄存器中保存的就是栈顶的内存地址。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/5d4d1d7ca01c3ad3c00d34b7880e0e7e.png" alt=""></p>
<p>SP 寄存器</p>
<p><strong>ELR_ELx 异常链接寄存器</strong></p>
<p>每个异常状态下都有一个 ELR_EL 寄存器，ELR_ELx 寄存器是异常综合寄存器或者异常状态寄存器，负责保存异常进入 Elx 的地址和发生异常的原因等信息。</p>
<p>该寄存器只有 ELR_EL1、ELR_EL2、ELR_EL3 这几种，没用 ELR_EL0 寄存器，因为异常不会 routing(target) 到 EL0。例如：16bit 指令的异常、32bit 指令的异常、simd 浮点运算的异常、MSR/MRS 的异常。</p>
<p>ELR_ELx 寄存器</p>
<p><strong>PSTATE</strong></p>
<p>PSTATE 不是单独的一个寄存器，而是保存当前 PE（Processing Element）状态的一组寄存器统称，其中可访问寄存器有：NZCV、DAIF、CurrentEL()、SPSel。这些属于 ARMv8 新增内容，在 64bit 下可以代替 CPSR（32 位系统下的 PE 信息）。</p>
<p>type ProcState is (<br>
// PSTATE.{N, Z, C, V}：条件标志位，这些位的含义跟之前 AArch32 位一样，分别表示补码标志，运算结果为 0 标志，进位标志，带符号位溢出标志<br>
bits (1) N, // Negative condition flag<br>
bits (1) Z, // Zero condition flag<br>
bits (1) C, // Carry condition flag<br>
bits (1) V, // oVerflow condition flag<br>
// D 表示 debug 异常产生，比如软件断点指令/断点/观察点/向量捕获/软件单步 等；<br>
// A, I, F 表示异步异常标志，异步异常会有两种类型：一种是物理中断产生的，包括 SError（系统错误类型，包括外部数据终止），IRQ 或者 FIQ；<br>
// 另一种是虚拟中断产生的，这种中断发生在运行在 EL2 管理者 enable 的情况下：vSError，vIRQ，vFIQ；<br>
bits (1) D, // Debug mask bit [AArch64 only]<br>
bits (1) A, // Asynchronous abort mask bit<br>
bits (1) I, // IRQ mask bit<br>
bits (1) F, // FIQ mask bit<br>
// 异常发生的时候，通过设置 MDSCR_EL1.SS 为 1 启动单步调试机制；<br>
bits (1) SS, // Software step bit<br>
// 异常执行状态标志，非法异常产生的时候，会设置这个标志位，<br>
bits (1) IL, // Illegal execution state bit<br>
bits (2) EL, // Exception Level (see above)<br>
// 表示当前 ELx 所运行的状态，分为 AArch64 和 AArch32:<br>
bits (1) nRW, // not Register Width: 0=64, 1=32<br>
// 某个 ELx 下的堆栈指针，EL0 下就表示 sp_el0；<br>
bits (1) SP, // Stack pointer select: 0=SP0, 1=SPx [AArch64 only]<br>
)</p>
<p><strong>SPSR_ELx 程序状态寄存器</strong></p>
<p>程序在运行中，处理大量数据，无非是进行各种数学运算，而数学运算的结果往往有各种状态，如进位、结果为 0、结果是负数等，还有程序的运行状态，是否允许中断，CPU 的工作模式，这些信息都保存在程序状态寄存器中，即 PSTATE 中。</p>
<p>但是当 CPU 处理异常时，进程相应的 ELx 状态不同，就要把 PSTATE 状态信息保存在 ELx 状态下对应的 SPSR_ELx 寄存器中。SPSR_ELx 寄存器的格式如下所示。</p>
<p>register_SPSR_ELx</p>
<h3 id="系统寄存器">系统寄存器</h3>
<p>最后，ARM 的 CPU 上还有一些系统寄存器，用于访问系统配置。</p>
<p>在 EL0 状态下，大多数系统寄存器是不可访问的，但是部分系统寄存器可以在 EL0 状态下进行访问，比如 Cache ID 寄存器（用于 EL0 状态下缓存管理）、调试寄存器（用于代码调试，如 MDCCSR_EL0、DBGDTR_EL0 等）、性能监控寄存器和时钟寄存器等。</p>
<h2 id="arm-a-arch64-体系下-cpu-的工作模式">ARM-A Arch64 体系下 CPU 的工作模式</h2>
<p>其实，AArch64、AArch32 体系都是简称，从严格意义上说，它们应该是处理器的两种执行方式或者状态。AArch64 体系执行 A64 指令集，这个指令集是全 64 位的；AArch32 体系则可以执行 A32 指令集和 T32 指令集（这节课我们不关注这个体系，所以这些指令集暂不深究）。</p>
<p>不管是 AArch64 体系还是 AArch32 体系，ARM CPU 的工作模式并没有差异。为了让你把握重点，我们后面只是以 AArch64 体系为例，探讨 ARM 处理器的工作模式。</p>
<h3 id="工作模式分类">工作模式分类</h3>
<p>前面我们介绍了 x86 CPU 的工作模式，但是 x86 CPU 的工作模式和 ARM 的 CPU 的工作差别很大，x86 CPU 的工作模式，包括特权级、处理器位宽、内存的访问与保护。</p>
<p>ARM CPU 工作模式则有些不同，究竟有哪些不同呢？</p>
<p>ARM 的 CPU 一共有 7 种不同工作模式，根据权限和状态，以及进入工作模式的方法等方面的不同，我为你用表格的方式做了梳理。</p>
<p>工作模式梳理</p>
<p>虽然看起来比较多，但是还是比较好归纳的，在 7 种模式中，除了用户模式之外的模式，被统称为 <strong>Privileged Modes</strong>(特权模式)。</p>
<p>首先，我们大多数的应用程序是运行在用户模式下的，在用户模式下，是不能够访问受保护的系统资源的。此外，应用程序也无法进行处理器模式的切换的。这样就做到了应用程序和内核程序的权力分隔，确保应用程序不能破坏操作系统。</p>
<p>一旦代码的执行流，切换到特权模式下，其代码就可以访问全部的系统资源了，代码也可以随时进行处理器模式的切换。而且只有在特权模式下，CPU 的部分内部寄存器才可以被读写。这里的代码就是指内核代码。</p>
<p>其次，系统模式也是特权模式，代码也是可以访问全部系统资源，也可以随时进行处理器模式的切换，主要供操作系统任务使用。系统模式和用户模式可以访问到的寄存器是同一套的，区别就是它是特权模式，不受用户模式的限制，一般系统模式用于调用操作系统的系统任务。</p>
<p>最后，特权模式下，除系统模式之外的其他五种模式就是异常模式。异常模式一般是在用户的应用程序发生中断异常时，随着特定的异常而进入的，比如之前我们讲过的硬件中断和软件中断，每种异常模式都有对应的一组寄存器，用来保证用户模式下的状态不被异常破坏。这样可以大大减小处理异常的时间，因为不用保存大量用户态寄存器。</p>
<h3 id="处理器如何切换工作模式">处理器如何切换工作模式</h3>
<p>前面我们已经了解了 ARM 架构下 CPU 的几种工作模式，那么 CPU 的工作模式是如何切换的呢？</p>
<p>工作模式切换大概分两种情况，一是软件控制，通过修改相应的寄存器或者执行相应的指令；二是当外部中断或是异常发生时，也会导致 CPU 工作模式的切换。</p>
<p>那么当 CPU 发生中断或者异常时，CPU 进入相应的异常模式时，以下工作由 CPU 自动完成。</p>
<p>1. 在异常模式的 R14 中，保存前一个工作模式里，下一条即将执行的指令地址；</p>
<p>2. 将 CPSR 的值复制到异常模式的 SPSR 中；</p>
<p>3. 将 CPSR 的工作模式设为该异常模式对应的工作模式；</p>
<p>4. 令 PC 值等于这个异常模式在异常向量表中的地址，即跳转去执行异常向量表中的相应指令。</p>
<p>处理完中断或者异常，就需要从中断或者异常中返回到发生中断或者异常的位置，继续执行程序。这个从异常工作模式退回到之前的工作模式时，需要由软件来完成后面这两项工作。</p>
<p>1. 将异常模式的 R14 减去一个适当的值（4 或 8）后，赋给 PC 寄存器；</p>
<p>2. 将异常模式 SPSR 的值赋给 CPSR；</p>
<p>好了，以上就是 CPU 切换工作的细节，有了这个基础，接下来我们一起看看 AArch64 体系下 CPU 是如何处理中断或者异常的。</p>
<h2 id="aarch64-体系如何处理中断">AArch64 体系如何处理中断</h2>
<p>现在我们来看看 AArch64 体系是如何处理中断的，首先我们要搞清楚中断和异常的区别，然后了解它们的处理过程，最后再研究一下中断向量表。</p>
<h3 id="异常和中断">异常和中断</h3>
<p>有时候，我们习惯于把异常（Exception）和中断（Interrupt）理解成一回事儿。但是对 ARM 来说，官方文档用了 Exception 这个术语来描述广义上的中断，包括异常（Exception）和中断（Interrupt），Exception 和 Interrupt 的执行机制都是一样的，只是触发方式有区别。</p>
<p>这里的异常，切入的视角是处理器<strong>被动接收</strong>到了异常。异常通常表现为错误，比如 CPU 执行了未知指令，但 CPU 明显不能执行这个指令，所以就会产生错误。再比如说，CPU 访问了不能访问的内存，这也是错误的。你会发现，共同点是异常都是同步的，不修改程序下次同样会发生。</p>
<p>而中断对应的视角是处理器<strong>主动申请</strong>，你可以当作是异步的异常，因外部事件产生。中断分为三种，它们分别是 IRQ、FIQ 和 SError。IRQ、FIQ 通常是连接到外部中断信号，当外部设备发出中断信号时，CPU 就能对此作出响应并处理外部设备需要完成的操作。</p>
<h3 id="中断处理">中断处理</h3>
<p>我们在了解中断处理之前，首先要搞明白异常级别。</p>
<p>在全局 ARMV8-A 体系结构中，定义了四个异常级别（Exception Level）从 EL0 到 El3，每个异常级别的权限不同，你不妨想像一下 x86 CPU 的 R3～R0 特权级。</p>
<p>只不过 ARMV8-A 体系结构下 EL0 为最低权限模式，也就是对应用户态，处理的是应用程序；EL1 处理的是 OS 内核层，对应的是内核态；EL2 是 Supervisor 模式，处理的则是可以跑多个虚拟 OS 内核的管理软件，对应的是虚拟机管理态，它是可选的，如 Hypervisor 用于和 virtualization 扩展；EL3 运行的是安全管理（Secure Monitor），处理的是监控态，用于 security 扩展。</p>
<p>开发通用的操作系统内核只需要使用到 EL1，EL2 两个异常级别，我为你画了一幅 EL 模型图，如下所示。</p>
<p>EL 模型图</p>
<p>现在我们来看看中断或者异常发生时，EL 级别的切换，这里分为两种情况。</p>
<p>第一种是高级别向低级别切换，这种方式通过修改 PSTATE 寄存器中的值来实现，EL 异常级别就保存在这个寄存器中；第二种是低级别向高级别切换，通过触发中断或者异常的方式进行切换的。</p>
<p>在这两种切换过程中，如果高级的状态是 AArch64，低级的可以是 AArch64 或者 AArch32，也就是可以向下兼容；如果高级的是 AArch32，那么低级的也一定要是 AArch32。</p>
<p>当一个中断或者异常触发后，CPU 的操作流程如下所示。</p>
<p>1. 更新 SPSR_ELx 寄存器，即当前的 PSTATE 寄存器的信息存储在 SPSR_ELx 寄存，以便中断结束时恢复到 PSTATE 寄存器。</p>
<p>2. 更新 PSTATE 寄存器以反映新的处理器状态，这个过程中，中断级别可能会发生变化。</p>
<p>3. 发生中断时的下一条指令地址存储在 ELR_ELx 寄存器中，以便中断返回后，能继续运行。</p>
<p>4. 当中断处理完成后，由高级别返回低级别时，需要使用 ERET 指令返回。</p>
<p>下图能帮你更加清楚地理解这一行为。</p>
<p>Interrupt 流程</p>
<p>上图已经清楚地展示了，中断或者异常发生时，其中几个关键寄存器是如何保存和恢复的。</p>
<h3 id="中断向量表">中断向量表</h3>
<p>当中断或者异常发生后，CPU 进行相应的操作后，必须要跳转到相应的地址开始运行相应的代码，进行中断或者异常的处理，这个地址就是<strong>中断向量</strong>。由于有多个中断或者异常，于是就形成了<strong>中断向量表</strong>。</p>
<p>在 AArch64 中，每个中断或者异常触发时会产生 EL 级别切换。通常在 EL0 级别调用 svc 指令，触发一个同步异常，CPU 则会切换到 EL1 级别；如果在 EL0 级别来了一个 IRQ 或 FIQ，就会触发一个异步中断，CPU 会根据 SCR 寄存器中的中断配置来决定切换 EL1 或 EL2 或 EL3 级别，同时也会区分 EL 级别使用的是 AArch64，还是 AArch32 的指令集。</p>
<p>16 个向量的分类和偏移地址在向量表中的关系如下所示。</p>
<p>上表中分了四个小表，小表中的每一个 entry 由不同的中断的类型（IRQ，FIQ，SError，Synchronous）决定。具体使用哪一个小表由以下几个条件决定。</p>
<ol>
<li>如果中断发生在同一中断级别，并且使用的栈指针是 SP_EL0，则使用 SP_EL0 这张表。</li>
<li>如果中断发生在同一中断级别，并且使用的栈指针是 SP_EL1/2/3，则使用 SP_EL 这张表。</li>
<li>如果中断发生在较低的中断级别，使用的小表则为下一个较低级别（AArch64 或 AArch32）的执行状态。</li>
</ol>
<p>有了这些硬件机制的支持，就可以完美支持现代意义中的操作系统了。</p>
<h2 id="aarch64-体系如何访问内存">AArch64 体系如何访问内存</h2>
<p>无论是操作系统内核代码还是应用程序代码，它们都是放在内存中的，CPU 要执行相应的代码指令，就要访问内存。访问内存有两大关键，<strong>一是寻址，这表现为内存的地址空间；第二个关键点是内存空间的保护，即内存地址的映射和转换</strong>。下面我分别解读一下这两个关键点。</p>
<h3 id="aarch64-体系下的地址空间">AArch64 体系下的地址空间</h3>
<p>对于工作在 AArch64 体系下的 CPU 来说，没有启动 MMU 的情况下，ARM 的 CPU 发出的地址，就是物理地址直接通过这个寻址内存空间。</p>
<p>但是你别以为 AArch64 体系下有 64 位的寄存器，能发出 64 位的地址，就一定能寻址 64 位地址空间的内存。其实实际只能使用 52 位或者 48 位的地址，这里我们只讨论使用 48 位地址的情况。如果启用了 MMU，那么 CPU 会通过虚拟地址寻址，MMU 负责将虚拟地址转换为物理地址，进而访问实际的物理地址空间。这个过程如下图所示。</p>
<p>AArch64 虚拟地址空间</p>
<p>上图中可以发现，如果 CPU 发出的虚拟地址在 0x0～0x0000ffffffffffff 范围内，MMU 就会使用 TTBR0_ELx 寄存器指向的地址转换表进行物理地址的转换；如果 CPU 发出的虚拟地址在 0xffff000000000000～0xffffffffffffffff，MMU 使用 TTBR1_ELx 寄存器指向的地址转换表进行物理地址的转换。</p>
<p>究竟虚拟地址是如何转换成物理地址的呢？我们接着往下看。</p>
<h3 id="aarch64-体系下地址映射和转换">AArch64 体系下地址映射和转换</h3>
<p>按照我们以往的经验来看，这里肯定是有一张把虚拟地址转化为物理地址的表，给出一个虚拟地址，通过查表就可以查到物理地址。但是实际过程却不是这么简单，在这里通常要有一个多级的查表过程。</p>
<p>MMU 将虚拟地址映射到物理地址是以页（Page）为单位的，ARMv8 架构的 AArch64 体系可以支持 48 位虚拟地址，并配置成 4 级页表（4K 页），或者 3 级页表（64K 页）。</p>
<p>例如，虚拟地址 0xb7001000~0xb7001fff 是一个页，可能被 MMU 映射到物理地址 0x2000~0x2fff，物理内存中的一个物理页面也称为一个页框（Page Frame）。</p>
<p>那么 MMU 执行地址转换的过程是怎样呢？我们看一看 4K 页表的情况下，虚拟地址转换物理地址的逻辑图。</p>
<p>虚拟地址转化</p>
<p>结合上图我们看到，首先要将 64 位的虚拟内存分成多个位段，这些位段就是用来索引不同级别页表中的 entry 的。那么 MMU 是如何具体操作的呢，一共分五步。</p>
<p>第一步从虚拟地址位段 [47:39] 开始，用来索引 0 级页表，0 级页表的物理基地址存放在 TTBR_ELx 寄存器中，以虚拟地址位段 [47:39] 为索引，找到 0 级页表中的某个 entry，该 entry 会返回 1 级页表的基地址。</p>
<p>第二步，接着之前找到的 1 级页表的基地址，现在可以用虚拟地址位段 [38:30] 索引到 1 级页表的某个 entry，该 entry 在 4KB 页表情况下，返回的是 2 级页表的基地址。</p>
<p>然后到了第三步，有了 2 级页表基地址，就可以用虚拟地址位段 [29:21] 作为索引找到 2 级页表中的某个 entry，该 entry 返回 3 级页表的基地址。</p>
<p>再然后是第四步，有了 3 级页表基地址，则用虚拟地址位段 [20:12] 作为索引找到 3 级页表中的某个 entry，该 entry 返回的是物理内存页面的基地址。</p>
<p>最后一步，我们得到物理内存页面基地址，用虚拟地址剩余的位段 [11:0] 作为索引，就能访问到 4KB 大小的物理内存页面内的某个字节了。</p>
<p>这个过程从 TTBR_ELx 寄存器开始到 0 级页表，接着到 1 级页表，然后到 2 级页表，再然后到 3 级页表，最终到物理页面，CPU 一次寻址，其实是五次访问物理内存。这个过程完全是由硬件处理的，每次寻址时 MMU 就自动完成前面这五步，不需要我们编写指令来控制 MMU，但是我们要保证内核维护正确的页表项。</p>
<p>有了 MMU 硬件转换机制，操作系统只需要控制页表就能控制内存的映射和隔离了。</p>
<h2 id="总结">总结</h2>
<p>这节课我们一起了解了 ARM 的 AArch64 体系，它是 ARMV8-A 下的一种执行状态。作为首款支持 64 位的处理器架构，AArch64 体系不只是 32 位 ARM 构架的兼容扩展，还引入了新的 A64 指令集。</p>
<p>处理器想要运行程序、处理数据，离不开各种寄存器。我们学习了 AARch64 下的三类寄存器，包括通用寄存器、特殊寄存器和系统寄存器。</p>
<p>相比 x86 系统，AArch64 的 CPU 工作模式更加多样，一共有七种工作模式。之后，我们分别研究了工作模式切换还有基于 EL0-3 的异常中断处理，以及 AArch64 下的内存架构和访问方式。访问内存，你重点要掌握的是访问内存的两大关键点，<strong>一是寻址，二是内存空间的保护</strong>。</p>
<p>自从 2011 年 ARM 发布首款支持 64 位的 ARMv8 版本后，到现在已经过去了十年。在今年 ARM 也宣布了下一代芯片架构 ARMv9 的部分技术细节，并称其为十年来最大的创新，也将是未来十年内千亿级别芯片的基础，其在 CPU 性能、安全性、AI 支持上有了显著提升。</p>
<p>但是 ARMv9 不会像 ARMv7 到 ARMv8 的根本性的执行模式和指令集的变化，ARMv9 继续使用 AArch64 作为基准指令集，但是在其功能上增加了一些非常重要的扩展，ARMv9 开发的处理器预计将在 2022 年正式面世，让我们拭目以待！</p>
<h2 id="思考题">思考题</h2>
<p>请问，ARMv8，有多少特权级？每个特权级有什么作用？</p>
<p>欢迎你在留言区记录你的思考，也欢迎把这节课分享给有需要的朋友。</p>
<p>我是 LMOS，我们下节课见。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/">操作系统实战45讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes/46__%E8%A7%A3%E8%AF%BB_cri_%E4%B8%8E_%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">46__解读_CRI_与_容器运行时</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E8%AF%BE/46_%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%93%88%E5%B8%8C%E8%A1%A8%E5%92%8C%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E8%AE%BF%E9%97%AE/">
            <span class="next-text nav-default">46_缓存系统：如何通过哈希表和队列实现高效访问？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
