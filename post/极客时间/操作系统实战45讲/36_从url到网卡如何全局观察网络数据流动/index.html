<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>36_从URL到网卡：如何全局观察网络数据流动？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是 LMOS。
从这节课起，我们就要开始学习网络篇的内容了。网络是一个极其宏大的知识结构，我会通过五节课带你了解计算机网络的关键内容。
具体我们是这样安排的。作为网络篇的开始，今天这节课我会从一个面试中高频出现的问题切入，带你梳理从输入 URL 到网卡的网络数据流动过程中都发生了什么事。如果你真正理解了这个过程，相信你对整个网络架构的认知也会有质的飞跃。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/36_%E4%BB%8Eurl%E5%88%B0%E7%BD%91%E5%8D%A1%E5%A6%82%E4%BD%95%E5%85%A8%E5%B1%80%E8%A7%82%E5%AF%9F%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A8/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/36_%E4%BB%8Eurl%E5%88%B0%E7%BD%91%E5%8D%A1%E5%A6%82%E4%BD%95%E5%85%A8%E5%B1%80%E8%A7%82%E5%AF%9F%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A8/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="36_从URL到网卡：如何全局观察网络数据流动？">
  <meta property="og:description" content="你好，我是 LMOS。
从这节课起，我们就要开始学习网络篇的内容了。网络是一个极其宏大的知识结构，我会通过五节课带你了解计算机网络的关键内容。
具体我们是这样安排的。作为网络篇的开始，今天这节课我会从一个面试中高频出现的问题切入，带你梳理从输入 URL 到网卡的网络数据流动过程中都发生了什么事。如果你真正理解了这个过程，相信你对整个网络架构的认知也会有质的飞跃。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="操作系统实战45讲">

  <meta itemprop="name" content="36_从URL到网卡：如何全局观察网络数据流动？">
  <meta itemprop="description" content="你好，我是 LMOS。
从这节课起，我们就要开始学习网络篇的内容了。网络是一个极其宏大的知识结构，我会通过五节课带你了解计算机网络的关键内容。
具体我们是这样安排的。作为网络篇的开始，今天这节课我会从一个面试中高频出现的问题切入，带你梳理从输入 URL 到网卡的网络数据流动过程中都发生了什么事。如果你真正理解了这个过程，相信你对整个网络架构的认知也会有质的飞跃。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6232">
  <meta itemprop="keywords" content="操作系统实战45讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="36_从URL到网卡：如何全局观察网络数据流动？">
  <meta name="twitter:description" content="你好，我是 LMOS。
从这节课起，我们就要开始学习网络篇的内容了。网络是一个极其宏大的知识结构，我会通过五节课带你了解计算机网络的关键内容。
具体我们是这样安排的。作为网络篇的开始，今天这节课我会从一个面试中高频出现的问题切入，带你梳理从输入 URL 到网卡的网络数据流动过程中都发生了什么事。如果你真正理解了这个过程，相信你对整个网络架构的认知也会有质的飞跃。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">36_从URL到网卡：如何全局观察网络数据流动？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6232 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#从一道经典面试题说起">从一道经典面试题说起</a></li>
        <li><a href="#前置知识网络分层和网络协议">前置知识：网络分层和网络协议</a></li>
        <li><a href="#发起请求阶段应用层">发起请求阶段（应用层）</a>
          <ul>
            <li><a href="#用户输入在浏览器中输入-url">用户输入：在浏览器中输入 URL</a></li>
            <li><a href="#网络请求前查看浏览器缓存">网络请求前：查看浏览器缓存</a></li>
            <li><a href="#域名解析dns">域名解析：DNS</a></li>
          </ul>
        </li>
        <li><a href="#操作系统协议栈传输层和网络层">操作系统协议栈（传输层和网络层）</a>
          <ul>
            <li><a href="#可靠性传输建立-tcp-连接">可靠性传输：建立 TCP 连接</a></li>
            <li><a href="#目的地定位ip-层">目的地定位：IP 层</a></li>
          </ul>
        </li>
        <li><a href="#点对点传输mac链路层">点对点传输：MAC（链路层）</a></li>
        <li><a href="#电信号的出口网卡物理层">电信号的出口：网卡（物理层）</a></li>
        <li><a href="#客户端服务端的持续数据交换应用层">客户端服务端的持续数据交换（应用层）</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是 LMOS。</p>
<p>从这节课起，我们就要开始学习网络篇的内容了。网络是一个极其宏大的知识结构，我会通过五节课带你了解计算机网络的关键内容。</p>
<p>具体我们是这样安排的。作为网络篇的开始，今天这节课我会从一个面试中高频出现的问题切入，带你梳理从输入 URL 到网卡的网络数据流动过程中都发生了什么事。如果你真正理解了这个过程，相信你对整个网络架构的认知也会有质的飞跃。</p>
<p>网络篇的第二节课，我会带你分析网络数据包在内核中如何流转；第三节课，我们一起探讨互联网架构演进过程，并动手做一次协议栈移植；最后两节课，我还是照例带你看看 Linux，让你理解套接字在 Linux 内核中怎样实现。</p>
<h2 id="从一道经典面试题说起">从一道经典面试题说起</h2>
<p>下面我们一起来看看一个问题，估计你多多少少会觉得熟悉。</p>
<blockquote>
<p>输入 URL，从一个请求到响应都发生了什么事？</p>
</blockquote>
<p>没错，这是一道非常经典的面试题，你在网上随便一搜，也会找到各种各样的资料解答这道题。</p>
<p>不过啊，那些答案都有一些笼统，今天我会尽量详细地为你梳理一下这个过程。跟着我学完这节课，你就能明白，为什么面试官对这道题青睐有加了。</p>
<p>这里我先给你概括一下全过程，让你有个整体印象。</p>
<p>1. 常规的网络交互过程是从客户端发起网络请求，用户态的应用程序（浏览器）会生成 HTTP 请求报文、并通过 DNS 协议查找到对应的远端 IP 地址。</p>
<p>2. 在套接字生成之后进入内核态，浏览器会委托操作系统内核协议栈中的上半部分，也就是 TCP/UDP 协议发起连接请求。</p>
<p>3. 然后经由协议栈下半部分的 IP 协议进行封装，使数据包具有远程定位能力。</p>
<p>4. 经过 MAC 层处理，找到接收方的目标 MAC 地址。</p>
<p>5. 最终数据包在经过网卡转化成电信号经过交换机、路由器发送到服务端，服务端经过处理拿到数据，再通过各种网络协议把数据响应给客户端。</p>
<p>6. 客户端拿到数据进行渲染。</p>
<p>7. 客户端和服务端之间反复交换数据，客户端的页面数据就会发生变化。</p>
<p>你有没有发现，刚才的过程中，我们提到了多个层级和网络协议，那么网络为什么要分层呢？网络协议又是什么呢？请听我给你一一道来。</p>
<h2 id="前置知识网络分层和网络协议">前置知识：网络分层和网络协议</h2>
<p>在计算机网络时代初期，各大厂商推出了不同的网络架构和标准，为统一标准，国际标准化组织 ISO 推出了统一的 OSI 参考模型。</p>
<p>当前网络主要遵循的 IEEE 802.3 标准，就是基于 OSI 模型提出的，主要定义的是<strong>物理层和数据链路层有线物理数据流传输的标准</strong>。</p>
<p>那么问题来了，网络为什么要分层呢？</p>
<p>我们都知道网络是复杂的。对于复杂的问题，我们自然要<strong>通过分层处理简化问题难度，降低复杂度</strong>，由于分层后的各层之间相互独立，我们可以把大问题分割成小问题。同样，分层也保证了网络的松耦合和相对的灵活，分层拆分后易于各层的实现和维护，也方便了各层的后续扩展。</p>
<p>网络分层解决了网络复杂的问题，在网络中传输数据中，我们对<strong>不同设备之间的传输数据的格式，需要定义一个数据标准，所以就有了网络协议。</strong></p>
<p>网络协议是双方通信的一种约定，以便双方都可以理解对方的信息。接下来我们就用 OSI 协议体系中广泛应用的 <strong>TCP/IP 层的体系结构</strong>来分析整个过程，你重点需要关注的是<strong>数据处理的过程和网络协议。</strong></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/bf98fbe298b255d45a51bdc573e066ae.png" alt=""></p>
<p>ISO_OSI 通信流转</p>
<h2 id="发起请求阶段应用层">发起请求阶段（应用层）</h2>
<p>下面我们首先来看看网络应用层，它是最上层的，也是我们能直接接触到的。</p>
<p>我们的电脑或⼿机使⽤的应⽤软件都是在应⽤层实现，所以应⽤层只需要专注于为⽤户提供应⽤功能，不⽤去关⼼数据是如何传输的。你可以这样理解，应⽤层是⼯作在操作系统中的⽤户态。</p>
<p>我们依然从浏览器中输入 URL，开始了解网络应用层的工作流程。</p>
<h3 id="用户输入在浏览器中输入-url">用户输入：在浏览器中输入 URL</h3>
<p>我们在浏览器中输入 URL 的时候，浏览器已经开始工作了。浏览器会根据我们的输入内容，先匹配对应的 URL 以及关键词，给出输入建议，同时校验 URL 的合法性，并且会在 URL 前后补全 URL。</p>
<p>为了帮你更好地理解，我给你举个例子说明。我们以输入 cosmos.com 为例，首先浏览器会判断出这是一个合法的 URL，并且会补全为 <a href="http://www.cosmos.com">http://www.cosmos.com</a>。</p>
<p>其中 http 为协议，cosmos.com 为网络地址，每个网络栏的地址都符合通用 URI 的语法。URI 一般语法由五个分层序列组成。后面的第一行内容我给你列了 URL 的格式，第二行做了行为说明。</p>
<p>URI = scheme:[//authority]path[?query][#fragment]</p>
<p>URI = 方案:[//授权] 路径 [?查询][#片段 ID]</p>
<p>接着，浏览器从 URL 中会提取出网络的地址，也叫做主机名（host），一般主机名可以为域名或 IP 地址，此处使用域名。</p>
<p>对 URL 进行解析之后，浏览器确定了服务器的主机名和请求路径，接下来就是根据这些信息来生成 HTTP 请求消息了，那么到现在为止，我们的 HTTP 请求是否已经发出了呢？并不是这样的，我们接着往下看。</p>
<h3 id="网络请求前查看浏览器缓存">网络请求前：查看浏览器缓存</h3>
<p>浏览器在 HTTP 报文生成完成后，它并不是马上就开始网络请求的。</p>
<p>在请求发出之前，浏览器首先会检查保存在本地计算机中的缓存，如果访问过当前的 URL，会先进入缓存中查询是否有要请求的文件。此时存在的缓存有路由器缓存、DNS 缓存、浏览器缓存、Service Worker、Memory Cache、Disk Cache、Push Cache、系统缓存等。</p>
<p>在这里我们看一下系统缓存，如果在浏览器缓存里没有命中缓存，浏览器会做一个系统调用获得系统缓存中的记录，就是我们的 gethostbyname 方法，它的作用是通过域名获取 IP 地址。这个方法会返回如下结构。</p>
<p>struct hostent<br>
{<br>
char    *h_name;// 主机的别名.www.cosmos.com 就是 google 他自己的别名 <br>
char    **h_aliases;// 主机 ip 地址的类型，到底是 ipv4(AF_INET)，还是 pv6(AF_INET6)<br>
int     h_addrtype;// 主机 ip 地址的长度<br>
int     h_length;// 主机 ip 地址的长度<br>
char    **h_addr_list; // 主机的 ip 地址，注意，这个是以网络字节序存储的<br>
#define h_addr h_addr_list[0] 这个函数，是将类型为 af 的网络地址结构 src，转换成主机序的字符串形式，存放在长度为 cnt 的字符串中。返回指向 dst 的一个指针。如果函数调用错误，返回值是 NULL<br>
};</p>
<p>如果没有访问过当前的 URL，就会跳过缓存这一步，这时我们就会进入网络操作了。</p>
<h3 id="域名解析dns">域名解析：DNS</h3>
<p>接着上一小节在浏览器确认了输入的 URL 之前没有访问，浏览器就会生成对应的 HTTP 请求，这时浏览器需要委托操作系统将 HTTP 报文发送到对应的服务端。在发送消息之前，还有一个工作需要做，就是查找服务端的 IP 地址，因为操作系统在发送消息时，必须知道对方的 IP 地址才可以发送。</p>
<p>但是由于 IP 地址由一串数字组成，不够语义化，为方便你记忆，我们将 IP 地址映射为域名，于是就有这样一个服务，维护了 IP 和域名的映射关系，它就是非常重要的基础设施——DNS 服务器。DNS 服务器是一个分布式数据库，分布在世界各地。</p>
<p>为提高效率，DNS 是按照一定的结构进行组织的，不同层次之间按照英文句点。来分割。</p>
<p>在域名中，我们的层级关系是按照从左到右、从低到高排列的，不同层级由低到高维护了一个树形结构，最高一级的根节点为 root 节点，就是我们所谓的根域名服务器，因此 cosmos.com 完整的域名应该是 cosmos.com.，后面的 . 相当于.root。</p>
<p>但是所有域名的顶级域名都一样，因此被省略；再下一级.com 为顶级域名；再下一级的 cosmos 为权威域名。</p>
<p>因为这是一个树形结构，所以客户端只要请求到一个 DNS 服务器，就可以一层层递归和迭代查找到所有的 DNS 服务器了。按照由高到低的优先级，DNS 域名解析的过程排列如下。</p>
<p>DNS 解析 &gt; 浏览器 DNS 缓存 &gt; hosts 文件 &gt; 本地 DNS 服务器 &gt; ISP DNS 服务器</p>
<h2 id="操作系统协议栈传输层和网络层">操作系统协议栈（传输层和网络层）</h2>
<p>现在我们已经根据 URL 拿到需要请求的唯一地址了，接下来就要委托操作系统将 HTTP 报文发送出去了，这个过程由操作系统中的协议栈负责处理。</p>
<p>TCP/IP 协议栈是现在使用最广泛的网络协议栈，Internet 就是建立在 TCP/IP 协议栈基础上的。除 TCP/IP 协议栈外，我们的操作系统内核可以支持多个不同的协议栈，如后续我们将会用到的 LwIp。</p>
<p>协议栈内部分为几部分，分别承担着不同的作用。协议栈的上半部分负责和应用层通过套接字（Socket）进行交互，它可以是 TCP 协议或 UDP 协议。应用层会委托协议栈的上部分完成收发数据的工作；而协议栈的下半部分则负责把数据发送给到指定方的 IP 协议，由 IP 协议连接下层的网卡驱动。</p>
<h3 id="可靠性传输建立-tcp-连接">可靠性传输：建立 TCP 连接</h3>
<p>浏览器通过 DNS 解析拿到 Cosmos 的 IP 地址后，浏览器取出 URL 的端口（HTTP 默认 80，HTTPS 默认 443）。随即浏览器会委托操作系统协议栈的上半部分创建新的套接字（Socket）向对应的 IP 发起 <code>TCP</code> 连接请求。</p>
<p>为了确保通信的可靠性，建立 TCP 首先会先进行三次握手的操作，我们可以结合后面的图示理解。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/e50f16284c9ef2aa1ecc0cb9c58d5796.png" alt=""></p>
<p>TCP 握手示意图</p>
<p>那么 TCP 的三次握手操作，是如何进行的呢？具体的操作步骤如下。</p>
<p>1. 首先浏览器作为客户端会发送一个小的 TCP 分组，这个分组设置了一个特殊的 <code>SYN</code> 标记，用来表示这是一条连接请求。同时设置初始序列号为 <code>x</code> 赋值给 <code>Seq</code> （这次捕获组的数据为：SYN=1, Seq=1）。</p>
<p>2. 服务器接受到客户端的 <code>SYN</code> 连接后，会选择服务器初始序号 <code>y</code>。同时向客户端发送含有连接确认（<code>SYN+ACK</code>）、<code>Seq=0</code>（本例中的服务器初始序号）、<code>Ack=1</code>（客户端的序号 x +1）等信息的 TCP 分组。</p>
<p>3. 客户端收到了服务器的确定字段后，向服务器发送带有 <code>ACK=1</code>、<code>Seq=1</code> (x+1)、<code>Ack=1</code> （服务器 Ack 信息的拷贝）等字段的 TCP 分组给服务器。</p>
<p>即使是发送一个 TCP 分组，也是一次网络通信，那么对于 TCP 层来说，这一次通信的数据前面就要包含一个 TCP 包头，向下层表明这是个 TCP 数据包。TCP 包头其实是一个数据结构，我为你准备了一幅图，以便理解。</p>
<p>下图就是 TCP 的包头，对于 TCP 头部来说，以下几个字段是很重要的，你要格外关注。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/3a1eec39a42342b9510919aed25fd468.png" alt=""></p>
<p>TCP 包头</p>
<p>首先，源端口号（Source port）和目标端口号（Destinantion port）是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</p>
<p>其次，你需要注意的是一串有序数字 Sequence number，这个序号保证了 TCP 报文是有序被接受的，解决网络包的乱序问题。</p>
<p>之后的 Acknowledgement number 是确认号，只有对方确认收到，否则会一直重发，这个是防止数据包丢失的。</p>
<p>紧接着还有一些状态位，由于 TCP 是有状态的，是用于维护双方连接的状态，状态发生变更会更新双方的连接状态。后面还有一个，窗口大小 Window Size，用于流量控制。</p>
<p>TCP 层封装好了数据包，会将这个 TCP 数据包向下层发送，而 TCP 层的下层就是 IP 层，下面我们一起去瞧一瞧完成目的地定位的 IP 层。</p>
<h3 id="目的地定位ip-层">目的地定位：IP 层</h3>
<p>TCP 在维护状态的过程中，都需要委托 IP 层将数据封装，发送和处理网络数据包进入网络层。<strong>IP 协议是 TCP/IP 协议栈的核心</strong>，IP 协议中规定了在 Internet 上进行通信时应遵循的规则，包括 IP 数据包应如何构成、数据包的路由等，而 IP 层实现了网络上的点对点通信。</p>
<p>我们首先来看看 IP 层处理上层网络数据包的过程，网络数据包（无论输入数据包还是输出数据包）进入网络层后，IP 层协议的函数都要对网络数据包做后面这 5 步操作。</p>
<p>1. 数据包校验和检验</p>
<p>2. 防火墙对数据包过滤</p>
<p>3.IP 选项处理</p>
<p>4. 数据分片和重组</p>
<p>5. 接收、发送和前送</p>
<p>为了完成上述操作，IP 层被设计成三个部分，分别是 <strong>IP 寻址、路由和分包组包</strong>。现在我们并不关注这三个部分的具体实现，仅仅是熟悉这个流程就好了。</p>
<p>其实在网络通信的过程中，每个设备都必须拥有自己的 IP 地址才可以完成通信，我们的 IP 地址是以四组八位的组合进行约定，每组以。号隔开，再转化为十进制的方式。这里要注意，IP 地址并不是以主机数目进行配置的，而是根据<strong>网卡数</strong>来进行。</p>
<p>有了 IP 地址，就可以通信了，但 IP 层仍然是一个软件实现的功能逻辑层，那它如何完成通信呢，答案是不能直接完成通信，它只是把 IP 地址及相关信息组装成一个 IP 头，把这个 IP 头放在网络数据的前面，形成了 IP 包，最后把这个 IP 包发送给 IP 层的下一层组件就行了，IP 头的格式如下所示。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/4841cfa41e1358827864a7163b1ecdf5.png" alt=""></p>
<p>IP 头部</p>
<p>有了 IP 头的网络数据，就有了发送目的地的信息，那么该如何才能将报文发送到目的地呢？这就要请 MAC 出场了，这个 MAC 层，就是 IP 层的下一层组件。下面我们一起进入 MAC 层。</p>
<h2 id="点对点传输mac链路层">点对点传输：MAC（链路层）</h2>
<p>我们经常听说网卡 MAC 地址，这个 MAC 地址指的就是计算机网卡的物理地址（Physical Address），MAC 地址被固化到网卡中，用来标识一个网络设备。MAC 地址是唯一且无重复的，由国际标准化组织分配，用来确保网络中的每个网卡是唯一的。</p>
<p>网络数据在 IP 层中加上 IP 头后，形成了 IP 包，现在进入 MAC 层了，我们就需要对 IP 包加上 MAC 头，这个 MAC 头包括<strong>发送方的 MAC 头</strong>和<strong>接收方的 MAC 头</strong>，用于两个物理地址点对点的传输；此外还有一个头部字段为<strong>协议类型</strong>，在常规的 TCP/IP 协议中，MAC 头的协议类型只有 IP 和 ARP 两种。</p>
<p>MAC 头格式如下所示。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/cf72717edea77b96ca4171d5dafba3e9.png" alt=""></p>
<p>MAC 头部</p>
<p>发送方的 MAC 头比较容易获取，读取当前设备网卡的 MAC 地址就可以获取，而接收方的 MAC 头则需要通过 ARP 协议在网络中携带 IP 地址，在一个网络中发送广播信息，这样就能获取这个网络中的 IP 地址对应的 MAC 地址，然后就能给我们的 IP 包加上 MAC 头了，最后这个加上 MAC 头的 IP 包，成为一个 MAC 数据包，就可以准备发送出去了。</p>
<p>下面我们一起进入最后的阶段，数据的发送，即网络层中的最低层——物理层。</p>
<h2 id="电信号的出口网卡物理层">电信号的出口：网卡（物理层）</h2>
<p>现在我们拿到了经过层层处理过的数据包，数据包只是一串二进制数据，然而我们都知道，网络上的数据传送，是依赖电信号的，所以我们现在需要将数据包转化为电信号，才能在物理的网线上面传输。</p>
<p>那么数据包是如何被转换电信号的呢，数据包通过网络协议栈的层层处理，最终得到了 MAC 数据包，这个 MAC 数据包会交给网卡驱动程序，而网卡驱动程序会将 MAC 数据包写入网卡的缓冲区（网卡上的内存）.</p>
<p>然后，网卡会在 MAC 数据包的起止位置加入起止帧和校验序列，最后网卡会将加入起止帧和校验序列的 MAC 数据包转化为电信号，发送出去。</p>
<h2 id="客户端服务端的持续数据交换应用层">客户端服务端的持续数据交换（应用层）</h2>
<p>现在，我们的数据终于通过网卡离开了计算机，进入到局域网，通过局域网中的设备，集线器、交换机和路由器等，数据会进入到互联网，最终到达目标服务器。</p>
<p>接着，服务器就会先取下数据包的 MAC 头部，查看是否匹配自己 MAC 地址。然后继续取下数据包的 IP 头，数据包中的目标 IP 地址和自己的 IP 地址匹配，再根据 IP 头中协议项，知道自己上层是 TCP 协议。</p>
<p>之后，还要继续取下数据包 TCP 的头。完成一系列的顺序校验和状态变更后，TCP 头部里面还有端口号，此时我们的 HTTP 的 server 正在监听这个端口号，就把数据包再发给对应的 HTTP 进程。</p>
<p>HTTP 进程从服务器中拿到对应的资源（HTML 文件），再交给操作系统对数据进行处理。然后再重复上面的过程，层层携带 TCP、IP、MAC 头部。</p>
<p>接下来数据从网卡出去，到达客户端，再重复刚才的过程拿到相应数据。客户端拿到对应的 HTML 资源，浏览器就可以开始解析渲染了，这步操作完成后，用户最终就能通过浏览器看到相应的页面。</p>
<p>我为你画了两幅图，来描述上述过程，第一幅是网络协议各层之间封装与拆封数据的过程，如下所示。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/6cf094622c4d40f72d691ffa3caf53b2.png" alt=""></p>
<p>TCP_IP 协议栈</p>
<p>下面的第二幅图，是描述客户端与服务器之间用网络协议连接通信的过程，如下所示。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/32fe2ca9342bef97a50b4c8f98314f22.png" alt=""></p>
<p>交互过程示意图</p>
<p>我们可以看到，此时客户端和服务端之间通过 TCP 协议维护了一个连接状态，如果客户端需要关闭网络，那么会进行四次挥手，两边的网络传输过程至此完成。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>好，这节课的内容告一段落了，我来给你梳理一下本节课的重点，如下所示。</p>
<p>1. 首先，常规的网络交互过程是从客户端发起网络请求，网络数据包经过各类网络协议的处理，为了约定一套不同设备都能理解的约定，我们引入了网络协议。</p>
<p>2. 然后，在不同的网络协议处理下，给我们的网络数据包加上了各种头部，这保证了网络数据在各层物理设备的流转下可以正确抵达目的地。收到处理后的网络数据包后，接受端再通过网络协议将头部字段去除，得到原始的网络数据。</p>
<p>3. 最后，这节课你需要重点理解<strong>网络协议对数据的处理过程，以及处理过程中的不同协议的数据结构和关键头部字段。</strong></p>
<h2 id="思考题">思考题</h2>
<p>我们这节课从宏观的角度分析了网络数据的运转，但是在内核中网络数据包怎么运转的呢？请你简单描述这个过程。</p>
<p>欢迎你在留言区跟我交流讨论，也欢迎你把这节课分享给你的同事、朋友。</p>
<p>我是 LMOS，我们下节课见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/">操作系统实战45讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/36_facebook%E6%B8%B8%E6%88%8F%E5%AE%9E%E6%97%B6%E6%B5%81%E5%A4%84%E7%90%86beam_pipeline%E5%AE%9E%E6%88%98%E4%B8%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">36_Facebook游戏实时流处理Beam_Pipeline实战（下）</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/36_%E5%BD%93%E5%89%8D%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%AF%B9%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%9A%84%E5%BD%B1%E5%93%8D/">
            <span class="next-text nav-default">36_当前技术的发展趋势以及其对编译技术的影响</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
