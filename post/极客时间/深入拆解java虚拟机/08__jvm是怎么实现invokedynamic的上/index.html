<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>08__JVM是怎么实现invokedynamic的？（上） - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="前不久，“虚拟机”赛马俱乐部来了个年轻人，标榜自己是动态语言，是先进分子。
这一天，先进分子牵着一头鹿进来，说要参加赛马。咱部里的老学究 Java 就不同意了呀，鹿又不是马，哪能参加赛马。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/08__jvm%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0invokedynamic%E7%9A%84%E4%B8%8A/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/08__jvm%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0invokedynamic%E7%9A%84%E4%B8%8A/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="08__JVM是怎么实现invokedynamic的？（上）">
  <meta property="og:description" content="前不久，“虚拟机”赛马俱乐部来了个年轻人，标榜自己是动态语言，是先进分子。
这一天，先进分子牵着一头鹿进来，说要参加赛马。咱部里的老学究 Java 就不同意了呀，鹿又不是马，哪能参加赛马。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="深入拆解Java虚拟机">

  <meta itemprop="name" content="08__JVM是怎么实现invokedynamic的？（上）">
  <meta itemprop="description" content="前不久，“虚拟机”赛马俱乐部来了个年轻人，标榜自己是动态语言，是先进分子。
这一天，先进分子牵着一头鹿进来，说要参加赛马。咱部里的老学究 Java 就不同意了呀，鹿又不是马，哪能参加赛马。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4752">
  <meta itemprop="keywords" content="深入拆解Java虚拟机">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="08__JVM是怎么实现invokedynamic的？（上）">
  <meta name="twitter:description" content="前不久，“虚拟机”赛马俱乐部来了个年轻人，标榜自己是动态语言，是先进分子。
这一天，先进分子牵着一头鹿进来，说要参加赛马。咱部里的老学究 Java 就不同意了呀，鹿又不是马，哪能参加赛马。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">08__JVM是怎么实现invokedynamic的？（上）</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4752 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#方法句柄的概念">方法句柄的概念</a></li>
        <li><a href="#方法句柄的操作">方法句柄的操作</a></li>
        <li><a href="#方法句柄的实现">方法句柄的实现</a></li>
        <li><a href="#总结与实践">总结与实践</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>前不久，“虚拟机”赛马俱乐部来了个年轻人，标榜自己是动态语言，是先进分子。</p>
<p>这一天，先进分子牵着一头鹿进来，说要参加赛马。咱部里的老学究 Java 就不同意了呀，鹿又不是马，哪能参加赛马。</p>
<p>当然了，这种墨守成规的调用方式，自然是先进分子所不齿的。现在年轻人里流行的是鸭子类型（duck typing）[1]，只要是跑起来像只马的，它就是一只马，也就能够参加赛马比赛。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Horse {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  public void race() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    System.out.println(&#34;Horse.race()&#34;); 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> class Deer {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  public void race() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    System.out.println(&#34;Deer.race()&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> class Cobra {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  public void race() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    System.out.println(&#34;How do you turn this on?&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>(如何用同一种方式调用他们的赛跑方法？)</p>
<p>说到了这里，如果我们将赛跑定义为对赛跑方法（对应上述代码中的 race()）的调用的话，那么这个故事的关键，就在于能不能在马场中调用非马类型的赛跑方法。</p>
<p>为了解答这个问题，我们先来回顾一下 Java 里的方法调用。在 Java 中，方法调用会被编译为 invokestatic，invokespecial，invokevirtual 以及 invokeinterface 四种指令。这些指令与包含目标方法类名、方法名以及方法描述符的符号引用捆绑。在实际运行之前，Java 虚拟机将根据这个符号引用链接到具体的目标方法。</p>
<p>可以看到，在这四种调用指令中，Java 虚拟机明确要求方法调用需要提供目标方法的类名。在这种体系下，我们有两个解决方案。一是调用其中一种类型的赛跑方法，比如说马类的赛跑方法。对于非马的类型，则给它套一层马甲，当成马来赛跑。</p>
<p>另外一种解决方式，是通过反射机制，来查找并且调用各个类型中的赛跑方法，以此模拟真正的赛跑。</p>
<p>显然，比起直接调用，这两种方法都相当复杂，执行效率也可想而知。为了解决这个问题，Java 7 引入了一条新的指令 invokedynamic。该指令的调用机制抽象出调用点这一个概念，并允许应用程序将调用点链接至任意符合条件的方法上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="n">public</span> <span class="k">static</span> <span class="n">void</span> <span class="n">startRace</span><span class="p">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="n">Object</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="mi">0</span><span class="p">:</span> <span class="n">aload_0</span>                <span class="o">//</span> <span class="err">加载一个任意对象</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="mi">1</span><span class="p">:</span> <span class="n">invokedynamic</span> <span class="n">race</span>     <span class="o">//</span> <span class="err">调用赛跑方法</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>(理想的调用方式)</p>
<p>作为 invokedynamic 的准备工作，Java 7 引入了更加底层、更加灵活的方法抽象：方法句柄（MethodHandle）。</p>
<h2 id="方法句柄的概念">方法句柄的概念</h2>
<p>方法句柄是一个强类型的，能够被直接执行的引用 [2]。该引用可以指向常规的静态方法或者实例方法，也可以指向构造器或者字段。当指向字段时，方法句柄实则指向包含字段访问字节码的虚构方法，语义上等价于目标字段的 getter 或者 setter 方法。</p>
<p>这里需要注意的是，它并不会直接指向目标字段所在类中的 getter/setter，毕竟你无法保证已有的 getter/setter 方法就是在访问目标字段。</p>
<p>方法句柄的类型（MethodType）是由所指向方法的参数类型以及返回类型组成的。它是用来确认方法句柄是否适配的唯一关键。当使用方法句柄时，我们其实并不关心方法句柄所指向方法的类名或者方法名。</p>
<p>打个比方，如果兔子的“赛跑”方法和“睡觉”方法的参数类型以及返回类型一致，那么对于兔子递过来的一个方法句柄，我们并不知道会是哪一个方法。</p>
<p>方法句柄的创建是通过 MethodHandles.Lookup 类来完成的。它提供了多个 API，既可以使用反射 API 中的 Method 来查找，也可以根据类、方法名以及方法句柄类型来查找。</p>
<p>当使用后者这种查找方式时，用户需要区分具体的调用类型，比如说对于用 invokestatic 调用的静态方法，我们需要使用 Lookup.findStatic 方法；对于用 invokevirutal 调用的实例方法，以及用 invokeinterface 调用的接口方法，我们需要使用 findVirtual 方法；对于用 invokespecial 调用的实例方法，我们则需要使用 findSpecial 方法。</p>
<p>调用方法句柄，和原本对应的调用指令是一致的。也就是说，对于原本用 invokevirtual 调用的方法句柄，它也会采用动态绑定；而对于原本用 invkespecial 调用的方法句柄，它会采用静态绑定。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Foo {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  private static void bar(Object o) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ..
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  public static Lookup lookup() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return MethodHandles.lookup();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 获取方法句柄的不同方式
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">MethodHandles.Lookup l = Foo.lookup(); // 具备 Foo 类的访问权限
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Method m = Foo.class.getDeclaredMethod(&#34;bar&#34;, Object.class);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">MethodHandle mh0 = l.unreflect(m);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> MethodType t = MethodType.methodType(void.class, Object.class);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">MethodHandle mh1 = l.findStatic(Foo.class, &#34;bar&#34;, t);
</span></span></code></pre></td></tr></table>
</div>
</div><p>方法句柄同样也有权限问题。但它与反射 API 不同，其权限检查是在句柄的创建阶段完成的。在实际调用过程中，Java 虚拟机并不会检查方法句柄的权限。如果该句柄被多次调用的话，那么与反射调用相比，它将省下重复权限检查的开销。</p>
<p>需要注意的是，方法句柄的访问权限不取决于方法句柄的创建位置，而是取决于 Lookup 对象的创建位置。</p>
<p>举个例子，对于一个私有字段，如果 Lookup 对象是在私有字段所在类中获取的，那么这个 Lookup 对象便拥有对该私有字段的访问权限，即使是在所在类的外边，也能够通过该 Lookup 对象创建该私有字段的 getter 或者 setter。</p>
<p>由于方法句柄没有运行时权限检查，因此，应用程序需要负责方法句柄的管理。一旦它发布了某些指向私有方法的方法句柄，那么这些私有方法便被暴露出去了。</p>
<h2 id="方法句柄的操作">方法句柄的操作</h2>
<p>方法句柄的调用可分为两种，一是需要严格匹配参数类型的 invokeExact。它有多严格呢？假设一个方法句柄将接收一个 Object 类型的参数，如果你直接传入 String 作为实际参数，那么方法句柄的调用会在运行时抛出方法类型不匹配的异常。正确的调用方式是将该 String 显式转化为 Object 类型。</p>
<p>在普通 Java 方法调用中，我们只有在选择重载方法时，才会用到这种显式转化。这是因为经过显式转化后，参数的声明类型发生了改变，因此有可能匹配到不同的方法描述符，从而选取不同的目标方法。调用方法句柄也是利用同样的原理，并且涉及了一个签名多态性（signature polymorphism）的概念。（在这里我们暂且认为签名等同于方法描述符。）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  public final native @PolymorphicSignature Object invokeExact(Object... args) throws Throwable;
</span></span></code></pre></td></tr></table>
</div>
</div><p>方法句柄 API 有一个特殊的注解类 @PolymorphicSignature。在碰到被它注解的方法调用时，Java 编译器会根据所传入参数的声明类型来生成方法描述符，而不是采用目标方法所声明的描述符。</p>
<p>在刚才的例子中，当传入的参数是 String 时，对应的方法描述符包含 String 类；而当我们转化为 Object 时，对应的方法描述符则包含 Object 类。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">public</span> <span class="n">void</span> <span class="n">test</span><span class="p">(</span><span class="n">MethodHandle</span> <span class="n">mh</span><span class="p">,</span> <span class="ne">String</span> <span class="n">s</span><span class="p">)</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mh</span><span class="o">.</span><span class="n">invokeExact</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mh</span><span class="o">.</span><span class="n">invokeExact</span><span class="p">((</span><span class="ne">Object</span><span class="p">)</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="o">//</span> <span class="err">对应的</span> <span class="n">Java</span> <span class="err">字节码</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">public</span> <span class="n">void</span> <span class="n">test</span><span class="p">(</span><span class="n">MethodHandle</span><span class="p">,</span> <span class="ne">String</span><span class="p">)</span> <span class="n">throws</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="n">Throwable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Code</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="mi">0</span><span class="p">:</span> <span class="n">aload_1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="mi">1</span><span class="p">:</span> <span class="n">aload_2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="mi">2</span><span class="p">:</span> <span class="n">invokevirtual</span> <span class="n">MethodHandle</span><span class="o">.</span><span class="n">invokeExact</span><span class="p">:(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="ne">String</span><span class="p">;)</span><span class="n">V</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="mi">5</span><span class="p">:</span> <span class="n">aload_1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="mi">6</span><span class="p">:</span> <span class="n">aload_2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="mi">7</span><span class="p">:</span> <span class="n">invokevirtual</span> <span class="n">MethodHandle</span><span class="o">.</span><span class="n">invokeExact</span><span class="p">:(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="ne">Object</span><span class="p">;)</span><span class="n">V</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="mi">10</span><span class="p">:</span> <span class="k">return</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>invokeExact 会确认该 invokevirtual 指令对应的方法描述符，和该方法句柄的类型是否严格匹配。在不匹配的情况下，便会在运行时抛出异常。</p>
<p>如果你需要自动适配参数类型，那么你可以选取方法句柄的第二种调用方式 invoke。它同样是一个签名多态性的方法。invoke 会调用 MethodHandle.asType 方法，生成一个适配器方法句柄，对传入的参数进行适配，再调用原方法句柄。调用原方法句柄的返回值同样也会先进行适配，然后再返回给调用者。</p>
<p>方法句柄还支持增删改参数的操作，这些操作都是通过生成另一个方法句柄来实现的。这其中，改操作就是刚刚介绍的 MethodHandle.asType 方法。删操作指的是将传入的部分参数就地抛弃，再调用另一个方法句柄。它对应的 API 是 MethodHandles.dropArguments 方法。</p>
<p>增操作则非常有意思。它会往传入的参数中插入额外的参数，再调用另一个方法句柄，它对应的 API 是 MethodHandle.bindTo 方法。Java 8 中捕获类型的 Lambda 表达式便是用这种操作来实现的，下一篇我会详细进行解释。</p>
<p>增操作还可以用来实现方法的柯里化 [3]。举个例子，有一个指向 f(x, y) 的方法句柄，我们可以通过将 x 绑定为 4，生成另一个方法句柄 g(y) = f(4, y)。在执行过程中，每当调用 g(y) 的方法句柄，它会在参数列表最前面插入一个 4，再调用指向 f(x, y) 的方法句柄。</p>
<h2 id="方法句柄的实现">方法句柄的实现</h2>
<p>下面我们来看看 HotSpot 虚拟机中方法句柄调用的具体实现。（由于篇幅原因，这里只讨论 DirectMethodHandle。）</p>
<p>前面提到，调用方法句柄所使用的 invokeExact 或者 invoke 方法具备签名多态性的特性。它们会根据具体的传入参数来生成方法描述符。那么，拥有这个描述符的方法实际存在吗？对 invokeExact 或者 invoke 的调用具体会进入哪个方法呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">import java.lang.invoke.*;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> public class Foo {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  public static void bar(Object o) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    new Exception().printStackTrace();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   public static void main(String[] args) throws Throwable {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MethodHandles.Lookup l = MethodHandles.lookup();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MethodType t = MethodType.methodType(void.class, Object.class);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MethodHandle mh = l.findStatic(Foo.class, &#34;bar&#34;, t);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    mh.invokeExact(new Object());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>和查阅反射调用的方式一样，我们可以通过新建异常实例来查看栈轨迹。打印出来的占轨迹如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ java Foo
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">java.lang.Exception
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        at Foo.bar(Foo.java:5)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        at Foo.main(Foo.java:12)
</span></span></code></pre></td></tr></table>
</div>
</div><p>也就是说，invokeExact 的目标方法竟然就是方法句柄指向的方法。</p>
<p>先别高兴太早。我刚刚提到过，invokeExact 会对参数的类型进行校验，并在不匹配的情况下抛出异常。如果它直接调用了方法句柄所指向的方法，那么这部分参数类型校验的逻辑将无处安放。因此，唯一的可能便是 Java 虚拟机隐藏了部分栈信息。</p>
<p>当我们启用了 -XX:+ShowHiddenFrames 这个参数来打印被 Java 虚拟机隐藏了的栈信息时，你会发现 main 方法和目标方法中间隔着两个貌似是生成的方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ java -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames Foo
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">java.lang.Exception
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        at Foo.bar(Foo.java:5)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        at java.base/java.lang.invoke.DirectMethodHandle$Holder. invokeStatic(DirectMethodHandle$Holder:1000010)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        at java.base/java.lang.invoke.LambdaForm$MH000/766572210. invokeExact_MT000_LLL_V(LambdaForm$MH000:1000019)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        at Foo.main(Foo.java:12)
</span></span></code></pre></td></tr></table>
</div>
</div><p>实际上，Java 虚拟机会对 invokeExact 调用做特殊处理，调用至一个共享的、与方法句柄类型相关的特殊适配器中。这个适配器是一个 LambdaForm，我们可以通过添加虚拟机参数将之导出成 class 文件（-Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=true）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">final</span> <span class="k">class</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="n">invoke</span><span class="o">.</span><span class="n">LambdaForm</span><span class="o">$</span><span class="n">MH000</span> <span class="p">{</span>  <span class="k">static</span> <span class="n">void</span> <span class="n">invokeExact_MT000_LLLLV</span><span class="p">(</span><span class="n">jeava</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="n">bject</span><span class="p">,</span> <span class="n">jjava</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="n">bject</span><span class="p">,</span> <span class="n">jjava</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="n">bject</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Code</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">:</span> <span class="n">aload_0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="mi">1</span> <span class="p">:</span> <span class="n">checkcast</span>      <span class="c1">#14                 //Mclass java/lang/invoke/ethodHandle</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">:</span> <span class="n">dup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="mi">5</span> <span class="p">:</span> <span class="n">astore_0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">:</span> <span class="n">aload_32</span>        <span class="p">:</span> <span class="n">checkcast</span>      <span class="c1">#16                 //Mclass java/lang/invoke/ethodType</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="mi">10</span><span class="p">:</span> <span class="n">invokestatic</span>  <span class="n">I</span><span class="c1">#22                 // Method java/lang/invoke/nvokers.checkExactType:(MLjava/lang/invoke/ethodHandle,;Ljava/lang/invoke/ethodType);V</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="mi">13</span><span class="p">:</span> <span class="n">aload_0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="mi">14</span><span class="p">:</span> <span class="n">invokestatic</span>   <span class="c1">#26     I           // Method java/lang/invoke/nvokers.checkCustomized:(MLjava/lang/invoke/ethodHandle);V</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="mi">17</span><span class="p">:</span> <span class="n">aload_0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="mi">18</span><span class="p">:</span> <span class="n">aload_1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="mi">19</span><span class="p">:</span> <span class="n">ainvakevirtudl</span> <span class="c1">#30             2   // Methodijava/lang/nvokev/ethodHandle.invokeBasic:(LLeava/lang/bject;;V</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="mi">23</span> <span class="k">return</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，在这个适配器中，它会调用 Invokers.checkExactType 方法来检查参数类型，然后调用 Invokers.checkCustomized 方法。后者会在方法句柄的执行次数超过一个阈值时进行优化（对应参数 -Djava.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD，默认值为 127）。最后，它会调用方法句柄的 invokeBasic 方法。</p>
<p>Java 虚拟机同样会对 invokeBasic 调用做特殊处理，这会将调用至方法句柄本身所持有的适配器中。这个适配器同样是一个 LambdaForm，你可以通过反射机制将其打印出来。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 该方法句柄持有的 LambdaForm 实例的 toString() 结果
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">DMH.invokeStatic_L_V=Lambda(a0:L,a1:L)=&gt;{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  t2:L=DirectMethodHandle.internalMemberName(a0:L);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  t3:V=MethodHandle.linkToStatic(a1:L,t2:L);void}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个适配器将获取方法句柄中的 MemberName 类型的字段，并且以它为参数调用 linkToStatic 方法。估计你已经猜到了，Java 虚拟机也会对 linkToStatic 调用做特殊处理，它将根据传入的 MemberName 参数所存储的方法地址或者方法表索引，直接跳转至目标方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">final class MemberName implements Member, Cloneable {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //@Injected JVM_Method* vmtarget;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //@Injected int         vmindex;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么前面那个适配器中的优化又是怎么回事？实际上，方法句柄一开始持有的适配器是共享的。当它被多次调用之后，Invokers.checkCustomized 方法会为该方法句柄生成一个特有的适配器。这个特有的适配器会将方法句柄作为常量，直接获取其 MemberName 类型的字段，并继续后面的 linkToStatic 调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">final</span> <span class="k">class</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="n">invoke</span><span class="o">.</span><span class="n">LambdaForm</span><span class="o">$</span><span class="n">DMH000</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="n">void</span> <span class="n">invokeStatic000_LL_V</span><span class="p">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="n">Object</span><span class="p">,</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="n">Object</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Code</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="mi">0</span><span class="p">:</span> <span class="n">ldc</span>           <span class="c1">#14                 // String CONSTANT_PLACEHOLDER_1 &lt;&lt;Foo.bar(Object)void/invokeStatic&gt;&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="mi">2</span><span class="p">:</span> <span class="n">checkcast</span>     <span class="c1">#16                 // class java/lang/invoke/MethodHandle</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="mi">5</span><span class="p">:</span> <span class="n">astore_0</span>     <span class="o">//</span> <span class="err">上面的优化代码覆盖了传入的方法句柄</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="mi">6</span><span class="p">:</span> <span class="n">aload_0</span>      <span class="o">//</span> <span class="err">从这里开始跟初始版本一致</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="mi">7</span><span class="p">:</span> <span class="n">invokestatic</span>  <span class="c1">#22                 // Method java/lang/invoke/DirectMethodHandle.internalMemberName:(Ljava/lang/Object;)Ljava/lang/Object;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="mi">10</span><span class="p">:</span> <span class="n">astore_2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="mi">11</span><span class="p">:</span> <span class="n">aload_1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="mi">12</span><span class="p">:</span> <span class="n">aload_2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="mi">13</span><span class="p">:</span> <span class="n">checkcast</span>     <span class="c1">#24                 // class java/lang/invoke/MemberName</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="mi">16</span><span class="p">:</span> <span class="n">invokestatic</span>  <span class="c1">#28                 // Method java/lang/invoke/MethodHandle.linkToStatic:(Ljava/lang/Object;Ljava/lang/invoke/MemberName;)V</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="mi">19</span><span class="p">:</span> <span class="k">return</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，方法句柄的调用和反射调用一样，都是间接调用。因此，它也会面临无法内联的问题。不过，与反射调用不同的是，方法句柄的内联瓶颈在于即时编译器能否将该方法句柄识别为常量。具体内容我会在下一篇中进行详细的解释。</p>
<h2 id="总结与实践">总结与实践</h2>
<p>今天我介绍了 invokedynamic 底层机制的基石：方法句柄。</p>
<p>方法句柄是一个强类型的、能够被直接执行的引用。它仅关心所指向方法的参数类型以及返回类型，而不关心方法所在的类以及方法名。方法句柄的权限检查发生在创建过程中，相较于反射调用节省了调用时反复权限检查的开销。</p>
<p>方法句柄可以通过 invokeExact 以及 invoke 来调用。其中，invokeExact 要求传入的参数和所指向方法的描述符严格匹配。方法句柄还支持增删改参数的操作，这些操作是通过生成另一个充当适配器的方法句柄来实现的。</p>
<p>方法句柄的调用和反射调用一样，都是间接调用，同样会面临无法内联的问题。</p>
<p>今天的实践环节，我们来测量一下方法句柄的性能。你可以尝试通过重构代码，将方法句柄变成常量，来提升方法句柄调用的性能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class Foo {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  public void bar(Object o) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   public static void main(String[] args) throws Throwable {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MethodHandles.Lookup l = MethodHandles.lookup();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MethodType t = MethodType.methodType(void.class, Object.class);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MethodHandle mh = l.findVirtual(Foo.class, &#34;bar&#34;, t);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     long current = System.currentTimeMillis();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (int i = 1; i &lt;= 2_000_000_000; i++) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      if (i % 100_000_000 == 0) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        long temp = System.currentTimeMillis();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(temp - current);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        current = temp;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       mh.invokeExact(new Foo(), new Object());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>[1] <a href="https://en.wikipedia.org/wiki/Duck%5Ftyping">https://en.wikipedia.org/wiki/Duck%5Ftyping</a><br>
[2]<br>
<a href="https://docs.oracle.com/javase/10/docs/api/java/lang/invoke/MethodHandle.html">https://docs.oracle.com/javase/10/docs/api/java/lang/invoke/MethodHandle.html</a><br>
[3]<br>
<a href="https://en.wikipedia.org/wiki/Currying">https://en.wikipedia.org/wiki/Currying</a></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/a500044f1e4938fb43719f802cba82d8.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/">深入拆解Java虚拟机</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/08__javascript%E5%AF%B9%E8%B1%A1%E4%BD%A0%E7%9F%A5%E9%81%93%E5%85%A8%E9%83%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB%E5%90%97/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">08__JavaScript对象：你知道全部的对象分类吗？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/openresty%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/08__luajit%E5%88%86%E6%94%AF%E5%92%8C%E6%A0%87%E5%87%86lua%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/">
            <span class="next-text nav-default">08__LuaJIT分支和标准Lua有什么不同？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
