<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>16__容器网络配置（1）：容器网络不通了要怎么调试_ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是程远。
在上一讲，我们讲了 Network Namespace 隔离了网络设备，IP 协议栈和路由表，以及防火墙规则，那容器 Network Namespace 里的参数怎么去配置，我们现在已经很清楚了。
其实对于网络配置的问题，我们还有一个最需要关心的内容，那就是容器和外面的容器或者节点是怎么通讯的，这就涉及到了容器网络接口配置的问题了。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/16__%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE1%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B8%8D%E9%80%9A%E4%BA%86%E8%A6%81%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95_/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/16__%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE1%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B8%8D%E9%80%9A%E4%BA%86%E8%A6%81%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95_/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="16__容器网络配置（1）：容器网络不通了要怎么调试_">
  <meta property="og:description" content="你好，我是程远。
在上一讲，我们讲了 Network Namespace 隔离了网络设备，IP 协议栈和路由表，以及防火墙规则，那容器 Network Namespace 里的参数怎么去配置，我们现在已经很清楚了。
其实对于网络配置的问题，我们还有一个最需要关心的内容，那就是容器和外面的容器或者节点是怎么通讯的，这就涉及到了容器网络接口配置的问题了。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="容器实战高手课">

  <meta itemprop="name" content="16__容器网络配置（1）：容器网络不通了要怎么调试_">
  <meta itemprop="description" content="你好，我是程远。
在上一讲，我们讲了 Network Namespace 隔离了网络设备，IP 协议栈和路由表，以及防火墙规则，那容器 Network Namespace 里的参数怎么去配置，我们现在已经很清楚了。
其实对于网络配置的问题，我们还有一个最需要关心的内容，那就是容器和外面的容器或者节点是怎么通讯的，这就涉及到了容器网络接口配置的问题了。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4699">
  <meta itemprop="keywords" content="容器实战高手课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="16__容器网络配置（1）：容器网络不通了要怎么调试_">
  <meta name="twitter:description" content="你好，我是程远。
在上一讲，我们讲了 Network Namespace 隔离了网络设备，IP 协议栈和路由表，以及防火墙规则，那容器 Network Namespace 里的参数怎么去配置，我们现在已经很清楚了。
其实对于网络配置的问题，我们还有一个最需要关心的内容，那就是容器和外面的容器或者节点是怎么通讯的，这就涉及到了容器网络接口配置的问题了。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">16__容器网络配置（1）：容器网络不通了要怎么调试_</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4699 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#问题再现">问题再现</a></li>
      </ul>
    </li>
    <li><a href="#docker-run--d---name-if-test-centos811911-sleep-36000">docker run -d &ndash;name if-test centos:8.1.1911 sleep 36000</a></li>
    <li><a href="#docker-exec--it-if-test-bash">docker exec -it if-test bash</a></li>
    <li><a href="#ping-39106233176-------------------------宿主机上可以-ping-通">ping 39.106.233.176                        ### 宿主机上可以 ping 通</a>
      <ul>
        <li><a href="#基本概念">基本概念</a></li>
      </ul>
    </li>
    <li><a href="#docker-run--d---name-if-test---network-none-centos811911-sleep-36000">docker run -d &ndash;name if-test &ndash;network none centos:8.1.1911 sleep 36000</a></li>
    <li><a href="#docker-exec--it-if-test-ip-addr">docker exec -it if-test ip addr</a></li>
    <li><a href="#create-a-pair-of-veth-interfaces">Create a pair of veth interfaces</a></li>
    <li><a href="#put-one-of-them-in-the-new-net-ns">Put one of them in the new net ns</a></li>
    <li><a href="#in-the-container-setup-veth_container">In the container, setup veth_container</a></li>
    <li><a href="#in-the-host-set-veth_host-up">In the host, set veth_host up</a></li>
    <li><a href="#ip-addr-add-172171116-dev-veth_host">ip addr add 172.17.1.1/16 dev veth_host</a></li>
    <li><a href="#docker-exec--it-if-test-ping-1721711">docker exec -it if-test ping 172.17.1.1</a></li>
    <li><a href="#ip-addr-delete-172171116-dev-veth_host">ip addr delete 172.17.1.1/16 dev veth_host</a>
      <ul>
        <li><a href="#解决问题">解决问题</a></li>
      </ul>
    </li>
    <li><a href="#ip-netns-exec-pid-tcpdump--i-eth0-host-39106233176--nn">ip netns exec $pid tcpdump -i eth0 host 39.106.233.176 -nn</a></li>
    <li><a href="#tcpdump--i-veth_host-host-39106233176--nn">tcpdump -i veth_host host 39.106.233.176 -nn</a></li>
    <li><a href="#tcpdump--i-docker0-host-39106233176--nn">tcpdump -i docker0 host 39.106.233.176 -nn</a></li>
    <li><a href="#tcpdump--i-eth0-host-39106233176--nn">tcpdump -i eth0 host 39.106.233.176 -nn</a></li>
    <li><a href="#iptables--l---t-nat">iptables -L  -t nat</a></li>
    <li><a href="#cat-procsysnetipv4ip_forward">cat /proc/sys/net/ipv4/ip_forward</a></li>
    <li><a href="#echo-1--procsysnetipv4ip_forward">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</a></li>
    <li><a href="#docker-exec--it-if-test-ping-39106233176">docker exec -it if-test ping 39.106.233.176</a>
      <ul>
        <li><a href="#重点小结">重点小结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是程远。</p>
<p>在上一讲，我们讲了 Network Namespace 隔离了网络设备，IP 协议栈和路由表，以及防火墙规则，那容器 Network Namespace 里的参数怎么去配置，我们现在已经很清楚了。</p>
<p>其实对于网络配置的问题，我们还有一个最需要关心的内容，那就是容器和外面的容器或者节点是怎么通讯的，这就涉及到了容器网络接口配置的问题了。</p>
<p>所以这一讲呢，我们就来聊一聊，容器 Network Namespace 里如何配置网络接口，还有当容器网络不通的时候，我们应该怎么去做一个简单调试。</p>
<h2 id="问题再现">问题再现</h2>
<p>在前面的课程里，我们一直是用 <code>docker run</code> 这个命令来启动容器的。容器启动了之后，我们也可以看到，在容器里面有一个&quot;eth0&quot;的网络接口，接口上也配置了一个 IP 地址。</p>
<p>不过呢，如果我们想从容器里访问外面的一个 IP 地址，比如说 39.106.233.176（这个是极客时间网址对应的 IP），结果就发现是不能 ping 通的。</p>
<p>这时我们可能会想到，到底是不是容器内出了问题，在容器里无法访问，会不会宿主机也一样不行呢？</p>
<p>所以我们需要验证一下，首先我们退出容器，然后在宿主机的 Network Namespace 下，再运行 <code>ping 39.106.233.176</code>，结果就会发现在宿主机上，却是可以连通这个地址的。</p>
<h1 id="docker-run--d---name-if-test-centos811911-sleep-36000">docker run -d &ndash;name if-test centos:8.1.1911 sleep 36000</h1>
<p>244d44f94dc2931626194c6fd3f99cec7b7c4bf61aafc6c702551e2c5ca2a371</p>
<h1 id="docker-exec--it-if-test-bash">docker exec -it if-test bash</h1>
<p>[root@244d44f94dc2 /]# ip addr<br>
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>
inet 127.0.0.1/8 scope host lo<br>
valid_lft forever preferred_lft forever<br>
808: eth0@if809: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default<br>
link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0<br>
inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0<br>
valid_lft forever preferred_lft forever</p>
<p>[root@244d44f94dc2 /]# ping 39.106.233.176       ### 容器中无法 ping 通<br>
PING 39.106.233.176 (39.106.233.176) 56(84) bytes of data.<br>
^C<br>
&mdash; 39.106.233.176 ping statistics &mdash;<br>
9 packets transmitted, 0 received, 100% packet loss, time 185ms</p>
<p>[root@244d44f94dc2 /]# exit             ###退出容器<br>
exit</p>
<h1 id="ping-39106233176-------------------------宿主机上可以-ping-通">ping 39.106.233.176                        ### 宿主机上可以 ping 通</h1>
<p>PING 39.106.233.176 (39.106.233.176) 56(84) bytes of data.<br>
64 bytes from 39.106.233.176: icmp_seq=1 ttl=78 time=296 ms<br>
64 bytes from 39.106.233.176: icmp_seq=2 ttl=78 time=306 ms<br>
64 bytes from 39.106.233.176: icmp_seq=3 ttl=78 time=303 ms<br>
^C<br>
&mdash; 39.106.233.176 ping statistics &mdash;<br>
4 packets transmitted, 3 received, 25% packet loss, time 7ms<br>
rtt min/avg/max/mdev = 296.059/301.449/305.580/4.037 ms</p>
<p>那么碰到这种容器内网络不通的问题，我们应该怎么分析调试呢？我们还是需要先来理解一下，容器 Network Namespace 里的网络接口是怎么配置的。</p>
<h2 id="基本概念">基本概念</h2>
<p>在讲解容器的网络接口配置之前，我们需要先建立一个整体的认识，搞清楚容器网络接口在系统架构中处于哪个位置。</p>
<p>你可以看一下我给你画的这张图，图里展示的是容器有自己的 Network Namespace，eth0 是这个 Network Namespace 里的网络接口。而宿主机上也有自己的 eth0，宿主机上的 eth0 对应着真正的物理网卡，可以和外面通讯。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/ea4a452ffbbfac9f7d7c848bf65baaca.png" alt=""></p>
<p>那你可以先想想，我们要让容器 Network Namespace 中的数据包最终发送到物理网卡上，需要完成哪些步骤呢？从图上看，我们大致可以知道应该包括这两步。</p>
<p><strong>第一步，就是要让数据包从容器的 Network Namespace 发送到 Host Network Namespace 上。</strong></p>
<p><strong>第二步，数据包发到了 Host Network Namespace 之后，还要解决数据包怎么从宿主机上的 eth0 发送出去的问题。</strong></p>
<p>好，整体的思路已经理清楚了，接下来我们做具体分析。我们先来看第一步，怎么让数据包从容器的 Network Namespace 发送到 Host Network Namespace 上面。</p>
<p>你可以查看一下Docker 网络的文档或者Kubernetes 网络的文档，这些文档里面介绍了很多种容器网络配置的方式。</p>
<p>不过对于容器从自己的 Network Namespace 连接到 Host Network Namespace 的方法，一般来说就只有两类设备接口：一类是veth，另外一类是 macvlan/ipvlan。</p>
<p>在这些方法中，我们使用最多的就是 veth 的方式，用 Docker 启动的容器缺省的网络接口用的也是这个 veth。既然它这么常见，所以我们就用 veth 作为例子来详细讲解。至于另外一类 macvlan/ipvlan 的方式，我们在下一讲里会讲到。</p>
<p>那什么是 veth 呢？为了方便你更好地理解，我们先来模拟一下 Docker 为容器建立 eth0 网络接口的过程，动手操作一下，这样呢，你就可以很快明白什么是 veth 了。</p>
<p>对于这个模拟操作呢，我们主要用到的是ip netns 这个命令，通过它来对 Network Namespace 做操作。</p>
<p>首先，我们先启动一个不带网络配置的容器，和我们之前的命令比较，主要是多加上了&quot;&ndash;network none&quot;参数。我们可以看到，这样在启动的容器中，Network Namespace 里就只有 loopback 一个网络设备，而没有了 eth0 网络设备了。</p>
<h1 id="docker-run--d---name-if-test---network-none-centos811911-sleep-36000">docker run -d &ndash;name if-test &ndash;network none centos:8.1.1911 sleep 36000</h1>
<p>cf3d3105b11512658a025f5b401a09c888ed3495205f31e0a0d78a2036729472</p>
<h1 id="docker-exec--it-if-test-ip-addr">docker exec -it if-test ip addr</h1>
<p>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>
inet 127.0.0.1/8 scope host lo<br>
valid_lft forever preferred_lft forever</p>
<p>完成刚才的设置以后，我们就在这个容器的 Network Namespace 里建立 veth，你可以执行一下后面的这个脚本。</p>
<p>pid=$(ps -ef | grep &ldquo;sleep 36000&rdquo; | grep -v grep | awk &lsquo;{print $2}&rsquo;)<br>
echo $pid<br>
ln -s /proc/$pid/ns/net /var/run/netns/$pid</p>
<h1 id="create-a-pair-of-veth-interfaces">Create a pair of veth interfaces</h1>
<p>ip link add name veth_host type veth peer name veth_container</p>
<h1 id="put-one-of-them-in-the-new-net-ns">Put one of them in the new net ns</h1>
<p>ip link set veth_container netns $pid</p>
<h1 id="in-the-container-setup-veth_container">In the container, setup veth_container</h1>
<p>ip netns exec $pid ip link set veth_container name eth0<br>
ip netns exec $pid ip addr add 172.17.1.2/16 dev eth0<br>
ip netns exec $pid ip link set eth0 up<br>
ip netns exec $pid ip route add default via 172.17.0.1</p>
<h1 id="in-the-host-set-veth_host-up">In the host, set veth_host up</h1>
<p>ip link set veth_host up</p>
<p>我在这里解释一下，这个 veth 的建立过程是什么样的。</p>
<p>首先呢，我们先找到这个容器里运行的进程&quot;sleep 36000&quot;的 pid，通过 &ldquo;/proc/$pid/ns/net&quot;这个文件得到 Network Namespace 的 ID，这个 Network Namespace ID 既是这个进程的，也同时属于这个容器。</p>
<p>然后我们在&rdquo;/var/run/netns/&ldquo;的目录下建立一个符号链接，指向这个容器的 Network Namespace。完成这步操作之后，在后面的&quot;ip netns&quot;操作里，就可以用 pid 的值作为这个容器的 Network Namesapce 的标识了。</p>
<p>接下来呢，我们用 <code>ip link</code> 命令来建立一对 veth 的虚拟设备接口，分别是 veth_container 和 veth_host。从名字就可以看出来，veth_container 这个接口会被放在容器 Network Namespace 里，而 veth_host 会放在宿主机的 Host Network Namespace。</p>
<p>所以我们后面的命令也很好理解了，就是用 <code>ip link set veth_container netns $pid</code> 把 veth_container 这个接口放入到容器的 Network Namespace 中。</p>
<p>再然后我们要把 veth_container 重新命名为 eth0，因为这时候接口已经在容器的 Network Namesapce 里了，eth0 就不会和宿主机上的 eth0 冲突了。</p>
<p>最后对容器内的 eht0，我们还要做基本的网络 IP 和缺省路由配置。因为 veth_host 已经在宿主机的 Host Network Namespace 了，就不需要我们做什么了，这时我们只需要 up 一下这个接口就可以了。</p>
<p>那刚才这些操作完成以后，我们就建立了一对 veth 虚拟设备接口。我给你画了一张示意图，图里直观展示了这对接口在容器和宿主机上的位置。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/03863cd49dad179c08c05765a419462c.png" alt=""></p>
<p>现在，我们再来看看 veth 的定义了，其实它也很简单。veth 就是一个虚拟的网络设备，一般都是成对创建，而且这对设备是相互连接的。当每个设备在不同的 Network Namespaces 的时候，Namespace 之间就可以用这对 veth 设备来进行网络通讯了。</p>
<p>比如说，你可以执行下面的这段代码，试试在 veth_host 上加上一个 IP，172.17.1.1/16，然后从容器里就可以 ping 通这个 IP 了。这也证明了从容器到宿主机可以利用这对 veth 接口来通讯了。</p>
<h1 id="ip-addr-add-172171116-dev-veth_host">ip addr add 172.17.1.1/16 dev veth_host</h1>
<h1 id="docker-exec--it-if-test-ping-1721711">docker exec -it if-test ping 172.17.1.1</h1>
<p>PING 172.17.1.1 (172.17.1.1) 56(84) bytes of data.<br>
64 bytes from 172.17.1.1: icmp_seq=1 ttl=64 time=0.073 ms<br>
64 bytes from 172.17.1.1: icmp_seq=2 ttl=64 time=0.092 ms<br>
^C<br>
&mdash; 172.17.1.1 ping statistics &mdash;<br>
2 packets transmitted, 2 received, 0% packet loss, time 30ms<br>
rtt min/avg/max/mdev = 0.073/0.082/0.092/0.013 ms</p>
<p>好了，这样我们完成了第一步，通过一对 veth 虚拟设备，可以让数据包从容器的 Network Namespace 发送到 Host Network Namespace 上。</p>
<p>那下面我们再来看第二步，数据包到了 Host Network Namespace 之后呢，怎么把它从宿主机上的 eth0 发送出去？</p>
<p>其实这一步呢，就是一个普通 Linux 节点上数据包转发的问题了。这里我们解决问题的方法有很多种，比如说用 nat 来做个转发，或者建立 Overlay 网络发送，也可以通过配置 proxy arp 加路由的方法来实现。</p>
<p>因为考虑到网络环境的配置，同时 Docker 缺省使用的是 <strong>bridge + nat</strong> 的转发方式，那我们就在刚才讲的第一步基础上，再手动实现一下 bridge+nat 的转发方式。对于其他的配置方法，你可以看一下 Docker 或者 Kubernetes 相关的文档。</p>
<p>Docker 程序在节点上安装完之后，就会自动建立了一个 docker0 的 bridge interface。所以我们只需要把第一步中建立的 veth_host 这个设备，接入到 docker0 这个 bridge 上。</p>
<p>这里我要提醒你注意一下，如果之前你在 veth_host 上设置了 IP 的，就需先运行一下&quot;ip addr delete 172.17.1.1/16 dev veth_host&rdquo;，把 IP 从 veth_host 上删除。</p>
<h1 id="ip-addr-delete-172171116-dev-veth_host">ip addr delete 172.17.1.1/16 dev veth_host</h1>
<p>ip link set veth_host master docker0</p>
<p>这个命令执行完之后，容器和宿主机的网络配置就会发生变化，这种配置是什么样呢？你可以参考一下面这张图的描述。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/65dbd7d7328edf61fd0c17f1a4f1b135.png" alt=""></p>
<p>从这张示意图中，我们可以看出来，容器和 docker0 组成了一个子网，docker0 上的 IP 就是这个子网的网关 IP。</p>
<p>如果我们要让子网通过宿主机上 eth0 去访问外网的话，那么加上 iptables 的规则就可以了，也就是下面这条规则。</p>
<p>iptables -P FORWARD ACCEPT</p>
<p>好了，进行到这里，我们通过 bridge+nat 的配置，似乎已经完成了第二步——让数据从宿主机的 eth0 发送出去。</p>
<p>那么我们这样配置，真的可以让容器里发送数据包到外网了吗？这需要我们做个测试，再重新尝试下这一讲开始的操作，从容器里 ping 外网的 IP，这时候，你会发现还是 ping 不通。</p>
<p>其实呢，做到这一步，我们通过自己的逐步操作呢，重现了这一讲了最开始的问题。</p>
<h2 id="解决问题">解决问题</h2>
<p>既然现在我们清楚了，在这个节点上容器和宿主机上的网络配置是怎么一回事。那么要调试这个问题呢，也有了思路，关键就是找到数据包传到哪个环节时发生了中断。</p>
<p>那最直接的方法呢，就是在容器中继续 ping 外网的 IP 39.106.233.176，然后在容器的 eth0 (veth_container)，容器外的 veth_host，docker0，宿主机的 eth0 这一条数据包的路径上运行 tcpdump。</p>
<p>这样就可以查到，到底在哪个设备接口上没有收到 ping 的 icmp 包。我把 tcpdump 运行的结果我列到了下面。</p>
<p>容器的 eth0：</p>
<h1 id="ip-netns-exec-pid-tcpdump--i-eth0-host-39106233176--nn">ip netns exec $pid tcpdump -i eth0 host 39.106.233.176 -nn</h1>
<p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>
00:47:29.934294 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 1, length 64<br>
00:47:30.934766 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 2, length 64<br>
00:47:31.958875 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 3, length 64</p>
<p>veth_host：</p>
<h1 id="tcpdump--i-veth_host-host-39106233176--nn">tcpdump -i veth_host host 39.106.233.176 -nn</h1>
<p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>
listening on veth_host, link-type EN10MB (Ethernet), capture size 262144 bytes<br>
00:48:01.654720 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 32, length 64<br>
00:48:02.678752 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 33, length 64<br>
00:48:03.702827 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 34, length 64</p>
<p>docker0：</p>
<h1 id="tcpdump--i-docker0-host-39106233176--nn">tcpdump -i docker0 host 39.106.233.176 -nn</h1>
<p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>
listening on docker0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>
00:48:20.086841 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 50, length 64<br>
00:48:21.110765 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 51, length 64<br>
00:48:22.134839 IP 172.17.1.2 &gt; 39.106.233.176: ICMP echo request, id 71, seq 52, length 64</p>
<p>host eth0：</p>
<h1 id="tcpdump--i-eth0-host-39106233176--nn">tcpdump -i eth0 host 39.106.233.176 -nn</h1>
<p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>
^C<br>
0 packets captured<br>
0 packets received by filter<br>
0 packets dropped by kernel</p>
<p>通过上面的输出结果，我们发现 icmp 包到达了 docker0，但是没有到达宿主机上的 eth0。</p>
<p>因为我们已经配置了 iptables nat 的转发，这个也可以通过查看 iptables 的 nat 表确认一下，是没有问题的，具体的操作命令如下：</p>
<h1 id="iptables--l---t-nat">iptables -L  -t nat</h1>
<p>Chain PREROUTING (policy ACCEPT)<br>
target     prot opt source               destination<br>
DOCKER     all  &ndash;  anywhere             anywhere             ADDRTYPE match dst-type LOCAL</p>
<p>Chain INPUT (policy ACCEPT)<br>
target     prot opt source               destination</p>
<p>Chain POSTROUTING (policy ACCEPT)<br>
target     prot opt source               destination<br>
MASQUERADE  all  &ndash;  172.17.0.0/16        anywhere</p>
<p>Chain OUTPUT (policy ACCEPT)<br>
target     prot opt source               destination<br>
DOCKER     all  &ndash;  anywhere            !127.0.0.0/8          ADDRTYPE match dst-type LOCAL</p>
<p>Chain DOCKER (2 references)<br>
target     prot opt source               destination<br>
RETURN     all  &ndash;  anywhere             anywhere</p>
<p>那么会是什么问题呢？因为这里需要做两个网络设备接口之间的数据包转发，也就是从 docker0 把数据包转发到 eth0 上，你可能想到了 Linux 协议栈里的一个常用参数 ip_forward。</p>
<p>我们可以看一下，它的值是 0，当我们把它改成 1 之后，那么我们就可以从容器中 ping 通外网 39.106.233.176 这个 IP 了！</p>
<h1 id="cat-procsysnetipv4ip_forward">cat /proc/sys/net/ipv4/ip_forward</h1>
<p>0</p>
<h1 id="echo-1--procsysnetipv4ip_forward">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</h1>
<h1 id="docker-exec--it-if-test-ping-39106233176">docker exec -it if-test ping 39.106.233.176</h1>
<p>PING 39.106.233.176 (39.106.233.176) 56(84) bytes of data.<br>
64 bytes from 39.106.233.176: icmp_seq=1 ttl=77 time=359 ms<br>
64 bytes from 39.106.233.176: icmp_seq=2 ttl=77 time=346 ms<br>
^C<br>
&mdash; 39.106.233.176 ping statistics &mdash;<br>
2 packets transmitted, 2 received, 0% packet loss, time 1ms<br>
rtt min/avg/max/mdev = 345.889/352.482/359.075/6.593 ms</p>
<h2 id="重点小结">重点小结</h2>
<p>这一讲，我们主要解决的问题是如何给容器配置网络接口，让容器可以和外面通讯；同时我们还学习了当容器网络不通的时候，我们应该怎么来做一个简单调试。</p>
<p>解决容器与外界通讯的问题呢，一共需要完成两步。第一步是，怎么让数据包从容器的 Network Namespace 发送到 Host Network Namespace 上；第二步，数据包到了 Host Network Namespace 之后，还需要让它可以从宿主机的 eth0 发送出去。</p>
<p>我们想让数据从容器 Netowrk Namespace 发送到 Host Network Namespace，可以用配置一对 veth 虚拟网络设备的方法实现。而让数据包从宿主机的 eth0 发送出去，就用可 bridge+nat 的方式完成。</p>
<p>这里我讲的是最基本的一种配置，但它也是很常用的一个网络配置。针对其他不同需要，容器网络还有很多种。那你学习完这一讲，了解了基本的概念和操作之后呢，还可以查看更多的网上资料，学习不同的网络配置。</p>
<p>遇到容器中网络不通的情况，我们先要理解自己的容器以及容器在宿主机上的配置，通过对主要设备上做 tcpdump 可以找到具体在哪一步数据包停止了转发。</p>
<p>然后我们结合内核网络配置参数，路由表信息，防火墙规则，一般都可以定位出根本原因，最终解决这种网络完全不通的问题。</p>
<p>但是如果是网络偶尔丢包的问题，这个就需要用到其他的一些工具来做分析了，这个我们会在之后的章节做讲解。</p>
<h2 id="思考题">思考题</h2>
<p>我们这一讲的例子呢，实现了从容器访问外面的 IP。那么如果要实现节点外的程序来访问容器的 IP，我们应该怎么配置网络呢？</p>
<p>欢迎你在留言区分享你的思考和问题。如果这篇文章对你有启发，也欢迎分享给你的朋友，一起学习进步。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/">容器实战高手课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AF%B4%E9%80%8F%E6%95%B0%E5%AD%97%E5%8C%96%E8%BD%AC%E5%9E%8B/16__%E4%BA%BA%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%A6%82%E4%BD%95%E5%9F%B9%E5%85%BB%E6%95%B0%E5%AD%97%E5%8C%96%E4%BA%BA%E6%89%8D%E5%92%8C%E5%BB%BA%E7%AB%8B%E4%BC%81%E4%B8%9A%E6%9E%B6%E6%9E%84%E6%96%B9%E6%B3%95%E8%AE%BA/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">16__人与工具：如何培养数字化人才和建立企业架构方法论？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%A1%85%E8%B0%B7%E4%BA%A7%E5%93%81%E5%AE%9E%E6%88%9836%E8%AE%B2/16__%E5%A6%82%E4%BD%95%E5%92%8C%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%9C%89%E6%95%88%E6%B2%9F%E9%80%9A/">
            <span class="next-text nav-default">16__如何和工程师有效沟通？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
