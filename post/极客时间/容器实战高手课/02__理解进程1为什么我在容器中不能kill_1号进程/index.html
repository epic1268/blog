<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>02__理解进程（1）：为什么我在容器中不能kill_1号进程？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是程远。
今天，我们正式进入理解进程的模块。我会通过 3 讲内容，带你了解容器 init 进程的特殊之处，还有它需要具备哪些功能，才能保证容器在运行过程中不会出现类似僵尸进程，或者应用程序无法 graceful shutdown 的问题。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/02__%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B1%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%B8%8D%E8%83%BDkill_1%E5%8F%B7%E8%BF%9B%E7%A8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/02__%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B1%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%B8%8D%E8%83%BDkill_1%E5%8F%B7%E8%BF%9B%E7%A8%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="02__理解进程（1）：为什么我在容器中不能kill_1号进程？">
  <meta property="og:description" content="你好，我是程远。
今天，我们正式进入理解进程的模块。我会通过 3 讲内容，带你了解容器 init 进程的特殊之处，还有它需要具备哪些功能，才能保证容器在运行过程中不会出现类似僵尸进程，或者应用程序无法 graceful shutdown 的问题。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="容器实战高手课">

  <meta itemprop="name" content="02__理解进程（1）：为什么我在容器中不能kill_1号进程？">
  <meta itemprop="description" content="你好，我是程远。
今天，我们正式进入理解进程的模块。我会通过 3 讲内容，带你了解容器 init 进程的特殊之处，还有它需要具备哪些功能，才能保证容器在运行过程中不会出现类似僵尸进程，或者应用程序无法 graceful shutdown 的问题。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6225">
  <meta itemprop="keywords" content="容器实战高手课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="02__理解进程（1）：为什么我在容器中不能kill_1号进程？">
  <meta name="twitter:description" content="你好，我是程远。
今天，我们正式进入理解进程的模块。我会通过 3 讲内容，带你了解容器 init 进程的特殊之处，还有它需要具备哪些功能，才能保证容器在运行过程中不会出现类似僵尸进程，或者应用程序无法 graceful shutdown 的问题。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">02__理解进程（1）：为什么我在容器中不能kill_1号进程？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6225 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#问题再现">问题再现</a></li>
      </ul>
    </li>
    <li><a href="#docker-stop-sig-procdocker-rm-sig-proc">docker stop sig-proc;docker rm sig-proc</a></li>
    <li><a href="#docker-run---name-sig-proc--d-registrysig-procv1-initsh">docker run &ndash;name sig-proc -d registry/sig-proc:v1 /init.sh</a></li>
    <li><a href="#docker-exec--it-sig-proc-bash">docker exec -it sig-proc bash</a>
      <ul>
        <li><a href="#知识详解">知识详解</a>
          <ul>
            <li><a href="#如何理解-init-进程">如何理解 init 进程？</a></li>
            <li><a href="#如何理解-linux-信号">如何理解 Linux 信号？</a></li>
          </ul>
        </li>
        <li><a href="#现象解释">现象解释</a></li>
      </ul>
    </li>
    <li><a href="#cat-c-init-nosigc">cat c-init-nosig.c</a></li>
    <li><a href="#docker-stop-sig-procdocker-rm-sig-proc-1">docker stop sig-proc;docker rm sig-proc</a></li>
    <li><a href="#docker-run---name-sig-proc--d-registrysig-procv1-c-init-nosig">docker run &ndash;name sig-proc -d registry/sig-proc:v1 /c-init-nosig</a></li>
    <li><a href="#docker-exec--it-sig-proc-bash-1">docker exec -it sig-proc bash</a></li>
    <li><a href="#cat-go-initgo">cat go-init.go</a></li>
    <li><a href="#docker-stop-sig-procdocker-rm-sig-proc-2">docker stop sig-proc;docker rm sig-proc</a></li>
    <li><a href="#docker-run---name-sig-proc--d-registrysig-procv1-go-init">docker run &ndash;name sig-proc -d registry/sig-proc:v1 /go-init</a></li>
    <li><a href="#docker-exec--it-sig-proc-bash-2">docker exec -it sig-proc bash</a>
      <ul>
        <li>
          <ul>
            <li><a href="#golang-init">golang init</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#cat-proc1status--grep--i-sigcgt">cat /proc/1/status | grep -i SigCgt</a>
      <ul>
        <li>
          <ul>
            <li><a href="#c-init">C init</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#cat-proc1status--grep--i-sigcgt-1">cat /proc/1/status | grep -i SigCgt</a>
      <ul>
        <li>
          <ul>
            <li><a href="#bash-init">bash init</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#cat-proc1status--grep--i-sigcgt-2">cat /proc/1/status | grep -i SigCgt</a></li>
    <li><a href="#docker-stop-sig-procdocker-rm-sig-proc-3">docker stop sig-proc;docker rm sig-proc</a></li>
    <li><a href="#docker-run---name-sig-proc--d-registrysig-procv1-c-init-sig">docker run &ndash;name sig-proc -d registry/sig-proc:v1 /c-init-sig</a></li>
    <li><a href="#docker-exec--it-sig-proc-bash-3">docker exec -it sig-proc bash</a></li>
    <li><a href="#docker-ps">docker ps</a>
      <ul>
        <li><a href="#重点总结">重点总结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是程远。</p>
<p>今天，我们正式进入理解进程的模块。我会通过 3 讲内容，带你了解容器 init 进程的特殊之处，还有它需要具备哪些功能，才能保证容器在运行过程中不会出现类似僵尸进程，或者应用程序无法 graceful shutdown 的问题。</p>
<p>那么通过这一讲，我会带你掌握 init 进程和 Linux 信号的核心概念。</p>
<h2 id="问题再现">问题再现</h2>
<p>接下来，我们一起再现用 <code>kill 1</code> 命令重启容器的问题。</p>
<p>我猜你肯定想问，为什么要在容器中执行 <code>kill 1</code> 或者 <code>kill -9 1</code> 的命令呢？其实这是我们团队里的一位同学提出的问题。</p>
<p>这位同学当时遇到的情况是这样的，他想修改容器镜像里的一个 bug，但因为网路配置的问题，这个同学又不想为了重建 pod 去改变 pod IP。</p>
<p>如果你用过 Kubernetes 的话，你也肯定知道，Kubernetes 上是没有 <code>restart pod</code> 这个命令的。这样看来，他似乎只能让 pod 做个原地重启了。<strong>当时我首先想到的，就是在容器中使用 kill pid 1 的方式重启容器。</strong></p>
<p>为了模拟这个过程，我们可以进行下面的这段操作。</p>
<p>如果你没有在容器中做过 <code>kill 1</code> ，你可以下载我在 GitHub 上的这个例子，运行 <code>make image</code> 来做一个容器镜像。</p>
<p>然后，我们用 Docker 构建一个容器，用例子中的 <strong>init.sh 脚本</strong>作为这个容器的 init 进程。</p>
<p>最后，我们在容器中运行 <code>kill 1</code> 和 <code>kill -9 1</code> ，看看会发生什么。</p>
<h1 id="docker-stop-sig-procdocker-rm-sig-proc">docker stop sig-proc;docker rm sig-proc</h1>
<h1 id="docker-run---name-sig-proc--d-registrysig-procv1-initsh">docker run &ndash;name sig-proc -d registry/sig-proc:v1 /init.sh</h1>
<h1 id="docker-exec--it-sig-proc-bash">docker exec -it sig-proc bash</h1>
<p>[root@5cc69036b7b2 /]# ps -ef<br>
UID        PID  PPID  C STIME TTY          TIME CMD<br>
root         1     0  0 07:23 ?        00:00:00 /bin/bash /init.sh<br>
root         8     1  0 07:25 ?        00:00:00 /usr/bin/coreutils &ndash;coreutils-prog-shebang=sleep /usr/bin/sleep 100<br>
root         9     0  6 07:27 pts/0    00:00:00 bash<br>
root        22     9  0 07:27 pts/0    00:00:00 ps -ef</p>
<p>[root@5cc69036b7b2 /]# kill 1<br>
[root@5cc69036b7b2 /]# kill -9 1<br>
[root@5cc69036b7b2 /]# ps -ef<br>
UID        PID  PPID  C STIME TTY          TIME CMD<br>
root         1     0  0 07:23 ?        00:00:00 /bin/bash /init.sh<br>
root         9     0  0 07:27 pts/0    00:00:00 bash<br>
root        23     1  0 07:27 ?        00:00:00 /usr/bin/coreutils &ndash;coreutils-prog-shebang=sleep /usr/bin/sleep 100<br>
root        24     9  0 07:27 pts/0    00:00:00 ps -ef</p>
<p>当我们完成前面的操作，就会发现无论运行 <code>kill 1</code> （对应 Linux 中的 SIGTERM 信号）还是 <code>kill -9 1</code>（对应 Linux 中的 SIGKILL 信号），都无法让进程终止。</p>
<p>那么问题来了，这两个常常用来终止进程的信号，都对容器中的 init 进程不起作用，这是怎么回事呢？</p>
<p>要解释这个问题，我们就要回到容器的两个最基本概念——init 进程和 Linux 信号中寻找答案。</p>
<h2 id="知识详解">知识详解</h2>
<h3 id="如何理解-init-进程">如何理解 init 进程？</h3>
<p>init 进程的意思并不难理解，你只要认真听我讲完，这块内容基本就不会有问题了。我们下面来看一看。</p>
<p>使用容器的理想境界是<strong>一个容器只启动一个进程</strong>，但这在现实应用中有时是做不到的。</p>
<p>比如说，在一个容器中除了主进程之外，我们可能还会启动辅助进程，做监控或者 rotate logs；再比如说，我们需要把原来运行在虚拟机（VM）的程序移到容器里，这些原来跑在虚拟机上的程序本身就是多进程的。</p>
<p>一旦我们启动了多个进程，那么容器里就会出现一个 pid 1，也就是我们常说的 1 号进程或者 init 进程，然后<strong>由这个进程创建出其他的子进程。</strong></p>
<p>接下来，我带你梳理一下 init 进程是怎么来的。</p>
<p>一个 Linux 操作系统，在系统打开电源，执行 BIOS/boot-loader 之后，就会由 boot-loader 负责加载 Linux 内核。</p>
<p>Linux 内核执行文件一般会放在 /boot 目录下，文件名类似 vmlinuz*。在内核完成了操作系统的各种初始化之后，<strong>这个程序需要执行的第一个用户态程就是 init 进程。</strong></p>
<p>内核代码启动 1 号进程的时候，在没有外面参数指定程序路径的情况下，一般会从几个缺省路径尝试执行 1 号进程的代码。这几个路径都是 Unix 常用的可执行代码路径。</p>
<p>系统启动的时候先是执行内核态的代码，然后在内核中调用 1 号进程的代码，从内核态切换到用户态。</p>
<p>目前主流的 Linux 发行版，无论是 RedHat 系的还是 Debian 系的，都会把 /sbin/init 作为符号链接指向 Systemd。Systemd 是目前最流行的 Linux init 进程，在它之前还有 SysVinit、UpStart 等 Linux init 进程。</p>
<p>**但无论是哪种 Linux init 进程，它最基本的功能都是创建出 Linux 系统中其他所有的进程，并且管理这些进程。**具体在 kernel 里的代码实现如下：</p>
<p>init/main.c</p>
<pre><code>    /*  
     * We try each of these until one succeeds.  
     *  
     * The Bourne shell can be used instead of init if we are  
     * trying to recover a really broken machine.  
     */  

    if (execute_command) {  
            ret = run_init_process(execute_command);  
            if (!ret)  
                    return 0;  
            panic(&quot;Requested init %s failed (error %d).&quot;,  
                  execute_command, ret);  
    }  

    if (!try_to_run_init_process(&quot;/sbin/init&quot;) ||  
        !try_to_run_init_process(&quot;/etc/init&quot;) ||  
        !try_to_run_init_process(&quot;/bin/init&quot;) ||  
        !try_to_run_init_process(&quot;/bin/sh&quot;))  
            return 0;  


    panic(&quot;No working init found.  Try passing init= option to kernel. &quot;  
          &quot;See Linux Documentation/admin-guide/init.rst for guidance.&quot;);
</code></pre>
<p>$ ls -l /sbin/init<br>
lrwxrwxrwx 1 root root 20 Feb  5 01:07 /sbin/init -&gt; /lib/systemd/systemd</p>
<p>在 Linux 上有了容器的概念之后，一旦容器建立了自己的 Pid Namespace（进程命名空间），这个 Namespace 里的进程号也是从 1 开始标记的。所以，容器的 init 进程也被称为 1 号进程。</p>
<p>怎么样，1 号进程是不是不难理解？关于这个知识点，你只需要记住： <strong>1 号进程是第一个用户态的进程，由它直接或者间接创建了 Namespace 中的其他进程。</strong></p>
<h3 id="如何理解-linux-信号">如何理解 Linux 信号？</h3>
<p>刚才我给你讲了什么是 1 号进程，要想解决“为什么我在容器中不能 kill 1 号进程”这个问题，我们还得看看 kill 命令起到的作用。</p>
<p>我们运行 kill 命令，其实在 Linux 里就是发送一个信号，那么信号到底是什么呢？这就涉及到 Linux 信号的概念了。</p>
<p>其实信号这个概念在很早期的 Unix 系统上就有了。它一般会从 1 开始编号，通常来说，信号编号是 1 到 31，这个编号在所有的 Unix 系统上都是一样的。</p>
<p>在 Linux 上我们可以用 <code>kill -l</code> 来看这些信号的编号和名字，具体的编号和名字我给你列在了下面，你可以看一看。</p>
<p>$ kill -l</p>
<ol>
<li>SIGHUP      2) SIGINT    3) SIGQUIT    4) SIGILL    5) SIGTRAP</li>
<li>SIGABRT     7) SIGBUS    8) SIGFPE     9) SIGKILL  10) SIGUSR1</li>
<li>SIGSEGV    12) SIGUSR2  13) SIGPIPE   14) SIGALRM  15) SIGTERM</li>
<li>SIGSTKFLT  17) SIGCHLD  18) SIGCONT   19) SIGSTOP  20) SIGTSTP</li>
<li>SIGTTIN    22) SIGTTOU  23) SIGURG    24) SIGXCPU  25) SIGXFSZ</li>
<li>SIGVTALRM  27) SIGPROF  28) SIGWINCH  29) SIGIO    30) SIGPWR</li>
<li>SIGSYS</li>
</ol>
<p>用一句话来概括，**信号（Signal）其实就是 Linux 进程收到的一个通知。**这些通知产生的源头有很多种，通知的类型也有很多种。</p>
<p>比如下面这几个典型的场景，你可以看一下：</p>
<ol>
<li>如果我们按下键盘“Ctrl+C”，当前运行的进程就会收到一个信号 SIGINT 而退出；</li>
<li>如果我们的代码写得有问题，导致内存访问出错了，当前的进程就会收到另一个信号 SIGSEGV；</li>
<li>我们也可以通过命令 kill <pid>，直接向一个进程发送一个信号，缺省情况下不指定信号的类型，那么这个信号就是 SIGTERM。也可以指定信号类型，比如命令“kill -9 <pid>”, 这里的 9，就是编号为 9 的信号，SIGKILL 信号。</li>
</ol>
<p>在这一讲中，我们主要用到 <strong>SIGTERM（15）和 SIGKILL（9）这两个信号</strong>，所以这里你主要了解这两个信号就可以了，其他信号以后用到时再做介绍。</p>
<p>进程在收到信号后，就会去做相应的处理。怎么处理呢？对于每一个信号，进程对它的处理都有下面三个选择。</p>
<p>第一个选择是<strong>忽略（Ignore）</strong>，就是对这个信号不做任何处理，但是有两个信号例外，对于 SIGKILL 和 SIGSTOP 这个两个信号，进程是不能忽略的。这是因为它们的主要作用是为 Linux kernel 和超级用户提供删除任意进程的特权。</p>
<p>第二个选择，就是<strong>捕获（Catch）</strong>，这个是指让用户进程可以注册自己针对这个信号的 handler。具体怎么做我们目前暂时涉及不到，你先知道就行，我们在后面课程会进行详细介绍。</p>
<p><strong>对于捕获，SIGKILL 和 SIGSTOP 这两个信号也同样例外，这两个信号不能有用户自己的处理代码，只能执行系统的缺省行为。</strong></p>
<p>还有一个选择是<strong>缺省行为（Default）</strong>，Linux 为每个信号都定义了一个缺省的行为，你可以在 Linux 系统中运行 <code>man 7 signal</code>来查看每个信号的缺省行为。</p>
<p>对于大部分的信号而言，应用程序不需要注册自己的 handler，使用系统缺省定义行为就可以了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/91c4469c38904c5fc2ab62499be203f7.png" alt=""></p>
<p>我刚才说了，SIGTERM（15）和 SIGKILL（9）这两个信号是我们重点掌握的。现在我们已经讲解了信号的概念和处理方式，我就拿这两个信号为例，再带你具体分析一下。</p>
<p>首先我们来看 SIGTERM（15），这个信号是 Linux 命令 kill 缺省发出的。前面例子里的命令 <code>kill 1</code> ，就是通过 kill 向 1 号进程发送一个信号，在没有别的参数时，这个信号类型就默认为 SIGTERM。</p>
<p>SIGTERM 这个信号是可以被捕获的，这里的“捕获”指的就是用户进程可以为这个信号注册自己的 handler，而这个 handler，我们后面会看到，它可以处理进程的 graceful-shutdown 问题。</p>
<p>我们再来了解一下 SIGKILL (9)，这个信号是 Linux 里两个<strong>特权信号</strong>之一。什么是特权信号呢？</p>
<p>前面我们已经提到过了，**特权信号就是 Linux 为 kernel 和超级用户去删除任意进程所保留的，不能被忽略也不能被捕获。**那么进程一旦收到 SIGKILL，就要退出。</p>
<p>在前面的例子里，我们运行的命令 <code>kill -9 1</code> 里的参数“-9”，其实就是指发送编号为 9 的这个 SIGKILL 信号给 1 号进程。</p>
<h2 id="现象解释">现象解释</h2>
<p>现在，你应该理解 init 进程和 Linux 信号这两个概念了，让我们回到开头的问题上来：“为什么我在容器中不能 kill 1 号进程，甚至 SIGKILL 信号也不行？”</p>
<p>你还记得么，在课程的最开始，我们已经尝试过用 bash 作为容器 1 号进程，这样是无法把 1 号进程杀掉的。那么我们再一起来看一看，用别的编程语言写的 1 号进程是否也杀不掉。</p>
<p>我们现在<strong>用 C 程序作为 init 进程</strong>，尝试一下杀掉 1 号进程。和 bash init 进程一样，无论 SIGTERM 信号还是 SIGKILL 信号，在容器里都不能杀死这个 1 号进程。</p>
<h1 id="cat-c-init-nosigc">cat c-init-nosig.c</h1>
<p>#include &lt;stdio.h&gt;<br>
#include &lt;unistd.h&gt;</p>
<p>int main(int argc, char *argv[])<br>
{<br>
printf(&ldquo;Process is sleeping\n&rdquo;);<br>
while (1) {<br>
sleep(100);<br>
}</p>
<pre><code>   return 0;  
</code></pre>
<p>}</p>
<h1 id="docker-stop-sig-procdocker-rm-sig-proc-1">docker stop sig-proc;docker rm sig-proc</h1>
<h1 id="docker-run---name-sig-proc--d-registrysig-procv1-c-init-nosig">docker run &ndash;name sig-proc -d registry/sig-proc:v1 /c-init-nosig</h1>
<h1 id="docker-exec--it-sig-proc-bash-1">docker exec -it sig-proc bash</h1>
<p>[root@5d3d42a031b1 /]# ps -ef<br>
UID        PID  PPID  C STIME TTY          TIME CMD<br>
root         1     0  0 07:48 ?        00:00:00 /c-init-nosig<br>
root         6     0  5 07:48 pts/0    00:00:00 bash<br>
root        19     6  0 07:48 pts/0    00:00:00 ps -ef<br>
[root@5d3d42a031b1 /]# kill 1<br>
[root@5d3d42a031b1 /]# kill -9 1<br>
[root@5d3d42a031b1 /]# ps -ef<br>
UID        PID  PPID  C STIME TTY          TIME CMD<br>
root         1     0  0 07:48 ?        00:00:00 /c-init-nosig<br>
root         6     0  0 07:48 pts/0    00:00:00 bash<br>
root        20     6  0 07:49 pts/0    00:00:00 ps -ef</p>
<p>我们是不是这样就可以得出结论——“容器里的 1 号进程，完全忽略了 SIGTERM 和 SIGKILL 信号了”呢？你先别着急，我们再拿其他语言试试。</p>
<p>接下来，我们用 <strong>Golang 程序作为 1 号进程</strong>，我们再在容器中执行 <code>kill -9 1</code> 和 <code>kill 1</code> 。</p>
<p>这次，我们发现 <code>kill -9 1</code> 这个命令仍然不能杀死 1 号进程，也就是说，SIGKILL 信号和之前的两个测试一样不起作用。</p>
<p><strong>但是，我们执行</strong> <code>kill 1</code> <strong>以后，SIGTERM 这个信号把 init 进程给杀了，容器退出了。</strong></p>
<h1 id="cat-go-initgo">cat go-init.go</h1>
<p>package main</p>
<p>import (<br>
&ldquo;fmt&rdquo;<br>
&ldquo;time&rdquo;<br>
)</p>
<p>func main() {<br>
fmt.Println(&ldquo;Start app\n&rdquo;)<br>
time.Sleep(time.Duration(100000) * time.Millisecond)<br>
}</p>
<h1 id="docker-stop-sig-procdocker-rm-sig-proc-2">docker stop sig-proc;docker rm sig-proc</h1>
<h1 id="docker-run---name-sig-proc--d-registrysig-procv1-go-init">docker run &ndash;name sig-proc -d registry/sig-proc:v1 /go-init</h1>
<h1 id="docker-exec--it-sig-proc-bash-2">docker exec -it sig-proc bash</h1>
<p>[root@234a23aa597b /]# ps -ef<br>
UID        PID  PPID  C STIME TTY          TIME CMD<br>
root         1     0  1 08:04 ?        00:00:00 /go-init<br>
root        10     0  9 08:04 pts/0    00:00:00 bash<br>
root        23    10  0 08:04 pts/0    00:00:00 ps -ef<br>
[root@234a23aa597b /]# kill -9 1<br>
[root@234a23aa597b /]# kill 1<br>
[root@234a23aa597b /]# [~]# docker ps<br>
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</p>
<p>对于这个测试结果，你是不是反而觉得更加困惑了？</p>
<p>为什么使用不同程序，结果就不一样呢？接下来我们就看看 kill 命令下达之后，Linux 里究竟发生了什么事，我给你系统地梳理一下整个过程。</p>
<p>在我们运行 <code>kill 1</code> 这个命令的时候，希望把 SIGTERM 这个信号发送给 1 号进程，就像下面图里的<strong>带箭头虚线</strong>。</p>
<p>在 Linux 实现里，kill 命令调用了 <strong>kill() 的这个系统调用</strong>（所谓系统调用就是内核的调用接口）而进入到了内核函数 sys_kill()，也就是下图里的<strong>实线箭头</strong>。</p>
<p>而内核在决定把信号发送给 1 号进程的时候，会调用 sig_task_ignored() 这个函数来做个判断，这个判断有什么用呢？</p>
<p>它会决定内核在哪些情况下会把发送的这个信号给忽略掉。如果信号被忽略了，那么 init 进程就不能收到指令了。</p>
<p>所以，我们想要知道 init 进程为什么收到或者收不到信号，都要去看看 <strong>sig_task_ignored() 的这个内核函数的实现。</strong></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/6b42b07720a1ae463ecf5cfbc23a22a3.png" alt=""></p>
<p>sig_task_ignored() 内核函数实现示意图</p>
<p>在 sig_task_ignored() 这个函数中有三个 if{}判断，第一个和第三个 if{}判断和我们的问题没有关系，并且代码有注释，我们就不讨论了。</p>
<p>我们重点来看第二个 if{}。我来给你分析一下，在容器中执行 <code>kill 1</code> 或者 <code>kill -9 1</code> 的时候，这第二个 if{}里的三个子条件是否可以被满足呢？</p>
<p>我们来看下面这串代码，这里表示<strong>一旦这三个子条件都被满足，那么这个信号就不会发送给进程。</strong></p>
<p>kernel/signal.c<br>
static bool sig_task_ignored(struct task_struct *t, int sig, bool force)<br>
{<br>
void __user *handler;<br>
handler = sig_handler(t, sig);</p>
<pre><code>    /* SIGKILL and SIGSTOP may not be sent to the global init */  
    if (unlikely(is_global_init(t) &amp;&amp; sig_kernel_only(sig)))  

            return true;  

    if (unlikely(t-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE) &amp;&amp;  
        handler == SIG_DFL &amp;&amp; !(force &amp;&amp; sig_kernel_only(sig)))  
            return true;  

    /* Only allow kernel generated signals to this kthread */  
    if (unlikely((t-&gt;flags &amp; PF_KTHREAD) &amp;&amp;  
                 (handler == SIG_KTHREAD_KERNEL) &amp;&amp; !force))  
            return true;  

    return sig_handler_ignored(handler, sig);  
</code></pre>
<p>}</p>
<p>接下来，我们就逐一分析一下这三个子条件，我们来说说这个&quot;!(force &amp;&amp; sig_kernel_only(sig))&quot; 。</p>
<p>第一个条件里 force 的值，对于同一个 Namespace 里发出的信号来说，调用值是 0，所以这个条件总是满足的。</p>
<p>我们再来看一下第二个条件“handler == SIG_DFL”，第二个条件判断信号的 handler 是否是 SIG_DFL。</p>
<p>那么什么是 SIG_DFL 呢？<strong>对于每个信号，用户进程如果不注册一个自己的 handler，就会有一个系统缺省的 handler，这个缺省的 handler 就叫作 SIG_DFL。</strong></p>
<p>对于 SIGKILL，我们前面介绍过它是特权信号，是不允许被捕获的，所以它的 handler 就一直是 SIG_DFL。这第二个条件对 SIGKILL 来说总是满足的。</p>
<p>对于 SIGTERM，它是可以被捕获的。也就是说如果用户不注册 handler，那么这个条件对 SIGTERM 也是满足的。</p>
<p>最后再来看一下第三个条件，“t-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE”，这里的条件判断是这样的，进程必须是 SIGNAL_UNKILLABLE 的。</p>
<p>这个 SIGNAL_UNKILLABLE flag 是在哪里置位的呢？</p>
<p>可以参考我们下面的这段代码，在每个 Namespace 的 init 进程建立的时候，就会打上 <strong>SIGNAL_UNKILLABLE</strong> 这个标签，也就是说只要是 1 号进程，就会有这个 flag，这个条件也是满足的。</p>
<p>kernel/fork.c<br>
if (is_child_reaper(pid)) {<br>
ns_of_pid(pid)-&gt;child_reaper = p;<br>
p-&gt;signal-&gt;flags |= SIGNAL_UNKILLABLE;<br>
}</p>
<p>/*</p>
<ul>
<li>is_child_reaper returns true if the pid is the init process</li>
<li>of the current namespace. As this one could be checked before</li>
<li>pid_ns-&gt;child_reaper is assigned in copy_process, we check</li>
<li>with the pid number.<br>
*/</li>
</ul>
<p>static inline bool is_child_reaper(struct pid *pid)<br>
{<br>
return pid-&gt;numbers[pid-&gt;level].nr == 1;<br>
}</p>
<p>我们可以看出来，其实<strong>最关键的一点就是</strong><code>handler == SIG_DFL</code><strong>。Linux 内核针对每个 Nnamespace 里的 init 进程，把只有 default handler 的信号都给忽略了。</strong></p>
<p>如果我们自己注册了信号的 handler（应用程序注册信号 handler 被称作&quot;Catch the Signal&quot;），那么这个信号 handler 就不再是 SIG_DFL。即使是 init 进程在接收到 SIGTERM 之后也是可以退出的。</p>
<p>不过，由于 SIGKILL 是一个特例，因为 SIGKILL 是不允许被注册用户 handler 的（还有一个不允许注册用户 handler 的信号是 SIGSTOP），那么它只有 SIG_DFL handler。</p>
<p>所以 init 进程是永远不能被 SIGKILL 所杀，但是可以被 SIGTERM 杀死。</p>
<p>说到这里，我们该怎么证实这一点呢？我们可以做下面两件事来验证。</p>
<p><strong>第一件事，你可以查看 1 号进程状态中 SigCgt Bitmap。</strong></p>
<p>我们可以看到，在 Golang 程序里，很多信号都注册了自己的 handler，当然也包括了 SIGTERM(15)，也就是 bit 15。</p>
<p>而 C 程序里，缺省状态下，一个信号 handler 都没有注册；bash 程序里注册了两个 handler，bit 2 和 bit 17，也就是 SIGINT 和 SIGCHLD，但是没有注册 SIGTERM。</p>
<p>所以，C 程序和 bash 程序里 SIGTERM 的 handler 是 SIG_DFL（系统缺省行为），那么它们就不能被 SIGTERM 所杀。</p>
<p>具体我们可以看一下这段 /proc 系统的进程状态：</p>
<h3 id="golang-init">golang init</h3>
<h1 id="cat-proc1status--grep--i-sigcgt">cat /proc/1/status | grep -i SigCgt</h1>
<p>SigCgt:     fffffffe7fc1feff</p>
<h3 id="c-init">C init</h3>
<h1 id="cat-proc1status--grep--i-sigcgt-1">cat /proc/1/status | grep -i SigCgt</h1>
<p>SigCgt:     0000000000000000</p>
<h3 id="bash-init">bash init</h3>
<h1 id="cat-proc1status--grep--i-sigcgt-2">cat /proc/1/status | grep -i SigCgt</h1>
<p>SigCgt:     0000000000010002</p>
<p><strong>第二件事，给 C 程序注册一下 SIGTERM handler，捕获 SIGTERM。</strong></p>
<p>我们调用 signal() 系统调用注册 SIGTERM 的 handler，在 handler 里主动退出，再看看容器中 <code>kill 1</code> 的结果。</p>
<p>这次我们就可以看到，<strong>在进程状态的 SigCgt bitmap 里，bit 15 (SIGTERM) 已经置位了。同时，运行</strong> <code>kill 1</code> <strong>也可以把这个 C 程序的 init 进程给杀死了。</strong></p>
<p>#include &lt;stdio.h&gt;<br>
#include &lt;stdlib.h&gt;<br>
#include &lt;sys/types.h&gt;<br>
#include &lt;sys/wait.h&gt;<br>
#include &lt;unistd.h&gt;</p>
<p>void sig_handler(int signo)<br>
{<br>
if (signo == SIGTERM) {<br>
printf(&ldquo;received SIGTERM\n&rdquo;);<br>
exit(0);<br>
}<br>
}</p>
<p>int main(int argc, char *argv[])<br>
{<br>
signal(SIGTERM, sig_handler);</p>
<pre><code>printf(&quot;Process is sleeping\n&quot;);  
while (1) {  
       sleep(100);  
}  
return 0;  
</code></pre>
<p>}</p>
<h1 id="docker-stop-sig-procdocker-rm-sig-proc-3">docker stop sig-proc;docker rm sig-proc</h1>
<h1 id="docker-run---name-sig-proc--d-registrysig-procv1-c-init-sig">docker run &ndash;name sig-proc -d registry/sig-proc:v1 /c-init-sig</h1>
<h1 id="docker-exec--it-sig-proc-bash-3">docker exec -it sig-proc bash</h1>
<p>[root@043f4f717cb5 /]# ps -ef<br>
UID        PID  PPID  C STIME TTY          TIME CMD<br>
root         1     0  0 09:05 ?        00:00:00 /c-init-sig<br>
root         6     0 18 09:06 pts/0    00:00:00 bash<br>
root        19     6  0 09:06 pts/0    00:00:00 ps -ef</p>
<p>[root@043f4f717cb5 /]# cat /proc/1/status | grep SigCgt<br>
SigCgt: 0000000000004000<br>
[root@043f4f717cb5 /]# kill 1</p>
<h1 id="docker-ps">docker ps</h1>
<p>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</p>
<p>好了，到这里我们可以确定这两点：</p>
<ol>
<li><code>kill -9 1</code> 在容器中是不工作的，内核阻止了 1 号进程对 SIGKILL 特权信号的响应。</li>
<li><code>kill 1</code> 分两种情况，如果 1 号进程没有注册 SIGTERM 的 handler，那么对 SIGTERM 信号也不响应，如果注册了 handler，那么就可以响应 SIGTERM 信号。</li>
</ol>
<h2 id="重点总结">重点总结</h2>
<p>好了，今天的内容讲完了。我们来总结一下。</p>
<p>这一讲我们主要讲了 init 进程。围绕这个知识点，我提出了一个真实发生的问题：“为什么我在容器中不能 kill 1 号进程？”。</p>
<p>想要解决这个问题，我们需要掌握两个基本概念。</p>
<p>第一个概念是 Linux 1 号进程。<strong>它是第一个用户态的进程。它直接或者间接创建了 Namespace 中的其他进程。</strong></p>
<p>第二个概念是 Linux 信号。Linux 有 31 个基本信号，进程在处理大部分信号时有三个选择：<strong>忽略、捕获和缺省行为。其中两个特权信号 SIGKILL 和 SIGSTOP 不能被忽略或者捕获。</strong></p>
<p>只知道基本概念还不行，我们还要去解决问题。我带你尝试了用 bash, C 语言还有 Golang 程序作为容器 init 进程，发现它们对 kill 1 的反应是不同的。</p>
<p>因为信号的最终处理都是在 Linux 内核中进行的，因此，我们需要对 Linux 内核代码进行分析。</p>
<p>容器里 1 号进程对信号处理的两个要点，这也是这一讲里我想让你记住的两句话：</p>
<ol>
<li><strong>在容器中，1 号进程永远不会响应 SIGKILL 和 SIGSTOP 这两个特权信号；</strong></li>
<li><strong>对于其他的信号，如果用户自己注册了 handler，1 号进程可以响应。</strong></li>
</ol>
<h2 id="思考题">思考题</h2>
<p>这一讲的最开始，有这样一个 C 语言的 init 进程，它没有注册任何信号的 handler。如果我们从 Host Namespace 向它发送 SIGTERM，会发生什么情况呢？</p>
<p>欢迎留言和我分享你的想法。如果你的朋友也对 1 号进程有困惑，欢迎你把这篇文章分享给他，说不定就帮他解决了一个难题。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/">容器实战高手课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AF%B4%E9%80%8F%E6%95%8F%E6%8D%B7/02__%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93%E6%95%8F%E6%8D%B7%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">02__老生常谈：你真的知道敏捷到底是什么吗？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/webassembly%E5%85%A5%E9%97%A8%E8%AF%BE/02__%E5%8E%86%E5%8F%B2%E7%AF%87%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89_webassembly_%E8%BF%99%E6%A0%B7%E4%B8%80%E9%97%A8%E6%8A%80%E6%9C%AF/">
            <span class="next-text nav-default">02__历史篇：为什么会有_WebAssembly_这样一门技术？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
