<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>加餐06__BCC：入门eBPF的前端工具 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是程远。
今天是我们专题加餐的最后一讲，明天就是春节了，我想给还在学习的你点个赞。这里我先给你拜个早年，祝愿你牛年工作顺利，健康如意！
上一讲，我们学习了 eBPF 的基本概念，以及 eBPF 编程的一个基本模型。在理解了这些概念之后，从理论上来说，你就能自己写出 eBPF 的程序，对 Linux 系统上的一些问题做跟踪和调试了。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/%E5%8A%A0%E9%A4%9006__bcc%E5%85%A5%E9%97%A8ebpf%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/%E5%8A%A0%E9%A4%9006__bcc%E5%85%A5%E9%97%A8ebpf%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="加餐06__BCC：入门eBPF的前端工具">
  <meta property="og:description" content="你好，我是程远。
今天是我们专题加餐的最后一讲，明天就是春节了，我想给还在学习的你点个赞。这里我先给你拜个早年，祝愿你牛年工作顺利，健康如意！
上一讲，我们学习了 eBPF 的基本概念，以及 eBPF 编程的一个基本模型。在理解了这些概念之后，从理论上来说，你就能自己写出 eBPF 的程序，对 Linux 系统上的一些问题做跟踪和调试了。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="容器实战高手课">

  <meta itemprop="name" content="加餐06__BCC：入门eBPF的前端工具">
  <meta itemprop="description" content="你好，我是程远。
今天是我们专题加餐的最后一讲，明天就是春节了，我想给还在学习的你点个赞。这里我先给你拜个早年，祝愿你牛年工作顺利，健康如意！
上一讲，我们学习了 eBPF 的基本概念，以及 eBPF 编程的一个基本模型。在理解了这些概念之后，从理论上来说，你就能自己写出 eBPF 的程序，对 Linux 系统上的一些问题做跟踪和调试了。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4584">
  <meta itemprop="keywords" content="容器实战高手课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="加餐06__BCC：入门eBPF的前端工具">
  <meta name="twitter:description" content="你好，我是程远。
今天是我们专题加餐的最后一讲，明天就是春节了，我想给还在学习的你点个赞。这里我先给你拜个早年，祝愿你牛年工作顺利，健康如意！
上一讲，我们学习了 eBPF 的基本概念，以及 eBPF 编程的一个基本模型。在理解了这些概念之后，从理论上来说，你就能自己写出 eBPF 的程序，对 Linux 系统上的一些问题做跟踪和调试了。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">加餐06__BCC：入门eBPF的前端工具</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4584 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#如何使用-bcc-工具">如何使用 BCC 工具</a></li>
      </ul>
    </li>
    <li><a href="#apt-install-bpfcc-tools">apt install bpfcc-tools</a></li>
    <li><a href="#ls--l-sbin-bpfcc--more">ls -l /sbin/*-bpfcc | more</a></li>
    <li><a href="#opensnoop-bpfcc">opensnoop-bpfcc</a></li>
    <li><a href="#softirqs-bpfcc--d">softirqs-bpfcc -d</a>
      <ul>
        <li><a href="#bcc-的工作原理">BCC 的工作原理</a></li>
      </ul>
    </li>
    <li><a href="#define-bpf-program">define BPF program</a></li>
    <li><a href="#initialize-bpf">initialize BPF</a></li>
    <li><a href="#loop-with-callback-to-print_event">loop with callback to print_event</a>
      <ul>
        <li><a href="#bcc-工具的发展">BCC 工具的发展</a></li>
      </ul>
    </li>
    <li><a href="#git-remote--v">git remote -v</a></li>
    <li><a href="#cd-libbpf-tools">cd libbpf-tools/</a></li>
    <li><a href="#make-v1">make V=1</a></li>
    <li><a href="#cat-opensnoopbpfc--head">cat opensnoop.bpf.c | head</a></li>
    <li><a href="#uname--r">uname -r</a></li>
    <li><a href="#ls--lh-opensnoop">ls -lh opensnoop</a></li>
    <li><a href="#opensnoop">./opensnoop</a>
      <ul>
        <li><a href="#重点小结">重点小结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是程远。</p>
<p>今天是我们专题加餐的最后一讲，明天就是春节了，我想给还在学习的你点个赞。这里我先给你拜个早年，祝愿你牛年工作顺利，健康如意！</p>
<p>上一讲，我们学习了 eBPF 的基本概念，以及 eBPF 编程的一个基本模型。在理解了这些概念之后，从理论上来说，你就能自己写出 eBPF 的程序，对 Linux 系统上的一些问题做跟踪和调试了。</p>
<p>不过，从上一讲的例子里估计你也发现了，eBPF 的程序从编译到运行还是有些复杂。</p>
<p>为了方便我们用 eBPF 的程序跟踪和调试系统，社区有很多 eBPF 的前端工具。在这些前端工具中，BCC 提供了最完整的工具集，以及用于 eBPF 工具开发的 Python/Lua/C++ 的接口。那么今天我们就一起来看看，怎么使用 BCC 这个 eBPF 的前端工具。</p>
<h2 id="如何使用-bcc-工具">如何使用 BCC 工具</h2>
<p>BCC（BPF Compiler Collection）这个社区项目开始于 2015 年，差不多在内核中支持了 eBPF 的特性之后，BCC 这个项目就开始了。</p>
<p>BCC 的目标就是提供一个工具链，用于编写、编译还有内核加载 eBPF 程序，同时 BCC 也提供了大量的 eBPF 的工具程序，这些程序能够帮我们做 Linux 的性能分析和跟踪调试。</p>
<p>这里我们可以先尝试用几个 BCC 的工具，通过实际操作来了解一下 BCC。</p>
<p>大部分 Linux 发行版本都有 BCC 的软件包，你可以直接安装。比如我们可以在 Ubuntu 20.04 上试试，用下面的命令安装 BCC：</p>
<h1 id="apt-install-bpfcc-tools">apt install bpfcc-tools</h1>
<p>安装完 BCC 软件包之后，你在 Linux 系统上就会看到多了 100 多个 BCC 的小工具（在 Ubuntu 里，这些工具的名字后面都加了 bpfcc 的后缀）：</p>
<h1 id="ls--l-sbin-bpfcc--more">ls -l /sbin/*-bpfcc | more</h1>
<p>-rwxr-xr-x 1 root root 34536 Feb  7  2020 /sbin/argdist-bpfcc<br>
-rwxr-xr-x 1 root root  2397 Feb  7  2020 /sbin/bashreadline-bpfcc<br>
-rwxr-xr-x 1 root root  6231 Feb  7  2020 /sbin/biolatency-bpfcc<br>
-rwxr-xr-x 1 root root  5524 Feb  7  2020 /sbin/biosnoop-bpfcc<br>
-rwxr-xr-x 1 root root  6439 Feb  7  2020 /sbin/biotop-bpfcc<br>
-rwxr-xr-x 1 root root  1152 Feb  7  2020 /sbin/bitesize-bpfcc<br>
-rwxr-xr-x 1 root root  2453 Feb  7  2020 /sbin/bpflist-bpfcc<br>
-rwxr-xr-x 1 root root  6339 Feb  7  2020 /sbin/btrfsdist-bpfcc<br>
-rwxr-xr-x 1 root root  9973 Feb  7  2020 /sbin/btrfsslower-bpfcc<br>
-rwxr-xr-x 1 root root  4717 Feb  7  2020 /sbin/cachestat-bpfcc<br>
-rwxr-xr-x 1 root root  7302 Feb  7  2020 /sbin/cachetop-bpfcc<br>
-rwxr-xr-x 1 root root  6859 Feb  7  2020 /sbin/capable-bpfcc<br>
-rwxr-xr-x 1 root root    53 Feb  7  2020 /sbin/cobjnew-bpfcc<br>
-rwxr-xr-x 1 root root  5209 Feb  7  2020 /sbin/cpudist-bpfcc<br>
-rwxr-xr-x 1 root root 14597 Feb  7  2020 /sbin/cpuunclaimed-bpfcc<br>
-rwxr-xr-x 1 root root  8504 Feb  7  2020 /sbin/criticalstat-bpfcc<br>
-rwxr-xr-x 1 root root  7095 Feb  7  2020 /sbin/dbslower-bpfcc<br>
-rwxr-xr-x 1 root root  3780 Feb  7  2020 /sbin/dbstat-bpfcc<br>
-rwxr-xr-x 1 root root  3938 Feb  7  2020 /sbin/dcsnoop-bpfcc<br>
-rwxr-xr-x 1 root root  3920 Feb  7  2020 /sbin/dcstat-bpfcc<br>
-rwxr-xr-x 1 root root 19930 Feb  7  2020 /sbin/deadlock-bpfcc<br>
-rwxr-xr-x 1 root root  7051 Dec 10  2019 /sbin/deadlock.c-bpfcc<br>
-rwxr-xr-x 1 root root  6830 Feb  7  2020 /sbin/drsnoop-bpfcc<br>
-rwxr-xr-x 1 root root  7658 Feb  7  2020 /sbin/execsnoop-bpfcc<br>
-rwxr-xr-x 1 root root 10351 Feb  7  2020 /sbin/exitsnoop-bpfcc<br>
-rwxr-xr-x 1 root root  6482 Feb  7  2020 /sbin/ext4dist-bpfcc<br>
&hellip;</p>
<p>这些工具几乎覆盖了 Linux 内核中各个模块，它们可以对 Linux 某个模块做最基本的 profile。你可以看看下面这张图，图里把 BCC 的工具与 Linux 中的各个模块做了一个映射。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/b0e36620c51acccf7c09e1229171483a.png" alt=""></p>
<p>在 BCC 的 github repo 里，也有很完整的文档和例子来描述每一个工具。Brendan D. Gregg写了一本书，书名叫《BPF Performance Tools》（我们上一讲也提到过这本书），这本书从 Linux CPU/Memory/Filesystem/Disk/Networking 等角度介绍了如何使用 BCC 工具，感兴趣的你可以自行学习。</p>
<p>为了让你更容易理解，这里我给你举两个例子。</p>
<p>第一个是使用 opensnoop 工具，用它来监控节点上所有打开文件的操作。这个命令有时候也可以用来查看某个文件被哪个进程给动过。</p>
<p>比如说，我们先启动 opensnoop，然后在其他的 console 里运行 <code>touch test-open</code> 命令，这时候我们就会看到 <code>touch</code> 命令在启动时读取到的库文件和配置文件，以及最后建立的“test-open”这个文件。</p>
<h1 id="opensnoop-bpfcc">opensnoop-bpfcc</h1>
<p>PID    COMM               FD ERR PATH<br>
2522843 touch               3   0 /etc/ld.so.cache<br>
2522843 touch               3   0 /lib/x86_64-linux-gnu/libc.so.6<br>
2522843 touch               3   0 /usr/lib/locale/locale-archive<br>
2522843 touch               3   0 /usr/share/locale/locale.alias<br>
2522843 touch               3   0 /usr/lib/locale/C.UTF-8/LC_IDENTIFICATION<br>
2522843 touch               3   0 /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache<br>
2522843 touch               3   0 /usr/lib/locale/C.UTF-8/LC_MEASUREMENT<br>
2522843 touch               3   0 /usr/lib/locale/C.UTF-8/LC_TELEPHONE<br>
2522843 touch               3   0 /usr/lib/locale/C.UTF-8/LC_ADDRESS<br>
2522843 touch               3   0 /usr/lib/locale/C.UTF-8/LC_NAME<br>
2522843 touch               3   0 /usr/lib/locale/C.UTF-8/LC_PAPER<br>
2522843 touch               3   0 /usr/lib/locale/C.UTF-8/LC_MESSAGES<br>
2522843 touch               3   0 /usr/lib/locale/C.UTF-8/LC_MESSAGES/SYS_LC_MESSAGES<br>
2522843 touch               3   0 /usr/lib/locale/C.UTF-8/LC_MONETARY<br>
2522843 touch               3   0 /usr/lib/locale/C.UTF-8/LC_COLLATE<br>
2522843 touch               3   0 /usr/lib/locale/C.UTF-8/LC_TIME<br>
2522843 touch               3   0 /usr/lib/locale/C.UTF-8/LC_NUMERIC<br>
2522843 touch               3   0 /usr/lib/locale/C.UTF-8/LC_CTYPE<br>
2522843 touch               3   0 test-open</p>
<p>第二个是使用 softirqs 这个命令，查看节点上各种类型的 softirqs 花费时间的分布图（直方图模式）。</p>
<p>比如在下面这个例子里，每一次 timer softirq 执行时间在 0～1us 时间区间里的有 16 次，在 2-3us 时间区间里的有 49 次，以此类推。</p>
<p>在我们分析网络延时的时候，也用过这个 softirqs 工具，用它来确认 timer softirq 花费的时间。</p>
<h1 id="softirqs-bpfcc--d">softirqs-bpfcc -d</h1>
<p>Tracing soft irq event time&hellip; Hit Ctrl-C to end.<br>
^C</p>
<p>softirq = block<br>
usecs               : count     distribution<br>
0 -&gt; 1          : 2        |********************                    |<br>
2 -&gt; 3          : 3        |******************************          |<br>
4 -&gt; 7          : 2        |********************                    |<br>
8 -&gt; 15         : 4        |****************************************|</p>
<p>softirq = rcu<br>
usecs               : count     distribution<br>
0 -&gt; 1          : 189      |***********************************<em><strong><strong>|<br>
2 -&gt; 3          : 52       |***********                             |<br>
4 -&gt; 7          : 21       |</strong></strong>                                    |<br>
8 -&gt; 15         : 5        |</em>                                       |<br>
16 -&gt; 31         : 1        |                                        |</p>
<p>softirq = net_rx<br>
usecs               : count     distribution<br>
0 -&gt; 1          : 1        |********************                    |<br>
2 -&gt; 3          : 0        |                                        |<br>
4 -&gt; 7          : 2        |<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>|<br>
8 -&gt; 15         : 0        |                                        |<br>
16 -&gt; 31         : 2        |</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>|</p>
<p>softirq = timer<br>
usecs               : count     distribution<br>
0 -&gt; 1          : 16       |*************                           |<br>
2 -&gt; 3          : 49       |****************<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>|<br>
4 -&gt; 7          : 43       |***********************************     |<br>
8 -&gt; 15         : 5        |</strong></strong>                                    |<br>
16 -&gt; 31         : 13       |</strong></strong></strong></strong></strong>                              |<br>
32 -&gt; 63         : 13       |</strong></strong></strong></strong></strong>                              |</p>
<p>softirq = sched<br>
usecs               : count     distribution<br>
0 -&gt; 1          : 18       |******                                  |<br>
2 -&gt; 3          : 107      |*********************************<em><strong><strong><strong>|<br>
4 -&gt; 7          : 20       |</strong></strong></strong></em>                                 |<br>
8 -&gt; 15         : 1        |                                        |<br>
16 -&gt; 31         : 1        |                                        |</p>
<p>BCC 中的工具数目虽然很多，但是你用过之后就会发现，它们的输出模式基本上就是上面我说的这两种。</p>
<p>第一种类似事件模式，就像 opensnoop 的输出一样，发生一次就输出一次；第二种是直方图模式，就是把内核中执行函数的时间做个统计，然后用直方图的方式输出，也就是 <code>softirqs -d</code> 的执行结果。</p>
<p>用过 BCC 工具之后，我们再来看一下 BCC 工具的工作原理，这样以后你有需要的时候，自己也可以编写和部署一个 BCC 工具了。</p>
<h2 id="bcc-的工作原理">BCC 的工作原理</h2>
<p>让我们来先看一下 BCC 工具的代码结构。</p>
<p>因为目前 BCC 的工具都是用 python 写的，所以你直接可以用文本编辑器打开节点上的一个工具文件。比如打开 /sbin/opensnoop-bpfcc 文件（也可在 github bcc 项目中查看 opensnoop.py），这里你可以看到大概 200 行左右的代码，代码主要分成了两部分。</p>
<p>第一部分其实是一块 C 代码，里面定义的就是 eBPF 内核态的代码，不过它是以 python 字符串的形式加在代码中的。</p>
<p>我在下面列出了这段 C 程序的主干，其实就是定义两个 eBPF Maps 和两个 eBPF Programs 的函数：</p>
<h1 id="define-bpf-program">define BPF program</h1>
<p>bpf_text = &quot;&quot;&quot;<br>
#include &lt;uapi/linux/ptrace.h&gt;<br>
#include &lt;uapi/linux/limits.h&gt;<br>
#include &lt;linux/sched.h&gt;</p>
<p>…</p>
<p>BPF_HASH(infotmp, u64, struct val_t);  //BPF_MAP_TYPE_HASH<br>
BPF_PERF_OUTPUT(events);                   // BPF_MAP_TYPE_PERF_EVENT_ARRAY</p>
<p>int trace_entry(struct pt_regs *ctx, int dfd, const char __user *filename, int flags)<br>
{<br>
…<br>
}</p>
<p>int trace_return(struct pt_regs *ctx)<br>
{<br>
…<br>
}<br>
“””</p>
<p>第二部分就是用 python 写的用户态代码，它的作用是加载内核态 eBPF 的代码，把内核态的函数 trace_entry() 以 kprobe 方式挂载到内核函数 do_sys_open()，把 trace_return() 以 kproberet 方式也挂载到 do_sys_open()，然后从 eBPF Maps 里读取数据并且输出。</p>
<p>…</p>
<h1 id="initialize-bpf">initialize BPF</h1>
<p>b = BPF(text=bpf_text)<br>
b.attach_kprobe(event=&ldquo;do_sys_open&rdquo;, fn_name=&ldquo;trace_entry&rdquo;)<br>
b.attach_kretprobe(event=&ldquo;do_sys_open&rdquo;, fn_name=&ldquo;trace_return&rdquo;)<br>
…</p>
<h1 id="loop-with-callback-to-print_event">loop with callback to print_event</h1>
<p>b[&ldquo;events&rdquo;].open_perf_buffer(print_event, page_cnt=64)<br>
start_time = datetime.now()<br>
while not args.duration or datetime.now() - start_time &lt; args.duration:<br>
try:<br>
b.perf_buffer_poll()<br>
except KeyboardInterrupt:<br>
exit()<br>
…</p>
<p>从代码的结构看，其实这和我们上一讲介绍的 eBPF 标准的编程模式是差不多的，只是用户态的程序是用 python 来写的。不过这里有一点比较特殊，用户态在加载程序的时候，输入的是 C 程序的文本而不是 eBPF bytecode。</p>
<p>BCC 可以这么做，是因为它通过 pythonBPF() 加载 C 代码之后，调用 libbcc 库中的函数 bpf_module_create_c_from_string() 把 C 代码编译成了 eBPF bytecode。也就是说，libbcc 库中集成了 clang/llvm 的编译器。</p>
<pre><code>def __init__(self, src_file=b&quot;&quot;, hdr_file=b&quot;&quot;, text=None, debug=0,  
        cflags=[], usdt_contexts=[], allow_rlimit=True, device=None):  
    &quot;&quot;&quot;Create a new BPF module with the given source code.  
</code></pre>
<p>&hellip;<br>
self.module = lib.bpf_module_create_c_from_string(text, self.debug，cflags_array, len(cflags_array), allow_rlimit, device)<br>
&hellip;</p>
<p>我们弄明白 libbcc 库的作用之后，再来整体看一下 BCC 工具的工作方式。为了让你理解，我给你画了一张示意图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/d5cc3c3d91179c0674ad50a7efa48905.png" alt=""></p>
<p>BCC 的这种设计思想是为了方便 eBPF 程序的开发和使用，特别是 eBPF 内核态的代码对当前运行的内核版本是有依赖的，比如在 4.15 内核的节点上编译好的 bytecode，放到 5.4 内核的节点上很有可能是运行不了的。</p>
<p>那么让编译和运行都在同一个节点，出现问题就可以直接修改源代码文件了。你有没有发现，这么做有点像把 C 程序的处理当成 python 的处理方式。</p>
<p>BCC 的这种设计思想虽然有好处，但是也带来了问题。其实问题也是很明显的，首先我们需要在运行 BCC 工具的节点上必须安装内核头文件，这个在编译内核态 eBPF C 代码的时候是必须要做的。</p>
<p>其次，在 libbcc 的库里面包含了 clang/llvm 的编译器，这不光占用磁盘空间，在运行程序前还需要编译，也会占用节点的 CPU 和 Memory，同时也让 BCC 工具的启动时间变长。这两个问题都会影响到 BCC 生产环境中的使用。</p>
<h2 id="bcc-工具的发展">BCC 工具的发展</h2>
<p>那么我们有什么办法来解决刚才说的问题呢？eBPF 的技术在不断进步，最新的 BPF CO-RE 技术可以解决这个问题。我们下面就来看 BPF CO-RE 是什么意思。</p>
<p>CO-RE 是“Compile Once – Run Everywhere”的缩写，BPF CO-RE 通过对 Linux 内核、用户态 BPF loader（libbpf 库）以及 Clang 编译器的修改，来实现编译出来的 eBPF 程序可以在不同版本的内核上运行。</p>
<p>不同版本的内核上，用 CO-RE 编译出来的 eBPF 程序都可以运行。在 Linux 内核和 BPF 程序之间，会通过BTF（BPF Type Format）来协调不同版本内核中数据结构的变量偏移或者变量长度变化等问题。</p>
<p>在 BCC 的 github repo 里，有一个目录libbpf-tools，在这个目录下已经有一些重写过的 BCC 工具的源代码，它们并不是用 python+libbcc 的方式实现的，而是用到了 libbpf+BPF CO-RE 的方式。</p>
<p>如果你的系统上有高于版本 10 的 CLANG/LLVM 编译器，就可以尝试编译一下 libbpf-tools 下的工具。这里可以加一个“V=1”参数，这样我们就能清楚编译的步骤了。</p>
<h1 id="git-remote--v">git remote -v</h1>
<p>origin   <a href="https://github.com/iovisor/bcc.git">https://github.com/iovisor/bcc.git</a> (fetch)<br>
origin   <a href="https://github.com/iovisor/bcc.git">https://github.com/iovisor/bcc.git</a> (push)</p>
<h1 id="cd-libbpf-tools">cd libbpf-tools/</h1>
<h1 id="make-v1">make V=1</h1>
<p>mkdir -p .output<br>
mkdir -p .output/libbpf<br>
make -C /root/bcc/src/cc/libbpf/src BUILD_STATIC_ONLY=1                             \<br>
OBJDIR=/root/bcc/libbpf-tools/.output//libbpf DESTDIR=/root/bcc/libbpf-tools/.output/                   \<br>
INCLUDEDIR= LIBDIR= UAPIDIR=                                  \<br>
Install<br>
…</p>
<p>ar rcs /root/bcc/libbpf-tools/.output//libbpf/libbpf.a …</p>
<p>…</p>
<p>clang -g -O2 -target bpf -D__TARGET_ARCH_x86                        \<br>
-I.output -c opensnoop.bpf.c -o .output/opensnoop.bpf.o &amp;&amp;                      \<br>
llvm-strip -g .output/opensnoop.bpf.o<br>
bin/bpftool gen skeleton .output/opensnoop.bpf.o &gt; .output/opensnoop.skel.h<br>
cc -g -O2 -Wall -I.output -c opensnoop.c -o .output/opensnoop.o<br>
cc -g -O2 -Wall .output/opensnoop.o /root/bcc/libbpf-tools/.output/libbpf.a .output/trace_helpers.o .output/syscall_helpers.o .output/errno_helpers.o -lelf -lz -o opensnoop</p>
<p>…</p>
<p>我们梳理一下编译的过程。首先这段代码生成了 libbpf.a 这个静态库，然后逐个的编译每一个工具。对于每一个工具的代码结构是差不多的，编译的方法也是差不多的。</p>
<p>我们拿 opensnoop 做例子来看一下，它的源代码分为两个文件。opensnoop.bpf.c 是内核态的 eBPF 代码，opensnoop.c 是用户态的代码，这个和我们之前学习的 eBPF 代码的标准结构是一样的。主要不同点有下面这些。</p>
<p>内核态的代码不再逐个 include 内核代码的头文件，而是只要 include 一个“vmlinux.h”就可以。在“vmlinux.h”中包含了所有内核的数据结构，它是由内核文件 vmlinux 中的 BTF 信息转化而来的。</p>
<h1 id="cat-opensnoopbpfc--head">cat opensnoop.bpf.c | head</h1>
<p>// SPDX-License-Identifier: GPL-2.0<br>
// Copyright (c) 2019 Facebook<br>
// Copyright (c) 2020 Netflix<br>
#include &ldquo;vmlinux.h&rdquo;<br>
#include &lt;bpf/bpf_helpers.h&gt;<br>
#include &ldquo;opensnoop.h&rdquo;</p>
<p>#define TASK_RUNNING 0</p>
<p>const volatile __u64 min_us = 0;</p>
<p>我们使用bpftool这个工具，可以把编译出来的 opensnoop.bpf.o 重新生成为一个 C 语言的头文件 opensnoop.skel.h。这个头文件中定义了加载 eBPF 程序的函数，eBPF bytecode 的二进制流也直接写在了这个头文件中。</p>
<p>bin/bpftool gen skeleton .output/opensnoop.bpf.o &gt; .output/opensnoop.skel.h</p>
<p>用户态的代码 opensnoop.c 直接 include 这个 opensnoop.skel.h，并且调用里面的 eBPF 加载的函数。这样在编译出来的可执行程序 opensnoop，就可以直接运行了，不用再找 eBPF bytecode 文件或者 eBPF 内核态的 C 文件。并且这个 opensnoop 程序可以运行在不同版本内核的节点上（当然，这个内核需要打开 CONFIG_DEBUG_INFO_BTF 这个编译选项）。</p>
<p>比如，我们可以把在 kernel5.4 节点上编译好的 opensnoop 程序 copy 到一台 kernel5.10.4 的节点来运行：</p>
<h1 id="uname--r">uname -r</h1>
<p>5.10.4</p>
<h1 id="ls--lh-opensnoop">ls -lh opensnoop</h1>
<p>-rwxr-x&mdash; 1 root root 235K Jan 30 23:08 opensnoop</p>
<h1 id="opensnoop">./opensnoop</h1>
<p>PID    COMM              FD ERR PATH<br>
2637411 opensnoop         24   0 /etc/localtime<br>
1      systemd           28   0 /proc/746/cgroup</p>
<p>从上面的代码我们会发现，这时候的 opensnoop 不依赖任何的库函数，只有一个文件，strip 后的文件大小只有 235KB，启动运行的时候，既不不需要读取外部的文件，也不会做额外的编译。</p>
<h2 id="重点小结">重点小结</h2>
<p>好了，今天我们主要讲了 eBPF 的一个前端工具 BCC，我来给你总结一下。</p>
<p>在我看来，对于把 eBPF 运用于 Linux 内核的性能分析和跟踪调试这个领域，BCC 是社区中最有影响力的一个项目。BCC 项目提供了 eBPF 工具开发的 Python/Lua/C++ 的接口，以及上百个基于 eBPF 的工具。</p>
<p>对不熟悉 eBPF 的同学来说，可以直接拿这些工具来调试 Linux 系统中的问题。而对于了解 eBPF 的同学，也可以利用 BCC 提供的接口，开发自己需要的 eBPF 工具。</p>
<p>BCC 工具目前主要通过 ptyhon+libbcc 的模式在目标节点上运行，但是这个模式需要节点有内核头文件以及内嵌在 libbcc 中的 Clang/LLVM 编译器，每次程序启动的时候还需要再做一次编译。</p>
<p>为了弥补这个缺点，BCC 工具开始向 libbpf+BPF CO-RE 的模式转变。用这种新模式编译出来的 BCC 工具程序，只需要很少的系统资源就可以在目标节点上运行，并且不受内核版本的限制。</p>
<p>除了 BCC 之外，你还可以看一下bpftrace、ebpf-exporter等 eBPF 的前端工具。</p>
<p>bpftrace 提供了类似 awk 和 C 语言混合的一种语言，在使用时也很类似 awk，可以用一两行的命令来完成一次 eBPF 的调用，它能做一些简单的内核事件的跟踪。当然它也可以编写比较复杂的 eBPF 程序。</p>
<p>ebpf-exporter 可以把 eBPF 程序收集到的 metrics 以Prometheus的格式对外输出，然后通过Grafana的 dashboard，可以对内核事件做长期的以及更加直观的监控。</p>
<p>总之，前面提到的这些工具，你都可以好好研究一下，它们可以帮助你对容器云平台上的节点做内核级别的监控与诊断。</p>
<h2 id="思考题">思考题</h2>
<p>这一讲的最后，我给你留一道思考题吧。</p>
<p>你可以动手操作一下，尝试编译和运行 BCC 项目中libbpf-tools目录下的工具。</p>
<p>欢迎你在留言区记录你的心得或者疑问。如果这一讲对你有帮助，也欢迎分享给你的同事、朋友，和他一起学习进步。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/">容器实战高手课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE/%E5%8A%A0%E9%A4%9005__ebpf%E6%80%8E%E4%B9%88%E6%9B%B4%E5%8A%A0%E6%B7%B1%E5%85%A5%E5%9C%B0%E6%9F%A5%E7%9C%8B%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">加餐05__eBPF：怎么更加深入地查看内核中的函数？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/%E5%8A%A0%E9%A4%901__%E5%B8%A6%E4%BD%A0%E5%90%83%E9%80%8F%E8%AF%BE%E7%A8%8B%E4%B8%ADjava_8%E7%9A%84%E9%82%A3%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8A/">
            <span class="next-text nav-default">加餐1__带你吃透课程中Java_8的那些重要知识点（上）</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
