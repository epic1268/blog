<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>45__发送网络包（上）：如何表达我们想让合作伙伴做什么？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="上一节，我们通过 socket 函数、bind 函数、listen 函数、accept 函数以及 connect 函数，在内核建立好了数据结构，并完成了 TCP 连接建立的三次握手过程。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/45__%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E5%8C%85%E4%B8%8A%E5%A6%82%E4%BD%95%E8%A1%A8%E8%BE%BE%E6%88%91%E4%BB%AC%E6%83%B3%E8%AE%A9%E5%90%88%E4%BD%9C%E4%BC%99%E4%BC%B4%E5%81%9A%E4%BB%80%E4%B9%88/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/45__%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E5%8C%85%E4%B8%8A%E5%A6%82%E4%BD%95%E8%A1%A8%E8%BE%BE%E6%88%91%E4%BB%AC%E6%83%B3%E8%AE%A9%E5%90%88%E4%BD%9C%E4%BC%99%E4%BC%B4%E5%81%9A%E4%BB%80%E4%B9%88/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="45__发送网络包（上）：如何表达我们想让合作伙伴做什么？">
  <meta property="og:description" content="上一节，我们通过 socket 函数、bind 函数、listen 函数、accept 函数以及 connect 函数，在内核建立好了数据结构，并完成了 TCP 连接建立的三次握手过程。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="趣谈Linux操作系统">

  <meta itemprop="name" content="45__发送网络包（上）：如何表达我们想让合作伙伴做什么？">
  <meta itemprop="description" content="上一节，我们通过 socket 函数、bind 函数、listen 函数、accept 函数以及 connect 函数，在内核建立好了数据结构，并完成了 TCP 连接建立的三次握手过程。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6301">
  <meta itemprop="keywords" content="趣谈Linux操作系统">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="45__发送网络包（上）：如何表达我们想让合作伙伴做什么？">
  <meta name="twitter:description" content="上一节，我们通过 socket 函数、bind 函数、listen 函数、accept 函数以及 connect 函数，在内核建立好了数据结构，并完成了 TCP 连接建立的三次握手过程。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">45__发送网络包（上）：如何表达我们想让合作伙伴做什么？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6301 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#解析-socket-的-write-操作">解析 socket 的 Write 操作</a></li>
        <li><a href="#解析-tcp_sendmsg-函数">解析 tcp_sendmsg 函数</a></li>
        <li><a href="#解析-tcp_write_xmit-函数">解析 tcp_write_xmit 函数</a></li>
        <li><a href="#总结时刻">总结时刻</a></li>
        <li><a href="#课堂练习">课堂练习</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>上一节，我们通过 socket 函数、bind 函数、listen 函数、accept 函数以及 connect 函数，在内核建立好了数据结构，并完成了 TCP 连接建立的三次握手过程。</p>
<p>这一节，我们接着来分析，发送一个网络包的过程。</p>
<h2 id="解析-socket-的-write-操作">解析 socket 的 Write 操作</h2>
<p>socket 对于用户来讲，是一个文件一样的存在，拥有一个文件描述符。因而对于网络包的发送，我们可以使用对于 socket 文件的写入系统调用，也就是 write 系统调用。</p>
<p>write 系统调用对于一个文件描述符的操作，大致过程都是类似的。在文件系统那一节，我们已经详细解析过，这里不再多说。对于每一个打开的文件都有一个 struct file 结构，write 系统调用会最终调用 stuct file 结构指向的 file_operations 操作。</p>
<p>对于 socket 来讲，它的 file_operations 定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">const</span> <span class="n">struct</span> <span class="n">file_operations</span> <span class="n">socket_file_ops</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">llseek</span> <span class="o">=</span>	<span class="n">no_llseek</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">read_iter</span> <span class="o">=</span>	<span class="n">sock_read_iter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">write_iter</span> <span class="o">=</span>	<span class="n">sock_write_iter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">poll</span> <span class="o">=</span>		<span class="n">sock_poll</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">sock_ioctl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">sock_mmap</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">sock_close</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">fasync</span> <span class="o">=</span>	<span class="n">sock_fasync</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">sendpage</span> <span class="o">=</span>	<span class="n">sock_sendpage</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">splice_write</span> <span class="o">=</span> <span class="n">generic_splice_sendpage</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">splice_read</span> <span class="o">=</span>	<span class="n">sock_splice_read</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>按照文件系统的写入流程，调用的是 sock_write_iter。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static ssize_t sock_write_iter(struct kiocb *iocb, struct iov_iter *from)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct file *file = iocb-&gt;ki_filp;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct socket *sock = file-&gt;private_data;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct msghdr msg = {.msg_iter = *from,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			     .msg_iocb = iocb};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	ssize_t res;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	res = sock_sendmsg(sock, &amp;msg);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	*from = msg.msg_iter;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return res;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 sock_write_iter 中，我们通过 VFS 中的 struct file，将创建好的 socket 结构拿出来，然后调用 sock_sendmsg。而 sock_sendmsg 会调用 sock_sendmsg_nosec。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int ret = sock-&gt;ops-&gt;sendmsg(sock, msg, msg_data_left(msg));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里调用了 socket 的 ops 的 sendmsg，我们在上一节已经遇到它好几次了。根据 inet_stream_ops 的定义，我们这里调用的是 inet_sendmsg。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int inet_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct sock *sk = sock-&gt;sk;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return sk-&gt;sk_prot-&gt;sendmsg(sk, msg, size);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里面，从 socket 结构中，我们可以得到更底层的 sock 结构，然后调用 sk_prot 的 sendmsg 方法。这个我们同样在上一节遇到好几次了。</p>
<h2 id="解析-tcp_sendmsg-函数">解析 tcp_sendmsg 函数</h2>
<p>根据 tcp_prot 的定义，我们调用的是 tcp_sendmsg。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int tcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct tcp_sock *tp = tcp_sk(sk);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct sk_buff *skb;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int flags, err, copied = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int mss_now = 0, size_goal, copied_syn = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	long timeo;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	/* Ok commence sending. */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	copied = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">restart:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	mss_now = tcp_send_mss(sk, &amp;size_goal, flags);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	while (msg_data_left(msg)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		int copy = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		int max = size_goal;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 		skb = tcp_write_queue_tail(sk);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (tcp_send_head(sk)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			if (skb-&gt;ip_summed == CHECKSUM_NONE)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				max = mss_now;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			copy = max - skb-&gt;len;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 		if (copy &lt;= 0 || !tcp_skb_can_collapse_to(skb)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			bool first_skb;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> new_segment:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			/* Allocate new segment. If the interface is SG,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			 * allocate skb fitting to single page.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			 */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			if (!sk_stream_memory_free(sk))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				goto wait_for_sndbuf;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			first_skb = skb_queue_empty(&amp;sk-&gt;sk_write_queue);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			skb = sk_stream_alloc_skb(sk,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">						  select_size(sk, sg, first_skb),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">						  sk-&gt;sk_allocation,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">						  first_skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			skb_entail(sk, skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			copy = size_goal;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			max = size_goal;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 		/* Try to append data to the end of skb. */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (copy &gt; msg_data_left(msg))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			copy = msg_data_left(msg);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 		/* Where to copy to? */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (skb_availroom(skb) &gt; 0) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			/* We have some space in skb head. Superb! */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			copy = min_t(int, copy, skb_availroom(skb));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			err = skb_add_data_nocache(sk, skb, &amp;msg-&gt;msg_iter, copy);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		} else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			bool merge = true;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			int i = skb_shinfo(skb)-&gt;nr_frags;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			struct page_frag *pfrag = sk_page_frag(sk);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			copy = min_t(int, copy, pfrag-&gt;size - pfrag-&gt;offset);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			err = skb_copy_to_page_nocache(sk, &amp;msg-&gt;msg_iter, skb,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">						       pfrag-&gt;page,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">						       pfrag-&gt;offset,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">						       copy);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			pfrag-&gt;offset += copy;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> ......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		tp-&gt;write_seq += copy;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		TCP_SKB_CB(skb)-&gt;end_seq += copy;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		tcp_skb_pcount_set(skb, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 		copied += copy;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (!msg_data_left(msg)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			if (unlikely(flags &amp; MSG_EOR))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				TCP_SKB_CB(skb)-&gt;eor = 1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			goto out;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 		if (skb-&gt;len &lt; max || (flags &amp; MSG_OOB) || unlikely(tp-&gt;repair))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			continue;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 		if (forced_push(tp)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			tcp_mark_push(tp, skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		} else if (skb == tcp_send_head(sk))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			tcp_push_one(sk, mss_now);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		continue;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>tcp_sendmsg 的实现还是很复杂的，这里面做了这样几件事情。</p>
<p>msg 是用户要写入的数据，这个数据要拷贝到内核协议栈里面去发送；在内核协议栈里面，网络包的数据都是由 struct sk_buff 维护的，因而第一件事情就是找到一个空闲的内存空间，将用户要写入的数据，拷贝到 struct sk_buff 的管辖范围内。而第二件事情就是发送 struct sk_buff。</p>
<p>在 tcp_sendmsg 中，我们首先通过强制类型转换，将 sock 结构转换为 struct tcp_sock，这个是维护 TCP 连接状态的重要数据结构。</p>
<p>接下来是 tcp_sendmsg 的第一件事情，把数据拷贝到 struct sk_buff。</p>
<p>我们先声明一个变量 copied，初始化为 0，这表示拷贝了多少数据。紧接着是一个循环，while (msg_data_left(msg))，也即如果用户的数据没有发送完毕，就一直循环。循环里声明了一个 copy 变量，表示这次拷贝的数值，在循环的最后有 copied += copy，将每次拷贝的数量都加起来。</p>
<p>我们这里只需要看一次循环做了哪些事情。</p>
<p><strong>第一步</strong>，tcp_write_queue_tail 从 TCP 写入队列 sk_write_queue 中拿出最后一个 struct sk_buff，在这个写入队列中排满了要发送的 struct sk_buff，为什么要拿最后一个呢？这里面只有最后一个，可能会因为上次用户给的数据太少，而没有填满。</p>
<p><strong>第二步</strong>，tcp_send_mss 会计算 MSS，也即 Max Segment Size。这是什么呢？这个意思是说，我们在网络上传输的网络包的大小是有限制的，而这个限制在最底层开始就有。</p>
<p><strong>MTU</strong>（Maximum Transmission Unit，最大传输单元）是二层的一个定义。以以太网为例，MTU 为 1500 个 Byte，前面有 6 个 Byte 的目标 MAC 地址，6 个 Byte 的源 MAC 地址，2 个 Byte 的类型，后面有 4 个 Byte 的 CRC 校验，共 1518 个 Byte。</p>
<p>在 IP 层，一个 IP 数据报在以太网中传输，如果它的长度大于该 MTU 值，就要进行分片传输。</p>
<p>在 TCP 层有个<strong>MSS</strong>（Maximum Segment Size，最大分段大小），等于 MTU 减去 IP 头，再减去 TCP 头。也就是，在不分片的情况下，TCP 里面放的最大内容。</p>
<p>在这里，max 是 struct sk_buff 的最大数据长度，skb-&gt;len 是当前已经占用的 skb 的数据长度，相减得到当前 skb 的剩余数据空间。</p>
<p><strong>第三步</strong>，如果 copy 小于 0，说明最后一个 struct sk_buff 已经没地方存放了，需要调用 sk_stream_alloc_skb，重新分配 struct sk_buff，然后调用 skb_entail，将新分配的 sk_buff 放到队列尾部。</p>
<p>struct sk_buff 是存储网络包的重要的数据结构，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。在 struct sk_buff，首先是一个链表，将 struct sk_buff 结构串起来。</p>
<p>接下来，我们从 headers_start 开始，到 headers_end 结束，里面都是各层次的头的位置。这里面有二层的 mac_header、三层的 network_header 和四层的 transport_header。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct sk_buff {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	union {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		struct {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			/* These two members must be first. */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			struct sk_buff		*next;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			struct sk_buff		*prev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		struct rb_node	rbnode; /* used in netem &amp; tcp stack */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	/* private: */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	__u32			headers_start[0];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	/* public: */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	__u32			priority;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int			skb_iif;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	__u32			hash;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	__be16			vlan_proto;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	__u16			vlan_tci;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	union {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		__u32		mark;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		__u32		reserved_tailroom;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	union {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		__be16		inner_protocol;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		__u8		inner_ipproto;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	__u16			inner_transport_header;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	__u16			inner_network_header;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	__u16			inner_mac_header;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	__be16			protocol;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	__u16			transport_header;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	__u16			network_header;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	__u16			mac_header;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	/* private: */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	__u32			headers_end[0];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	/* public: */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	/* These elements must be at the end, see alloc_skb() for details.  */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	sk_buff_data_t		tail;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	sk_buff_data_t		end;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	unsigned char		*head,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				*data;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	unsigned int		truesize;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	refcount_t		users;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后几项，head 指向分配的内存块起始地址。data 这个指针指向的位置是可变的。它有可能随着报文所处的层次而变动。当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。而要发送报文时，各协议会创建 sk_buff{}，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。tail 指向数据的结尾，end 指向分配的内存块的结束地址。</p>
<p>要分配这样一个结构，sk_stream_alloc_skb 会最终调用到 __alloc_skb。在这个函数里面，除了分配一个 sk_buff 结构之外，还要分配 sk_buff 指向的数据区域。这段数据区域分为下面这几个部分。</p>
<p>第一部分是连续的数据区域。紧接着是第二部分，一个 struct skb_shared_info 结构。这个结构是对于网络包发送过程的一个优化，因为传输层之上就是应用层了。按照 TCP 的定义，应用层感受不到下面的网络层的 IP 包是一个个独立的包的存在的。反正就是一个流，往里写就是了，可能一下子写多了，超过了一个 IP 包的承载能力，就会出现上面 MSS 的定义，拆分成一个个的 Segment 放在一个个的 IP 包里面，也可能一次写一点，一次写一点，这样数据是分散的，在 IP 层还要通过内存拷贝合成一个 IP 包。</p>
<p>为了减少内存拷贝的代价，有的网络设备支持<strong>分散聚合</strong>（Scatter/Gather）I/O，顾名思义，就是 IP 层没必要通过内存拷贝进行聚合，让散的数据零散的放在原处，在设备层进行聚合。如果使用这种模式，网络包的数据就不会放在连续的数据区域，而是放在 struct skb_shared_info 结构里面指向的离散数据，skb_shared_info 的成员变量 skb_frag_t frags[MAX_SKB_FRAGS]，会指向一个数组的页面，就不能保证连续了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5db9b225d6b8eea00966be2f6a919601.png" alt=""></p>
<p>于是我们就有了<strong>第四步</strong>。在注释 /* Where to copy to? */ 后面有个 if-else 分支。if 分支就是 skb_add_data_nocache 将数据拷贝到连续的数据区域。else 分支就是 skb_copy_to_page_nocache 将数据拷贝到 struct skb_shared_info 结构指向的不需要连续的页面区域。</p>
<p><strong>第五步</strong>，就是要发生网络包了。第一种情况是积累的数据报数目太多了，因而我们需要通过调用 __tcp_push_pending_frames 发送网络包。第二种情况是，这是第一个网络包，需要马上发送，调用 tcp_push_one。无论 __tcp_push_pending_frames 还是 tcp_push_one，都会调用 tcp_write_xmit 发送网络包。</p>
<p>至此，tcp_sendmsg 解析完了。</p>
<h2 id="解析-tcp_write_xmit-函数">解析 tcp_write_xmit 函数</h2>
<p>接下来我们来看，tcp_write_xmit 是如何发送网络包的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static bool tcp_write_xmit(struct sock *sk, unsigned int mss_now, int nonagle, int push_one, gfp_t gfp)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct tcp_sock *tp = tcp_sk(sk);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct sk_buff *skb;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	unsigned int tso_segs, sent_pkts;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int cwnd_quota;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	max_segs = tcp_tso_segs(sk, mss_now);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	while ((skb = tcp_send_head(sk))) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		unsigned int limit;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		tso_segs = tcp_init_tso_segs(skb, mss_now);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		cwnd_quota = tcp_cwnd_test(tp, skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (unlikely(!tcp_snd_wnd_test(tp, skb, mss_now))) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			is_rwnd_limited = true;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			break;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		limit = mss_now;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (tso_segs &gt; 1 &amp;&amp; !tcp_urg_mode(tp))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            limit = tcp_mss_split_point(sk, skb, mss_now, min_t(unsigned int, cwnd_quota, max_segs), nonagle);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 		if (skb-&gt;len &gt; limit &amp;&amp;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		    unlikely(tso_fragment(sk, skb, limit, mss_now, gfp)))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			break;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (unlikely(tcp_transmit_skb(sk, skb, 1, gfp)))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			break;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> repair:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		/* Advance the send_head.  This one is sent out.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		 * This call will increment packets_out.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		 */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		tcp_event_new_data_sent(sk, skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 		tcp_minshall_update(tp, mss_now, skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		sent_pkts += tcp_skb_pcount(skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 		if (push_one)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			break;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里面主要的逻辑是一个循环，用来处理发送队列，只要队列不空，就会发送。</p>
<p>在一个循环中，涉及 TCP 层的很多传输算法，我们来一一解析。</p>
<p>第一个概念是<strong>TSO</strong>（TCP Segmentation Offload）。如果发送的网络包非常大，就像上面说的一样，要进行分段。分段这个事情可以由协议栈代码在内核做，但是缺点是比较费 CPU，另一种方式是延迟到硬件网卡去做，需要网卡支持对大数据包进行自动分段，可以降低 CPU 负载。</p>
<p>在代码中，tcp_init_tso_segs 会调用 tcp_set_skb_tso_segs。这里面有这样的语句：DIV_ROUND_UP(skb-&gt;len, mss_now)。也就是 sk_buff 的长度除以 mss_now，应该分成几个段。如果算出来要分成多个段，接下来就是要看，是在这里（协议栈的代码里面）分好，还是等待到了底层网卡再分。</p>
<p>于是，调用函数 tcp_mss_split_point，开始计算切分的 limit。这里面会计算 max_len = mss_now * max_segs，根据现在不切分来计算 limit，所以下一步的判断中，大部分情况下 tso_fragment 不会被调用，等待到了底层网卡来切分。</p>
<p>第二个概念是<strong>拥塞窗口</strong>的概念（cwnd，congestion window），也就是说为了避免拼命发包，把网络塞满了，定义一个窗口的概念，在这个窗口之内的才能发送，超过这个窗口的就不能发送，来控制发送的频率。</p>
<p>那窗口大小是多少呢？就是遵循下面这个著名的拥塞窗口变化图。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6056eaf2d0ba46891c429c1513836fdd.png" alt=""></p>
<p>一开始的窗口只有一个 mss 大小叫作 slow start（慢启动）。一开始的增长速度的很快的，翻倍增长。一旦到达一个临界值 ssthresh，就变成线性增长，我们就称为<strong>拥塞避免</strong>。什么时候算真正拥塞呢？就是出现了丢包。一旦丢包，一种方法是马上降回到一个 mss，然后重复先翻倍再线性对的过程。如果觉得太过激进，也可以有第二种方法，就是降到当前 cwnd 的一半，然后进行线性增长。</p>
<p>在代码中，tcp_cwnd_test 会将当前的 snd_cwnd，减去已经在窗口里面尚未发送完毕的网络包，那就是剩下的窗口大小 cwnd_quota，也即就能发送这么多了。</p>
<p>第三个概念就是<strong>接收窗口</strong>rwnd 的概念（receive window），也叫滑动窗口。如果说拥塞窗口是为了怕把网络塞满，在出现丢包的时候减少发送速度，那么滑动窗口就是为了怕把接收方塞满，而控制发送速度。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/300a0bc916040023fe556d856e63d053.png" alt=""></p>
<p>滑动窗口，其实就是接收方告诉发送方自己的网络包的接收能力，超过这个能力，我就受不了了。因为滑动窗口的存在，将发送方的缓存分成了四个部分。</p>
<ul>
<li>第一部分：发送了并且已经确认的。这部分是已经发送完毕的网络包，这部分没有用了，可以回收。</li>
<li>第二部分：发送了但尚未确认的。这部分，发送方要等待，万一发送不成功，还要重新发送，所以不能删除。</li>
<li>第三部分：没有发送，但是已经等待发送的。这部分是接收方空闲的能力，可以马上发送，接收方收得了。</li>
<li>第四部分：没有发送，并且暂时还不会发送的。这部分已经超过了接收方的接收能力，再发送接收方就收不了了。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1b5393cd950a587649dd3e038bdd99b6.png" alt=""></p>
<p>因为滑动窗口的存在，接收方的缓存也要分成了三个部分。</p>
<ul>
<li>第一部分：接受并且确认过的任务。这部分完全接收成功了，可以交给应用层了。</li>
<li>第二部分：还没接收，但是马上就能接收的任务。这部分有的网络包到达了，但是还没确认，不算完全完毕，有的还没有到达，那就是接收方能够接受的最大的网络包数量。</li>
<li>第三部分：还没接收，也没法接收的任务。这部分已经超出接收方能力。</li>
</ul>
<p>在网络包的交互过程中，接收方会将第二部分的大小，作为 AdvertisedWindow 发送给发送方，发送方就可以根据他来调整发送速度了。</p>
<p>在 tcp_snd_wnd_test 函数中，会判断 sk_buff 中的 end_seq 和 tcp_wnd_end(tp) 之间的关系，也即这个 sk_buff 是否在滑动窗口的允许范围之内。如果不在范围内，说明发送要受限制了，我们就要把 is_rwnd_limited 设置为 true。</p>
<p>接下来，tcp_mss_split_point 函数要被调用了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">unsigned</span> <span class="ne">int</span> <span class="n">tcp_mss_split_point</span><span class="p">(</span><span class="k">const</span> <span class="n">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                        <span class="k">const</span> <span class="n">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                        <span class="n">unsigned</span> <span class="ne">int</span> <span class="n">mss_now</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                        <span class="n">unsigned</span> <span class="ne">int</span> <span class="n">max_segs</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                        <span class="ne">int</span> <span class="n">nonagle</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">u32</span> <span class="n">partial</span><span class="p">,</span> <span class="n">needed</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">max_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         <span class="n">window</span> <span class="o">=</span> <span class="n">tcp_wnd_end</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">-</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">max_len</span> <span class="o">=</span> <span class="n">mss_now</span> <span class="o">*</span> <span class="n">max_segs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">max_len</span> <span class="o">&lt;=</span> <span class="n">window</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span> <span class="o">!=</span> <span class="n">tcp_write_queue_tail</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">max_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         <span class="n">needed</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="n">max_len</span> <span class="o">&lt;=</span> <span class="n">needed</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">max_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">needed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里面除了会判断上面讲的，是否会因为超出 mss 而分段，还会判断另一个条件，就是是否在滑动窗口的运行范围之内，如果小于窗口的大小，也需要分段，也即需要调用 tso_fragment。</p>
<p>在一个循环的最后，是调用 tcp_transmit_skb，真的去发送一个网络包。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="ne">int</span> <span class="n">tcp_transmit_skb</span><span class="p">(</span><span class="n">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="ne">int</span> <span class="n">clone_it</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">struct</span> <span class="n">inet_sock</span> <span class="o">*</span><span class="n">inet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">struct</span> <span class="n">tcp_skb_cb</span> <span class="o">*</span><span class="n">tcb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">skb_mstamp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_mstamp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">inet</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">tcb</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">opts</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">tcp_header_size</span> <span class="o">=</span> <span class="n">tcp_options_size</span> <span class="o">+</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">tcphdr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tcp_header_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="o">/*</span> <span class="n">Build</span> <span class="n">TCP</span> <span class="n">header</span> <span class="ow">and</span> <span class="n">checksum</span> <span class="n">it</span><span class="o">.</span> <span class="o">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">th</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">th</span><span class="o">-&gt;</span><span class="n">source</span>      <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_sport</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">th</span><span class="o">-&gt;</span><span class="n">dest</span>        <span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_dport</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">th</span><span class="o">-&gt;</span><span class="n">seq</span>         <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">th</span><span class="o">-&gt;</span><span class="n">ack_seq</span>     <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="p">(((</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)</span><span class="n">th</span><span class="p">)</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span>   <span class="o">=</span> <span class="n">htons</span><span class="p">(((</span><span class="n">tcp_header_size</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">|</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="n">tcb</span><span class="o">-&gt;</span><span class="n">tcp_flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">th</span><span class="o">-&gt;</span><span class="n">check</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">th</span><span class="o">-&gt;</span><span class="n">urg_ptr</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">tcp_options_write</span><span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)(</span><span class="n">th</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">th</span><span class="o">-&gt;</span><span class="n">window</span>  <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span><span class="p">,</span> <span class="mi">65535</span><span class="n">U</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">err</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">queue_xmit</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">cork</span><span class="o">.</span><span class="n">fl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>tcp_transmit_skb 这个函数比较长，主要做了两件事情，第一件事情就是填充 TCP 头，如果我们对着 TCP 头的格式。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7f07f2370d9007ce0c43dfb133a44c64.png" alt=""></p>
<p>这里面有源端口，设置为 inet_sport，有目标端口，设置为 inet_dport；有序列号，设置为 tcb-&gt;seq；有确认序列号，设置为 tp-&gt;rcv_nxt。我们把所有的 flags 设置为 tcb-&gt;tcp_flags。设置选项为 opts。设置窗口大小为 tp-&gt;rcv_wnd。</p>
<p>全部设置完毕之后，就会调用 icsk_af_ops 的 queue_xmit 方法，icsk_af_ops 指向 ipv4_specific，也即调用的是 ip_queue_xmit 函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">struct</span> <span class="n">inet_connection_sock_af_ops</span> <span class="n">ipv4_specific</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">queue_xmit</span>        <span class="o">=</span> <span class="n">ip_queue_xmit</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">send_check</span>        <span class="o">=</span> <span class="n">tcp_v4_send_check</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">rebuild_header</span>    <span class="o">=</span> <span class="n">inet_sk_rebuild_header</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">sk_rx_dst_set</span>     <span class="o">=</span> <span class="n">inet_sk_rx_dst_set</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">conn_request</span>      <span class="o">=</span> <span class="n">tcp_v4_conn_request</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">syn_recv_sock</span>     <span class="o">=</span> <span class="n">tcp_v4_syn_recv_sock</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">net_header_len</span>    <span class="o">=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">iphdr</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">setsockopt</span>        <span class="o">=</span> <span class="n">ip_setsockopt</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">getsockopt</span>        <span class="o">=</span> <span class="n">ip_getsockopt</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">addr2sockaddr</span>     <span class="o">=</span> <span class="n">inet_csk_addr2sockaddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">sockaddr_len</span>      <span class="o">=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">sockaddr_in</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">mtu_reduced</span>       <span class="o">=</span> <span class="n">tcp_v4_mtu_reduced</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="总结时刻">总结时刻</h2>
<p>这一节，我们解析了发送一个网络包的一部分过程，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3fbddf86ec293bf44393a7da4626743a.png" alt=""></p>
<p>这个过程分成几个层次。</p>
<ul>
<li>VFS 层：write 系统调用找到 struct file，根据里面的 file_operations 的定义，调用 sock_write_iter 函数。sock_write_iter 函数调用 sock_sendmsg 函数。</li>
<li>Socket 层：从 struct file 里面的 private_data 得到 struct socket，根据里面 ops 的定义，调用 inet_sendmsg 函数。</li>
<li>Sock 层：从 struct socket 里面的 sk 得到 struct sock，根据里面 sk_prot 的定义，调用 tcp_sendmsg 函数。</li>
<li>TCP 层：tcp_sendmsg 函数会调用 tcp_write_xmit 函数，tcp_write_xmit 函数会调用 tcp_transmit_skb，在这里实现了 TCP 层面向连接的逻辑。</li>
<li>IP 层：扩展 struct sock，得到 struct inet_connection_sock，根据里面 icsk_af_ops 的定义，调用 ip_queue_xmit 函数。</li>
</ul>
<h2 id="课堂练习">课堂练习</h2>
<p>如果你对 TCP 协议的结构不太熟悉，可以使用 tcpdump 命令截取一个 TCP 的包，看看里面的结构。</p>
<p>欢迎留言和我分享你的疑惑和见解，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1a5564dd4e1c9f25d4772c7f844ca84a.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">趣谈Linux操作系统</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/45__%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">45__弹力设计篇之“服务的状态”</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/45__%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAdependency_injection%E6%A1%86%E6%9E%B6/">
            <span class="next-text nav-default">45__工厂模式（下）：如何设计实现一个Dependency_Injection框架？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
