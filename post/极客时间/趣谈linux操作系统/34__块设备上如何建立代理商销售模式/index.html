<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>34__块设备（上）：如何建立代理商销售模式？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="上一章，我们解析了文件系统，最后讲文件系统读写的流程到达底层的时候，没有更深入地分析下去，这是因为文件系统再往下就是硬盘设备了。上两节，我们解析了字符设备的 mknod、打开和读写流程。那这一节我们就来讲块设备的 mknod、打开流程，以及文件系统和下层的硬盘设备的读写流程。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/34__%E5%9D%97%E8%AE%BE%E5%A4%87%E4%B8%8A%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%BB%A3%E7%90%86%E5%95%86%E9%94%80%E5%94%AE%E6%A8%A1%E5%BC%8F/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/34__%E5%9D%97%E8%AE%BE%E5%A4%87%E4%B8%8A%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%BB%A3%E7%90%86%E5%95%86%E9%94%80%E5%94%AE%E6%A8%A1%E5%BC%8F/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="34__块设备（上）：如何建立代理商销售模式？">
  <meta property="og:description" content="上一章，我们解析了文件系统，最后讲文件系统读写的流程到达底层的时候，没有更深入地分析下去，这是因为文件系统再往下就是硬盘设备了。上两节，我们解析了字符设备的 mknod、打开和读写流程。那这一节我们就来讲块设备的 mknod、打开流程，以及文件系统和下层的硬盘设备的读写流程。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="趣谈Linux操作系统">

  <meta itemprop="name" content="34__块设备（上）：如何建立代理商销售模式？">
  <meta itemprop="description" content="上一章，我们解析了文件系统，最后讲文件系统读写的流程到达底层的时候，没有更深入地分析下去，这是因为文件系统再往下就是硬盘设备了。上两节，我们解析了字符设备的 mknod、打开和读写流程。那这一节我们就来讲块设备的 mknod、打开流程，以及文件系统和下层的硬盘设备的读写流程。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6664">
  <meta itemprop="keywords" content="趣谈Linux操作系统">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="34__块设备（上）：如何建立代理商销售模式？">
  <meta name="twitter:description" content="上一章，我们解析了文件系统，最后讲文件系统读写的流程到达底层的时候，没有更深入地分析下去，这是因为文件系统再往下就是硬盘设备了。上两节，我们解析了字符设备的 mknod、打开和读写流程。那这一节我们就来讲块设备的 mknod、打开流程，以及文件系统和下层的硬盘设备的读写流程。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">34__块设备（上）：如何建立代理商销售模式？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6664 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#总结时刻">总结时刻</a></li>
        <li><a href="#课堂练习">课堂练习</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>上一章，我们解析了文件系统，最后讲文件系统读写的流程到达底层的时候，没有更深入地分析下去，这是因为文件系统再往下就是硬盘设备了。上两节，我们解析了字符设备的 mknod、打开和读写流程。那这一节我们就来讲块设备的 mknod、打开流程，以及文件系统和下层的硬盘设备的读写流程。</p>
<p>块设备一般会被格式化为文件系统，但是，下面的讲述中，你可能会有一点困惑。你会看到各种各样的 dentry 和 inode。块设备涉及三种文件系统，所以你看到的这些 dentry 和 inode 可能都不是一回事儿，请注意分辨。</p>
<p>块设备需要 mknod 吗？对于启动盘，你可能觉得，启动了就在那里了。可是如果我们要插进一块新的 USB 盘，还是要有这个操作的。</p>
<p>mknod 还是会创建在 /dev 路径下面，这一点和字符设备一样。/dev 路径下面是 devtmpfs 文件系统。<strong>这是块设备遇到的第一个文件系统</strong>。我们会为这个块设备文件，分配一个特殊的 inode，这一点和字符设备也是一样的。只不过字符设备走 S_ISCHR 这个分支，对应 inode 的 file_operations 是 def_chr_fops；而块设备走 S_ISBLK 这个分支，对应的 inode 的 file_operations 是 def_blk_fops。这里要注意，inode 里面的 i_rdev 被设置成了块设备的设备号 dev_t，这个我们后面会用到，你先记住有这么一回事儿。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	inode-&gt;i_mode = mode;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (S_ISCHR(mode)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		inode-&gt;i_fop = &amp;def_chr_fops;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		inode-&gt;i_rdev = rdev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	} else if (S_ISBLK(mode)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		inode-&gt;i_fop = &amp;def_blk_fops;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		inode-&gt;i_rdev = rdev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	} else if (S_ISFIFO(mode))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		inode-&gt;i_fop = &amp;pipefifo_fops;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	else if (S_ISSOCK(mode))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		;	/* leave it no_open_fops */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>特殊 inode 的默认 file_operations 是 def_blk_fops，就像字符设备一样，有打开、读写这个块设备文件，但是我们常规操作不会这样做。我们会将这个块设备文件 mount 到一个文件夹下面。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">struct</span> <span class="n">file_operations</span> <span class="n">def_blk_fops</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">blkdev_open</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">blkdev_close</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">block_llseek</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">read_iter</span>      <span class="o">=</span> <span class="n">blkdev_read_iter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">write_iter</span>     <span class="o">=</span> <span class="n">blkdev_write_iter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">mmap</span>           <span class="o">=</span> <span class="n">generic_file_mmap</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">fsync</span>          <span class="o">=</span> <span class="n">blkdev_fsync</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">block_ioctl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">splice_read</span>    <span class="o">=</span> <span class="n">generic_file_splice_read</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">splice_write</span>   <span class="o">=</span> <span class="n">iter_file_splice_write</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">fallocate</span>      <span class="o">=</span> <span class="n">blkdev_fallocate</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过，这里我们还是简单看一下，打开这个块设备的操作 blkdev_open。它里面调用的是 blkdev_get 打开这个块设备，了解到这一点就可以了。</p>
<p>接下来，我们要调用 mount，将这个块设备文件挂载到一个文件夹下面。如果这个块设备原来被格式化为一种文件系统的格式，例如 ext4，那我们调用的就是 ext4 相应的 mount 操作。<strong>这是块设备遇到的第二个文件系统</strong>，也是向这个块设备读写文件，需要基于的主流文件系统。咱们在文件系统那一节解析的对于文件的读写流程，都是基于这个文件系统的。</p>
<p>还记得，咱们注册 ext4 文件系统的时候，有下面这样的结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static struct file_system_type ext4_fs_type = {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	.owner		= THIS_MODULE,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	.name		= &#34;ext4&#34;,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	.mount		= ext4_mount,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	.kill_sb	= kill_block_super,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	.fs_flags	= FS_REQUIRES_DEV,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>在将一个硬盘的块设备 mount 成为 ext4 的时候，我们会调用 ext4_mount-&gt;mount_bdev。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ext4_mount</span><span class="p">(</span><span class="n">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span> <span class="ne">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">mount_bdev</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ext4_fill_super</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">mount_bdev</span><span class="p">(</span><span class="n">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="ne">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="ne">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill_super</span><span class="p">)(</span><span class="n">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="p">,</span> <span class="ne">int</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">fmode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">FMODE_READ</span> <span class="o">|</span> <span class="n">FMODE_EXCL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="ne">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">mode</span> <span class="o">|=</span> <span class="n">FMODE_WRITE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	<span class="n">bdev</span> <span class="o">=</span> <span class="n">blkdev_get_by_path</span><span class="p">(</span><span class="n">dev_name</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">fs_type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">s</span> <span class="o">=</span> <span class="n">sget</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">test_bdev_super</span><span class="p">,</span> <span class="n">set_bdev_super</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">MS_NOSEC</span><span class="p">,</span> <span class="n">bdev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">dget</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>mount_bdev 主要做了两件大事情。第一，blkdev_get_by_path 根据 /dev/xxx 这个名字，找到相应的设备并打开它；第二，sget 根据打开的设备文件，填充 ext4 文件系统的 super_block，从而以此为基础，建立一整套咱们在文件系统那一章讲的体系。</p>
<p>一旦这套体系建立起来以后，对于文件的读写都是通过 ext4 文件系统这个体系进行的，创建的 inode 结构也是指向 ext4 文件系统的。文件系统那一章我们只解析了这部分，由于没有到达底层，也就没有关注块设备相关的操作。这一章我们重新回过头来，一方面看 mount 的时候，对于块设备都做了哪些操作，另一方面看读写的时候，到了底层，对于块设备做了哪些操作。</p>
<p>这里我们先来看 mount_bdev 做的第一件大事情，通过 blkdev_get_by_path，根据设备名 /dev/xxx，得到 struct block_device *bdev。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">/**</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="n">blkdev_get_by_path</span> <span class="o">-</span> <span class="n">open</span> <span class="n">a</span> <span class="n">block</span> <span class="n">device</span> <span class="n">by</span> <span class="n">name</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="err">@</span><span class="n">path</span><span class="p">:</span> <span class="n">path</span> <span class="n">to</span> <span class="n">the</span> <span class="n">block</span> <span class="n">device</span> <span class="n">to</span> <span class="n">open</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="err">@</span><span class="n">mode</span><span class="p">:</span> <span class="n">FMODE_</span><span class="o">*</span> <span class="n">mask</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="err">@</span><span class="n">holder</span><span class="p">:</span> <span class="n">exclusive</span> <span class="n">holder</span> <span class="n">identifier</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="n">Open</span> <span class="n">the</span> <span class="n">blockdevice</span> <span class="n">described</span> <span class="n">by</span> <span class="n">the</span> <span class="n">device</span> <span class="n">file</span> <span class="n">at</span> <span class="err">@</span><span class="n">path</span><span class="o">.</span>  <span class="err">@</span><span class="n">mode</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="ow">and</span> <span class="err">@</span><span class="n">holder</span> <span class="n">are</span> <span class="n">identical</span> <span class="n">to</span> <span class="n">blkdev_get</span><span class="p">()</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="n">On</span> <span class="n">success</span><span class="p">,</span> <span class="n">the</span> <span class="n">returned</span> <span class="n">block_device</span> <span class="n">has</span> <span class="n">reference</span> <span class="n">count</span> <span class="n">of</span> <span class="n">one</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">blkdev_get_by_path</span><span class="p">(</span><span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">					<span class="n">void</span> <span class="o">*</span><span class="n">holder</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="ne">int</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	<span class="n">bdev</span> <span class="o">=</span> <span class="n">lookup_bdev</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">err</span> <span class="o">=</span> <span class="n">blkdev_get</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">holder</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">bdev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>blkdev_get_by_path 干了两件事情。第一个，lookup_bdev 根据设备路径 /dev/xxx 得到 block_device。第二个，打开这个设备，调用 blkdev_get。</p>
<p>咱们上面分析过 def_blk_fops 的默认打开设备函数 blkdev_open，它也是调用 blkdev_get 的。块设备的打开往往不是直接调用设备文件的打开函数，而是调用 mount 来打开的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">/**</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="n">lookup_bdev</span>  <span class="o">-</span> <span class="n">lookup</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">block_device</span> <span class="n">by</span> <span class="n">name</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="err">@</span><span class="n">pathname</span><span class="p">:</span>	<span class="n">special</span> <span class="n">file</span> <span class="n">representing</span> <span class="n">the</span> <span class="n">block</span> <span class="n">device</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="n">Get</span> <span class="n">a</span> <span class="n">reference</span> <span class="n">to</span> <span class="n">the</span> <span class="n">blockdevice</span> <span class="n">at</span> <span class="err">@</span><span class="n">pathname</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">current</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="n">namespace</span> <span class="k">if</span> <span class="n">possible</span> <span class="ow">and</span> <span class="k">return</span> <span class="n">it</span><span class="o">.</span>  <span class="n">Return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="n">otherwise</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">lookup_bdev</span><span class="p">(</span><span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="ne">int</span> <span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pathname</span> <span class="o">||</span> <span class="o">!*</span><span class="n">pathname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	<span class="n">error</span> <span class="o">=</span> <span class="n">kern_path</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="n">LOOKUP_FOLLOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	<span class="n">inode</span> <span class="o">=</span> <span class="n">d_backing_inode</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">bdev</span> <span class="o">=</span> <span class="n">bd_acquire</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>lookup_bdev 这里的 pathname 是设备的文件名，例如 /dev/xxx。这个文件是在 devtmpfs 文件系统中的，kern_path 可以在这个文件系统里面，一直找到它对应的 dentry。接下来，d_backing_inode 会获得 inode。这个 inode 就是那个 init_special_inode 生成的特殊 inode。</p>
<p>接下来，bd_acquire 通过这个特殊的 inode，找到 struct block_device。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static struct block_device *bd_acquire(struct inode *inode)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct block_device *bdev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	bdev = bdget(inode-&gt;i_rdev);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (bdev) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		spin_lock(&amp;bdev_lock);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (!inode-&gt;i_bdev) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			/*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			 * We take an additional reference to bd_inode,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			 * and it&#39;s released in clear_inode() of inode.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			 * So, we can access it via -&gt;i_mapping always
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			 * without igrab().
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			 */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			bdgrab(bdev);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			inode-&gt;i_bdev = bdev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			inode-&gt;i_mapping = bdev-&gt;bd_inode-&gt;i_mapping;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return bdev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>bd_acquire 中最主要的就是调用 bdget，它的参数是特殊 inode 的 i_rdev。这里面在 mknod 的时候，放的是设备号 dev_t。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct block_device *bdget(dev_t dev)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        struct block_device *bdev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        struct inode *inode;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          inode = iget5_locked(blockdev_superblock, hash(dev),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        bdev_test, bdev_set, &amp;dev);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         bdev = &amp;BDEV_I(inode)-&gt;bdev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          if (inode-&gt;i_state &amp; I_NEW) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                bdev-&gt;bd_contains = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                bdev-&gt;bd_super = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                bdev-&gt;bd_inode = inode;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                bdev-&gt;bd_block_size = i_blocksize(inode);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                bdev-&gt;bd_part_count = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                bdev-&gt;bd_invalidated = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                inode-&gt;i_mode = S_IFBLK;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                inode-&gt;i_rdev = dev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                inode-&gt;i_bdev = bdev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                inode-&gt;i_data.a_ops = &amp;def_blk_aops;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                mapping_set_gfp_mask(&amp;inode-&gt;i_data, GFP_USER);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                spin_lock(&amp;bdev_lock);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                list_add(&amp;bdev-&gt;bd_list, &amp;all_bdevs);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                spin_unlock(&amp;bdev_lock);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                unlock_new_inode(inode);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        return bdev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>在 bdget 中，我们遇到了第三个文件系统，bdev 伪文件系统</strong>。bdget 函数根据传进来的 dev_t，在 blockdev_superblock 这个文件系统里面找到 inode。这里注意，这个 inode 已经不是 devtmpfs 文件系统的 inode 了。blockdev_superblock 的初始化在整个系统初始化的时候，会调用 bdev_cache_init 进行初始化。它的定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct super_block *blockdev_superblock __read_mostly;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  static struct file_system_type bd_type = {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        .name           = &#34;bdev&#34;,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        .mount          = bd_mount,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        .kill_sb        = kill_anon_super,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  void __init bdev_cache_init(void)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        int err;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        static struct vfsmount *bd_mnt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          bdev_cachep = kmem_cache_create(&#34;bdev_cache&#34;, sizeof(struct bdev_inode), 0, (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD|SLAB_ACCOUNT|SLAB_PANIC), init_once);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        err = register_filesystem(&amp;bd_type);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (err)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                panic(&#34;Cannot register bdev pseudo-fs&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        bd_mnt = kern_mount(&amp;bd_type);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (IS_ERR(bd_mnt))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                panic(&#34;Cannot create bdev pseudo-fs&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        blockdev_superblock = bd_mnt-&gt;mnt_sb;   /* For writeback */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>所有表示块设备的 inode 都保存在伪文件系统 bdev 中，这些对用户层不可见，主要为了方便块设备的管理。Linux 将块设备的 block_device 和 bdev 文件系统的块设备的 inode，通过 struct bdev_inode 进行关联。所以，在 bdget 中，BDEV_I 就是通过 bdev 文件系统的 inode，获得整个 struct bdev_inode 结构的地址，然后取成员 bdev，得到 block_device。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct bdev_inode {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct block_device bdev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct inode vfs_inode;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>绕了一大圈，我们终于通过设备文件 /dev/xxx，获得了设备的结构 block_device。有点儿绕，我们再捋一下。设备文件 /dev/xxx 在 devtmpfs 文件系统中，找到 devtmpfs 文件系统中的 inode，里面有 dev_t。我们可以通过 dev_t，在伪文件系统 bdev 中找到对应的 inode，然后根据 struct bdev_inode 找到关联的 block_device。</p>
<p>接下来，blkdev_get_by_path 开始做第二件事情，在找到 block_device 之后，要调用 blkdev_get 打开这个设备。blkdev_get 会调用 __blkdev_get。</p>
<p>在分析打开一个设备之前，我们先来看 block_device 这个结构是什么样的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct block_device {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	dev_t			bd_dev;  /* not a kdev_t - it&#39;s a search key */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int			bd_openers;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct super_block *	bd_super;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct block_device *	bd_contains;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	unsigned		bd_block_size;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct hd_struct *	bd_part;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	unsigned		bd_part_count;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int			bd_invalidated;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct gendisk *	bd_disk;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct request_queue *  bd_queue;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct backing_dev_info *bd_bdi;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct list_head	bd_list;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} ;
</span></span></code></pre></td></tr></table>
</div>
</div><p>你应该能发现，这个结构和其他几个结构有着千丝万缕的联系，比较复杂。这是因为块设备本身就比较复杂。</p>
<p>比方说，我们有一个磁盘 /dev/sda，我们既可以把它整个格式化成一个文件系统，也可以把它分成多个分区 /dev/sda1、 /dev/sda2，然后把每个分区格式化成不同的文件系统。如果我们访问某个分区的设备文件 /dev/sda2，我们应该能知道它是哪个磁盘设备的。按说它们的驱动应该是一样的。如果我们访问整个磁盘的设备文件 /dev/sda，我们也应该能知道它分了几个区域，所以就有了下图这个复杂的关系结构。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f2e4c8bf29f5fa6eb58c8c69d4a90ad6.png" alt=""></p>
<p>struct gendisk 是用来描述整个设备的，因而上面的例子中，gendisk 只有一个实例，指向 /dev/sda。它的定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">gendisk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="ne">int</span> <span class="n">major</span><span class="p">;</span>			<span class="o">/*</span> <span class="n">major</span> <span class="n">number</span> <span class="n">of</span> <span class="n">driver</span> <span class="o">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="ne">int</span> <span class="n">first_minor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="ne">int</span> <span class="n">minors</span><span class="p">;</span>                     <span class="o">/*</span> <span class="n">maximum</span> <span class="n">number</span> <span class="n">of</span> <span class="n">minors</span><span class="p">,</span> <span class="o">=</span><span class="mi">1</span> <span class="k">for</span> <span class="n">disks</span> <span class="n">that</span> <span class="n">can</span><span class="s1">&#39;t be partitioned. */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">char</span> <span class="n">disk_name</span><span class="p">[</span><span class="n">DISK_NAME_LEN</span><span class="p">];</span>	<span class="o">/*</span> <span class="n">name</span> <span class="n">of</span> <span class="n">major</span> <span class="n">driver</span> <span class="o">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">devnode</span><span class="p">)(</span><span class="n">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">,</span> <span class="n">umode_t</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">disk_part_tbl</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">part_tbl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">hd_struct</span> <span class="n">part0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	<span class="k">const</span> <span class="n">struct</span> <span class="n">block_device_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">void</span> <span class="o">*</span><span class="n">private_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	<span class="ne">int</span> <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">slave_dir</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里 major 是主设备号，first_minor 表示第一个分区的从设备号，minors 表示分区的数目。</p>
<p>disk_name 给出了磁盘块设备的名称。</p>
<p>struct disk_part_tbl 结构里是一个 struct hd_struct 的数组，用于表示各个分区。struct block_device_operations fops 指向对于这个块设备的各种操作。struct request_queue queue 是表示在这个块设备上的请求队列。</p>
<p>struct hd_struct 是用来表示某个分区的，在上面的例子中，有两个 hd_struct 的实例，分别指向 /dev/sda1、 /dev/sda2。它的定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct hd_struct {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	sector_t start_sect;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	sector_t nr_sects;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct device __dev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct kobject *holder_dir;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int policy, partno;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct partition_meta_info *info;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct disk_stats dkstats;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct percpu_ref ref;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct rcu_head rcu_head;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 hd_struct 中，比较重要的成员变量保存了如下的信息：从磁盘的哪个扇区开始，到哪个扇区结束。</p>
<p>而 block_device 既可以表示整个块设备，也可以表示某个分区，所以对于上面的例子，block_device 有三个实例，分别指向 /dev/sda1、/dev/sda2、/dev/sda。</p>
<p>block_device 的成员变量 bd_disk，指向的 gendisk 就是整个块设备。这三个实例都指向同一个 gendisk。bd_part 指向的某个分区的 hd_struct，bd_contains 指向的是整个块设备的 block_device。</p>
<p>了解了这些复杂的关系，我们再来看打开设备文件的代码，就会清晰很多。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static int __blkdev_get(struct block_device *bdev, fmode_t mode, int for_part)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct gendisk *disk;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct module *owner;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int ret;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int partno;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int perm = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	if (mode &amp; FMODE_READ)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		perm |= MAY_READ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (mode &amp; FMODE_WRITE)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		perm |= MAY_WRITE;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	disk = get_gendisk(bdev-&gt;bd_dev, &amp;partno);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	owner = disk-&gt;fops-&gt;owner;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (!bdev-&gt;bd_openers) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		bdev-&gt;bd_disk = disk;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		bdev-&gt;bd_queue = disk-&gt;queue;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		bdev-&gt;bd_contains = bdev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  		if (!partno) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			ret = -ENXIO;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			bdev-&gt;bd_part = disk_get_part(disk, partno);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			if (disk-&gt;fops-&gt;open) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				ret = disk-&gt;fops-&gt;open(bdev, mode);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  			if (!ret)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				bd_set_size(bdev,(loff_t)get_capacity(disk)&lt;&lt;9);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  			if (bdev-&gt;bd_invalidated) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				if (!ret)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">					rescan_partitions(disk, bdev);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		} else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			struct block_device *whole;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			whole = bdget_disk(disk, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			ret = __blkdev_get(whole, mode, 1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			bdev-&gt;bd_contains = whole;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			bdev-&gt;bd_part = disk_get_part(disk, partno);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			bd_set_size(bdev, (loff_t)bdev-&gt;bd_part-&gt;nr_sects &lt;&lt; 9);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	} 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	bdev-&gt;bd_openers++;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (for_part)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		bdev-&gt;bd_part_count++;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">.....
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 __blkdev_get 函数中，我们先调用 get_gendisk，根据 block_device 获取 gendisk。具体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * get_gendisk - get partitioning information for a given device
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * @devt: device to get partitioning information for
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * @partno: returned partition index
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> *
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * This function gets the structure containing partitioning
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * information for the given device @devt.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct gendisk *get_gendisk(dev_t devt, int *partno)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct gendisk *disk = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	if (MAJOR(devt) != BLOCK_EXT_MAJOR) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		struct kobject *kobj;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  		kobj = kobj_lookup(bdev_map, devt, partno);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (kobj)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			disk = dev_to_disk(kobj_to_dev(kobj));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	} else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		struct hd_struct *part;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		part = idr_find(&amp;ext_devt_idr, blk_mangle_minor(MINOR(devt)));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (part &amp;&amp; get_disk(part_to_disk(part))) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			*partno = part-&gt;partno;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			disk = part_to_disk(part);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return disk;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以想象这里面有两种情况。第一种情况是，block_device 是指向整个磁盘设备的。这个时候，我们只需要根据 dev_t，在 bdev_map 中将对应的 gendisk 拿出来就好。</p>
<p>bdev_map 是干什么的呢？前面咱们学习字符设备驱动的时候讲过，任何一个字符设备初始化的时候，都需要调用 __register_chrdev_region，注册这个字符设备。对于块设备也是类似的，每一个块设备驱动初始化的时候，都会调用 add_disk 注册一个 gendisk。</p>
<p>这里需要说明一下，gen 的意思是 general 通用的意思，也就是说，所有的块设备，不仅仅是硬盘 disk，都会用一个 gendisk 来表示，然后通过调用链 add_disk-&gt;device_add_disk-&gt;blk_register_region，将 dev_t 和一个 gendisk 关联起来，保存在 bdev_map 中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static struct kobj_map *bdev_map;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  static inline void add_disk(struct gendisk *disk)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	device_add_disk(NULL, disk);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  /**
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * device_add_disk - add partitioning information to kernel list
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * @parent: parent device for the disk
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * @disk: per-device partitioning information
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> *
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * This function registers the partitioning information in @disk
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * with the kernel.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void device_add_disk(struct device *parent, struct gendisk *disk)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">blk_register_region(disk_devt(disk), disk-&gt;minors, NULL,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			    exact_match, exact_lock, disk);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">.....
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  /*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * Register device numbers dev..(dev+range-1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * range must be nonzero
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> * The hash chain is sorted on range, so that subranges can override.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void blk_register_region(dev_t devt, unsigned long range, struct module *module,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			 struct kobject *(*probe)(dev_t, int *, void *),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			 int (*lock)(dev_t, void *), void *data)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	kobj_map(bdev_map, devt, range, module, probe, lock, data);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>get_gendisk 要处理的第二种情况是，block_device 是指向某个分区的。这个时候我们要先得到 hd_struct，然后通过 hd_struct，找到对应的整个设备的 gendisk，并且把 partno 设置为分区号。</p>
<p>我们再回到 __blkdev_get 函数中，得到 gendisk。接下来我们可以分两种情况。</p>
<p>如果 partno 为 0，也就是说，打开的是整个设备而不是分区，那我们就调用 disk_get_part，获取 gendisk 中的分区数组，然后调用 block_device_operations 里面的 open 函数打开设备。</p>
<p>如果 partno 不为 0，也就是说打开的是分区，那我们就获取整个设备的 block_device，赋值给变量 struct block_device *whole，然后调用递归 __blkdev_get，打开 whole 代表的整个设备，将 bd_contains 设置为变量 whole。</p>
<p>block_device_operations 就是在驱动层了。例如在 drivers/scsi/sd.c 里面，也就是 MODULE_DESCRIPTION(“SCSI disk (sd) driver”) 中，就有这样的定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">const</span> <span class="n">struct</span> <span class="n">block_device_operations</span> <span class="n">sd_fops</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">owner</span>			<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">open</span>			<span class="o">=</span> <span class="n">sd_open</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">sd_release</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">ioctl</span>			<span class="o">=</span> <span class="n">sd_ioctl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">getgeo</span>			<span class="o">=</span> <span class="n">sd_getgeo</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#ifdef CONFIG_COMPAT</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">compat_ioctl</span>		<span class="o">=</span> <span class="n">sd_compat_ioctl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">check_events</span>		<span class="o">=</span> <span class="n">sd_check_events</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">revalidate_disk</span>	<span class="o">=</span> <span class="n">sd_revalidate_disk</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">unlock_native_capacity</span>	<span class="o">=</span> <span class="n">sd_unlock_native_capacity</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">pr_ops</span>			<span class="o">=</span> <span class="o">&amp;</span><span class="n">sd_pr_ops</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">/**</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span>	<span class="n">sd_open</span> <span class="o">-</span> <span class="n">open</span> <span class="n">a</span> <span class="n">scsi</span> <span class="n">disk</span> <span class="n">device</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span>	<span class="err">@</span><span class="n">bdev</span><span class="p">:</span> <span class="n">Block</span> <span class="n">device</span> <span class="n">of</span> <span class="n">the</span> <span class="n">scsi</span> <span class="n">disk</span> <span class="n">to</span> <span class="n">open</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span>	<span class="err">@</span><span class="n">mode</span><span class="p">:</span> <span class="n">FMODE_</span><span class="o">*</span> <span class="n">mask</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span>	<span class="n">Returns</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">successful</span><span class="o">.</span> <span class="n">Returns</span> <span class="n">a</span> <span class="n">negated</span> <span class="n">errno</span> <span class="n">value</span> <span class="ow">in</span> <span class="k">case</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span>	<span class="n">of</span> <span class="n">error</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">**/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="ne">int</span> <span class="n">sd_open</span><span class="p">(</span><span class="n">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在驱动层打开了磁盘设备之后，我们可以看到，在这个过程中，block_device 相应的成员变量该填的都填上了，这才完成了 mount_bdev 的第一件大事，通过 blkdev_get_by_path 得到 block_device。</p>
<p>接下来就是第二件大事情，我们要通过 sget，将 block_device 塞进 superblock 里面。注意，调用 sget 的时候，有一个参数是一个函数 set_bdev_super。这里面将 block_device 设置进了 super_block。而 sget 要做的，就是分配一个 super_block，然后调用 set_bdev_super 这个 callback 函数。这里的 super_block 是 ext4 文件系统的 super_block。</p>
<p>sget(fs_type, test_bdev_super, set_bdev_super, flags | MS_NOSEC, bdev);</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static int set_bdev_super(struct super_block *s, void *data)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	s-&gt;s_bdev = data;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	s-&gt;s_dev = s-&gt;s_bdev-&gt;bd_dev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	s-&gt;s_bdi = bdi_get(s-&gt;s_bdev-&gt;bd_bdi);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  /**
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> *	sget	-	find or create a superblock
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> *	@type:	  filesystem type superblock should belong to
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> *	@test:	  comparison callback
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> *	@set:	  setup callback
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> *	@flags:	  mount flags
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> *	@data:	  argument to each of them
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct super_block *sget(struct file_system_type *type,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			int (*test)(struct super_block *,void *),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			int (*set)(struct super_block *,void *),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			int flags,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			void *data)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return sget_userns(type, test, set, flags, user_ns, data);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  /**
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> *	sget_userns -	find or create a superblock
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> *	@type:	filesystem type superblock should belong to
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> *	@test:	comparison callback
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> *	@set:	setup callback
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> *	@flags:	mount flags
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> *	@user_ns: User namespace for the super_block
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> *	@data:	argument to each of them
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct super_block *sget_userns(struct file_system_type *type,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			int (*test)(struct super_block *,void *),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			int (*set)(struct super_block *,void *),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			int flags, struct user_namespace *user_ns,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			void *data)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct super_block *s = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct super_block *old;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int err;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (!s) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		s = alloc_super(type, (flags &amp; ~MS_SUBMOUNT), user_ns);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	err = set(s, data);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	s-&gt;s_type = type;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	strlcpy(s-&gt;s_id, type-&gt;name, sizeof(s-&gt;s_id));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	list_add_tail(&amp;s-&gt;s_list, &amp;super_blocks);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	hlist_add_head(&amp;s-&gt;s_instances, &amp;type-&gt;fs_supers);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	spin_unlock(&amp;sb_lock);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	get_filesystem(type);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	register_shrinker(&amp;s-&gt;s_shrink);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return s;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>好了，到此为止，mount 中一个块设备的过程就结束了。设备打开了，形成了 block_device 结构，并且塞到了 super_block 中。</p>
<p>有了 ext4 文件系统的 super_block 之后，接下来对于文件的读写过程，就和文件系统那一章的过程一摸一样了。只要不涉及真正写入设备的代码，super_block 中的这个 block_device 就没啥用处。这也是为什么文件系统那一章，我们丝毫感觉不到它的存在，但是一旦到了底层，就到了 block_device 起作用的时候了，这个我们下一节仔细分析。</p>
<h2 id="总结时刻">总结时刻</h2>
<p>从这一节我们可以看出，块设备比字符设备复杂多了，涉及三个文件系统，工作过程我用一张图总结了一下，下面带你总结一下。</p>
<ol>
<li>所有的块设备被一个 map 结构管理从 dev_t 到 gendisk 的映射；</li>
<li>所有的 block_device 表示的设备或者分区都在 bdev 文件系统的 inode 列表中；</li>
<li>mknod 创建出来的块设备文件在 devtemfs 文件系统里面，特殊 inode 里面有块设备号；</li>
<li>mount 一个块设备上的文件系统，调用这个文件系统的 mount 接口；</li>
<li>通过按照 /dev/xxx 在文件系统 devtmpfs 文件系统上搜索到特殊 inode，得到块设备号；</li>
<li>根据特殊 inode 里面的 dev_t 在 bdev 文件系统里面找到 inode；</li>
<li>根据 bdev 文件系统上的 inode 找到对应的 block_device，根据 dev_t 在 map 中找到 gendisk，将两者关联起来；</li>
<li>找到 block_device 后打开设备，调用和 block_device 关联的 gendisk 里面的 block_device_operations 打开设备；</li>
<li>创建被 mount 的文件系统的 super_block。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3535c9788754cafa5d8179dad20d8d55.png" alt=""></p>
<h2 id="课堂练习">课堂练习</h2>
<p>到这里，你是否真的体会到了 Linux 里面“一切皆文件”了呢？那个特殊的 inode 除了能够表示字符设备和块设备，还能表示什么呢？请你看代码分析一下。</p>
<p>欢迎留言和我分享你的疑惑和见解，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1a5564dd4e1c9f25d4772c7f844ca84a.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">趣谈Linux操作系统</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A140%E9%97%AE/34__%E9%99%8D%E7%BA%A7%E7%86%94%E6%96%AD%E5%A6%82%E4%BD%95%E5%B1%8F%E8%94%BD%E9%9D%9E%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C%E7%9A%84%E5%BD%B1%E5%93%8D/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">34__降级熔断：如何屏蔽非核心系统故障的影响？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/34__%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%A0%E5%9C%A8%E4%BA%91%E4%B8%8A%E6%8B%BF%E5%88%B0%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84/">
            <span class="next-text nav-default">34__理解虚拟机：你在云上拿到的计算机是什么样的？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
