<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>39__管道：项目组A完成了，如何交接给项目组B？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="在这一章的第一节里，我们大概讲了管道的使用方式以及相应的命令行。这一节，我们就具体来看一下管道是如何实现的。
我们先来看，我们常用的匿名管道（Anonymous Pipes），也即将多个命令串起来的竖线，背后的原理到底是什么。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/39__%E7%AE%A1%E9%81%93%E9%A1%B9%E7%9B%AE%E7%BB%84a%E5%AE%8C%E6%88%90%E4%BA%86%E5%A6%82%E4%BD%95%E4%BA%A4%E6%8E%A5%E7%BB%99%E9%A1%B9%E7%9B%AE%E7%BB%84b/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/39__%E7%AE%A1%E9%81%93%E9%A1%B9%E7%9B%AE%E7%BB%84a%E5%AE%8C%E6%88%90%E4%BA%86%E5%A6%82%E4%BD%95%E4%BA%A4%E6%8E%A5%E7%BB%99%E9%A1%B9%E7%9B%AE%E7%BB%84b/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="39__管道：项目组A完成了，如何交接给项目组B？">
  <meta property="og:description" content="在这一章的第一节里，我们大概讲了管道的使用方式以及相应的命令行。这一节，我们就具体来看一下管道是如何实现的。
我们先来看，我们常用的匿名管道（Anonymous Pipes），也即将多个命令串起来的竖线，背后的原理到底是什么。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="趣谈Linux操作系统">

  <meta itemprop="name" content="39__管道：项目组A完成了，如何交接给项目组B？">
  <meta itemprop="description" content="在这一章的第一节里，我们大概讲了管道的使用方式以及相应的命令行。这一节，我们就具体来看一下管道是如何实现的。
我们先来看，我们常用的匿名管道（Anonymous Pipes），也即将多个命令串起来的竖线，背后的原理到底是什么。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4803">
  <meta itemprop="keywords" content="趣谈Linux操作系统">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="39__管道：项目组A完成了，如何交接给项目组B？">
  <meta name="twitter:description" content="在这一章的第一节里，我们大概讲了管道的使用方式以及相应的命令行。这一节，我们就具体来看一下管道是如何实现的。
我们先来看，我们常用的匿名管道（Anonymous Pipes），也即将多个命令串起来的竖线，背后的原理到底是什么。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">39__管道：项目组A完成了，如何交接给项目组B？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4803 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#总结时刻">总结时刻</a></li>
        <li><a href="#课堂练习">课堂练习</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>在这一章的第一节里，我们大概讲了管道的使用方式以及相应的命令行。这一节，我们就具体来看一下管道是如何实现的。</p>
<p>我们先来看，我们常用的<strong>匿名管道</strong>（Anonymous Pipes），也即将多个命令串起来的竖线，背后的原理到底是什么。</p>
<p>上次我们说，它是基于管道的，那管道如何创建呢？管道的创建，需要通过下面这个系统调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int pipe(int fd[2])
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，我们创建了一个管道 pipe，返回了两个文件描述符，这表示管道的两端，一个是管道的读取端描述符 fd[0]，另一个是管道的写入端描述符 fd[1]。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/297ec762e9cb3215e1899942093f69f1.png" alt=""></p>
<p>我们来看在内核里面是如何实现的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">SYSCALL_DEFINE1(pipe, int __user *, fildes)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return sys_pipe2(fildes, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> SYSCALL_DEFINE2(pipe2, int __user *, fildes, int, flags)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct file *files[2];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int fd[2];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int error;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	error = __do_pipe_flags(fd, files, flags);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (!error) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (unlikely(copy_to_user(fildes, fd, sizeof(fd)))) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			error = -EFAULT;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		} else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			fd_install(fd[0], files[0]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			fd_install(fd[1], files[1]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return error;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在内核中，主要的逻辑在 pipe2 系统调用中。这里面要创建一个数组 files，用来存放管道的两端的打开文件，另一个数组 fd 存放管道的两端的文件描述符。如果调用 __do_pipe_flags 没有错误，那就调用 fd_install，将两个 fd 和两个 struct file 关联起来。这一点和打开一个文件的过程很像了。</p>
<p>我们来看 __do_pipe_flags。这里面调用了 create_pipe_files，然后生成了两个 fd。从这里可以看出，fd[0] 是用于读的，fd[1] 是用于写的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static int __do_pipe_flags(int *fd, struct file **files, int flags)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int error;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int fdw, fdr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	error = create_pipe_files(files, flags);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	error = get_unused_fd_flags(flags);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	fdr = error;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	error = get_unused_fd_flags(flags);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	fdw = error;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	fd[0] = fdr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	fd[1] = fdw;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建一个管道，大部分的逻辑其实都是在 create_pipe_files 函数里面实现的。这一章第一节的时候，我们说过，命名管道是创建在文件系统上的。从这里我们可以看出，匿名管道，也是创建在文件系统上的，只不过是一种特殊的文件系统，创建一个特殊的文件，对应一个特殊的 inode，就是这里面的 get_pipe_inode。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int create_pipe_files(struct file **res, int flags)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int err;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct inode *inode = get_pipe_inode();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct file *f;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct path path;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	path.dentry = d_alloc_pseudo(pipe_mnt-&gt;mnt_sb, &amp;empty_name);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	path.mnt = mntget(pipe_mnt);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	d_instantiate(path.dentry, inode);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	f = alloc_file(&amp;path, FMODE_WRITE, &amp;pipefifo_fops);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	f-&gt;f_flags = O_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	f-&gt;private_data = inode-&gt;i_pipe;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	res[0] = alloc_file(&amp;path, FMODE_READ, &amp;pipefifo_fops);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	path_get(&amp;path);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	res[0]-&gt;private_data = inode-&gt;i_pipe;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	res[0]-&gt;f_flags = O_RDONLY | (flags &amp; O_NONBLOCK);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	res[1] = f;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>从 get_pipe_inode 的实现，我们可以看出，匿名管道来自一个特殊的文件系统 pipefs。这个文件系统被挂载后，我们就得到了 struct vfsmount *pipe_mnt。然后挂载的文件系统的 superblock 就变成了：pipe_mnt-&gt;mnt_sb。如果你对文件系统的操作还不熟悉，要返回去复习一下文件系统那一章啊。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static struct file_system_type pipe_fs_type = {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	.name		= &#34;pipefs&#34;,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	.mount		= pipefs_mount,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	.kill_sb	= kill_anon_super,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> static int __init init_pipe_fs(void)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int err = register_filesystem(&amp;pipe_fs_type);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	if (!err) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		pipe_mnt = kern_mount(&amp;pipe_fs_type);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> static struct inode * get_pipe_inode(void)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct inode *inode = new_inode_pseudo(pipe_mnt-&gt;mnt_sb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct pipe_inode_info *pipe;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	inode-&gt;i_ino = get_next_ino();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	pipe = alloc_pipe_info();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	inode-&gt;i_pipe = pipe;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	pipe-&gt;files = 2;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	pipe-&gt;readers = pipe-&gt;writers = 1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	inode-&gt;i_fop = &amp;pipefifo_fops;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	inode-&gt;i_state = I_DIRTY;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	inode-&gt;i_mode = S_IFIFO | S_IRUSR | S_IWUSR;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	inode-&gt;i_uid = current_fsuid();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	inode-&gt;i_gid = current_fsgid();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	return inode;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们从 new_inode_pseudo 函数创建一个 inode。这里面开始填写 Inode 的成员，这里和文件系统的很像。这里值得注意的是 struct pipe_inode_info，这个结构里面有个成员是 struct pipe_buffer *bufs。我们可以知道，<strong>所谓的匿名管道，其实就是内核里面的一串缓存</strong>。</p>
<p>另外一个需要注意的是 pipefifo_fops，将来我们对于文件描述符的操作，在内核里面都是对应这里面的操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">struct</span> <span class="n">file_operations</span> <span class="n">pipefifo_fops</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">fifo_open</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">read_iter</span>	<span class="o">=</span> <span class="n">pipe_read</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">write_iter</span>	<span class="o">=</span> <span class="n">pipe_write</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">pipe_poll</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">pipe_ioctl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">pipe_release</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">fasync</span>		<span class="o">=</span> <span class="n">pipe_fasync</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们回到 create_pipe_files 函数，创建完了 inode，还需创建一个 dentry 和他对应。dentry 和 inode 对应好了，我们就要开始创建 struct file 对象了。先创建用于写入的，对应的操作为 pipefifo_fops；再创建读取的，对应的操作也为 pipefifo_fops。然后把 private_data 设置为 pipe_inode_info。这样从 struct file 这个层级上，就能直接操作底层的读写操作。</p>
<p>至此，一个匿名管道就创建成功了。如果对于 fd[1] 写入，调用的是 pipe_write，向 pipe_buffer 里面写入数据；如果对于 fd[0] 的读入，调用的是 pipe_read，也就是从 pipe_buffer 里面读取数据。</p>
<p>但是这个时候，两个文件描述符都是在一个进程里面的，并没有起到进程间通信的作用，怎么样才能使得管道是跨两个进程的呢？还记得创建进程调用的 fork 吗？在这里面，创建的子进程会复制父进程的 struct files_struct，在这里面 fd 的数组会复制一份，但是 fd 指向的 struct file 对于同一个文件还是只有一份，这样就做到了，两个进程各有两个 fd 指向同一个 struct file 的模式，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/dcca6abead478473dc85e71f74debf38.png" alt=""></p>
<p>由于管道只能一端写入，另一端读出，所以上面的这种模式会造成混乱，因为父进程和子进程都可以写入，也都可以读出，通常的方法是父进程关闭读取的 fd，只保留写入的 fd，而子进程关闭写入的 fd，只保留读取的 fd，如果需要双向通行，则应该创建两个管道。</p>
<p>一个典型的使用管道在父子进程之间的通信代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;errno.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> int main(int argc, char *argv[])
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  int fds[2];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  if (pipe(fds) == -1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    perror(&#34;pipe error&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   pid_t pid;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  pid = fork();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  if (pid == -1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    perror(&#34;fork error&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   if (pid == 0){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    close(fds[0]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    char msg[] = &#34;hello world&#34;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    write(fds[1], msg, strlen(msg) + 1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    close(fds[1]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  } else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    close(fds[1]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    char msg[128];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    read(fds[0], msg, 128);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    close(fds[0]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    printf(&#34;message : %s\n&#34;, msg);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/327ca782d780c04e98ad99398bd5d181.png" alt=""></p>
<p>到这里，我们仅仅解析了使用管道进行父子进程之间的通信，但是我们在 shell 里面的不是这样的。在 shell 里面运行 A|B 的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系。</p>
<p>不过，有了上面父子进程之间的管道这个基础，实现 A 和 B 之间的管道就方便多了。</p>
<p>我们首先从 shell 创建子进程 A，然后在 shell 和 A 之间建立一个管道，其中 shell 保留读取端，A 进程保留写入端，然后 shell 再创建子进程 B。这又是一次 fork，所以，shell 里面保留的读取端的 fd 也被复制到了子进程 B 里面。这个时候，相当于 shell 和 B 都保留读取端，只要 shell 主动关闭读取端，就变成了一管道，写入端在 A 进程，读取端在 B 进程。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/bfd755fd7f2cc0d384f2bd1e43812738.png" alt=""></p>
<p>接下来我们要做的事情就是，将这个管道的两端和输入输出关联起来。这就要用到 dup2 系统调用了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int dup2(int oldfd, int newfd);
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个系统调用，将老的文件描述符赋值给新的文件描述符，让 newfd 的值和 oldfd 一样。</p>
<p>我们还是回忆一下，在 files_struct 里面，有这样一个表，下标是 fd，内容指向一个打开的文件 struct file。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct files_struct {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  struct file __rcu * fd_array[NR_OPEN_DEFAULT];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个表里面，前三项是定下来的，其中第零项 STDIN_FILENO 表示标准输入，第一项 STDOUT_FILENO 表示标准输出，第三项 STDERR_FILENO 表示错误输出。</p>
<p>在 A 进程中，写入端可以做这样的操作：dup2(fd[1],STDOUT_FILENO)，将 STDOUT_FILENO（也即第一项）不再指向标准输出，而是指向创建的管道文件，那么以后往标准输出写入的任何东西，都会写入管道文件。</p>
<p>在 B 进程中，读取端可以做这样的操作，dup2(fd[0],STDIN_FILENO)，将 STDIN_FILENO 也即第零项不再指向标准输入，而是指向创建的管道文件，那么以后从标准输入读取的任何东西，都来自于管道文件。</p>
<p>至此，我们才将 A|B 的功能完成。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ab27f0382a3f37b7f926b281a7a2a48b.png" alt=""></p>
<p>为了模拟 A|B 的情况，我们可以将前面的那一段代码，进一步修改成为下面这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;errno.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> int main(int argc, char *argv[])
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  int fds[2];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  if (pipe(fds) == -1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    perror(&#34;pipe error&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   pid_t pid;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  pid = fork();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  if (pid == -1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    perror(&#34;fork error&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   if (pid == 0){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    dup2(fds[1], STDOUT_FILENO);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    close(fds[1]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    close(fds[0]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    execlp(&#34;ps&#34;, &#34;ps&#34;, &#34;-ef&#34;, NULL);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  } else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    dup2(fds[0], STDIN_FILENO);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    close(fds[0]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    close(fds[1]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    execlp(&#34;grep&#34;, &#34;grep&#34;, &#34;systemd&#34;, NULL);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，我们来看命名管道。我们在讲命令的时候讲过，命名管道需要事先通过命令 mkfifo，进行创建。如果是通过代码创建命名管道，也有一个函数，但是这不是一个系统调用，而是 Glibc 提供的函数。它的定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="ne">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">mkfifo</span> <span class="p">(</span><span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">dev_t</span> <span class="n">dev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">__xmknod</span> <span class="p">(</span><span class="n">_MKNOD_VER</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="n">S_IFIFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="ne">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">__xmknod</span> <span class="p">(</span><span class="ne">int</span> <span class="n">vers</span><span class="p">,</span> <span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">unsigned</span> <span class="n">long</span> <span class="n">long</span> <span class="ne">int</span> <span class="n">k_dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">/*</span> <span class="n">We</span> <span class="n">must</span> <span class="nb">convert</span> <span class="n">the</span> <span class="n">value</span> <span class="n">to</span> <span class="n">dev_t</span> <span class="n">type</span> <span class="n">used</span> <span class="n">by</span> <span class="n">the</span> <span class="n">kernel</span><span class="o">.</span>  <span class="o">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">k_dev</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span><span class="n">ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">INLINE_SYSCALL</span> <span class="p">(</span><span class="n">mknodat</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                         <span class="p">(</span><span class="n">unsigned</span> <span class="ne">int</span><span class="p">)</span> <span class="n">k_dev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Glibc 的 mkfifo 函数会调用 mknodat 系统调用，还记得咱们学字符设备的时候，创建一个字符设备的时候，也是调用的 mknod。这里命名管道也是一个设备，因而我们也用 mknod。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">mknodat</span><span class="p">,</span> <span class="ne">int</span><span class="p">,</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="n">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">unsigned</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">unsigned</span> <span class="ne">int</span> <span class="n">lookup_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">retry</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">dentry</span> <span class="o">=</span> <span class="n">user_path_create</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">lookup_flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="n">S_IFIFO</span><span class="p">:</span> <span class="k">case</span> <span class="n">S_IFSOCK</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_mknod</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span><span class="n">dentry</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于 mknod 的解析，我们在字符设备那一节已经解析过了，先是通过 user_path_create 对于这个管道文件创建一个 dentry，然后因为是 S_IFIFO，所以调用 vfs_mknod。由于这个管道文件是创建在一个普通文件系统上的，假设是在 ext4 文件上，于是 vfs_mknod 会调用 ext4_dir_inode_operations 的 mknod，也即会调用 ext4_mknod。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">struct</span> <span class="n">inode_operations</span> <span class="n">ext4_dir_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">mknod</span>		<span class="o">=</span> <span class="n">ext4_mknod</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">static</span> <span class="ne">int</span> <span class="n">ext4_mknod</span><span class="p">(</span><span class="n">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="n">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		      <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">rdev</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">inode</span> <span class="o">=</span> <span class="n">ext4_new_inode_start_handle</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">					    <span class="n">NULL</span><span class="p">,</span> <span class="n">EXT4_HT_DIR</span><span class="p">,</span> <span class="n">credits</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_current_handle</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">rdev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext4_special_inode_operations</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_add_nondir</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">ext4_handle_sync</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1">#define ext4_new_inode_start_handle(dir, mode, qstr, goal, owner, \</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				    <span class="n">type</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">)</span>		    \
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">__ext4_new_inode</span><span class="p">(</span><span class="n">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="p">(</span><span class="n">mode</span><span class="p">),</span> <span class="p">(</span><span class="n">qstr</span><span class="p">),</span> <span class="p">(</span><span class="n">goal</span><span class="p">),</span> <span class="p">(</span><span class="n">owner</span><span class="p">),</span> \
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			 <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">type</span><span class="p">),</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="p">(</span><span class="n">nblocks</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="n">void</span> <span class="n">init_special_inode</span><span class="p">(</span><span class="n">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">rdev</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">def_chr_fops</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span> <span class="o">=</span> <span class="n">rdev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">def_blk_fops</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span> <span class="o">=</span> <span class="n">rdev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISFIFO</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pipefifo_fops</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISSOCK</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="p">;</span>	<span class="o">/*</span> <span class="n">leave</span> <span class="n">it</span> <span class="n">no_open_fops</span> <span class="o">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">else</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 ext4_mknod 中，ext4_new_inode_start_handle 会调用 __ext4_new_inode，在 ext4 文件系统上真的创建一个文件，但是会调用 init_special_inode，创建一个内存中特殊的 inode，这个函数我们在字符设备文件中也遇到过，只不过当时 inode 的 i_fop 指向的是 def_chr_fops，这次换成管道文件了，inode 的 i_fop 变成指向 pipefifo_fops，这一点和匿名管道是一样的。</p>
<p>这样，管道文件就创建完毕了。</p>
<p>接下来，要打开这个管道文件，我们还是会调用文件系统的 open 函数。还是沿着文件系统的调用方式，一路调用到 pipefifo_fops 的 open 函数，也就是 fifo_open。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static int fifo_open(struct inode *inode, struct file *filp)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct pipe_inode_info *pipe;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	bool is_pipe = inode-&gt;i_sb-&gt;s_magic == PIPEFS_MAGIC;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int ret;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	filp-&gt;f_version = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	if (inode-&gt;i_pipe) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		pipe = inode-&gt;i_pipe;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		pipe-&gt;files++;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	} else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		pipe = alloc_pipe_info();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		pipe-&gt;files = 1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		inode-&gt;i_pipe = pipe;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		spin_unlock(&amp;inode-&gt;i_lock);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	filp-&gt;private_data = pipe;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	filp-&gt;f_mode &amp;= (FMODE_READ | FMODE_WRITE);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	switch (filp-&gt;f_mode) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	case FMODE_READ:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		pipe-&gt;r_counter++;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (pipe-&gt;readers++ == 0)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			wake_up_partner(pipe);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (!is_pipe &amp;&amp; !pipe-&gt;writers) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			if ((filp-&gt;f_flags &amp; O_NONBLOCK)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			filp-&gt;f_version = pipe-&gt;w_counter;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			} else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				if (wait_for_partner(pipe, &amp;pipe-&gt;w_counter))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">					goto err_rd;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		break;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	case FMODE_WRITE:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		pipe-&gt;w_counter++;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (!pipe-&gt;writers++)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			wake_up_partner(pipe);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (!is_pipe &amp;&amp; !pipe-&gt;readers) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			if (wait_for_partner(pipe, &amp;pipe-&gt;r_counter))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				goto err_wr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		break;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	case FMODE_READ | FMODE_WRITE:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		pipe-&gt;readers++;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		pipe-&gt;writers++;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		pipe-&gt;r_counter++;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		pipe-&gt;w_counter++;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (pipe-&gt;readers == 1 || pipe-&gt;writers == 1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			wake_up_partner(pipe);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		break;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 fifo_open 里面，创建 pipe_inode_info，这一点和匿名管道也是一样的。这个结构里面有个成员是 struct pipe_buffer *bufs。我们可以知道，<strong>所谓的命名管道，其实是也是内核里面的一串缓存。</strong></p>
<p>接下来，对于命名管道的写入，我们还是会调用 pipefifo_fops 的 pipe_write 函数，向 pipe_buffer 里面写入数据。对于命名管道的读入，我们还是会调用 pipefifo_fops 的 pipe_read，也就是从 pipe_buffer 里面读取数据。</p>
<h2 id="总结时刻">总结时刻</h2>
<p>无论是匿名管道，还是命名管道，在内核都是一个文件。只要是文件就要有一个 inode。这里我们又用到了特殊 inode、字符设备、块设备，其实都是这种特殊的 inode。</p>
<p>在这种特殊的 inode 里面，file_operations 指向管道特殊的 pipefifo_fops，这个 inode 对应内存里面的缓存。</p>
<p>当我们用文件的 open 函数打开这个管道设备文件的时候，会调用 pipefifo_fops 里面的方法创建 struct file 结构，他的 inode 指向特殊的 inode，也对应内存里面的缓存，file_operations 也指向管道特殊的 pipefifo_fops。</p>
<p>写入一个 pipe 就是从 struct file 结构找到缓存写入，读取一个 pipe 就是从 struct file 结构找到缓存读出。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8eca715e806eb632243f3d224872abf5.png" alt=""></p>
<h2 id="课堂练习">课堂练习</h2>
<p>上面创建匿名管道的程序，你一定要运行一下，然后试着通过 strace 查看自己写的程序的系统调用，以及直接在命令行使用匿名管道的系统调用，做一个比较。</p>
<p>欢迎留言和我分享你的疑惑和见解，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1a5564dd4e1c9f25d4772c7f844ca84a.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">趣谈Linux操作系统</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B5%B5%E6%88%90%E7%9A%84%E8%BF%90%E7%BB%B4%E4%BD%93%E7%B3%BB%E7%AE%A1%E7%90%86%E8%AF%BE/39__%E6%95%85%E9%9A%9C%E7%AE%A1%E7%90%86%E9%BC%93%E5%8A%B1%E5%81%9A%E4%BA%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E5%A4%84%E7%BD%9A%E9%94%99%E8%AF%AF/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">39__故障管理：鼓励做事，而不是处罚错误</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/39__%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%BB%8E%E7%94%B5%E5%BD%B1%E8%9D%B4%E8%9D%B6%E6%95%88%E5%BA%94%E4%B8%AD%E5%AD%A6%E4%B9%A0%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/">
            <span class="next-text nav-default">39__回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
