<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>52__计算虚拟化之内存：如何建立独立的办公室？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="上一节，我们解析了计算虚拟化之 CPU。可以看到，CPU 的虚拟化是用户态的 qemu 和内核态的 KVM 共同配合完成的。它们二者通过 ioctl 进行通信。对于内存管理来讲，也是需要这两者配合完成的。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/52__%E8%AE%A1%E7%AE%97%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%8A%9E%E5%85%AC%E5%AE%A4/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/52__%E8%AE%A1%E7%AE%97%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%8A%9E%E5%85%AC%E5%AE%A4/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="52__计算虚拟化之内存：如何建立独立的办公室？">
  <meta property="og:description" content="上一节，我们解析了计算虚拟化之 CPU。可以看到，CPU 的虚拟化是用户态的 qemu 和内核态的 KVM 共同配合完成的。它们二者通过 ioctl 进行通信。对于内存管理来讲，也是需要这两者配合完成的。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="趣谈Linux操作系统">

  <meta itemprop="name" content="52__计算虚拟化之内存：如何建立独立的办公室？">
  <meta itemprop="description" content="上一节，我们解析了计算虚拟化之 CPU。可以看到，CPU 的虚拟化是用户态的 qemu 和内核态的 KVM 共同配合完成的。它们二者通过 ioctl 进行通信。对于内存管理来讲，也是需要这两者配合完成的。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="9118">
  <meta itemprop="keywords" content="趣谈Linux操作系统">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="52__计算虚拟化之内存：如何建立独立的办公室？">
  <meta name="twitter:description" content="上一节，我们解析了计算虚拟化之 CPU。可以看到，CPU 的虚拟化是用户态的 qemu 和内核态的 KVM 共同配合完成的。它们二者通过 ioctl 进行通信。对于内存管理来讲，也是需要这两者配合完成的。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">52__计算虚拟化之内存：如何建立独立的办公室？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 9118 字 </span>
          <span class="more-meta"> 预计阅读 19 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#内存管理">内存管理</a></li>
        <li><a href="#页面分配和映射">页面分配和映射</a>
          <ul>
            <li><a href="#影子页表">影子页表</a></li>
            <li><a href="#扩展页表">扩展页表</a></li>
          </ul>
        </li>
        <li><a href="#总结时刻">总结时刻</a></li>
        <li><a href="#课堂练习">课堂练习</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>上一节，我们解析了计算虚拟化之 CPU。可以看到，CPU 的虚拟化是用户态的 qemu 和内核态的 KVM 共同配合完成的。它们二者通过 ioctl 进行通信。对于内存管理来讲，也是需要这两者配合完成的。</p>
<p>咱们在内存管理的时候讲过，操作系统给每个进程分配的内存都是虚拟内存，需要通过页表映射，变成物理内存进行访问。当有了虚拟机之后，情况会变得更加复杂。因为虚拟机对于物理机来讲是一个进程，但是虚拟机里面也有内核，也有虚拟机里面跑的进程。所以有了虚拟机，内存就变成了四类：</p>
<ul>
<li><strong>虚拟机里面的虚拟内存</strong>（Guest OS Virtual Memory，GVA），这是虚拟机里面的进程看到的内存空间；</li>
<li><strong>虚拟机里面的物理内存</strong>（Guest OS Physical Memory，GPA），这是虚拟机里面的操作系统看到的内存，它认为这是物理内存；</li>
<li><strong>物理机的虚拟内存</strong>（Host Virtual Memory，HVA），这是物理机上的 qemu 进程看到的内存空间；</li>
<li><strong>物理机的物理内存</strong>（Host Physical Memory，HPA），这是物理机上的操作系统看到的内存。</li>
</ul>
<p>咱们内存管理那一章讲的两大内容，一个是内存管理，它变得非常复杂；另一个是内存映射，具体来说就是，从 GVA 到 GPA，到 HVA，再到 HPA，这样几经转手，计算机的性能就会变得很差。当然，虚拟化技术成熟的今天，有了一些优化的手段，具体怎么优化呢？我们这一节就来一一解析。</p>
<h2 id="内存管理">内存管理</h2>
<p>我们先来看内存管理的部分。</p>
<p>由于 CPU 和内存是紧密结合的，因而内存虚拟化的初始化过程，和 CPU 虚拟化的初始化是一起完成的。</p>
<p>上一节说 CPU 虚拟化初始化的时候，我们会调用 kvm_init 函数，这里面打开了&quot;/dev/kvm&quot;这个字符文件，并且通过 ioctl 调用到内核 kvm 的 KVM_CREATE_VM 操作，除了这些 CPU 相关的调用，接下来还有内存相关的。我们来看看。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static int kvm_init(MachineState *ms)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MachineClass *mc = MACHINE_GET_CLASS(ms);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    kvm_memory_listener_register(s, &amp;s-&gt;memory_listener,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                 &amp;address_space_memory, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    memory_listener_register(&amp;kvm_io_listener,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                             &amp;address_space_io);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> AddressSpace address_space_io;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">AddressSpace address_space_memory;
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里面有两个地址空间 AddressSpace，一个是系统内存的地址空间 address_space_memory，一个用于 I/O 的地址空间 address_space_io。这里我们重点看 address_space_memory。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct AddressSpace {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* All fields are private. */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct rcu_head rcu;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    char *name;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MemoryRegion *root;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     /* Accessed via RCU.  */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct FlatView *current_map;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     int ioeventfd_nb;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct MemoryRegionIoeventfd *ioeventfds;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    QTAILQ_HEAD(, MemoryListener) listeners;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    QTAILQ_ENTRY(AddressSpace) address_spaces_link;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于一个地址空间，会有多个内存区域 MemoryRegion 组成树形结构。这里面，root 是这棵树的根。另外，还有一个 MemoryListener 链表，当内存区域发生变化的时候，需要做一些动作，使得用户态和内核态能够协同，就是由这些 MemoryListener 完成的。</p>
<p>在 kvm_init 这个时候，还没有内存区域加入进来，root 还是空的，但是我们可以先注册 MemoryListener，这里注册的是 KVMMemoryListener。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void kvm_memory_listener_register(KVMState *s, KVMMemoryListener *kml,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                  AddressSpace *as, int as_id)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int i;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     kml-&gt;slots = g_malloc0(s-&gt;nr_slots * sizeof(KVMSlot));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    kml-&gt;as_id = as_id;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     for (i = 0; i &lt; s-&gt;nr_slots; i++) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        kml-&gt;slots[i].slot = i;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     kml-&gt;listener.region_add = kvm_region_add;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    kml-&gt;listener.region_del = kvm_region_del;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    kml-&gt;listener.priority = 10;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     memory_listener_register(&amp;kml-&gt;listener, as);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个 KVMMemoryListener 中是这样配置的：当添加一个 MemoryRegion 的时候，region_add 会被调用，这个我们后面会用到。</p>
<p>接下来，在 qemu 启动的 main 函数中，我们会调用 cpu_exec_init_all-&gt;memory_map_init.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static void memory_map_init(void)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    system_memory = g_malloc(sizeof(*system_memory));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     memory_region_init(system_memory, NULL, &#34;system&#34;, UINT64_MAX);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    address_space_init(&amp;address_space_memory, system_memory, &#34;memory&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     system_io = g_malloc(sizeof(*system_io));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    memory_region_init_io(system_io, NULL, &amp;unassigned_io_ops, NULL, &#34;io&#34;,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                          65536);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    address_space_init(&amp;address_space_io, system_io, &#34;I/O&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，对于系统内存区域 system_memory 和用于 I/O 的内存区域 system_io，我们都进行了初始化，并且关联到了相应的地址空间 AddressSpace。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">address_space_init</span><span class="p">(</span><span class="n">AddressSpace</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span> <span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">memory_region_ref</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">as</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">as</span><span class="o">-&gt;</span><span class="n">current_map</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">as</span><span class="o">-&gt;</span><span class="n">ioeventfd_nb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">as</span><span class="o">-&gt;</span><span class="n">ioeventfds</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">QTAILQ_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">listeners</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">QTAILQ_INSERT_TAIL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">address_spaces</span><span class="p">,</span> <span class="n">as</span><span class="p">,</span> <span class="n">address_spaces_link</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">as</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">g_strdup</span><span class="p">(</span><span class="n">name</span> <span class="err">?</span> <span class="n">name</span> <span class="p">:</span> <span class="s2">&#34;anonymous&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">address_space_update_topology</span><span class="p">(</span><span class="n">as</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">address_space_update_ioeventfds</span><span class="p">(</span><span class="n">as</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于系统内存地址空间 address_space_memory，我们需要把它里面内存区域的根 root 设置为 system_memory。</p>
<p>另外，在这里，我们还调用了 address_space_update_topology。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static void address_space_update_topology(AddressSpace *as)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MemoryRegion *physmr = memory_region_get_flatview_root(as-&gt;root);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     flatviews_init();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (!g_hash_table_lookup(flat_views, physmr)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        generate_memory_topology(physmr);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    address_space_set_flatview(as);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> static void address_space_set_flatview(AddressSpace *as)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    FlatView *old_view = address_space_to_flatview(as);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MemoryRegion *physmr = memory_region_get_flatview_root(as-&gt;root);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    FlatView *new_view = g_hash_table_lookup(flat_views, physmr);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     if (old_view == new_view) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        return;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (!QTAILQ_EMPTY(&amp;as-&gt;listeners)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        FlatView tmpview = { .nr = 0 }, *old_view2 = old_view;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         if (!old_view2) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            old_view2 = &amp;tmpview;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        address_space_update_topology_pass(as, old_view2, new_view, false);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        address_space_update_topology_pass(as, old_view2, new_view, true);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     /* Writes are protected by the BQL.  */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    atomic_rcu_set(&amp;as-&gt;current_map, new_view);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里面会生成 AddressSpace 的 flatview。flatview 是什么意思呢？</p>
<p>我们可以看到，在 AddressSpace 里面，除了树形结构的 MemoryRegion 之外，还有一个 flatview 结构，其实这个结构就是把这样一个树形的内存结构变成平的内存结构。因为树形内存结构比较容易管理，但是平的内存结构，比较方便和内核里面通信，来请求物理内存。虽然操作系统内核里面也是用树形结构来表示内存区域的，但是用户态向内核申请内存的时候，会按照平的、连续的模式进行申请。这里，qemu 在用户态，所以要做这样一个转换。</p>
<p>在 address_space_set_flatview 中，我们将老的 flatview 和新的 flatview 进行比较。如果不同，说明内存结构发生了变化，会调用 address_space_update_topology_pass-&gt;MEMORY_LISTENER_UPDATE_REGION-&gt;MEMORY_LISTENER_CALL。</p>
<p>这里面调用所有的 listener。但是，这个逻辑这里不会执行的。这是因为这里内存处于初始化的阶段，全局的 flat_views 里面肯定找不到。因而 generate_memory_topology 第一次生成了 FlatView，然后才调用了 address_space_set_flatview。这里面，老的 flatview 和新的 flatview 一定是一样的。</p>
<p>但是，请你记住这个逻辑，到这里我们还没解析 qemu 有关内存的参数，所以这里添加的 MemoryRegion 虽然是一个根，但是是空的，是为了管理使用的，后面真的添加内存的时候，这个逻辑还会调用到。</p>
<p>我们再回到 qemu 启动的 main 函数中。接下来的初始化过程会调用 pc_init1。在这里面，对于 CPU 虚拟化，我们会调用 pc_cpus_init。这个我们在上一节已经讲过了。另外，pc_init1 还会调用 pc_memory_init，进行内存的虚拟化，我们这里解析这一部分。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void pc_memory_init(PCMachineState *pcms,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    MemoryRegion *system_memory,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    MemoryRegion *rom_memory,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    MemoryRegion **ram_memory)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int linux_boot, i;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MemoryRegion *ram, *option_rom_mr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MemoryRegion *ram_below_4g, *ram_above_4g;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    FWCfgState *fw_cfg;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MachineState *machine = MACHINE(pcms);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* Allocate RAM.  We allocate it as a single memory region and use
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     * aliases to address portions of it, mostly for backwards compatibility with older qemus that used qemu_ram_alloc().
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ram = g_malloc(sizeof(*ram));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    memory_region_allocate_system_memory(ram, NULL, &#34;pc.ram&#34;,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                         machine-&gt;ram_size);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    *ram_memory = ram;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ram_below_4g = g_malloc(sizeof(*ram_below_4g));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    memory_region_init_alias(ram_below_4g, NULL, &#34;ram-below-4g&#34;, ram,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                             0, pcms-&gt;below_4g_mem_size);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    memory_region_add_subregion(system_memory, 0, ram_below_4g);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    e820_add_entry(0, pcms-&gt;below_4g_mem_size, E820_RAM);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (pcms-&gt;above_4g_mem_size &gt; 0) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ram_above_4g = g_malloc(sizeof(*ram_above_4g));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        memory_region_init_alias(ram_above_4g, NULL, &#34;ram-above-4g&#34;, ram, pcms-&gt;below_4g_mem_size, pcms-&gt;above_4g_mem_size);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        memory_region_add_subregion(system_memory, 0x100000000ULL,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                    ram_above_4g);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        e820_add_entry(0x100000000ULL, pcms-&gt;above_4g_mem_size, E820_RAM);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 pc_memory_init 中，我们已经知道了虚拟机要申请的内存 ram_size，于是通过 memory_region_allocate_system_memory 来申请内存。</p>
<p>接下来的调用链为：memory_region_allocate_system_memory-&gt;allocate_system_memory_nonnuma-&gt;memory_region_init_ram_nomigrate-&gt;memory_region_init_ram_shared_nomigrate。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">memory_region_init_ram_shared_nomigrate</span><span class="p">(</span><span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">mr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                             <span class="ne">Object</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                             <span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                             <span class="n">uint64_t</span> <span class="n">size</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                             <span class="ne">bool</span> <span class="n">share</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                             <span class="n">Error</span> <span class="o">**</span><span class="n">errp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Error</span> <span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">memory_region_init</span><span class="p">(</span><span class="n">mr</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mr</span><span class="o">-&gt;</span><span class="n">ram</span> <span class="o">=</span> <span class="bp">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mr</span><span class="o">-&gt;</span><span class="n">terminates</span> <span class="o">=</span> <span class="bp">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mr</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">memory_region_destructor_ram</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mr</span><span class="o">-&gt;</span><span class="n">ram_block</span> <span class="o">=</span> <span class="n">qemu_ram_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">share</span><span class="p">,</span> <span class="n">mr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">static</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">RAMBlock</span> <span class="o">*</span><span class="n">qemu_ram_alloc_internal</span><span class="p">(</span><span class="n">ram_addr_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">ram_addr_t</span> <span class="n">max_size</span><span class="p">,</span> <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resized</span><span class="p">)(</span><span class="k">const</span> <span class="n">char</span><span class="o">*</span><span class="p">,</span><span class="n">uint64_t</span> <span class="n">length</span><span class="p">,</span><span class="n">void</span> <span class="o">*</span><span class="n">host</span><span class="p">),</span><span class="n">void</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="ne">bool</span> <span class="n">resizeable</span><span class="p">,</span> <span class="ne">bool</span> <span class="n">share</span><span class="p">,</span><span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">mr</span><span class="p">,</span> <span class="n">Error</span> <span class="o">**</span><span class="n">errp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">RAMBlock</span> <span class="o">*</span><span class="n">new_block</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">size</span> <span class="o">=</span> <span class="n">HOST_PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">max_size</span> <span class="o">=</span> <span class="n">HOST_PAGE_ALIGN</span><span class="p">(</span><span class="n">max_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">new_block</span> <span class="o">=</span> <span class="n">g_malloc0</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_block</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">mr</span> <span class="o">=</span> <span class="n">mr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">resized</span> <span class="o">=</span> <span class="n">resized</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">used_length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">max_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">=</span> <span class="n">getpagesize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">host</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ram_block_add</span><span class="p">(</span><span class="n">new_block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local_err</span><span class="p">,</span> <span class="n">share</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">new_block</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">static</span> <span class="n">void</span> <span class="n">ram_block_add</span><span class="p">(</span><span class="n">RAMBlock</span> <span class="o">*</span><span class="n">new_block</span><span class="p">,</span> <span class="n">Error</span> <span class="o">**</span><span class="n">errp</span><span class="p">,</span> <span class="ne">bool</span> <span class="n">shared</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">RAMBlock</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">RAMBlock</span> <span class="o">*</span><span class="n">last_block</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ram_addr_t</span> <span class="n">old_ram_size</span><span class="p">,</span> <span class="n">new_ram_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Error</span> <span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">old_ram_size</span> <span class="o">=</span> <span class="n">last_ram_page</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">find_ram_offset</span><span class="p">(</span><span class="n">new_block</span><span class="o">-&gt;</span><span class="n">max_length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_block</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">new_block</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">phys_mem_alloc</span><span class="p">(</span><span class="n">new_block</span><span class="o">-&gt;</span><span class="n">max_length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_block</span><span class="o">-&gt;</span><span class="n">mr</span><span class="o">-&gt;</span><span class="n">align</span><span class="p">,</span> <span class="n">shared</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里面，我们会调用 qemu_ram_alloc，创建一个 RAMBlock 用来表示内存块。这里面调用 ram_block_add-&gt;phys_mem_alloc。phys_mem_alloc 是一个函数指针，指向函数 qemu_anon_ram_alloc，这里面调用 qemu_ram_mmap，在 qemu_ram_mmap 中调用 mmap 分配内存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static void *(*phys_mem_alloc)(size_t size, uint64_t *align, bool shared) = qemu_anon_ram_alloc;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> void *qemu_anon_ram_alloc(size_t size, uint64_t *alignment, bool shared)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    size_t align = QEMU_VMALLOC_ALIGN;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void *ptr = qemu_ram_mmap(-1, size, align, shared);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (alignment) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        *alignment = align;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return ptr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> void *qemu_ram_mmap(int fd, size_t size, size_t align, bool shared)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int flags;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int guardfd;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    size_t offset;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    size_t pagesize;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    size_t total;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void *guardptr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void *ptr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    total = size + align;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    guardfd = -1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    pagesize = getpagesize();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    flags = MAP_PRIVATE | MAP_ANONYMOUS;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    guardptr = mmap(0, total, PROT_NONE, flags, guardfd, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    flags = MAP_FIXED;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    flags |= fd == -1 ? MAP_ANONYMOUS : 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    flags |= shared ? MAP_SHARED : MAP_PRIVATE;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    offset = QEMU_ALIGN_UP((uintptr_t)guardptr, align) - (uintptr_t)guardptr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ptr = mmap(guardptr + offset, size, PROT_READ | PROT_WRITE, flags, fd, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return ptr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们回到 pc_memory_init，通过 memory_region_allocate_system_memory 申请到内存以后，为了兼容过去的版本，我们分成两个 MemoryRegion 进行管理，一个是 ram_below_4g，一个是 ram_above_4g。对于这两个 MemoryRegion，我们都会初始化一个 alias，也即别名，意思是说，两个 MemoryRegion 其实都指向 memory_region_allocate_system_memory 分配的内存，只不过分成两个部分，起两个别名指向不同的区域。</p>
<p>这两部分 MemoryRegion 都会调用 memory_region_add_subregion，将这两部分作为子的内存区域添加到 system_memory 这棵树上。</p>
<p>接下来的调用链为：memory_region_add_subregion-&gt;memory_region_add_subregion_common-&gt;memory_region_update_container_subregions。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static void memory_region_update_container_subregions(MemoryRegion *subregion)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MemoryRegion *mr = subregion-&gt;container;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MemoryRegion *other;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     memory_region_transaction_begin();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     memory_region_ref(subregion);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    QTAILQ_FOREACH(other, &amp;mr-&gt;subregions, subregions_link) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (subregion-&gt;priority &gt;= other-&gt;priority) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            QTAILQ_INSERT_BEFORE(other, subregion, subregions_link);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            goto done;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    QTAILQ_INSERT_TAIL(&amp;mr-&gt;subregions, subregion, subregions_link);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">done:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    memory_region_update_pending |= mr-&gt;enabled &amp;&amp; subregion-&gt;enabled;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    memory_region_transaction_commit();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 memory_region_update_container_subregions 中，我们会将子区域放到链表中，然后调用 memory_region_transaction_commit。在这里面，我们会调用 address_space_set_flatview。因为内存区域变了，flatview 也会变，就像上面分析过的一样，listener 会被调用。</p>
<p>因为添加了一个 MemoryRegion，region_add 也即 kvm_region_add。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static void kvm_region_add(MemoryListener *listener,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                           MemoryRegionSection *section)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    KVMMemoryListener *kml = container_of(listener, KVMMemoryListener, listener);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    kvm_set_phys_mem(kml, section, true);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> static void kvm_set_phys_mem(KVMMemoryListener *kml,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                             MemoryRegionSection *section, bool add)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    KVMSlot *mem;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int err;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MemoryRegion *mr = section-&gt;mr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    bool writeable = !mr-&gt;readonly &amp;&amp; !mr-&gt;rom_device;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    hwaddr start_addr, size;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void *ram;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    size = kvm_align_section(section, &amp;start_addr);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* use aligned delta to align the ram address */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ram = memory_region_get_ram_ptr(mr) + section-&gt;offset_within_region + (start_addr - section-&gt;offset_within_address_space);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* register the new slot */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    mem = kvm_alloc_slot(kml);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    mem-&gt;memory_size = size;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    mem-&gt;start_addr = start_addr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    mem-&gt;ram = ram;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    mem-&gt;flags = kvm_mem_flags(mr);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     err = kvm_set_user_memory_region(kml, mem, true);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>kvm_region_add 调用的是 kvm_set_phys_mem，这里面分配一个用于放这块那内存的 KVMSlot 结构，就像一个内存条一样，当然这是在用户态模拟出来的内存条，放在 KVMState 结构里面。这个结构是我们上一节创建虚拟机的时候创建的。</p>
<p>接下来，kvm_set_user_memory_region 就会将用户态模拟出来的内存条，和内核中的 KVM 模块关联起来。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static int kvm_set_user_memory_region(KVMMemoryListener *kml, KVMSlot *slot, bool new)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    KVMState *s = kvm_state;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct kvm_userspace_memory_region mem;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int ret;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     mem.slot = slot-&gt;slot | (kml-&gt;as_id &lt;&lt; 16);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    mem.guest_phys_addr = slot-&gt;start_addr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    mem.userspace_addr = (unsigned long)slot-&gt;ram;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    mem.flags = slot-&gt;flags;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    mem.memory_size = slot-&gt;memory_size;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    slot-&gt;old_flags = mem.flags;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return ret;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>终于，在这里，我们又看到了可以和内核通信的 kvm_vm_ioctl。我们来看内核收到 KVM_SET_USER_MEMORY_REGION 会做哪些事情。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static long kvm_vm_ioctl(struct file *filp,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">               unsigned int ioctl, unsigned long arg)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct kvm *kvm = filp-&gt;private_data;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void __user *argp = (void __user *)arg;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    switch (ioctl) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    case KVM_SET_USER_MEMORY_REGION: {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        struct kvm_userspace_memory_region kvm_userspace_mem;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (copy_from_user(&amp;kvm_userspace_mem, argp,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        sizeof(kvm_userspace_mem)))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            goto out;   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        r = kvm_vm_ioctl_set_memory_region(kvm, &amp;kvm_userspace_mem);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        break;  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来的调用链为：kvm_vm_ioctl_set_memory_region-&gt;kvm_set_memory_region-&gt;__kvm_set_memory_region。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">__kvm_set_memory_region</span><span class="p">(</span><span class="n">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			    <span class="k">const</span> <span class="n">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="ne">int</span> <span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">gfn_t</span> <span class="n">base_gfn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">unsigned</span> <span class="n">long</span> <span class="n">npages</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">kvm_memory_slot</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">old_memslots</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="ne">int</span> <span class="n">as_id</span><span class="p">,</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">enum</span> <span class="n">kvm_mr_change</span> <span class="n">change</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">as_id</span> <span class="o">=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	<span class="n">slot</span> <span class="o">=</span> <span class="n">id_to_memslot</span><span class="p">(</span><span class="n">__kvm_memslots</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">as_id</span><span class="p">),</span> <span class="n">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">base_gfn</span> <span class="o">=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">guest_phys_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">npages</span> <span class="o">=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">memory_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">new</span> <span class="o">=</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	<span class="n">new</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">new</span><span class="o">.</span><span class="n">base_gfn</span> <span class="o">=</span> <span class="n">base_gfn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">new</span><span class="o">.</span><span class="n">npages</span> <span class="o">=</span> <span class="n">npages</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">new</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	<span class="k">if</span> <span class="p">(</span><span class="n">change</span> <span class="o">==</span> <span class="n">KVM_MR_CREATE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">new</span><span class="o">.</span><span class="n">userspace_addr</span> <span class="o">=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">userspace_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_arch_create_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">,</span> <span class="n">npages</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">goto</span> <span class="n">out_free</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">slots</span> <span class="o">=</span> <span class="n">kvzalloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">kvm_memslots</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">memcpy</span><span class="p">(</span><span class="n">slots</span><span class="p">,</span> <span class="n">__kvm_memslots</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">as_id</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">kvm_memslots</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_prepare_memory_region</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">change</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	<span class="n">update_memslots</span><span class="p">(</span><span class="n">slots</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">old_memslots</span> <span class="o">=</span> <span class="n">install_new_memslots</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">as_id</span><span class="p">,</span> <span class="n">slots</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	<span class="n">kvm_arch_commit_memory_region</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">,</span> <span class="n">change</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在用户态每个 KVMState 有多个 KVMSlot，在内核里面，同样每个 struct kvm 也有多个 struct kvm_memory_slot，两者是对应起来的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 用户态
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct KVMState
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int nr_slots;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    KVMMemoryListener memory_listener;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> typedef struct KVMMemoryListener {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    MemoryListener listener;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    KVMSlot *slots;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int as_id;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} KVMMemoryListener
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> typedef struct KVMSlot
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    hwaddr start_addr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ram_addr_t memory_size;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void *ram;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int slot;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int flags;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int old_flags;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} KVMSlot;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 内核态
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct kvm {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	spinlock_t mmu_lock;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct mutex slots_lock;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct mm_struct *mm; /* userspace tied to this vm */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct kvm_memslots __rcu *memslots[KVM_ADDRESS_SPACE_NUM];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> struct kvm_memslots {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	u64 generation;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct kvm_memory_slot memslots[KVM_MEM_SLOTS_NUM];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	/* The mapping table from slot id to the index in memslots[]. */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	short id_to_index[KVM_MEM_SLOTS_NUM];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	atomic_t lru_slot;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int used_slots;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> struct kvm_memory_slot {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	gfn_t base_gfn;// 根据 guest_phys_addr 计算
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	unsigned long npages;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	unsigned long *dirty_bitmap;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct kvm_arch_memory_slot arch;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	unsigned long userspace_addr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	u32 flags;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	short id;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>并且，id_to_memslot 函数可以根据用户态的 slot 号得到内核态的 slot 结构。</p>
<p>如果传进来的参数是 KVM_MR_CREATE，表示要创建一个新的内存条，就会调用 kvm_arch_create_memslot 来创建 kvm_memory_slot 的成员 kvm_arch_memory_slot。</p>
<p>接下来就是创建 kvm_memslots 结构，填充这个结构，然后通过 install_new_memslots 将这个新的内存条，添加到 struct kvm 结构中。</p>
<p>至此，用户态的内存结构和内核态的内存结构算是对应了起来。</p>
<h2 id="页面分配和映射">页面分配和映射</h2>
<p>上面对于内存的管理，还只是停留在元数据的管理。对于内存的分配与映射，我们还没有涉及，接下来，我们就来看看，页面是如何进行分配和映射的。</p>
<p>上面咱们说了，内存映射对于虚拟机来讲是一件非常麻烦的事情，从 GVA 到 GPA 到 HVA 到 HPA，性能很差，为了解决这个问题，有两种主要的思路。</p>
<h3 id="影子页表">影子页表</h3>
<p>第一种方式就是软件的方式，<strong>影子页表</strong> （Shadow Page Table）。</p>
<p>按照咱们在内存管理那一节讲的，内存映射要通过页表来管理，页表地址应该放在 cr3 寄存器里面。本来的过程是，客户机要通过 cr3 找到客户机的页表，实现从 GVA 到 GPA 的转换，然后在宿主机上，要通过 cr3 找到宿主机的页表，实现从 HVA 到 HPA 的转换。</p>
<p>为了实现客户机虚拟地址空间到宿主机物理地址空间的直接映射。客户机中每个进程都有自己的虚拟地址空间，所以 KVM 需要为客户机中的每个进程页表都要维护一套相应的影子页表。</p>
<p>在客户机访问内存时，使用的不是客户机的原来的页表，而是这个页表对应的影子页表，从而实现了从客户机虚拟地址到宿主机物理地址的直接转换。而且，在 TLB 和 CPU 缓存上缓存的是来自影子页表中客户机虚拟地址和宿主机物理地址之间的映射，也因此提高了缓存的效率。</p>
<p>但是影子页表的引入也意味着 KVM 需要为每个客户机的每个进程的页表都要维护一套相应的影子页表，内存占用比较大，而且客户机页表和和影子页表也需要进行实时同步。</p>
<h3 id="扩展页表">扩展页表</h3>
<p>于是就有了第二种方式，就是硬件的方式，Intel 的 EPT（Extent Page Table，扩展页表）技术。</p>
<p>EPT 在原有客户机页表对客户机虚拟地址到客户机物理地址映射的基础上，又引入了 EPT 页表来实现客户机物理地址到宿主机物理地址的另一次映射。客户机运行时，客户机页表被载入 CR3，而 EPT 页表被载入专门的 EPT 页表指针寄存器 EPTP。</p>
<p>有了 EPT，在客户机物理地址到宿主机物理地址转换的过程中，缺页会产生 EPT 缺页异常。KVM 首先根据引起异常的客户机物理地址，映射到对应的宿主机虚拟地址，然后为此虚拟地址分配新的物理页，最后 KVM 再更新 EPT 页表，建立起引起异常的客户机物理地址到宿主机物理地址之间的映射。</p>
<p>KVM 只需为每个客户机维护一套 EPT 页表，也大大减少了内存的开销。</p>
<p>这里，我们重点看第二种方式。因为使用了 EPT 之后，客户机里面的页表映射，也即从 GVA 到 GPA 的转换，还是用传统的方式，和在内存管理那一章讲的没有什么区别。而 EPT 重点帮我们解决的就是从 GPA 到 HPA 的转换问题。因为要经过两次页表，所以 EPT 又 tdp(two dimentional paging)。</p>
<p>EPT 的页表结构也是分为四层，EPT Pointer（EPTP）指向 PML4 的首地址。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/479b296f4911d782b8e6c2efafc3446b.png" alt=""></p>
<p>管理物理页面的 Page 结构和咱们讲内存管理那一章是一样的。EPT 页表也需要存放在一个页中，这些页要用 kvm_mmu_page 这个结构来管理。</p>
<p>当一个虚拟机运行，进入客户机模式的时候，我们上一节解析过，它会调用 vcpu_enter_guest 函数，这里面会调用 kvm_mmu_reload-&gt;kvm_mmu_load。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">kvm_mmu_load</span><span class="p">(</span><span class="n">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">r</span> <span class="o">=</span> <span class="n">mmu_topup_memory_caches</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">r</span> <span class="o">=</span> <span class="n">mmu_alloc_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">kvm_mmu_sync_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">/*</span> <span class="n">set_cr3</span><span class="p">()</span> <span class="n">should</span> <span class="n">ensure</span> <span class="n">TLB</span> <span class="n">has</span> <span class="n">been</span> <span class="n">flushed</span> <span class="o">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="o">.</span><span class="n">mmu</span><span class="o">.</span><span class="n">set_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="o">.</span><span class="n">mmu</span><span class="o">.</span><span class="n">root_hpa</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">static</span> <span class="ne">int</span> <span class="n">mmu_alloc_roots</span><span class="p">(</span><span class="n">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="o">.</span><span class="n">mmu</span><span class="o">.</span><span class="n">direct_map</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">mmu_alloc_direct_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">else</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">mmu_alloc_shadow_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">static</span> <span class="ne">int</span> <span class="n">mmu_alloc_direct_roots</span><span class="p">(</span><span class="n">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">unsigned</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="o">.</span><span class="n">mmu</span><span class="o">.</span><span class="n">shadow_root_level</span> <span class="o">==</span> <span class="n">PT64_ROOT_LEVEL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">make_mmu_pages_available</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">sp</span> <span class="o">=</span> <span class="n">kvm_mmu_get_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PT64_ROOT_LEVEL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ACC_ALL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="o">++</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">root_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="o">.</span><span class="n">mmu</span><span class="o">.</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里构建的是页表的根部，也即顶级页表，并且设置 cr3 来刷新 TLB。mmu_alloc_roots 会调用 mmu_alloc_direct_roots，因为我们用的是 EPT 模式，而非影子表。在 mmu_alloc_direct_roots 中，kvm_mmu_get_page 会分配一个 kvm_mmu_page，来存放顶级页表项。</p>
<p>接下来，当虚拟机真的要访问内存的时候，会发现有的页表没有建立，有的物理页没有分配，这都会触发缺页异常，在 KVM 里面会发送 VM-Exit，从客户机模式转换为宿主机模式，来修复这个缺失的页表或者物理页。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="ne">int</span> <span class="p">(</span><span class="o">*</span><span class="k">const</span> <span class="n">kvm_vmx_exit_handlers</span><span class="p">[])(</span><span class="n">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="n">EXIT_REASON_EXCEPTION_NMI</span><span class="p">]</span>           <span class="o">=</span> <span class="n">handle_exception</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="n">EXIT_REASON_EXTERNAL_INTERRUPT</span><span class="p">]</span>      <span class="o">=</span> <span class="n">handle_external_interrupt</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="n">EXIT_REASON_IO_INSTRUCTION</span><span class="p">]</span>          <span class="o">=</span> <span class="n">handle_io</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="n">EXIT_REASON_EPT_VIOLATION</span><span class="p">]</span>       <span class="o">=</span> <span class="n">handle_ept_violation</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>咱们前面讲过，虚拟机退出客户机模式有很多种原因，例如接收到中断、接收到 I/O 等，EPT 的缺页异常也是一种类型，我们称为 EXIT_REASON_EPT_VIOLATION，对应的处理函数是 handle_ept_violation。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static int handle_ept_violation(struct kvm_vcpu *vcpu)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	gpa_t gpa;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	gpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	vcpu-&gt;arch.gpa_available = true;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	vcpu-&gt;arch.exit_qualification = exit_qualification;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	return kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> int kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gva_t cr2, u64 error_code,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		       void *insn, int insn_len)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	r = vcpu-&gt;arch.mmu.page_fault(vcpu, cr2, lower_32_bits(error_code),false);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 handle_ept_violation 里面，我们从 VMCS 中得到没有解析成功的 GPA，也即客户机的物理地址，然后调用 kvm_mmu_page_fault，看为什么解析不成功。kvm_mmu_page_fault 会调用 page_fault 函数，其实是 tdp_page_fault 函数。tdp 的意思就是 EPT，前面我们解释过了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static int tdp_page_fault(struct kvm_vcpu *vcpu, gva_t gpa, u32 error_code, bool prefault)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	kvm_pfn_t pfn;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int r;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int level;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	bool force_pt_level;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	gfn_t gfn = gpa &gt;&gt; PAGE_SHIFT;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	unsigned long mmu_seq;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int write = error_code &amp; PFERR_WRITE_MASK;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	bool map_writable;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	r = mmu_topup_memory_caches(vcpu);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	level = mapping_level(vcpu, gfn, &amp;force_pt_level);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (try_async_pf(vcpu, prefault, gfn, gpa, &amp;pfn, write, &amp;map_writable))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		return 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	if (handle_abnormal_pfn(vcpu, 0, gfn, pfn, ACC_ALL, &amp;r))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		return r;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	make_mmu_pages_available(vcpu);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	r = __direct_map(vcpu, write, map_writable, level, gfn, pfn, prefault);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>既然没有映射，就应该加上映射，tdp_page_fault 就是干这个事情的。</p>
<p>在 tdp_page_fault 这个函数开头，我们通过 gpa，也即客户机的物理地址得到客户机的页号 gfn。接下来，我们要通过调用 try_async_pf 得到宿主机的物理地址对应的页号，也即真正的物理页的页号，然后通过 __direct_map 将两者关联起来。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn, gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct kvm_memory_slot *slot;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	bool async;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	async = false;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	*pfn = __gfn_to_pfn_memslot(slot, gfn, false, &amp;async, write, writable);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (!async)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		return false; /* *pfn has correct page already */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	if (!prefault &amp;&amp; kvm_can_do_async_pf(vcpu)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (kvm_find_async_pf_gfn(vcpu, gfn)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			kvm_make_request(KVM_REQ_APF_HALT, vcpu);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			return true;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		} else if (kvm_arch_setup_async_pf(vcpu, gva, gfn))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			return true;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	*pfn = __gfn_to_pfn_memslot(slot, gfn, false, NULL, write, writable);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return false;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 try_async_pf 中，要想得到 pfn，也即物理页的页号，会先通过 kvm_vcpu_gfn_to_memslot，根据客户机的物理地址对应的页号找到内存条，然后调用 __gfn_to_pfn_memslot，根据内存条找到 pfn。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kvm_pfn_t __gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn,bool atomic, bool *async, bool write_fault,bool *writable)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	unsigned long addr = __gfn_to_hva_many(slot, gfn, NULL, write_fault);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return hva_to_pfn(addr, atomic, async, write_fault,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			  writable);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 __gfn_to_pfn_memslot 中，我们会调用 __gfn_to_hva_many，从客户机物理地址对应的页号，得到宿主机虚拟地址 hva，然后从宿主机虚拟地址到宿主机物理地址，调用的是 hva_to_pfn。</p>
<p>hva_to_pfn 会调用 hva_to_pfn_slow。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static int hva_to_pfn_slow(unsigned long addr, bool *async, bool write_fault,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			   bool *writable, kvm_pfn_t *pfn)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct page *page[1];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int npages = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (async) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		npages = get_user_page_nowait(addr, write_fault, page);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	} else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		npages = get_user_pages_unlocked(addr, 1, page, flags);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	*pfn = page_to_pfn(page[0]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return npages;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 hva_to_pfn_slow 中，我们要先调用 get_user_page_nowait，得到一个物理页面，然后再调用 page_to_pfn 将物理页面转换成为物理页号。</p>
<p>无论是哪一种 get_user_pages_XXX，最终都会调用 __get_user_pages 函数。这里面会调用 faultin_page，在 faultin_page 中我们会调用 handle_mm_fault。看到这个是不是很熟悉？这就是咱们内存管理那一章讲的缺页异常的逻辑，分配一个物理内存。</p>
<p>至此，try_async_pf 得到了物理页面，并且转换为对应的物理页号。</p>
<p>接下来，__direct_map 会关联客户机物理页号和宿主机物理页号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static int __direct_map(struct kvm_vcpu *vcpu, int write, int map_writable,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			int level, gfn_t gfn, kvm_pfn_t pfn, bool prefault)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct kvm_shadow_walk_iterator iterator;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct kvm_mmu_page *sp;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int emulate = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	gfn_t pseudo_gfn;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	if (!VALID_PAGE(vcpu-&gt;arch.mmu.root_hpa))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		return 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	for_each_shadow_entry(vcpu, (u64)gfn &lt;&lt; PAGE_SHIFT, iterator) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (iterator.level == level) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			emulate = mmu_set_spte(vcpu, iterator.sptep, ACC_ALL,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">					       write, level, gfn, pfn, prefault,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">					       map_writable);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			direct_pte_prefetch(vcpu, iterator.sptep);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			++vcpu-&gt;stat.pf_fixed;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			break;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 		drop_large_spte(vcpu, iterator.sptep);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (!is_shadow_present_pte(*iterator.sptep)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			u64 base_addr = iterator.addr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 			base_addr &amp;= PT64_LVL_ADDR_MASK(iterator.level);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			pseudo_gfn = base_addr &gt;&gt; PAGE_SHIFT;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			sp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">					      iterator.level - 1, 1, ACC_ALL);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 			link_shadow_page(vcpu, iterator.sptep, sp);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return emulate;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>__direct_map 首先判断页表的根是否存在，当然存在，我们刚才初始化了。</p>
<p>接下来是 for_each_shadow_entry 一个循环。每一个循环中，先是会判断需要映射的 level，是否正是当前循环的这个 iterator.level。如果是，则说明是叶子节点，直接映射真正的物理页面 pfn，然后退出。接着是非叶子节点的情形，判断如果这一项指向的页表项不存在，就要建立页表项，通过 kvm_mmu_get_page 得到保存页表项的页面，然后将这一项指向下一级的页表页面。</p>
<p>至此，内存映射就结束了。</p>
<h2 id="总结时刻">总结时刻</h2>
<p>我们这里来总结一下，虚拟机的内存管理也是需要用户态的 qemu 和内核态的 KVM 共同完成。为了加速内存映射，需要借助硬件的 EPT 技术。</p>
<p>在用户态 qemu 中，有一个结构 AddressSpace address_space_memory 来表示虚拟机的系统内存，这个内存可能包含多个内存区域 struct MemoryRegion，组成树形结构，指向由 mmap 分配的虚拟内存。</p>
<p>在 AddressSpace 结构中，有一个 struct KVMMemoryListener，当有新的内存区域添加的时候，会被通知调用 kvm_region_add 来通知内核。</p>
<p>在用户态 qemu 中，对于虚拟机有一个结构 struct KVMState 表示这个虚拟机，这个结构会指向一个数组的 struct KVMSlot 表示这个虚拟机的多个内存条，KVMSlot 中有一个 void *ram 指针指向 mmap 分配的那块虚拟内存。</p>
<p>kvm_region_add 是通过 ioctl 来通知内核 KVM 的，会给内核 KVM 发送一个 KVM_SET_USER_MEMORY_REGION 消息，表示用户态 qemu 添加了一个内存区域，内核 KVM 也应该添加一个相应的内存区域。</p>
<p>和用户态 qemu 对应的内核 KVM，对于虚拟机有一个结构 struct kvm 表示这个虚拟机，这个结构会指向一个数组的 struct kvm_memory_slot 表示这个虚拟机的多个内存条，kvm_memory_slot 中有起始页号，页面数目，表示这个虚拟机的物理内存空间。</p>
<p>虚拟机的物理内存空间里面的页面当然不是一开始就映射到物理页面的，只有当虚拟机的内存被访问的时候，也即 mmap 分配的虚拟内存空间被访问的时候，先查看 EPT 页表，是否已经映射过，如果已经映射过，则经过四级页表映射，就能访问到物理页面。</p>
<p>如果没有映射过，则虚拟机会通过 VM-Exit 指令回到宿主机模式，通过 handle_ept_violation 补充页表映射。先是通过 handle_mm_fault 为虚拟机的物理内存空间分配真正的物理页面，然后通过 __direct_map 添加 EPT 页表映射。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/a663c60d4dc5ba1fa56761dafa5332fb.png" alt=""></p>
<h2 id="课堂练习">课堂练习</h2>
<p>这一节，影子页表我们没有深入去讲，你能自己研究一下，它是如何实现的吗？</p>
<p>欢迎留言和我分享你的疑惑和见解，也欢迎收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1a5564dd4e1c9f25d4772c7f844ca84a.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">趣谈Linux操作系统</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/52__%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">52__管理设计篇之“分布式锁”</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/52__%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%90%88%E7%90%86%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%B2%92%E5%BA%A6%E4%BB%A5%E5%85%BC%E9%A1%BE%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%98%93%E7%94%A8%E6%80%A7%E5%92%8C%E9%80%9A%E7%94%A8%E6%80%A7/">
            <span class="next-text nav-default">52__门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
