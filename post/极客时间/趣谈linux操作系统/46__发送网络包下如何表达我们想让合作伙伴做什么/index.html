<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>46__发送网络包（下）：如何表达我们想让合作伙伴做什么？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="上一节我们讲网络包的发送，讲了上半部分，也即从 VFS 层一直到 IP 层，这一节我们接着看下去，看 IP 层和 MAC 层是如何发送数据的。
解析 ip_queue_xmit 函数 从 ip_queue_xmit 函数开始，我们就要进入 IP 层的发送逻辑了。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/46__%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E5%8C%85%E4%B8%8B%E5%A6%82%E4%BD%95%E8%A1%A8%E8%BE%BE%E6%88%91%E4%BB%AC%E6%83%B3%E8%AE%A9%E5%90%88%E4%BD%9C%E4%BC%99%E4%BC%B4%E5%81%9A%E4%BB%80%E4%B9%88/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/46__%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E5%8C%85%E4%B8%8B%E5%A6%82%E4%BD%95%E8%A1%A8%E8%BE%BE%E6%88%91%E4%BB%AC%E6%83%B3%E8%AE%A9%E5%90%88%E4%BD%9C%E4%BC%99%E4%BC%B4%E5%81%9A%E4%BB%80%E4%B9%88/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="46__发送网络包（下）：如何表达我们想让合作伙伴做什么？">
  <meta property="og:description" content="上一节我们讲网络包的发送，讲了上半部分，也即从 VFS 层一直到 IP 层，这一节我们接着看下去，看 IP 层和 MAC 层是如何发送数据的。
解析 ip_queue_xmit 函数 从 ip_queue_xmit 函数开始，我们就要进入 IP 层的发送逻辑了。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="趣谈Linux操作系统">

  <meta itemprop="name" content="46__发送网络包（下）：如何表达我们想让合作伙伴做什么？">
  <meta itemprop="description" content="上一节我们讲网络包的发送，讲了上半部分，也即从 VFS 层一直到 IP 层，这一节我们接着看下去，看 IP 层和 MAC 层是如何发送数据的。
解析 ip_queue_xmit 函数 从 ip_queue_xmit 函数开始，我们就要进入 IP 层的发送逻辑了。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7913">
  <meta itemprop="keywords" content="趣谈Linux操作系统">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="46__发送网络包（下）：如何表达我们想让合作伙伴做什么？">
  <meta name="twitter:description" content="上一节我们讲网络包的发送，讲了上半部分，也即从 VFS 层一直到 IP 层，这一节我们接着看下去，看 IP 层和 MAC 层是如何发送数据的。
解析 ip_queue_xmit 函数 从 ip_queue_xmit 函数开始，我们就要进入 IP 层的发送逻辑了。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">46__发送网络包（下）：如何表达我们想让合作伙伴做什么？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7913 字 </span>
          <span class="more-meta"> 预计阅读 16 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#解析-ip_queue_xmit-函数">解析 ip_queue_xmit 函数</a></li>
        <li><a href="#解析-ip_finish_output-函数">解析 ip_finish_output 函数</a></li>
        <li><a href="#总结时刻">总结时刻</a></li>
        <li><a href="#课堂练习">课堂练习</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>上一节我们讲网络包的发送，讲了上半部分，也即从 VFS 层一直到 IP 层，这一节我们接着看下去，看 IP 层和 MAC 层是如何发送数据的。</p>
<h2 id="解析-ip_queue_xmit-函数">解析 ip_queue_xmit 函数</h2>
<p>从 ip_queue_xmit 函数开始，我们就要进入 IP 层的发送逻辑了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int ip_queue_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct inet_sock *inet = inet_sk(sk);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct net *net = sock_net(sk);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct ip_options_rcu *inet_opt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct flowi4 *fl4;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct rtable *rt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct iphdr *iph;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int res;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     inet_opt = rcu_dereference(inet-&gt;inet_opt);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    fl4 = &amp;fl-&gt;u.ip4;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    rt = skb_rtable(skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* Make sure we can route this packet. */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    rt = (struct rtable *)__sk_dst_check(sk, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (!rt) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        __be32 daddr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        /* Use correct destination address if we have options. */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        daddr = inet-&gt;inet_daddr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> ......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        rt = ip_route_output_ports(net, fl4, sk,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                       daddr, inet-&gt;inet_saddr,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                       inet-&gt;inet_dport,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                       inet-&gt;inet_sport,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                       sk-&gt;sk_protocol,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                       RT_CONN_FLAGS(sk),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                       sk-&gt;sk_bound_dev_if);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (IS_ERR(rt))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            goto no_route;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        sk_setup_caps(sk, &amp;rt-&gt;dst);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    skb_dst_set_noref(skb, &amp;rt-&gt;dst);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> packet_routed:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* OK, we know where to send it, allocate and build IP header. */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    skb_push(skb, sizeof(struct iphdr) + (inet_opt ? inet_opt-&gt;opt.optlen : 0));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    skb_reset_network_header(skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    iph = ip_hdr(skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    *((__be16 *)iph) = htons((4 &lt;&lt; 12) | (5 &lt;&lt; 8) | (inet-&gt;tos &amp; 0xff));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (ip_dont_fragment(sk, &amp;rt-&gt;dst) &amp;&amp; !skb-&gt;ignore_df)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        iph-&gt;frag_off = htons(IP_DF);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        iph-&gt;frag_off = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    iph-&gt;ttl      = ip_select_ttl(inet, &amp;rt-&gt;dst);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    iph-&gt;protocol = sk-&gt;sk_protocol;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ip_copy_addrs(iph, fl4);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     /* Transport layer set skb-&gt;h.foo itself. */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     if (inet_opt &amp;&amp; inet_opt-&gt;opt.optlen) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        iph-&gt;ihl += inet_opt-&gt;opt.optlen &gt;&gt; 2;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ip_options_build(skb, &amp;inet_opt-&gt;opt, inet-&gt;inet_daddr, rt, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     ip_select_ident_segs(net, skb, sk,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                 skb_shinfo(skb)-&gt;gso_segs ?: 1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     /* TODO : should we use skb-&gt;sk here instead of sk ? */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    skb-&gt;priority = sk-&gt;sk_priority;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    skb-&gt;mark = sk-&gt;sk_mark;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     res = ip_local_out(net, sk, skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 ip_queue_xmit 中，也即 IP 层的发送函数里面，有三部分逻辑。</p>
<p>第一部分，选取路由，也即我要发送这个包应该从哪个网卡出去。</p>
<p>这件事情主要由 ip_route_output_ports 函数完成。接下来的调用链为：ip_route_output_ports-&gt;ip_route_output_flow-&gt;__ip_route_output_key-&gt;ip_route_output_key_hash-&gt;ip_route_output_key_hash_rcu。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">ip_route_output_key_hash_rcu</span><span class="p">(</span><span class="n">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">struct</span> <span class="n">flowi4</span> <span class="o">*</span><span class="n">fl4</span><span class="p">,</span> <span class="n">struct</span> <span class="n">fib_result</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="k">const</span> <span class="n">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev_out</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="ne">int</span> <span class="n">orig_oif</span> <span class="o">=</span> <span class="n">fl4</span><span class="o">-&gt;</span><span class="n">flowi4_oif</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">unsigned</span> <span class="ne">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">err</span> <span class="o">=</span> <span class="n">fib_lookup</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">fl4</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">make_route</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">rth</span> <span class="o">=</span> <span class="n">__mkroute_output</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">fl4</span><span class="p">,</span> <span class="n">orig_oif</span><span class="p">,</span> <span class="n">dev_out</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>ip_route_output_key_hash_rcu 先会调用 fib_lookup。</p>
<p><strong>FIB</strong>全称是 Forwarding Information Base，**转发信息表。**其实就是咱们常说的路由表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">inline</span> <span class="ne">int</span> <span class="n">fib_lookup</span><span class="p">(</span><span class="n">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="n">struct</span> <span class="n">flowi4</span> <span class="o">*</span><span class="n">flp</span><span class="p">,</span> <span class="n">struct</span> <span class="n">fib_result</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="n">unsigned</span> <span class="ne">int</span> <span class="n">flags</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>	<span class="n">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">tb</span> <span class="o">=</span> <span class="n">fib_get_table</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">RT_TABLE_MAIN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">err</span> <span class="o">=</span> <span class="n">fib_table_lookup</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">flp</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">FIB_LOOKUP_NOREF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>路由表可以有多个，一般会有一个主表，RT_TABLE_MAIN。然后 fib_table_lookup 函数在这个表里面进行查找。</p>
<p>路由表是一个什么样的结构呢？</p>
<p>路由就是在 Linux 服务器上的路由表里面配置的一条一条规则。这些规则大概是这样的：想访问某个网段，从某个网卡出去，下一跳是某个 IP。</p>
<p>之前我们讲过一个简单的拓扑图，里面的三台 Linux 机器的路由表都可以通过 ip route 命令查看。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/d459fc4ad82615125d84e33da6bddca9.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Linux 服务器 A
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">default via 192.168.1.1 dev eth0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.100 metric 100
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> # Linux 服务器 B
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">default via 192.168.2.1 dev eth0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">192.168.2.0/24 dev eth0 proto kernel scope link src 192.168.2.100 metric 100
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> # Linux 服务器做路由器
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.1  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">192.168.2.0/24 dev eth1 proto kernel scope link src 192.168.2.1  
</span></span></code></pre></td></tr></table>
</div>
</div><p>其实，对于两端的服务器来讲，我们没有太多路由可以选，但是对于中间的 Linux 服务器做路由器来讲，这里有两条路可以选，一个是往左面转发，一个是往右面转发，就需要路由表的查找。</p>
<p>fib_table_lookup 的代码逻辑比较复杂，好在注释比较清楚。因为路由表要按照前缀进行查询，希望找到最长匹配的那一个，例如 192.168.2.0/24 和 192.168.0.0/16 都能匹配 192.168.2.100/24。但是，我们应该使用 192.168.2.0/24 的这一条。</p>
<p>为了更方面的做这个事情，我们使用了 Trie 树这种结构。比如我们有一系列的字符串：{bcs#, badge#, baby#, back#, badger#, badness#}。之所以每个字符串都加上 #，是希望不要一个字符串成为另外一个字符串的前缀。然后我们把它们放在 Trie 树中，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/597bbb9c2f6c17f885cba2e53d98521f.png" alt=""></p>
<p>对于将 IP 地址转成二进制放入 trie 树，也是同样的道理，可以很快进行路由的查询。</p>
<p>找到了路由，就知道了应该从哪个网卡发出去。</p>
<p>然后，ip_route_output_key_hash_rcu 会调用 __mkroute_output，创建一个 struct rtable，表示找到的路由表项。这个结构是由 rt_dst_alloc 函数分配的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct rtable *rt_dst_alloc(struct net_device *dev,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			    unsigned int flags, u16 type,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			    bool nopolicy, bool noxfrm, bool will_cache)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct rtable *rt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	rt = dst_alloc(&amp;ipv4_dst_ops, dev, 1, DST_OBSOLETE_FORCE_CHK,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		       (will_cache ? 0 : DST_HOST) |
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		       (nopolicy ? DST_NOPOLICY : 0) |
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		       (noxfrm ? DST_NOXFRM : 0));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	if (rt) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		rt-&gt;rt_genid = rt_genid_ipv4(dev_net(dev));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		rt-&gt;rt_flags = flags;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		rt-&gt;rt_type = type;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		rt-&gt;rt_is_input = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		rt-&gt;rt_iif = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		rt-&gt;rt_pmtu = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		rt-&gt;rt_gateway = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		rt-&gt;rt_uses_gateway = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		rt-&gt;rt_table_id = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		INIT_LIST_HEAD(&amp;rt-&gt;rt_uncached);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 		rt-&gt;dst.output = ip_output;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (flags &amp; RTCF_LOCAL)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			rt-&gt;dst.input = ip_local_deliver;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	return rt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>最终返回 struct rtable 实例，第一部分也就完成了。</p>
<p>第二部分，就是准备 IP 层的头，往里面填充内容。这就要对着 IP 层的头的格式进行理解。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7fa0c2e86bfbad44574ff2a4055d48ae.png" alt=""></p>
<p>在这里面，服务类型设置为 tos，标识位里面设置是否允许分片 frag_off。如果不允许，而遇到 MTU 太小过不去的情况，就发送 ICMP 报错。TTL 是这个包的存活时间，为了防止一个 IP 包迷路以后一直存活下去，每经过一个路由器 TTL 都减一，减为零则“死去”。设置 protocol，指的是更上层的协议，这里是 TCP。源地址和目标地址由 ip_copy_addrs 设置。最后，设置 options。</p>
<p>第三部分，就是调用 ip_local_out 发送 IP 包。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int ip_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int err;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	err = __ip_local_out(net, sk, skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (likely(err == 1))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		err = dst_output(net, sk, skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	return err;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> int __ip_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct iphdr *iph = ip_hdr(skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	iph-&gt;tot_len = htons(skb-&gt;len);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	skb-&gt;protocol = htons(ETH_P_IP);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	return nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		       net, sk, skb, NULL, skb_dst(skb)-&gt;dev,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		       dst_output);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>ip_local_out 先是调用 __ip_local_out，然后里面调用了 nf_hook。这是什么呢？nf 的意思是 Netfilter，这是 Linux 内核的一个机制，用于在网络发送和转发的关键节点上加上 hook 函数，这些函数可以截获数据包，对数据包进行干预。</p>
<p>一个著名的实现，就是内核模块 ip_tables。在用户态，还有一个客户端程序 iptables，用命令行来干预内核的规则。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9580de0e1667e75a5994feb8573c6142.png" alt=""></p>
<p>iptables 有表和链的概念，最终要的是两个表。</p>
<p>filter 表处理过滤功能，主要包含以下三个链。</p>
<ul>
<li>INPUT 链：过滤所有目标地址是本机的数据包</li>
<li>FORWARD 链：过滤所有路过本机的数据包</li>
<li>OUTPUT 链：过滤所有由本机产生的数据包</li>
</ul>
<p>nat 表主要处理网络地址转换，可以进行 SNAT（改变源地址）、DNAT（改变目标地址），包含以下三个链。</p>
<ul>
<li>PREROUTING 链：可以在数据包到达时改变目标地址</li>
<li>OUTPUT 链：可以改变本地产生的数据包的目标地址</li>
<li>POSTROUTING 链：在数据包离开时改变数据包的源地址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/31c698fceff76c367bb425d106c4d737.png" alt=""></p>
<p>在这里，网络包马上就要发出去了，因而是 NF_INET_LOCAL_OUT，也即 ouput 链，如果用户曾经在 iptables 里面写过某些规则，就会在 nf_hook 这个函数里面起作用。</p>
<p>ip_local_out 再调用 dst_output，就是真正的发送数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/* Output packet to network from transport.  */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static inline int dst_output(struct net *net, struct sock *sk, struct sk_buff *skb)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return skb_dst(skb)-&gt;output(net, sk, skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里调用的就是 struct rtable 成员 dst 的 ouput 函数。在 rt_dst_alloc 中，我们可以看到，output 函数指向的是 ip_output。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int ip_output(struct net *net, struct sock *sk, struct sk_buff *skb)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct net_device *dev = skb_dst(skb)-&gt;dev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	skb-&gt;dev = dev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	skb-&gt;protocol = htons(ETH_P_IP);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	return NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			    net, sk, skb, NULL, dev,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			    ip_finish_output,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			    !(IPCB(skb)-&gt;flags &amp; IPSKB_REROUTED));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 ip_output 里面，我们又看到了熟悉的 NF_HOOK。这一次是 NF_INET_POST_ROUTING，也即 POSTROUTING 链，处理完之后，调用 ip_finish_output。</p>
<h2 id="解析-ip_finish_output-函数">解析 ip_finish_output 函数</h2>
<p>从 ip_finish_output 函数开始，发送网络包的逻辑由第三层到达第二层。ip_finish_output 最终调用 ip_finish_output2。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static int ip_finish_output2(struct net *net, struct sock *sk, struct sk_buff *skb)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct dst_entry *dst = skb_dst(skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct rtable *rt = (struct rtable *)dst;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct net_device *dev = dst-&gt;dev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	unsigned int hh_len = LL_RESERVED_SPACE(dev);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct neighbour *neigh;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	u32 nexthop;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	nexthop = (__force u32) rt_nexthop(rt, ip_hdr(skb)-&gt;daddr);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	neigh = __ipv4_neigh_lookup_noref(dev, nexthop);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (unlikely(!neigh))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		neigh = __neigh_create(&amp;arp_tbl, &amp;nexthop, dev, false);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (!IS_ERR(neigh)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		int res;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		sock_confirm_neigh(skb, neigh);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		res = neigh_output(neigh, skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		return res;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 ip_finish_output2 中，先找到 struct rtable 路由表里面的下一跳，下一跳一定和本机在同一个局域网中，可以通过二层进行通信，因而通过 __ipv4_neigh_lookup_noref，查找如何通过二层访问下一跳。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static inline struct neighbour *__ipv4_neigh_lookup_noref(struct net_device *dev, u32 key)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return ___neigh_lookup_noref(&amp;arp_tbl, neigh_key_eq32, arp_hashfn, &amp;key, dev);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>__ipv4_neigh_lookup_noref 是从本地的 ARP 表中查找下一跳的 MAC 地址。ARP 表的定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">neigh_table</span> <span class="n">arp_tbl</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">family</span>     <span class="o">=</span> <span class="n">AF_INET</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">key_len</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">protocol</span>   <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">hash</span>       <span class="o">=</span> <span class="n">arp_hash</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">key_eq</span>     <span class="o">=</span> <span class="n">arp_key_eq</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">constructor</span>    <span class="o">=</span> <span class="n">arp_constructor</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">proxy_redo</span> <span class="o">=</span> <span class="n">parp_redo</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">id</span>     <span class="o">=</span> <span class="s2">&#34;arp_cache&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">gc_interval</span>    <span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">gc_thresh1</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">gc_thresh2</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">gc_thresh3</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果在 ARP 表中没有找到相应的项，则调用 __neigh_create 进行创建。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">__neigh_create</span><span class="p">(</span><span class="n">struct</span> <span class="n">neigh_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span> <span class="k">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">pkey</span><span class="p">,</span> <span class="n">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="ne">bool</span> <span class="n">want_ref</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">u32</span> <span class="n">hash_val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">key_len</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">key_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">n1</span><span class="p">,</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">neigh_alloc</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">struct</span> <span class="n">neigh_hash_table</span> <span class="o">*</span><span class="n">nht</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">memcpy</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">primary_key</span><span class="p">,</span> <span class="n">pkey</span><span class="p">,</span> <span class="n">key_len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">n</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">dev_hold</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="o">/*</span> <span class="n">Protocol</span> <span class="n">specific</span> <span class="n">setup</span><span class="o">.</span> <span class="o">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">constructor</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">constructor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">nht</span><span class="o">-&gt;</span><span class="n">hash_shift</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">nht</span> <span class="o">=</span> <span class="n">neigh_hash_grow</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">nht</span><span class="o">-&gt;</span><span class="n">hash_shift</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">hash_val</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="nb">hash</span><span class="p">(</span><span class="n">pkey</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">nht</span><span class="o">-&gt;</span><span class="n">hash_rnd</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">nht</span><span class="o">-&gt;</span><span class="n">hash_shift</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="k">for</span> <span class="p">(</span><span class="n">n1</span> <span class="o">=</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">nht</span><span class="o">-&gt;</span><span class="n">hash_buckets</span><span class="p">[</span><span class="n">hash_val</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         <span class="n">n1</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         <span class="n">n1</span> <span class="o">=</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">n1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="n">n1</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">n1</span><span class="o">-&gt;</span><span class="n">primary_key</span><span class="p">,</span> <span class="n">pkey</span><span class="p">,</span> <span class="n">key_len</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">want_ref</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="n">neigh_hold</span><span class="p">(</span><span class="n">n1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">rc</span> <span class="o">=</span> <span class="n">n1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">goto</span> <span class="n">out_tbl_unlock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">               <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">nht</span><span class="o">-&gt;</span><span class="n">hash_buckets</span><span class="p">[</span><span class="n">hash_val</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                             <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">nht</span><span class="o">-&gt;</span><span class="n">hash_buckets</span><span class="p">[</span><span class="n">hash_val</span><span class="p">],</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>__neigh_create 先调用 neigh_alloc，创建一个 struct neighbour 结构，用于维护 MAC 地址和 ARP 相关的信息。这个名字也很好理解，大家都是在一个局域网里面，可以通过 MAC 地址访问到，当然是邻居了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static struct neighbour *neigh_alloc(struct neigh_table *tbl, struct net_device *dev)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	struct neighbour *n = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	unsigned long now = jiffies;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int entries;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	n = kzalloc(tbl-&gt;entry_size + dev-&gt;neigh_priv_len, GFP_ATOMIC);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (!n)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		goto out_entries;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	__skb_queue_head_init(&amp;n-&gt;arp_queue);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	rwlock_init(&amp;n-&gt;lock);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	seqlock_init(&amp;n-&gt;ha_lock);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	n-&gt;updated	  = n-&gt;used = now;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	n-&gt;nud_state	  = NUD_NONE;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	n-&gt;output	  = neigh_blackhole;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	seqlock_init(&amp;n-&gt;hh.hh_lock);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	n-&gt;parms	  = neigh_parms_clone(&amp;tbl-&gt;parms);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	setup_timer(&amp;n-&gt;timer, neigh_timer_handler, (unsigned long)n);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	NEIGH_CACHE_STAT_INC(tbl, allocs);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	n-&gt;tbl		  = tbl;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	refcount_set(&amp;n-&gt;refcnt, 1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	n-&gt;dead		  = 1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 neigh_alloc 中，我们先分配一个 struct neighbour 结构并且初始化。这里面比较重要的有两个成员，一个是 arp_queue，所以上层想通过 ARP 获取 MAC 地址的任务，都放在这个队列里面。另一个是 timer 定时器，我们设置成，过一段时间就调用 neigh_timer_handler，来处理这些 ARP 任务。</p>
<p>__neigh_create 然后调用了 arp_tbl 的 constructor 函数，也即调用了 arp_constructor，在这里面定义了 ARP 的操作 arp_hh_ops。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="ne">int</span> <span class="n">arp_constructor</span><span class="p">(</span><span class="n">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">__be32</span> <span class="n">addr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">primary_key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">in_dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">neigh_parms</span> <span class="o">*</span><span class="n">parms</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">inet_addr_type_dev_table</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	<span class="n">parms</span> <span class="o">=</span> <span class="n">in_dev</span><span class="o">-&gt;</span><span class="n">arp_parms</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">__neigh_parms_put</span><span class="p">(</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">parms</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">parms</span> <span class="o">=</span> <span class="n">neigh_parms_clone</span><span class="p">(</span><span class="n">parms</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arp_hh_ops</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">output</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">static</span> <span class="k">const</span> <span class="n">struct</span> <span class="n">neigh_ops</span> <span class="n">arp_hh_ops</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">family</span> <span class="o">=</span>		<span class="n">AF_INET</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">solicit</span> <span class="o">=</span>		<span class="n">arp_solicit</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">error_report</span> <span class="o">=</span>		<span class="n">arp_error_report</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">output</span> <span class="o">=</span>		<span class="n">neigh_resolve_output</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="n">connected_output</span> <span class="o">=</span>	<span class="n">neigh_resolve_output</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>__neigh_create 最后是将创建的 struct neighbour 结构放入一个哈希表，从里面的代码逻辑比较容易看出，这是一个数组加链表的链式哈希表，先计算出哈希值 hash_val，得到相应的链表，然后循环这个链表找到对应的项，如果找不到就在最后插入一项。</p>
<p>我们回到 ip_finish_output2，在 __neigh_create 之后，会调用 neigh_output 发送网络包。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static inline int neigh_output(struct neighbour *n, struct sk_buff *skb)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return n-&gt;output(n, skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>按照上面对于 struct neighbour 的操作函数 arp_hh_ops 的定义，output 调用的是 neigh_resolve_output。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int neigh_resolve_output(struct neighbour *neigh, struct sk_buff *skb)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (!neigh_event_send(neigh, skb)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		rc = dev_queue_xmit(skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 neigh_resolve_output 里面，首先 neigh_event_send 触发一个事件，看能否激活 ARP。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int __neigh_event_send(struct neighbour *neigh, struct sk_buff *skb)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int rc;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	bool immediate_probe = false;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	if (!(neigh-&gt;nud_state &amp; (NUD_STALE | NUD_INCOMPLETE))) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (NEIGH_VAR(neigh-&gt;parms, MCAST_PROBES) +
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		    NEIGH_VAR(neigh-&gt;parms, APP_PROBES)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			unsigned long next, now = jiffies;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 			atomic_set(&amp;neigh-&gt;probes,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				   NEIGH_VAR(neigh-&gt;parms, UCAST_PROBES));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			neigh-&gt;nud_state     = NUD_INCOMPLETE;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			neigh-&gt;updated = now;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			next = now + max(NEIGH_VAR(neigh-&gt;parms, RETRANS_TIME),
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">					 HZ/2);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			neigh_add_timer(neigh, next);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			immediate_probe = true;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		} 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	} else if (neigh-&gt;nud_state &amp; NUD_STALE) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		neigh_dbg(2, &#34;neigh %p is delayed\n&#34;, neigh);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		neigh-&gt;nud_state = NUD_DELAY;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		neigh-&gt;updated = jiffies;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		neigh_add_timer(neigh, jiffies +
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				NEIGH_VAR(neigh-&gt;parms, DELAY_PROBE_TIME));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	if (neigh-&gt;nud_state == NUD_INCOMPLETE) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if (skb) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">.......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			__skb_queue_tail(&amp;neigh-&gt;arp_queue, skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			neigh-&gt;arp_queue_len_Bytes += skb-&gt;truesize;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		rc = 1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">out_unlock_bh:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if (immediate_probe)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		neigh_probe(neigh);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">.......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 __neigh_event_send 中，激活 ARP 分两种情况，第一种情况是马上激活，也即 immediate_probe。另一种情况是延迟激活则仅仅设置一个 timer。然后将 ARP 包放在 arp_queue 上。如果马上激活，就直接调用 neigh_probe；如果延迟激活，则定时器到了就会触发 neigh_timer_handler，在这里面还是会调用 neigh_probe。</p>
<p>我们就来看 neigh_probe 的实现，在这里面会从 arp_queue 中拿出 ARP 包来，然后调用 struct neighbour 的 solicit 操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static void neigh_probe(struct neighbour *neigh)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        __releases(neigh-&gt;lock)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        struct sk_buff *skb = skb_peek_tail(&amp;neigh-&gt;arp_queue);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (neigh-&gt;ops-&gt;solicit)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                neigh-&gt;ops-&gt;solicit(neigh, skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>按照上面对于 struct neighbour 的操作函数 arp_hh_ops 的定义，solicit 调用的是 arp_solicit，在这里我们可以找到对于 arp_send_dst 的调用，创建并发送一个 arp 包，得到结果放在 struct dst_entry 里面。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">void</span> <span class="n">arp_send_dst</span><span class="p">(</span><span class="ne">int</span> <span class="n">type</span><span class="p">,</span> <span class="ne">int</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">dest_ip</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                         <span class="n">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">src_ip</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                         <span class="k">const</span> <span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="n">dest_hw</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                         <span class="k">const</span> <span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="n">src_hw</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                         <span class="k">const</span> <span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="n">target_hw</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                         <span class="n">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">skb</span> <span class="o">=</span> <span class="n">arp_create</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">dest_ip</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">src_ip</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                         <span class="n">dest_hw</span><span class="p">,</span> <span class="n">src_hw</span><span class="p">,</span> <span class="n">target_hw</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">skb_dst_set</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dst_clone</span><span class="p">(</span><span class="n">dst</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">arp_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们回到 neigh_resolve_output 中，当 ARP 发送完毕，就可以调用 dev_queue_xmit 发送二层网络包了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">/**</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span>	<span class="n">__dev_queue_xmit</span> <span class="o">-</span> <span class="n">transmit</span> <span class="n">a</span> <span class="n">buffer</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span>	<span class="err">@</span><span class="n">skb</span><span class="p">:</span> <span class="n">buffer</span> <span class="n">to</span> <span class="n">transmit</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span>	<span class="err">@</span><span class="n">accel_priv</span><span class="p">:</span> <span class="n">private</span> <span class="n">data</span> <span class="n">used</span> <span class="k">for</span> <span class="n">L2</span> <span class="n">forwarding</span> <span class="n">offload</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*</span>	<span class="n">Queue</span> <span class="n">a</span> <span class="n">buffer</span> <span class="k">for</span> <span class="n">transmission</span> <span class="n">to</span> <span class="n">a</span> <span class="n">network</span> <span class="n">device</span><span class="o">.</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="o">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="ne">int</span> <span class="n">__dev_queue_xmit</span><span class="p">(</span><span class="n">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">accel_priv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_pick_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">accel_priv</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">q</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">qdisc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">rc</span> <span class="o">=</span> <span class="n">__dev_xmit_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>就像咱们在讲述硬盘块设备的时候讲过，每个块设备都有队列，用于将内核的数据放到队列里面，然后设备驱动从队列里面取出后，将数据根据具体设备的特性发送给设备。</p>
<p>网络设备也是类似的，对于发送来说，有一个发送队列 struct netdev_queue *txq。</p>
<p>这里还有另一个变量叫做 struct Qdisc，这个是什么呢？如果我们在一台 Linux 机器上运行 ip addr，我们能看到对于一个网卡，都有下面的输出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># ip addr
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    inet 127.0.0.1/8 scope host lo
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       valid_lft forever preferred_lft forever
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    inet6 ::1/128 scope host 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       valid_lft forever preferred_lft forever
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1400 qdisc pfifo_fast state UP group default qlen 1000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    link/ether fa:16:3e:75:99:08 brd ff:ff:ff:ff:ff:ff
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    inet 10.173.32.47/21 brd 10.173.39.255 scope global noprefixroute dynamic eth0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       valid_lft 67104sec preferred_lft 67104sec
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    inet6 fe80::f816:3eff:fe75:9908/64 scope link 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       valid_lft forever preferred_lft forever
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里面有个关键字 qdisc pfifo_fast 是什么意思呢？qdisc 全称是 queueing discipline，中文叫排队规则。内核如果需要通过某个网络接口发送数据包，都需要按照为这个接口配置的 qdisc（排队规则）把数据包加入队列。</p>
<p>最简单的 qdisc 是 pfifo，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。pfifo_fast 稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则。</p>
<p>三个波段的优先级也不相同。band 0 的优先级最高，band 2 的最低。如果 band 0 里面有数据包，系统就不会处理 band 1 里面的数据包，band 1 和 band 2 之间也是一样。</p>
<p>数据包是按照服务类型（Type of Service，TOS）被分配到三个波段里面的。TOS 是 IP 头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的。</p>
<p>pfifo_fast 分为三个先入先出的队列，我们能称为三个 Band。根据网络包里面的 TOS，看这个包到底应该进入哪个队列。TOS 总共四位，每一位表示的意思不同，总共十六种类型。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/d7d8d33a08390884ee6095d69a90df80.png" alt=""></p>
<p>通过命令行 tc qdisc show dev eth0，我们可以输出结果 priomap，也是十六个数字。在 0 到 2 之间，和 TOS 的十六种类型对应起来。不同的 TOS 对应不同的队列。其中 Band 0 优先级最高，发送完毕后才轮到 Band 1 发送，最后才是 Band 2。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># tc qdisc show dev eth0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">qdisc pfifo_fast 0: root refcnt 2 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，__dev_xmit_skb 开始进行网络包发送。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static inline int __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                 struct net_device *dev,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                 struct netdev_queue *txq)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    rc = q-&gt;enqueue(skb, q, &amp;to_free) &amp; NET_XMIT_MASK;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (qdisc_run_begin(q)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        __qdisc_run(q);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> void __qdisc_run(struct Qdisc *q)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int quota = dev_tx_weight;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int packets;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     while (qdisc_restart(q, &amp;packets)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        /*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         * Ordered by possible occurrence: Postpone processing if
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         * 1. we&#39;ve exceeded packet quota
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         * 2. another process needs the CPU;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        quota -= packets;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (quota &lt;= 0 || need_resched()) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            __netif_schedule(q);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     qdisc_run_end(q);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>__dev_xmit_skb 会将请求放入队列，然后调用 __qdisc_run 处理队列中的数据。qdisc_restart 用于数据的发送。根据注释中的说法，qdisc 的另一个功能是用于控制网络包的发送速度，因而如果超过速度，就需要重新调度，则会调用 __netif_schedule。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static void __netif_reschedule(struct Qdisc *q)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct softnet_data *sd;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    unsigned long flags;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    local_irq_save(flags);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    sd = this_cpu_ptr(&amp;softnet_data);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    q-&gt;next_sched = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    *sd-&gt;output_queue_tailp = q;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    sd-&gt;output_queue_tailp = &amp;q-&gt;next_sched;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    raise_softirq_irqoff(NET_TX_SOFTIRQ);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    local_irq_restore(flags);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>__netif_schedule 会调用 __netif_reschedule，发起一个软中断 NET_TX_SOFTIRQ。咱们讲设备驱动程序的时候讲过，设备驱动程序处理中断，分两个过程，一个是屏蔽中断的关键处理逻辑，一个是延迟处理逻辑。当时说工作队列是延迟处理逻辑的处理方案，软中断也是一种方案。</p>
<p>在系统初始化的时候，我们会定义软中断的处理函数。例如，NET_TX_SOFTIRQ 的处理函数是 net_tx_action，用于发送网络包。还有一个 NET_RX_SOFTIRQ 的处理函数是 net_rx_action，用于接收网络包。接收网络包的过程咱们下一节解析。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">open_softirq(NET_TX_SOFTIRQ, net_tx_action);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">open_softirq(NET_RX_SOFTIRQ, net_rx_action);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里我们来解析一下 net_tx_action。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static __latent_entropy void net_tx_action(struct softirq_action *h)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct softnet_data *sd = this_cpu_ptr(&amp;softnet_data);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (sd-&gt;output_queue) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        struct Qdisc *head;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         local_irq_disable();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        head = sd-&gt;output_queue;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        sd-&gt;output_queue = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        sd-&gt;output_queue_tailp = &amp;sd-&gt;output_queue;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        local_irq_enable();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         while (head) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            struct Qdisc *q = head;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            spinlock_t *root_lock;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">             head = head-&gt;next_sched;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            qdisc_run(q);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们会发现，net_tx_action 还是调用了 qdisc_run，还是会调用 __qdisc_run，然后调用 qdisc_restart 发送网络包。</p>
<p>我们来看一下 qdisc_restart 的实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static inline int qdisc_restart(struct Qdisc *q, int *packets)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        struct netdev_queue *txq;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        struct net_device *dev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        spinlock_t *root_lock;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        struct sk_buff *skb;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        bool validate;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         /* Dequeue packet */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        skb = dequeue_skb(q, &amp;validate, packets);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (unlikely(!skb))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                return 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         root_lock = qdisc_lock(q);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        dev = qdisc_dev(q);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        txq = skb_get_tx_queue(dev, skb);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         return sch_direct_xmit(skb, q, dev, txq, root_lock, validate);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>qdisc_restart 将网络包从 Qdisc 的队列中拿下来，然后调用 sch_direct_xmit 进行发送。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            struct net_device *dev, struct netdev_queue *txq,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            spinlock_t *root_lock, bool validate)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int ret = NETDEV_TX_BUSY;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     if (likely(skb)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (!netif_xmit_frozen_or_stopped(txq))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            skb = dev_hard_start_xmit(skb, dev, txq, &amp;ret); 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    } 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (dev_xmit_complete(ret)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        /* Driver sent out skb successfully or skb was consumed */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ret = qdisc_qlen(q);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        /* Driver returned NETDEV_TX_BUSY - requeue skb */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ret = dev_requeue_skb(skb, q);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 sch_direct_xmit 中，调用 dev_hard_start_xmit 进行发送，如果发送不成功，会返回 NETDEV_TX_BUSY。这说明网络卡很忙，于是就调用 dev_requeue_skb，重新放入队列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct sk_buff *dev_hard_start_xmit(struct sk_buff *first, struct net_device *dev, struct netdev_queue *txq, int *ret) 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct sk_buff *skb = first;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int rc = NETDEV_TX_OK;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     while (skb) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        struct sk_buff *next = skb-&gt;next;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        rc = xmit_one(skb, dev, txq, next != NULL);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        skb = next; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (netif_xmit_stopped(txq) &amp;&amp; skb) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            rc = NETDEV_TX_BUSY;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            break;      
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }       
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 dev_hard_start_xmit 中，是一个 while 循环。每次在队列中取出一个 sk_buff，调用 xmit_one 发送。</p>
<p>接下来的调用链为：xmit_one-&gt;netdev_start_xmit-&gt;__netdev_start_xmit。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">inline</span> <span class="n">netdev_tx_t</span> <span class="n">__netdev_start_xmit</span><span class="p">(</span><span class="k">const</span> <span class="n">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="n">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="ne">bool</span> <span class="n">more</span><span class="p">)</span>          
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">xmit_more</span> <span class="o">=</span> <span class="n">more</span> <span class="err">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_start_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个时候，已经到了设备驱动层了。我们能看到，drivers/net/ethernet/intel/ixgb/ixgb_main.c 里面有对于这个网卡的操作的定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">const</span> <span class="n">struct</span> <span class="n">net_device_ops</span> <span class="n">ixgb_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">ndo_open</span>               <span class="o">=</span> <span class="n">ixgb_open</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">ndo_stop</span>               <span class="o">=</span> <span class="n">ixgb_close</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">ndo_start_xmit</span>         <span class="o">=</span> <span class="n">ixgb_xmit_frame</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">ndo_set_rx_mode</span>        <span class="o">=</span> <span class="n">ixgb_set_multi</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">ndo_validate_addr</span>      <span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">ndo_set_mac_address</span>    <span class="o">=</span> <span class="n">ixgb_set_mac</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">ndo_change_mtu</span>         <span class="o">=</span> <span class="n">ixgb_change_mtu</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">ndo_tx_timeout</span>         <span class="o">=</span> <span class="n">ixgb_tx_timeout</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">ndo_vlan_rx_add_vid</span>    <span class="o">=</span> <span class="n">ixgb_vlan_rx_add_vid</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">ndo_vlan_rx_kill_vid</span>   <span class="o">=</span> <span class="n">ixgb_vlan_rx_kill_vid</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">ndo_fix_features</span>       <span class="o">=</span> <span class="n">ixgb_fix_features</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">ndo_set_features</span>       <span class="o">=</span> <span class="n">ixgb_set_features</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里面，我们可以找到对于 ndo_start_xmit 的定义，调用 ixgb_xmit_frame。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static netdev_tx_t
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ixgb_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct ixgb_adapter *adapter = netdev_priv(netdev);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (count) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ixgb_tx_queue(adapter, count, vlan_id, tx_flags);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        /* Make sure there is space in the ring for the next send. */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ixgb_maybe_stop_tx(netdev, &amp;adapter-&gt;tx_ring, DESC_NEEDED);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     } 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return NETDEV_TX_OK;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 ixgb_xmit_frame 中，我们会得到这个网卡对应的适配器，然后将其放入硬件网卡的队列中。</p>
<p>至此，整个发送才算结束。</p>
<h2 id="总结时刻">总结时刻</h2>
<p>这一节，我们继续解析了发送一个网络包的过程，我们整个过程的图画在了下面。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/046cd0892e36c9df01a9bf2376328fe4.png" alt=""></p>
<p>这个过程分成几个层次。</p>
<ul>
<li>VFS 层：write 系统调用找到 struct file，根据里面的 file_operations 的定义，调用 sock_write_iter 函数。sock_write_iter 函数调用 sock_sendmsg 函数。</li>
<li>Socket 层：从 struct file 里面的 private_data 得到 struct socket，根据里面 ops 的定义，调用 inet_sendmsg 函数。</li>
<li>Sock 层：从 struct socket 里面的 sk 得到 struct sock，根据里面 sk_prot 的定义，调用 tcp_sendmsg 函数。</li>
<li>TCP 层：tcp_sendmsg 函数会调用 tcp_write_xmit 函数，tcp_write_xmit 函数会调用 tcp_transmit_skb，在这里实现了 TCP 层面向连接的逻辑。</li>
<li>IP 层：扩展 struct sock，得到 struct inet_connection_sock，根据里面 icsk_af_ops 的定义，调用 ip_queue_xmit 函数。</li>
<li>IP 层：ip_route_output_ports 函数里面会调用 fib_lookup 查找路由表。FIB 全称是 Forwarding Information Base，转发信息表，也就是路由表。</li>
<li>在 IP 层里面要做的另一个事情是填写 IP 层的头。</li>
<li>在 IP 层还要做的一件事情就是通过 iptables 规则。</li>
<li>MAC 层：IP 层调用 ip_finish_output 进行 MAC 层。</li>
<li>MAC 层需要 ARP 获得 MAC 地址，因而要调用 ___neigh_lookup_noref 查找属于同一个网段的邻居，他会调用 neigh_probe 发送 ARP。</li>
<li>有了 MAC 地址，就可以调用 dev_queue_xmit 发送二层网络包了，它会调用 __dev_xmit_skb 会将请求放入队列。</li>
<li>设备层：网络包的发送回触发一个软中断 NET_TX_SOFTIRQ 来处理队列中的数据。这个软中断的处理函数是 net_tx_action。</li>
<li>在软中断处理函数中，会将网络包从队列上拿下来，调用网络设备的传输函数 ixgb_xmit_frame，将网络包发的设备的队列上去。</li>
</ul>
<h2 id="课堂练习">课堂练习</h2>
<p>上一节你应该通过 tcpdump 看到了 TCP 包头的格式，这一节，请你查看一下 IP 包的格式以及 ARP 的过程。</p>
<p>欢迎留言和我分享你的疑惑和见解，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1a5564dd4e1c9f25d4772c7f844ca84a.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">趣谈Linux操作系统</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/46__%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E8%A1%A5%E5%81%BF%E4%BA%8B%E5%8A%A1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">46__弹力设计篇之“补偿事务”</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2/46__%E8%AE%BF%E9%97%AE%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/">
            <span class="next-text nav-default">46__访问网络服务</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
