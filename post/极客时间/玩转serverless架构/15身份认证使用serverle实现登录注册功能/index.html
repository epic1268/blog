<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>15身份认证：使用Serverle实现登录注册功能 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="从今天开始，我们将进入 Serverless 应用的场景案例篇。这一讲我将带你实现 Serverless 中的身份认证。
我们平时用过那么多的网站和 App，很多都需要登录，登录的过程就是身份认证的过程。以电商网站为例，如果你想下单，先要注册账号，然后输入用户名（可能手机号或邮箱）、密码登录。之后你在一段时间内再访问该电商网站，都不用再登录，只有在连续长时间不登录的情况下（比如一个月），才用登录。这样一来，当你长时间不输入密码，很可能换了电脑或手机后，就忘记密码了。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%A9%E8%BD%ACserverless%E6%9E%B6%E6%9E%84/15%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%BD%BF%E7%94%A8serverle%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%A9%E8%BD%ACserverless%E6%9E%B6%E6%9E%84/15%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%BD%BF%E7%94%A8serverle%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="15身份认证：使用Serverle实现登录注册功能">
  <meta property="og:description" content="从今天开始，我们将进入 Serverless 应用的场景案例篇。这一讲我将带你实现 Serverless 中的身份认证。
我们平时用过那么多的网站和 App，很多都需要登录，登录的过程就是身份认证的过程。以电商网站为例，如果你想下单，先要注册账号，然后输入用户名（可能手机号或邮箱）、密码登录。之后你在一段时间内再访问该电商网站，都不用再登录，只有在连续长时间不登录的情况下（比如一个月），才用登录。这样一来，当你长时间不输入密码，很可能换了电脑或手机后，就忘记密码了。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="玩转Serverless架构">

  <meta itemprop="name" content="15身份认证：使用Serverle实现登录注册功能">
  <meta itemprop="description" content="从今天开始，我们将进入 Serverless 应用的场景案例篇。这一讲我将带你实现 Serverless 中的身份认证。
我们平时用过那么多的网站和 App，很多都需要登录，登录的过程就是身份认证的过程。以电商网站为例，如果你想下单，先要注册账号，然后输入用户名（可能手机号或邮箱）、密码登录。之后你在一段时间内再访问该电商网站，都不用再登录，只有在连续长时间不登录的情况下（比如一个月），才用登录。这样一来，当你长时间不输入密码，很可能换了电脑或手机后，就忘记密码了。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4958">
  <meta itemprop="keywords" content="玩转Serverless架构">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="15身份认证：使用Serverle实现登录注册功能">
  <meta name="twitter:description" content="从今天开始，我们将进入 Serverless 应用的场景案例篇。这一讲我将带你实现 Serverless 中的身份认证。
我们平时用过那么多的网站和 App，很多都需要登录，登录的过程就是身份认证的过程。以电商网站为例，如果你想下单，先要注册账号，然后输入用户名（可能手机号或邮箱）、密码登录。之后你在一段时间内再访问该电商网站，都不用再登录，只有在连续长时间不登录的情况下（比如一个月），才用登录。这样一来，当你长时间不输入密码，很可能换了电脑或手机后，就忘记密码了。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">15身份认证：使用Serverle实现登录注册功能</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4958 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#使用错误的密码登录">使用错误的密码登录</a></li>
    <li><a href="#使用错误的-token-进行身份认证">使用错误的 token 进行身份认证</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>从今天开始，我们将进入 Serverless 应用的场景案例篇。这一讲我将带你实现 Serverless 中的身份认证。</p>
<p>我们平时用过那么多的网站和 App，很多都需要登录，登录的过程就是身份认证的过程。以电商网站为例，如果你想下单，先要注册账号，然后输入用户名（可能手机号或邮箱）、密码登录。之后你在一段时间内再访问该电商网站，都不用再登录，只有在连续长时间不登录的情况下（比如一个月），才用登录。这样一来，当你长时间不输入密码，很可能换了电脑或手机后，就忘记密码了。</p>
<p>身份认证几乎是每个系统必备能力，所以很多同学开发应用时，实现的第一功能就是登录注册。然而当把应用迁移到 Serverless 架构时，很多同学就犯难了，基于 Serverless 的身份认证功能应该怎么实现呢？</p>
<p>为了让你深入理解 Serverless 架构中的身份认证实现原理，我准备了今天的内容，这一讲我会先带你了解一些身份认证技术方案，然后带你从零到一实现一个 Serverless 的登录注册应用。</p>
<p>话不多说，我们进入今天的学习。</p>
<p>身份认证的技术方案</p>
<p>要实现应用中的身份认证，你首先要详细了解身份认证的技术方案，以及该方案怎么在 Serverless 架构中使用，因为有的技术方案可能不适合 Serverless。</p>
<p>Cookie-Session</p>
<p>早期互联网主要以 Web 为主，客户端是浏览器，所以 Cookie-Session 方式是早期最常用的身份认证方式，直到现在很多 Web 网站依然使用这种方式。其认证流程是：</p>
<p>用户在浏览器中输入账号密码登录；</p>
<p>服务端验证通过后，将用户信息保存在 Session 中并生成一个 Session ID；</p>
<p>然后服务端将 Session ID 放在 HTTP 响应头的 cookie 字段中；</p>
<p>浏览器收到 HTTP 响应后，将 cookie 保存在浏览器中，cookie 内容就是之前登录时生成的 Session ID；</p>
<p>用户再访问网站时，浏览器请求头就会自动带上 cookie 信息；</p>
<p>服务端接收到请求后，从 cookie 获取到 Session ID，然后根据 Session ID 解析出用户信息。</p>
<p>Cookie-Session 身份认证流程</p>
<p>这种方案存在两个主要问题：</p>
<p>服务端的 Session ID 是直接存储在内存中的，在分布式系统中无法共享登录状态；</p>
<p>cookie 是浏览器的功能，手机 App 等客户端并不支持 cookie，所以该方案不适用于非浏览器的应用。</p>
<p>第一个问题也是 Cookie-Session 方案应用于 Serverless 架构的主要问题，因为 Serverless 应用是无状态的，内存中的数据用完即销毁，多个请求间无法共享 Session。解决该问题也比较容易， 就是用一个共享存储来保存 Session 信息，最常见的就是 Redis，因为 Redis 是一个内存数据库，读写速度很快。</p>
<p>于是 Cookie-Session 的身份认证方案就发生了变化：</p>
<p>基于共享存储的 Cookie-Session 身份认证流程</p>
<p>与早期方案不同，用户登录时，该方案会把用户信息保存在 Redis 中，而不是内存中，然后服务端依然会将 Session ID 返回给浏览器，浏览器将其保存在 cookie 中。而之后非登录的请求，浏览器依然会将包含 Session ID 的 cookie 放在请求头中发送给服务端，服务端拿到 Session ID 后，从 Redis 中查询出用户信息。这样就可以解决分布式、无状态的系统中用户登录状态共享问题。</p>
<p>不过这个方案依旧无法解决非浏览器场景的身份认证问题，所以 JWT 方案诞生了。</p>
<p>JWT</p>
<p>JWT 是（JSON Web Token）的简称，其原理是：</p>
<p>服务端认证通过后，根据用户信息生成一个 token 返回给客户端；</p>
<p>客户端将 token 存储在 cookie 或 localStorage 中；</p>
<p>之后客户端每次请求都需要带上 token，通常是将 token 放在 HTTP 请求头的 Authorization 字段中；</p>
<p>服务端接收到 token 后，验证 token 的合法性，并从 token 中解析出用户信息。</p>
<p>JWT 身份认证流程</p>
<p>token 是个比较长字符串，格式为
Header.Payload.Signature
，由
.
分隔为三部分。下面是一个实际的 token 示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJqYWNrIiwiaWF0IjoxNjEwODg1MTcxfQ.KIduc-undaZ0z-Bt4wjGZIK5fMlx1auVHl_G1DvGDCw
</span></span></code></pre></td></tr></table>
</div>
</div><p>可能有同学会担忧： token 是根据用户信息生成的，这样会不会泄露用户信息呢？其实不用担心，因为生成 token 的加密算法是不可逆的，并且 token 也可以设置过期时间，所以 token 字符串本身不会泄露用户信息。基于 JWT ，客户端可以使用自己特有的存储来保存 token，不依赖 cookie，所以 JWT 可以适用于任意客户端。并且使用 JWT 进行身份认证，服务端就不用存储用户信息了，这样服务端就是无状态的。因此 JWT 这种身份认证方案，也非常适合 Serverless 应用。</p>
<p>接下来，我就基于 JWT ，带你从 0 到 1实现一个登录注册应用。</p>
<p>从 0 到 1 实现一个登录注册应用</p>
<p>为了方便，我们将基于 Express.js 框架进行开发。关于该应用的所有代码你可以在 Github 上查看：Serverless Authorization。</p>
<p>应用初始化</p>
<p>首先安装 express、body-parser 和 @webserverless/fc-express 等依赖：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ npm i express body-parser @webserverless/fc-express -S
</span></span></code></pre></td></tr></table>
</div>
</div><p>@webserverless/fc-express 的作用是将函数计算的 HTTP 或 API 网关触发器参数转换为 Express.js 框架的参数，这样你就可以很方便在函数计算中使用 Express.js 了。</p>
<p>然后我们初始化一个 template.yaml 模板，该模板定义了 auth-app 这个函数，函数触发器为 HTTP 触发器，支持 GET 和 POST 请求：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ROSTemplateFormatVersion: &#39;2015-09-01&#39;
</span></span><span class="line"><span class="cl">Transform: &#39;Aliyun::Serverless-2018-04-03&#39;
</span></span><span class="line"><span class="cl">Resources:
</span></span><span class="line"><span class="cl">  serverless:
</span></span><span class="line"><span class="cl">    Type: &#39;Aliyun::Serverless::Service&#39;
</span></span><span class="line"><span class="cl">    Properties:
</span></span><span class="line"><span class="cl">      Description: &#39;Serverless Authorization App&#39;
</span></span><span class="line"><span class="cl">    auth-app:
</span></span><span class="line"><span class="cl">      Type: &#39;Aliyun::Serverless::Function&#39;
</span></span><span class="line"><span class="cl">      Properties:
</span></span><span class="line"><span class="cl">        Handler: index.handler
</span></span><span class="line"><span class="cl">        Runtime: nodejs12
</span></span><span class="line"><span class="cl">        CodeUri: &#39;./&#39;
</span></span><span class="line"><span class="cl">        Timeout: 10
</span></span><span class="line"><span class="cl">      Events:
</span></span><span class="line"><span class="cl">        httpTrigger:
</span></span><span class="line"><span class="cl">          Type: HTTP
</span></span><span class="line"><span class="cl">          Properties:
</span></span><span class="line"><span class="cl">            AuthType: ANONYMOUS
</span></span><span class="line"><span class="cl">            Methods: [&#39;POST&#39;, &#39;GET&#39;]
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来在 index.js 中编写初始化代码，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="s1">&#39;@webserverless/fc-express&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">express</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="s1">&#39;express&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">bodyParser</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="s1">&#39;body-parser&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">app</span> <span class="o">=</span> <span class="n">express</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">app</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="n">bodyParser</span><span class="o">.</span><span class="n">urlencoded</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="n">extended</span><span class="p">:</span> <span class="bp">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="err">定义</span> <span class="o">/</span> <span class="err">路由，返回</span> <span class="n">Hello</span> <span class="n">Serverless</span><span class="o">!</span>
</span></span><span class="line"><span class="cl"><span class="n">app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span><span class="o">.</span><span class="n">json</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">        <span class="n">success</span><span class="p">:</span> <span class="bp">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">:</span> <span class="s1">&#39;Hello Serverless!&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">server</span> <span class="o">=</span> <span class="n">new</span> <span class="n">proxy</span><span class="o">.</span><span class="n">Server</span><span class="p">(</span><span class="n">app</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">module</span><span class="o">.</span><span class="n">exports</span><span class="o">.</span><span class="n">handler</span> <span class="o">=</span> <span class="n">function</span> <span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">使用</span> <span class="err">@</span><span class="n">webserverless</span><span class="o">/</span><span class="n">fc</span><span class="o">-</span><span class="n">express</span> <span class="err">来将函数计算的请求转发给</span> <span class="n">Express</span><span class="o">.</span><span class="n">js</span> <span class="err">应用</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">@</span><span class="n">webserverless</span><span class="o">/</span><span class="n">fc</span><span class="o">-</span><span class="n">express</span> <span class="err">可以将函数参数转换为</span> <span class="n">Express</span><span class="o">.</span><span class="n">js</span> <span class="err">的路由参数</span>
</span></span><span class="line"><span class="cl">    <span class="n">server</span><span class="o">.</span><span class="n">httpProxy</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码主要实现两个功能：</p>
<p>定义了
/
  路由，该路由返回了
Hello Serverless!
 字符串，我们之后可以用它来测试代码是否正常运行；</p>
<p>使用 @webserverless/fc-express 将函数计算的请求转发给 Express.js 应用，@webserverless/fc-express 可以将函数参数转换为 Express.js 的路由参数。</p>
<p>然后通过
fun deploy
部署应用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 部署应用
</span></span><span class="line"><span class="cl">$ fun deploy -y
</span></span><span class="line"><span class="cl">Waiting for service serverless to be deployed...
</span></span><span class="line"><span class="cl">        Waiting for function auth-app to be deployed...
</span></span><span class="line"><span class="cl">                Waiting for packaging function auth-app code...
</span></span><span class="line"><span class="cl">                The function auth-app has been packaged. A total of 419 files were compressed and the final size was 724.49 KB
</span></span><span class="line"><span class="cl">                Waiting for HTTP trigger httpTrigger to be deployed...
</span></span><span class="line"><span class="cl">                triggerName: httpTrigger
</span></span><span class="line"><span class="cl">                methods: [ &#39;POST&#39;, &#39;GET&#39; ]
</span></span><span class="line"><span class="cl">                url: https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/
</span></span><span class="line"><span class="cl">                trigger httpTrigger deploy success
</span></span><span class="line"><span class="cl">        function auth-app deploy success
</span></span><span class="line"><span class="cl">service serverless deploy success
</span></span><span class="line"><span class="cl">$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/
</span></span><span class="line"><span class="cl">{&#34;success&#34;:true,&#34;data&#34;:&#34;Hello Serverless!&#34;}
</span></span></code></pre></td></tr></table>
</div>
</div><p>部署成功后，我们就可以获取到函数计算提供的测试 HTTP Endpoint，然后就可以通过 curl 命令进行测试应用是否正常运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ curl https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/
</span></span><span class="line"><span class="cl">{&#34;success&#34;:true,&#34;data&#34;:&#34;Hello Serverless!&#34;}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你和我一样返回了上述 JSON 字符串，就说明应用正常运行了，接下来我们就可以继续实现注册功能了。</p>
<p>实现注册功能</p>
<p>注册的逻辑是：先获取用户输入的用户名和密码，然后判断用户是否存在，如果不存在就将其存入表格存储数据库。</p>
<p>这里我们使用的数据库是表格存储。 可能你使用的比较多的是 MySQL，之所以选用表格存储而不是 MySQL，是因为表格存储可以直接通过 Restful API 进行读写，并且弹性可扩展，更适合 Serverless 应用。使用表格存储时，你要先创建一个表格存储实例，然后创建一个 user 表。为了方便，我也给你提供了一个创建 user 表的脚本：create-table。</p>
<p>接下来继续编写代码。由于要使用表格存储，所以首先需要安装 tablestore 依赖，然后在 index.js 中初始化表格存储 client：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 安装 tablestore 依赖
</span></span><span class="line"><span class="cl"># tablestore 封装了表格存储的 API
</span></span><span class="line"><span class="cl">$ npm i tablestore -S
</span></span></code></pre></td></tr></table>
</div>
</div><p>// index.js
// &hellip;
const TableStore = require(&rsquo;tablestore&rsquo;);</p>
<p>// 初始化 TableStore client
const client = new TableStore.Client({
accessKeyId: &lsquo;<your access key>&rsquo;,
accessKeySecret: &lsquo;your access secret&rsquo;,
endpoint: &lsquo;<a href="https://serverless-app.cn-shanghai.ots.aliyuncs.com">https://serverless-app.cn-shanghai.ots.aliyuncs.com</a>&rsquo;,
instancename: &lsquo;serverless-app&rsquo;,
});</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">现在我们就可以定义一个路由来处理用户的注册请求了。代码如下所示，首先我们根据 name 从表格存储中查询用户信息，如果用户已存在，则直接返回；如果用户不存在，则将用户信息写入表格存储。
</span></span></code></pre></td></tr></table>
</div>
</div><p>// 定义 /register 路由，处理注册请求
app.post(&rsquo;/register&rsquo;, async (req, res) =&gt; {
// 从请求体中获取用户信息
const name = req.body.name;
const password = req.body.password;
const age = req.body.age;
// 判断用户是否已经存在
const { row } = await client.getRow({
tableName: &ldquo;user&rdquo;,
primaryKey: [{
name
}]
});
if (row.primaryKey) {
// 如果用户已存在，则直接返回
return res.json({
success: false,
message: &lsquo;用户已存在&rsquo;
});
}
// 创建用户，将用户信息写入到表格存储中
await client.putRow({
tableName: &ldquo;user&rdquo;,
condition: new TableStore.Condition(TableStore.RowExistenceExpectation.EXPECT_NOT_EXIST, null),
primaryKey: [{
name
}],
attributeColumns: [{
password
}, {
age
}]
});
// 返回创建成功
return res.send({
success: true,
});
});</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">至此注册功能就完成了，你可以将代码部署到函数计算上，像下面这样通过 curl 命令来模拟用户请求，验证功能是否正常：
</span></span></code></pre></td></tr></table>
</div>
</div><p>$ curl <a href="https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth/login">https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth/login</a> <br>
-d &ldquo;name=jack&amp;password=123456&amp;age=18&rdquo; <br>
-X POST
{&ldquo;success&rdquo;:true}</p>
<p>$ curl <a href="https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth/login">https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth/login</a> <br>
-d &ldquo;name=jack&amp;password=123456&amp;age=18&rdquo; <br>
-X POST
{&ldquo;success&rdquo;:false,&ldquo;message&rdquo;:&ldquo;用户已存在&rdquo;}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">注册功能完成后，就可以继续实现登录功能了。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">实现登录功能
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">登录就是验证用户输入的用户名密码是否正确。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">首先根据用户输入的 name 从表格存储中查询出用户信息，然后对比用户密码与数据库中的用户密码是否一致，如果一致，则登录成功；否则登录失败。登录成功后，还需要根据用户信息生成一个 token 返回给用户。具体怎么实现呢？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">前面我们提到，Serverless 中最通用的身份认证方案是 JWT，所以我们首先需要安装 Node.js 中的 JWT 依赖包 jsonwebtoken：
</span></span></code></pre></td></tr></table>
</div>
</div><p>$ npm install jsonwebtoken -S</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">然后在代码中引入 jsonwebtoken ，并定义 SECRET。SECRET 是用来加密和解密 token 的密钥，非常重要，且不能泄露。接下来在代码中定义 
</span></span><span class="line"><span class="cl">/login
</span></span><span class="line"><span class="cl"> 路由来处理用户请求。这段代码中，我们首先验证了用户密码是否正确，密码正确后，再使用 jwt.sign() 方法，根据用户信息生成了 token，最后将 token 返回给客户端，客户端需要将 token 保存下来。之后客户端每次请求，都需要带上 token 进行身份认证。
</span></span></code></pre></td></tr></table>
</div>
</div><p>// index.js
// &hellip;
const jwt = require(&lsquo;jsonwebtoken&rsquo;)
// 设置密钥，非常重要，不能泄露
const SECRET = &rsquo;token_secret_xd2dasf19df=&rsquo;
// &hellip;
// 定义 /login 路由，用来实现登录功能
app.post(&rsquo;/login&rsquo;, async (req, res) =&gt; {
// 从请求体中获取用户名和密码
const name = req.body.name;
const password = req.body.password;
// 根据用户名查询用户信息
const {
row
} = await client.getRow({
tableName: &lsquo;user&rsquo;,
primaryKey: [{
name
}]
})
// 如果查询结果为空，则直接返回用户不存在
if (!row.primaryKey) {
return res.json({
success: false,
message: &lsquo;用户不存在&rsquo;
})
}
// 从查询结果中构造用户信息
const user = {
name
};
row.attributes.forEach(item =&gt; user[item.columnName] = item.columnValue);
// 判断密码是否正确
if (password !== user.password) {
return res.json({
success: false,
message: &lsquo;密码错误&rsquo;
})
}
user.password = &lsquo;****<strong>&rsquo;;
/</strong></p>
<ul>
<li>生成 token</li>
<li>jwt.sign() 接受两个参数，一个是传入的对象，一个是自定义的密钥
*/
const token = jwt.sign(user, SECRET)
return res.json({
success: true,
data: { token }
})
});</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">代码编写完成后，部署到函数计算并进行测试，如下所示：
</span></span></code></pre></td></tr></table>
</div>
</div><p>curl <a href="https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/login">https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/login</a> <br>
-d &ldquo;name=jack&amp;password=123456&rdquo; \
-X POST
{&ldquo;success&rdquo;:true,&ldquo;data&rdquo;:{&ldquo;token&rdquo;:&ldquo;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiamFjayIsImFnZSI6IjE4IiwicGFzc3dvcmQiOiIqKioqKioiLCJpYXQiOjE2MTA5MDY5MTJ9.qzNZarWbpDUA8-SO6nLd4ffEUR1IVOWKGXiocHV7MkU&rdquo;}}</p>
<h1 id="使用错误的密码登录">使用错误的密码登录</h1>
<p>$ curl <a href="https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/login">https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/login</a> <br>
-d &ldquo;name=jack&amp;password=1234561&rdquo; <br>
-X POST
{&ldquo;success&rdquo;:false,&ldquo;message&rdquo;:&ldquo;密码错误&rdquo;}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">那么问题来了：对于需要登录后才能访问的接口，应该怎么根据 token 验证用户身份呢？别急，我们继续下面的学习。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">验证用户身份
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">前面提到，登录成功后，客户端需要将 token 保存下来，然后在接下来的请求中，都需要带上 token。通常会将 token 放在 HTTP 请求头中，格式通常为：
</span></span></code></pre></td></tr></table>
</div>
</div><p>Authorization: Bearer token</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这时假设我们要实现一个新的接口，获取当前登录用户信息，该接口也只能登录后才能使用。那么代码实现就是下面这样：
</span></span></code></pre></td></tr></table>
</div>
</div><p>// 定义 /user 路由，获取当前登录的用户信息
app.get(&rsquo;/user&rsquo;, (req, res) =&gt; {
// 从 HTTP 请求头中获取 token 信息
const token = req
.headers
.authorization
.split(&rsquo; &lsquo;)
.pop();
try {
// 验证 token 并解析出用户信息
const user = jwt.verify(token, SECRET);
return res.json({
success: true,
data: user
})
} catch (error) {
return res.json({
success: false,
data: &lsquo;身份认证失败&rsquo;
})
}
});</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">首先我们定义了 
</span></span><span class="line"><span class="cl">/user
</span></span><span class="line"><span class="cl"> 路由，然后通过请求头拿到 token 信息，最后使用 
</span></span><span class="line"><span class="cl">jwt.verify()
</span></span><span class="line"><span class="cl"> 对 token 进行解密，并从中得到用户信息，如果用户传入的 token 无法解析，则说明用户身份异常。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">同样，我们可以将代码部署到函数计算并进行测试：
</span></span></code></pre></td></tr></table>
</div>
</div><p>curl <a href="https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/user">https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/user</a> <br>
-H &ldquo;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiamFjayIsImFnZSI6IjE4IiwicGFzc3dvcmQiOiIqKioqKioiLCJpYXQiOjE2MTA5MDY5MTJ9.qzNZarWbpDUA8-SO6nLd4ffEUR1IVOWKGXiocHV7MkU&rdquo;
{&ldquo;success&rdquo;:true,&ldquo;data&rdquo;:{&ldquo;name&rdquo;:&ldquo;jack&rdquo;,&ldquo;age&rdquo;:&ldquo;18&rdquo;,&ldquo;password&rdquo;:&quot;******&quot;,&ldquo;iat&rdquo;:1610905944}}</p>
<h1 id="使用错误的-token-进行身份认证">使用错误的 token 进行身份认证</h1>
<p>$ curl <a href="https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/user">https://1457216987974698.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/serverless/auth-app/user</a> -H &ldquo;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiamFjayIsImFnZSI6IjE4IiwicGFzc3dvcmQiOiIqKioqKioiLCJpYXQiOjE2MTA5MDY5MTJ9.qzNZarWbpDUA8-SO6nLd4ffEUR1IVOWKGXiocHV7Mk&rdquo;
{&ldquo;success&rdquo;:false,&ldquo;data&rdquo;:&ldquo;身份认证失败&rdquo;}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">到此为止，一个 Serverless 架构的登录注册功能就完成了，我们也基于 JWT 实现了 Serverless 中的身份认证。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">总结
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这一讲，我首先为你介绍了常用的身份认证方案，并分析了这些方案的特点，以及如何在 Serverless 架构中使用这些方案。然后我带你从0到1实现了一个 Serverless 的登录注册应用，通过该场景实践，让你深入理解 Serverless 中的身份认证。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Serverless 应用的身份认证，本质上是要将有状态的认证方案改为无状态的。如何改为无状态呢？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">使用共享存储来保存登录状态，比如将 Session 信息存储到 Reids，这样应用就不用存储状态了；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">使用无状态的身份认证方案，比如 JWT。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">当然了，除了自己实现应用的身份认证，你也可以使用第三方的身份认证服务，比如 AWS Cognito、Google Firebase 等，基于它们，你就不用自己开发用户管理及身份认证功能了。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">关于这一讲，我想强调这样几点：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Cookie-Session 的身份认证方式，是在服务端存储 Session 信息，客户端（浏览器）通过 cookie 存储 Session ID；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">JWT 的身份认证方式，是在服务端根据用户信息生成 token，客户端保存 token；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Cookie-Session 的认证方案通常是有状态的，对于分布式、无状态的应用，需要将 Session 保存在共享存储中；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">JWT 的认证方式通常是无状态的，所以比较适合 Serverless 应用。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">最后，希望通过今天的学习，你能深入了解 Serverless 应用的身份认证，今天留给你的作业就是：亲自动手实现一个 Serverless 的登录注册应用，我们下一讲见。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">\--- ### 精选评论 ##### \*乐： &gt; 为什么要转发消息到Express.js呢？直接在函数计算中加密得到token，解密token得到信息不好么？ ######     讲师回复： &gt;     使用 Express.js 我们可以更方便地构建一个 Web 应用，本节课基于 Express.js 开发也是讲解如何基于 Express.js 开发 Serverless 应用，这样学完本节课之后，您就会学到如何将已有的 Express.js 应用迁移到 Serverless 平台。此外下节课中我就讲解了如何不使用框架直接开发 Serverless 应用。
</span></span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%8E%A9%E8%BD%ACserverless%E6%9E%B6%E6%9E%84/">玩转Serverless架构</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/15%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E7%AB%99recycler%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">15轻量级对象回收站：Recycler对象池技术解析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/15%E6%95%B0%E6%8D%AE%E7%A3%90%E7%9F%B3apm%E6%94%B6%E9%9B%86%E7%AB%AF%E7%9A%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/">
            <span class="next-text nav-default">15数据磐石：APM收集端的存储模型</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
