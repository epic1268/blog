<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>05开发框架：如何提高应用开发调试和部署效率？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="到目前为止，你已经知道怎么基于 FaaS 开发 Serverless 应用了。不过你应该可以发现，04讲中的应用很简单（只有一个函数）。而实际情况中，绝大部分应用都是由多个函数组成的，应用部署时需要将所有函数一同部署，并且函数运行依赖 FaaS 环境，这就导致函数代码不能直接在本地运行。这些限制就给我们的应用开发、调试和部署流程带来了挑战，比如：
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%A9%E8%BD%ACserverless%E6%9E%B6%E6%9E%84/05%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%92%8C%E9%83%A8%E7%BD%B2%E6%95%88%E7%8E%87/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%A9%E8%BD%ACserverless%E6%9E%B6%E6%9E%84/05%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%92%8C%E9%83%A8%E7%BD%B2%E6%95%88%E7%8E%87/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="05开发框架：如何提高应用开发调试和部署效率？">
  <meta property="og:description" content="到目前为止，你已经知道怎么基于 FaaS 开发 Serverless 应用了。不过你应该可以发现，04讲中的应用很简单（只有一个函数）。而实际情况中，绝大部分应用都是由多个函数组成的，应用部署时需要将所有函数一同部署，并且函数运行依赖 FaaS 环境，这就导致函数代码不能直接在本地运行。这些限制就给我们的应用开发、调试和部署流程带来了挑战，比如：">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="玩转Serverless架构">

  <meta itemprop="name" content="05开发框架：如何提高应用开发调试和部署效率？">
  <meta itemprop="description" content="到目前为止，你已经知道怎么基于 FaaS 开发 Serverless 应用了。不过你应该可以发现，04讲中的应用很简单（只有一个函数）。而实际情况中，绝大部分应用都是由多个函数组成的，应用部署时需要将所有函数一同部署，并且函数运行依赖 FaaS 环境，这就导致函数代码不能直接在本地运行。这些限制就给我们的应用开发、调试和部署流程带来了挑战，比如：">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6238">
  <meta itemprop="keywords" content="玩转Serverless架构">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="05开发框架：如何提高应用开发调试和部署效率？">
  <meta name="twitter:description" content="到目前为止，你已经知道怎么基于 FaaS 开发 Serverless 应用了。不过你应该可以发现，04讲中的应用很简单（只有一个函数）。而实际情况中，绝大部分应用都是由多个函数组成的，应用部署时需要将所有函数一同部署，并且函数运行依赖 FaaS 环境，这就导致函数代码不能直接在本地运行。这些限制就给我们的应用开发、调试和部署流程带来了挑战，比如：">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">05开发框架：如何提高应用开发调试和部署效率？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6238 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#serverlessyaml">serverless.yaml</a></li>
    <li><a href="#远程调试">远程调试</a></li>
    <li><a href="#本地调试">本地调试</a></li>
    <li><a href="#项目根目录-env">项目根目录 .env</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>到目前为止，你已经知道怎么基于 FaaS 开发 Serverless 应用了。不过你应该可以发现，04讲中的应用很简单（只有一个函数）。而实际情况中，绝大部分应用都是由多个函数组成的，应用部署时需要将所有函数一同部署，并且函数运行依赖 FaaS 环境，这就导致函数代码不能直接在本地运行。这些限制就给我们的应用开发、调试和部署流程带来了挑战，比如：</p>
<p>函数太多如何管理？</p>
<p>本地开发时如何进行调试？</p>
<p>代码开发完成后如何部署？</p>
<p>……</p>
<p>要解决这些问题，你就需要一套完整的开发、调试和部署 Serverless 的解决方案，这个解决方案最终可以抽象为一个开发框架。那么什么是 Serverless 开发框架呢？我认为Serverless 的开发框架不是传统的 Express.js、Spring Boot 等代码框架，而是集成 Serverless 思想、贯穿 Serverless 应用从开发到上线全流程的工具。 基于 Serverless 开发框架，你很容易开发一个 Serverless 架构的应用，企业也能轻松把现有业务演化为 Serverless 架构。对 Serverless 来说，除了底层的 FaaS、BaaS 等基础设施， 上层的开发框架也是一个非常重要的部分，这直接决定了开发者使用 Serverless 的成本。</p>
<p>这一讲，我以框架开发者的视角，带你思考如何设计并实现一个 Serverless 开发框架，以此让你深入理解开发框架底层设计思路和实现原理，进而明白为什么开发框架能提高 Serverless 应用开发效率。这样一来，当你学完这一讲内容之后，再面对任何开发框架，都能快速上手了，甚至你也能成为一个框架开发者，为广大 Serverless 用户提供更好用的开发工具。</p>
<p>如何设计 Serverless 的开发框架</p>
<p>前面我已经提到，Serverless 开发框架是贯穿 Serverless 应用从开发到上线全流程的工具。基于这个定义，一个开发框架至少要满足应用管理、应用开发、应用调试和应用部署这几个基本功能。 从形态上来看，Serverless 开发框架可以抽象为一个平台或服务，最终以终端工具（命令行工具）或控制台的方式提供给开发者使用。接下来我就从这几个方面进行讲解。</p>
<p>应用管理</p>
<p>Serverless 应用是由函数组成的，所以应用的管理主要就是函数的管理。各个 FaaS 平台其实也考虑到了这一点，比如函数计算的 “服务”功能或 Lambda 的 “应用” 功能。你可以把一个应用的函数都创建在同一个 “服务” 下，一个 “服务” 即代表一个应用。</p>
<p>那么如何去描述 “服务” 和 “函数” 的关系呢？因为二者是静态的，不会在代码运行时改变，所以你可以用 YAML 或 JSON 配置文件来表示（我推荐 YAML，因为它可以编写注释，可读性更好）。在创建函数时，你还要指定函数的入口、编程语言、触发器等信息。所以 YAML 文件的内容可能是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># serverless.yaml
</span></span><span class="line"><span class="cl"># 应用名称
</span></span><span class="line"><span class="cl">service: myservice
</span></span><span class="line"><span class="cl"># 函数列表
</span></span><span class="line"><span class="cl">functions:
</span></span><span class="line"><span class="cl">    # 函数1
</span></span><span class="line"><span class="cl">  hello:
</span></span><span class="line"><span class="cl">    handler: hello.main # 函数入口
</span></span><span class="line"><span class="cl">    runtime: nodejs12
</span></span><span class="line"><span class="cl">    events: # 函数触发器，一个函数可能有多个触发器
</span></span><span class="line"><span class="cl">        - http
</span></span><span class="line"><span class="cl">        - timer
</span></span><span class="line"><span class="cl">  # 函数2
</span></span><span class="line"><span class="cl">  goodbye:
</span></span><span class="line"><span class="cl">    handler: goodbye.main
</span></span><span class="line"><span class="cl">    runtime: nodejs12
</span></span><span class="line"><span class="cl">    events:
</span></span><span class="line"><span class="cl">        - http
</span></span></code></pre></td></tr></table>
</div>
</div><p>我来简单讲一下其中的关键属性。</p>
<p>service：应用名称 。</p>
<p>functions：它的属性就是组成应用的函数，一个应用可以有多个函数，并且函数名不能重复，例如 hello 和 goodbye 就是 myservice 应用的两个函数。</p>
<p>handler ：函数的入口。</p>
<p>runtime ：函数运行环境（在 Serverless 中函数的运行环境是预先定义好的）。</p>
<p>events：一个函数可能有多个触发器，所以使用 events 数组来表示触发器，例如 hello 函数有 http 和 timer两个触发器。</p>
<p>这里你要注意， 当用户不了解你的 YAML 结构时，让用户去编写这个配置文件就很困难了，所以你要为用户提供一个初始化的功能。假设你的终端工具是一个可执行脚本，命令为 serverless，那么你就可以提供 serverless init 命令自动为用户创建一个管理 Serverless 应用的 YAML 配置文件。</p>
<p>应用开发</p>
<p>有了应用配置文件之后，开发者就可以开始开发代码了。为了进一步简化用户操作，你甚至可以提供一些代码模板，然后提供 init 命令让开发者基于模板一键生成一个 Serverless 应用。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ serverless init --template hello-world
</span></span><span class="line"><span class="cl">|-- hello.js
</span></span><span class="line"><span class="cl">|-- serverless.yaml
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="serverlessyaml">serverless.yaml</h1>
<p>service: myservice
functions:
hello:
handler: hello.main
events:
- http</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这样开发者就能直接在本地用自己喜欢的编辑器编写代码了。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">此外你也可以提供一个 Web IDE，在 Web IDE 中为开发者初始化运行环境，这样开发者不用在本地安装编辑器就能开发，也不用关心运行环境的差异。目前各个 FaaS 平台也有提供了自己的 Web IDE，比如 AWS 的 Cloud9、函数计算 Web IDE。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这里我多说几句，丰富一下你的知识面。 Cloud9 原本是一家创业公司，提供云上应用开发、部署能力，其 Web IDE 功能很强大，不过它在 2016 年 7 月就被 AWS 收购了。另一个比较有趣的事情是，腾讯在 2018 年投资了 Coding，Coding 的重点产品就是 Cloud Studio 这款 Web IDE，之后 Cloud Studio 就集成到了腾讯云中，腾讯云函数的 Web IDE 就是 Cloud Studio。2019 年腾讯则收购了 Coding。函数计算 Web IDE 则是基于 VS Code 开发的。微软在 2019 年 5 月发布了 Visual Studio Online，让开发者可以轻松实现一个 Web IDE。所以你也能感受到 Serverless 时代 Web IDE 的重要性。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">现在你基于 Visual Studio Online 也可以开发一个 Web IDE，当然要做一个完善的 Web IDE 还是很难的，我觉得目前体验最好的 Web IDE 还是 Cloud9，但相比本地开发还是有一定差距，不过我也相信，未来 Web IDE 的体验会越来越好。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">应用调试
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">接着说回来，应用开发结束后，就要进入调试阶段了，毫不夸张地说，在 Serverless 应用开发中，应用调试十分麻烦。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">以《03 | 基础入门：开发你的第一个 Serverless 应用》中的函数为例，函数代码如下：
</span></span></code></pre></td></tr></table>
</div>
</div><p>exports.handler = (event, context, callback) =&gt; {
// 从 event 中获取 URL query 参数
const { name } = event.queryStringParameters;
// 定义 HTTP Response
const response = {
statusCode: 200,
headers: {
&ldquo;Content-Type&rdquo;: &ldquo;application/json&rdquo;
},
body: JSON.stringify({ message: <code>Hello ${name}!</code>} ),
};
callback(null, response);
};</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">要想调试这个函数，就需要手动构造 event、context 和 callback 三个对象，然后以它们为参数来调用函数，测试函数运行情况。麻烦点就在于： 这些参数运行依赖于 FaaS 环境，不同运行环境、不同触发器函数的入参都有差异，手动模拟这些对象很麻烦，且容易出错。那如何让开发者方便调试呢？ 有两种方式。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">远程调试：将代码部署到 FaaS 平台，然后直接调用 FaaS 平台的接口执行函数，再得到函数运行日志及返回结果。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">本地调试：由开发框架模拟函数运行时环境，构造函数参数来执行函数。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">我认为对一个 Serverless 开发框架来说，这两种调试方式都需要， 也就是需要实现 serverless invoke 和 serverless local invoke 两个命令。虽然远程调试最接近代码真实运行情况，但需要进行网络调用，大部分情况还是本地调试效率更高。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">应用部署
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">当代码开发完成后，就要部署应用了，过程是：根据 YAML 的配置，解析出应用的服务名称和函数列表，然后调用 FaaS 平台的接口来创建或更新服务和函数。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">需要注意的是，在创建函数时，FaaS 平台中的函数代码通常以压缩包的方式存储在文件存储服务中，所以部署函数前需要先在本地把代码压缩成 .zip 文件。而在部署应用时，大部分同学会有这样一个担忧： 代码调试可以把函数部署到 FaaS 中进行调试，可能每次代码改动都会影响到线上服务，如果有版本控制就可以避免了。FaaS 平台当然考虑了这个问题，提供了函数版本功能（默认是 LATEST 版本）。通过版本控制，你在开发时可以使用 LATEST 版本进行开发，测试稳定了再发布稳定的新版本，用稳定版本提供线上服务。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">所以在远程调试时，就不能更新函数版本，一直用 LATEST，而当应用部署时，就需要更新函数版本。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">账号设置与多平台支持
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">讲到这儿，我们已经完成了应用部署功能设计， 但还有个问题没有解决，就是应用要部署到哪个云账号上？这时就需要账号功能了。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">在账号方面，对于接口编程访问，云厂商都是通过 AccessKeyId 和 AccessKeySecret 来授权的。你可以提供一个命令，让用户输入自己的云账号 AccessKeyId 和 AccessKeySecret，然后把账号信息保存到用户自己的磁盘上。这样应用部署的时候，你就可以从磁盘上读取账号信息，以用户的账号去调用 FaaS 平台的接口。这样就可以把应用部署到用户云账号下了，并且账号信息是存储在用户自己的磁盘上，也没有安全问题。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">除此之外，我认为一个优秀的 Serverless 开发框架，还应该具备多种不同 Serverless 平台或云厂商的支持，因为你不能限制用户只使用某一种云服务。Serverless 开发框架最好还要抹平不同 Serverless 平台的差异，让应用能够在不同 Serverless 平台中进行平滑迁移，甚至让开发者使用一个开发框架、一套开发流程就能实现多云部署。而这，正是一个 Serverless 开发框架的核心竞争力之一。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">当然，要支持多种 Serverless 平台，就需要在框架层去适配各个不同的平台。但现在各个 Serverless 平台都没有遵循统一的标准，这也是实现一个多平台支持的难点所在。 所以你在实现一个开发框架时，需要先抽象出各个平台公共部分，然后制订一套你的开发标准，再以适配器的方式去适配不同的 Serverless 平台。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Serverless 框架架构
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">至此，你就完成了一个完整的 Serverless 开发框架的设计。在 Serverless 框架架构中，你通过一个 serverless 命令对开发者提供所有服务，贯穿 Serverless 应用开发到上线的全流程。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这其实也是现在主流 Serverless 开发框架的实现原理。接下来，就让我带你看一下主流 Serverless 开发框架的实现细节、功能特性和使用方法，从而让你对 Serverless 开发框架的原理和实现有更多了解。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">主流 Serverless 开发框架的实现
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">整体而言，国外 Serverless 生态要比国内领先一到两年，因此国外有很多优秀的开发框架，但国内这方面还不够成熟，所以我就讲解一下国内外最具代表性的两个开发框架，Serverless Framework和函数计算 Fun。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">我会按照以下顺序讲解这部分内容：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Serverless Framework
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">说到 Serverless，就不得不说 Serverless Framework ，我认为这是目前最完善的 Serverless 开发框架之一。它不仅实现了前面提到的应用开发、调试、部署等基础功能，还实现了多个 Serverless 平台的支持（因为它不仅支持 AWS、Azure、Google、阿里云、腾讯云等公有云 Serverless 平台，还支持 CloudFlare、Kubeless、OpenWhisk 等私有 Serverless 平台）。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">安装
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Serverless Framework 是使用 Node.js 开发的，所以你可以使用 npm 直接来安装它，安装后你就可以直接使用 serverless 这个命令了（好巧，跟我们前面设计的开发框架的命令一样）。
</span></span></code></pre></td></tr></table>
</div>
</div><p>$ npm install -g serverless
$ serverless &ndash;version
Framework Core: 2.15.0
Plugin: 4.2.0
SDK: 2.3.2
Components: 3.4.3</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">账号设置
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">你在使用 Serverless 时，第一件事就进行账号设置，假设你使用 AWS 则命令如下：
</span></span></code></pre></td></tr></table>
</div>
</div><p>$ serverless config credentials &ndash;provider aws &ndash;key key &ndash;secret secret</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">\--provider 具体的 Serverless 平台
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">\--key AWS 账号的 aws\_access\_key\_id
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">\--secret AWS 账号的 aws\_secret\_access\_key
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Serverless Framework 会把 AWS 的 aws\_access\_key\_id 和 aws\_secret\_access\_key 保存在 ~/.aws/credentials文件中。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">在 Serverless Framework 中，通过 provider 来实现不同平台的支持。在不同 provider 中， Serverless Framework 的命令大部分相同，但不同 provider 的功能完整性还是有一定差异，比如它虽然支持阿里云 provider，但目前只支持 HTTP 触发器和 OSS 触发器。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">应用配置
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">接下来你就可以使用 serverless 初始化一个应用了：
</span></span></code></pre></td></tr></table>
</div>
</div><p>$ serverless create &ndash;template aws-nodejs
Serverless: Generating boilerplate&hellip;</p>
<hr>
<p>|   _   .&mdash;&ndash;.&mdash;-.&ndash;.&ndash;.&mdash;&ndash;.&mdash;-|  .&mdash;&ndash;.&mdash;&ndash;.&mdash;&ndash;.
|   |<em><strong>|  -</strong>|   _|  |  |  -</em><em>|   _|  |  -</em><em>|</em>_ &ndash;|__ &ndash;|
|____   |<em><strong><strong>|</strong>|  _</strong>/|</em><strong><strong>|</strong>| |</strong>|<em><strong><strong>|</strong></strong></em>|_____|
|   |   |             The Serverless Application Framework
|       |                           serverless.com, v2.15.0
&mdash;&mdash;-'
Serverless: Successfully generated boilerplate for template: &ldquo;aws-nodejs&rdquo;
Serverless: NOTE: Please update the &ldquo;service&rdquo; property in serverless.yml with your service name
$ ls
handler.js    serverless.yml</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Serverless Framework 也是通过 YAML 配置文件来定义应用和函数的，其 YAML 格式如下：
</span></span></code></pre></td></tr></table>
</div>
</div><p>service: myservice
frameworkVersion: &lsquo;2&rsquo;
provider:
name: aws
runtime: nodejs12.x
functions:
hello:
handler: handler.hello
events:
- http:
path: users/create
method: get
- websocket: $connect
- s3: ${env:BUCKET}
resources:
Resources:
NewResource:
Type: AWS::S3::Bucket
Properties:
BucketName: my-new-bucket
Outputs:
NewOutput:
Description: &ldquo;Description for the output&rdquo;
Value: &ldquo;Some output value&rdquo;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">在这份 YAML 中，有一个前面没有提到过的属性 resources，resources 的作用就是帮你创建或更新资源（如果资源不存在则创建，如果资源已存在则更新）。比如示例中，就是为你创建一个 AWS 的 S3 存储桶。之所以会有 resources 属性，是因为通常一个应用都需要依赖其他云服务，比如存储、数据库等，之前你可能都是手动在云厂商的控制台去购买这些资源，一旦应用需要扩容的时候，手动创建资源就非常复杂且容易出错。Serverless Framework 则给你一种新的方式去管理云上资源，即通过代码来描述基础基础设施。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">应用调试
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">在 Serverless Framework 中，调试函数也很简单，直接通过 invoke 命令即可：
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="远程调试">远程调试</h1>
<p>$ serverless invoke &ndash;function hello
{
&ldquo;statusCode&rdquo;: 200,
&ldquo;body&rdquo;: &ldquo;{\n  &quot;message&quot;: &quot;Go Serverless v1.0! Your function executed successfully!&quot;,\n  &quot;input&quot;: &quot;&quot;\n}&rdquo;
}</p>
<h1 id="本地调试">本地调试</h1>
<p>$ serverless invoke local &ndash;function hello
{
&ldquo;statusCode&rdquo;: 200,
&ldquo;body&rdquo;: &ldquo;{\n  &quot;message&quot;: &quot;Go Serverless v1.0! Your function executed successfully!&quot;,\n  &quot;input&quot;: &quot;&quot;\n}&rdquo;
}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">当然了，你也可以通过 serverless invoke local 来实现本地调试。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">应用部署
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">应用开发完成后，你就可以使用 deploy 命令来部署应用，如下所示：
</span></span></code></pre></td></tr></table>
</div>
</div><p>$ serverless deploy
Serverless: Packaging service&hellip;
Serverless: Excluding development dependencies&hellip;
Serverless: Service files not changed. Skipping deployment&hellip;
Service Information
service: myservice
stage: dev
region: us-east-1
stack: myservice-dev
resources: 6
functions:
hello: myservice-dev-hello
layers:
None
$ tree
|&ndash; .serverless
|&ndash; myservice.zip
|&ndash; handler.js
|&ndash; serverless.yaml</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">在将函数部署到 Lambda 之前，serverless 会先在本地将代码打包，最终代码是一个压缩包，路径为 .serverles/\[serviceName\].zip 。你也可以通过 serverless deploy function -f functionName 来单独部署某个函数。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">除此之外，Serverless Framework 还提供了日志查询功能，当然，Serverless Framework 的功能不止于此（但因为不是这一讲的重点，所以我想留给你去探索），接下来我们再来了解一下，函数计算 Fun 的基本功能和使用，看看它和 Serverless Framework 有什么差异。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">函数计算 Fun
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Fun 是阿里云函数计算团队开发维护的一个 Serverles 开发框架，因此只支持函数计算。因为它是用 Node.js 编写的，所以也可以使用 npm 安装：
</span></span></code></pre></td></tr></table>
</div>
</div><p>$ npm install @alicloud/fun -g
$ fun &ndash;version
3.6.20</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">安装后第一步同样是设置账号：
</span></span></code></pre></td></tr></table>
</div>
</div><p>$ fun config
? Aliyun Account ID *******
? Aliyun Access Key ID ******
? Aliyun Access Key Secret ******
? Default region name cn-hangzhou
$ cat ~/.fcli/config.yaml
endpoint: &lsquo;https://******.cn-hangzhou.fc.aliyuncs.com&rsquo;
api_version: &lsquo;2016-08-15&rsquo;
access_key_id: ******
access_key_secret: ******
security_token: &rsquo;'
debug: false
timeout: 10
retries: 3
sls_endpoint: cn-hangzhou.log.aliyuncs.com
report: true
enable_custom_endpoint: false</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">配置完成后，fun 会将账号信息存储在.fcli/config.yaml 文件中。除此之外，你也可以在项目根目录中使用 .env文件来配置账号信息，其优先级更高。
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="项目根目录-env">项目根目录 .env</h1>
<p>ACCOUNT_ID=*****
REGION=cn-hangzhou
ACCESS_KEY_ID=******
ACCESS_KEY_SECRET=******
TIMEOUT=10
RETRIES=3
FC_ENDPOINT=******
ENABLE_CUSTOM_ENDPOINT=false</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">在应用配置上， 你可以通过 fun init 
</span></span><span class="line"><span class="cl">&lt;templateName&gt;
</span></span><span class="line"><span class="cl">命令来初始化一个项目：
</span></span></code></pre></td></tr></table>
</div>
</div><p>$ fun init event-nodejs12
$ ls -l
index.js    template.yaml</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">其中  template.yaml 功能与 serverless.yaml 一致，但内容定义有较大差异。template.yaml 的定义如下：
</span></span></code></pre></td></tr></table>
</div>
</div><p>ROSTemplateFormatVersion: &lsquo;2015-09-01&rsquo;
Transform: &lsquo;Aliyun::Serverless-2018-04-03&rsquo;
Resources:
myservice:
Type: &lsquo;Aliyun::Serverless::Service&rsquo;
Properties:
Description: &lsquo;helloworld&rsquo;
hello:
Type: &lsquo;Aliyun::Serverless::Function&rsquo;
Properties:
Handler: index.handler
Runtime: nodejs12
CodeUri: &lsquo;./&rsquo;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">其中 Resources 是表示资源的对象，对象的属性就是具体资源，对象属性中的Type 用来表示资源的类型。比如 Aliyun::Serverless::Service就表示是“服务”，Aliyun::Serverless::Function 表示函数。因此 template.yaml 中你可以定义多个服务，一个服务中也可以定义多个函数。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">接下来，你可以通过 fun invoke functionName 命令对函数进行远程调试：
</span></span></code></pre></td></tr></table>
</div>
</div><p>$ fun invoke hello
using template: template.yml
========= FC invoke Logs begin =========
FC Invoke Start RequestId: c6abf471-949a-4bbc-9edf-35e4c312a974
load code for handler:index.handler
2020-12-06T14:19:11.353Z c6abf471-949a-4bbc-9edf-35e4c312a974 [verbose] hello world
FC Invoke End RequestId: c6abf471-949a-4bbc-9edf-35e4c312a974
Duration: 13.99 ms, Billed Duration: 100 ms, Memory Size: 128 MB, Max Memory Used: 17.30 MB
========= FC invoke Logs end =========
FC Invoke Result:
hello world</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">当然，你也可以通过fun local invoke function 在本地调试。但本地调试前，你必须先安装 Docker，因为 fun 的本地调试原理是通过 Docker 在本地启动一个代码运行环境来执行代码，而不是直接模拟函数参数。这样的好处是，更接近 FaaS 平台的运行环境。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">应用开发完毕后，你可以通过 fun deploy 进行应用部署。
</span></span></code></pre></td></tr></table>
</div>
</div><p>$ fun fun deploy
using template: template.yml
using region: cn-hangzhou
using accountId: ***********4698
using accessKeyId: ***********QliF
using timeout: 10
Waiting for service myservice to be deployed&hellip;
Waiting for function hello to be deployed&hellip;
Waiting for packaging function hello code&hellip;
The function hello has been packaged. A total of 1 file were compressed and the final size was 318 B
function hello deploy success
service myservice deploy success</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">总结
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">在我看来，开发框架的意义就在于帮助开发者提升 Serverless 应用的开发效率， 因此一个 Serverless 开发框架最主要的就是要实现应用管理、应用调试、应用部署等功能。而在Serverless Framework 和 Fun 这两个开发框架中：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Serverless Framework 特点是功能完善、支持平台丰富。但由于 Serverless 平台尚且没有统一标准，所以支持多平台难度极大，也导致其对国内产品支持不够友好；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Fun 的特点是只为函数计算服务，因此有很多针对函数计算的特定功能。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">除了 Serverless Framework 外，国外还有 Vercel、Apex Up 等非常优秀的 Serverless 开发框架，Vercel 的前生就是 now.sh ，Apex Up 则是 Node.js 领域的 TJ 大神 2016 年就开始开发的产品。而国内除了 Fun，现在也有 Midway FaaS、Malagu 等新兴产品出现，这些产品虽然没有国外产品功能完善，但相信随着时间的推移，国内的 Serverless 开发体验也一定会越来越好。也是由于国内 Serverless 生态还不够完善，所以我们才有更多的机会，也希望你也能一起参与进来，为国内 Serverless 开发生态做出贡献。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">另一方面，现在绝大部分 Serverless 开发框架都是基于 Node.js 实现，并且大部分都是对 Node.js 编写语言支持最友好，甚至只支持 Node.js，这也能看出 Node.js 在 Serverless 领域的重要性。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">关于这节课，我想强调这几个点：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">与 FaaS、BaaS 等基础技术一样，Serverless 开发框架也是 Serverless 领域中的非常重要的一部分；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">一个优秀的 Serverless 开发框架，可以让开发者很容易开发一个 Serverless 架构的应用，也能让企业轻易将现有业务演化到 Serverless 架构；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Serverless 开发框架需要具备的基本能力是应用管理、应用调试和应用部署。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">最后，这节课我留给你的作业时，亲自体验一下本文中提到的各个开发框架，进而对 Serverless 的开发体系有更深的了解。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">\--- ### 精选评论
</span></span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%8E%A9%E8%BD%ACserverless%E6%9E%B6%E6%9E%84/">玩转Serverless架构</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%81%8C%E5%9C%BA%E6%B1%82%E7%94%9F%E6%94%BB%E7%95%A5/05%E4%B8%A8%E8%B4%A3%E4%BB%BB%E7%9A%84%E8%BE%B9%E7%95%8C%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E8%B4%A3%E8%8C%83%E5%9B%B4%E4%BB%85%E4%BB%85%E5%8F%AA%E6%98%AF%E8%A2%AB%E5%AE%89%E6%8E%92%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%90%97/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">05丨责任的边界：程序员的职责范围仅仅只是被安排的任务吗？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/05%E9%93%BE%E8%A1%A8%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%81%87%E5%A4%B4%E6%96%B0%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E5%86%B3%E9%93%BE%E8%A1%A8%E9%A2%98%E4%B8%8B/">
            <span class="next-text nav-default">05链表：如何利用“假头、新链表、双指针”解决链表题？（下）</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
