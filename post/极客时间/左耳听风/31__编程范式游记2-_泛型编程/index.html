<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>31__编程范式游记（2）-_泛型编程 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="上一篇文章中，我从 C 语言开始说起，聊了聊面向过程式的编程范式，相信从代码的角度你对这类型的语言已经有了一些理解。作为一门高级语言，C 语言绝对是编程语言历史发展中的一个重要里程碑，但随着认知的升级，面向过程的 C 语言已经无法满足更高层次的编程的需要。于是，C&#43;&#43; 出现了。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/31__%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B02-_%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/31__%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B02-_%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="31__编程范式游记（2）-_泛型编程">
  <meta property="og:description" content="上一篇文章中，我从 C 语言开始说起，聊了聊面向过程式的编程范式，相信从代码的角度你对这类型的语言已经有了一些理解。作为一门高级语言，C 语言绝对是编程语言历史发展中的一个重要里程碑，但随着认知的升级，面向过程的 C 语言已经无法满足更高层次的编程的需要。于是，C&#43;&#43; 出现了。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="左耳听风">

  <meta itemprop="name" content="31__编程范式游记（2）-_泛型编程">
  <meta itemprop="description" content="上一篇文章中，我从 C 语言开始说起，聊了聊面向过程式的编程范式，相信从代码的角度你对这类型的语言已经有了一些理解。作为一门高级语言，C 语言绝对是编程语言历史发展中的一个重要里程碑，但随着认知的升级，面向过程的 C 语言已经无法满足更高层次的编程的需要。于是，C&#43;&#43; 出现了。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6023">
  <meta itemprop="keywords" content="左耳听风">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="31__编程范式游记（2）-_泛型编程">
  <meta name="twitter:description" content="上一篇文章中，我从 C 语言开始说起，聊了聊面向过程式的编程范式，相信从代码的角度你对这类型的语言已经有了一些理解。作为一门高级语言，C 语言绝对是编程语言历史发展中的一个重要里程碑，但随着认知的升级，面向过程的 C 语言已经无法满足更高层次的编程的需要。于是，C&#43;&#43; 出现了。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">31__编程范式游记（2）-_泛型编程</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6023 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#c-语言">C++ 语言</a></li>
    <li><a href="#c-泛型编程">C++ 泛型编程</a>
      <ul>
        <li><a href="#c-泛型编程的示例---search-函数">C++ 泛型编程的示例 - Search 函数</a></li>
        <li><a href="#c-泛型编程示例---sum-函数">C++ 泛型编程示例 - Sum 函数</a></li>
        <li><a href="#c-泛型编程的重要技术---迭代器">C++ 泛型编程的重要技术 - 迭代器</a></li>
      </ul>
    </li>
    <li><a href="#需要更多的抽象">需要更多的抽象</a>
      <ul>
        <li><a href="#更为复杂的需求">更为复杂的需求</a></li>
        <li><a href="#更高维度的抽象">更高维度的抽象</a>
          <ul>
            <li><a href="#reduce-函数">Reduce 函数</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#小结">小结</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>上一篇文章中，我从 C 语言开始说起，聊了聊面向过程式的编程范式，相信从代码的角度你对这类型的语言已经有了一些理解。作为一门高级语言，C 语言绝对是编程语言历史发展中的一个重要里程碑，但随着认知的升级，面向过程的 C 语言已经无法满足更高层次的编程的需要。于是，C++ 出现了。</p>
<h1 id="c-语言">C++ 语言</h1>
<p>1980 年，AT&amp;T 贝尔实验室的<strong>Bjarne Stroustrup</strong>创建的 C++ 语言横空出世，它既可以全面兼容 C 语言，又巧妙揉和了一些面向对象的编程理念。现在来看，不得不佩服 Stroustrup 的魄力。在这里，我也向你推荐一本书，书名是《C++ 语言的设计和演化》。</p>
<p>这本书系统介绍了 C++ 诞生的背景以及初衷，书的作者就是<a href="./362072.md">Stroustrup</a>本人，所以你可以非常详细地从语言创建者的角度了解他的设计思路和创新之旅。当然，就是在今天，C++ 这门语言也还有很多争议，这里我不细说。如果你感兴趣的话，可以看看我几年前在酷壳上发表的文章《<a href="./7992.md">C++ 的坑真的多吗？</a>》。</p>
<p>从语言角度来说，实际上早期 C++ 的许多工作是对 C 的强化和净化，并把完全兼容 C 作为强制性要求（这也是 C++ 复杂晦涩的原因，这点 Java 就干得比 C++ 彻底得多）。在 C89、C99 这两个 C 语言的标准中，有许多改进都是从 C++ 中引进的。</p>
<p>可见，C++ 对 C 语言的贡献非常之大。是的，因为 C++ 很大程度就是用来解决 C 语言中的各种问题和各种不方便的。比如：</p>
<ul>
<li>用引用来解决指针的问题。</li>
<li>用 namespace 来解决名字空间冲突的问题。</li>
<li>通过 try-catch 来解决检查返回值编程的问题。</li>
<li>用 class 来解决对象的创建、复制、销毁的问题，从而可以达到在结构体嵌套时可以深度复制的内存安全问题。</li>
<li>通过重载操作符来达到操作上的泛型。（比如，消除<a href="./301.md">上一篇文章</a>中提到的比较函数<code>cmpFn</code>，再比如用<code>&gt;&gt;</code>操作符消除<code>printf()</code>的数据类型不够泛型的问题。）</li>
<li>通过模板 template 和虚函数的多态以及运行时识别来达到更高层次的泛型和多态。</li>
<li>用 RAII、智能指针的方式，解决了 C 语言中因为需要释放资源而出现的那些非常 ugly 也很容易出错的代码的问题。</li>
<li>用 STL 解决了 C 语言中算法和数据结构的 N 多种坑。</li>
</ul>
<h1 id="c-泛型编程">C++ 泛型编程</h1>
<p>C++ 是支持编程范式最多的一门语言，它虽然解决了很多 C 语言的问题，但我个人觉得它最大的意义是解决了 C 语言泛型编程的问题。因为，我们可以看到一些 C++ 的标准规格说明书里，有一半以上都在说明 STL 的标准规格应该是什么样的，这说明泛型编程是 C++ 重点中的重点。</p>
<p>理想情况下，算法应是和数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作。算法只关心一个标准的实现。<strong>而对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求又是什么呢？</strong></p>
<p>我们来看看 C++ 是如何有效解决程序泛型问题的，我认为有三点。</p>
<p><strong>第一，它通过类的方式来解决</strong>。</p>
<ul>
<li>类里面会有构造函数、析构函数表示这个类的分配和释放。</li>
<li>还有它的拷贝构造函数，表示了对内存的复制。</li>
<li>还有重载操作符，像我们要去比较大于、等于、不等于。</li>
</ul>
<p>这样可以让一个用户自定义的数据类型和内建的那些数据类型就很一致了。</p>
<p><strong>第二，通过模板达到类型和算法的妥协</strong>。</p>
<ul>
<li>模板有点像 DSL，模板的特化会根据使用者的类型在编译时期生成那个模板的代码。</li>
<li>模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时的问题。</li>
</ul>
<p>模板很好地取代了 C 时代宏定义带来的问题。</p>
<p><strong>第三，通过虚函数和运行时类型识别</strong>。</p>
<ul>
<li>虚函数带来的多态在语义上可以支持“同一类”的类型泛型。</li>
<li>运行时类型识别技术可以做到在泛型时对具体类型的特殊处理。</li>
</ul>
<p>这样一来，就可以写出基于抽象接口的泛型。</p>
<p>拥有了这些 C++ 引入的技术，我们就可以做到 C 语言很难做到的泛型编程了。</p>
<p>正如前面说过的，一个良好的泛型编程需要解决如下几个泛型编程的问题：</p>
<ol>
<li>算法的泛型；</li>
<li>类型的泛型；</li>
<li>数据结构（数据容器）的泛型。</li>
</ol>
<h2 id="c-泛型编程的示例---search-函数">C++ 泛型编程的示例 - Search 函数</h2>
<p>就像前面的<code>search()</code>函数，里面的 <code>for(int i=0; i&lt;len; i++)</code> 这样的遍历方式，只能适用于<strong>顺序型的数据结构</strong>的方式迭代，如：array、set、queue、list 和 link 等。并不适用于<strong>非顺序型的数据结构</strong>。</p>
<p>如哈希表 hash table，二叉树 binary tree、图 graph 等这样数据不是按顺序存放的数据结构（数据容器）。所以，如果找不到一种<strong>泛型的数据结构的操作方式（如遍历、查找、增加、删除、修改……）</strong>，那么，任何的算法或是程序都不可能做到真正意义上的泛型。</p>
<p>除了<code>search()</code>函数的“遍历操作”之外，还有 search 函数的返回值，是一个整型的索引下标。这个整型的下标对于“顺序型的数据结构”是没有问题的，但是对于“非顺序的数据结构”，在语义上都存在问题。</p>
<p>比如，如果我要在一个 hash table 中查找一个 key，返回什么呢？一定不是返回“索引下标”，因为在 hash table 这样的数据结构中，数据的存放位置不是顺序的，而且还会因为容量不够的问题被重新 hash 后改变，所以返回数组下标是没有意义的。</p>
<p>对此，我们要把这个事做得泛型和通用一些。如果找到，返回找到的这个元素的一个指针（地址）会更靠谱一些。</p>
<p>所以，为了解决泛型的问题，我们需要动用以下几个 C++ 的技术。</p>
<ol>
<li>使用模板技术来抽象类型，这样可以写出类型无关的数据结构（数据容器）。</li>
<li>使用一个迭代器来遍历或是操作数据结构内的元素。</li>
</ol>
<p>我们来看一下 C++ 版的<code>search()</code>函数是什么样的。</p>
<p>先重温一下 C 语言版的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int search(void* a, size_t size, void* target, 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	size_t elem_size, int(*cmpFn)(void*, void*) )
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	for(int i=0; i&lt;size; i++) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if ( cmpFn (a + elem_size * i, target) == 0 ) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			return i;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return -1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们再来看一下 C++ 泛型版的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">template&lt;typename T, typename Iter&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Iter search(Iter pStart, Iter pEnd, T target) 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	for(Iter p = pStart; p != pEnd; p++) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		if ( *p == target ) 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			return p;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 C++ 的泛型版本中，我们可以看到：</p>
<ul>
<li>使用<code>typename T</code>抽象了数据结构中存储数据的类型。</li>
<li>使用<code>typename Iter</code>，这是不同的数据结构需要自己实现的“迭代器”，这样也就抽象掉了不同类型的数据结构。</li>
<li>然后，我们对数据容器的遍历使用了<code>Iter</code>中的<code>++</code>方法，这是数据容器需要重载的操作符，这样通过操作符重载也就泛型掉了遍历。</li>
<li>在函数的入参上使用了<code>pStart</code>和<code>pEnd</code>来表示遍历的起止。</li>
<li>使用<code>*Iter</code>来取得这个“指针”的内容。这也是通过重载 <code>*</code> 取值操作符来达到的泛型。</li>
</ul>
<p>当然，你可能会问，为什么我们不用标准接口<code>Iter.Next()</code>取代<code>++</code>，用<code>Iter.GetValue()</code>来取代<code>*</code>，而是通过重载操作符？其实这样做是为了兼容原有 C 语言的编程习惯。</p>
<p>说明一下，所谓的<code>Iter</code>，在实际代码中，就是像<code>vector&lt;int&gt;::iterator</code>或<code>map&lt;int, string&gt;::iterator</code>这样的东西。这是由相应的数据容器来实现和提供的。</p>
<p>注：下面是 C++ STL 中的<code>find()</code>函数的代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="n">InputIterator</span><span class="p">,</span> <span class="k">class</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">InputIterator</span> <span class="n">find</span> <span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">first</span><span class="o">!=</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="o">==</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="c-泛型编程示例---sum-函数">C++ 泛型编程示例 - Sum 函数</h2>
<p>也许你觉得到这一步，我们的泛型设计就完成了。其实，还远远不够。<code>search</code>函数只是一个开始，我们还有很多别的算法会让问题变得更为复杂。</p>
<p>我们再来看一个<code>sum()</code>函数。</p>
<p>先看 C 语言版：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">long sum(int *a, size_t size) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	long result = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	for(int i=0; i&lt;size; i++) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		result += a[i];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return result;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>再看一下 C++ 泛型的版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">template&lt;typename T, typename Iter&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">T sum(Iter pStart, Iter pEnd) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	T result = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	for(Iter p=pStart; p!=pEnd; p++) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		result += *p;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return result;	
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>你看到了什么样的问题？这个代码中最大的问题就是 <code>T result = 0;</code> 这条语句：</p>
<ul>
<li>那个<code>0</code>假设了类型是<code>int</code>；</li>
<li>那个<code>T</code>假设了 Iter 中出来的类型是<code>T</code>。</li>
</ul>
<p>这样的假设是有问题的，如果类型不一样，就会导致转型的问题，这会带来非常 buggy 的代码。那么，我们怎么解决呢？</p>
<h2 id="c-泛型编程的重要技术---迭代器">C++ 泛型编程的重要技术 - 迭代器</h2>
<p>我们知道<code>Iter</code>在实际调用者那会是一个具体的像<code>vector&lt;int&gt;::iterator</code>这样的东西。在这个声明中，<code>int</code>已经被传入<code>Iter</code>中了。所以，定义<code>result</code>的<code>T</code>应该可以从<code>Iter</code>中来。这样就可以保证类型是一样的，而且不会有被转型的问题。</p>
<p>所以，我们需要精心地实现一个“迭代器”。下面是一个“精简版”的迭代器（我没有把 C++ STL 代码里的迭代器列出来，是因为代码太多太复杂，我这里只是为了说明问题）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="n">container</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">class</span> <span class="n">iterator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">typedef</span> <span class="n">iterator</span> <span class="n">self_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">typedef</span> <span class="n">T</span>   <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">typedef</span> <span class="n">T</span><span class="o">*</span>  <span class="n">pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">typedef</span> <span class="n">T</span><span class="o">&amp;</span> 	<span class="n">reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 		<span class="n">reference</span> <span class="n">operator</span><span class="o">*</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">pointer</span> <span class="n">operator</span><span class="o">-&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="ne">bool</span> <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">self_type</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span><span class="err">；</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="ne">bool</span> <span class="n">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">self_type</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span><span class="err">；</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">self_type</span> <span class="n">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span> <span class="n">self_type</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span> <span class="n">ptr_</span><span class="o">++</span><span class="p">;</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">self_type</span> <span class="n">operator</span><span class="o">++</span><span class="p">(</span><span class="ne">int</span> <span class="n">junk</span><span class="p">)</span> <span class="p">{</span> <span class="n">ptr_</span><span class="o">++</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">pointer</span> <span class="n">_ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	<span class="n">iterator</span> <span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">iterator</span> <span class="n">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的代码是我写的一个迭代器（这个迭代器在语义上是没有问题的），我没有把所有的代码列出来，而把它的一些基本思路列了出来。这里我说明一下几个关键点。</p>
<ul>
<li>首先，一个迭代器需要和一个容器在一起，因为里面是对这个容器的具体的代码实现。</li>
<li>它需要重载一些操作符，比如：取值操作<code>*</code>、成员操作<code>-&gt;</code>、比较操作<code>==</code>和<code>!=</code>，还有遍历操作<code>++</code>，等等。</li>
<li>然后，还要<code>typedef</code>一些类型，比如<code>value_type</code>，告诉我们容器内的数据的实际类型是什么样子。</li>
<li>还有一些，如<code>begin()</code>和<code>end()</code>的基本操作。</li>
<li>我们还可以看到其中有一个<code>pointer _ptr</code>的内部指针来指向当前的数据（注意，<code>pointer</code>就是 <code>T*</code>）。</li>
</ul>
<p>好了，有了这个迭代器后，我们还要解决<code>T result = 0</code>后面的这个<code>0</code>的问题。这个事，算法没有办法搞定，最好由用户传入。于是出现了下面最终泛型的<code>sum()</code>版函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">template &lt;class Iter&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">typename Iter::value_type
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sum(Iter start, Iter end, T init) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	typename Iter::value_type result = init;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	while (start != end) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		result = result + *start;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		start++;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return result;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以看到<code>typename Iter::value_type result = init</code>这条语句是关键。我们解决了所有的问题。</p>
<p>我们如下使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">container&lt;int&gt; c;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">container&lt;int&gt;::iterator it = c.begin();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sum(c.begin(), c.end(), 0);
</span></span></code></pre></td></tr></table>
</div>
</div><p>这就是整个 STL 的泛型方法，其中包括：</p>
<ul>
<li>泛型的数据容器；</li>
<li>泛型数据容器的迭代器；</li>
<li>然后泛型的算法就很容易写了。</li>
</ul>
<h1 id="需要更多的抽象">需要更多的抽象</h1>
<h2 id="更为复杂的需求">更为复杂的需求</h2>
<p>但是，还能不能做到更为泛型呢？比如：如果我们有这样的一个数据结构 Employee，里面有 vacation 就是休假多少天，以及工资。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct Employee {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	string name;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	string id;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	int vacation;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	double salary；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在我想计算员工的总薪水，或是总休假天数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">vector&lt;Employee&gt; staff;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//total salary or total vacation days?
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sum(staff.begin(), staff.end(), 0);
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们的<code>sum</code>完全不知道怎么搞了，因为要累加的是<code>Employee</code>类中的不同字段，即便我们的 Employee 中重载了<code>+</code>操作，也不知道要加哪个字段。</p>
<p>另外，我们可能还会有：求平均值 average，求最小值 min，求最大值 max，求中位数 mean 等等。你会发现，算法写出来基本上都是一样的，只是其中的“累加”操作变成了另外一个操作。就这个例子而言，我想计算员工薪水里面最高的，和休假最少的，或者我想计算全部员工的总共休假多少天。那么面对这么多的需求，我们是否可以泛型一些呢？怎样解决这些问题呢？</p>
<h2 id="更高维度的抽象">更高维度的抽象</h2>
<p>要解决这个问题，我希望我的这个算法只管遍历，具体要干什么，那是业务逻辑，由外面的调用方来定义我就好了，和我无关。这样一来，代码的重用度就更高了。</p>
<p>下面是一个抽象度更高的版本，这个版本再叫<code>sum</code>就不太合适了。这个版本应该是<code>reduce</code>——用于把一个数组 reduce 成一个值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">template&lt;class Iter, class T, class Op&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">T reduce (Iter start, Iter end, T init, Op op) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	T result = init;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	while ( start != end ) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		result = op( result, *start );
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		start++;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return result;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的代码中，我们需要传一个函数进来。在 STL 中，它是个函数对象，我们还是这套算法，但是 result 不是像前面那样去加，是把整个迭代器值给你一个 operation，然后由它来做。我把这个方法又拿出去了，所以就会变成这个样子。</p>
<p>在 C++ STL 中，与我的这个 reduce 函数对应的函数名叫 <code>accumulate()</code>，其实际代码有两个版本。</p>
<p>第一个版本就是上面的版本，只不过是用<code>for</code>语句而不是<code>while</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">template&lt;class InputIt, class T&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">T accumulate(InputIt first, InputIt last, T init)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (; first != last; ++first) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        init = init + *first;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return init;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二个版本，更为抽象，因为需要传入一个“二元操作函数”——<code>BinaryOperation op</code>来做 accumulate。accumulate 的语义比 sum 更抽象了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">template&lt;class InputIt, class T, class BinaryOperation&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">T accumulate(InputIt first, InputIt last, T init, 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">             BinaryOperation op)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (; first != last; ++first) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        init = op(init, *first);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return init;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>来看看我们在使用中是什么样子的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">double sum_salaries = 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  reduce( staff.begin(), staff.end(), 0.0,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		  		    {return s + e.salary;}  );
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> double max_salary =
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  reduce( staff.begin(), staff.end(), 0.0,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		  		    {return s &gt; e.salary? s: e.salary; } );
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：我这里用了 C++ 的 lambda 表达式。</p>
<p>你可以很清楚地看到，reduce 这个函数就更通用了，具体要干什么样的事情呢？放在匿名函数里面，它会定义我，我只做一个 reduce。更抽象地来说，我就把一个数组，一个集合，变成一个值。怎么变成一个值呢？由这个函数来决定。</p>
<h3 id="reduce-函数">Reduce 函数</h3>
<p>我们来看看如何使用 reduce 和其它函数完成一个更为复杂的功能。</p>
<p>下面这个示例中，我先定义了一个函数对象<code>counter</code>。这个函数对象需要一个<code>Cond</code>的函数对象，它是个条件判断函数，如果满足条件，则加 1，否则加 0。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="n">T</span><span class="p">,</span> <span class="k">class</span> <span class="n">Cond</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">counter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">size_t</span> <span class="n">operator</span><span class="p">()(</span><span class="n">size_t</span> <span class="n">c</span><span class="p">,</span> <span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">c</span> <span class="o">+</span> <span class="p">(</span><span class="n">Cond</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="err">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，我用上面的<code>counter</code>函数对象和<code>reduce</code>函数共同来打造一个<code>counter_if</code>算法（当条件满足的时候我就记个数，也就是统计满足某个条件的个数），我们可以看到，就是一行代码的事。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">template&lt;class Iter, class Cond&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">size_t count_if(Iter begin, Iter end, Cond c){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	return reduce(begin, end, 0, 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				  counter&lt;Iter::value_type, Cond&gt;(c));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>至于是什么样的条件，这个属于业务逻辑，不是我的流程控制，所以，这应该交给使用方。</p>
<p>于是，当我需要统计薪资超过 1 万元的员工的数量时，一行代码就完成了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">size_t cnt = count_if(staff.begin(), staff.end(), 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">					{ return e.salary &gt; 10000; });
</span></span></code></pre></td></tr></table>
</div>
</div><p>Reduce 时可以只对结构体中的某些值做 Reduce，比如说只对 <code>salary&gt;10000</code> 的人做，只选出这个里面的值，它用 Reduce 就可以达到这步，只要传不同的方式给它，你就可以又造出一个新的东西出来。</p>
<p>说着说着，就到了函数式编程。函数式编程里面，我们可以用很多的像 reduce 这样的函数来完成更多的像 STL 里面的<code>count_if()</code>这样有具体意义的函数。关于函数式编程，我们会在后面继续具体聊。</p>
<h1 id="小结">小结</h1>
<p>在这篇文章中，我们聊到 C++ 语言是如何通过泛型来解决 C 语言遇到的问题，其实这里面主要就是泛型编程和函数式编程的基本方法相关的细节，虽然解决编程语言中类型带来的问题可能有多种方式，不一定就是 C++ 这种方式。</p>
<p>而我之所以从 C/C++ 开始，目的只是因为 C/C++ 都是比较偏底层的编程语言。从底层的原理上，我们可以更透彻地了解，从 C 到 C++ 的演进这一过程中带来的编程方式的变化。这可以让你看到，在静态类型语言方面解决泛型编程的一些技术和方法，从而感受到其中的奥妙和原理。</p>
<p><strong>因为形式是多样的，但是原理是相通的。所以，这个过程会非常有助于你更深刻地了解后面会谈到的更多的编程范式</strong>。</p>
<p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。<strong>这一系列文章中代码量很大，很难用音频体现出来，所以没有录制音频，还望谅解。</strong></p>
<ul>
<li><a href="./301.md">编程范式游记（1）- 起源</a></li>
<li><a href="./303.md">编程范式游记（2）- 泛型编程</a></li>
<li><a href="./2017.md">编程范式游记（3）- 类型系统和泛型的本质</a></li>
<li><a href="./2711.md">编程范式游记（4）- 函数式编程</a></li>
<li><a href="./2723.md">编程范式游记（5）- 修饰器模式</a></li>
<li><a href="./2729.md">编程范式游记（6）- 面向对象编程</a></li>
<li><a href="./2741.md">编程范式游记（7）- 基于原型的编程范式</a></li>
<li><a href="./2748.md">编程范式游记（8）- Go 语言的委托模式</a></li>
<li><a href="./2751.md">编程范式游记（9）- 编程的本质</a></li>
<li><a href="./2752.md">编程范式游记（10）- 逻辑编程范式</a></li>
<li><a href="./2754.md">编程范式游记（11）- 程序世界里的编程范式</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/1c1e992cf41f5294df097aabed82f9e4.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/">左耳听风</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2/31__sync.waitgroup%E5%92%8Csync.once/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">31__sync.WaitGroup和sync.Once</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kafka%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/31__%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC%E5%A4%A7%E6%B1%87%E6%80%BB/">
            <span class="next-text nav-default">31__常见工具脚本大汇总</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
