<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>98__项目实战三：设计实现一个支持自定义规则的灰度发布组件（实现） - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="上两节课，我们讲解了灰度组件的需求和设计思路。不管是之前讲过的限流、幂等框架，还是现在正在讲的灰度组件，这些框架、组件、类库的功能性需求都不复杂，相反，非功能性需求是开发的重点、难点。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/98__%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%89%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99%E7%9A%84%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/98__%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%89%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99%E7%9A%84%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="98__项目实战三：设计实现一个支持自定义规则的灰度发布组件（实现）">
  <meta property="og:description" content="上两节课，我们讲解了灰度组件的需求和设计思路。不管是之前讲过的限流、幂等框架，还是现在正在讲的灰度组件，这些框架、组件、类库的功能性需求都不复杂，相反，非功能性需求是开发的重点、难点。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="设计模式之美">

  <meta itemprop="name" content="98__项目实战三：设计实现一个支持自定义规则的灰度发布组件（实现）">
  <meta itemprop="description" content="上两节课，我们讲解了灰度组件的需求和设计思路。不管是之前讲过的限流、幂等框架，还是现在正在讲的灰度组件，这些框架、组件、类库的功能性需求都不复杂，相反，非功能性需求是开发的重点、难点。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4400">
  <meta itemprop="keywords" content="设计模式之美">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="98__项目实战三：设计实现一个支持自定义规则的灰度发布组件（实现）">
  <meta name="twitter:description" content="上两节课，我们讲解了灰度组件的需求和设计思路。不管是之前讲过的限流、幂等框架，还是现在正在讲的灰度组件，这些框架、组件、类库的功能性需求都不复杂，相反，非功能性需求是开发的重点、难点。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">98__项目实战三：设计实现一个支持自定义规则的灰度发布组件（实现）</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4400 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#灰度组件功能需求整理">灰度组件功能需求整理</a>
          <ul>
            <li><a href="#1-灰度规则的格式和存储方式">1. 灰度规则的格式和存储方式</a></li>
            <li><a href="#2-灰度规则的语法格式">2. 灰度规则的语法格式</a></li>
            <li><a href="#3-灰度规则的内存组织方式">3. 灰度规则的内存组织方式</a></li>
            <li><a href="#4-灰度规则热更新">4. 灰度规则热更新</a></li>
          </ul>
        </li>
        <li><a href="#实现灰度组件基本功能">实现灰度组件基本功能</a></li>
        <li><a href="#添加优化灰度组件功能">添加、优化灰度组件功能</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#课堂讨论">课堂讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>上两节课，我们讲解了灰度组件的需求和设计思路。不管是之前讲过的限流、幂等框架，还是现在正在讲的灰度组件，这些框架、组件、类库的功能性需求都不复杂，相反，非功能性需求是开发的重点、难点。</p>
<p>今天，我们按照上节课给出的灰度组件的设计思路，讲解如何进行编码实现。不过今天对实现的讲解，跟前面两个实战项目有所不同。在前面两个项目中，我都是手把手地从最基础的 MVP 代码讲起，然后讲解如何 review 代码发现问题、重构代码解决问题，最终得到一份还算高质量的代码。考虑到已经有前面两个项目的学习和锻炼了，你应该对开发套路、思考路径很熟悉了，所以，今天我们换个讲法，就不从最基础的讲起了，而是重点讲解实现思路。</p>
<p>话不多说，让我们正式开始今天的学习吧！</p>
<h2 id="灰度组件功能需求整理">灰度组件功能需求整理</h2>
<p>针对上两节课给出的开发需求和设计思路，我们还是按照老套路，从中剥离出 V1 版本要实现的内容。为了方便我讲解和你查看，我把灰度组件的开发需求和设计思路，重新整理罗列了一下，放到了这里。</p>
<h3 id="1-灰度规则的格式和存储方式">1. 灰度规则的格式和存储方式</h3>
<p>我们希望支持不同格式（JSON、YAML、XML 等）、不同存储方式（本地配置文件、Redis、Zookeeper、或者自研配置中心等）的灰度规则配置方式。实际上，这一点跟之前的限流框架中限流规则的格式和存储方式完全一致，代码实现也是相同的，所以在接下来的讲解中，就不重复啰嗦了，你可以回过头去看下第 92 讲。</p>
<h3 id="2-灰度规则的语法格式">2. 灰度规则的语法格式</h3>
<p>我们支持三种灰度规则语法格式：具体值（比如 893）、区间值（比如 1020-1120）、比例值（比如 %30）。除此之外，对于更加复杂的灰度规则，比如只对 30 天内购买过某某商品并且退货次数少于 10 次的用户进行灰度，我们通过编程的方式来实现。</p>
<h3 id="3-灰度规则的内存组织方式">3. 灰度规则的内存组织方式</h3>
<p>类似于限流框架中的限流规则，我们需要把灰度规则组织成支持快速查找的数据结构，能够快速判定某个灰度对象（darkTarget，比如用户 ID），是否落在灰度规则设定的范围内。</p>
<h3 id="4-灰度规则热更新">4. 灰度规则热更新</h3>
<p>修改了灰度规则之后，我们希望不重新部署和重启系统，新的灰度规则就能生效，所以，我们需要支持灰度规则热更新。</p>
<p>在 V1 版本中，对于第一点灰度规则的格式和存储方式，我们只支持 YAML 格式本地文件的配置存储方式。对于剩下的三点，我们都要进行实现。考虑到 V1 版本要实现的内容比较多，我们分两步来实现代码，第一步先将大的流程、框架搭建好，第二步再进一步添加、丰富、优化功能。</p>
<h2 id="实现灰度组件基本功能">实现灰度组件基本功能</h2>
<p>在第一步中，我们先实现基于 YAML 格式的本地文件的灰度规则配置方式，以及灰度规则热更新，并且只支持三种基本的灰度规则语法格式。基于编程实现灰度规则的方式，我们留在第二步实现。</p>
<p>我们先把这个基本功能的开发需求，用代码实现出来。它的目录结构及其 Demo 示例如下所示。代码非常简单，只包含 4 个类。接下来，我们针对每个类再详细讲解一下。</p>
<p>// 代码目录结构<br>
com.xzg.darklaunch<br>
&ndash;DarkLaunch(框架的最顶层入口类)<br>
&ndash;DarkFeature(每个 feature 的灰度规则)<br>
&ndash;DarkRule(灰度规则)<br>
&ndash;DarkRuleConfig(用来映射配置到内存中)</p>
<p>// Demo 示例<br>
public class DarkDemo {<br>
public static void main(String[] args) {<br>
DarkLaunch darkLaunch = new DarkLaunch();<br>
DarkFeature darkFeature = darkLaunch.getDarkFeature(&ldquo;call_newapi_getUserById&rdquo;);<br>
System.out.println(darkFeature.enabled());<br>
System.out.println(darkFeature.dark(893));<br>
}<br>
}</p>
<p>// 灰度规则配置 (dark-rule.yaml) 放置在 classpath 路径下<br>
features:</p>
<ul>
<li>key: call_newapi_getUserById<br>
enabled: true<br>
rule: {893,342,1020-1120,%30}</li>
<li>key: call_newapi_registerUser<br>
enabled: true<br>
rule: {1391198723, %10}</li>
<li>key: newalgo_loan<br>
enabled: true<br>
rule: {0-1000}</li>
</ul>
<p>从 Demo 代码中，我们可以看出，对于业务系统来说，灰度组件的两个直接使用的类是 DarkLaunch 类和 DarkFeature 类。</p>
<p>**我们先来看 DarkLaunch 类。**这个类是灰度组件的最顶层入口类。它用来组装其他类对象，串联整个操作流程，提供外部调用的接口。</p>
<p>DarkLaunch 类先读取灰度规则配置文件，映射为内存中的 Java 对象（DarkRuleConfig），然后再将这个中间结构，构建成一个支持快速查询的数据结构（DarkRule）。除此之外，它还负责定期更新灰度规则，也就是前面提到的灰度规则热更新。</p>
<p>为了避免更新规则和查询规则的并发执行冲突，在更新灰度规则的时候，我们并非直接操作老的 DarkRule，而是先创建一个新的 DarkRule，然后等新的 DarkRule 都构建好之后，再“瞬间”赋值给老的 DarkRule。你可以结合着下面的代码一块看下。</p>
<p>public class DarkLaunch {<br>
private static final Logger log = LoggerFactory.getLogger(DarkLaunch.class);<br>
private static final int DEFAULT_RULE_UPDATE_TIME_INTERVAL = 60; // in seconds<br>
private DarkRule rule;<br>
private ScheduledExecutorService executor;</p>
<p>public DarkLaunch(int ruleUpdateTimeInterval) {<br>
loadRule();<br>
this.executor = Executors.newSingleThreadScheduledExecutor();<br>
this.executor.scheduleAtFixedRate(new Runnable() {<br>
@Override<br>
public void run() {<br>
loadRule();<br>
}<br>
}, ruleUpdateTimeInterval, ruleUpdateTimeInterval, TimeUnit.SECONDS);<br>
}</p>
<p>public DarkLaunch() {<br>
this(DEFAULT_RULE_UPDATE_TIME_INTERVAL);<br>
}</p>
<p>private void loadRule() {<br>
// 将灰度规则配置文件 dark-rule.yaml 中的内容读取 DarkRuleConfig 中<br>
InputStream in = null;<br>
DarkRuleConfig ruleConfig = null;<br>
try {<br>
in = this.getClass().getResourceAsStream(&quot;/dark-rule.yaml&quot;);<br>
if (in != null) {<br>
Yaml yaml = new Yaml();<br>
ruleConfig = yaml.loadAs(in, DarkRuleConfig.class);<br>
}<br>
} finally {<br>
if (in != null) {<br>
try {<br>
in.close();<br>
} catch (IOException e) {<br>
log.error(&ldquo;close file error:{}&rdquo;, e);<br>
}<br>
}<br>
}</p>
<pre><code>if (ruleConfig == null) {  
  throw new RuntimeException(&quot;Can not load dark rule.&quot;);  
}  
// 更新规则并非直接在 this.rule 上进行，  
// 而是通过创建一个新的 DarkRule，然后赋值给 this.rule，  
// 来避免更新规则和规则查询的并发冲突问题  
DarkRule newRule = new DarkRule(ruleConfig);  
this.rule = newRule;  
</code></pre>
<p>}</p>
<p>public DarkFeature getDarkFeature(String featureKey) {<br>
DarkFeature darkFeature = this.rule.getDarkFeature(featureKey);<br>
return darkFeature;<br>
}<br>
}</p>
<p>**我们再来看下 DarkRuleConfig 类。**这个类功能非常简单，只是用来将灰度规则映射到内存中。具体的代码如下所示：</p>
<p>public class DarkRuleConfig {<br>
private List<DarkFeatureConfig> features;</p>
<p>public List<DarkFeatureConfig> getFeatures() {<br>
return this.features;<br>
}</p>
<p>public void setFeatures(List<DarkFeatureConfig> features) {<br>
this.features = features;<br>
}</p>
<p>public static class DarkFeatureConfig {<br>
private String key;<br>
private boolean enabled;<br>
private String rule;<br>
// 省略 getter、setter 方法<br>
}<br>
}</p>
<p>从代码中，我们可以看出来，DarkRuleConfig 类嵌套了一个内部类 DarkFeatureConfig。这两个类跟配置文件的两层嵌套结构完全对应。我把对应关系标注在了下面的示例中，你可以对照着代码看下。</p>
<!--对应 DarkRuleConfig-->  
<p>features:</p>
<ul>
<li>key: call_newapi_getUserById  <!--对应 DarkFeatureConfig--><br>
enabled: true<br>
rule: {893,342,1020-1120,%30}</li>
<li>key: call_newapi_registerUser <!--对应 DarkFeatureConfig--><br>
enabled: true<br>
rule: {1391198723, %10}</li>
<li>key: newalgo_loan             <!--对应 DarkFeatureConfig--><br>
enabled: true<br>
rule: {0-1000}</li>
</ul>
<p>**我们再来看下 DarkRule。**DarkRule 包含所有要灰度的业务功能的灰度规则。它用来支持根据业务功能标识（feature key），快速查询灰度规则（DarkFeature）。代码也比较简单，具体如下所示：</p>
<p>public class DarkRule {<br>
private Map&lt;String, DarkFeature&gt; darkFeatures = new HashMap&lt;&gt;();</p>
<p>public DarkRule(DarkRuleConfig darkRuleConfig) {<br>
List&lt;DarkRuleConfig.DarkFeatureConfig&gt; darkFeatureConfigs = darkRuleConfig.getFeatures();<br>
for (DarkRuleConfig.DarkFeatureConfig darkFeatureConfig : darkFeatureConfigs) {<br>
darkFeatures.put(darkFeatureConfig.getKey(), new DarkFeature(darkFeatureConfig));<br>
}<br>
}</p>
<p>public DarkFeature getDarkFeature(String featureKey) {<br>
return darkFeatures.get(featureKey);<br>
}<br>
}</p>
<p>**我们最后来看下 DarkFeature 类。**DarkFeature 类表示每个要灰度的业务功能的灰度规则。DarkFeature 将配置文件中灰度规则，解析成一定的结构（比如 RangeSet），方便快速判定某个灰度对象是否落在灰度规则范围内。具体的代码如下所示：</p>
<p>public class DarkFeature {<br>
private String key;<br>
private boolean enabled;<br>
private int percentage;<br>
private RangeSet<Long> rangeSet = TreeRangeSet.create();</p>
<p>public DarkFeature(DarkRuleConfig.DarkFeatureConfig darkFeatureConfig) {<br>
this.key = darkFeatureConfig.getKey();<br>
this.enabled = darkFeatureConfig.getEnabled();<br>
String darkRule = darkFeatureConfig.getRule().trim();<br>
parseDarkRule(darkRule);<br>
}</p>
<p>@VisibleForTesting<br>
protected void parseDarkRule(String darkRule) {<br>
if (!darkRule.startsWith(&quot;{&quot;) || !darkRule.endsWith(&quot;}&quot;)) {<br>
throw new RuntimeException(&ldquo;Failed to parse dark rule: &quot; + darkRule);<br>
}</p>
<pre><code>String[] rules = darkRule.substring(1, darkRule.length() - 1).split(&quot;,&quot;);  
this.rangeSet.clear();  
this.percentage = 0;  
for (String rule : rules) {  
  rule = rule.trim();  
  if (StringUtils.isEmpty(rule)) {  
    continue;  
  }  

  if (rule.startsWith(&quot;%&quot;)) {  
    int newPercentage = Integer.parseInt(rule.substring(1));  
    if (newPercentage &gt; this.percentage) {  
      this.percentage = newPercentage;  
    }  
  } else if (rule.contains(&quot;-&quot;)) {  
    String[] parts = rule.split(&quot;-&quot;);  
    if (parts.length != 2) {  
      throw new RuntimeException(&quot;Failed to parse dark rule: &quot; + darkRule);  
    }  
    long start = Long.parseLong(parts[0]);  
    long end = Long.parseLong(parts[1]);  
    if (start &gt; end) {  
      throw new RuntimeException(&quot;Failed to parse dark rule: &quot; + darkRule);  
    }  
    this.rangeSet.add(Range.closed(start, end));  
  } else {  
    long val = Long.parseLong(rule);  
    this.rangeSet.add(Range.closed(val, val));  
  }  
}  
</code></pre>
<p>}</p>
<p>public boolean enabled() {<br>
return this.enabled;<br>
}</p>
<p>public boolean dark(long darkTarget) {<br>
boolean selected = this.rangeSet.contains(darkTarget);<br>
if (selected) {<br>
return true;<br>
}</p>
<pre><code>long reminder = darkTarget % 100;  
if (reminder &gt;= 0 &amp;&amp; reminder &lt; this.percentage) {  
  return true;  
}  

return false;  
</code></pre>
<p>}</p>
<p>public boolean dark(String darkTarget) {<br>
long target = Long.parseLong(darkTarget);<br>
return dark(target);<br>
}<br>
}</p>
<h2 id="添加优化灰度组件功能">添加、优化灰度组件功能</h2>
<p>在第一步中，我们完成了灰度组件的基本功能。在第二步中，我们再实现基于编程的灰度规则配置方式，用来支持更加复杂、更加灵活的灰度规则。</p>
<p>我们需要对于第一步实现的代码，进行一些改造。改造之后的代码目录结构如下所示。其中，DarkFeature、DarkRuleConfig 的基本代码不变，新增了 IDarkFeature 接口，DarkLaunch、DarkRule 的代码有所改动，用来支持编程实现灰度规则。</p>
<p>// 第一步的代码目录结构<br>
com.xzg.darklaunch<br>
&ndash;DarkLaunch(框架的最顶层入口类)<br>
&ndash;DarkFeature(每个 feature 的灰度规则)<br>
&ndash;DarkRule(灰度规则)<br>
&ndash;DarkRuleConfig(用来映射配置到内存中)</p>
<p>// 第二步的代码目录结构<br>
com.xzg.darklaunch<br>
&ndash;DarkLaunch(框架的最顶层入口类，代码有改动)<br>
&ndash;IDarkFeature(抽象接口)<br>
&ndash;DarkFeature(实现 IDarkFeature 接口，基于配置文件的灰度规则，代码不变)<br>
&ndash;DarkRule(灰度规则，代码有改动)<br>
&ndash;DarkRuleConfig(用来映射配置到内存中，代码不变)</p>
<p>我们先来看下 IDarkFeature 接口，它用来抽象从配置文件中得到的灰度规则，以及编程实现的灰度规则。具体代码如下所示：</p>
<p>public interface IDarkFeature {<br>
boolean enabled();<br>
boolean dark(long darkTarget);<br>
boolean dark(String darkTarget);<br>
}</p>
<p>基于这个抽象接口，业务系统可以自己编程实现复杂的灰度规则，然后添加到 DarkRule 中。为了避免配置文件中的灰度规则热更新时，覆盖掉编程实现的灰度规则，在 DarkRule 中，我们对从配置文件中加载的灰度规则和编程实现的灰度规则分开存储。按照这个设计思路，我们对 DarkRule 类进行重构。重构之后的代码如下所示：</p>
<p>public class DarkRule {<br>
// 从配置文件中加载的灰度规则<br>
private Map&lt;String, IDarkFeature&gt; darkFeatures = new HashMap&lt;&gt;();<br>
// 编程实现的灰度规则<br>
private ConcurrentHashMap&lt;String, IDarkFeature&gt; programmedDarkFeatures = new ConcurrentHashMap&lt;&gt;();</p>
<p>public void addProgrammedDarkFeature(String featureKey, IDarkFeature darkFeature) {<br>
programmedDarkFeatures.put(featureKey, darkFeature);<br>
}</p>
<p>public void setDarkFeatures(Map&lt;String, IDarkFeature&gt; newDarkFeatures) {<br>
this.darkFeatures = newDarkFeatures;<br>
}</p>
<p>public IDarkFeature getDarkFeature(String featureKey) {<br>
IDarkFeature darkFeature = programmedDarkFeatures.get(featureKey);<br>
if (darkFeature != null) {<br>
return darkFeature;<br>
}<br>
return darkFeatures.get(featureKey);<br>
}<br>
}</p>
<p>因为 DarkRule 代码有所修改，对应地，DarkLaunch 的代码也需要做少许改动，主要有一处修改和一处新增代码，具体如下所示，我在代码中都做了注释，就不再重复解释了。</p>
<p>public class DarkLaunch {<br>
private static final Logger log = LoggerFactory.getLogger(DarkLaunch.class);<br>
private static final int DEFAULT_RULE_UPDATE_TIME_INTERVAL = 60; // in seconds<br>
private DarkRule rule = new DarkRule();<br>
private ScheduledExecutorService executor;</p>
<p>public DarkLaunch(int ruleUpdateTimeInterval) {<br>
loadRule();<br>
this.executor = Executors.newSingleThreadScheduledExecutor();<br>
this.executor.scheduleAtFixedRate(new Runnable() {<br>
@Override<br>
public void run() {<br>
loadRule();<br>
}<br>
}, ruleUpdateTimeInterval, ruleUpdateTimeInterval, TimeUnit.SECONDS);<br>
}</p>
<p>public DarkLaunch() {<br>
this(DEFAULT_RULE_UPDATE_TIME_INTERVAL);<br>
}</p>
<p>private void loadRule() {<br>
InputStream in = null;<br>
DarkRuleConfig ruleConfig = null;<br>
try {<br>
in = this.getClass().getResourceAsStream(&quot;/dark-rule.yaml&rdquo;);<br>
if (in != null) {<br>
Yaml yaml = new Yaml();<br>
ruleConfig = yaml.loadAs(in, DarkRuleConfig.class);<br>
}<br>
} finally {<br>
if (in != null) {<br>
try {<br>
in.close();<br>
} catch (IOException e) {<br>
log.error(&ldquo;close file error:{}&rdquo;, e);<br>
}<br>
}<br>
}</p>
<pre><code>if (ruleConfig == null) {  
  throw new RuntimeException(&quot;Can not load dark rule.&quot;);  
}  
  
// 修改：单独更新从配置文件中得到的灰度规则，不覆盖编程实现的灰度规则  
Map&lt;String, IDarkFeature&gt; darkFeatures = new HashMap&lt;&gt;();  
List&lt;DarkRuleConfig.DarkFeatureConfig&gt; darkFeatureConfigs = ruleConfig.getFeatures();  
for (DarkRuleConfig.DarkFeatureConfig darkFeatureConfig : darkFeatureConfigs) {  
  darkFeatures.put(darkFeatureConfig.getKey(), new DarkFeature(darkFeatureConfig));  
}  
this.rule.setDarkFeatures(darkFeatures);  
</code></pre>
<p>}</p>
<p>// 新增：添加编程实现的灰度规则的接口<br>
public void addProgrammedDarkFeature(String featureKey, IDarkFeature darkFeature) {<br>
this.rule.addProgrammedDarkFeature(featureKey, darkFeature);<br>
}</p>
<p>public IDarkFeature getDarkFeature(String featureKey) {<br>
IDarkFeature darkFeature = this.rule.getDarkFeature(featureKey);<br>
return darkFeature;<br>
}<br>
}</p>
<p>灰度组件的代码实现就讲完了。我们再通过一个 Demo 来看下，目前实现的灰度组件该如何使用。结合着 Demo，再去理解上面的代码，会更容易些。Demo 代码如下所示：</p>
<p>// 灰度规则配置 (dark-rule.yaml)，放到 classpath 路径下<br>
features:</p>
<ul>
<li>key: call_newapi_getUserById<br>
enabled: true<br>
rule: {893,342,1020-1120,%30}</li>
<li>key: call_newapi_registerUser<br>
enabled: true<br>
rule: {1391198723, %10}</li>
<li>key: newalgo_loan<br>
enabled: true<br>
rule: {0-100}</li>
</ul>
<p>// 编程实现的灰度规则<br>
public class UserPromotionDarkRule implements IDarkFeature {<br>
@Override<br>
public boolean enabled() {<br>
return true;<br>
}</p>
<p>@Override<br>
public boolean dark(long darkTarget) {<br>
// 灰度规则自己想怎么写就怎么写<br>
return false;<br>
}</p>
<p>@Override<br>
public boolean dark(String darkTarget) {<br>
// 灰度规则自己想怎么写就怎么写<br>
return false;<br>
}<br>
}</p>
<p>// Demo<br>
public class Demo {<br>
public static void main(String[] args) {<br>
DarkLaunch darkLaunch = new DarkLaunch(); // 默认加载 classpath 下 dark-rule.yaml 文件中的灰度规则<br>
darkLaunch.addProgrammedDarkFeature(&ldquo;user_promotion&rdquo;, new UserPromotionDarkRule()); // 添加编程实现的灰度规则<br>
IDarkFeature darkFeature = darkLaunch.getDarkFeature(&ldquo;user_promotion&rdquo;);<br>
System.out.println(darkFeature.enabled());<br>
System.out.println(darkFeature.dark(893));<br>
}<br>
}</p>
<h2 id="重点回顾">重点回顾</h2>
<p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p>
<p>到今天为止，项目实战环节就彻底结束了。在这一部分中，我们通过限流、幂等、灰度这三个实战项目，带你从需求分析、系统设计、代码实现这三个环节，学习了如何进行功能性、非功能性需求分析，如何通过合理的设计，完成功能性需求的同时，满足非功能性需求，以及如何编写高质量的代码实现。</p>
<p>实际上，项目本身的分析、设计、实现并不重要，不必对细节过于纠结。我希望通过这三个例子，分享我的思考路径、开发套路，让你借鉴并举一反三地应用到你平时的项目开发中。我觉得这才是最有价值的，才是你学习的重点。</p>
<p>如果你学完这一部分之后，对于项目中的一些通用的功能，能够开始下意识地主动思考代码复用的问题，考虑如何抽象成框架、类库、组件，并且对于如何开发，也不再觉得无从下手，而是觉得有章可循，那我觉得你就学到了这一部分的精髓。</p>
<h2 id="课堂讨论">课堂讨论</h2>
<p>在 DarkFeature 类中，灰度规则的解析代码设计的不够优雅，你觉得问题在哪里呢？又该如何重构呢？</p>
<p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/">设计模式之美</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/98__%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E5%92%8C%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">98__高效学习：如何学习和阅读代码</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/">
            <span class="next-text nav-default">98-设计模式之美</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
