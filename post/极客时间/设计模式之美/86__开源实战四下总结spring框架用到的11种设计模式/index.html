<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>86__开源实战四（下）：总结Spring框架用到的11种设计模式 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="上一节课，我们讲解了 Spring 中支持扩展功能的两种设计模式：观察者模式和模板模式。这两种模式能够帮助我们创建扩展点，让框架的使用者在不修改源码的情况下，基于扩展点定制化框架功能。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/86__%E5%BC%80%E6%BA%90%E5%AE%9E%E6%88%98%E5%9B%9B%E4%B8%8B%E6%80%BB%E7%BB%93spring%E6%A1%86%E6%9E%B6%E7%94%A8%E5%88%B0%E7%9A%8411%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/86__%E5%BC%80%E6%BA%90%E5%AE%9E%E6%88%98%E5%9B%9B%E4%B8%8B%E6%80%BB%E7%BB%93spring%E6%A1%86%E6%9E%B6%E7%94%A8%E5%88%B0%E7%9A%8411%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="86__开源实战四（下）：总结Spring框架用到的11种设计模式">
  <meta property="og:description" content="上一节课，我们讲解了 Spring 中支持扩展功能的两种设计模式：观察者模式和模板模式。这两种模式能够帮助我们创建扩展点，让框架的使用者在不修改源码的情况下，基于扩展点定制化框架功能。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="设计模式之美">

  <meta itemprop="name" content="86__开源实战四（下）：总结Spring框架用到的11种设计模式">
  <meta itemprop="description" content="上一节课，我们讲解了 Spring 中支持扩展功能的两种设计模式：观察者模式和模板模式。这两种模式能够帮助我们创建扩展点，让框架的使用者在不修改源码的情况下，基于扩展点定制化框架功能。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5596">
  <meta itemprop="keywords" content="设计模式之美">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="86__开源实战四（下）：总结Spring框架用到的11种设计模式">
  <meta name="twitter:description" content="上一节课，我们讲解了 Spring 中支持扩展功能的两种设计模式：观察者模式和模板模式。这两种模式能够帮助我们创建扩展点，让框架的使用者在不修改源码的情况下，基于扩展点定制化框架功能。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">86__开源实战四（下）：总结Spring框架用到的11种设计模式</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5596 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#适配器模式在-spring-中的应用">适配器模式在 Spring 中的应用</a></li>
        <li><a href="#策略模式在-spring-中的应用">策略模式在 Spring 中的应用</a></li>
        <li><a href="#组合模式在-spring-中的应用">组合模式在 Spring 中的应用</a></li>
        <li><a href="#装饰器模式在-spring-中的应用">装饰器模式在 Spring 中的应用</a></li>
        <li><a href="#工厂模式在-spring-中的应用">工厂模式在 Spring 中的应用</a></li>
        <li><a href="#其他模式在-spring-中的应用">其他模式在 Spring 中的应用</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#课堂讨论">课堂讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>上一节课，我们讲解了 Spring 中支持扩展功能的两种设计模式：观察者模式和模板模式。这两种模式能够帮助我们创建扩展点，让框架的使用者在不修改源码的情况下，基于扩展点定制化框架功能。</p>
<p>实际上，Spring 框架中用到的设计模式非常多，不下十几种。我们今天就总结罗列一下它们。限于篇幅，我不可能对每种设计模式都进行非常详细的讲解。有些前面已经讲过的或者比较简单的，我就点到为止。如果有什么不是很懂的地方，你可以通过阅读源码，查阅之前的理论讲解，自己去搞定它。如果一直跟着我的课程学习，相信你现在已经具备这样的学习能力。</p>
<p>话不多说，让我们正式开始今天的学习吧！</p>
<h2 id="适配器模式在-spring-中的应用">适配器模式在 Spring 中的应用</h2>
<p>在 Spring MVC 中，定义一个 Controller 最常用的方式是，通过 @Controller 注解来标记某个类是 Controller 类，通过 @RequesMapping 注解来标记函数对应的 URL。不过，定义一个 Controller 远不止这一种方法。我们还可以通过让类实现 Controller 接口或者 Servlet 接口，来定义一个 Controller。针对这三种定义方式，我写了三段示例代码，如下所示：</p>
<p>// 方法一：通过@Controller、@RequestMapping 来定义<br>
@Controller<br>
public class DemoController {<br>
@RequestMapping(&quot;/employname&quot;)<br>
public ModelAndView getEmployeeName() {<br>
ModelAndView model = new ModelAndView(&ldquo;Greeting&rdquo;);       <br>
model.addObject(&ldquo;message&rdquo;, &ldquo;Dinesh&rdquo;);      <br>
return model;<br>
} <br>
}</p>
<p>// 方法二：实现 Controller 接口 + xml 配置文件：配置 DemoController 与 URL 的对应关系<br>
public class DemoController implements Controller {<br>
@Override<br>
public ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception {<br>
ModelAndView model = new ModelAndView(&ldquo;Greeting&rdquo;);<br>
model.addObject(&ldquo;message&rdquo;, &ldquo;Dinesh Madhwal&rdquo;);<br>
return model;<br>
}<br>
}</p>
<p>// 方法三：实现 Servlet 接口 + xml 配置文件：配置 DemoController 类与 URL 的对应关系<br>
public class DemoServlet extends HttpServlet {<br>
@Override<br>
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>
this.doPost(req, resp);<br>
}</p>
<p>@Override<br>
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>
resp.getWriter().write(&ldquo;Hello World.&rdquo;);<br>
}<br>
}</p>
<p>在应用启动的时候，Spring 容器会加载这些 Controller 类，并且解析出 URL 对应的处理函数，封装成 Handler 对象，存储到 HandlerMapping 对象中。当有请求到来的时候，DispatcherServlet 从 HanderMapping 中，查找请求 URL 对应的 Handler，然后调用执行 Handler 对应的函数代码，最后将执行结果返回给客户端。</p>
<p>但是，不同方式定义的 Controller，其函数的定义（函数名、入参、返回值等）是不统一的。如上示例代码所示，方法一中的函数的定义很随意、不固定，方法二中的函数定义是 handleRequest()、方法三中的函数定义是 service()（看似是定义了 doGet()、doPost()，实际上，这里用到了模板模式，Servlet 中的 service() 调用了 doGet() 或 doPost() 方法，DispatcherServlet 调用的是 service() 方法）。DispatcherServlet 需要根据不同类型的 Controller，调用不同的函数。下面是具体的伪代码：</p>
<p>Handler handler = handlerMapping.get(URL);<br>
if (handler instanceof Controller) {<br>
((Controller)handler).handleRequest(&hellip;);<br>
} else if (handler instanceof Servlet) {<br>
((Servlet)handler).service(&hellip;);<br>
} else if (hanlder 对应通过注解来定义的 Controller) {<br>
反射调用方法&hellip;<br>
}</p>
<p>从代码中我们可以看出，这种实现方式会有很多 if-else 分支判断，而且，如果要增加一个新的 Controller 的定义方法，我们就要在 DispatcherServlet 类代码中，对应地增加一段如上伪代码所示的 if 逻辑。这显然不符合开闭原则。</p>
<p>实际上，我们可以利用是适配器模式对代码进行改造，让其满足开闭原则，能更好地支持扩赞。在第 51 节课中，我们讲到，适配器其中一个作用是“统一多个类的接口设计”。利用适配器模式，我们将不同方式定义的 Controller 类中的函数，适配为统一的函数定义。这样，我们就能在 DispatcherServlet 类代码中，移除掉 if-else 分支判断逻辑，调用统一的函数。</p>
<p>刚刚讲了大致的设计思路，我们再具体看下 Spring 的代码实现。</p>
<p>Spring 定义了统一的接口 HandlerAdapter，并且对每种 Controller 定义了对应的适配器类。这些适配器类包括：AnnotationMethodHandlerAdapter、SimpleControllerHandlerAdapter、SimpleServletHandlerAdapter 等。源码我贴到了下面，你可以结合着看下。</p>
<p>public interface HandlerAdapter {<br>
boolean supports(Object var1);</p>
<p>ModelAndView handle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;</p>
<p>long getLastModified(HttpServletRequest var1, Object var2);<br>
}</p>
<p>// 对应实现 Controller 接口的 Controller<br>
public class SimpleControllerHandlerAdapter implements HandlerAdapter {<br>
public SimpleControllerHandlerAdapter() {<br>
}</p>
<p>public boolean supports(Object handler) {<br>
return handler instanceof Controller;<br>
}</p>
<p>public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {<br>
return ((Controller)handler).handleRequest(request, response);<br>
}</p>
<p>public long getLastModified(HttpServletRequest request, Object handler) {<br>
return handler instanceof LastModified ? ((LastModified)handler).getLastModified(request) : -1L;<br>
}<br>
}</p>
<p>// 对应实现 Servlet 接口的 Controller<br>
public class SimpleServletHandlerAdapter implements HandlerAdapter {<br>
public SimpleServletHandlerAdapter() {<br>
}</p>
<p>public boolean supports(Object handler) {<br>
return handler instanceof Servlet;<br>
}</p>
<p>public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {<br>
((Servlet)handler).service(request, response);<br>
return null;<br>
}</p>
<p>public long getLastModified(HttpServletRequest request, Object handler) {<br>
return -1L;<br>
}<br>
}</p>
<p>//AnnotationMethodHandlerAdapter 对应通过注解实现的 Controller，<br>
//代码太多了，我就不贴在这里了</p>
<p>在 DispatcherServlet 类中，我们就不需要区分对待不同的 Controller 对象了，统一调用 HandlerAdapter 的 handle() 函数就可以了。按照这个思路实现的伪代码如下所示。你看，这样就没有烦人的 if-else 逻辑了吧？</p>
<p>// 之前的实现方式<br>
Handler handler = handlerMapping.get(URL);<br>
if (handler instanceof Controller) {<br>
((Controller)handler).handleRequest(&hellip;);<br>
} else if (handler instanceof Servlet) {<br>
((Servlet)handler).service(&hellip;);<br>
} else if (hanlder 对应通过注解来定义的 Controller) {<br>
反射调用方法&hellip;<br>
}</p>
<p>// 现在实现方式<br>
HandlerAdapter handlerAdapter = handlerMapping.get(URL);<br>
handlerAdapter.handle(&hellip;);</p>
<h2 id="策略模式在-spring-中的应用">策略模式在 Spring 中的应用</h2>
<p>我们前面讲到，Spring AOP 是通过动态代理来实现的。熟悉 Java 的同学应该知道，具体到代码实现，Spring 支持两种动态代理实现方式，一种是 JDK 提供的动态代理实现方式，另一种是 Cglib 提供的动态代理实现方式。</p>
<p>前者需要被代理的类有抽象的接口定义，后者不需要（这两种动态代理实现方式的更多区别请自行百度研究吧）。针对不同的被代理类，Spring 会在运行时动态地选择不同的动态代理实现方式。这个应用场景实际上就是策略模式的典型应用场景。</p>
<p>我们前面讲过，策略模式包含三部分，策略的定义、创建和使用。接下来，我们具体看下，这三个部分是如何体现在 Spring 源码中的。</p>
<p>在策略模式中，策略的定义这一部分很简单。我们只需要定义一个策略接口，让不同的策略类都实现这一个策略接口。对应到 Spring 源码，AopProxy 是策略接口，JdkDynamicAopProxy、CglibAopProxy 是两个实现了 AopProxy 接口的策略类。其中，AopProxy 接口的定义如下所示：</p>
<p>public interface AopProxy {<br>
Object getProxy();<br>
Object getProxy(ClassLoader var1);<br>
}</p>
<p>在策略模式中，策略的创建一般通过工厂方法来实现。对应到 Spring 源码，AopProxyFactory 是一个工厂类接口，DefaultAopProxyFactory 是一个默认的工厂类，用来创建 AopProxy 对象。两者的源码如下所示：</p>
<p>public interface AopProxyFactory {<br>
AopProxy createAopProxy(AdvisedSupport var1) throws AopConfigException;<br>
}</p>
<p>public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {<br>
public DefaultAopProxyFactory() {<br>
}</p>
<p>public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {<br>
if (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !this.hasNoUserSuppliedProxyInterfaces(config)) {<br>
return new JdkDynamicAopProxy(config);<br>
} else {<br>
Class<?> targetClass = config.getTargetClass();<br>
if (targetClass == null) {<br>
throw new AopConfigException(&ldquo;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&rdquo;);<br>
} else {<br>
return (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass) ? new ObjenesisCglibAopProxy(config) : new JdkDynamicAopProxy(config));<br>
}<br>
}<br>
}</p>
<p>//用来判断用哪个动态代理实现方式<br>
private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {<br>
Class<?>[] ifcs = config.getProxiedInterfaces();<br>
return ifcs.length == 0 || ifcs.length == 1 &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[0]);<br>
}<br>
}</p>
<p>策略模式的典型应用场景，一般是通过环境变量、状态值、计算结果等动态地决定使用哪个策略。对应到 Spring 源码中，我们可以参看刚刚给出的 DefaultAopProxyFactory 类中的 createAopProxy() 函数的代码实现。其中，第 10 行代码是动态选择哪种策略的判断条件。</p>
<h2 id="组合模式在-spring-中的应用">组合模式在 Spring 中的应用</h2>
<p>上节课讲到 Spring“再封装、再抽象”设计思想的时候，我们提到了 Spring Cache。Spring Cache 提供了一套抽象的 Cache 接口。使用它我们能够统一不同缓存实现（Redis、Google Guava…）的不同的访问方式。Spring 中针对不同缓存实现的不同缓存访问类，都依赖这个接口，比如：EhCacheCache、GuavaCache、NoOpCache、RedisCache、JCacheCache、ConcurrentMapCache、CaffeineCache。Cache 接口的源码如下所示：</p>
<p>public interface Cache {<br>
String getName();<br>
Object getNativeCache();<br>
Cache.ValueWrapper get(Object var1);<br>
<T> T get(Object var1, Class<T> var2);<br>
<T> T get(Object var1, Callable<T> var2);<br>
void put(Object var1, Object var2);<br>
Cache.ValueWrapper putIfAbsent(Object var1, Object var2);<br>
void evict(Object var1);<br>
void clear();</p>
<p>public static class ValueRetrievalException extends RuntimeException {<br>
private final Object key;</p>
<pre><code>public ValueRetrievalException(Object key, Callable&lt;?&gt; loader, Throwable ex) {  
  super(String.format(&quot;Value for key '%s' could not be loaded using '%s'&quot;, key, loader), ex);  
  this.key = key;  
}  

public Object getKey() {  
  return this.key;  
}  
</code></pre>
<p>}</p>
<p>public interface ValueWrapper {<br>
Object get();<br>
}<br>
}</p>
<p>在实际的开发中，一个项目有可能会用到多种不同的缓存，比如既用到 Google Guava 缓存，也用到 Redis 缓存。除此之外，同一个缓存实例，也可以根据业务的不同，分割成多个小的逻辑缓存单元（或者叫作命名空间）。</p>
<p>为了管理多个缓存，Spring 还提供了缓存管理功能。不过，它包含的功能很简单，主要有这样两部分：一个是根据缓存名字（创建 Cache 对象的时候要设置 name 属性）获取 Cache 对象；另一个是获取管理器管理的所有缓存的名字列表。对应的 Spring 源码如下所示：</p>
<p>public interface CacheManager {<br>
Cache getCache(String var1);<br>
Collection<String> getCacheNames();<br>
}</p>
<p>刚刚给出的是 CacheManager 接口的定义，那如何来实现这两个接口呢？实际上，这就要用到了我们之前讲过的组合模式。</p>
<p>我们前面讲过，组合模式主要应用在能表示成树形结构的一组数据上。树中的结点分为叶子节点和中间节点两类。对应到 Spring 源码，EhCacheManager、SimpleCacheManager、NoOpCacheManager、RedisCacheManager 等表示叶子节点，CompositeCacheManager 表示中间节点。</p>
<p>叶子节点包含的是它所管理的 Cache 对象，中间节点包含的是其他 CacheManager 管理器，既可以是 CompositeCacheManager，也可以是具体的管理器，比如 EhCacheManager、RedisManager 等。</p>
<p>我把 CompositeCacheManger 的代码贴到了下面，你可以结合着讲解一块看下。其中，getCache()、getCacheNames() 两个函数的实现都用到了递归。这正是树形结构最能发挥优势的地方。</p>
<p>public class CompositeCacheManager implements CacheManager, InitializingBean {<br>
private final List<CacheManager> cacheManagers = new ArrayList();<br>
private boolean fallbackToNoOpCache = false;</p>
<p>public CompositeCacheManager() {<br>
}</p>
<p>public CompositeCacheManager(CacheManager&hellip; cacheManagers) {<br>
this.setCacheManagers(Arrays.asList(cacheManagers));<br>
}</p>
<p>public void setCacheManagers(Collection<CacheManager> cacheManagers) {<br>
this.cacheManagers.addAll(cacheManagers);<br>
}</p>
<p>public void setFallbackToNoOpCache(boolean fallbackToNoOpCache) {<br>
this.fallbackToNoOpCache = fallbackToNoOpCache;<br>
}</p>
<p>public void afterPropertiesSet() {<br>
if (this.fallbackToNoOpCache) {<br>
this.cacheManagers.add(new NoOpCacheManager());<br>
}</p>
<p>}</p>
<p>public Cache getCache(String name) {<br>
Iterator var2 = this.cacheManagers.iterator();</p>
<pre><code>Cache cache;  
do {  
  if (!var2.hasNext()) {  
    return null;  
  }  

  CacheManager cacheManager = (CacheManager)var2.next();  
  cache = cacheManager.getCache(name);  
} while(cache == null);  

return cache;  
</code></pre>
<p>}</p>
<p>public Collection<String> getCacheNames() {<br>
Set<String> names = new LinkedHashSet();<br>
Iterator var2 = this.cacheManagers.iterator();</p>
<pre><code>while(var2.hasNext()) {  
  CacheManager manager = (CacheManager)var2.next();  
  names.addAll(manager.getCacheNames());  
}  

return Collections.unmodifiableSet(names);  
</code></pre>
<p>}<br>
}</p>
<h2 id="装饰器模式在-spring-中的应用">装饰器模式在 Spring 中的应用</h2>
<p>我们知道，缓存一般都是配合数据库来使用的。如果写缓存成功，但数据库事务回滚了，那缓存中就会有脏数据。为了解决这个问题，我们需要将缓存的写操作和数据库的写操作，放到同一个事务中，要么都成功，要么都失败。</p>
<p>实现这样一个功能，Spring 使用到了装饰器模式。TransactionAwareCacheDecorator 增加了对事务的支持，在事务提交、回滚的时候分别对 Cache 的数据进行处理。</p>
<p>TransactionAwareCacheDecorator 实现 Cache 接口，并且将所有的操作都委托给 targetCache 来实现，对其中的写操作添加了事务功能。这是典型的装饰器模式的应用场景和代码实现，我就不多作解释了。</p>
<p>public class TransactionAwareCacheDecorator implements Cache {<br>
private final Cache targetCache;</p>
<p>public TransactionAwareCacheDecorator(Cache targetCache) {<br>
Assert.notNull(targetCache, &ldquo;Target Cache must not be null&rdquo;);<br>
this.targetCache = targetCache;<br>
}</p>
<p>public Cache getTargetCache() {<br>
return this.targetCache;<br>
}</p>
<p>public String getName() {<br>
return this.targetCache.getName();<br>
}</p>
<p>public Object getNativeCache() {<br>
return this.targetCache.getNativeCache();<br>
}</p>
<p>public ValueWrapper get(Object key) {<br>
return this.targetCache.get(key);<br>
}</p>
<p>public <T> T get(Object key, Class<T> type) {<br>
return this.targetCache.get(key, type);<br>
}</p>
<p>public <T> T get(Object key, Callable<T> valueLoader) {<br>
return this.targetCache.get(key, valueLoader);<br>
}</p>
<p>public void put(final Object key, final Object value) {<br>
if (TransactionSynchronizationManager.isSynchronizationActive()) {<br>
TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {<br>
public void afterCommit() {<br>
TransactionAwareCacheDecorator.this.targetCache.put(key, value);<br>
}<br>
});<br>
} else {<br>
this.targetCache.put(key, value);<br>
}<br>
}</p>
<p>public ValueWrapper putIfAbsent(Object key, Object value) {<br>
return this.targetCache.putIfAbsent(key, value);<br>
}</p>
<p>public void evict(final Object key) {<br>
if (TransactionSynchronizationManager.isSynchronizationActive()) {<br>
TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {<br>
public void afterCommit() {<br>
TransactionAwareCacheDecorator.this.targetCache.evict(key);<br>
}<br>
});<br>
} else {<br>
this.targetCache.evict(key);<br>
}</p>
<p>}</p>
<p>public void clear() {<br>
if (TransactionSynchronizationManager.isSynchronizationActive()) {<br>
TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {<br>
public void afterCommit() {<br>
TransactionAwareCacheDecorator.this.targetCache.clear();<br>
}<br>
});<br>
} else {<br>
this.targetCache.clear();<br>
}<br>
}<br>
}</p>
<h2 id="工厂模式在-spring-中的应用">工厂模式在 Spring 中的应用</h2>
<p>在 Spring 中，工厂模式最经典的应用莫过于实现 IOC 容器，对应的 Spring 源码主要是 BeanFactory 类和 ApplicationContext 相关类（AbstractApplicationContext、ClassPathXmlApplicationContext、FileSystemXmlApplicationContext…）。除此之外，在理论部分，我还带你手把手实现了一个简单的 IOC 容器。你可以回过头去再看下。</p>
<p>在 Spring 中，创建 Bean 的方式有很多种，比如前面提到的纯构造函数、无参构造函数加 setter 方法。我写了一个例子来说明这两种创建方式，代码如下所示：</p>
<p>public class Student {<br>
private long id;<br>
private String name;</p>
<p>public Student(long id, String name) {<br>
this.id = id;<br>
this.name = name;<br>
}</p>
<p>public void setId(long id) {<br>
this.id = id;<br>
}</p>
<p>public void setName(String name) {<br>
this.name = name;<br>
}<br>
}</p>
<p>// 使用构造函数来创建 Bean<br>
<bean id="student" class="com.xzg.cd.Student"><br>
<constructor-arg name="id" value="1"/><br>
<constructor-arg name="name" value="wangzheng"/><br>
</bean></p>
<p>// 使用无参构造函数+setter 方法来创建 Bean<br>
<bean id="student" class="com.xzg.cd.Student"><br>
<property name="id" value="1"></property><br>
<property name="name" value="wangzheng"></property><br>
</bean></p>
<p>实际上，除了这两种创建 Bean 的方式之外，我们还可以通过工厂方法来创建 Bean。还是刚刚这个例子，用这种方式来创建 Bean 的话就是下面这个样子：</p>
<p>public class StudentFactory {<br>
private static Map&lt;Long, Student&gt; students = new HashMap&lt;&gt;();</p>
<p>static{<br>
map.put(1, new Student(1,&ldquo;wang&rdquo;));<br>
map.put(2, new Student(2,&ldquo;zheng&rdquo;));<br>
map.put(3, new Student(3,&ldquo;xzg&rdquo;));<br>
}</p>
<p>public static Student getStudent(long id){<br>
return students.get(id);<br>
}<br>
}</p>
<p>// 通过工厂方法 getStudent(2) 来创建 BeanId=&ldquo;zheng&quot;&ldquo;的 Bean<br>
<bean id="zheng" class="com.xzg.cd.StudentFactory" factory-method="getStudent"><br>
<constructor-arg value="2"></constructor-arg>          <br>
</bean></p>
<h2 id="其他模式在-spring-中的应用">其他模式在 Spring 中的应用</h2>
<p>前面的几个模式在 Spring 中的应用讲解的都比较详细，接下来的几个模式，大部分都是我们之前讲过的，这里只是简单总结一下，点到为止，如果你对哪块有遗忘，可以回过头去看下理论部分的讲解。</p>
<p>SpEL，全称叫 Spring Expression Language，是 Spring 中常用来编写配置的表达式语言。它定义了一系列的语法规则。我们只要按照这些语法规则来编写表达式，Spring 就能解析出表达式的含义。实际上，这就是我们前面讲到的解释器模式的典型应用场景。</p>
<p>因为解释器模式没有一个非常固定的代码实现结构，而且 Spring 中 SpEL 相关的代码也比较多，所以这里就不带你一块阅读源码了。如果感兴趣或者项目中正好要实现类似的功能的时候，你可以再去阅读、借鉴它的代码实现。代码主要集中在 spring-expresssion 这个模块下面。</p>
<p>前面讲到单例模式的时候，我提到过，单例模式有很多弊端，比如单元测试不友好等。应对策略就是通过 IOC 容器来管理对象，通过 IOC 容器来实现对象的唯一性的控制。实际上，这样实现的单例并非真正的单例，它的唯一性的作用范围仅仅在同一个 IOC 容器内。</p>
<p>除此之外，Spring 还用到了观察者模式、模板模式、职责链模式、代理模式。其中，观察者模式、模板模式在上一节课已经详细讲过了。</p>
<p>实际上，在 Spring 中，只要后缀带有 Template 的类，基本上都是模板类，而且大部分都是用 Callback 回调来实现的，比如 JdbcTemplate、RedisTemplate 等。剩下的两个模式在 Spring 中的应用应该人尽皆知了。职责链模式在 Spring 中的应用是拦截器（Interceptor），代理模式经典应用是 AOP。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p>
<p>我们今天提到的设计模式有 11 种，它们分别是适配器模式、策略模式、组合模式、装饰器模式、工厂模式、单例模式、解释器模式、观察者模式、模板模式、职责链模式、代理模式，基本上占了 23 种设计模式的一半。这还只是我所知道的，实际上，Spring 用到的设计模式可能还要更多。你看，设计模式并非“花拳绣腿”吧，它在实际的项目开发中，确实有很多应用，确实可以发挥很大的作用。</p>
<p>还是那句话，对于今天的内容，你不需要去记忆哪个类用到了哪个设计模式。你只需要跟着我的讲解，把每个设计模式在 Spring 中的应用场景，搞懂就可以了。看到类似的代码，能够立马识别出它用到了哪种设计模式；看到类似的应用场景，能够立马反映出要用哪种模式去解决，这样就说明你已经掌握得足够好了。</p>
<h2 id="课堂讨论">课堂讨论</h2>
<p>我们前面讲到，除了纯构造函数、构造函数加 setter 方法和工厂方法之外，还有另外一个经常用来创建对象的模式，Builder 模式。如果我们让 Spring 支持通过 Builder 模式来创建 Bean，应该如何来编写代码和配置呢？你可以设计一下吗？</p>
<p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/">设计模式之美</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/86__%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">86__程序员练级攻略：机器学习和人工智能</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%8D%B3%E6%97%B6%E6%B6%88%E6%81%AF%E6%8A%80%E6%9C%AF%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/86-%E5%8D%B3%E6%97%B6%E6%B6%88%E6%81%AF%E6%8A%80%E6%9C%AF%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/">
            <span class="next-text nav-default">86-即时消息技术剖析与实战</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
