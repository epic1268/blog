<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>68__访问者模式（上）：手把手带你还原访问者模式诞生的思维过程 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="前面我们讲到，大部分设计模式的原理和实现都很简单，不过也有例外，比如今天要讲的访问者模式。它可以算是 23 种经典设计模式中最难理解的几个之一。因为它难理解、难实现，应用它会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很少被用到，在没有特别必要的情况下，建议你不要使用访问者模式。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/68__%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E8%BF%98%E5%8E%9F%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%9E%E7%94%9F%E7%9A%84%E6%80%9D%E7%BB%B4%E8%BF%87%E7%A8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/68__%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E8%BF%98%E5%8E%9F%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%9E%E7%94%9F%E7%9A%84%E6%80%9D%E7%BB%B4%E8%BF%87%E7%A8%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="68__访问者模式（上）：手把手带你还原访问者模式诞生的思维过程">
  <meta property="og:description" content="前面我们讲到，大部分设计模式的原理和实现都很简单，不过也有例外，比如今天要讲的访问者模式。它可以算是 23 种经典设计模式中最难理解的几个之一。因为它难理解、难实现，应用它会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很少被用到，在没有特别必要的情况下，建议你不要使用访问者模式。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="设计模式之美">

  <meta itemprop="name" content="68__访问者模式（上）：手把手带你还原访问者模式诞生的思维过程">
  <meta itemprop="description" content="前面我们讲到，大部分设计模式的原理和实现都很简单，不过也有例外，比如今天要讲的访问者模式。它可以算是 23 种经典设计模式中最难理解的几个之一。因为它难理解、难实现，应用它会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很少被用到，在没有特别必要的情况下，建议你不要使用访问者模式。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3878">
  <meta itemprop="keywords" content="设计模式之美">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="68__访问者模式（上）：手把手带你还原访问者模式诞生的思维过程">
  <meta name="twitter:description" content="前面我们讲到，大部分设计模式的原理和实现都很简单，不过也有例外，比如今天要讲的访问者模式。它可以算是 23 种经典设计模式中最难理解的几个之一。因为它难理解、难实现，应用它会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很少被用到，在没有特别必要的情况下，建议你不要使用访问者模式。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">68__访问者模式（上）：手把手带你还原访问者模式诞生的思维过程</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3878 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#带你发明访问者模式">带你“发明”访问者模式</a></li>
        <li><a href="#重新来看访问者模式">重新来看访问者模式</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#课堂讨论">课堂讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>前面我们讲到，大部分设计模式的原理和实现都很简单，不过也有例外，比如今天要讲的访问者模式。它可以算是 23 种经典设计模式中最难理解的几个之一。因为它难理解、难实现，应用它会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很少被用到，在没有特别必要的情况下，建议你不要使用访问者模式。</p>
<p>尽管如此，为了让你以后读到应用了访问者模式的代码的时候，能一眼就能看出代码的设计意图，同时为了整个专栏内容的完整性，我觉得还是有必要给你讲一讲这个模式。除此之外，为了最大化学习效果，我今天不只是单纯地讲解原理和实现，更重要的是，我会手把手带你还原访问者模式诞生的思维过程，让你切身感受到创造一种新的设计模式出来并不是件难事。</p>
<p>话不多说，让我们正式开始今天的学习吧！</p>
<h2 id="带你发明访问者模式">带你“发明”访问者模式</h2>
<p>假设我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到 txt 文件中。如果让你来实现，你会怎么来做呢？</p>
<p>实现这个功能并不难，不同的人有不同的写法，我将其中一种代码实现方式贴在这里。其中，ResourceFile 是一个抽象类，包含一个抽象函数 extract2txt()。PdfFile、PPTFile、WordFile 都继承 ResourceFile 类，并且重写了 extract2txt() 函数。在 ToolApplication 中，我们可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。</p>
<p>public abstract class ResourceFile {<br>
protected String filePath;</p>
<p>public ResourceFile(String filePath) {<br>
this.filePath = filePath;<br>
}</p>
<p>public abstract void extract2txt();<br>
}</p>
<p>public class PPTFile extends ResourceFile {<br>
public PPTFile(String filePath) {<br>
super(filePath);<br>
}</p>
<p>@Override<br>
public void extract2txt() {<br>
//&hellip;省略一大坨从 PPT 中抽取文本的代码&hellip;<br>
//&hellip;将抽取出来的文本保存在跟 filePath 同名的.txt 文件中&hellip;<br>
System.out.println(&ldquo;Extract PPT.&rdquo;);<br>
}<br>
}</p>
<p>public class PdfFile extends ResourceFile {<br>
public PdfFile(String filePath) {<br>
super(filePath);<br>
}</p>
<p>@Override<br>
public void extract2txt() {<br>
//&hellip;<br>
System.out.println(&ldquo;Extract PDF.&rdquo;);<br>
}<br>
}</p>
<p>public class WordFile extends ResourceFile {<br>
public WordFile(String filePath) {<br>
super(filePath);<br>
}</p>
<p>@Override<br>
public void extract2txt() {<br>
//&hellip;<br>
System.out.println(&ldquo;Extract WORD.&rdquo;);<br>
}<br>
}</p>
<p>// 运行结果是：<br>
// Extract PDF.<br>
// Extract WORD.<br>
// Extract PPT.<br>
public class ToolApplication {<br>
public static void main(String[] args) {<br>
List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);<br>
for (ResourceFile resourceFile : resourceFiles) {<br>
resourceFile.extract2txt();<br>
}<br>
}</p>
<p>private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {<br>
List<ResourceFile> resourceFiles = new ArrayList&lt;&gt;();<br>
//&hellip;根据后缀 (pdf/ppt/word) 由工厂方法创建不同的类对象 (PdfFile/PPTFile/WordFile)<br>
resourceFiles.add(new PdfFile(&ldquo;a.pdf&rdquo;));<br>
resourceFiles.add(new WordFile(&ldquo;b.word&rdquo;));<br>
resourceFiles.add(new PPTFile(&ldquo;c.ppt&rdquo;));<br>
return resourceFiles;<br>
}<br>
}</p>
<p>如果工具的功能不停地扩展，不仅要能抽取文本内容，还要支持压缩、提取文件元信息（文件名、大小、更新时间等等）构建索引等一系列的功能，那如果我们继续按照上面的实现思路，就会存在这样几个问题：</p>
<ol>
<li>违背开闭原则，添加一个新的功能，所有类的代码都要修改；</li>
<li>虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；</li>
<li>把所有比较上层的业务逻辑都耦合到 PdfFile、PPTFile、WordFile 类中，导致这些类的职责不够单一，变成了大杂烩。</li>
</ol>
<p>针对上面的问题，我们常用的解决方法就是拆分解耦，把业务操作跟具体的数据结构解耦，设计成独立的类。这里我们按照访问者模式的演进思路来对上面的代码进行重构。重构之后的代码如下所示。</p>
<p>public abstract class ResourceFile {<br>
protected String filePath;<br>
public ResourceFile(String filePath) {<br>
this.filePath = filePath;<br>
}<br>
}</p>
<p>public class PdfFile extends ResourceFile {<br>
public PdfFile(String filePath) {<br>
super(filePath);<br>
}<br>
//&hellip;<br>
}<br>
//&hellip;PPTFile、WordFile 代码省略&hellip;<br>
public class Extractor {<br>
public void extract2txt(PPTFile pptFile) {<br>
//&hellip;<br>
System.out.println(&ldquo;Extract PPT.&rdquo;);<br>
}</p>
<p>public void extract2txt(PdfFile pdfFile) {<br>
//&hellip;<br>
System.out.println(&ldquo;Extract PDF.&rdquo;);<br>
}</p>
<p>public void extract2txt(WordFile wordFile) {<br>
//&hellip;<br>
System.out.println(&ldquo;Extract WORD.&rdquo;);<br>
}<br>
}</p>
<p>public class ToolApplication {<br>
public static void main(String[] args) {<br>
Extractor extractor = new Extractor();<br>
List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);<br>
for (ResourceFile resourceFile : resourceFiles) {<br>
extractor.extract2txt(resourceFile);<br>
}<br>
}</p>
<p>private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {<br>
List<ResourceFile> resourceFiles = new ArrayList&lt;&gt;();<br>
//&hellip;根据后缀 (pdf/ppt/word) 由工厂方法创建不同的类对象 (PdfFile/PPTFile/WordFile)<br>
resourceFiles.add(new PdfFile(&ldquo;a.pdf&rdquo;));<br>
resourceFiles.add(new WordFile(&ldquo;b.word&rdquo;));<br>
resourceFiles.add(new PPTFile(&ldquo;c.ppt&rdquo;));<br>
return resourceFiles;<br>
}<br>
}</p>
<p>这其中最关键的一点设计是，我们把抽取文本内容的操作，设计成了三个重载函数。函数重载是 Java、C++ 这类面向对象编程语言中常见的语法机制。所谓重载函数是指，在同一类中函数名相同、参数不同的一组函数。</p>
<p>不过，如果你足够细心，就会发现，上面的代码是编译通过不了的，第 37 行会报错。这是为什么呢？</p>
<p>我们知道，多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法。</p>
<p>在上面代码的第 35～38 行中，resourceFiles 包含的对象的声明类型都是 ResourceFile，而我们并没有在 Extractor 类中定义参数类型是 ResourceFile 的 extract2txt() 重载函数，所以在编译阶段就通过不了，更别说在运行时根据对象的实际类型执行不同的重载函数了。那如何解决这个问题呢？</p>
<p>解决的办法稍微有点难理解，我们先来看代码，然后我再来给你慢慢解释。</p>
<p>public abstract class ResourceFile {<br>
protected String filePath;<br>
public ResourceFile(String filePath) {<br>
this.filePath = filePath;<br>
}<br>
abstract public void accept(Extractor extractor);<br>
}</p>
<p>public class PdfFile extends ResourceFile {<br>
public PdfFile(String filePath) {<br>
super(filePath);<br>
}</p>
<p>@Override<br>
public void accept(Extractor extractor) {<br>
extractor.extract2txt(this);<br>
}</p>
<p>//&hellip;<br>
}</p>
<p>//&hellip;PPTFile、WordFile 跟 PdfFile 类似，这里就省略了&hellip;<br>
//&hellip;Extractor 代码不变&hellip;</p>
<p>public class ToolApplication {<br>
public static void main(String[] args) {<br>
Extractor extractor = new Extractor();<br>
List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);<br>
for (ResourceFile resourceFile : resourceFiles) {<br>
resourceFile.accept(extractor);<br>
}<br>
}</p>
<p>private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {<br>
List<ResourceFile> resourceFiles = new ArrayList&lt;&gt;();<br>
//&hellip;根据后缀 (pdf/ppt/word) 由工厂方法创建不同的类对象 (PdfFile/PPTFile/WordFile)<br>
resourceFiles.add(new PdfFile(&ldquo;a.pdf&rdquo;));<br>
resourceFiles.add(new WordFile(&ldquo;b.word&rdquo;));<br>
resourceFiles.add(new PPTFile(&ldquo;c.ppt&rdquo;));<br>
return resourceFiles;<br>
}<br>
}</p>
<p>在执行第 30 行的时候，根据多态特性，程序会调用实际类型的 accept 函数，比如 PdfFile 的 accept 函数，也就是第 16 行代码。而 16 行代码中的 this 类型是 PdfFile 的，在编译的时候就确定了，所以会调用 extractor 的 extract2txt(PdfFile pdfFile) 这个重载函数。这个实现思路是不是很有技巧？这是理解访问者模式的关键所在，也是我之前所说的访问者模式不好理解的原因。</p>
<p>现在，如果要继续添加新的功能，比如前面提到的压缩功能，根据不同的文件类型，使用不同的压缩算法来压缩资源文件，那我们该如何实现呢？我们需要实现一个类似 Extractor 类的新类 Compressor 类，在其中定义三个重载函数，实现对不同类型资源文件的压缩。除此之外，我们还要在每个资源文件类中定义新的 accept 重载函数。具体的代码如下所示：</p>
<p>public abstract class ResourceFile {<br>
protected String filePath;<br>
public ResourceFile(String filePath) {<br>
this.filePath = filePath;<br>
}<br>
abstract public void accept(Extractor extractor);<br>
abstract public void accept(Compressor compressor);<br>
}</p>
<p>public class PdfFile extends ResourceFile {<br>
public PdfFile(String filePath) {<br>
super(filePath);<br>
}</p>
<p>@Override<br>
public void accept(Extractor extractor) {<br>
extractor.extract2txt(this);<br>
}</p>
<p>@Override<br>
public void accept(Compressor compressor) {<br>
compressor.compress(this);<br>
}</p>
<p>//&hellip;<br>
}<br>
}<br>
//&hellip;PPTFile、WordFile 跟 PdfFile 类似，这里就省略了&hellip;<br>
//&hellip;Extractor 代码不变</p>
<p>public class ToolApplication {<br>
public static void main(String[] args) {<br>
Extractor extractor = new Extractor();<br>
List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);<br>
for (ResourceFile resourceFile : resourceFiles) {<br>
resourceFile.accept(extractor);<br>
}</p>
<pre><code>Compressor compressor = new Compressor();  
for(ResourceFile resourceFile : resourceFiles) {  
  resourceFile.accept(compressor);  
}  
</code></pre>
<p>}</p>
<p>private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {<br>
List<ResourceFile> resourceFiles = new ArrayList&lt;&gt;();<br>
//&hellip;根据后缀 (pdf/ppt/word) 由工厂方法创建不同的类对象 (PdfFile/PPTFile/WordFile)<br>
resourceFiles.add(new PdfFile(&ldquo;a.pdf&rdquo;));<br>
resourceFiles.add(new WordFile(&ldquo;b.word&rdquo;));<br>
resourceFiles.add(new PPTFile(&ldquo;c.ppt&rdquo;));<br>
return resourceFiles;<br>
}<br>
}</p>
<p>上面代码还存在一些问题，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭原则。针对这个问题，我们抽象出来一个 Visitor 接口，包含是三个命名非常通用的 visit() 重载函数，分别处理三种不同类型的资源文件。具体做什么业务处理，由实现这个 Visitor 接口的具体的类来决定，比如 Extractor 负责抽取文本内容，Compressor 负责压缩。当我们新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改 ToolApplication 的代码就可以了。</p>
<p>按照这个思路我们可以对代码进行重构，重构之后的代码如下所示：</p>
<p>public abstract class ResourceFile {<br>
protected String filePath;<br>
public ResourceFile(String filePath) {<br>
this.filePath = filePath;<br>
}<br>
abstract public void accept(Visitor vistor);<br>
}</p>
<p>public class PdfFile extends ResourceFile {<br>
public PdfFile(String filePath) {<br>
super(filePath);<br>
}</p>
<p>@Override<br>
public void accept(Visitor visitor) {<br>
visitor.visit(this);<br>
}</p>
<p>//&hellip;<br>
}<br>
//&hellip;PPTFile、WordFile 跟 PdfFile 类似，这里就省略了&hellip;</p>
<p>public interface Visitor {<br>
void visit(PdfFile pdfFile);<br>
void visit(PPTFile pdfFile);<br>
void visit(WordFile pdfFile);<br>
}</p>
<p>public class Extractor implements Visitor {<br>
@Override<br>
public void visit(PPTFile pptFile) {<br>
//&hellip;<br>
System.out.println(&ldquo;Extract PPT.&rdquo;);<br>
}</p>
<p>@Override<br>
public void visit(PdfFile pdfFile) {<br>
//&hellip;<br>
System.out.println(&ldquo;Extract PDF.&rdquo;);<br>
}</p>
<p>@Override<br>
public void visit(WordFile wordFile) {<br>
//&hellip;<br>
System.out.println(&ldquo;Extract WORD.&rdquo;);<br>
}<br>
}</p>
<p>public class Compressor implements Visitor {<br>
@Override<br>
public void visit(PPTFile pptFile) {<br>
//&hellip;<br>
System.out.println(&ldquo;Compress PPT.&rdquo;);<br>
}</p>
<p>@Override<br>
public void visit(PdfFile pdfFile) {<br>
//&hellip;<br>
System.out.println(&ldquo;Compress PDF.&rdquo;);<br>
}</p>
<p>@Override<br>
public void visit(WordFile wordFile) {<br>
//&hellip;<br>
System.out.println(&ldquo;Compress WORD.&rdquo;);<br>
}</p>
<p>}</p>
<p>public class ToolApplication {<br>
public static void main(String[] args) {<br>
Extractor extractor = new Extractor();<br>
List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);<br>
for (ResourceFile resourceFile : resourceFiles) {<br>
resourceFile.accept(extractor);<br>
}</p>
<pre><code>Compressor compressor = new Compressor();  
for(ResourceFile resourceFile : resourceFiles) {  
  resourceFile.accept(compressor);  
}  
</code></pre>
<p>}</p>
<p>private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {<br>
List<ResourceFile> resourceFiles = new ArrayList&lt;&gt;();<br>
//&hellip;根据后缀 (pdf/ppt/word) 由工厂方法创建不同的类对象 (PdfFile/PPTFile/WordFile)<br>
resourceFiles.add(new PdfFile(&ldquo;a.pdf&rdquo;));<br>
resourceFiles.add(new WordFile(&ldquo;b.word&rdquo;));<br>
resourceFiles.add(new PPTFile(&ldquo;c.ppt&rdquo;));<br>
return resourceFiles;<br>
}<br>
}</p>
<h2 id="重新来看访问者模式">重新来看访问者模式</h2>
<p>刚刚我带你一步一步还原了访问者模式诞生的思维过程，现在，我们回过头来总结一下，这个模式的原理和代码实现。</p>
<p>访问者者模式的英文翻译是 Visitor Design Pattern。在 GoF 的《设计模式》一书中，它是这么定义的：</p>
<blockquote>
<p>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.</p>
</blockquote>
<p>翻译成中文就是：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p>
<p>定义比较简单，结合前面的例子不难理解，我就不过多解释了。对于访问者模式的代码实现，实际上，在上面例子中，经过层层重构之后的最终代码，就是标准的访问者模式的实现代码。这里，我又总结了一张类图，贴在了下面，你可以对照着前面的例子代码一块儿来看一下。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/7d50afaddb8da22d026e03a7d76250ca.png" alt=""></p>
<p>最后，我们再来看下，访问者模式的应用场景。</p>
<p>一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作（抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile）不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类（Extractor、Compressor）中。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p>
<p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。</p>
<p>对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。</p>
<p>正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。</p>
<h2 id="课堂讨论">课堂讨论</h2>
<p>实际上，今天举的例子不用访问者模式也可以搞定，你能够想到其他实现思路吗？</p>
<p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/">设计模式之美</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/67__%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">67__区块链技术细节：智能合约</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/68__%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF_-_%E4%BC%A0%E7%BB%9F%E9%87%91%E8%9E%8D%E5%92%8C%E8%99%9A%E6%8B%9F%E8%B4%A7%E5%B8%81/">
            <span class="next-text nav-default">68__区块链技术_-_传统金融和虚拟货币</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
