<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>88__开源实战五（中）：如何利用职责链与代理模式实现MyBatis_Plugin？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="上节课，我们对 MyBatis 框架做了简单的背景介绍，并且通过对比各种 ORM 框架，学习了代码的易用性、性能、灵活性之间的关系。一般来讲，框架提供的高级功能越多，那性能损耗就会越大；框架用起来越简单，提供越简化的使用方式，那灵活性也就越低。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/88__%E5%BC%80%E6%BA%90%E5%AE%9E%E6%88%98%E4%BA%94%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%81%8C%E8%B4%A3%E9%93%BE%E4%B8%8E%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0mybatis_plugin/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/88__%E5%BC%80%E6%BA%90%E5%AE%9E%E6%88%98%E4%BA%94%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%81%8C%E8%B4%A3%E9%93%BE%E4%B8%8E%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0mybatis_plugin/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="88__开源实战五（中）：如何利用职责链与代理模式实现MyBatis_Plugin？">
  <meta property="og:description" content="上节课，我们对 MyBatis 框架做了简单的背景介绍，并且通过对比各种 ORM 框架，学习了代码的易用性、性能、灵活性之间的关系。一般来讲，框架提供的高级功能越多，那性能损耗就会越大；框架用起来越简单，提供越简化的使用方式，那灵活性也就越低。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="设计模式之美">

  <meta itemprop="name" content="88__开源实战五（中）：如何利用职责链与代理模式实现MyBatis_Plugin？">
  <meta itemprop="description" content="上节课，我们对 MyBatis 框架做了简单的背景介绍，并且通过对比各种 ORM 框架，学习了代码的易用性、性能、灵活性之间的关系。一般来讲，框架提供的高级功能越多，那性能损耗就会越大；框架用起来越简单，提供越简化的使用方式，那灵活性也就越低。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4676">
  <meta itemprop="keywords" content="设计模式之美">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="88__开源实战五（中）：如何利用职责链与代理模式实现MyBatis_Plugin？">
  <meta name="twitter:description" content="上节课，我们对 MyBatis 框架做了简单的背景介绍，并且通过对比各种 ORM 框架，学习了代码的易用性、性能、灵活性之间的关系。一般来讲，框架提供的高级功能越多，那性能损耗就会越大；框架用起来越简单，提供越简化的使用方式，那灵活性也就越低。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">88__开源实战五（中）：如何利用职责链与代理模式实现MyBatis_Plugin？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4676 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#mybatis-plugin-功能介绍">MyBatis Plugin 功能介绍</a></li>
        <li><a href="#mybatis-plugin-的设计与实现">MyBatis Plugin 的设计与实现</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#课堂讨论">课堂讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>上节课，我们对 MyBatis 框架做了简单的背景介绍，并且通过对比各种 ORM 框架，学习了代码的易用性、性能、灵活性之间的关系。一般来讲，框架提供的高级功能越多，那性能损耗就会越大；框架用起来越简单，提供越简化的使用方式，那灵活性也就越低。</p>
<p>接下来的两节课，我们再学习一下 MyBatis 用到一些经典设计模式。其中，今天，我们主要讲解 MyBatis Plugin。尽管名字叫 Plugin（插件），但它实际上跟之前讲到的 Servlet Filter（过滤器）、Spring Interceptor（拦截器）类似，设计的初衷都是为了框架的扩展性，用到的主要设计模式都是职责链模式。</p>
<p>不过，相对于 Servlet Filter 和 Spring Interceptor，MyBatis Plugin 中职责链模式的代码实现稍微有点复杂。它是借助动态代理模式来实现的职责链。今天我就带你看下，如何利用这两个模式实现 MyBatis Plugin。</p>
<p>话不多说，让我们正式开始今天的学习吧！</p>
<h2 id="mybatis-plugin-功能介绍">MyBatis Plugin 功能介绍</h2>
<p>实际上，MyBatis Plugin 跟 Servlet Filter、Spring Interceptor 的功能是类似的，都是在不需要修改原有流程代码的情况下，拦截某些方法调用，在拦截的方法调用的前后，执行一些额外的代码逻辑。它们的唯一区别在于拦截的位置是不同的。Servlet Filter 主要拦截 Servlet 请求，Spring Interceptor 主要拦截 Spring 管理的 Bean 方法（比如 Controller 类的方法等），而 MyBatis Plugin 主要拦截的是 MyBatis 在执行 SQL 的过程中涉及的一些方法。</p>
<p>MyBatis Plugin 使用起来比较简单，我们通过一个例子来快速看下。</p>
<p>假设我们需要统计应用中每个 SQL 的执行耗时，如果使用 MyBatis Plugin 来实现的话，我们只需要定义一个 SqlCostTimeInterceptor 类，让它实现 MyBatis 的 Interceptor 接口，并且，在 MyBatis 的全局配置文件中，简单声明一下这个插件就可以了。具体的代码和配置如下所示：</p>
<p>@Intercepts({<br>
@Signature(type = StatementHandler.class, method = &ldquo;query&rdquo;, args = {Statement.class, ResultHandler.class}),<br>
@Signature(type = StatementHandler.class, method = &ldquo;update&rdquo;, args = {Statement.class}),<br>
@Signature(type = StatementHandler.class, method = &ldquo;batch&rdquo;, args = {Statement.class})})<br>
public class SqlCostTimeInterceptor implements Interceptor {<br>
private static Logger logger = LoggerFactory.getLogger(SqlCostTimeInterceptor.class);</p>
<p>@Override<br>
public Object intercept(Invocation invocation) throws Throwable {<br>
Object target = invocation.getTarget();<br>
long startTime = System.currentTimeMillis();<br>
StatementHandler statementHandler = (StatementHandler) target;<br>
try {<br>
return invocation.proceed();<br>
} finally {<br>
long costTime = System.currentTimeMillis() - startTime;<br>
BoundSql boundSql = statementHandler.getBoundSql();<br>
String sql = boundSql.getSql();<br>
logger.info(&ldquo;执行 SQL：[ {} ] 执行耗时 [ {} ms]&rdquo;, sql, costTime);<br>
}<br>
}</p>
<p>@Override<br>
public Object plugin(Object target) {<br>
return Plugin.wrap(target, this);<br>
}</p>
<p>@Override<br>
public void setProperties(Properties properties) {<br>
System.out.println(&ldquo;插件配置的信息：&quot;+properties);<br>
}<br>
}</p>
<!-- MyBatis 全局配置文件：mybatis-config.xml -->  
<plugins>  
  <plugin interceptor="com.xzg.cd.a88.SqlCostTimeInterceptor">  
    <property name="someProperty" value="100"/>  
  </plugin>  
</plugins>
<p>因为待会我会详细地介绍 MyBatis Plugin 的底层实现原理，所以，这里暂时不对上面的代码做详细地解释。现在，我们只重点看下 @Intercepts 注解这一部分。</p>
<p>我们知道，不管是拦截器、过滤器还是插件，都需要明确地标明拦截的目标方法。@Intercepts 注解实际上就是起了这个作用。其中，@Intercepts 注解又可以嵌套 @Signature 注解。一个 @Signature 注解标明一个要拦截的目标方法。如果要拦截多个方法，我们可以像例子中那样，编写多条 @Signature 注解。</p>
<p>@Signature 注解包含三个元素：type、method、args。其中，type 指明要拦截的类、method 指明方法名、args 指明方法的参数列表。通过指定这三个元素，我们就能完全确定一个要拦截的方法。</p>
<p>默认情况下，MyBatis Plugin 允许拦截的方法有下面这样几个：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/90af8b15d3374000a44af22593dbd154.png" alt=""></p>
<p>为什么默认允许拦截的是这样几个类的方法呢？</p>
<p>MyBatis 底层是通过 Executor 类来执行 SQL 的。Executor 类会创建 StatementHandler、ParameterHandler、ResultSetHandler 三个对象，并且，首先使用 ParameterHandler 设置 SQL 中的占位符参数，然后使用 StatementHandler 执行 SQL 语句，最后使用 ResultSetHandler 封装执行结果。所以，我们只需要拦截 Executor、ParameterHandler、ResultSetHandler、StatementHandler 这几个类的方法，基本上就能满足我们对整个 SQL 执行流程的拦截了。</p>
<p>实际上，除了统计 SQL 的执行耗时，利用 MyBatis Plugin，我们还可以做很多事情，比如分库分表、自动分页、数据脱敏、加密解密等等。如果感兴趣的话，你可以自己实现一下。</p>
<h2 id="mybatis-plugin-的设计与实现">MyBatis Plugin 的设计与实现</h2>
<p>刚刚我们简单介绍了 MyBatis Plugin 是如何使用的。现在，我们再剖析一下源码，看看如此简洁的使用方式，底层是如何实现的，隐藏了哪些复杂的设计。</p>
<p>相对于 Servlet Filter、Spring Interceptor 中职责链模式的代码实现，MyBatis Plugin 的代码实现还是蛮有技巧的，因为它是借助动态代理来实现职责链的。</p>
<p>在第 62 节和第 63 节中，我们讲到，职责链模式的实现一般包含处理器（Handler）和处理器链（HandlerChain）两部分。这两个部分对应到 Servlet Filter 的源码就是 Filter 和 FilterChain，对应到 Spring Interceptor 的源码就是 HandlerInterceptor 和 HandlerExecutionChain，对应到 MyBatis Plugin 的源码就是 Interceptor 和 InterceptorChain。除此之外，MyBatis Plugin 还包含另外一个非常重要的类：Plugin。它用来生成被拦截对象的动态代理。</p>
<p>集成了 MyBatis 的应用在启动的时候，MyBatis 框架会读取全局配置文件（前面例子中的 mybatis-config.xml 文件），解析出 Interceptor（也就是例子中的 SqlCostTimeInterceptor），并且将它注入到 Configuration 类的 InterceptorChain 对象中。这部分逻辑对应到源码如下所示：</p>
<p>public class XMLConfigBuilder extends BaseBuilder {<br>
//解析配置<br>
private void parseConfiguration(XNode root) {<br>
try {<br>
//省略部分代码&hellip;<br>
pluginElement(root.evalNode(&ldquo;plugins&rdquo;)); //解析插件<br>
} catch (Exception e) {<br>
throw new BuilderException(&ldquo;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);<br>
}<br>
}</p>
<p>//解析插件<br>
private void pluginElement(XNode parent) throws Exception {<br>
if (parent != null) {<br>
for (XNode child : parent.getChildren()) {<br>
String interceptor = child.getStringAttribute(&ldquo;interceptor&rdquo;);<br>
Properties properties = child.getChildrenAsProperties();<br>
//创建 Interceptor 类对象<br>
Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();<br>
//调用 Interceptor 上的 setProperties() 方法设置 properties<br>
interceptorInstance.setProperties(properties);<br>
//下面这行代码会调用 InterceptorChain.addInterceptor() 方法<br>
configuration.addInterceptor(interceptorInstance);<br>
}<br>
}<br>
}<br>
}</p>
<p>// Configuration 类的 addInterceptor() 方法的代码如下所示<br>
public void addInterceptor(Interceptor interceptor) {<br>
interceptorChain.addInterceptor(interceptor);<br>
}</p>
<p>我们再来看 Interceptor 和 InterceptorChain 这两个类的代码，如下所示。Interceptor 的 setProperties() 方法就是一个单纯的 setter 方法，主要是为了方便通过配置文件配置 Interceptor 的一些属性值，没有其他作用。Interceptor 类中 intecept() 和 plugin() 函数，以及 InterceptorChain 类中的 pluginAll() 函数，是最核心的三个函数，我们待会再详细解释。</p>
<p>public class Invocation {<br>
private final Object target;<br>
private final Method method;<br>
private final Object[] args;<br>
// 省略构造函数和 getter 方法&hellip;<br>
public Object proceed() throws InvocationTargetException, IllegalAccessException {<br>
return method.invoke(target, args);<br>
}<br>
}<br>
public interface Interceptor {<br>
Object intercept(Invocation invocation) throws Throwable;<br>
Object plugin(Object target);<br>
void setProperties(Properties properties);<br>
}</p>
<p>public class InterceptorChain {<br>
private final List<Interceptor> interceptors = new ArrayList<Interceptor>();</p>
<p>public Object pluginAll(Object target) {<br>
for (Interceptor interceptor : interceptors) {<br>
target = interceptor.plugin(target);<br>
}<br>
return target;<br>
}</p>
<p>public void addInterceptor(Interceptor interceptor) {<br>
interceptors.add(interceptor);<br>
}</p>
<p>public List<Interceptor> getInterceptors() {<br>
return Collections.unmodifiableList(interceptors);<br>
}<br>
}</p>
<p>解析完配置文件之后，所有的 Interceptor 都加载到了 InterceptorChain 中。接下来，我们再来看下，这些拦截器是在什么时候被触发执行的？又是如何被触发执行的呢？</p>
<p>前面我们提到，在执行 SQL 的过程中，MyBatis 会创建 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这几个类的对象，对应的创建代码在 Configuration 类中，如下所示：</p>
<p>public Executor newExecutor(Transaction transaction, ExecutorType executorType) {<br>
executorType = executorType == null ? defaultExecutorType : executorType;<br>
executorType = executorType == null ? ExecutorType.SIMPLE : executorType;<br>
Executor executor;<br>
if (ExecutorType.BATCH == executorType) {<br>
executor = new BatchExecutor(this, transaction);<br>
} else if (ExecutorType.REUSE == executorType) {<br>
executor = new ReuseExecutor(this, transaction);<br>
} else {<br>
executor = new SimpleExecutor(this, transaction);<br>
}<br>
if (cacheEnabled) {<br>
executor = new CachingExecutor(executor);<br>
}<br>
executor = (Executor) interceptorChain.pluginAll(executor);<br>
return executor;<br>
}</p>
<p>public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {<br>
ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);<br>
parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);<br>
return parameterHandler;<br>
}</p>
<p>public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,<br>
ResultHandler resultHandler, BoundSql boundSql) {<br>
ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);<br>
resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);<br>
return resultSetHandler;<br>
}</p>
<p>public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {<br>
StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);<br>
statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);<br>
return statementHandler;<br>
}</p>
<p>从上面的代码中，我们可以发现，这几个类对象的创建过程都调用了 InteceptorChain 的 pluginAll() 方法。这个方法的代码前面已经给出了。你可以回过头去再看一眼。它的代码实现很简单，嵌套调用 InterceptorChain 上每个 Interceptor 的 plugin() 方法。plugin() 是一个接口方法（不包含实现代码），需要由用户给出具体的实现代码。在之前的例子中，SQLTimeCostInterceptor 的 plugin() 方法通过直接调用 Plugin 的 wrap() 方法来实现。wrap() 方法的代码实现如下所示：</p>
<p>// 借助 Java InvocationHandler 实现的动态代理模式<br>
public class Plugin implements InvocationHandler {<br>
private final Object target;<br>
private final Interceptor interceptor;<br>
private final Map&lt;Class<?>, Set<Method>&gt; signatureMap;</p>
<p>private Plugin(Object target, Interceptor interceptor, Map&lt;Class<?>, Set<Method>&gt; signatureMap) {<br>
this.target = target;<br>
this.interceptor = interceptor;<br>
this.signatureMap = signatureMap;<br>
}</p>
<p>// wrap() 静态方法，用来生成 target 的动态代理，<br>
// 动态代理对象=target 对象+interceptor 对象。<br>
public static Object wrap(Object target, Interceptor interceptor) {<br>
Map&lt;Class<?>, Set<Method>&gt; signatureMap = getSignatureMap(interceptor);<br>
Class<?> type = target.getClass();<br>
Class<?>[] interfaces = getAllInterfaces(type, signatureMap);<br>
if (interfaces.length &gt; 0) {<br>
return Proxy.newProxyInstance(<br>
type.getClassLoader(),<br>
interfaces,<br>
new Plugin(target, interceptor, signatureMap));<br>
}<br>
return target;<br>
}</p>
<p>// 调用 target 上的 f() 方法，会触发执行下面这个方法。<br>
// 这个方法包含：执行 interceptor 的 intecept() 方法 + 执行 target 上 f() 方法。<br>
@Override<br>
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br>
try {<br>
Set<Method> methods = signatureMap.get(method.getDeclaringClass());<br>
if (methods != null &amp;&amp; methods.contains(method)) {<br>
return interceptor.intercept(new Invocation(target, method, args));<br>
}<br>
return method.invoke(target, args);<br>
} catch (Exception e) {<br>
throw ExceptionUtil.unwrapThrowable(e);<br>
}<br>
}</p>
<p>private static Map&lt;Class<?>, Set<Method>&gt; getSignatureMap(Interceptor interceptor) {<br>
Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);<br>
// issue #251<br>
if (interceptsAnnotation == null) {<br>
throw new PluginException(&ldquo;No @Intercepts annotation was found in interceptor &quot; + interceptor.getClass().getName());     <br>
}<br>
Signature[] sigs = interceptsAnnotation.value();<br>
Map&lt;Class<?>, Set<Method>&gt; signatureMap = new HashMap&lt;Class<?>, Set<Method>&gt;();<br>
for (Signature sig : sigs) {<br>
Set<Method> methods = signatureMap.get(sig.type());<br>
if (methods == null) {<br>
methods = new HashSet<Method>();<br>
signatureMap.put(sig.type(), methods);<br>
}<br>
try {<br>
Method method = sig.type().getMethod(sig.method(), sig.args());<br>
methods.add(method);<br>
} catch (NoSuchMethodException e) {<br>
throw new PluginException(&ldquo;Could not find method on &quot; + sig.type() + &quot; named &quot; + sig.method() + &ldquo;. Cause: &quot; + e, e);<br>
}<br>
}<br>
return signatureMap;<br>
}</p>
<p>private static Class<?>[] getAllInterfaces(Class<?> type, Map&lt;Class<?>, Set<Method>&gt; signatureMap) {<br>
Set&lt;Class<?>&gt; interfaces = new HashSet&lt;Class<?>&gt;();<br>
while (type != null) {<br>
for (Class<?> c : type.getInterfaces()) {<br>
if (signatureMap.containsKey(c)) {<br>
interfaces.add(c);<br>
}<br>
}<br>
type = type.getSuperclass();<br>
}<br>
return interfaces.toArray(new Class<?>[interfaces.size()]);<br>
}<br>
}</p>
<p>实际上，Plugin 是借助 Java InvocationHandler 实现的动态代理类。用来代理给 target 对象添加 Interceptor 功能。其中，要代理的 target 对象就是 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这四个类的对象。wrap() 静态方法是一个工具函数，用来生成 target 对象的动态代理对象。</p>
<p>当然，只有 interceptor 与 target 互相匹配的时候，wrap() 方法才会返回代理对象，否则就返回 target 对象本身。怎么才算是匹配呢？那就是 interceptor 通过 @Signature 注解要拦截的类包含 target 对象，具体可以参看 wrap() 函数的代码实现（上面一段代码中的第 16~19 行）。</p>
<p>MyBatis 中的职责链模式的实现方式比较特殊。它对同一个目标对象嵌套多次代理（也就是 InteceptorChain 中的 pluginAll() 函数要执行的任务）。每个代理对象（Plugin 对象）代理一个拦截器（Interceptor 对象）功能。为了方便你查看，我将 pluginAll() 函数的代码又拷贝到了下面。</p>
<p>public Object pluginAll(Object target) {<br>
// 嵌套代理<br>
for (Interceptor interceptor : interceptors) {<br>
target = interceptor.plugin(target);<br>
// 上面这行代码等于下面这行代码，target(代理对象)=target(目标对象)+interceptor(拦截器功能)<br>
// target = Plugin.wrap(target, interceptor);<br>
}<br>
return target;<br>
}</p>
<p>// MyBatis 像下面这样创建 target(Executor、StatementHandler、ParameterHandler、ResultSetHandler），相当于多次嵌套代理<br>
Object target = interceptorChain.pluginAll(target);</p>
<p>当执行 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这四个类上的某个方法的时候，MyBatis 会嵌套执行每层代理对象（Plugin 对象）上的 invoke() 方法。而 invoke() 方法会先执行代理对象中的 interceptor 的 intecept() 函数，然后再执行被代理对象上的方法。就这样，一层一层地把代理对象上的 intercept() 函数执行完之后，MyBatis 才最终执行那 4 个原始类对象上的方法。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>好了，今天内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。</p>
<p>今天，我们带你剖析了如何利用职责链模式和动态代理模式来实现 MyBatis Plugin。至此，我们就已经学习了三种职责链常用的应用场景：过滤器（Servlet Filter）、拦截器（Spring Interceptor）、插件（MyBatis Plugin）。</p>
<p>职责链模式的实现一般包含处理器和处理器链两部分。这两个部分对应到 Servlet Filter 的源码就是 Filter 和 FilterChain，对应到 Spring Interceptor 的源码就是 HandlerInterceptor 和 HandlerExecutionChain，对应到 MyBatis Plugin 的源码就是 Interceptor 和 InterceptorChain。除此之外，MyBatis Plugin 还包含另外一个非常重要的类：Plugin 类。它用来生成被拦截对象的动态代理。</p>
<p>在这三种应用场景中，职责链模式的实现思路都不大一样。其中，Servlet Filter 采用递归来实现拦截方法前后添加逻辑。Spring Interceptor 的实现比较简单，把拦截方法前后要添加的逻辑放到两个方法中实现。MyBatis Plugin 采用嵌套动态代理的方法来实现，实现思路很有技巧。</p>
<h2 id="课堂讨论">课堂讨论</h2>
<p>Servlet Filter、Spring Interceptor 可以用来拦截用户自己定义的类的方法，而 MyBatis Plugin 默认可以拦截的只有 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这四个类的方法，而且这四个类是 MyBatis 实现的类，并非用户自己定义的类。那 MyBatis Plugin 为什么不像 Servlet Filter、Spring Interceptor 那样，提供拦截用户自定义类的方法的功能呢？</p>
<p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/">设计模式之美</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/88__%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8C%E6%A1%86%E6%9E%B6/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">88__程序员练级攻略：前端性能优化和框架</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A140%E9%97%AE/88-%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A140%E9%97%AE/">
            <span class="next-text nav-default">88-高并发系统设计40问</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
