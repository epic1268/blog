<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>51__适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="前面几节课我们学习了代理模式、桥接模式、装饰器模式，今天，我们再来学习一个比较常用的结构型模式：适配器模式。这个模式相对来说还是比较简单、好理解的，应用场景也很具体，总体上来讲比较好掌握。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/51__%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%90%86%E9%80%82%E9%85%8D%E5%99%A8%E6%A1%A5%E6%8E%A5%E8%A3%85%E9%A5%B0%E8%BF%99%E5%9B%9B%E4%B8%AA%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/51__%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%90%86%E9%80%82%E9%85%8D%E5%99%A8%E6%A1%A5%E6%8E%A5%E8%A3%85%E9%A5%B0%E8%BF%99%E5%9B%9B%E4%B8%AA%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="51__适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？">
  <meta property="og:description" content="前面几节课我们学习了代理模式、桥接模式、装饰器模式，今天，我们再来学习一个比较常用的结构型模式：适配器模式。这个模式相对来说还是比较简单、好理解的，应用场景也很具体，总体上来讲比较好掌握。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="设计模式之美">

  <meta itemprop="name" content="51__适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？">
  <meta itemprop="description" content="前面几节课我们学习了代理模式、桥接模式、装饰器模式，今天，我们再来学习一个比较常用的结构型模式：适配器模式。这个模式相对来说还是比较简单、好理解的，应用场景也很具体，总体上来讲比较好掌握。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5369">
  <meta itemprop="keywords" content="设计模式之美">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="51__适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？">
  <meta name="twitter:description" content="前面几节课我们学习了代理模式、桥接模式、装饰器模式，今天，我们再来学习一个比较常用的结构型模式：适配器模式。这个模式相对来说还是比较简单、好理解的，应用场景也很具体，总体上来讲比较好掌握。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">51__适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5369 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#适配器模式的原理与实现">适配器模式的原理与实现</a></li>
        <li><a href="#适配器模式应用场景总结">适配器模式应用场景总结</a>
          <ul>
            <li><a href="#1-封装有缺陷的接口设计">1. 封装有缺陷的接口设计</a></li>
            <li><a href="#2-统一多个类的接口设计">2. 统一多个类的接口设计</a></li>
            <li><a href="#3-替换依赖的外部系统">3. 替换依赖的外部系统</a></li>
            <li><a href="#4-兼容老版本接口">4. 兼容老版本接口</a></li>
            <li><a href="#5-适配不同格式的数据">5. 适配不同格式的数据</a></li>
          </ul>
        </li>
        <li><a href="#剖析适配器模式在-java-日志中的应用">剖析适配器模式在 Java 日志中的应用</a></li>
        <li><a href="#代理桥接装饰器适配器-4-种设计模式的区别">代理、桥接、装饰器、适配器 4 种设计模式的区别</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#课堂讨论">课堂讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>前面几节课我们学习了代理模式、桥接模式、装饰器模式，今天，我们再来学习一个比较常用的结构型模式：适配器模式。这个模式相对来说还是比较简单、好理解的，应用场景也很具体，总体上来讲比较好掌握。</p>
<p>关于适配器模式，今天我们主要学习它的两种实现方式，类适配器和对象适配器，以及 5 种常见的应用场景。同时，我还会通过剖析 slf4j 日志框架，来给你展示这个模式在真实项目中的应用。除此之外，在文章的最后，我还对代理、桥接、装饰器、适配器，这 4 种代码结构非常相似的设计模式做简单的对比，对这几节内容做一个简单的总结。</p>
<p>话不多说，让我们正式开始今天的学习吧！</p>
<h2 id="适配器模式的原理与实现">适配器模式的原理与实现</h2>
<p><strong>适配器模式</strong>的英文翻译是 <strong>Adapter Design Pattern</strong>。顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p>
<p>原理很简单，我们再来看下它的代码实现。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。</p>
<p>// 类适配器：基于继承<br>
public interface ITarget {<br>
void f1();<br>
void f2();<br>
void fc();<br>
}</p>
<p>public class Adaptee {<br>
public void fa() { //&hellip; }<br>
public void fb() { //&hellip; }<br>
public void fc() { //&hellip; }<br>
}</p>
<p>public class Adaptor extends Adaptee implements ITarget {<br>
public void f1() {<br>
super.fa();<br>
}</p>
<p>public void f2() {<br>
//&hellip;重新实现 f2()&hellip;<br>
}</p>
<p>// 这里 fc() 不需要实现，直接继承自 Adaptee，这是跟对象适配器最大的不同点<br>
}</p>
<p>// 对象适配器：基于组合<br>
public interface ITarget {<br>
void f1();<br>
void f2();<br>
void fc();<br>
}</p>
<p>public class Adaptee {<br>
public void fa() { //&hellip; }<br>
public void fb() { //&hellip; }<br>
public void fc() { //&hellip; }<br>
}</p>
<p>public class Adaptor implements ITarget {<br>
private Adaptee adaptee;</p>
<p>public Adaptor(Adaptee adaptee) {<br>
this.adaptee = adaptee;<br>
}</p>
<p>public void f1() {<br>
adaptee.fa(); //委托给 Adaptee<br>
}</p>
<p>public void f2() {<br>
//&hellip;重新实现 f2()&hellip;<br>
}</p>
<p>public void fc() {<br>
adaptee.fc();<br>
}<br>
}</p>
<p>针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度。</p>
<ol>
<li>如果 Adaptee 接口并不多，那两种实现方式都可以。</li>
<li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。</li>
<li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</li>
</ol>
<h2 id="适配器模式应用场景总结">适配器模式应用场景总结</h2>
<p>原理和实现讲完了，都不复杂。我们再来看，到底什么时候会用到适配器模式呢？</p>
<p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p>
<p>前面我们反复提到，适配器模式的应用场景是“接口不兼容”。那在实际的开发中，什么情况下才会出现接口不兼容呢？我建议你先自己思考一下这个问题，然后再来看我下面的总结。</p>
<h3 id="1-封装有缺陷的接口设计">1. 封装有缺陷的接口设计</h3>
<p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p>
<p>具体我还是举个例子来解释一下，你直接看代码应该会更清晰。具体代码如下所示：</p>
<p>public class CD { //这个类来自外部 sdk，我们无权修改它的代码<br>
//&hellip;<br>
public static void staticFunction1() { //&hellip; }</p>
<p>public void uglyNamingFunction2() { //&hellip; }</p>
<p>public void tooManyParamsFunction3(int paramA, int paramB, &hellip;) { //&hellip; }</p>
<p>public void lowPerformanceFunction4() { //&hellip; }<br>
}</p>
<p>// 使用适配器模式进行重构<br>
public class ITarget {<br>
void function1();<br>
void function2();<br>
void fucntion3(ParamsWrapperDefinition paramsWrapper);<br>
void function4();<br>
//&hellip;<br>
}<br>
// 注意：适配器类的命名不一定非得末尾带 Adaptor<br>
public class CDAdaptor extends CD implements ITarget {<br>
//&hellip;<br>
public void function1() {<br>
super.staticFunction1();<br>
}</p>
<p>public void function2() {<br>
super.uglyNamingFucntion2();<br>
}</p>
<p>public void function3(ParamsWrapperDefinition paramsWrapper) {<br>
super.tooManyParamsFunction3(paramsWrapper.getParamA(), &hellip;);<br>
}</p>
<p>public void function4() {<br>
//&hellip;reimplement it&hellip;<br>
}<br>
}</p>
<h3 id="2-统一多个类的接口设计">2. 统一多个类的接口设计</h3>
<p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体我还是举个例子来解释一下。</p>
<p>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。</p>
<p>你可以配合着下面的代码示例，来理解我刚才举的这个例子。</p>
<p>public class ASensitiveWordsFilter { // A 敏感词过滤系统提供的接口<br>
//text 是原始文本，函数输出用***替换敏感词之后的文本<br>
public String filterSexyWords(String text) {<br>
// &hellip;<br>
}</p>
<p>public String filterPoliticalWords(String text) {<br>
// &hellip;<br>
}<br>
}</p>
<p>public class BSensitiveWordsFilter  { // B 敏感词过滤系统提供的接口<br>
public String filter(String text) {<br>
//&hellip;<br>
}<br>
}</p>
<p>public class CSensitiveWordsFilter { // C 敏感词过滤系统提供的接口<br>
public String filter(String text, String mask) {<br>
//&hellip;<br>
}<br>
}</p>
<p>// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好<br>
public class RiskManagement {<br>
private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter();<br>
private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter();<br>
private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter();</p>
<p>public String filterSensitiveWords(String text) {<br>
String maskedText = aFilter.filterSexyWords(text);<br>
maskedText = aFilter.filterPoliticalWords(maskedText);<br>
maskedText = bFilter.filter(maskedText);<br>
maskedText = cFilter.filter(maskedText, &ldquo;***&rdquo;);<br>
return maskedText;<br>
}<br>
}</p>
<p>// 使用适配器模式进行改造<br>
public interface ISensitiveWordsFilter { // 统一接口定义<br>
String filter(String text);<br>
}</p>
<p>public class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter {<br>
private ASensitiveWordsFilter aFilter;<br>
public String filter(String text) {<br>
String maskedText = aFilter.filterSexyWords(text);<br>
maskedText = aFilter.filterPoliticalWords(maskedText);<br>
return maskedText;<br>
}<br>
}<br>
//&hellip;省略 BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor&hellip;</p>
<p>// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，<br>
// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。<br>
public class RiskManagement {<br>
private List<ISensitiveWordsFilter> filters = new ArrayList&lt;&gt;();</p>
<p>public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) {<br>
filters.add(filter);<br>
}</p>
<p>public String filterSensitiveWords(String text) {<br>
String maskedText = text;<br>
for (ISensitiveWordsFilter filter : filters) {<br>
maskedText = filter.filter(maskedText);<br>
}<br>
return maskedText;<br>
}<br>
}</p>
<h3 id="3-替换依赖的外部系统">3. 替换依赖的外部系统</h3>
<p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。具体的代码示例如下所示：</p>
<p>// 外部系统 A<br>
public interface IA {<br>
//&hellip;<br>
void fa();<br>
}<br>
public class A implements IA {<br>
//&hellip;<br>
public void fa() { //&hellip; }<br>
}<br>
// 在我们的项目中，外部系统 A 的使用示例<br>
public class Demo {<br>
private IA a;<br>
public Demo(IA a) {<br>
this.a = a;<br>
}<br>
//&hellip;<br>
}<br>
Demo d = new Demo(new A());</p>
<p>// 将外部系统 A 替换成外部系统 B<br>
public class BAdaptor implemnts IA {<br>
private B b;<br>
public BAdaptor(B b) {<br>
this.b= b;<br>
}<br>
public void fa() {<br>
//&hellip;<br>
b.fb();<br>
}<br>
}<br>
// 借助 BAdaptor，Demo 的代码中，调用 IA 接口的地方都无需改动，<br>
// 只需要将 BAdaptor 如下注入到 Demo 即可。<br>
Demo d = new Demo(new BAdaptor(new B()));</p>
<h3 id="4-兼容老版本接口">4. 兼容老版本接口</h3>
<p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。同样，我还是通过一个例子，来进一步解释一下。</p>
<p>JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使用 Iterator 才行。</p>
<p>单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码，我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下所示：</p>
<p>public class Collections {<br>
public static Emueration emumeration(final Collection c) {<br>
return new Enumeration() {<br>
Iterator i = c.iterator();</p>
<pre><code>  public boolean hasMoreElments() {  
    return i.hashNext();  
  }  
    
  public Object nextElement() {  
    return i.next():  
  }  
}  
</code></pre>
<p>}<br>
}</p>
<h3 id="5-适配不同格式的数据">5. 适配不同格式的数据</h3>
<p>前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p>
<p>List<String> stooges = Arrays.asList(&ldquo;Larry&rdquo;, &ldquo;Moe&rdquo;, &ldquo;Curly&rdquo;);</p>
<h2 id="剖析适配器模式在-java-日志中的应用">剖析适配器模式在 Java 日志中的应用</h2>
<p>Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。</p>
<p>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像 JDBC 那样，一开始就制定了数据库操作的接口规范。</p>
<p>如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。</p>
<p>比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是 logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。</p>
<p>如果你是做 Java 开发的，那 Slf4j 这个日志框架你肯定不陌生，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。</p>
<p>不仅如此，Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合 Slf4j 接口规范。Slf4j 也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。具体的代码示例如下所示：</p>
<p>// slf4j 统一的接口定义<br>
package org.slf4j;<br>
public interface Logger {<br>
public boolean isTraceEnabled();<br>
public void trace(String msg);<br>
public void trace(String format, Object arg);<br>
public void trace(String format, Object arg1, Object arg2);<br>
public void trace(String format, Object[] argArray);<br>
public void trace(String msg, Throwable t);</p>
<p>public boolean isDebugEnabled();<br>
public void debug(String msg);<br>
public void debug(String format, Object arg);<br>
public void debug(String format, Object arg1, Object arg2)<br>
public void debug(String format, Object[] argArray)<br>
public void debug(String msg, Throwable t);</p>
<p>//&hellip;省略 info、warn、error 等一堆接口<br>
}</p>
<p>// log4j 日志框架的适配器<br>
// Log4jLoggerAdapter 实现了 LocationAwareLogger 接口，<br>
// 其中 LocationAwareLogger 继承自 Logger 接口，<br>
// 也就相当于 Log4jLoggerAdapter 实现了 Logger 接口。<br>
package org.slf4j.impl;<br>
public final class Log4jLoggerAdapter extends MarkerIgnoringBase<br>
implements LocationAwareLogger, Serializable {<br>
final transient org.apache.log4j.Logger logger; // log4j</p>
<p>public boolean isDebugEnabled() {<br>
return logger.isDebugEnabled();<br>
}</p>
<p>public void debug(String msg) {<br>
logger.log(FQCN, Level.DEBUG, msg, null);<br>
}</p>
<p>public void debug(String format, Object arg) {<br>
if (logger.isDebugEnabled()) {<br>
FormattingTuple ft = MessageFormatter.format(format, arg);<br>
logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>
}<br>
}</p>
<p>public void debug(String format, Object arg1, Object arg2) {<br>
if (logger.isDebugEnabled()) {<br>
FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);<br>
logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>
}<br>
}</p>
<p>public void debug(String format, Object[] argArray) {<br>
if (logger.isDebugEnabled()) {<br>
FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);<br>
logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());<br>
}<br>
}</p>
<p>public void debug(String msg, Throwable t) {<br>
logger.log(FQCN, Level.DEBUG, msg, t);<br>
}<br>
//&hellip;省略一堆接口的实现&hellip;<br>
}</p>
<p>所以，在开发业务系统或者开发框架、组件的时候，我们统一使用 Slf4j 提供的接口来编写打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定的（使用 Java 的 SPI 技术，这里我不多解释，你自行研究吧），只需要将相应的 SDK 导入到项目中即可。</p>
<p>不过，你可能会说，如果一些老的项目没有使用 Slf4j，而是直接使用比如 JCL 来打印日志，那如果想要替换成其他日志框架，比如 log4j，该怎么办呢？实际上，Slf4j 不仅仅提供了从其他日志框架到 Slf4j 的适配器，还提供了反向适配器，也就是从 Slf4j 到其他日志框架的适配。我们可以先将 JCL 切换为 Slf4j，然后再将 Slf4j 切换为 log4j。经过两次适配器的转换，我们能就成功将 log4j 切换为了 logback。</p>
<h2 id="代理桥接装饰器适配器-4-种设计模式的区别">代理、桥接、装饰器、适配器 4 种设计模式的区别</h2>
<p>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。</p>
<p>尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。这里我就简单说一下它们之间的区别。</p>
<p>**代理模式：**代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</p>
<p>**桥接模式：**桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</p>
<p>**装饰器模式：**装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</p>
<p>**适配器模式：**适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>好了，今天的内容到此就讲完了。让我们一块来总结回顾一下，你需要重点掌握的内容。</p>
<p>适配器模式是用来做适配，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p>
<p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”，如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p>
<p>那在实际的开发中，什么情况下才会出现接口不兼容呢？我总结下了下面这样 5 种场景：</p>
<ol>
<li>封装有缺陷的接口设计</li>
<li>统一多个类的接口设计</li>
<li>替换依赖的外部系统</li>
<li>兼容老版本接口</li>
<li>适配不同格式的数据</li>
</ol>
<h2 id="课堂讨论">课堂讨论</h2>
<p>今天我们讲到，适配器有两种实现方式：类适配器、对象适配器。那我们之前讲到的代理模式、装饰器模式，是否也同样可以有两种实现方式（类代理模式、对象代理模式，以及类装饰器模式、对象装饰器模式）呢？</p>
<p>欢迎留言和我分享你的思考，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/">设计模式之美</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%9552%E8%AE%B2/51__%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%BD%91%E7%AB%99%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">51__深入浅出网站伸缩性架构设计</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes/51__%E8%B0%88%E8%B0%88kubernetes%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E5%92%8C%E6%9C%AA%E6%9D%A5%E8%B5%B0%E5%90%91/">
            <span class="next-text nav-default">51__谈谈Kubernetes开源社区和未来走向</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
