<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>66__迭代器模式（中）：遍历集合的同时，为什么不能增删集合元素？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="上一节课中，我们通过给 ArrayList、LinkedList 容器实现迭代器，学习了迭代器模式的原理、实现和设计意图。迭代器模式主要作用是解耦容器代码和遍历代码，这也印证了我们前面多次讲过的应用设计模式的主要目的是解耦。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/66__%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%AD%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E7%9A%84%E5%90%8C%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%A2%9E%E5%88%A0%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/66__%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%AD%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E7%9A%84%E5%90%8C%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%A2%9E%E5%88%A0%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="66__迭代器模式（中）：遍历集合的同时，为什么不能增删集合元素？">
  <meta property="og:description" content="上一节课中，我们通过给 ArrayList、LinkedList 容器实现迭代器，学习了迭代器模式的原理、实现和设计意图。迭代器模式主要作用是解耦容器代码和遍历代码，这也印证了我们前面多次讲过的应用设计模式的主要目的是解耦。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="设计模式之美">

  <meta itemprop="name" content="66__迭代器模式（中）：遍历集合的同时，为什么不能增删集合元素？">
  <meta itemprop="description" content="上一节课中，我们通过给 ArrayList、LinkedList 容器实现迭代器，学习了迭代器模式的原理、实现和设计意图。迭代器模式主要作用是解耦容器代码和遍历代码，这也印证了我们前面多次讲过的应用设计模式的主要目的是解耦。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3971">
  <meta itemprop="keywords" content="设计模式之美">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="66__迭代器模式（中）：遍历集合的同时，为什么不能增删集合元素？">
  <meta name="twitter:description" content="上一节课中，我们通过给 ArrayList、LinkedList 容器实现迭代器，学习了迭代器模式的原理、实现和设计意图。迭代器模式主要作用是解耦容器代码和遍历代码，这也印证了我们前面多次讲过的应用设计模式的主要目的是解耦。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">66__迭代器模式（中）：遍历集合的同时，为什么不能增删集合元素？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3971 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#在遍历的同时增删集合元素会发生什么">在遍历的同时增删集合元素会发生什么？</a></li>
        <li><a href="#如何应对遍历时改变集合导致的未决行为">如何应对遍历时改变集合导致的未决行为？</a></li>
        <li><a href="#如何在遍历的同时安全地删除集合元素">如何在遍历的同时安全地删除集合元素？</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#课堂讨论">课堂讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>上一节课中，我们通过给 ArrayList、LinkedList 容器实现迭代器，学习了迭代器模式的原理、实现和设计意图。迭代器模式主要作用是解耦容器代码和遍历代码，这也印证了我们前面多次讲过的应用设计模式的主要目的是解耦。</p>
<p>上一节课中讲解的内容都比较基础，今天，我们来深挖一下，如果在使用迭代器遍历集合的同时增加、删除集合中的元素，会发生什么情况？应该如何应对？如何在遍历的同时安全地删除集合元素？</p>
<p>话不多说，让我们正式开始今天的内容吧！</p>
<h2 id="在遍历的同时增删集合元素会发生什么">在遍历的同时增删集合元素会发生什么？</h2>
<p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为<strong>结果不可预期行为</strong>或者<strong>未决行为</strong>，也就是说，运行结果到底是对还是错，要视情况而定。</p>
<p>怎么理解呢？我们通过一个例子来解释一下。我们还是延续上一节课实现的 ArrayList 迭代器的例子。为了方便你查看，我把相关的代码都重新拷贝到这里了。</p>
<p>public interface Iterator<E> {<br>
boolean hasNext();<br>
void next();<br>
E currentItem();<br>
}</p>
<p>public class ArrayIterator<E> implements Iterator<E> {<br>
private int cursor;<br>
private ArrayList<E> arrayList;</p>
<p>public ArrayIterator(ArrayList<E> arrayList) {<br>
this.cursor = 0;<br>
this.arrayList = arrayList;<br>
}</p>
<p>@Override<br>
public boolean hasNext() {<br>
return cursor &lt; arrayList.size();<br>
}</p>
<p>@Override<br>
public void next() {<br>
cursor++;<br>
}</p>
<p>@Override<br>
public E currentItem() {<br>
if (cursor &gt;= arrayList.size()) {<br>
throw new NoSuchElementException();<br>
}<br>
return arrayList.get(cursor);<br>
}<br>
}</p>
<p>public interface List<E> {<br>
Iterator iterator();<br>
}</p>
<p>public class ArrayList<E> implements List<E> {<br>
//&hellip;<br>
public Iterator iterator() {<br>
return new ArrayIterator(this);<br>
}<br>
//&hellip;<br>
}</p>
<p>public class Demo {<br>
public static void main(String[] args) {<br>
List<String> names = new ArrayList&lt;&gt;();<br>
names.add(&ldquo;a&rdquo;);<br>
names.add(&ldquo;b&rdquo;);<br>
names.add(&ldquo;c&rdquo;);<br>
names.add(&ldquo;d&rdquo;);</p>
<pre><code>Iterator&lt;String&gt; iterator = names.iterator();  
iterator.next();  
names.remove(&quot;a&quot;);  
</code></pre>
<p>}<br>
}</p>
<p>我们知道，ArrayList 底层对应的是数组这种数据结构，在执行完第 55 行代码的时候，数组中存储的是 a、b、c、d 四个元素，迭代器的游标 cursor 指向元素 a。当执行完第 56 行代码的时候，游标指向元素 b，到这里都没有问题。</p>
<p>为了保持数组存储数据的连续性，数组的删除操作会涉及元素的搬移（详细的讲解你可以去看我的另一个专栏《数据结构与算法之美》）。当执行到第 57 行代码的时候，我们从数组中将元素 a 删除掉，b、c、d 三个元素会依次往前搬移一位，这就会导致游标本来指向元素 b，现在变成了指向元素 c。原本在执行完第 56 行代码之后，我们还可以遍历到 b、c、d 三个元素，但在执行完第 57 行代码之后，我们只能遍历到 c、d 两个元素，b 遍历不到了。</p>
<p>对于上面的描述，我画了一张图，你可以对照着理解。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/587a76e6f0e390f267d58409f57c1f78.png" alt=""></p>
<p>不过，如果第 57 行代码删除的不是游标前面的元素（元素 a）以及游标所在位置的元素（元素 b），而是游标后面的元素（元素 c 和 d），这样就不会存在任何问题了，不会存在某个元素遍历不到的情况了。</p>
<p>所以，我们前面说，在遍历的过程中删除集合元素，结果是不可预期的，有时候没问题（删除元素 c 或 d），有时候就有问题（删除元素 a 或 b），这个要视情况而定（到底删除的是哪个位置的元素），就是这个意思。</p>
<p>在遍历的过程中删除集合元素，有可能会导致某个元素遍历不到，那在遍历的过程中添加集合元素，会发生什么情况呢？还是结合刚刚那个例子来讲解，我们将上面的代码稍微改造一下，把删除元素改为添加元素。具体的代码如下所示：</p>
<p>public class Demo {<br>
public static void main(String[] args) {<br>
List<String> names = new ArrayList&lt;&gt;();<br>
names.add(&ldquo;a&rdquo;);<br>
names.add(&ldquo;b&rdquo;);<br>
names.add(&ldquo;c&rdquo;);<br>
names.add(&ldquo;d&rdquo;);</p>
<pre><code>Iterator&lt;String&gt; iterator = names.iterator();  
iterator.next();  
names.add(0, &quot;x&quot;);  
</code></pre>
<p>}<br>
}</p>
<p>在执行完第 10 行代码之后，数组中包含 a、b、c、d 四个元素，游标指向 b 这个元素，已经跳过了元素 a。在执行完第 11 行代码之后，我们将 x 插入到下标为 0 的位置，a、b、c、d 四个元素依次往后移动一位。这个时候，游标又重新指向了元素 a。元素 a 被游标重复指向两次，也就是说，元素 a 存在被重复遍历的情况。</p>
<p>跟删除情况类似，如果我们在游标的后面添加元素，就不会存在任何问题。所以，在遍历的同时添加集合元素也是一种不可预期行为。</p>
<p>同样，对于上面的添加元素的情况，我们也画了一张图，如下所示，你可以对照着理解。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/9258e4226a0282e81106d7e5a6ee1e09.png" alt=""></p>
<h2 id="如何应对遍历时改变集合导致的未决行为">如何应对遍历时改变集合导致的未决行为？</h2>
<p>当通过迭代器来遍历集合的时候，增加、删除集合元素会导致不可预期的遍历结果。实际上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 debug 的 bug 就是这么产生的。那我们如何才能避免出现这种不可预期的运行结果呢？</p>
<p>有两种比较干脆利索的解决方案：一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。</p>
<p>实际上，第一种解决方案比较难实现，我们要确定遍历开始和结束的时间点。遍历开始的时间节点我们很容易获得。我们可以把创建迭代器的时间点作为遍历开始的时间点。但是，遍历结束的时间点该如何来确定呢？</p>
<p>你可能会说，遍历到最后一个元素的时候就算结束呗。但是，在实际的软件开发中，每次使用迭代器来遍历元素，并不一定非要把所有元素都遍历一遍。如下所示，我们找到一个值为 b 的元素就提前结束了遍历。</p>
<p>public class Demo {<br>
public static void main(String[] args) {<br>
List<String> names = new ArrayList&lt;&gt;();<br>
names.add(&ldquo;a&rdquo;);<br>
names.add(&ldquo;b&rdquo;);<br>
names.add(&ldquo;c&rdquo;);<br>
names.add(&ldquo;d&rdquo;);</p>
<pre><code>Iterator&lt;String&gt; iterator = names.iterator();  
while (iterator.hasNext()) {  
  String name = iterator.currentItem();  
  if (name.equals(&quot;b&quot;)) {  
    break;  
  }  
}  
</code></pre>
<p>}<br>
}</p>
<p>你可能还会说，那我们可以在迭代器类中定义一个新的接口 finishIteration()，主动告知容器迭代器使用完了，你可以增删元素了，示例代码如下所示。但是，这就要求程序员在使用完迭代器之后要主动调用这个函数，也增加了开发成本，还很容易漏掉。</p>
<p>public class Demo {<br>
public static void main(String[] args) {<br>
List<String> names = new ArrayList&lt;&gt;();<br>
names.add(&ldquo;a&rdquo;);<br>
names.add(&ldquo;b&rdquo;);<br>
names.add(&ldquo;c&rdquo;);<br>
names.add(&ldquo;d&rdquo;);</p>
<pre><code>Iterator&lt;String&gt; iterator = names.iterator();  
while (iterator.hasNext()) {  
  String name = iterator.currentItem();  
  if (name.equals(&quot;b&quot;)) {  
    iterator.finishIteration();//主动告知容器这个迭代器用完了  
    break;  
  }  
}  
</code></pre>
<p>}<br>
}</p>
<p>实际上，第二种解决方法更加合理。Java 语言就是采用的这种解决方案，增删元素之后，让遍历报错。接下来，我们具体来看一下如何实现。</p>
<p>怎么确定在遍历时候，集合有没有增删元素呢？我们在 ArrayList 中定义一个成员变量 modCount，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给 modCount 加 1。当通过调用集合上的 iterator() 函数来创建迭代器的时候，我们把 modCount 值传递给迭代器的 expectedModCount 成员变量，之后每次调用迭代器上的 hasNext()、next()、currentItem() 函数，我们都会检查集合上的 modCount 是否等于 expectedModCount，也就是看，在创建完迭代器之后，modCount 是否改变过。</p>
<p>如果两个值不相同，那就说明集合存储的元素已经改变了，要么增加了元素，要么删除了元素，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以我们选择 fail-fast 解决方式，抛出运行时异常，结束掉程序，让程序员尽快修复这个因为不正确使用迭代器而产生的 bug。</p>
<p>上面的描述翻译成代码就是下面这样子。你可以结合着代码一起理解我刚才的讲解。</p>
<p>public class ArrayIterator implements Iterator {<br>
private int cursor;<br>
private ArrayList arrayList;<br>
private int expectedModCount;</p>
<p>public ArrayIterator(ArrayList arrayList) {<br>
this.cursor = 0;<br>
this.arrayList = arrayList;<br>
this.expectedModCount = arrayList.modCount;<br>
}</p>
<p>@Override<br>
public boolean hasNext() {<br>
checkForComodification();<br>
return cursor &lt; arrayList.size();<br>
}</p>
<p>@Override<br>
public void next() {<br>
checkForComodification();<br>
cursor++;<br>
}</p>
<p>@Override<br>
public Object currentItem() {<br>
checkForComodification();<br>
return arrayList.get(cursor);<br>
}</p>
<p>private void checkForComodification() {<br>
if (arrayList.modCount != expectedModCount)<br>
throw new ConcurrentModificationException();<br>
}<br>
}</p>
<p>//代码示例<br>
public class Demo {<br>
public static void main(String[] args) {<br>
List<String> names = new ArrayList&lt;&gt;();<br>
names.add(&ldquo;a&rdquo;);<br>
names.add(&ldquo;b&rdquo;);<br>
names.add(&ldquo;c&rdquo;);<br>
names.add(&ldquo;d&rdquo;);</p>
<pre><code>Iterator&lt;String&gt; iterator = names.iterator();  
iterator.next();  
names.remove(&quot;a&quot;);  
iterator.next();//抛出 ConcurrentModificationException 异常  
</code></pre>
<p>}<br>
}</p>
<h2 id="如何在遍历的同时安全地删除集合元素">如何在遍历的同时安全地删除集合元素？</h2>
<p>像 Java 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 remove() 方法，能够在遍历集合的同时，安全地删除集合中的元素。不过，需要说明的是，它并没有提供添加元素的方法。毕竟迭代器的主要作用是遍历，添加元素放到迭代器里本身就不合适。</p>
<p>我个人觉得，Java 迭代器中提供的 remove() 方法还是比较鸡肋的，作用有限。它只能删除游标指向的前一个元素，而且一个 next() 函数之后，只能跟着最多一个 remove() 操作，多次调用 remove() 操作会报错。我还是通过一个例子来解释一下。</p>
<p>public class Demo {<br>
public static void main(String[] args) {<br>
List<String> names = new ArrayList&lt;&gt;();<br>
names.add(&ldquo;a&rdquo;);<br>
names.add(&ldquo;b&rdquo;);<br>
names.add(&ldquo;c&rdquo;);<br>
names.add(&ldquo;d&rdquo;);</p>
<pre><code>Iterator&lt;String&gt; iterator = names.iterator();  
iterator.next();  
iterator.remove();  
iterator.remove(); //报错，抛出 IllegalStateException 异常  
</code></pre>
<p>}<br>
}</p>
<p>现在，我们一块来看下，为什么通过迭代器就能安全的删除集合中的元素呢？源码之下无秘密。我们来看下 remove() 函数是如何实现的，代码如下所示。稍微提醒一下，在 Java 实现中，迭代器类是容器类的内部类，并且 next() 函数不仅将游标后移一位，还会返回当前的元素。</p>
<p>public class ArrayList<E> {<br>
transient Object[] elementData;<br>
private int size;</p>
<p>public Iterator<E> iterator() {<br>
return new Itr();<br>
}</p>
<p>private class Itr implements Iterator<E> {<br>
int cursor;       // index of next element to return<br>
int lastRet = -1; // index of last element returned; -1 if no such<br>
int expectedModCount = modCount;</p>
<pre><code>Itr() {}  

public boolean hasNext() {  
  return cursor != size;  
}  

@SuppressWarnings(&quot;unchecked&quot;)  
public E next() {  
  checkForComodification();  
  int i = cursor;  
  if (i &gt;= size)  
    throw new NoSuchElementException();  
  Object[] elementData = ArrayList.this.elementData;  
  if (i &gt;= elementData.length)  
    throw new ConcurrentModificationException();  
  cursor = i + 1;  
  return (E) elementData[lastRet = i];  
}  
  
public void remove() {  
  if (lastRet &lt; 0)  
    throw new IllegalStateException();  
  checkForComodification();  

  try {  
    ArrayList.this.remove(lastRet);  
    cursor = lastRet;  
    lastRet = -1;  
    expectedModCount = modCount;  
  } catch (IndexOutOfBoundsException ex) {  
    throw new ConcurrentModificationException();  
  }  
}  
</code></pre>
<p>}<br>
}</p>
<p>在上面的代码实现中，迭代器类新增了一个 lastRet 成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和 lastRet 值，来保证不会因为删除元素而导致某个元素遍历不到。如果通过容器来删除元素，并且希望更新迭代器中的游标值来保证遍历不出错，我们就要维护这个容器都创建了哪些迭代器，每个迭代器是否还在使用等信息，代码实现就变得比较复杂了。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p>
<p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为。实际上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 debug 的 bug 就是这么产生的。</p>
<p>有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理。Java 语言就是采用的这种解决方案。增删元素之后，我们选择 fail-fast 解决方式，让遍历操作直接抛出运行时异常。</p>
<p>像 Java 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 remove() 方法，能够在遍历集合的同时，安全地删除集合中的元素。</p>
<h2 id="课堂讨论">课堂讨论</h2>
<ol>
<li>基于文章中给出的 Java 迭代器的实现代码，如果一个容器对象同时创建了两个迭代器，一个迭代器调用了 remove() 方法删除了集合中的一个元素，那另一个迭代器是否还可用？或者，我换个问法，下面代码中的第 13 行的运行结果是什么？</li>
</ol>
<p>public class Demo {<br>
public static void main(String[] args) {<br>
List<String> names = new ArrayList&lt;&gt;();<br>
names.add(&ldquo;a&rdquo;);<br>
names.add(&ldquo;b&rdquo;);<br>
names.add(&ldquo;c&rdquo;);<br>
names.add(&ldquo;d&rdquo;);</p>
<pre><code>Iterator&lt;String&gt; iterator1 = names.iterator();  
Iterator&lt;String&gt; iterator2 = names.iterator();  
iterator1.next();  
iterator1.remove();  
iterator2.next(); // 运行结果？  
</code></pre>
<p>}<br>
}</p>
<ol>
<li>LinkedList 底层基于链表，如果在遍历的同时，增加删除元素，会出现哪些不可预期的行为呢？</li>
</ol>
<p>欢迎留言和我分享你的想法。如果有收获，欢迎你把这篇文章分享给你的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/">设计模式之美</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/65__%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%E7%94%A8%E4%B8%80%E4%B8%AA%E5%88%9B%E4%B8%9A%E6%95%85%E4%BA%8B%E4%B8%B2%E8%B5%B7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%9B%9B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">65__知识串讲：用一个创业故事串起操作系统原理（四）</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/66__%E6%9E%B6%E6%9E%84%E8%80%81%E5%8C%96%E4%B8%8E%E9%87%8D%E6%9E%84/">
            <span class="next-text nav-default">66__架构老化与重构</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
