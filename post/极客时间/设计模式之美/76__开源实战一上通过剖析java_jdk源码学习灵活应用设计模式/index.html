<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>76__开源实战一（上）：通过剖析Java_JDK源码学习灵活应用设计模式 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="从今天开始，我们就正式地进入到实战环节。实战环节包括两部分，一部分是开源项目实战，另一部分是项目实战。
在开源项目实战部分，我会带你剖析几个经典的开源项目中用到的设计原则、思想和模式，这其中就包括对 Java JDK、Unix、Google Guava、Spring、MyBatis 这样五个开源项目的分析。在项目实战部分，我们精心挑选了几个实战项目，手把手地带你利用之前学过的设计原则、思想、模式，来对它们进行分析、设计和代码实现，这其中就包括鉴权限流、幂等重试、灰度发布这样三个项目。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/76__%E5%BC%80%E6%BA%90%E5%AE%9E%E6%88%98%E4%B8%80%E4%B8%8A%E9%80%9A%E8%BF%87%E5%89%96%E6%9E%90java_jdk%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/76__%E5%BC%80%E6%BA%90%E5%AE%9E%E6%88%98%E4%B8%80%E4%B8%8A%E9%80%9A%E8%BF%87%E5%89%96%E6%9E%90java_jdk%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="76__开源实战一（上）：通过剖析Java_JDK源码学习灵活应用设计模式">
  <meta property="og:description" content="从今天开始，我们就正式地进入到实战环节。实战环节包括两部分，一部分是开源项目实战，另一部分是项目实战。
在开源项目实战部分，我会带你剖析几个经典的开源项目中用到的设计原则、思想和模式，这其中就包括对 Java JDK、Unix、Google Guava、Spring、MyBatis 这样五个开源项目的分析。在项目实战部分，我们精心挑选了几个实战项目，手把手地带你利用之前学过的设计原则、思想、模式，来对它们进行分析、设计和代码实现，这其中就包括鉴权限流、幂等重试、灰度发布这样三个项目。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="设计模式之美">

  <meta itemprop="name" content="76__开源实战一（上）：通过剖析Java_JDK源码学习灵活应用设计模式">
  <meta itemprop="description" content="从今天开始，我们就正式地进入到实战环节。实战环节包括两部分，一部分是开源项目实战，另一部分是项目实战。
在开源项目实战部分，我会带你剖析几个经典的开源项目中用到的设计原则、思想和模式，这其中就包括对 Java JDK、Unix、Google Guava、Spring、MyBatis 这样五个开源项目的分析。在项目实战部分，我们精心挑选了几个实战项目，手把手地带你利用之前学过的设计原则、思想、模式，来对它们进行分析、设计和代码实现，这其中就包括鉴权限流、幂等重试、灰度发布这样三个项目。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4122">
  <meta itemprop="keywords" content="设计模式之美">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="76__开源实战一（上）：通过剖析Java_JDK源码学习灵活应用设计模式">
  <meta name="twitter:description" content="从今天开始，我们就正式地进入到实战环节。实战环节包括两部分，一部分是开源项目实战，另一部分是项目实战。
在开源项目实战部分，我会带你剖析几个经典的开源项目中用到的设计原则、思想和模式，这其中就包括对 Java JDK、Unix、Google Guava、Spring、MyBatis 这样五个开源项目的分析。在项目实战部分，我们精心挑选了几个实战项目，手把手地带你利用之前学过的设计原则、思想、模式，来对它们进行分析、设计和代码实现，这其中就包括鉴权限流、幂等重试、灰度发布这样三个项目。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">76__开源实战一（上）：通过剖析Java_JDK源码学习灵活应用设计模式</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4122 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#工厂模式在-calendar-类中的应用">工厂模式在 Calendar 类中的应用</a></li>
        <li><a href="#建造者模式在-calendar-类中的应用">建造者模式在 Calendar 类中的应用</a></li>
        <li><a href="#装饰器模式在-collections-类中的应用">装饰器模式在 Collections 类中的应用</a></li>
        <li><a href="#适配器模式在-collections-类中的应用">适配器模式在 Collections 类中的应用</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#课堂讨论">课堂讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>从今天开始，我们就正式地进入到实战环节。实战环节包括两部分，一部分是开源项目实战，另一部分是项目实战。</p>
<p>在开源项目实战部分，我会带你剖析几个经典的开源项目中用到的设计原则、思想和模式，这其中就包括对 Java JDK、Unix、Google Guava、Spring、MyBatis 这样五个开源项目的分析。在项目实战部分，我们精心挑选了几个实战项目，手把手地带你利用之前学过的设计原则、思想、模式，来对它们进行分析、设计和代码实现，这其中就包括鉴权限流、幂等重试、灰度发布这样三个项目。</p>
<p>接下来的两节课，我们重点剖析 Java JDK 中用到的几种常见的设计模式。学习的目的是让你体会，在真实的项目开发中，要学会活学活用，切不可过于死板，生搬硬套设计模式的设计与实现。除此之外，针对每个模式，我们不可能像前面学习理论知识那样，分析得细致入微，很多都是点到为止。在已经具备之前理论知识的前提下，我想你可以跟着我的指引自己去研究，有哪里不懂的话，也可以再回过头去看下之前的理论讲解。</p>
<p>话不多说，让我们正式开始今天的学习吧！</p>
<h2 id="工厂模式在-calendar-类中的应用">工厂模式在 Calendar 类中的应用</h2>
<p>在前面讲到工厂模式的时候，大部分工厂类都是以 Factory 作为后缀来命名，并且工厂类主要负责创建对象这样一件事情。但在实际的项目开发中，工厂类的设计更加灵活。那我们就来看下，工厂模式在 Java JDK 中的一个应用：java.util.Calendar。从命名上，我们无法看出它是一个工厂类。</p>
<p>Calendar 类提供了大量跟日期相关的功能代码，同时，又提供了一个 getInstance() 工厂方法，用来根据不同的 TimeZone 和 Locale 创建不同的 Calendar 子类对象。也就是说，功能代码和工厂方法代码耦合在了一个类中。所以，即便我们去查看它的源码，如果不细心的话，也很难发现它用到了工厂模式。同时，因为它不单单是一个工厂类，所以，它并没有以 Factory 作为后缀来命名。</p>
<p>Calendar 类的相关代码如下所示，大部分代码都已经省略，我只给出了 getInstance() 工厂方法的代码实现。从代码中，我们可以看出，getInstance() 方法可以根据不同 TimeZone 和 Locale，创建不同的 Calendar 子类对象，比如 BuddhistCalendar、JapaneseImperialCalendar、GregorianCalendar，这些细节完全封装在工厂方法中，使用者只需要传递当前的时区和地址，就能够获得一个 Calendar 类对象来使用，而获得的对象具体是哪个 Calendar 子类的对象，使用者在使用的时候并不关心。</p>
<p>public abstract class Calendar implements Serializable, Cloneable, Comparable<Calendar> {<br>
//&hellip;<br>
public static Calendar getInstance(TimeZone zone, Locale aLocale){<br>
return createCalendar(zone, aLocale);<br>
}</p>
<p>private static Calendar createCalendar(TimeZone zone,Locale aLocale) {<br>
CalendarProvider provider = LocaleProviderAdapter.getAdapter(<br>
CalendarProvider.class, aLocale).getCalendarProvider();<br>
if (provider != null) {<br>
try {<br>
return provider.getInstance(zone, aLocale);<br>
} catch (IllegalArgumentException iae) {<br>
// fall back to the default instantiation<br>
}<br>
}</p>
<pre><code>Calendar cal = null;  
if (aLocale.hasExtensions()) {  
  String caltype = aLocale.getUnicodeLocaleType(&quot;ca&quot;);  
  if (caltype != null) {  
    switch (caltype) {  
      case &quot;buddhist&quot;:  
        cal = new BuddhistCalendar(zone, aLocale);  
        break;  
      case &quot;japanese&quot;:  
        cal = new JapaneseImperialCalendar(zone, aLocale);  
        break;  
      case &quot;gregory&quot;:  
        cal = new GregorianCalendar(zone, aLocale);  
        break;  
    }  
  }  
}  
if (cal == null) {  
  if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) {  
    cal = new BuddhistCalendar(zone, aLocale);  
  } else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot; &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) {  
    cal = new JapaneseImperialCalendar(zone, aLocale);  
  } else {  
    cal = new GregorianCalendar(zone, aLocale);  
  }  
}  
return cal;  
</code></pre>
<p>}<br>
//&hellip;<br>
}</p>
<h2 id="建造者模式在-calendar-类中的应用">建造者模式在 Calendar 类中的应用</h2>
<p>还是刚刚的 Calendar 类，它不仅仅用到了工厂模式，还用到了建造者模式。我们知道，建造者模式有两种实现方法，一种是单独定义一个 Builder 类，另一种是将 Builder 实现为原始类的内部类。Calendar 就采用了第二种实现思路。我们先来看代码再讲解，相关代码我贴在了下面。</p>
<p>public abstract class Calendar implements Serializable, Cloneable, Comparable<Calendar> {<br>
//&hellip;<br>
public static class Builder {<br>
private static final int NFIELDS = FIELD_COUNT + 1;<br>
private static final int WEEK_YEAR = FIELD_COUNT;<br>
private long instant;<br>
private int[] fields;<br>
private int nextStamp;<br>
private int maxFieldIndex;<br>
private String type;<br>
private TimeZone zone;<br>
private boolean lenient = true;<br>
private Locale locale;<br>
private int firstDayOfWeek, minimalDaysInFirstWeek;</p>
<pre><code>public Builder() {}  
  
public Builder setInstant(long instant) {  
    if (fields != null) {  
        throw new IllegalStateException();  
    }  
    this.instant = instant;  
    nextStamp = COMPUTED;  
    return this;  
}  
//...省略 n 多 set() 方法  
  
public Calendar build() {  
  if (locale == null) {  
    locale = Locale.getDefault();  
  }  
  if (zone == null) {  
    zone = TimeZone.getDefault();  
  }  
  Calendar cal;  
  if (type == null) {  
    type = locale.getUnicodeLocaleType(&quot;ca&quot;);  
  }  
  if (type == null) {  
    if (locale.getCountry() == &quot;TH&quot; &amp;&amp; locale.getLanguage() == &quot;th&quot;) {  
      type = &quot;buddhist&quot;;  
    } else {  
      type = &quot;gregory&quot;;  
    }  
  }  
  switch (type) {  
    case &quot;gregory&quot;:  
      cal = new GregorianCalendar(zone, locale, true);  
      break;  
    case &quot;iso8601&quot;:  
      GregorianCalendar gcal = new GregorianCalendar(zone, locale, true);  
      // make gcal a proleptic Gregorian  
      gcal.setGregorianChange(new Date(Long.MIN_VALUE));  
      // and week definition to be compatible with ISO 8601  
      setWeekDefinition(MONDAY, 4);  
      cal = gcal;  
      break;  
    case &quot;buddhist&quot;:  
      cal = new BuddhistCalendar(zone, locale);  
      cal.clear();  
      break;  
    case &quot;japanese&quot;:  
      cal = new JapaneseImperialCalendar(zone, locale, true);  
      break;  
    default:  
      throw new IllegalArgumentException(&quot;unknown calendar type: &quot; + type);  
  }  
  cal.setLenient(lenient);  
  if (firstDayOfWeek != 0) {  
    cal.setFirstDayOfWeek(firstDayOfWeek);  
    cal.setMinimalDaysInFirstWeek(minimalDaysInFirstWeek);  
  }  
  if (isInstantSet()) {  
    cal.setTimeInMillis(instant);  
    cal.complete();  
    return cal;  
  }  

  if (fields != null) {  
    boolean weekDate = isSet(WEEK_YEAR) &amp;&amp; fields[WEEK_YEAR] &gt; fields[YEAR];  
    if (weekDate &amp;&amp; !cal.isWeekDateSupported()) {  
      throw new IllegalArgumentException(&quot;week date is unsupported by &quot; + type);  
    }  
    for (int stamp = MINIMUM_USER_STAMP; stamp &lt; nextStamp; stamp++) {  
      for (int index = 0; index &lt;= maxFieldIndex; index++) {  
        if (fields[index] == stamp) {  
          cal.set(index, fields[NFIELDS + index]);  
          break;  
         }  
      }  
    }  

    if (weekDate) {  
      int weekOfYear = isSet(WEEK_OF_YEAR) ? fields[NFIELDS + WEEK_OF_YEAR] : 1;  
      int dayOfWeek = isSet(DAY_OF_WEEK) ? fields[NFIELDS + DAY_OF_WEEK] : cal.getFirstDayOfWeek();  
      cal.setWeekDate(fields[NFIELDS + WEEK_YEAR], weekOfYear, dayOfWeek);  
    }  
    cal.complete();  
  }  
  return cal;  
}  
</code></pre>
<p>}<br>
}</p>
<p>看了上面的代码，我有一个问题请你思考一下：既然已经有了 getInstance() 工厂方法来创建 Calendar 类对象，为什么还要用 Builder 来创建 Calendar 类对象呢？这两者之间的区别在哪里呢？</p>
<p>实际上，在前面讲到这两种模式的时候，我们对它们之间的区别做了详细的对比，现在，我们再来一块回顾一下。工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p>
<p>网上有一个经典的例子很好地解释了两者的区别。</p>
<blockquote>
<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作不同的披萨。</p>
</blockquote>
<p>粗看 Calendar 的 Builder 类的 build() 方法，你可能会觉得它有点像工厂模式。你的感觉没错，前面一半代码确实跟 getInstance() 工厂方法类似，根据不同的 type 创建了不同的 Calendar 子类。实际上，后面一半代码才属于标准的建造者模式，根据 setXXX() 方法设置的参数，来定制化刚刚创建的 Calendar 子类对象。</p>
<p>你可能会说，这还能算是建造者模式吗？我用第 46 讲的一段话来回答你：</p>
<blockquote>
<p>我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式，创造出新的模式来解决特定场景的问题。</p>
</blockquote>
<p>实际上，从 Calendar 这个例子，我们也能学到，不要过于死板地套用各种模式的原理和实现，不要不敢做丝毫的改动。模式是死的，用的人是活的。在实际上的项目开发中，不仅各种模式可以混合在一起使用，而且具体的代码实现，也可以根据具体的功能需求做灵活的调整。</p>
<h2 id="装饰器模式在-collections-类中的应用">装饰器模式在 Collections 类中的应用</h2>
<p>我们前面讲到，Java IO 类库是装饰器模式的非常经典的应用。实际上，Java 的 Collections 类也用到了装饰器模式。</p>
<p>Collections 类是一个集合容器的工具类，提供了很多静态方法，用来创建各种集合容器，比如通过 unmodifiableColletion() 静态方法，来创建 UnmodifiableCollection 类对象。而这些容器类中的 UnmodifiableCollection 类、CheckedCollection 和 SynchronizedCollection 类，就是针对 Collection 类的装饰器类。</p>
<p>因为刚刚提到的这三个装饰器类，在代码结构上几乎一样，所以，我们这里只拿其中的 UnmodifiableCollection 类来举例讲解一下。UnmodifiableCollection 类是 Collections 类的一个内部类，相关代码我摘抄到了下面，你可以先看下。</p>
<p>public class Collections {<br>
private Collections() {}</p>
<p>public static <T> Collection<T> unmodifiableCollection(Collection&lt;? extends T&gt; c) {<br>
return new UnmodifiableCollection&lt;&gt;(c);<br>
}</p>
<p>static class UnmodifiableCollection<E> implements Collection<E>,   Serializable {<br>
private static final long serialVersionUID = 1820017752578914078L;<br>
final Collection&lt;? extends E&gt; c;</p>
<pre><code>UnmodifiableCollection(Collection&lt;? extends E&gt; c) {  
  if (c==null)  
    throw new NullPointerException();  
  this.c = c;  
}  

public int size()                   {return c.size();}  
public boolean isEmpty()            {return c.isEmpty();}  
public boolean contains(Object o)   {return c.contains(o);}  
public Object[] toArray()           {return c.toArray();}  
public &lt;T&gt; T[] toArray(T[] a)       {return c.toArray(a);}  
public String toString()            {return c.toString();}  

public Iterator&lt;E&gt; iterator() {  
  return new Iterator&lt;E&gt;() {  
    private final Iterator&lt;? extends E&gt; i = c.iterator();  

    public boolean hasNext() {return i.hasNext();}  
    public E next()          {return i.next();}  
    public void remove() {  
      throw new UnsupportedOperationException();  
    }  
    @Override  
    public void forEachRemaining(Consumer&lt;? super E&gt; action) {  
      // Use backing collection version  
      i.forEachRemaining(action);  
    }  
  };  
}  

public boolean add(E e) {  
  throw new UnsupportedOperationException();  
}  
public boolean remove(Object o) {  
   hrow new UnsupportedOperationException();  
}  
public boolean containsAll(Collection&lt;?&gt; coll) {  
  return c.containsAll(coll);  
}  
public boolean addAll(Collection&lt;? extends E&gt; coll) {  
  throw new UnsupportedOperationException();  
}  
public boolean removeAll(Collection&lt;?&gt; coll) {  
  throw new UnsupportedOperationException();  
}  
public boolean retainAll(Collection&lt;?&gt; coll) {  
  throw new UnsupportedOperationException();  
}  
public void clear() {  
  throw new UnsupportedOperationException();  
}  

// Override default methods in Collection  
@Override  
public void forEach(Consumer&lt;? super E&gt; action) {  
  c.forEach(action);  
}  
@Override  
public boolean removeIf(Predicate&lt;? super E&gt; filter) {  
  throw new UnsupportedOperationException();  
}  
@SuppressWarnings(&quot;unchecked&quot;)  
@Override  
public Spliterator&lt;E&gt; spliterator() {  
  return (Spliterator&lt;E&gt;)c.spliterator();  
}  
@SuppressWarnings(&quot;unchecked&quot;)  
@Override  
public Stream&lt;E&gt; stream() {  
  return (Stream&lt;E&gt;)c.stream();  
}  
@SuppressWarnings(&quot;unchecked&quot;)  
@Override  
public Stream&lt;E&gt; parallelStream() {  
  return (Stream&lt;E&gt;)c.parallelStream();  
}  
</code></pre>
<p>}<br>
}</p>
<p>看了上面的代码，请你思考一下，为什么说 UnmodifiableCollection 类是 Collection 类的装饰器类呢？这两者之间可以看作简单的接口实现关系或者类继承关系吗？</p>
<p>我们前面讲过，装饰器模式中的装饰器类是对原始类功能的增强。尽管 UnmodifiableCollection 类可以算是对 Collection 类的一种功能增强，但这点还不具备足够的说服力来断定 UnmodifiableCollection 就是 Collection 类的装饰器类。</p>
<p>实际上，最关键的一点是，UnmodifiableCollection 的构造函数接收一个 Collection 类对象，然后对其所有的函数进行了包裹（Wrap）：重新实现（比如 add() 函数）或者简单封装（比如 stream() 函数）。而简单的接口实现或者继承，并不会如此来实现 UnmodifiableCollection 类。所以，从代码实现的角度来说，UnmodifiableCollection 类是典型的装饰器类。</p>
<h2 id="适配器模式在-collections-类中的应用">适配器模式在 Collections 类中的应用</h2>
<p>在第 51 讲中我们讲到，适配器模式可以用来兼容老的版本接口。当时我们举了一个 JDK 的例子，这里我们再重新仔细看一下。</p>
<p>老版本的 JDK 提供了 Enumeration 类来遍历容器。新版本的 JDK 用 Iterator 类替代 Enumeration 类来遍历容器。为了兼容老的客户端代码（使用老版本 JDK 的代码），我们保留了 Enumeration 类，并且在 Collections 类中，仍然保留了 enumaration() 静态方法（因为我们一般都是通过这个静态函数来创建一个容器的 Enumeration 类对象）。</p>
<p>不过，保留 Enumeration 类和 enumeration() 函数，都只是为了兼容，实际上，跟适配器没有一点关系。那到底哪一部分才是适配器呢？</p>
<p>在新版本的 JDK 中，Enumeration 类是适配器类。它适配的是客户端代码（使用 Enumeration 类）和新版本 JDK 中新的迭代器 Iterator 类。不过，从代码实现的角度来说，这个适配器模式的代码实现，跟经典的适配器模式的代码实现，差别稍微有点大。enumeration() 静态函数的逻辑和 Enumeration 适配器类的代码耦合在一起，enumeration() 静态函数直接通过 new 的方式创建了匿名类对象。具体的代码如下所示：</p>
<p>/**</p>
<ul>
<li>
<p>Returns an enumeration over the specified collection.  This provides</p>
</li>
<li>
<p>interoperability with legacy APIs that require an enumeration</p>
</li>
<li>
<p>as input.</p>
</li>
<li></li>
<li>
<p>@param  <T> the class of the objects in the collection</p>
</li>
<li>
<p>@param c the collection for which an enumeration is to be returned.</p>
</li>
<li>
<p>@return an enumeration over the specified collection.</p>
</li>
<li>
<p>@see Enumeration<br>
*/<br>
public static <T> Enumeration<T> enumeration(final Collection<T> c) {<br>
return new Enumeration<T>() {<br>
private final Iterator<T> i = c.iterator();</p>
<p>public boolean hasMoreElements() {<br>
return i.hasNext();<br>
}</p>
<p>public T nextElement() {<br>
return i.next();<br>
}<br>
};<br>
}</p>
</li>
</ul>
<h2 id="重点回顾">重点回顾</h2>
<p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p>
<p>今天，我重点讲了工厂模式、建造者模式、装饰器模式、适配器模式，这四种模式在 Java JDK 中的应用，主要目的是给你展示真实项目中是如何灵活应用设计模式的。</p>
<p>从今天的讲解中，我们可以学习到，尽管在之前的理论讲解中，我们都有讲到每个模式的经典代码实现，但是，在真实的项目开发中，这些模式的应用更加灵活，代码实现更加自由，可以根据具体的业务场景、功能需求，对代码实现做很大的调整，甚至还可能会对模式本身的设计思路做调整。</p>
<p>比如，Java JDK 中的 Calendar 类，就耦合了业务功能代码、工厂方法、建造者类三种类型的代码，而且，在建造者类的 build 方法中，前半部分是工厂方法的代码实现，后半部分才是真正的建造者模式的代码实现。这也告诉我们，在项目中应用设计模式，切不可生搬硬套，过于学院派，要学会结合实际情况做灵活调整，做到心中无剑胜有剑。</p>
<h2 id="课堂讨论">课堂讨论</h2>
<p>在 Java 中，经常用到的 StringBuilder 类是否是建造者模式的应用呢？你可以试着像我一样从源码的角度去剖析一下。</p>
<p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/">设计模式之美</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/76__%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">76__程序员练级攻略：软件设计</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/76__%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%9C%AA%E6%9D%A5/">
            <span class="next-text nav-default">76__软件工程的未来</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
