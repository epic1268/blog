<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>72__解释器模式：如何设计实现一个自定义接口告警规则功能？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="上一节课，我们学习了命令模式。命令模式将请求封装成对象，方便作为函数参数传递和赋值给变量。它主要的应用场景是给命令的执行附加功能，换句话说，就是控制命令的执行，比如，排队、异步、延迟执行命令、给命令执行记录日志、撤销重做命令等等。总体上来讲，命令模式的应用范围并不广。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/72__%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E5%91%8A%E8%AD%A6%E8%A7%84%E5%88%99%E5%8A%9F%E8%83%BD/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/72__%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E5%91%8A%E8%AD%A6%E8%A7%84%E5%88%99%E5%8A%9F%E8%83%BD/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="72__解释器模式：如何设计实现一个自定义接口告警规则功能？">
  <meta property="og:description" content="上一节课，我们学习了命令模式。命令模式将请求封装成对象，方便作为函数参数传递和赋值给变量。它主要的应用场景是给命令的执行附加功能，换句话说，就是控制命令的执行，比如，排队、异步、延迟执行命令、给命令执行记录日志、撤销重做命令等等。总体上来讲，命令模式的应用范围并不广。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="设计模式之美">

  <meta itemprop="name" content="72__解释器模式：如何设计实现一个自定义接口告警规则功能？">
  <meta itemprop="description" content="上一节课，我们学习了命令模式。命令模式将请求封装成对象，方便作为函数参数传递和赋值给变量。它主要的应用场景是给命令的执行附加功能，换句话说，就是控制命令的执行，比如，排队、异步、延迟执行命令、给命令执行记录日志、撤销重做命令等等。总体上来讲，命令模式的应用范围并不广。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4203">
  <meta itemprop="keywords" content="设计模式之美">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="72__解释器模式：如何设计实现一个自定义接口告警规则功能？">
  <meta name="twitter:description" content="上一节课，我们学习了命令模式。命令模式将请求封装成对象，方便作为函数参数传递和赋值给变量。它主要的应用场景是给命令的执行附加功能，换句话说，就是控制命令的执行，比如，排队、异步、延迟执行命令、给命令执行记录日志、撤销重做命令等等。总体上来讲，命令模式的应用范围并不广。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">72__解释器模式：如何设计实现一个自定义接口告警规则功能？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4203 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#解释器模式的原理和实现">解释器模式的原理和实现</a></li>
        <li><a href="#解释器模式实战举例">解释器模式实战举例</a></li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#课堂讨论">课堂讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>上一节课，我们学习了命令模式。命令模式将请求封装成对象，方便作为函数参数传递和赋值给变量。它主要的应用场景是给命令的执行附加功能，换句话说，就是控制命令的执行，比如，排队、异步、延迟执行命令、给命令执行记录日志、撤销重做命令等等。总体上来讲，命令模式的应用范围并不广。</p>
<p>今天，我们来学习解释器模式，它用来描述如何构建一个简单的“语言”解释器。比起命令模式，解释器模式更加小众，只在一些特定的领域会被用到，比如编译器、规则引擎、正则表达式。所以，解释器模式也不是我们学习的重点，你稍微了解一下就可以了。</p>
<p>话不多说，让我们正式开始今天的学习吧！</p>
<h2 id="解释器模式的原理和实现">解释器模式的原理和实现</h2>
<p>解释器模式的英文翻译是 Interpreter Design Pattern。在 GoF 的《设计模式》一书中，它是这样定义的：</p>
<blockquote>
<p>Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.</p>
</blockquote>
<p>翻译成中文就是：解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。</p>
<p>看了定义，你估计会一头雾水，因为这里面有很多我们平时开发中很少接触的概念，比如“语言”“语法”“解释器”。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p>
<p>要想了解“语言”表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。</p>
<p>为了让你更好地理解定义，我举一个比较贴近生活的例子来解释一下。</p>
<p>实际上，理解这个概念，我们可以类比中英文翻译。我们知道，把英文翻译成中文是有一定规则的。这个规则就是定义中的“语法”。我们开发一个类似 Google Translate 这样的翻译器，这个翻译器能够根据语法规则，将输入的中文翻译成英文。这里的翻译器就是解释器模式定义中的“解释器”。</p>
<p>刚刚翻译器这个例子比较贴近生活，现在，我们再举个更加贴近编程的例子。</p>
<p>假设我们定义了一个新的加减乘除计算“语言”，语法规则如下：</p>
<ol>
<li>运算符只包含加、减、乘、除，并且没有优先级的概念；</li>
<li>表达式（也就是前面提到的“句子”）中，先书写数字，后书写运算符，空格隔开；</li>
<li>按照先后顺序，取出两个数字和一个运算符计算结果，结果重新放入数字的最头部位置，循环上述过程，直到只剩下一个数字，这个数字就是表达式最终的计算结果。</li>
</ol>
<p>我们举个例子来解释一下上面的语法规则。</p>
<p>比如“8 3 2 4 - + * ”这样一个表达式，我们按照上面的语法规则来处理，取出数字“8 3”和“-”运算符，计算得到 5，于是表达式就变成了“5 2 4 + * ”。然后，我们再取出“5 2”和“ + ”运算符，计算得到 7，表达式就变成了“7 4 * ”。最后，我们取出“7 4”和“ * ”运算符，最终得到的结果就是 28。</p>
<p>看懂了上面的语法规则，我们将它用代码实现出来，如下所示。代码非常简单，用户按照上面的规则书写表达式，传递给 interpret() 函数，就可以得到最终的计算结果。</p>
<p>public class ExpressionInterpreter {<br>
private Deque<Long> numbers = new LinkedList&lt;&gt;();</p>
<p>public long interpret(String expression) {<br>
String[] elements = expression.split(&quot; &ldquo;);<br>
int length = elements.length;<br>
for (int i = 0; i &lt; (length+1)/2; ++i) {<br>
numbers.addLast(Long.parseLong(elements[i]));<br>
}</p>
<pre><code>for (int i = (length+1)/2; i &lt; length; ++i) {  
  String operator = elements[i];  
  boolean isValid = &quot;+&quot;.equals(operator) || &quot;-&quot;.equals(operator)  
          || &quot;*&quot;.equals(operator) || &quot;/&quot;.equals(operator);  
  if (!isValid) {  
    throw new RuntimeException(&quot;Expression is invalid: &quot; + expression);  
  }  

  long number1 = numbers.pollFirst();  
  long number2 = numbers.pollFirst();  
  long result = 0;  
  if (operator.equals(&quot;+&quot;)) {  
    result = number1 + number2;  
  } else if (operator.equals(&quot;-&quot;)) {  
    result = number1 - number2;  
  } else if (operator.equals(&quot;*&quot;)) {  
    result = number1 * number2;  
  } else if (operator.equals(&quot;/&quot;)) {  
    result = number1 / number2;  
  }  
  numbers.addFirst(result);  
}  

if (numbers.size() != 1) {  
  throw new RuntimeException(&quot;Expression is invalid: &quot; + expression);  
}  

return numbers.pop();  
</code></pre>
<p>}<br>
}</p>
<p>在上面的代码实现中，语法规则的解析逻辑（第 23、25、27、29 行）都集中在一个函数中，对于简单的语法规则的解析，这样的设计就足够了。但是，对于复杂的语法规则的解析，逻辑复杂，代码量多，所有的解析逻辑都耦合在一个函数中，这样显然是不合适的。这个时候，我们就要考虑拆分代码，将解析逻辑拆分到独立的小类中。</p>
<p>该怎么拆分呢？我们可以借助解释器模式。</p>
<p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面也说过，应用设计模式主要是应对代码的复杂性，实际上，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p>
<p>前面定义的语法规则有两类表达式，一类是数字，一类是运算符，运算符又包括加减乘除。利用解释器模式，我们把解析的工作拆分到 NumberExpression、AdditionExpression、SubstractionExpression、MultiplicationExpression、DivisionExpression 这样五个解析类中。</p>
<p>按照这个思路，我们对代码进行重构，重构之后的代码如下所示。当然，因为加减乘除表达式的解析比较简单，利用解释器模式的设计思路，看起来有点过度设计。不过呢，这里我主要是为了解释原理，你明白意思就好，不用过度细究这个例子。</p>
<p>public interface Expression {<br>
long interpret();<br>
}</p>
<p>public class NumberExpression implements Expression {<br>
private long number;</p>
<p>public NumberExpression(long number) {<br>
this.number = number;<br>
}</p>
<p>public NumberExpression(String number) {<br>
this.number = Long.parseLong(number);<br>
}</p>
<p>@Override<br>
public long interpret() {<br>
return this.number;<br>
}<br>
}</p>
<p>public class AdditionExpression implements Expression {<br>
private Expression exp1;<br>
private Expression exp2;</p>
<p>public AdditionExpression(Expression exp1, Expression exp2) {<br>
this.exp1 = exp1;<br>
this.exp2 = exp2;<br>
}</p>
<p>@Override<br>
public long interpret() {<br>
return exp1.interpret() + exp2.interpret();<br>
}<br>
}<br>
// SubstractionExpression/MultiplicationExpression/DivisionExpression与AdditionExpression代码结构类似，这里就省略了</p>
<p>public class ExpressionInterpreter {<br>
private Deque<Expression> numbers = new LinkedList&lt;&gt;();</p>
<p>public long interpret(String expression) {<br>
String[] elements = expression.split(&rdquo; &ldquo;);<br>
int length = elements.length;<br>
for (int i = 0; i &lt; (length+1)/2; ++i) {<br>
numbers.addLast(new NumberExpression(elements[i]));<br>
}</p>
<pre><code>for (int i = (length+1)/2; i &lt; length; ++i) {  
  String operator = elements[i];  
  boolean isValid = &quot;+&quot;.equals(operator) || &quot;-&quot;.equals(operator)  
          || &quot;*&quot;.equals(operator) || &quot;/&quot;.equals(operator);  
  if (!isValid) {  
    throw new RuntimeException(&quot;Expression is invalid: &quot; + expression);  
  }  

  Expression exp1 = numbers.pollFirst();  
  Expression exp2 = numbers.pollFirst();  
  Expression combinedExp = null;  
  if (operator.equals(&quot;+&quot;)) {  
    combinedExp = new AdditionExpression(exp1, exp2);  
  } else if (operator.equals(&quot;-&quot;)) {  
    combinedExp = new AdditionExpression(exp1, exp2);  
  } else if (operator.equals(&quot;*&quot;)) {  
    combinedExp = new AdditionExpression(exp1, exp2);  
  } else if (operator.equals(&quot;/&quot;)) {  
    combinedExp = new AdditionExpression(exp1, exp2);  
  }  
  long result = combinedExp.interpret();  
  numbers.addFirst(new NumberExpression(result));  
}  

if (numbers.size() != 1) {  
  throw new RuntimeException(&quot;Expression is invalid: &quot; + expression);  
}  

return numbers.pop().interpret();  
</code></pre>
<p>}<br>
}</p>
<h2 id="解释器模式实战举例">解释器模式实战举例</h2>
<p>接下来，我们再来看一个更加接近实战的例子，也就是咱们今天标题中的问题：如何实现一个自定义接口告警规则功能？</p>
<p>在我们平时的项目开发中，监控系统非常重要，它可以时刻监控业务系统的运行情况，及时将异常报告给开发者。比如，如果每分钟接口出错数超过 100，监控系统就通过短信、微信、邮件等方式发送告警给开发者。</p>
<p>一般来讲，监控系统支持开发者自定义告警规则，比如我们可以用下面这样一个表达式，来表示一个告警规则，它表达的意思是：每分钟 API 总出错数超过 100 或者每分钟 API 总调用数超过 10000 就触发告警。</p>
<p>api_error_per_minute &gt; 100 || api_count_per_minute &gt; 10000</p>
<p>在监控系统中，告警模块只负责根据统计数据和告警规则，判断是否触发告警。至于每分钟 API 接口出错数、每分钟接口调用数等统计数据的计算，是由其他模块来负责的。其他模块将统计数据放到一个 Map 中（数据的格式如下所示），发送给告警模块。接下来，我们只关注告警模块。</p>
<p>Map&lt;String, Long&gt; apiStat = new HashMap&lt;&gt;();<br>
apiStat.put(&ldquo;api_error_per_minute&rdquo;, 103);<br>
apiStat.put(&ldquo;api_count_per_minute&rdquo;, 987);</p>
<p>为了简化讲解和代码实现，我们假设自定义的告警规则只包含“||、&amp;&amp;、&gt;、&lt;、==”这五个运算符，其中，“&gt;、&lt;、==”运算符的优先级高于“||、&amp;&amp;”运算符，“&amp;&amp;”运算符优先级高于“||”。在表达式中，任意元素之间需要通过空格来分隔。除此之外，用户可以自定义要监控的 key，比如前面的 api_error_per_minute、api_count_per_minute。</p>
<p>那如何实现上面的需求呢？我写了一个骨架代码，如下所示，其中的核心的实现我没有给出，你可以当作面试题，自己试着去补全一下，然后再看我的讲解。</p>
<p>public class AlertRuleInterpreter {</p>
<p>// key1 &gt; 100 &amp;&amp; key2 &lt; 1000 || key3 == 200<br>
public AlertRuleInterpreter(String ruleExpression) {<br>
//TODO:由你来完善<br>
}</p>
<p>//&lt;String, Long&gt; apiStat = new HashMap&lt;&gt;();<br>
//apiStat.put(&ldquo;key1&rdquo;, 103);<br>
//apiStat.put(&ldquo;key2&rdquo;, 987);<br>
public boolean interpret(Map&lt;String, Long&gt; stats) {<br>
//TODO:由你来完善<br>
}</p>
<p>}</p>
<p>public class DemoTest {<br>
public static void main(String[] args) {<br>
String rule = &ldquo;key1 &gt; 100 &amp;&amp; key2 &lt; 30 || key3 &lt; 100 || key4 == 88&rdquo;;<br>
AlertRuleInterpreter interpreter = new AlertRuleInterpreter(rule);<br>
Map&lt;String, Long&gt; stats = new HashMap&lt;&gt;();<br>
stats.put(&ldquo;key1&rdquo;, 101l);<br>
stats.put(&ldquo;key3&rdquo;, 121l);<br>
stats.put(&ldquo;key4&rdquo;, 88l);<br>
boolean alert = interpreter.interpret(stats);<br>
System.out.println(alert);<br>
}<br>
}</p>
<p>实际上，我们可以把自定义的告警规则，看作一种特殊“语言”的语法规则。我们实现一个解释器，能够根据规则，针对用户输入的数据，判断是否触发告警。利用解释器模式，我们把解析表达式的逻辑拆分到各个小类中，避免大而复杂的大类的出现。按照这个实现思路，我把刚刚的代码补全，如下所示，你可以拿你写的代码跟我写的对比一下。</p>
<p>public interface Expression {<br>
boolean interpret(Map&lt;String, Long&gt; stats);<br>
}</p>
<p>public class GreaterExpression implements Expression {<br>
private String key;<br>
private long value;</p>
<p>public GreaterExpression(String strExpression) {<br>
String[] elements = strExpression.trim().split(&rdquo;\s+&quot;);<br>
if (elements.length != 3 || !elements[1].trim().equals(&quot;&gt;&quot;)) {<br>
throw new RuntimeException(&ldquo;Expression is invalid: &quot; + strExpression);<br>
}<br>
this.key = elements[0].trim();<br>
this.value = Long.parseLong(elements[2].trim());<br>
}</p>
<p>public GreaterExpression(String key, long value) {<br>
this.key = key;<br>
this.value = value;<br>
}</p>
<p>@Override<br>
public boolean interpret(Map&lt;String, Long&gt; stats) {<br>
if (!stats.containsKey(key)) {<br>
return false;<br>
}<br>
long statValue = stats.get(key);<br>
return statValue &gt; value;<br>
}<br>
}</p>
<p>// LessExpression/EqualExpression跟GreaterExpression代码类似，这里就省略了</p>
<p>public class AndExpression implements Expression {<br>
private List<Expression> expressions = new ArrayList&lt;&gt;();</p>
<p>public AndExpression(String strAndExpression) {<br>
String[] strExpressions = strAndExpression.split(&rdquo;&amp;&amp;&quot;);<br>
for (String strExpr : strExpressions) {<br>
if (strExpr.contains(&quot;&gt;&quot;)) {<br>
expressions.add(new GreaterExpression(strExpr));<br>
} else if (strExpr.contains(&quot;&lt;&quot;)) {<br>
expressions.add(new LessExpression(strExpr));<br>
} else if (strExpr.contains(&quot;==&quot;)) {<br>
expressions.add(new EqualExpression(strExpr));<br>
} else {<br>
throw new RuntimeException(&ldquo;Expression is invalid: &quot; + strAndExpression);<br>
}<br>
}<br>
}</p>
<p>public AndExpression(List<Expression> expressions) {<br>
this.expressions.addAll(expressions);<br>
}</p>
<p>@Override<br>
public boolean interpret(Map&lt;String, Long&gt; stats) {<br>
for (Expression expr : expressions) {<br>
if (!expr.interpret(stats)) {<br>
return false;<br>
}<br>
}<br>
return true;<br>
}</p>
<p>}</p>
<p>public class OrExpression implements Expression {<br>
private List<Expression> expressions = new ArrayList&lt;&gt;();</p>
<p>public OrExpression(String strOrExpression) {<br>
String[] andExpressions = strOrExpression.split(&rdquo;\|\|&quot;);<br>
for (String andExpr : andExpressions) {<br>
expressions.add(new AndExpression(andExpr));<br>
}<br>
}</p>
<p>public OrExpression(List<Expression> expressions) {<br>
this.expressions.addAll(expressions);<br>
}</p>
<p>@Override<br>
public boolean interpret(Map&lt;String, Long&gt; stats) {<br>
for (Expression expr : expressions) {<br>
if (expr.interpret(stats)) {<br>
return true;<br>
}<br>
}<br>
return false;<br>
}<br>
}</p>
<p>public class AlertRuleInterpreter {<br>
private Expression expression;</p>
<p>public AlertRuleInterpreter(String ruleExpression) {<br>
this.expression = new OrExpression(ruleExpression);<br>
}</p>
<p>public boolean interpret(Map&lt;String, Long&gt; stats) {<br>
return expression.interpret(stats);<br>
}<br>
}</p>
<h2 id="重点回顾">重点回顾</h2>
<p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p>
<p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p>
<p>要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。</p>
<p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p>
<h2 id="课堂讨论">课堂讨论</h2>
<p>1. 在你过往的项目经历或阅读源码的时候，有没有用到或者见过解释器模式呢？</p>
<p>2. 在告警规则解析的例子中，如果我们要在表达式中支持括号“()”，那如何对代码进行重构呢？你可以把它当作练习，试着编写一下代码。</p>
<p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/">设计模式之美</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/72__%E5%8F%91%E5%B8%83%E5%8D%95%E5%85%83%E4%B8%8E%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">72__发布单元与版本管理</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/73__%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">
            <span class="next-text nav-default">73__程序员练级攻略：编程语言</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
