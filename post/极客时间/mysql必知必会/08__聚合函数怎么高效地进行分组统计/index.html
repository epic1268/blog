<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>08__聚合函数：怎么高效地进行分组统计？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是朱晓峰。今天，我来和你聊一聊聚合函数。
MySQL 中有 5 种聚合函数较为常用，分别是求和函数 SUM()、求平均函数 AVG()、最大值函数 MAX()、最小值函数 MIN() 和计数函数 COUNT()。接下来，我就结合超市项目的真实需求，来带你掌握聚合函数的用法，帮你实现高效的分组统计。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/08__%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%80%8E%E4%B9%88%E9%AB%98%E6%95%88%E5%9C%B0%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/08__%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%80%8E%E4%B9%88%E9%AB%98%E6%95%88%E5%9C%B0%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="08__聚合函数：怎么高效地进行分组统计？">
  <meta property="og:description" content="你好，我是朱晓峰。今天，我来和你聊一聊聚合函数。
MySQL 中有 5 种聚合函数较为常用，分别是求和函数 SUM()、求平均函数 AVG()、最大值函数 MAX()、最小值函数 MIN() 和计数函数 COUNT()。接下来，我就结合超市项目的真实需求，来带你掌握聚合函数的用法，帮你实现高效的分组统计。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="MySQL必知必会">

  <meta itemprop="name" content="08__聚合函数：怎么高效地进行分组统计？">
  <meta itemprop="description" content="你好，我是朱晓峰。今天，我来和你聊一聊聚合函数。
MySQL 中有 5 种聚合函数较为常用，分别是求和函数 SUM()、求平均函数 AVG()、最大值函数 MAX()、最小值函数 MIN() 和计数函数 COUNT()。接下来，我就结合超市项目的真实需求，来带你掌握聚合函数的用法，帮你实现高效的分组统计。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4272">
  <meta itemprop="keywords" content="MySQL必知必会">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="08__聚合函数：怎么高效地进行分组统计？">
  <meta name="twitter:description" content="你好，我是朱晓峰。今天，我来和你聊一聊聚合函数。
MySQL 中有 5 种聚合函数较为常用，分别是求和函数 SUM()、求平均函数 AVG()、最大值函数 MAX()、最小值函数 MIN() 和计数函数 COUNT()。接下来，我就结合超市项目的真实需求，来带你掌握聚合函数的用法，帮你实现高效的分组统计。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">08__聚合函数：怎么高效地进行分组统计？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4272 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#sum">SUM()</a></li>
        <li><a href="#avgmax和-min">AVG()、MAX()和 MIN()</a></li>
        <li><a href="#count">COUNT()</a></li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是朱晓峰。今天，我来和你聊一聊聚合函数。</p>
<p>MySQL 中有 5 种聚合函数较为常用，分别是求和函数 SUM()、求平均函数 AVG()、最大值函数 MAX()、最小值函数 MIN() 和计数函数 COUNT()。接下来，我就结合超市项目的真实需求，来带你掌握聚合函数的用法，帮你实现高效的分组统计。</p>
<p>咱们的项目需求是这样的：超市经营者提出，他们需要统计某个门店，每天、每个单品的销售情况，包括销售数量和销售金额等。这里涉及 3 个数据表，具体信息如下所示：</p>
<p>销售明细表（demo.transactiondetails)：</p>
<p>销售单头表（demo.transactionhead)：</p>
<p>商品信息表（demo.goodsmaster）：</p>
<p>要统计销售，就要用到数据求和，那么我们就先来学习下求和函数 SUM()。</p>
<h2 id="sum">SUM()</h2>
<p>SUM()函数可以返回指定字段值的和。我们可以用它来获得用户某个门店，每天，每种商品的销售总计数据：</p>
<p>mysql&gt;  SELECT<br>
-&gt;     LEFT(b.transdate, 10), &ndash; 从关联表获取交易时间，并且通过 LEFT 函数，获取交易时间字符串的左边 10 个字符，得到年月日的数据<br>
-&gt;     c.goodsname,           &ndash; 从关联表获取商品名称<br>
-&gt;     SUM(a.quantity),       &ndash; 数量求和<br>
-&gt;     SUM(a.salesvalue)      &ndash; 金额求和<br>
-&gt; FROM<br>
-&gt;     demo.transactiondetails a<br>
-&gt;         JOIN<br>
-&gt;     demo.transactionhead b ON (a.transactionid = b.transactionid)<br>
-&gt;         JOIN<br>
-&gt;     demo.goodsmaster c ON (a.itemnumber = c.itemnumber)<br>
-&gt; GROUP BY LEFT(b.transdate, 10) , c.goodsname      &ndash; 分组<br>
-&gt; ORDER BY LEFT(b.transdate, 10) , c.goodsname;     &ndash; 排序<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br>
| LEFT(b.transdate, 10) | goodsname | SUM(a.quantity) | SUM(a.salesvalue) |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br>
| 2020-12-01            | 书        |           2.000 |            178.00 |<br>
| 2020-12-01            | 笔        |           5.000 |             25.00 |<br>
| 2020-12-02            | 书        |           4.000 |            356.00 |<br>
| 2020-12-02            | 笔        |          16.000 |             80.00 |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br>
4 rows in set (0.01 sec)</p>
<p>可以看到，我们引入了 2 个关键字：LEFT 和 ORDER BY，你可能对它们不熟悉，我来具体解释下。</p>
<p><strong>LEFT(str，n)</strong>：表示返回字符串 str 最左边的 n 个字符。我们这里的 LEFT（a.transdate,10），表示返回交易时间字符串最左边的 10 个字符。在 MySQL 中，DATETIME 类型的默认格式是：YYYY-MM-DD，也就是说，年份 4 个字符，之后是“-”，然后是月份 2 个字符，之后又是“-”，然后是日 2 个字符，所以完整的年月日是 10 个字符。用户要求按照日期统计，所以，我们需要从日期时间数据中，把年月日的部分截取出来。</p>
<p><strong>ORDER BY</strong>：表示按照指定的字段排序。超市经营者指定按照日期和单品统计，那么，统计的结果按照交易日期和商品名称的顺序排序，会更加清晰。</p>
<p>知道了 2 个关键字之后，刚刚的查询就容易理解了。接下来我们就再拆解一下，看看这个查询是如何执行的。我用图表来直观地演示一下各个步骤。</p>
<p>第一步，完成 3 个表的连接（由于字段比较多，为了你理解，我省略了一些在这一步不重要的字段）：</p>
<p>第二步，对结果集按照交易时间和商品名称进行分组，我们可以分成下面 4 组。</p>
<p>第一组：</p>
<p>第二组</p>
<p>第三组</p>
<p>第四组</p>
<p>第三步，对各组的销售数量和销售金额进行统计，并且按照交易日期和商品名称排序。这样就得到了我们需要的结果，如下所示：</p>
<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br>
| LEFT(b.transdate, 10) | goodsname | SUM(a.quantity) | SUM(a.salesvalue) |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br>
| 2020-12-01            | 书        |           2.000 |            178.00 |<br>
| 2020-12-01            | 笔        |           5.000 |             25.00 |<br>
| 2020-12-02            | 书        |           4.000 |            356.00 |<br>
| 2020-12-02            | 笔        |          16.000 |             80.00 |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br>
4 rows in set (0.01 sec)</p>
<p>如果用户需要知道全部商品销售的总计数量和总计金额，我们也可以把数据集的整体看作一个分组，进行计算。这样就不需要分组关键字 GROUP BY，以及排序关键字 ORDER BY 了。你甚至不需要从关联表中获取数据，也就不需要连接了。就像下面这样：</p>
<p>mysql&gt; SELECT<br>
-&gt;  SUM(quantity), &ndash; 总计数量<br>
-&gt;  SUM(salesvalue)&ndash; 总计金额<br>
-&gt; FROM<br>
-&gt;  demo.transactiondetails;<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+<br>
| SUM(quantity) | SUM(salesvalue) |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+<br>
|        27.000 |          639.00 |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+<br>
1 row in set (0.05 sec)</p>
<p>到这里呢，求和函数 SUM() 的使用方法我就讲完了。需要提醒你的是，求和函数获取的是分组中的合计数据，所以你要对分组的结果有准确的把握，否则就很容易搞错。这也就是说，你要知道是按什么字段进行分组的。如果是按多个字段分组，你要知道字段之间有什么样的层次关系；如果是按照以字段作为变量的某个函数进行分组的，你要知道这个函数的返回值是什么，返回值又是如何影响分组的等。</p>
<h2 id="avgmax和-min">AVG()、MAX()和 MIN()</h2>
<p>接下来，我们来计算一下分组中数据的平均值、最大值和最小值。这个时候，就要用到 AVG()、MAX() 和 MIN() 了。</p>
<p>1.AVG()</p>
<p>首先，我们来学习下计算平均值的函数 AVG()。它的作用是，通过计算分组内指定字段值的和，以及分组内的记录数，算出分组内指定字段的平均值。</p>
<p>举个例子，如果用户需要计算每天、每种商品，平均一次卖出多少个、多少钱，这个时候，我们就可以用到 AVG()函数了，如下所示：</p>
<p>mysql&gt; SELECT<br>
-&gt; LEFT(a.transdate, 10),<br>
-&gt; c.goodsname,<br>
-&gt; AVG(b.quantity),    &ndash; 平均数量<br>
-&gt; AVG(b.salesvalue)   &ndash; 平均金额<br>
-&gt; FROM<br>
-&gt; demo.transactionhead a<br>
-&gt; JOIN<br>
-&gt; demo.transactiondetails b ON (a.transactionid = b.transactionid)<br>
-&gt; JOIN<br>
-&gt; demo.goodsmaster c ON (b.itemnumber = c.itemnumber)<br>
-&gt; GROUP BY LEFT(a.transdate,10),c.goodsname<br>
-&gt; ORDER BY LEFT(a.transdate,10),c.goodsname;<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br>
| LEFT(a.transdate, 10) | goodsname | AVG(b.quantity) | AVG(b.salesvalue) |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br>
| 2020-12-01 | 书 | 2.0000000 | 178.000000 |<br>
| 2020-12-01 | 笔 | 5.0000000 | 25.000000 |<br>
| 2020-12-02 | 书 | 2.0000000 | 178.000000 |<br>
| 2020-12-02 | 笔 | 8.0000000 | 40.000000 |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br>
4 rows in set (0.00 sec)</p>
<p>2.MAX()和 MIN()</p>
<p>MAX() 表示获取指定字段在分组中的最大值，MIN() 表示获取指定字段在分组中的最小值。它们的实现原理差不多，下面我就重点讲一下 MAX()，知道了它的用法，MIN() 也就很好理解了。</p>
<p>我们还是来看具体的例子。假如用户要求计算每天里的一次销售的最大数量和最大金额，就可以用下面的代码，得到我们需要的结果：</p>
<p>mysql&gt; SELECT<br>
-&gt; LEFT(a.transdate, 10),<br>
-&gt; MAX(b.quantity),     &ndash; 数量最大值<br>
-&gt; MAX(b.salesvalue)    &ndash; 金额最大值<br>
-&gt; FROM<br>
-&gt; demo.transactionhead a<br>
-&gt; JOIN<br>
-&gt; demo.transactiondetails b ON (a.transactionid = b.transactionid)<br>
-&gt; JOIN<br>
-&gt; demo.goodsmaster c ON (b.itemnumber = c.itemnumber)<br>
-&gt; GROUP BY LEFT(a.transdate,10)<br>
-&gt; ORDER BY LEFT(a.transdate,10);<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br>
| LEFT(a.transdate, 10) | MAX(b.quantity) | MAX(b.salesvalue) |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br>
| 2020-12-01 | 5.000 | 178.00 |<br>
| 2020-12-02 | 10.000 | 267.00 |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br>
2 rows in set (0.00 sec)</p>
<p>代码很简单，你一看就明白了。但是，这里有个问题你要注意：千万不要以为 MAX（b.quantity）和 MAX（b.salesvalue）算出的结果一定是同一条记录的数据。实际上，MySQL 是分别计算的。下面我们就来分析一下刚刚的查询。</p>
<p>查询中用到 3 个相互关联的表：销售流水明细表、销售流水单头表和商品信息表。这 3 个表连接完成之后，MySQL 进行了分组。我用图示的办法给你展示出来：</p>
<p>第一组</p>
<p>第二组</p>
<p>在第一组中，最大数量出现在第 2 条记录，是 5；最大金额出现在第 1 条记录，是 178。同样道理，在第二组中，最大数量出现在第 4 条记录，是 10；最大金额则出现在第 1 条记录，是 267。</p>
<p>所以，MAX（字段）这个函数返回分组集中最大的那个值。如果你要查询 MAX（字段 1）和 MAX（字段 2），而它们是相互独立、分别计算的，你千万不要想当然地认为结果在同一条记录上。那样的话，你就掉坑里了。</p>
<h2 id="count">COUNT()</h2>
<p>通过 <strong>COUNT()</strong>，我们可以了解数据集的大小，这对系统优化十分重要。</p>
<p>举个小例子，在项目实施的过程中，我们遇到了这么一个问题：由于用户的销售数据很多，而且每天都在增长，因此，在做销售查询的时候，经常会遇到卡顿的问题。这是因为，查询的数据量太大了，导致系统不得不花很多时间来处理数据，并给数据集分配资源，比如内存什么的。</p>
<p>怎么解决卡顿的问题呢？我们想到了一个分页的策略。</p>
<p>所谓的分页策略，其实就是，不把查询的结果一次性全部返回给客户端，而是根据用户电脑屏幕的大小，计算一屏可以显示的记录数，每次只返回用户电脑屏幕可以显示的数据集。接着，再通过翻页、跳转等功能按钮，实现查询目标的精准锁定。这样一来，每次查询的数据量较少，也就大大提高了系统响应速度。</p>
<p>这个策略能够实现的一个关键，就是要<strong>计算出符合条件的记录一共有多少条</strong>，之后才能计算出一共有几页、能不能翻页或跳转。</p>
<p>要计算记录数，就要用到 COUNT() 函数了。这个函数有两种情况。</p>
<ol>
<li>COUNT（*）：统计一共有多少条记录；</li>
<li>COUNT（字段）：统计有多少个不为空的字段值。</li>
</ol>
<p>1.COUNT(*)</p>
<p>如果 COUNT（*）与 GROUP BY 一起使用，就表示统计分组内有多少条数据。它也可以单独使用，这就相当于数据集全体是一个分组，统计全部数据集的记录数。</p>
<p>我举个小例子，假设我有个销售流水明细表如下：</p>
<p>mysql&gt; SELECT *<br>
-&gt; FROM demo.transactiondetails;<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;+<br>
| transactionid | itemnumber | quantity | price | salesvalue |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;+<br>
|             1 |          1 |    2.000 | 89.00 |     178.00 |<br>
|             1 |          2 |    5.000 |  5.00 |      25.00 |<br>
|             2 |          1 |    3.000 | 89.00 |     267.00 |<br>
|             2 |          2 |    6.000 |  5.00 |      30.00 |<br>
|             3 |          1 |    1.000 | 89.00 |      89.00 |<br>
|             3 |          2 |   10.000 |  5.00 |      50.00 |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;+<br>
6 rows in set (0.00 sec)</p>
<p>如果我们一屏可以显示 30 行，需要多少页才能显示完这个表的全部数据呢？</p>
<p>mysql&gt; SELECT COUNT(<em>)<br>
-&gt; FROM demo.transactiondetails;<br>
+&mdash;&mdash;&mdash;-+<br>
| COUNT(</em>) |<br>
+&mdash;&mdash;&mdash;-+<br>
| 6 |<br>
+&mdash;&mdash;&mdash;-+<br>
1 row in set (0.03 sec)</p>
<p>我们这里只有 6 条数据，一屏就可以显示了，所以一共 1 页。</p>
<p>那么，如果超市经营者想知道，每天、每种商品都有几次销售，我们就需要按天、按商品名称，进行分组查询：</p>
<p>mysql&gt; SELECT<br>
-&gt; LEFT(a.transdate, 10), c.goodsname, COUNT(<em>) &ndash; 统计销售次数<br>
-&gt; FROM<br>
-&gt; demo.transactionhead a<br>
-&gt; JOIN<br>
-&gt; demo.transactiondetails b ON (a.transactionid = b.transactionid)<br>
-&gt; JOIN<br>
-&gt; demo.goodsmaster c ON (b.itemnumber = c.itemnumber)<br>
-&gt; GROUP BY LEFT(a.transdate, 10) , c.goodsname<br>
-&gt; ORDER BY LEFT(a.transdate, 10) , c.goodsname;<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;-+<br>
| LEFT(a.transdate, 10) | goodsname | COUNT(</em>) |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;-+<br>
| 2020-12-01 | 书 | 1 |<br>
| 2020-12-01 | 笔 | 1 |<br>
| 2020-12-02 | 书 | 2 |<br>
| 2020-12-02 | 笔 | 2 |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;-+<br>
4 rows in set (0.00 sec)</p>
<p>运行这段代码，我们就得到了每天、每种商品有几次销售的全部结果。</p>
<p>2.COUNT（字段）</p>
<p>COUNT（字段）用来统计分组内这个字段的值出现了多少次。如果字段值是空，就不统计。</p>
<p>为了说明它们的区别，我举个小例子。假设我们有这样的一个商品信息表，里面包括了商品编号、条码、名称、规格、单位和售价的信息。</p>
<p>mysql&gt; SELECT *<br>
-&gt; FROM demo.goodsmaster;<br>
+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;+<br>
| itemnumber | barcode | goodsname | specification | unit | salesprice |<br>
+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;+<br>
| 1 | 0001 | 书 | 16 开 | 本 | 89.00 |<br>
| 2 | 0002 | 笔 | NULL | 支 | 5.00 |<br>
| 3 | 0002 | 笔 | NULL | 支 | 10.00 |<br>
+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;+<br>
3 rows in set (0.01 sec)</p>
<p>如果我们要统计字段“goodsname”出现了多少次，就要用到函数 COUNT（goodsname），结果是 3 次：</p>
<p>mysql&gt; SELECT COUNT(goodsname) &ndash; 统计商品名称字段<br>
-&gt; FROM demo.goodsmaster;<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+<br>
| COUNT(goodsname) |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+<br>
| 3 |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+<br>
1 row in set (0.00 sec)</p>
<p>如果我们统计字段“specification”，用 COUNT(specification)，结果是 1 次：</p>
<p>mysql&gt; SELECT COUNT(specification) &ndash; 统计规格字段<br>
-&gt; FROM demo.goodsmaster;<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br>
| COUNT(specification) |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br>
| 1 |<br>
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br>
1 row in set (0.00 sec)</p>
<p>你可能会问，为啥计数字段“goodsname”的结果是 3，计数字段“specification”却只有 1 呢？其实，这里的原因就是，3 条记录里面的字段“goodsname”没有空值，因此被统计了 3 次；而字段“specification”有 2 个空值，因此只统计了 1 次。</p>
<p>理解了这一点，你就可以利用计数函数对某个字段计数时，不统计空值的特点，对表中字段的非空值进行计数了。</p>
<h2 id="总结">总结</h2>
<p>今天，我们学习了聚合函数 SUM()、AVG()、MAX()、MIN()和 COUNT()。我们在对分组数据进行统计的时候，可以用这些函数来对分组数据求和、求平均值、最大值、最小值，以及统计分组内的记录数，或者分组内字段的值不为空的次数。</p>
<p>这些函数，为我们对数据库中的数据进行统计和计算提供了方便。因为计算直接在数据库中执行，比在应用层面完成相同的工作，效率高很多。</p>
<p>最后，我还想多说一句，不知道你注意到没有，这节课我还提到了 LEFT 和 ORDER BY。其实，聚合函数可以和其他关键字、函数一起使用，这样会拓展它的使用场景，让原本复杂的计算变简单。所以，我建议你不仅要认真学习这节课的聚合函数，还要掌握 MySQL 的各种关键字的功能和用法，并且根据实际工作的需要，尝试把它们组合在一起使用，这样就能利用好数据库的强大功能，更好地满足用户的需求。</p>
<h2 id="思考题">思考题</h2>
<p>如果用户想要查询一下，在商品信息表中，到底是哪种商品的商品名称有重复，分别重复了几次，该如何查询呢？</p>
<p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你分享你的朋友或同事，我们下节课见。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">MySQL必知必会</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/devops%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/08__%E7%B2%BE%E7%9B%8A%E7%9C%8B%E6%9D%BF%E4%B8%8A%E7%B2%BE%E7%9B%8A%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">08__精益看板（上）：精益驱动的敏捷开发方法</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%9D%A2%E8%AF%95%E7%8E%B0%E5%9C%BA/08__%E8%80%83%E5%AE%98%E9%9D%A2%E5%AF%B9%E9%9D%A2%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E5%9C%B0%E5%87%86%E5%A4%87%E4%B8%80%E5%9C%BA%E9%9D%A2%E8%AF%95/">
            <span class="next-text nav-default">08__考官面对面：如何有效地准备一场面试？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
