<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>05字典集合你真的了解吗 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="04 | 字典、集合，你真的了解吗？
你好，我是景霄。
前面的课程，我们学习了 Python 中的列表和元组，了解了他们的基本操作和性能比较。这节课，我们再来学习两个同样很常见并且很有用的数据结构：字典（dict）和集合（set）。字典和集合在 Python 被广泛使用，并且性能进行了高度优化，其重要性不言而喻。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/05%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/05%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="05字典集合你真的了解吗">
  <meta property="og:description" content="04 | 字典、集合，你真的了解吗？
你好，我是景霄。
前面的课程，我们学习了 Python 中的列表和元组，了解了他们的基本操作和性能比较。这节课，我们再来学习两个同样很常见并且很有用的数据结构：字典（dict）和集合（set）。字典和集合在 Python 被广泛使用，并且性能进行了高度优化，其重要性不言而喻。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Python核心技术与实战">

  <meta itemprop="name" content="05字典集合你真的了解吗">
  <meta itemprop="description" content="04 | 字典、集合，你真的了解吗？
你好，我是景霄。
前面的课程，我们学习了 Python 中的列表和元组，了解了他们的基本操作和性能比较。这节课，我们再来学习两个同样很常见并且很有用的数据结构：字典（dict）和集合（set）。字典和集合在 Python 被广泛使用，并且性能进行了高度优化，其重要性不言而喻。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4066">
  <meta itemprop="keywords" content="Python核心技术与实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="05字典集合你真的了解吗">
  <meta name="twitter:description" content="04 | 字典、集合，你真的了解吗？
你好，我是景霄。
前面的课程，我们学习了 Python 中的列表和元组，了解了他们的基本操作和性能比较。这节课，我们再来学习两个同样很常见并且很有用的数据结构：字典（dict）和集合（set）。字典和集合在 Python 被广泛使用，并且性能进行了高度优化，其重要性不言而喻。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">05字典集合你真的了解吗</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4066 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>04 | 字典、集合，你真的了解吗？</p>
<p>你好，我是景霄。</p>
<p>前面的课程，我们学习了 Python 中的列表和元组，了解了他们的基本操作和性能比较。这节课，我们再来学习两个同样很常见并且很有用的数据结构：字典（dict）和集合（set）。字典和集合在 Python 被广泛使用，并且性能进行了高度优化，其重要性不言而喻。</p>
<p>字典和集合基础</p>
<p>那究竟什么是字典，什么是集合呢？字典是一系列由键（key）和值（value）配对组成的元素的集合，在 Python3.7+，字典被确定为有序（注意：在 3.6 中，字典有序是一个 implementation detail，在 3.7 才正式成为语言特性，因此 3.6 中无法 100% 确保其有序性），而 3.6 之前是无序的，其长度大小可变，元素可以任意地删减和改变。</p>
<p>相比于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成。</p>
<p>而集合和字典基本相同，唯一的区别，就是集合没有键和值的配对，是一系列无序的、唯一的元素组合。</p>
<p>首先我们来看字典和集合的创建，通常有下面这几种方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">d1 = {&#39;name&#39;: &#39;jason&#39;, &#39;age&#39;: 20, &#39;gender&#39;: &#39;male&#39;}
</span></span><span class="line"><span class="cl">d2 = dict({&#39;name&#39;: &#39;jason&#39;, &#39;age&#39;: 20, &#39;gender&#39;: &#39;male&#39;})
</span></span><span class="line"><span class="cl">d3 = dict([(&#39;name&#39;, &#39;jason&#39;), (&#39;age&#39;, 20), (&#39;gender&#39;, &#39;male&#39;)])
</span></span><span class="line"><span class="cl">d4 = dict(name=&#39;jason&#39;, age=20, gender=&#39;male&#39;) 
</span></span><span class="line"><span class="cl">d1 == d2 == d3 ==d4
</span></span><span class="line"><span class="cl">True
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">s1 = {1, 2, 3}
</span></span><span class="line"><span class="cl">s2 = set([1, 2, 3])
</span></span><span class="line"><span class="cl">s1 == s2
</span></span><span class="line"><span class="cl">True
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里注意，Python 中字典和集合，无论是键还是值，都可以是混合类型。比如下面这个例子，我创建了一个元素为
1
，
&lsquo;hello&rsquo;
，
5.0
的集合：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">s = {1, &#39;hello&#39;, 5.0}
</span></span></code></pre></td></tr></table>
</div>
</div><p>再来看元素访问的问题。字典访问可以直接索引键，如果不存在，就会抛出异常：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">d = {&#39;name&#39;: &#39;jason&#39;, &#39;age&#39;: 20}
</span></span><span class="line"><span class="cl">d[&#39;name&#39;]
</span></span><span class="line"><span class="cl">&#39;jason&#39;
</span></span><span class="line"><span class="cl">d[&#39;location&#39;]
</span></span><span class="line"><span class="cl">Traceback (most recent call last):
</span></span><span class="line"><span class="cl">  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
</span></span><span class="line"><span class="cl">KeyError: &#39;location&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以使用 get(key, default) 函数来进行索引。如果键不存在，调用 get() 函数可以返回一个默认值。比如下面这个示例，返回了
&rsquo;null'
。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">d = {&#39;name&#39;: &#39;jason&#39;, &#39;age&#39;: 20}
</span></span><span class="line"><span class="cl">d.get(&#39;name&#39;)
</span></span><span class="line"><span class="cl">&#39;jason&#39;
</span></span><span class="line"><span class="cl">d.get(&#39;location&#39;, &#39;null&#39;)
</span></span><span class="line"><span class="cl">&#39;null&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><p>说完了字典的访问，我们再来看集合。</p>
<p>首先我要强调的是，集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一样。所以，下面这样的操作是错误的，Python 会抛出异常：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">s = {1, 2, 3}
</span></span><span class="line"><span class="cl">s[0]
</span></span><span class="line"><span class="cl">Traceback (most recent call last):
</span></span><span class="line"><span class="cl">  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
</span></span><span class="line"><span class="cl">TypeError: &#39;set&#39; object does not support indexing
</span></span></code></pre></td></tr></table>
</div>
</div><p>想要判断一个元素在不在字典或集合内，我们可以用 value in dict/set 来判断。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">s = {1, 2, 3}
</span></span><span class="line"><span class="cl">1 in s
</span></span><span class="line"><span class="cl">True
</span></span><span class="line"><span class="cl">10 in s
</span></span><span class="line"><span class="cl">False
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">d = {&#39;name&#39;: &#39;jason&#39;, &#39;age&#39;: 20}
</span></span><span class="line"><span class="cl">&#39;name&#39; in d
</span></span><span class="line"><span class="cl">True
</span></span><span class="line"><span class="cl">&#39;location&#39; in d
</span></span><span class="line"><span class="cl">False
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然，除了创建和访问，字典和集合也同样支持增加、删除、更新等操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">d = {&#39;name&#39;: &#39;jason&#39;, &#39;age&#39;: 20}
</span></span><span class="line"><span class="cl">d[&#39;gender&#39;] = &#39;male&#39; # 增加元素对&#39;gender&#39;: &#39;male&#39;
</span></span><span class="line"><span class="cl">d[&#39;dob&#39;] = &#39;1999-02-01&#39; # 增加元素对&#39;dob&#39;: &#39;1999-02-01&#39;
</span></span><span class="line"><span class="cl">d
</span></span><span class="line"><span class="cl">{&#39;name&#39;: &#39;jason&#39;, &#39;age&#39;: 20, &#39;gender&#39;: &#39;male&#39;, &#39;dob&#39;: &#39;1999-02-01&#39;}
</span></span><span class="line"><span class="cl">d[&#39;dob&#39;] = &#39;1998-01-01&#39; # 更新键&#39;dob&#39;对应的值 
</span></span><span class="line"><span class="cl">d.pop(&#39;dob&#39;) # 删除键为&#39;dob&#39;的元素对
</span></span><span class="line"><span class="cl">&#39;1998-01-01&#39;
</span></span><span class="line"><span class="cl">d
</span></span><span class="line"><span class="cl">{&#39;name&#39;: &#39;jason&#39;, &#39;age&#39;: 20, &#39;gender&#39;: &#39;male&#39;}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">s = {1, 2, 3}
</span></span><span class="line"><span class="cl">s.add(4) # 增加元素 4 到集合
</span></span><span class="line"><span class="cl">s
</span></span><span class="line"><span class="cl">{1, 2, 3, 4}
</span></span><span class="line"><span class="cl">s.remove(4) # 从集合中删除元素 4
</span></span><span class="line"><span class="cl">s
</span></span><span class="line"><span class="cl">{1, 2, 3}
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过要注意，集合的 pop() 操作是删除集合中最后一个元素，可是集合本身是无序的，你无法知道会删除哪个元素，因此这个操作得谨慎使用。</p>
<p>实际应用中，很多情况下，我们需要对字典或集合进行排序，比如，取出值最大的 50 对。</p>
<p>对于字典，我们通常会根据键或值，进行升序或降序排序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">d = {&#39;b&#39;: 1, &#39;a&#39;: 2, &#39;c&#39;: 10}
</span></span><span class="line"><span class="cl">d_sorted_by_key = sorted(d.items(), key=lambda x: x[0]) # 根据字典键的升序排序
</span></span><span class="line"><span class="cl">d_sorted_by_value = sorted(d.items(), key=lambda x: x[1]) # 根据字典值的升序排序
</span></span><span class="line"><span class="cl">d_sorted_by_key
</span></span><span class="line"><span class="cl">[(&#39;a&#39;, 2), (&#39;b&#39;, 1), (&#39;c&#39;, 10)]
</span></span><span class="line"><span class="cl">d_sorted_by_value
</span></span><span class="line"><span class="cl">[(&#39;b&#39;, 1), (&#39;a&#39;, 2), (&#39;c&#39;, 10)]
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里返回了一个列表。列表中的每个元素，是由原字典的键和值组成的元组。</p>
<p>而对于集合，其排序和前面讲过的列表、元组很类似，直接调用 sorted(set) 即可，结果会返回一个排好序的列表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">s = {3, 4, 2, 1}
</span></span><span class="line"><span class="cl">sorted(s) # 对集合的元素进行升序排序
</span></span><span class="line"><span class="cl">[1, 2, 3, 4]
</span></span></code></pre></td></tr></table>
</div>
</div><p>字典和集合性能</p>
<p>文章开头我就说到了，字典和集合是进行过性能高度优化的数据结构，特别是对于查找、添加和删除操作。那接下来，我们就来看看，它们在具体场景下的性能表现，以及与列表等其他数据结构的对比。</p>
<p>比如电商企业的后台，存储了每件产品的 ID、名称和价格。现在的需求是，给定某件商品的 ID，我们要找出其价格。</p>
<p>如果我们用列表来存储这些数据结构，并进行查找，相应的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def find_product_price(products, product_id):
</span></span><span class="line"><span class="cl">    for id, price in products:
</span></span><span class="line"><span class="cl">        if id == product_id:
</span></span><span class="line"><span class="cl">            return price
</span></span><span class="line"><span class="cl">    return None 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">products = [
</span></span><span class="line"><span class="cl">    (143121312, 100), 
</span></span><span class="line"><span class="cl">    (432314553, 30),
</span></span><span class="line"><span class="cl">    (32421912367, 150) 
</span></span><span class="line"><span class="cl">]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">print(&#39;The price of product 432314553 is {}&#39;.format(find_product_price(products, 432314553)))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 输出
</span></span><span class="line"><span class="cl">The price of product 432314553 is 30
</span></span></code></pre></td></tr></table>
</div>
</div><p>假设列表有 n 个元素，而查找的过程要遍历列表，那么时间复杂度就为 O(n)。即使我们先对列表进行排序，然后使用二分查找，也会需要 O(logn) 的时间复杂度，更何况，列表的排序还需要 O(nlogn) 的时间。</p>
<p>但如果我们用字典来存储这些数据，那么查找就会非常便捷高效，只需 O(1) 的时间复杂度就可以完成。原因也很简单，刚刚提到过的，字典的内部组成是一张哈希表，你可以直接通过键的哈希值，找到其对应的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">products = {
</span></span><span class="line"><span class="cl">  143121312: 100,
</span></span><span class="line"><span class="cl">  432314553: 30,
</span></span><span class="line"><span class="cl">  32421912367: 150
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">print(&#39;The price of product 432314553 is {}&#39;.format(products[432314553])) 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 输出
</span></span><span class="line"><span class="cl">The price of product 432314553 is 30
</span></span></code></pre></td></tr></table>
</div>
</div><p>类似的，现在需求变成，要找出这些商品有多少种不同的价格。我们还用同样的方法来比较一下。</p>
<p>如果还是选择使用列表，对应的代码如下，其中，A 和 B 是两层循环。同样假设原始列表有 n 个元素，那么，在最差情况下，需要 O(n^2) 的时间复杂度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># list version
</span></span><span class="line"><span class="cl">def find_unique_price_using_list(products):
</span></span><span class="line"><span class="cl">    unique_price_list = []
</span></span><span class="line"><span class="cl">    for _, price in products: # A
</span></span><span class="line"><span class="cl">        if price not in unique_price_list: #B
</span></span><span class="line"><span class="cl">            unique_price_list.append(price)
</span></span><span class="line"><span class="cl">    return len(unique_price_list)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">products = [
</span></span><span class="line"><span class="cl">    (143121312, 100), 
</span></span><span class="line"><span class="cl">    (432314553, 30),
</span></span><span class="line"><span class="cl">    (32421912367, 150),
</span></span><span class="line"><span class="cl">    (937153201, 30)
</span></span><span class="line"><span class="cl">]
</span></span><span class="line"><span class="cl">print(&#39;number of unique price is: {}&#39;.format(find_unique_price_using_list(products)))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 输出
</span></span><span class="line"><span class="cl">number of unique price is: 3
</span></span></code></pre></td></tr></table>
</div>
</div><p>但如果我们选择使用集合这个数据结构，由于集合是高度优化的哈希表，里面元素不能重复，并且其添加和查找操作只需 O(1) 的复杂度，那么，总的时间复杂度就只有 O(n)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># set version
</span></span><span class="line"><span class="cl">def find_unique_price_using_set(products):
</span></span><span class="line"><span class="cl">    unique_price_set = set()
</span></span><span class="line"><span class="cl">    for _, price in products:
</span></span><span class="line"><span class="cl">        unique_price_set.add(price)
</span></span><span class="line"><span class="cl">    return len(unique_price_set)        
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">products = [
</span></span><span class="line"><span class="cl">    (143121312, 100), 
</span></span><span class="line"><span class="cl">    (432314553, 30),
</span></span><span class="line"><span class="cl">    (32421912367, 150),
</span></span><span class="line"><span class="cl">    (937153201, 30)
</span></span><span class="line"><span class="cl">]
</span></span><span class="line"><span class="cl">print(&#39;number of unique price is: {}&#39;.format(find_unique_price_using_set(products)))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 输出
</span></span><span class="line"><span class="cl">number of unique price is: 3
</span></span></code></pre></td></tr></table>
</div>
</div><p>可能你对这些时间复杂度没有直观的认识，我可以举一个实际工作场景中的例子，让你来感受一下。</p>
<p>下面的代码，初始化了含有 100,000 个元素的产品，并分别计算了使用列表和集合来统计产品价格数量的运行时间：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">import time
</span></span><span class="line"><span class="cl">id = [x for x in range(0, 100000)]
</span></span><span class="line"><span class="cl">price = [x for x in range(200000, 300000)]
</span></span><span class="line"><span class="cl">products = list(zip(id, price))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 计算列表版本的时间
</span></span><span class="line"><span class="cl">start_using_list = time.perf_counter()
</span></span><span class="line"><span class="cl">find_unique_price_using_list(products)
</span></span><span class="line"><span class="cl">end_using_list = time.perf_counter()
</span></span><span class="line"><span class="cl">print(&#34;time elapse using list: {}&#34;.format(end_using_list - start_using_list))
</span></span><span class="line"><span class="cl">## 输出
</span></span><span class="line"><span class="cl">time elapse using list: 41.61519479751587
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 计算集合版本的时间
</span></span><span class="line"><span class="cl">start_using_set = time.perf_counter()
</span></span><span class="line"><span class="cl">find_unique_price_using_set(products)
</span></span><span class="line"><span class="cl">end_using_set = time.perf_counter()
</span></span><span class="line"><span class="cl">print(&#34;time elapse using set: {}&#34;.format(end_using_set - start_using_set))
</span></span><span class="line"><span class="cl"># 输出
</span></span><span class="line"><span class="cl">time elapse using set: 0.008238077163696289
</span></span></code></pre></td></tr></table>
</div>
</div><p>你可以看到，仅仅十万的数据量，两者的速度差异就如此之大。事实上，大型企业的后台数据往往有上亿乃至十亿数量级，如果使用了不合适的数据结构，就很容易造成服务器的崩溃，不但影响用户体验，并且会给公司带来巨大的财产损失。</p>
<p>字典和集合的工作原理</p>
<p>我们通过举例以及与列表的对比，看到了字典和集合操作的高效性。不过，字典和集合为什么能够如此高效，特别是查找、插入和删除操作？</p>
<p>这当然和字典、集合内部的数据结构密不可分。不同于其他数据结构，字典和集合的内部结构都是一张哈希表。</p>
<p>对于字典而言，这张表存储了哈希值（hash）、键和值这 3 个元素。</p>
<p>而对集合来说，区别就是哈希表内没有键和值的配对，只有单一的元素了。</p>
<p>我们来看，老版本 Python 的哈希表结构如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--+-------------------------------+
</span></span><span class="line"><span class="cl">  | 哈希值 (hash)  键 (key)  值 (value)
</span></span><span class="line"><span class="cl">--+-------------------------------+
</span></span><span class="line"><span class="cl">0 |    hash0      key0    value0
</span></span><span class="line"><span class="cl">--+-------------------------------+
</span></span><span class="line"><span class="cl">1 |    hash1      key1    value1
</span></span><span class="line"><span class="cl">--+-------------------------------+
</span></span><span class="line"><span class="cl">2 |    hash2      key2    value2
</span></span><span class="line"><span class="cl">--+-------------------------------+
</span></span><span class="line"><span class="cl">. |           ...
</span></span><span class="line"><span class="cl">__+_______________________________+
</span></span></code></pre></td></tr></table>
</div>
</div><p>不难想象，随着哈希表的扩张，它会变得越来越稀疏。举个例子，比如我有这样一个字典：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{&#39;name&#39;: &#39;mike&#39;, &#39;dob&#39;: &#39;1999-01-01&#39;, &#39;gender&#39;: &#39;male&#39;}
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么它会存储为类似下面的形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">entries = [
</span></span><span class="line"><span class="cl">[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;]
</span></span><span class="line"><span class="cl">[-230273521, &#39;dob&#39;, &#39;1999-01-01&#39;],
</span></span><span class="line"><span class="cl">[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;],
</span></span><span class="line"><span class="cl">[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;],
</span></span><span class="line"><span class="cl">[1231236123, &#39;name&#39;, &#39;mike&#39;],
</span></span><span class="line"><span class="cl">[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;],
</span></span><span class="line"><span class="cl">[9371539127, &#39;gender&#39;, &#39;male&#39;]
</span></span><span class="line"><span class="cl">]
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样的设计结构显然非常浪费存储空间。为了提高存储空间的利用率，现在的哈希表除了字典本身的结构，会把索引和哈希值、键、值单独分开，也就是下面这样新的结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Indices
</span></span><span class="line"><span class="cl">----------------------------------------------------
</span></span><span class="line"><span class="cl">None | index | None | None | index | None | index ...
</span></span><span class="line"><span class="cl">----------------------------------------------------
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Entries
</span></span><span class="line"><span class="cl">--------------------
</span></span><span class="line"><span class="cl">hash0   key0  value0
</span></span><span class="line"><span class="cl">---------------------
</span></span><span class="line"><span class="cl">hash1   key1  value1
</span></span><span class="line"><span class="cl">---------------------
</span></span><span class="line"><span class="cl">hash2   key2  value2
</span></span><span class="line"><span class="cl">---------------------
</span></span><span class="line"><span class="cl">        ...
</span></span><span class="line"><span class="cl">---------------------
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么，刚刚的这个例子，在新的哈希表结构下的存储形式，就会变成下面这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">indices = [None, 1, None, None, 0, None, 2]
</span></span><span class="line"><span class="cl">entries = [
</span></span><span class="line"><span class="cl">[1231236123, &#39;name&#39;, &#39;mike&#39;],
</span></span><span class="line"><span class="cl">[-230273521, &#39;dob&#39;, &#39;1999-01-01&#39;],
</span></span><span class="line"><span class="cl">[9371539127, &#39;gender&#39;, &#39;male&#39;]
</span></span><span class="line"><span class="cl">]
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以很清晰地看到，空间利用率得到很大的提高。</p>
<p>清楚了具体的设计结构，我们接着来看这几个操作的工作原理。</p>
<p>插入操作</p>
<p>每次向字典或集合插入一个元素时，Python 会首先计算键的哈希值（hash(key)），再和 mask = PyDicMinSize - 1 做与操作，计算这个元素应该插入哈希表的位置 index = hash(key) &amp; mask。如果哈希表中此位置是空的，那么这个元素就会被插入其中。</p>
<p>而如果此位置已被占用，Python 便会比较两个元素的哈希值和键是否相等。</p>
<p>若两者都相等，则表明这个元素已经存在，如果值不同，则更新值。</p>
<p>若两者中有一个不相等，这种情况我们通常称为哈希冲突（hash collision），意思是两个元素的键不相等，但是哈希值相等。这种情况下，Python 便会继续寻找表中空余的位置，直到找到位置为止。</p>
<p>值得一提的是，通常来说，遇到这种情况，最简单的方式是线性寻找，即从这个位置开始，挨个往后寻找空位。当然，Python 内部对此进行了优化（这一点无需深入了解，你有兴趣可以查看源码，我就不再赘述），让这个步骤更加高效。</p>
<p>查找操作</p>
<p>和前面的插入操作类似，Python 会根据哈希值，找到其应该处于的位置；然后，比较哈希表这个位置中元素的哈希值和键，与需要查找的元素是否相等。如果相等，则直接返回；如果不等，则继续查找，直到找到空位或者抛出异常为止。</p>
<p>删除操作</p>
<p>对于删除操作，Python 会暂时对这个位置的元素，赋于一个特殊的值，等到重新调整哈希表的大小时，再将其删除。</p>
<p>不难理解，哈希冲突的发生，往往会降低字典和集合操作的速度。因此，为了保证其高效性，字典和集合内的哈希表，通常会保证其至少留有 1/3 的剩余空间。随着元素的不停插入，当剩余空间小于 1/3 时，Python 会重新获取更大的内存空间，扩充哈希表。不过，这种情况下，表内所有的元素位置都会被重新排放。</p>
<p>虽然哈希冲突和哈希表大小的调整，都会导致速度减缓，但是这种情况发生的次数极少。所以，平均情况下，这仍能保证插入、查找和删除的时间复杂度为 O(1)。</p>
<p>总结</p>
<p>这节课，我们一起学习了字典和集合的基本操作，并对它们的高性能和内部存储结构进行了讲解。</p>
<p>字典在 Python3.7+ 是有序的数据结构，而集合是无序的，其内部的哈希表存储结构，保证了其查找、插入、删除操作的高效性。所以，字典和集合通常运用在对元素的高效查找、去重等场景。</p>
<p>思考题</p>
<ol>
<li>下面初始化字典的方式，哪一种更高效？</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Option A
</span></span><span class="line"><span class="cl">d = {&#39;name&#39;: &#39;jason&#39;, &#39;age&#39;: 20, &#39;gender&#39;: &#39;male&#39;}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Option B
</span></span><span class="line"><span class="cl">d = dict({&#39;name&#39;: &#39;jason&#39;, &#39;age&#39;: 20, &#39;gender&#39;: &#39;male&#39;})
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>字典的键可以是一个列表吗？下面这段代码中，字典的初始化是否正确呢？如果不正确，可以说出你的原因吗？</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">d = {&#39;name&#39;: &#39;jason&#39;, [&#39;education&#39;]: [&#39;Tsinghua University&#39;, &#39;Stanford University&#39;]}
</span></span></code></pre></td></tr></table>
</div>
</div><p>欢迎留言和我分享，也欢迎你把这篇文章分享给你的同事、朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/">Python核心技术与实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3tomcat_jetty/05%E5%AE%9E%E6%88%98%E7%BA%AF%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0%E5%92%8C%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AAservlet/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">05实战纯手工打造和运行一个Servlet</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/05%E9%A1%B6%E7%BA%A7%E6%A1%86%E6%9E%B6spring%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9reactor%E4%BD%9C%E4%B8%BA%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/">
            <span class="next-text nav-default">05顶级框架：Spring为什么选择Reactor作为响应式编程框架？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
