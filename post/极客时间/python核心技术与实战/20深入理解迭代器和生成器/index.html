<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>20深入理解迭代器和生成器 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="19 | 深入理解迭代器和生成器
你好，我是景霄。
在第一次接触 Python 的时候，你可能写过类似 for i in [2, 3, 5, 7, 11, 13]: print(i) 这样的语句。for in 语句理解起来很直观形象，比起 C&#43;&#43; 和 java 早期的 for (int i = 0; i &lt; n; i &#43;&#43;) printf(&quot;%d\n&quot;, a[i]) 这样的语句，不知道简洁清晰到哪里去了。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="20深入理解迭代器和生成器">
  <meta property="og:description" content="19 | 深入理解迭代器和生成器
你好，我是景霄。
在第一次接触 Python 的时候，你可能写过类似 for i in [2, 3, 5, 7, 11, 13]: print(i) 这样的语句。for in 语句理解起来很直观形象，比起 C&#43;&#43; 和 java 早期的 for (int i = 0; i &lt; n; i &#43;&#43;) printf(&#34;%d\n&#34;, a[i]) 这样的语句，不知道简洁清晰到哪里去了。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Python核心技术与实战">

  <meta itemprop="name" content="20深入理解迭代器和生成器">
  <meta itemprop="description" content="19 | 深入理解迭代器和生成器
你好，我是景霄。
在第一次接触 Python 的时候，你可能写过类似 for i in [2, 3, 5, 7, 11, 13]: print(i) 这样的语句。for in 语句理解起来很直观形象，比起 C&#43;&#43; 和 java 早期的 for (int i = 0; i &lt; n; i &#43;&#43;) printf(&#34;%d\n&#34;, a[i]) 这样的语句，不知道简洁清晰到哪里去了。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4036">
  <meta itemprop="keywords" content="Python核心技术与实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="20深入理解迭代器和生成器">
  <meta name="twitter:description" content="19 | 深入理解迭代器和生成器
你好，我是景霄。
在第一次接触 Python 的时候，你可能写过类似 for i in [2, 3, 5, 7, 11, 13]: print(i) 这样的语句。for in 语句理解起来很直观形象，比起 C&#43;&#43; 和 java 早期的 for (int i = 0; i &lt; n; i &#43;&#43;) printf(&#34;%d\n&#34;, a[i]) 这样的语句，不知道简洁清晰到哪里去了。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">20深入理解迭代器和生成器</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4036 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>19 | 深入理解迭代器和生成器</p>
<p>你好，我是景霄。</p>
<p>在第一次接触 Python 的时候，你可能写过类似
for i in [2, 3, 5, 7, 11, 13]: print(i)
这样的语句。for in 语句理解起来很直观形象，比起 C++ 和 java 早期的
for (int i = 0; i &lt; n; i ++) printf(&quot;%d\n&quot;, a[i])
这样的语句，不知道简洁清晰到哪里去了。</p>
<p>但是，你想过 Python 在处理 for in 语句的时候，具体发生了什么吗？什么样的对象可以被 for in 来枚举呢？</p>
<p>这一节课，我们深入到 Python 的容器类型实现底层去走走，了解一种叫做迭代器和生成器的东西。</p>
<p>你肯定用过的容器、可迭代对象和迭代器</p>
<p>容器这个概念非常好理解。我们说过，在 Python 中一切皆对象，对象的抽象就是类，而对象的集合就是容器。</p>
<p>列表（list: [0, 1, 2]），元组（tuple: (0, 1, 2)），字典（dict: {0:0, 1:1, 2:2}），集合（set: set([0, 1, 2])）都是容器。对于容器，你可以很直观地想象成多个元素在一起的单元；而不同容器的区别，正是在于内部数据结构的实现方法。然后，你就可以针对不同场景，选择不同时间和空间复杂度的容器。</p>
<p>所有的容器都是可迭代的（iterable）。这里的迭代，和枚举不完全一样。迭代可以想象成是你去买苹果，卖家并不告诉你他有多少库存。这样，每次你都需要告诉卖家，你要一个苹果，然后卖家采取行为：要么给你拿一个苹果；要么告诉你，苹果已经卖完了。你并不需要知道，卖家在仓库是怎么摆放苹果的。</p>
<p>严谨地说，迭代器（iterator）提供了一个 next 的方法。调用这个方法后，你要么得到这个容器的下一个对象，要么得到一个 StopIteration 的错误（苹果卖完了）。你不需要像列表一样指定元素的索引，因为字典和集合这样的容器并没有索引一说。比如，字典采用哈希表实现，那么你就只需要知道，next 函数可以不重复不遗漏地一个一个拿到所有元素即可。</p>
<p>而可迭代对象，通过 iter() 函数返回一个迭代器，再通过 next() 函数就可以实现遍历。for in 语句将这个过程隐式化，所以，你只需要知道它大概做了什么就行了。</p>
<p>我们来看下面这段代码，主要向你展示怎么判断一个对象是否可迭代。当然，这还有另一种做法，是 isinstance(obj, Iterable)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def is_iterable(param):
</span></span><span class="line"><span class="cl">    try: 
</span></span><span class="line"><span class="cl">        iter(param) 
</span></span><span class="line"><span class="cl">        return True
</span></span><span class="line"><span class="cl">    except TypeError:
</span></span><span class="line"><span class="cl">        return False
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">params = [
</span></span><span class="line"><span class="cl">    1234,
</span></span><span class="line"><span class="cl">    &#39;1234&#39;,
</span></span><span class="line"><span class="cl">    [1, 2, 3, 4],
</span></span><span class="line"><span class="cl">    set([1, 2, 3, 4]),
</span></span><span class="line"><span class="cl">    {1:1, 2:2, 3:3, 4:4},
</span></span><span class="line"><span class="cl">    (1, 2, 3, 4)
</span></span><span class="line"><span class="cl">]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">for param in params:
</span></span><span class="line"><span class="cl">    print(&#39;{} is iterable? {}&#39;.format(param, is_iterable(param)))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">########## 输出 ##########
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">1234 is iterable? False
</span></span><span class="line"><span class="cl">1234 is iterable? True
</span></span><span class="line"><span class="cl">[1, 2, 3, 4] is iterable? True
</span></span><span class="line"><span class="cl">{1, 2, 3, 4} is iterable? True
</span></span><span class="line"><span class="cl">{1: 1, 2: 2, 3: 3, 4: 4} is iterable? True
</span></span><span class="line"><span class="cl">(1, 2, 3, 4) is iterable? True
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过这段代码，你就可以知道，给出的类型中，除了数字 1234 之外，其它的数据类型都是可迭代的。</p>
<p>生成器，又是什么？</p>
<p>据我所知，很多人对生成器这个概念会比较陌生，因为生成器在很多常用语言中，并没有相对应的模型。</p>
<p>这里，你只需要记着一点：生成器是懒人版本的迭代器。</p>
<p>我们知道，在迭代器中，如果我们想要枚举它的元素，这些元素需要事先生成。这里，我们先来看下面这个简单的样例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">import os
</span></span><span class="line"><span class="cl">import psutil
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 显示当前 python 程序占用的内存大小
</span></span><span class="line"><span class="cl">def show_memory_info(hint):
</span></span><span class="line"><span class="cl">    pid = os.getpid()
</span></span><span class="line"><span class="cl">    p = psutil.Process(pid)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    info = p.memory_full_info()
</span></span><span class="line"><span class="cl">    memory = info.uss / 1024. / 1024
</span></span><span class="line"><span class="cl">    print(&#39;{} memory used: {} MB&#39;.format(hint, memory))
</span></span></code></pre></td></tr></table>
</div>
</div><p>def test_iterator():
    show_memory_info(&lsquo;initing iterator&rsquo;)
    list_1 = [i for i in range(100000000)]
    show_memory_info(&lsquo;after iterator initiated&rsquo;)
    print(sum(list_1))
    show_memory_info(&lsquo;after sum called&rsquo;)</p>
<p>def test_generator():
    show_memory_info(&lsquo;initing generator&rsquo;)
    list_2 = (i for i in range(100000000))
    show_memory_info(&lsquo;after generator initiated&rsquo;)
    print(sum(list_2))
    show_memory_info(&lsquo;after sum called&rsquo;)</p>
<p>%time test_iterator()
%time test_generator()</p>
<p>########## 输出 ##########</p>
<p>initing iterator memory used: 48.9765625 MB
after iterator initiated memory used: 3920.30078125 MB
4999999950000000
after sum called memory used: 3920.3046875 MB
Wall time: 17 s
initing generator memory used: 50.359375 MB
after generator initiated memory used: 50.359375 MB
4999999950000000
after sum called memory used: 50.109375 MB
Wall time: 12.5 s</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">声明一个迭代器很简单，
</span></span><span class="line"><span class="cl">[i for i in range(100000000)]
</span></span><span class="line"><span class="cl">就可以生成一个包含一亿元素的列表。每个元素在生成后都会保存到内存中，你通过代码可以看到，它们占用了巨量的内存，内存不够的话就会出现 OOM 错误。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">不过，我们并不需要在内存中同时保存这么多东西，比如对元素求和，我们只需要知道每个元素在相加的那一刻是多少就行了，用完就可以扔掉了。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">于是，生成器的概念应运而生，在你调用 next() 函数的时候，才会生成下一个变量。生成器在 Python 的写法是用小括号括起来，
</span></span><span class="line"><span class="cl">(i for i in range(100000000))
</span></span><span class="line"><span class="cl">，即初始化了一个生成器。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这样一来，你可以清晰地看到，生成器并不会像迭代器一样占用大量内存，只有在被使用的时候才会调用。而且生成器在初始化的时候，并不需要运行一次生成操作，相比于 test\_iterator() ，test\_generator() 函数节省了一次生成一亿个元素的过程，因此耗时明显比迭代器短。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">到这里，你可能说，生成器不过如此嘛，我有的是钱，不就是多占一些内存和计算资源嘛，我多出点钱就是了呗。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">哪怕你是土豪，请坐下先喝点茶，再听我继续讲完，这次，我们来实现一个自定义的生成器。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">生成器，还能玩什么花样？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">数学中有一个恒等式，
</span></span><span class="line"><span class="cl">(1 + 2 + 3 + ... + n)^2 = 1^3 + 2^3 + 3^3 + ... + n^3
</span></span><span class="line"><span class="cl">，想必你高中就应该学过它。现在，我们来验证一下这个公式的正确性。老规矩，先放代码，你先自己阅读一下，看不懂的也不要紧，接下来我再来详细讲解。
</span></span></code></pre></td></tr></table>
</div>
</div><p>def generator(k):
    i = 1
    while True:
        yield i ** k
        i += 1</p>
<p>gen_1 = generator(1)
gen_3 = generator(3)
print(gen_1)
print(gen_3)</p>
<p>def get_sum(n):
    sum_1, sum_3 = 0, 0
    for i in range(n):
        next_1 = next(gen_1)
        next_3 = next(gen_3)
        print(&rsquo;next_1 = {}, next_3 = {}&rsquo;.format(next_1, next_3))
        sum_1 += next_1
        sum_3 += next_3
    print(sum_1 * sum_1, sum_3)</p>
<p>get_sum(8)</p>
<p>########## 输出 ##########</p>
<p>&lt;generator object generator at 0x000001E70651C4F8&gt;
&lt;generator object generator at 0x000001E70651C390&gt;
next_1 = 1, next_3 = 1
next_1 = 2, next_3 = 8
next_1 = 3, next_3 = 27
next_1 = 4, next_3 = 64
next_1 = 5, next_3 = 125
next_1 = 6, next_3 = 216
next_1 = 7, next_3 = 343
next_1 = 8, next_3 = 512
1296 1296</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这段代码中，你首先注意一下 generator() 这个函数，它返回了一个生成器。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">接下来的 yield 是魔术的关键。对于初学者来说，你可以理解为，函数运行到这一行的时候，程序会从这里暂停，然后跳出，不过跳到哪里呢？答案是 next() 函数。那么 
</span></span><span class="line"><span class="cl">i ** k
</span></span><span class="line"><span class="cl"> 是干什么的呢？它其实成了 next() 函数的返回值。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这样，每次 next(gen) 函数被调用的时候，暂停的程序就又复活了，从 yield 这里向下继续执行；同时注意，局部变量 i 并没有被清除掉，而是会继续累加。我们可以看到 next\_1 从 1 变到 8，next\_3 从 1 变到 512。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">聪明的你应该注意到了，这个生成器居然可以一直进行下去！没错，事实上，迭代器是一个有限集合，生成器则可以成为一个无限集。我只管调用 next()，生成器根据运算会自动生成新的元素，然后返回给你，非常便捷。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">到这里，土豪同志应该也坐不住了吧，那么，还能再给力一点吗？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">别急，我们再来看一个问题：给定一个 list 和一个指定数字，求这个数字在 list 中的位置。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">下面这段代码你应该不陌生，也就是常规做法，枚举每个元素和它的 index，判断后加入 result，最后返回。
</span></span></code></pre></td></tr></table>
</div>
</div><p>def index_normal(L, target):
    result = []
    for i, num in enumerate(L):
        if num == target:
            result.append(i)
    return result</p>
<p>print(index_normal([1, 6, 2, 4, 5, 2, 8, 6, 3, 2], 2))</p>
<p>########## 输出 ##########</p>
<p>[2, 5, 9]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">那么使用迭代器可以怎么做呢？二话不说，先看代码。
</span></span></code></pre></td></tr></table>
</div>
</div><p>def index_generator(L, target):
    for i, num in enumerate(L):
        if num == target:
            yield i</p>
<p>print(list(index_generator([1, 6, 2, 4, 5, 2, 8, 6, 3, 2], 2)))</p>
<p>########## 输出 ##########</p>
<p>[2, 5, 9]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">聪明的你应该看到了明显的区别，我就不做过多解释了。唯一需要强调的是， index\_generator 会返回一个 Generator 对象，需要使用 list 转换为列表后，才能用 print 输出。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这里我再多说两句。在 Python 语言规范中，用更少、更清晰的代码实现相同功能，一直是被推崇的做法，因为这样能够很有效提高代码的可读性，减少出错概率，也方便别人快速准确理解你的意图。当然，要注意，这里“更少”的前提是清晰，而不是使用更多的魔术操作，虽说减少了代码却反而增加了阅读的难度。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">回归正题。接下来我们再来看一个问题：给定两个序列，判定第一个是不是第二个的子序列。（LeetCode 链接如下：https://leetcode.com/problems/is-subsequence/ ）
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">先来解读一下这个问题本身。序列就是列表，子序列则指的是，一个列表的元素在第二个列表中都按顺序出现，但是并不必挨在一起。举个例子，\[1, 3, 5\] 是 \[1, 2, 3, 4, 5\] 的子序列，\[1, 4, 3\] 则不是。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">要解决这个问题，常规算法是贪心算法。我们维护两个指针指向两个列表的最开始，然后对第二个序列一路扫过去，如果某个数字和第一个指针指的一样，那么就把第一个指针前进一步。第一个指针移出第一个序列最后一个元素的时候，返回 True，否则返回 False。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">不过，这个算法正常写的话，写下来怎么也得十行左右。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">那么如果我们用迭代器和生成器呢？
</span></span></code></pre></td></tr></table>
</div>
</div><p>def is_subsequence(a, b):
    b = iter(b)
    return all(i in b for i in a)</p>
<p>print(is_subsequence([1, 3, 5], [1, 2, 3, 4, 5]))
print(is_subsequence([1, 4, 3], [1, 2, 3, 4, 5]))</p>
<p>########## 输出 ##########</p>
<p>True
False</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这简短的几行代码，你是不是看得一头雾水，不知道发生了什么？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">来，我们先把这段代码复杂化，然后一步步看。
</span></span></code></pre></td></tr></table>
</div>
</div><p>def is_subsequence(a, b):
    b = iter(b)
    print(b)</p>
<p>    gen = (i for i in a)
    print(gen)</p>
<p>    for i in gen:
        print(i)</p>
<p>    gen = ((i in b) for i in a)
    print(gen)</p>
<p>    for i in gen:
        print(i)</p>
<p>    return all(((i in b) for i in a))</p>
<p>print(is_subsequence([1, 3, 5], [1, 2, 3, 4, 5]))
print(is_subsequence([1, 4, 3], [1, 2, 3, 4, 5]))</p>
<p>########## 输出 ##########</p>
<p>&lt;list_iterator object at 0x000001E7063D0E80&gt;
&lt;generator object is_subsequence.<locals>.<genexpr> at 0x000001E70651C570&gt;
1
3
5
&lt;generator object is_subsequence.<locals>.<genexpr> at 0x000001E70651C5E8&gt;
True
True
True
False
&lt;list_iterator object at 0x000001E7063D0D30&gt;
&lt;generator object is_subsequence.<locals>.<genexpr> at 0x000001E70651C5E8&gt;
1
4
3
&lt;generator object is_subsequence.<locals>.<genexpr> at 0x000001E70651C570&gt;
True
True
False
False</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">首先，第二行的
</span></span><span class="line"><span class="cl">b = iter(b)
</span></span><span class="line"><span class="cl">，把列表 b 转化成了一个迭代器，这里我先不解释为什么要这么做。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">接下来的
</span></span><span class="line"><span class="cl">gen = (i for i in a)
</span></span><span class="line"><span class="cl">语句很好理解，产生一个生成器，这个生成器可以遍历对象 a，因此能够输出 1, 3, 5。而 
</span></span><span class="line"><span class="cl">(i in b)
</span></span><span class="line"><span class="cl">需要好好揣摩，这里你是不是能联想到 for in 语句？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">没错，这里的
</span></span><span class="line"><span class="cl">(i in b)
</span></span><span class="line"><span class="cl">，大致等价于下面这段代码：
</span></span></code></pre></td></tr></table>
</div>
</div><p>while True:
    val = next(b)
    if val == i:
        yield True</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这里非常巧妙地利用生成器的特性，next() 函数运行的时候，保存了当前的指针。比如再看下面这个示例：
</span></span></code></pre></td></tr></table>
</div>
</div><p>b = (i for i in range(5))</p>
<p>print(2 in b)
print(4 in b)
print(3 in b)</p>
<p>########## 输出 ##########</p>
<p>True
True
False</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">至于最后的 all() 函数，就很简单了。它用来判断一个迭代器的元素是否全部为 True，如果是则返回 True，否则就返回 False.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">于是到此，我们就很优雅地解决了这道面试题。不过你一定注意，面试的时候尽量不要用这种技巧，因为你的面试官有可能并不知道生成器的用法，他们也没有看过我的极客时间专栏。不过，在这个技术知识点上，在实际工作的应用上，你已经比很多人更加熟练了。继续加油！
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">总结
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">总结一下，今天我们讲了四种不同的对象，分别是容器、可迭代对象、迭代器和生成器。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">容器是可迭代对象，可迭代对象调用 iter() 函数，可以得到一个迭代器。迭代器可以通过 next() 函数来得到下一个元素，从而支持遍历。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">生成器是一种特殊的迭代器（注意这个逻辑关系反之不成立）。使用生成器，你可以写出来更加清晰的代码；合理使用生成器，可以降低内存占用、优化程序结构、提高程序速度。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">生成器在 Python 2 的版本上，是协程的一种重要实现方式；而 Python 3.5 引入 async await 语法糖后，生成器实现协程的方式就已经落后了。我们会在下节课，继续深入讲解 Python 协程。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">思考题
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">最后给你留一个思考题。对于一个有限元素的生成器，如果迭代完成后，继续调用 next() ，会发生什么呢？生成器可以遍历多次吗？
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">欢迎留言和我讨论，也欢迎你把这篇文章分享给你的同事、朋友，一起在交流中进步。
</span></span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/">Python核心技术与实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A4%A7%E5%8E%82%E6%99%8B%E5%8D%87%E6%8C%87%E5%8D%97/20%E9%93%BE%E5%BC%8F%E6%AF%94%E8%BE%83%E7%8E%AF%E5%BC%8F%E5%AD%A6%E4%B9%A0%E6%B3%95%E6%80%8E%E4%B9%88%E5%A4%9A%E7%BB%B4%E5%BA%A6%E6%8F%90%E5%8D%87%E6%8A%80%E6%9C%AF%E8%83%BD%E5%8A%9B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">20链式比较环式学习法怎么多维度提升技术能力</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/20%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E6%9C%80%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E6%8E%8C%E6%8F%A1%E4%BB%80%E4%B9%88/">
            <span class="next-text nav-default">20协同过滤最经典的推荐模型我们应该掌握什么</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
