<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>07__性能场景的数据到底应该做成什么样子？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是高楼。
在性能项目中，性能数据是非常重要的输入资源。但是我经常看到有人拿着少得可怜的数据，来做比较大的压力，这显然不符合真实的场景，虽然拿到的结果很好看，但并不会得到什么有价值的结果。所以，今天我们就来讲一下性能场景中的数据到底应该做成什么样子。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/07__%E6%80%A7%E8%83%BD%E5%9C%BA%E6%99%AF%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%B0%E5%BA%95%E5%BA%94%E8%AF%A5%E5%81%9A%E6%88%90%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/07__%E6%80%A7%E8%83%BD%E5%9C%BA%E6%99%AF%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%B0%E5%BA%95%E5%BA%94%E8%AF%A5%E5%81%9A%E6%88%90%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="07__性能场景的数据到底应该做成什么样子？">
  <meta property="og:description" content="你好，我是高楼。
在性能项目中，性能数据是非常重要的输入资源。但是我经常看到有人拿着少得可怜的数据，来做比较大的压力，这显然不符合真实的场景，虽然拿到的结果很好看，但并不会得到什么有价值的结果。所以，今天我们就来讲一下性能场景中的数据到底应该做成什么样子。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="高楼的性能工程实战课">

  <meta itemprop="name" content="07__性能场景的数据到底应该做成什么样子？">
  <meta itemprop="description" content="你好，我是高楼。
在性能项目中，性能数据是非常重要的输入资源。但是我经常看到有人拿着少得可怜的数据，来做比较大的压力，这显然不符合真实的场景，虽然拿到的结果很好看，但并不会得到什么有价值的结果。所以，今天我们就来讲一下性能场景中的数据到底应该做成什么样子。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5051">
  <meta itemprop="keywords" content="高楼的性能工程实战课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="07__性能场景的数据到底应该做成什么样子？">
  <meta name="twitter:description" content="你好，我是高楼。
在性能项目中，性能数据是非常重要的输入资源。但是我经常看到有人拿着少得可怜的数据，来做比较大的压力，这显然不符合真实的场景，虽然拿到的结果很好看，但并不会得到什么有价值的结果。所以，今天我们就来讲一下性能场景中的数据到底应该做成什么样子。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">07__性能场景的数据到底应该做成什么样子？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5051 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#铺底数据">铺底数据</a></li>
        <li><a href="#参数化数据">参数化数据</a></li>
        <li><a href="#如何造数据">如何造数据？</a></li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#课后作业">课后作业</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是高楼。</p>
<p>在性能项目中，性能数据是非常重要的输入资源。但是我经常看到有人拿着少得可怜的数据，来做比较大的压力，这显然不符合真实的场景，虽然拿到的结果很好看，但并不会得到什么有价值的结果。所以，今天我们就来讲一下性能场景中的数据到底应该做成什么样子。</p>
<p>在 RESAR 性能工程中，场景里使用的数据需要满足两个方面：</p>
<ol>
<li>第一，数据要符合真实环境中的数据分布，因为只有这样，我们才能模拟出相应的 IO 操作；</li>
<li>第二，要符合真实用户输入的数据，以真正模拟出真实环境中的用户操作。</li>
</ol>
<p>而这两个方面分别对应着两类数据：铺底数据和参数化数据。我们先来看铺底数据。</p>
<h2 id="铺底数据">铺底数据</h2>
<p>在通常的线上系统架构中，系统中用到的数据分为两部分：静态数据（图中红色点）和动态数据（图中绿色点），这也是我们在性能场景中需要存入的铺底数据。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/af12ce8412fddb1973d680485423bd44.png" alt=""></p>
<p>从这个简单的结构图中不难看出，如果没有铺底数据，那就相当于是一个空系统。但是在生产环境中，这个系统肯定不会是空的，所以要有足够的数据在里面。如果数据不真实，我们就无法模拟出生产上有真实数据的场景，比如应用的内存占用、数据库 IO 能力、网络吞吐能力等。</p>
<p>其中，对于静态数据而言，我们最容易出现的问题是，一想到它占的网络带宽大，就觉得要用 CDN 了；或者是觉得不模拟静态数据，就是不符合真实场景，不支持我们的优化结果了。其实，数据放在哪里，怎么做最合理，怎么做成本最低，这些都需要综合考虑，并不是一味跟风，别人怎么做我们就要怎么做。</p>
<p>我曾经看到有的官方门户网站明明没几个流量，却在做技术规划的时候，非要把零星的几个图片放到 CDN 上去，以显示自己设计的架构有多先进。</p>
<p>我也经常看到一些企业认为网站上的图片很重要，出于不懂技术又要寻找安全感的逻辑，非要把图片都放到自己的服务器里。本来图片就很大，一张有 3～4M，用户一访问，自然就会吵吵着慢。</p>
<p>像这两种极端都不可取。要知道，当外行指使内行干活的时候，基本上没什么好结果，因为有些外行觉得只要压力发起就可以了，在细节上根本不在乎结果会怎么样。在我看来，处理这样问题的最合理的方式是先分析业务逻辑，再判断技术架构怎么实现。</p>
<p>我们知道，静态数据通常有两个可以存放的地方，一个是服务端的 Web 层，另一个是 CDN。对于大系统而言，流量大，网络带宽自然就要求得多。在这种情况下，数据必然要放 CDN，你也没有其他选择（当然了，你可以选择不同的 CDN 厂商）。</p>
<p>对于一些小的业务系统，由于用的人并不多，整体网络流量要求也少，那我们就可以把静态数据直接放到负载均衡服务器（比如 Nginx）或应用服务器中去。用户访问一次之后，后续的访问直接走本地缓存就可以了，对系统的压力也不会产生多大的影响。</p>
<p>静态数据讲完了，我们再来看动态数据，这就需要我们好好分析一下了，因为有些动态数据是可以放到 CDN 中的。</p>
<p>还是前面那张图，在我们不用任何预热加载的情况下，这些动态数据都是存放在数据库中的。当我们使用预热加载时，这些数据就会转到缓存中去（当然，这也取决于架构设计和代码实现），变成下图中这样：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/21761a202cd1ceeecb89bb0be27e6876.png" alt=""></p>
<p>所以按照这样的逻辑，真实场景中业务操作的数据量实际有多少，我们就要模拟出多少，不然会出现一些问题。当模拟数据量与实际数据量差别较大时，会对数据库、缓存等造成不同的影响。下面我列出了五点，为你具体分析一下。</p>
<ol>
<li><strong>对数据库压力的区别</strong></li>
</ol>
<p>假设线上系统中有 100 万的用户量，而我们在做压力测试时，由于没有生产数据，造数据又比较麻烦，所以就直接使用 1000 条甚至更低的用户量来做性能场景。那一个表里有 100 万条数据和 1000 条数据的差别是什么呢？我们来实际操作一下。</p>
<p>在这里，有一个前提条件：同样的硬件环境，同样的数据库，同样的表结构，同样的索引，只是两张表的数据不同。</p>
<p>两条 SQL 如下：</p>
<p>select * from ob_tuning.temp1_1000 where id = &lsquo;3959805&rsquo;;<br>
select * from ob_tuning.temp2_100w where id = &lsquo;3959805&rsquo;;</p>
<p>因为表内的数据量不同，所以结果如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/b80cac7bf2ee1140aa5afe19f3943fbc.png" alt=""></p>
<p>可以看到，查询时间一个是 19ms，一个是 732ms。我们不妨再来看一下表的操作细节。</p>
<p>第一个表（用户量为 1000）的操作细节：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/2d93b903d43d37355e619c92dee62253.png" alt=""></p>
<p>第二个表（用户量为 100 万）的操作细节：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/9d6ed9312cd186fe79a5384a69237c11.png" alt=""></p>
<p>这里我们只需要对比“executing”这一行就能看到明显的差距，它告诉我们当执行这个语句时，需要的 CPU 时间明显因为数据量的增加而增加了。所以我们不难发现，如果你没有足够的铺底数据放在性能场景中，那一开始便注定了悲剧的结果。</p>
<ol>
<li><strong>缓存的区别</strong></li>
</ol>
<p>数据量的多少在缓存中有很明显的区别，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/3865e4fc8066984427e79f65186e7742.png" alt=""></p>
<p>也就是说，场景中用的数据量越多，缓存必然要求越大。</p>
<ol>
<li><strong>压力工具使用的区别</strong></li>
</ol>
<p>压力工具中使用的数据多少，不仅影响着压力工具本身需要的内存，同时也影响着性能场景的执行结果。这一点，我们会在后面的课程中详细讲到。</p>
<ol>
<li><strong>网络的区别</strong></li>
</ol>
<p>其实不同的数据量，不管是走缓存，还是数据库，对客户端和服务器之间的网络消耗都是差不多的。只要不是缓存在客户那边，都是要走到服务器里转一圈的。所以我们认为，数据量是多还是少，对客户端和服务器之间的网络的压力没有什么区别。如果你用的是 CDN，那可以做另外的考虑。</p>
<ol>
<li><strong>应用的区别</strong></li>
</ol>
<p>如果不是在应用中直接缓存数据，我们也认为对应用没什么区别，反正不管是什么样的请求过来，都是要到缓存或数据库中去取数据的，应用的 Self Time 不会有什么差别，方法依旧要执行。但是，如果你的应用是直接在应用的缓存中存数据的，那就有区别了，同样也是数据量越大，对内存的要求就越大。</p>
<p>基于以上几点，<strong>我们可以看到</strong> <strong>有两个</strong> <strong>比较重要</strong> <strong>的</strong> <strong>环节：数据库</strong> <strong>和</strong> <strong>缓存</strong> <strong>，</strong> <strong>这是直接的影响。</strong></p>
<p>那间接的影响有什么呢？比如说，数据在数据库中执行得慢了，在同步调用的应用中必然需要更多的应用线程来处理。</p>
<p>我们假设有一个 100TPS 的系统，先忽略其他时间，只看数据库时间。如果数据库执行需要 10ms，那应用只需要一个线程就能处理完了。如果数据库需要 100ms，而我们仍然想达到 100TPS，那应用就得有 10 个线程来同时处理。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/fb2c343a32fc2237d1a20bc6700d3afe.png" alt=""></p>
<p>与此同时，整个链路上的所有线程、队列、超时等都会因为受到数据量的影响而产生大的变化。所以，我们要想模拟出生产时候的样子，在铺底数据上一定不能含糊。</p>
<h2 id="参数化数据">参数化数据</h2>
<p>有了前面铺底数据的分析，我们在做参数化的时候就会明确很多。不过，在场景中应该用多少量的数据，是性能场景中最容易出问题的一个环节。</p>
<p>参数化数据量应该是多少，取决于场景运行多长时间。而在场景运行中，我们通常要用到两类数据：唯一性数据和可重复使用的数据。</p>
<p>对于唯一性数据（比如用户数据）来说，我们需要使用多少参数化数据是非常容易计算的。比如一个运行半小时的场景，TPS 如果是 100 的话，那就需要 18 万的数据量，计算过程如下：</p>
<p>数据量=30min×60s×100TPS=18w</p>
<p>对于可重复使用的数据量，我们需要分析真实业务场景中是如何重复的，比如说电商系统中商品的数据量，我们在做参数化的时候就可以重复，毕竟多个人是可以同时购买同一个商品的。我们假设平均有 1000 个用户在 10 个商品中，那当我们有 18 万个用户时，就需要 1800 个商品：</p>
<p>商品数量=18w用户÷1000用户×10商品=1800商品</p>
<p>上述就是唯一性数据量和可重复使用数据量的计算方式。</p>
<p>你可能会问，如果参数化数据量太大，在压力工具中处理不了怎么办？比如说我们在用 JMeter 处理文件参数化数据时，如果参数化文件太长，会导致 JMeter 消耗更多的时间。其实像这种参数化数据量要求多的情况，我们可以采用连接远程缓存（比如 Redis）或数据库（比如 MySQL）的方式来做参数化。</p>
<ol>
<li><strong>连接 Redis 做参数化</strong></li>
</ol>
<p><strong>方法一</strong>：直接在 JMeter 中写 Beanshell 连接 Redis 取数据。</p>
<p>import redis.clients.jedis.Jedis;<br>
//连接本地的 Redis 服务<br>
Jedis jedis = new Jedis(&ldquo;172.16.106.130&rdquo;,30379);<br>
log.info(&ldquo;服务正在运行：&quot;+jedis.ping());<br>
String key = vars.get(&ldquo;username&rdquo;);<br>
String value = vars.get(&ldquo;token&rdquo;);<br>
vars.put(&ldquo;tokenredis&rdquo;,jedis.get(key));</p>
<p><strong>方法二</strong>：使用 Redis Data Set 组件。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/b7846b0601b26c5d0938894f6f890e93.png" alt=""></p>
<p>这两种方式都可以用 Redis 做参数化的数据源。</p>
<ol>
<li><strong>连接 MySQL 做参数化</strong></li>
</ol>
<p><strong>第一步</strong>：创建一个 JDBC Connection Configuration。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/7f6377623a1d5d416bc43bf9a2be1ad8.png" alt=""></p>
<p>同时，配置好连接信息，比如用户名密码等：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/93753ee30f8c6d53724bc7634a8512d9.png" alt=""></p>
<p><strong>第二步</strong>：创建一个 JDBC Request。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/08d7bef891d05f2d30b0af4ba42ca0e4.png" alt=""></p>
<p>用 JDBC Request 把数据取回来：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/d60730a7123745cd14e98a3650eaf9a0.png" alt=""></p>
<p><strong>第三步</strong>：用 ${user_name}引用参数。</p>
<p>完成上述三步，我们就实现了用数据库的方式做参数化。</p>
<p>知道了 RESAR 性能工程中需要什么样的数据后，我们接下来聊一下如何造数据。</p>
<h2 id="如何造数据">如何造数据？</h2>
<p>因为我们这个项目中的电商平台是开源的，数据库也完全是空的，系统中没有任何的数据。所以，我们虽然只是实现了电商的主流程，但需要的数据量仍然不少。这些数据包括：</p>
<ol>
<li>用户数据；</li>
<li>地址数据；</li>
<li>商品数据；</li>
<li>订单数据。</li>
</ol>
<p>下面我们具体考虑一下数据量应该怎么设置。</p>
<p>根据我们第 5 讲中的性能方案，登录 TPS 如果是每秒 150，并且如果按容量场景的需求，在场景连续递增时，大概在 20 分钟内（这是一个经验值，在具体的场景执行中也会有变化）会递增到最大值，然后再执行 10 分钟，也就是说总时间大概为 30 分钟。</p>
<p>但是因为场景是递增的，一开始我们并没有要求达到 150TPS，同时登录场景 TPS 最大值能达到多少，我们现在也没法预知。根据经验来看的话，登录的 TPS 在当前的硬件环境中，就算是不走缓存，达到三、四百应该是没有多大问题的。</p>
<p>如果按最大 400TPS 来算，跑半个小时，需要的数据量就是 54 万，而我们造出来的用户量要远远大于这个量级。这里我们就先造 200 万的用户量，因为地址的数据量肯定大于用户的数据量，所以会多于 200 万。</p>
<p>我们先查一下当前的数据库中有多少数据量，再确定要造多少数据。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/59aac845d861c2446e632a5ef6d71fec.png" alt=""></p>
<p>这个数据量级明显是不够的，太少了。下面我们来看看怎么造出那么多的数据量。</p>
<p>我们造的数据主要分为两种：用户数据和订单数据。</p>
<ol>
<li><strong>登陆用户</strong></li>
</ol>
<p>对于登陆用户数据而言，我们要先了解表结构，因为造出来的数据只有符合业务逻辑才能使用。我们先看一下用户表结构和数据。</p>
<p>用户表：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/dc09714d836aeb6dd65e29d9a8523a29.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/5e0eff48ba580469d1b5a8f3f9e916f1.png" alt=""></p>
<p>地址表：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/86e9931af89e96195a809859590d8f3e.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/f0a739c037cb84a2f2b3f1765afe7afc.png" alt=""></p>
<p>根据我的经验，<strong>造数据时不要往数据库里直接写存储过程插数据，除非你非常清楚表之间的关系，并且存储过程又写得非常溜</strong>。否则你会把数据库弄得一团乱，最后不得不在数据库的表里改数据，这是非常被动的做法。在这里，我推荐你使用接口直接调用来造数据，这个操作比较简单，也比较安全。</p>
<p>如果你想用代码来造数据，那就需要做下面这些分析。</p>
<p>在这里，我们的用户表和地址表之间是有对应关系的，你可以通过下面这段代码查看到，地址表中的 MemberID 就是用户 ID 号。</p>
<p>@Override<br>
public int add(UmsMemberReceiveAddress address) {<br>
UmsMember currentMember = memberService.getCurrentMember();<br>
address.setMemberId(currentMember.getId());<br>
return addressMapper.insert(address);<br>
}</p>
<p>其实造用户数据就是实现注册流程。你可以先分析下用户注册的代码，直接把其中的注册代码部分拿过来用就行了。具体调用代码如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/424093beaef0953b710c5f4eb0816b2d.png" alt=""></p>
<p>看到这里，你可能会想，造数据需要关心注册流程吗？其实如果我们是调接口造数据，就不需要；但如果写代码开启了多线程来造数据，我们就需要了解接口之间的调用关系了。</p>
<p>下面我们截出中间一部分来分析它们的调用关系：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/cff9b2b0b7dd6d4dc155719b15bb9ac8.png" alt=""></p>
<p>因为注册用户表中的密码都是加密的，所以我们可以通过注册用户实现类代码，如下:</p>
<p>@Override<br>
public void register(String username, String password, String telephone, String authCode) {<br>
&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.<br>
//获取默认会员等级并设置<br>
UmsMemberLevelExample levelExample = new UmsMemberLevelExample();<br>
levelExample.createCriteria().andDefaultStatusEqualTo(1)  ;<br>
List<UmsMemberLevel> memberLevelList = memberLevelMapper.selectByExample(levelExample);<br>
if (!CollectionUtils.isEmpty(memberLevelList)) {<br>
umsMember.setMemberLevelId(memberLevelList.get(0).getId());<br>
}<br>
//插入用户<br>
memberMapper.insert(umsMember);<br>
umsMember.setPassword(null);<br>
}</p>
<p>了解了上面的内容之后，我们就可以直接写一段代码来造用户数据了，具体请见：《造用户代码.java》</p>
<p>有了用户数据，我们还需要下单用户的地址等详细信息，只有这样才能完成下单。所以，接下来我们就开始分析怎么造出可以下单的地址数据。</p>
<ol>
<li><strong>用户地址</strong></li>
</ol>
<p>首先，我们要根据用户地址资源路径找到 Controller 层，查看用户地址的代码调用关系，如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/d4a28ea8332b5ec96e46d5c070ae6fde.png" alt=""></p>
<p>然后找到用户地址的关键代码：</p>
<p>@Override<br>
public int add(UmsMemberReceiveAddress address) {<br>
UmsMember currentMember = memberService.getCurrentMember();<br>
address.setMemberId(currentMember.getId());<br>
//插入地址<br>
return addressMapper.insert(address);<br>
}</p>
<p>从这段代码中，我们可以观察到这几个信息：</p>
<ol>
<li>调用地址接口需要用户登陆态，通过登陆态来解析用户 ID 号；</li>
<li>用户 ID 号是地址代码中的 MemberID 号；</li>
<li>用户 ID 号是自增加。</li>
</ol>
<p>具体参考请见《造用户地址代码.java》。</p>
<p>通过上面的代码编写，然后再开启 Java 线程池与多线程，我们就可以把基础数据快速造完了。下面是造用户地址数据的时间记录（每台电脑配置不一样，用的数据也许会有差异）：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/f5694dcdaf9022861426010504c82dad.png" alt=""></p>
<p>通过以上手段，我们最后造出如下数据量：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/100d9d1d661d2a443e54f81870a173ba.png" alt=""></p>
<p>表中的订单数据会在做基准场景时补充上去。等这些数据量都有了，我们在容量场景中就有了足够的铺底数据。</p>
<h2 id="总结">总结</h2>
<p>在这节课里，我们一起学习了性能场景中的数据到底应该做成什么样子。对于造数据而言，方法有很多，我们不用拘泥于某种造数据的手段，只要能快速造出足够的数据量就好。在 RESAR 性能工程中，性能场景需要两类数据：铺底数据和参数化数据。其中，铺底数据需要满足这三个条件：</p>
<ol>
<li>一定要造出符合生产量级的数据量；</li>
<li>数据量要真实模拟出生产的数据分布；</li>
<li>数据要真实可用。</li>
</ol>
<p>参数化数据需要满足这两个条件：</p>
<ol>
<li>参数化数据量要足够；</li>
<li>要符合真实用户的输入数据。</li>
</ol>
<p>有了以上这些知识，我们就不会在造数据时出现混乱的情况了。</p>
<h2 id="课后作业">课后作业</h2>
<p>这就是今天的全部内容，最后给你留两个思考题吧：</p>
<ol>
<li>为什么要造出符合生产量级的数据量？</li>
<li>为什么参数化时要用符合真实用户的输入数据？</li>
</ol>
<p>记得在留言区和我讨论、交流你的想法，每一次思考都会让你更进一步。</p>
<p>如果这节课让你有所收获，也欢迎你分享给你的朋友，共同学习进步。我们下一讲再见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/">高楼的性能工程实战课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2/07__%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E8%A1%8C%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">07__行锁功过：怎么减少行锁对性能的影响？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/07__%E6%80%A7%E8%83%BD%E5%A5%BD%E6%95%88%E7%8E%87%E9%AB%98%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%E9%80%9A%E8%AE%AF%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/">
            <span class="next-text nav-default">07__性能好，效率高的一对多通讯该如何实现？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
