<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>18__购物车信息确定订单：为什么动态参数化逻辑非常重要？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是高楼。
我们今天来看一下购物车信息确定订单这个接口的性能怎么样，有哪些需要优化的地方。
在这节课中，我将给你展示如何进行方法级的跟踪，来判断参数的问题。而这个参数，并不是我们这个接口直接用到的，它有不同的使用层次。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/18__%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%BF%A1%E6%81%AF%E7%A1%AE%E5%AE%9A%E8%AE%A2%E5%8D%95%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%E5%8C%96%E9%80%BB%E8%BE%91%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/18__%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%BF%A1%E6%81%AF%E7%A1%AE%E5%AE%9A%E8%AE%A2%E5%8D%95%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%E5%8C%96%E9%80%BB%E8%BE%91%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="18__购物车信息确定订单：为什么动态参数化逻辑非常重要？">
  <meta property="og:description" content="你好，我是高楼。
我们今天来看一下购物车信息确定订单这个接口的性能怎么样，有哪些需要优化的地方。
在这节课中，我将给你展示如何进行方法级的跟踪，来判断参数的问题。而这个参数，并不是我们这个接口直接用到的，它有不同的使用层次。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="高楼的性能工程实战课">

  <meta itemprop="name" content="18__购物车信息确定订单：为什么动态参数化逻辑非常重要？">
  <meta itemprop="description" content="你好，我是高楼。
我们今天来看一下购物车信息确定订单这个接口的性能怎么样，有哪些需要优化的地方。
在这节课中，我将给你展示如何进行方法级的跟踪，来判断参数的问题。而这个参数，并不是我们这个接口直接用到的，它有不同的使用层次。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5110">
  <meta itemprop="keywords" content="高楼的性能工程实战课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="18__购物车信息确定订单：为什么动态参数化逻辑非常重要？">
  <meta name="twitter:description" content="你好，我是高楼。
我们今天来看一下购物车信息确定订单这个接口的性能怎么样，有哪些需要优化的地方。
在这节课中，我将给你展示如何进行方法级的跟踪，来判断参数的问题。而这个参数，并不是我们这个接口直接用到的，它有不同的使用层次。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">18__购物车信息确定订单：为什么动态参数化逻辑非常重要？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5110 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#场景运行数据">场景运行数据</a></li>
        <li><a href="#看架构图">看架构图</a></li>
        <li><a href="#拆分响应时间">拆分响应时间</a></li>
        <li><a href="#第一阶段">第一阶段</a>
          <ul>
            <li><a href="#全局分析">全局分析</a></li>
            <li><a href="#定向分析">定向分析</a></li>
          </ul>
        </li>
        <li><a href="#第二阶段">第二阶段</a>
          <ul>
            <li><a href="#场景运行数据-1">场景运行数据</a></li>
            <li><a href="#拆分响应时间-1">拆分响应时间</a></li>
            <li><a href="#全局分析-1">全局分析</a></li>
            <li><a href="#定向分析-1">定向分析</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#课后作业">课后作业</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是高楼。</p>
<p>我们今天来看一下购物车信息确定订单这个接口的性能怎么样，有哪些需要优化的地方。</p>
<p>在这节课中，我将给你展示如何进行方法级的跟踪，来判断参数的问题。而这个参数，并不是我们这个接口直接用到的，它有不同的使用层次。</p>
<p>直接的参数化我们都能理解，对吧。但是当一个参数产生新的数据，而新的数据又会在后续的动作中用到时，你就得注意了，因为我们有可能在第一层数据中没有发现问题，但是在后续的动作中会遇到问题。所以，我们一定要关注参数化的变化，也就是动态的参数化的数据。</p>
<p>此外，在这节课中，我还将带你一起来看看在应用有多个节点的情况下，某个节点消耗资源过多导致的复杂问题该怎么处理。</p>
<p>话不多说，我们开始今天的分析吧！</p>
<h2 id="场景运行数据">场景运行数据</h2>
<p>对于购物车信息确定订单这个接口，我们第一次运行的性能场景结果如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/b13d072c36da6f3c766cefe05602ec4d.png" alt=""></p>
<p>在图中，响应时间随着压力的增加而增加，而 TPS 只到了 160 多，还是有点低了，我们现在就得考虑把 TPS 提升。</p>
<p>注意，<strong>这是一个典型的 TPS 不高，响应时间不断增加的性能问题。</strong></p>
<p>按照 RESAR 性能分析逻辑，我们看一下这个接口的架构图。</p>
<h2 id="看架构图">看架构图</h2>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/1f1abbcc570eebe7031a2ee0eae9fb9e.png" alt=""></p>
<p>可以看到，这个接口涉及到的服务比较多，架构图也比之前其他接口的要复杂一些。</p>
<p>紧接着，我们就来拆分响应时间。</p>
<h2 id="拆分响应时间">拆分响应时间</h2>
<ol>
<li>Gateway：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/7044c688405cc5e712b525abb3168985.png" alt=""></p>
<ol>
<li>Order：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/59f26c368cb85cb31a1e6a351e5dda3a.png" alt=""></p>
<ol>
<li>Member：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/3e307e37902d6407faaaef7051c28a05.png" alt=""></p>
<ol>
<li>Cart：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/049cc26d85ba8b5f52c377a9dc6f839b.png" alt=""></p>
<ol>
<li>Portal：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/b0aa5c18151de45527f8980c5fad3426.png" alt=""></p>
<p>从上面的时间拆分来看，Cart 消耗了最长的时间。所以，我们先分析 Cart。</p>
<p>我们再顺手点一下 Cart 和 MySQL 之间的时间消耗，看看是什么情况：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/577a7ddbe560c6ad08cff6de455f4091.png" alt=""></p>
<p>这个 Cart 和 MySQL 之间的时间看起来不长，那我们就不用考虑数据库的 SQL 时间消耗了。</p>
<p>接下来，我们就来分析响应时间长的 Cart 服务。</p>
<h2 id="第一阶段">第一阶段</h2>
<h3 id="全局分析">全局分析</h3>
<p>按照惯例，我们来看一下 worker 层面的资源消耗情况：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/1dbcf76ecb80e6280cd6cddfaf49fa80.png" alt=""></p>
<p>从上图来看，worker-3 上消耗的资源较多。那我们就来查看一下 worker-3 上有什么服务。</p>
<p>[root@k8s-master-2 ~]# kubectl get pods -o wide | grep k8s-worker-3<br>
cloud-nacos-registry-685b8957d7-vskb6       1/1     Running     0          2d11h   10.100.69.199    k8s-worker-3   <none>           <none><br>
cloud-redis-7f7db7f45c-t5g46                2/2     Running     0          2d8h    10.100.69.196    k8s-worker-3   <none>           <none><br>
elasticsearch-master-2                      1/1     Running     0          3h28m   10.100.69.209    k8s-worker-3   <none>           <none><br>
svc-mall-cart-558d787dc7-g6qgh              1/1     Running     0          2d11h   10.100.69.201    k8s-worker-3   <none>           <none><br>
svc-mall-order-fbfd8b57c-kbczh              1/1     Running     0          2d11h   10.100.69.202    k8s-worker-3   <none>           <none><br>
svc-mall-portal-846d9994f8-m7jbq            1/1     Running     0          38h     10.100.69.207    k8s-worker-3   <none>           <none><br>
svc-mall-search-c9c8bc847-h7sgv             1/1     Running     0          161m    10.100.69.210    k8s-worker-3   <none>           <none><br>
[root@k8s-master-2 ~]#</p>
<p>可以看到，worker-3 上有 8 个服务，哪个服务消耗的资源最多呢？现在我们进入 worker-3，查看下 top：</p>
<p>[root@k8s-worker-3 ~]# top<br>
top - 01:51:35 up 2 days, 12:18,  2 users,  load average: 19.48, 18.40, 17.07<br>
Tasks: 319 total,   1 running, 318 sleeping,   0 stopped,   0 zombie<br>
%Cpu0  : 68.6 us,  6.4 sy,  0.0 ni, 19.9 id,  0.0 wa,  0.0 hi,  5.1 si,  0.0 st<br>
%Cpu1  : 66.7 us,  5.8 sy,  0.0 ni, 22.8 id,  0.0 wa,  0.0 hi,  4.8 si,  0.0 st<br>
%Cpu2  : 66.4 us,  6.1 sy,  0.0 ni, 22.7 id,  0.0 wa,  0.0 hi,  4.7 si,  0.0 st<br>
%Cpu3  : 65.7 us,  5.4 sy,  0.0 ni, 23.6 id,  0.0 wa,  0.0 hi,  5.4 si,  0.0 st<br>
%Cpu4  : 66.6 us,  5.7 sy,  0.0 ni, 22.0 id,  0.0 wa,  0.0 hi,  5.7 si,  0.0 st<br>
%Cpu5  : 67.6 us,  5.8 sy,  0.0 ni, 22.5 id,  0.0 wa,  0.0 hi,  4.1 si,  0.0 st<br>
KiB Mem : 16265992 total,  2525940 free,  7015104 used,  6724948 buff/cache<br>
KiB Swap:        0 total,        0 free,        0 used.  8848464 avail Mem</p>
<p>PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                     <br>
32216 root      20   0 8878548 658820  16980 S 280.5  4.1 375:31.82 java -Dapp.id=svc-mall-cart -javaagent:/opt/skywalking/agent/skywalking-agen+<br>
32589 root      20   0 8839408 589196  15892 S  84.1  3.6 171:16.88 java -Dapp.id=svc-mall-order -javaagent:/opt/skywalking/agent/skywalking-age+<br>
24119 root      20   0 8798548 549804  15892 S  65.9  3.4 115:52.74 java -Dapp.id=svc-mall-portal -javaagent:/opt/skywalking/agent/skywalking-ag+<br>
1089 root      20   0 2438956 105708  37776 S   6.3  0.6 248:21.71 /usr/bin/kubelet &ndash;bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.co+<br>
5470 root      20   0 1154816  14992   1816 S   3.6  0.1  20:15.93 redis-server 0.0.0.0:6379</p>
<p>从以上数据来看，的确是 Cart 服务消耗的 CPU 比较高。不过，它<strong>还没有把 6 个 CPU 都用完</strong>，这一点我们要记一下。</p>
<p>下面开始定向分析。</p>
<h3 id="定向分析">定向分析</h3>
<p>既然 Cart 服务消耗的 CPU 多，那我们当然要看一下 Cart 中的线程都在干啥。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/018606497f1a5ad22720f2a481a2b740.png" alt=""></p>
<p>这些线程状态基本都在绿色的 Runnable 状态，看起来都比较繁忙，有可能是因为线程数配置的太低了，我们查看下配置：</p>
<p>server:<br>
port: 8086<br>
tomcat:<br>
accept-count: 1000<br>
threads:<br>
max: 20<br>
min-spare: 5<br>
max-connections: 500</p>
<p>知道了 Spring Boot 内置的 Tomcat 线程数配置，我们拆分一下在 Cart 上正在执行的方法，看看我们的定位方法是不是合理：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/6117ca8e533c9c61b8d917bed0047e77.png" alt=""></p>
<p>看这张图的时候，你要注意消耗时间长的位置，也就是图中右侧线段比较长的地方。这里面有两个环节的问题：</p>
<ol>
<li>MySQL 的执行时间长。你要注意哦，虽然这里的 MySQL/JDBI/PreparedStatement/execute 并没有消耗很长的时间，但是它的下一步 Balance/Promotion/Cart/CartPromotion 消耗的时间是长的；</li>
<li>Promotionnew 方法本身的时间长。</li>
</ol>
<p>由于慢的节点和 MySQL 有关，我们创建一个，mysqlreport 来看 MySQL 整体的监控数据：</p>
<p>__ Connections _________________________________________________________<br>
Max used          152 of  151      %Max: 100.66<br>
Total             540     0.0/s</p>
<p>原来是连接用完了！我们赶紧改一下，从 151 改到 500。</p>
<p>不过，重测之后响应时间还是没有变化，那我们就只能接着跟踪 Cart 上的方法了。</p>
<h4 id="方法级跟踪">方法级跟踪</h4>
<p>于是，我们不得不来到方法级跟踪，看一下我们关注的方法 Promotionnew 慢在哪里。</p>
<p>由上面那张调用视图，我们可以编写下面这样的跟踪语句：</p>
<p>trace -E com.dunshan.mall.cart.controller.CartItemController listPromotionnew -n 5 -v &ndash;skipJDKMethod false &lsquo;1==1&rsquo;</p>
<p>然后得到了下面这个结果：</p>
<p><code>---ts=2021-01-16 15:08:58;thread_name=http-nio-8086-exec-34;id=f8;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@56887c8f   </code>&mdash;[97.827186ms] com.dunshan.mall.cart.service.imp.CartItemServiceImpl$$EnhancerBySpringCGLIB$$ac8f5a97:listPromotion()<br>
<code>---[97.750962ms] org.springframework.cglib.proxy.MethodInterceptor:intercept() #57   </code>&mdash;[97.557484ms] com.dunshan.mall.cart.service.imp.CartItemServiceImpl:listPromotion()<br>
+&mdash;[72.273747ms] com.dunshan.mall.cart.service.imp.CartItemServiceImpl:list() #166<br>
+&mdash;[0.003516ms] cn.hutool.core.collection.CollUtil:isNotEmpty() #172<br>
+&mdash;[0.004207ms] java.util.List:stream() #173<br>
+&mdash;[0.003893ms] java.util.stream.Stream:filter() #57<br>
+&mdash;[0.003018ms] java.util.stream.Collectors:toList() #57<br>
+&mdash;[0.060052ms] java.util.stream.Stream:collect() #57<br>
+&mdash;[0.002017ms] java.util.ArrayList:<init>() #177<br>
+&mdash;[0.003013ms] org.springframework.util.CollectionUtils:isEmpty() #179<br>
`&mdash;[25.152532ms] com.dunshan.mall.cart.feign.CartPromotionService:calcCartPromotion() #181</p>
<p>可以看到，在我们跟踪的方法 com.dunshan.mall.cart.service.imp.CartItemServiceImpl:listPromotion() 中，有两处 listPromotion 和 calcCartPromotion 时间消耗较大，分别是：</p>
<ol>
<li>com.dunshan.mall.cart.service.imp.CartItemServiceImpl:list()</li>
<li>com.dunshan.mall.cart.feign.CartPromotionService:calcCartPromotion()</li>
</ol>
<h4 id="跟踪-list-函数">跟踪 List 函数</h4>
<p>我们在 Arthas 中执行 trace 跟踪语句如下：</p>
<p>trace com.dunshan.mall.cart.service.imp.CartItemServiceImpl list -v -n 5 &ndash;skipJDKMethod false &lsquo;1==1&rsquo;</p>
<p>然后得到这样的结果：</p>
<p><code>---ts=2021-01-16 15:19:45;thread_name=http-nio-8086-exec-65;id=23ce;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@56887c8f   </code>&mdash;[70.158793ms] com.dunshan.mall.cart.service.imp.CartItemServiceImpl:list()<br>
+&mdash;[0.003501ms] com.dunshan.mall.model.OmsCartItemExample:<init>() #150<br>
+&mdash;[0.002642ms] com.dunshan.mall.model.OmsCartItemExample:createCriteria() #151<br>
+&mdash;[0.002932ms] com.dunshan.mall.model.OmsCartItemExample$Criteria:andDeleteStatusEqualTo() #57<br>
+&mdash;[0.00304ms] com.dunshan.mall.model.OmsCartItemExample$Criteria:andMemberIdEqualTo() #57<br>
`&mdash;[70.078976ms] com.dunshan.mall.mapper.OmsCartItemMapper:selectByExample() #152</p>
<p>在一阵无聊的 trace 之后，看到一个 select 语句消耗时间较长，这个 select 语句是：</p>
<p>select id, product_id, product_sku_id, member_id, quantity, price, product_pic, product_name,     product_sub_title, product_sku_code, member_nickname, create_date, modify_date, delete_status,     product_category_id, product_brand, product_sn, product_attr       from oms_cart_item                 WHERE (  delete_status = ?                                                            and member_id = ? )</p>
<p>一个简单的 select 语句，怎么会耗时这么久呢？我们先不管为什么会这样，先来看看这个 oms_cart_item 的数据有多少。我连上数据库后一查，发现在 oms_cart_item 里面有 10612 条数据，这个数据量并不大。</p>
<p>此外，我还查看了一下索引，也是有的，并且执行计划也走到了索引这里。那为什么会慢呢？到这里，我们得考虑一下是不是和数据量有关了。所以，我们来看看这个 select 语句究竟查出了多少条数据。</p>
<p>在我补全 SQL 后一查，发现一个 member_id 对应 500 多条记录，这是一个人一次买了 500 个东西？</p>
<p>既然在购物车信息里，同一个人有这么多记录，那一定是在商品加入购物车时加进去的。而要往一个人的购物车里加东西，显然是在性能脚本执行的过程中添加，因为每个用户的购物车一开始都是空的。所以，我们要去查一下商品加入购物车的脚本是怎么回事。</p>
<p>商品加入购物车的脚本很简单，就是一个 post，加上商品 ID，在 HTTP 协议的请求头里面有一个 Token 来标识是哪个用户。</p>
<p>在这里，我们要查的就是 token 有没有用重，JMeter 中的 Token 参数化配置如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/98df27264474ce0ea387b8ff16003275.png" alt=""></p>
<p>看起来挺好，我们在这里设计了不重用数据，所以在设置上 Token 不会被重用。那么，只有一种可能，就是 Token 重了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/8d5ecc4ad08bca5c4615ecd1e3027a33.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/6ad6bc6a9da2e4b7a7c97e036110d47f.png" alt=""></p>
<p>在随机检查了几条 Token 之后，我发现有大量的 Token 重复。这也就解释了，为什么我们会在一个人的购物车里看到那么多商品数据。</p>
<p>可是，这个逻辑就有问题了。你想想，我们设置了参数化中数据不重复使用，但实际上确实有大量的 Token 被重用，这就说明 Token 的参数化文件本身就重复了。</p>
<p>那怎么办呢？我们只有把所有的 Token 全部清掉，让 Token 数据在商品加入购物车的时候不会被重用，以此来避免在一个人的购物车中加入太多商品的情况。</p>
<p>接着怎么办？只有一招了，就是把所有的数据都清掉，然后用所有的用户创建合理的购物车数据。于是，我在这里又花了几个小时，造出了 130 多万数据。现在，我们再回归一下场景：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/c1970af6e05fe7fb65b2e18de1d510e4.png" alt=""></p>
<p>你看，TPS 增加到了 300！</p>
<p>本来这是一个美好到可以喝下午茶的结果，然而……天不随人愿，我在场景持续执行的过程中，又发现了问题，这让我们不得不开启第二阶段的分析。</p>
<h2 id="第二阶段">第二阶段</h2>
<h3 id="场景运行数据-1">场景运行数据</h3>
<p>是什么问题呢？我在压力运行的数据中，竟然看到了这种 TPS 曲线：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/a587abe482caf38a9729421597dd0c10.png" alt=""></p>
<p>你看，TPS 相当规律地往下掉，不仅会掉下去，而且还会恢复回去，形成一个明显的锯齿状，并且这锯齿还挺大。</p>
<p>怎么办？根据高老师的思路，现在我们就得按照 RESAR 性能分析逻辑来收拾这个问题了。我们在前面已经看过架构图，所以，现在直接来拆分响应时间。</p>
<h3 id="拆分响应时间-1">拆分响应时间</h3>
<ol>
<li>Gateway：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/d70bebdff6c1d17eecae6dfe40727e92.png" alt=""></p>
<ol>
<li>Order：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/aa894e9caf26ca33a004cfbce724e98c.png" alt=""></p>
<ol>
<li>Cart：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/bd6355153be901fa47164c2bcb685654.png" alt=""></p>
<ol>
<li>Portal：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/3396ce9d77ecdc47ef7f97f6991ae1ad.png" alt=""></p>
<p>从上面的数据来看，似乎每一层都有时间消耗，性能都不怎么样。</p>
<h3 id="全局分析-1">全局分析</h3>
<p>那我们就查看下当前的全局监控数据，可以看到 worker-3 上的 CPU 消耗最多：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/f8f269c18284947fad3c9a737233b524.png" alt=""></p>
<p>因此，我们来查一下 worker-3 上有哪些 Pod：</p>
<p>[root@k8s-master-3 ~]# kubectl get pods -o wide | grep k8s-worker-3<br>
cloud-nacos-registry-685b8957d7-vskb6       1/1     Running     0          3d7h    10.100.69.199    k8s-worker-3   <none>           <none><br>
cloud-redis-7f7db7f45c-t5g46                2/2     Running     1          3d4h    10.100.69.196    k8s-worker-3   <none>           <none><br>
elasticsearch-master-2                      1/1     Running     0          23h     10.100.69.209    k8s-worker-3   <none>           <none><br>
svc-mall-cart-79c667bf56-j76h6              1/1     Running     0          20h     10.100.69.213    k8s-worker-3   <none>           <none><br>
svc-mall-order-fbfd8b57c-kbczh              1/1     Running     0          3d7h    10.100.69.202    k8s-worker-3   <none>           <none><br>
svc-mall-portal-846d9994f8-m7jbq            1/1     Running     0          2d10h   10.100.69.207    k8s-worker-3   <none>           <none><br>
svc-mall-search-c9c8bc847-h7sgv             1/1     Running     0          23h     10.100.69.210    k8s-worker-3   <none>           <none><br>
[root@k8s-master-3 ~]#</p>
<p>居然有这么多服务都在 worker-3 上。</p>
<p>我们现在登录到 worker-3 上，看一下 top 资源。其实，我在这里主要想看的是 process table，因为我想先确定一下哪个服务消耗的资源最高，然后再决定收拾哪个服务。</p>
<p>[root@k8s-worker-3 ~]# top<br>
top - 22:13:01 up 3 days,  8:39,  3 users,  load average: 40.34, 30.03, 18.02<br>
Tasks: 326 total,   6 running, 320 sleeping,   0 stopped,   0 zombie<br>
%Cpu0  : 74.5 us, 13.4 sy,  0.0 ni,  7.7 id,  0.0 wa,  0.0 hi,  4.4 si,  0.0 st<br>
%Cpu1  : 66.3 us, 12.1 sy,  0.0 ni, 16.5 id,  0.0 wa,  0.0 hi,  4.7 si,  0.3 st<br>
%Cpu2  : 49.7 us, 32.4 sy,  0.0 ni, 14.9 id,  0.0 wa,  0.0 hi,  2.7 si,  0.3 st<br>
%Cpu3  : 73.2 us,  9.7 sy,  0.0 ni, 12.4 id,  0.0 wa,  0.0 hi,  4.7 si,  0.0 st<br>
%Cpu4  : 76.4 us, 10.5 sy,  0.0 ni,  8.8 id,  0.0 wa,  0.0 hi,  4.1 si,  0.3 st<br>
%Cpu5  : 62.4 us, 16.4 sy,  0.0 ni, 16.1 id,  0.0 wa,  0.0 hi,  4.7 si,  0.3 st<br>
KiB Mem : 16265992 total,   211212 free,  9204800 used,  6849980 buff/cache<br>
KiB Swap:        0 total,        0 free,        0 used.  6650068 avail Mem</p>
<p>PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                                 <br>
32485 root      20   0 8895760 700564  16896 S 101.6  4.3 723:03.52 java -Dapp.id=svc-mall-cart -javaagent:/opt/skywalking/agent/skywalking-agent.jar -Dskywalking.agent.service_name=svc-ma+<br>
32589 root      20   0 8845576 778684  15896 S  93.6  4.8 427:04.44 java -Dapp.id=svc-mall-order -javaagent:/opt/skywalking/agent/skywalking-agent.jar -Dskywalking.agent.service_name=svc-m+<br>
24119 root      20   0 8825208 600956  15888 S  67.9  3.7 262:00.83 java -Dapp.id=svc-mall-portal -javaagent:/opt/skywalking/agent/skywalking-agent.jar -Dskywalking.agent.service_name=svc-+<br>
&hellip;&hellip;&hellip;&hellip;</p>
<p>在上述 top 资源中，我们主要来看几个吃 CPU 的大户。不难发现，Cart/Order/Portal 这三个服务在购物车信息确定订单的业务中都有用到，并且都在同一个 worker 上。同时，我们也可以看到，在这个 6C 的 worker 中，现在的 CPU 队列已经达到 40 了。</p>
<h3 id="定向分析-1">定向分析</h3>
<p>从系统上来看，CPU 队列长的问题主要是由于资源的争用，因为线程在不断地唤醒，通过 start_thread 就能看出来：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/2e5df84b6e2a9100715c3df919114a1d.png" alt=""></p>
<p>现在我们要做的就是把线程降下去。</p>
<p>怎么降呢？有两种手段：</p>
<ol>
<li>把服务移走，先一个个收拾，分而治之。</li>
<li>把服务的线程减少。</li>
</ol>
<p>这两种方式都是能减少资源争用，但是会带来不同的影响。其中，第一种手段比较合理，只是会消耗更多的整体资源；第二种手段虽然会减少争用，但是会导致响应时间增加。</p>
<p>我这么跟你一讲，你可能已经发现了，这两种手段都不能解释 TPS 不稳定的问题。那为什么 TPS 一会儿掉下去，一会儿又恢复呢？现在我们还不知道答案，不过基于我们“全局 - 定向”的分析思路，我们先看一下 worker-3 的资源消耗：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/4659bad9e237194b42c35c7bb6987504.png" alt=""></p>
<p>在同一时间段，我也查看了同一台物理机上的其他 worker 的资源消耗情况，发现 worker-8 的资源消耗有点不太正常。请你注意，我此时的查看逻辑，仍然依据的是第 3讲中描述的逻辑，以及对应第 4讲中的性能分析决策树。希望你不要觉得这里有跳跃，实际上我们还是在全局监控的第一层计数器上。</p>
<p>我们具体来看一下 worker-8 的资源消耗：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/60927bbb03435dbdc5ab1a0e02c1e4ec.png" alt=""></p>
<p>再来看一下压力场景的执行数据：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/96c1d7c0c5ef47988e5c460c376c06c4.png" alt=""></p>
<p>从上面 worker-8 的资源使用率来看，确实有很高的时候。考虑到同一物理机上资源的争用问题，我们现在把 cart 移到 Worker-7 上去，把 order 移到 worker-9 上去，再来看 TPS：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/59217257bca51af0eb29631f737a1e16.png" alt=""></p>
<p>花花绿绿，起起伏伏，真是好看……我们先不管这样做有没有增加 TPS，光看这个趋势，就足以让人心碎了。既然结果还是这样，那我们就用老套路，继续拆分时间来看看。</p>
<ol>
<li>Gateway：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/4a1f50426532a5755b4e56fad95bfd43.png" alt=""></p>
<ol>
<li>Order：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/03a00aa32ffd9f249c75db05e930d299.png" alt=""></p>
<ol>
<li>Cart：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/33251323dae0e447616da41acc38d6ad.png" alt=""></p>
<ol>
<li>Portal：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/71aa579229988dc649f4ded931ca5485.png" alt=""></p>
<ol>
<li>Member：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/65ae9fd2fb0d8c6c79d470ade0a276e7.png" alt=""></p>
<p>从上面的时间来看，Gateway 消耗的时间比较长，这就奇怪了，这都换了到了 Gateway 服务上有问题了。所以，我们到 Gateway 机器上看一下到底有哪些服务：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/e06d05aefc003314854adda92f029245.png" alt=""></p>
<p>呀呀呀，那个占第一位的是个啥？原来是 ES 的一个进程，这个进程消耗了多个 CPU。看到这，我想起来前几天为了增加 ES 的能力，我们给 ES data 和 ES client 增加过 CPU。当时考虑到它们都是吃 CPU 的大户，只能用一个 CPU 实在太委屈它们了，所以增加了 CPU 数量，想让它们的性能好一些。</p>
<p>可是没想到，ES data 和 ES client 对应用的影响有这么大。</p>
<p>我当时改 ES 的 CPU，是因为我们架构中的一个搜索服务用到了它，而当时的 CPU 给的是一个 C，这导致 Search 服务的 TPS 很低。关于这一点，我在第15讲中有描述，你如果不清楚，可以再看看。</p>
<p>同时，我们还要注意一点，ES data 和 ES client 都不是单一的节点，而是有几个节点。由此产生的问题就是，任意一个 ES 节点出现资源消耗过多的时候，都会影响到它所在的 worker 机器资源，进而影响到这个 ES 节点所在的整个物理机。</p>
<p>既然 ES 的进程消耗资源占居首位，那我们该怎么办呢？为了验证问题，我先把 ES 给停掉，看看 TPS 能不能上来，如果能上来，我们再考虑怎么限制 ES 的资源。</p>
<p>停了 ES 之后，TPS 如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/3a1db2a2b4f9da0a522de8f1f26277c2.png" alt=""></p>
<p>看到没有？TPS 增加了一倍，并且也没有掉下来！非常理想！</p>
<p>所以，接下来，我们就要考虑把 ES 限制到固定的 worker 上，让它不影响现在的应用。</p>
<h2 id="总结">总结</h2>
<p>在这节课中，我们有两个阶段的分析。</p>
<p>在第一个阶段中，我们定位了数据问题。对于性能来说，<strong>数据是非常重要的基础资源，而数据的合理性直接影响了测试的结果。</strong></p>
<p>经常有初入性能行业的人讨论：性能脚本中的数据到底应该用多少？我觉得这是一个非常明确的问题，<strong>在所有的性能场景中，使用的资源都应该按真实发生的业务逻辑来确定，有且只有这样，才能保证结果是有效的</strong>。</p>
<p>在第二阶段中，我们定位了一个有意思的问题，而这个问题的复杂性在于整体的架构。因为我们是用 KVM、Kubernetes 和 Docker 作为基础设施的，而我们选择的应用原本也不是真正的微服务，是对一个开源系统架构做了更改，把它改成了真正的微服务。</p>
<p>在这样的环境中，如果一个应用有问题，那在修改重启的时候，应用会被 Kubernetes 调度到哪个节点上，是不确定的。也正是出于这样的原因，我们一会儿看到这里有问题，一会儿看到那里有问题，定位的逻辑全都对，但是就是层面不对。这也是上节课中随机问题出现的原因。</p>
<p>所以，根据我们在第 4 讲中提到的性能分析决策树，我们仍然需要有全局监控、定向监控的思路，并且还要找到计数器的相关性。这样一来，当看到相关计数器有问题的时候，我们就能知道它们之间的关联关系了。</p>
<p>希望你在这节课中，能把性能分析的逻辑记在心中。</p>
<h2 id="课后作业">课后作业</h2>
<p>最后，请你思考一下：</p>
<ol>
<li>性能脚本中的参数应该如何设计？</li>
<li>如何定位 TPS 会掉下来的情况？大概描述一下你的思路。</li>
</ol>
<p>记得在留言区和我讨论、交流你的想法，每一次思考都会让你更进一步。</p>
<p>如果你读完这篇文章有所收获，也欢迎你分享给你的朋友，共同学习进步。我们下这节课再见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/">高楼的性能工程实战课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/18__%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C%E5%A4%84%E7%90%86%E4%B8%80%E7%BB%84%E5%AD%90%E4%BB%BB%E5%8A%A1%E8%AF%A5%E7%94%A8%E4%BB%80%E4%B9%88%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">18__分组操作：处理一组子任务，该用什么并发原语？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/18__%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%95%85%E9%9A%9C%E6%94%B9%E8%BF%9B/">
            <span class="next-text nav-default">18__故障处理最佳实践：故障改进</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
