<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>21__支付前查询订单列表：如何分析优化一个固定的技术组件？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="今天我们来分析支付前查询订单列表接口。
在这节课中，我将带你来看一下对于一个固定的技术组件，分析优化思路应该是怎样的，也就是说组件不是我们开发的，但是又要分析优化它，我们该怎么办？
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/21__%E6%94%AF%E4%BB%98%E5%89%8D%E6%9F%A5%E8%AF%A2%E8%AE%A2%E5%8D%95%E5%88%97%E8%A1%A8%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E4%B8%80%E4%B8%AA%E5%9B%BA%E5%AE%9A%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/21__%E6%94%AF%E4%BB%98%E5%89%8D%E6%9F%A5%E8%AF%A2%E8%AE%A2%E5%8D%95%E5%88%97%E8%A1%A8%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E4%B8%80%E4%B8%AA%E5%9B%BA%E5%AE%9A%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="21__支付前查询订单列表：如何分析优化一个固定的技术组件？">
  <meta property="og:description" content="今天我们来分析支付前查询订单列表接口。
在这节课中，我将带你来看一下对于一个固定的技术组件，分析优化思路应该是怎样的，也就是说组件不是我们开发的，但是又要分析优化它，我们该怎么办？">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="高楼的性能工程实战课">

  <meta itemprop="name" content="21__支付前查询订单列表：如何分析优化一个固定的技术组件？">
  <meta itemprop="description" content="今天我们来分析支付前查询订单列表接口。
在这节课中，我将带你来看一下对于一个固定的技术组件，分析优化思路应该是怎样的，也就是说组件不是我们开发的，但是又要分析优化它，我们该怎么办？">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3918">
  <meta itemprop="keywords" content="高楼的性能工程实战课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="21__支付前查询订单列表：如何分析优化一个固定的技术组件？">
  <meta name="twitter:description" content="今天我们来分析支付前查询订单列表接口。
在这节课中，我将带你来看一下对于一个固定的技术组件，分析优化思路应该是怎样的，也就是说组件不是我们开发的，但是又要分析优化它，我们该怎么办？">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">21__支付前查询订单列表：如何分析优化一个固定的技术组件？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3918 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#场景运行数据">场景运行数据</a></li>
        <li><a href="#架构图">架构图</a></li>
        <li><a href="#拆分响应时间">拆分响应时间</a></li>
        <li><a href="#第一阶段">第一阶段</a>
          <ul>
            <li><a href="#全局监控分析">全局监控分析</a></li>
            <li><a href="#定向监控分析">定向监控分析</a></li>
            <li><a href="#优化效果">优化效果</a></li>
          </ul>
        </li>
        <li><a href="#第二阶段">第二阶段</a>
          <ul>
            <li><a href="#全局监控分析-1">全局监控分析</a></li>
            <li><a href="#定向监控分析-1">定向监控分析</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#课后作业">课后作业</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>今天我们来分析支付前查询订单列表接口。</p>
<p>在这节课中，我将带你来看一下对于一个固定的技术组件，分析优化思路应该是怎样的，也就是说组件不是我们开发的，但是又要分析优化它，我们该怎么办？</p>
<p>此外，我们还会遇到一个问题，就是当数据库的 CPU 并没有全部用完，而是只用了几颗的时候，我们应该如何具体定向？对此，我们将用到查看数据库本身线程栈的方法，这和前面直接看 trx 表有所不同。</p>
<p>下面，我们一起进入今天的内容。</p>
<h2 id="场景运行数据">场景运行数据</h2>
<p>对于支付前查询订单列表接口，我们先来看第一次运行的性能场景结果：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/81cf6328529720fd4cf072d18e3b74a2.png" alt=""></p>
<p>从运行的场景数据来看，这个接口的 TPS 一开始还是挺高的，达到了 800 多。但是，响应时间也增加了，瓶颈已经出现。我们只要知道瓶颈在哪，就能知道这个接口有没有优化空间。</p>
<p>根据高老师的分析逻辑，在正式分析之前，我们看一下架构图。</p>
<h2 id="架构图">架构图</h2>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/ebe69573f33519d0305d1365f970aa7a.png" alt=""></p>
<p>这张架构图是非常清楚的，可以看到，当前接口的逻辑为：Gateway - Order - Member，其中也使用到了 MySQL 和 Redis。</p>
<p>下面我们来看看，响应时间消耗到哪里去了。</p>
<h2 id="拆分响应时间">拆分响应时间</h2>
<ol>
<li>Gateway：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/322acb354d8364195f34f3e752b2a9c2.png" alt=""></p>
<ol start="2">
<li>Order：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/815579a56db1146994b2f56b260313a5.png" alt=""></p>
<ol start="3">
<li>Member：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/6e39e6e2070ca11a660d7c202dfa5287.png" alt=""></p>
<p>从响应时间的分布来看，Gateway（网关）上消耗的时间要长一些。所以，我们接下来得从 Gateway 下手，分析一下到底是哪里消耗了时间。</p>
<h2 id="第一阶段">第一阶段</h2>
<h3 id="全局监控分析">全局监控分析</h3>
<p>按照“<strong>先看全局监控，后看定向监控</strong>”的逻辑，我们先看这个接口的全局监控：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/6b900cd3d63f0506487e5ab3ef62b381.png" alt=""></p>
<p>由于 Gateway 消耗的响应时间长，我们看过全局监控视图之后，要判断出 Gateway 在哪个 worker 上：</p>
<p>[root@k8s-master-2 ~]# kubectl get pods -o wide | grep gateway<br>
gateway-mall-gateway-757659dbc9-tdwnm       1/1     Running     0          3d16h   10.100.79.96     k8s-worker-4   <none>           <none><br>
[root@k8s-master-2 ~]#</p>
<p>这个 Gateway 服务在 worker-4 上，同时，在全局监控图上可以看到，虽然 Gateway 只消耗了 70% 的 CPU，但它还是消耗了最多的响应时间。既然这样，我们就要关注一下 Gateway 的线程状态，看看它在处理什么。</p>
<h3 id="定向监控分析">定向监控分析</h3>
<p>在做定向监控时，我们先来看一下线程的 CPU 消耗：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/498f7d71a4fb9a2d73e77b4a0eeca30e.png" alt=""></p>
<p>通过上图可以看到，在 Gateway 中有两类重要的工作线程，分别是 reactor-http-epoll 和 boundedElastic。</p>
<p>在官方的说明中提到，reactor-http-epoll 线程的设置最好与 CPU 个数一致。我们当前的 reactor-http-epoll 线程是 4 个，而这个 worker 有 6C，所以还能增加两个，增加多了意义也不大。至于 boundedElastic，它是有边界的弹性线程池，默认为 CPU 核 x10，也没啥可优化的。</p>
<p>我们再持续看一会儿 Gateway 服务中的线程所消耗的时间比例，看一下方法级的时间消耗有没有异常的情况，也就是比例非常高的，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/876ff59214ecc87f89c5bb001f843889.png" alt=""></p>
<p>你看，当前的执行方法也都没啥异常的。</p>
<p>现在我们就把线程增加到 6 个，看能不能把 CPU 用高一点。如果 CPU 用多了之后，仍然是 Gateway 消耗的时间长，那我们就只有再继续加 CPU 了。</p>
<p>请你注意，在性能项目中，不要轻易给出加 CPU 这样的建议。一定要在你分析了逻辑之后，确定没有其他优化空间了，再给这样的建议。</p>
<h3 id="优化效果">优化效果</h3>
<p>我们来看一下优化效果：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/67bb20da883e181c555d45fb362cf5bb.png" alt=""></p>
<p>通过回归测试，我们看到 TPS 有一点增加，只是在图的后半段（由于在测试过程中，Gateway 重启过，前面的 TPS 就当是预热了）增加的并不明显，大概有 50 多 TPS 的样子。不过，也算是有了效果。</p>
<p>我们优化到这里并没有结束，因为在查看各个 Worker 的过程中，我还发现一个奇怪的现象，那就是数据库里有两个 CPU 的使用率非常高。下面我们来扒一扒。</p>
<h2 id="第二阶段">第二阶段</h2>
<h3 id="全局监控分析-1">全局监控分析</h3>
<p>因为前面优化的效果并不怎么样，所以我们要重新开始分析。让我们从全局监控开始：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/db7822633c3fda39fb73b3f21492f477.png" alt=""></p>
<p>看起来倒是没啥，数据库所在的 worker-1 也不见有什么大的资源消耗。</p>
<p>请你注意，我在文章中经常用这个界面来看全局监控的数据。但这并不是说，我只看这个界面。当我在这个界面中看不到明显的问题点时，我也会去看一些命令，像 top/vmstat 等，这和我一直说的全局监控的完整计数器有关。因此，你的脑袋里要有全局监控计数器的视图，然后才能真正看全第一层的计数器。</p>
<p>我们再来看数据库所在的 worker 上的 top 数据，发现了这样的现象：</p>
<p>bash-4.2$ top     <br>
top - 09:57:43 up 3 days, 17:54,  0 users,  load average: 4.40, 3.57, 3.11<br>
Tasks:  11 total,   1 running,   9 sleeping,   1 stopped,   0 zombie<br>
%Cpu0  :  8.0 us,  4.7 sy,  0.0 ni, 84.3 id,  0.0 wa,  0.0 hi,  2.2 si,  0.7 st<br>
%Cpu1  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>
%Cpu2  :  6.5 us,  4.4 sy,  0.0 ni, 85.5 id,  0.0 wa,  0.0 hi,  2.2 si,  1.5 st<br>
%Cpu3  :  7.8 us,  5.7 sy,  0.0 ni, 83.7 id,  0.0 wa,  0.0 hi,  2.1 si,  0.7 st<br>
%Cpu4  : 96.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  4.0 si,  0.0 st<br>
%Cpu5  :  7.0 us,  4.0 sy,  0.0 ni, 84.9 id,  0.0 wa,  0.0 hi,  2.6 si,  1.5 st<br>
KiB Mem : 16265992 total,  1203032 free,  6695156 used,  8367804 buff/cache<br>
KiB Swap:        0 total,        0 free,        0 used.  9050344 avail Mem</p>
<p>PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                     <br>
1 mysql     20   0 8272536   4.7g  13196 S 248.8 30.5   6184:36 mysqld</p>
<p>可以非常明显地看到，有两个 CPU 的使用率高，那我们就来定向分析下数据库。</p>
<p>在此之前，我们不妨心中默念 10 遍“只要思路不乱，任何问题都是一盘菜”，因为保持思路清晰非常重要。</p>
<h3 id="定向监控分析-1">定向监控分析</h3>
<p>我们要定向分析数据库，可是在数据库上又不是所有的 CPU 使用率都高，所以，我们要来看一下数据库线程到底在做什么动作。有了上面的进程信息之后，我们再深入到线程级：</p>
<p>bash-4.2$ top -Hp 1<br>
top - 09:56:40 up 3 days, 17:53,  0 users,  load average: 3.05, 3.30, 3.01<br>
Threads:  92 total,   2 running,  90 sleeping,   0 stopped,   0 zombie<br>
%Cpu0  :  5.4 us,  2.9 sy,  0.0 ni, 89.2 id,  0.0 wa,  0.0 hi,  2.2 si,  0.4 st<br>
%Cpu1  : 99.7 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.3 st<br>
%Cpu2  :  5.4 us,  3.2 sy,  0.0 ni, 88.2 id,  0.0 wa,  0.0 hi,  2.5 si,  0.7 st<br>
%Cpu3  :  6.3 us,  4.2 sy,  0.0 ni, 87.0 id,  0.0 wa,  0.0 hi,  2.1 si,  0.4 st<br>
%Cpu4  : 96.3 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  3.7 si,  0.0 st<br>
%Cpu5  :  4.0 us,  2.5 sy,  0.0 ni, 91.0 id,  0.0 wa,  0.0 hi,  1.8 si,  0.7 st<br>
KiB Mem : 16265992 total,  1205356 free,  6692736 used,  8367900 buff/cache<br>
KiB Swap:        0 total,        0 free,        0 used.  9052664 avail Mem</p>
<p>PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                      <br>
311 mysql     20   0 8272536   4.7g  13196 R 99.9 30.5  18:20.34 mysqld                                                                       <br>
241 mysql     20   0 8272536   4.7g  13196 R 99.7 30.5   1906:40 mysqld                                                                       <br>
291 mysql     20   0 8272536   4.7g  13196 S  3.3 30.5  15:49.21 mysqld                                                                       <br>
319 mysql     20   0 8272536   4.7g  13196 S  3.0 30.5  11:50.34 mysqld                                                                       <br>
355 mysql     20   0 8272536   4.7g  13196 S  3.0 30.5  13:01.53 mysqld                                                                       <br>
265 mysql     20   0 8272536   4.7g  13196 S  2.7 30.5  18:17.48 mysqld                                                                       <br>
307 mysql     20   0 8272536   4.7g  13196 S  2.7 30.5  16:47.77 mysqld                                                                       <br>
328 mysql     20   0 8272536   4.7g  13196 S  2.7 30.5  15:34.92 mysqld                                                                       <br>
335 mysql     20   0 8272536   4.7g  13196 S  2.7 30.5   8:55.38 mysqld                                                                       <br>
316 mysql     20   0 8272536   4.7g  13196 S  2.3 30.5  14:38.68 mysqld                                                                       <br>
350 mysql     20   0 8272536   4.7g  13196 S  2.3 30.5  10:37.94 mysqld                                                                       <br>
233 mysql     20   0 8272536   4.7g  13196 S  2.0 30.5  14:19.32 mysqld                                                                       <br>
279 mysql     20   0 8272536   4.7g  13196 S  2.0 30.5  19:51.80 mysqld                                                                       <br>
318 mysql     20   0 8272536   4.7g  13196 S  2.0 30.5  11:34.62 mysqld                                                                       <br>
331 mysql     20   0 8272536   4.7g  13196 S  2.0 30.5  11:46.94 mysqld                                                                       <br>
375 mysql     20   0 8272536   4.7g  13196 S  2.0 30.5   1:29.22 mysqld                                                                       <br>
300 mysql     20   0 8272536   4.7g  13196 S  1.7 30.5  17:45.26 mysqld                                                                       <br>
380 mysql     20   0 8272536   4.7g  13196 S  1.7 30.5   1:24.32 mysqld</p>
<p>你看，只有两个 MySQL 的线程在使用 CPU。到了这一步，你可能会想，接下来去查 SQL！虽然可能就是 SQL 的问题，但我还是建议你<strong>找到相应的证据。</strong></p>
<p>由于 MySQL 是用 C 语言写的，那我们就用 gstack（这是一个装了 GDB 之后就会有的命令）打印一下这两个 MySQL 的栈看看具体的函数。我们把那两个 PID（311、241）的栈拿出来之后，看到如下信息：</p>
<p>Thread 59 (Thread 0x7f1d60174700 (LWP 241)):<br>
#0  0x000055a431fefea9 in JOIN_CACHE::read_record_field(st_cache_field*, bool) ()<br>
#1  0x000055a431ff01ca in JOIN_CACHE::read_some_record_fields() ()<br>
#2  0x000055a431ff070f in JOIN_CACHE::get_record() ()<br>
#3  0x000055a431ff2a92 in JOIN_CACHE_BNL::join_matching_records(bool) ()<br>
#4  0x000055a431ff18f0 in JOIN_CACHE::join_records(bool) ()<br>
#5  0x000055a431e397c0 in evaluate_join_record(JOIN*, QEP_TAB*) ()<br>
#6  0x000055a431e3f1a5 in sub_select(JOIN*, QEP_TAB*, bool) ()<br>
#7  0x000055a431e37a90 in JOIN::exec() ()<br>
#8  0x000055a431eaa0ba in handle_query(THD*, LEX*, Query_result*, unsigned long long, unsigned long long) ()<br>
#9  0x000055a43194760d in execute_sqlcom_select(THD*, TABLE_LIST*) ()<br>
#10 0x000055a431e6accf in mysql_execute_command(THD*, bool) ()<br>
#11 0x000055a431e6d455 in mysql_parse(THD*, Parser_state*) ()<br>
#12 0x000055a431e6e3b6 in dispatch_command(THD*, COM_DATA const*, enum_server_command) ()<br>
#13 0x000055a431e6fc00 in do_command(THD*) ()<br>
#14 0x000055a431f33938 in handle_connection ()<br>
#15 0x000055a4320e66d4 in pfs_spawn_thread ()<br>
#16 0x00007f1e8f1fcdd5 in start_thread () from /lib64/libpthread.so.0<br>
#17 0x00007f1e8d3cc02d in clone () from /lib64/libc.so.6<br>
Thread 41 (Thread 0x7f1d585e0700 (LWP 311)):<br>
#0  0x000055a4319dbe44 in Item_field::val_int() ()<br>
#1  0x000055a4319fb839 in Arg_comparator::compare_int_signed() ()<br>
#2  0x000055a4319fbd9b in Item_func_eq::val_int() ()<br>
#3  0x000055a431ff24ab in JOIN_CACHE::check_match(unsigned char*) ()<br>
#4  0x000055a431ff26ec in JOIN_CACHE::generate_full_extensions(unsigned char*) ()<br>
#5  0x000055a431ff2ab4 in JOIN_CACHE_BNL::join_matching_records(bool) ()<br>
#6  0x000055a431ff18f0 in JOIN_CACHE::join_records(bool) ()<br>
#7  0x000055a431e397c0 in evaluate_join_record(JOIN*, QEP_TAB*) ()<br>
#8  0x000055a431e3f1a5 in sub_select(JOIN*, QEP_TAB*, bool) ()<br>
#9  0x000055a431e37a90 in JOIN::exec() ()<br>
#10 0x000055a431eaa0ba in handle_query(THD*, LEX*, Query_result*, unsigned long long, unsigned long long) ()<br>
#11 0x000055a43194760d in execute_sqlcom_select(THD*, TABLE_LIST*) ()<br>
#12 0x000055a431e6accf in mysql_execute_command(THD*, bool) ()<br>
#13 0x000055a431e6d455 in mysql_parse(THD*, Parser_state*) ()<br>
#14 0x000055a431e6e3b6 in dispatch_command(THD*, COM_DATA const*, enum_server_command) ()<br>
#15 0x000055a431e6fc00 in do_command(THD*) ()<br>
#16 0x000055a431f33938 in handle_connection ()<br>
#17 0x000055a4320e66d4 in pfs_spawn_thread ()<br>
#18 0x00007f1e8f1fcdd5 in start_thread () from /lib64/libpthread.so.0<br>
#19 0x00007f1e8d3cc02d in clone () from /lib64/libc.so.6</p>
<p>很明显，是两个 execute_sqlcom_select 函数，也就是两个 select 语句。我们接着往上看栈，还可以看到是 JOIN 函数。既然是 select 语句中的 JOIN，那我们直接去找 SQL 语句就好了。</p>
<p>因此，我们直接去查 innodb_trx 表，看看正在执行 SQL 有没有消耗时间长的。你也许会执行 show processlist 之类的命令，但是为了看全 SQL，我还是建议你直接查 trx 表。由于我们使用的 thread_handling 是默认的 one-thread-per-connection，操作系统的线程和 mysql 里的线程都是一一对应的。所以，我们在这里直接查 trx 表不会有什么误判。</p>
<p>通过查找 innodb_trx 表，我们看到了这样两个 SQL 消耗时间较长，列在这里：</p>
<p>&ndash; sql1<br>
SELECT<br>
count(*)<br>
FROM<br>
oms_order o<br>
LEFT JOIN oms_order_item ot ON o.id = ot.order_id<br>
WHERE<br>
o. STATUS = 0<br>
AND o.create_time &lt; date_add(NOW(), INTERVAL - 120 MINUTE)<br>
LIMIT 0,<br>
1000</p>
<p>&ndash; sql2：<br>
SELECT<br>
o.id,<br>
o.order_sn,<br>
o.coupon_id,<br>
o.integration,<br>
o.member_id,<br>
o.use_integration,<br>
ot.id ot_id,<br>
ot.product_name ot_product_name,<br>
ot.product_sku_id ot_product_sku_id,<br>
ot.product_sku_code ot_product_sku_code,<br>
ot.product_quantity ot_product_quantity<br>
FROM<br>
oms_order o<br>
LEFT JOIN oms_order_item ot ON o.id = ot.order_id<br>
WHERE<br>
o. STATUS = 0<br>
AND o.create_time &lt; date_add(NOW(), INTERVAL - 120 MINUTE)</p>
<p>我们提到多次，要想看 SQL 慢，就得看 SQL 对应的执行计划（在 MySQL 中，如果执行计划看得不清楚，还可以看 Profile 信息）。这两个 SQL 对应的执行计划如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/2a2dd1b4daac4dff11b2a8c4ae481762.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/63dd9d72189cc119f94d532b5d2408ce.png" alt=""></p>
<p>依然是常见的全表扫描。看到这里，你是不是有一种索然无味的感觉？但是，我们还是需要知道这两个语句为什么会产生。</p>
<p>其实，支付前查询订单列表这个接口并没有用到这两个 SQL。于是，我到代码中看了一下这两个 SQL 的生成过程，反向查找到如下代码：</p>
<p>@Scheduled(cron = &ldquo;0 0/20 * ? * ?&rdquo;)<br>
private void cancelTimeOutOrder(){<br>
Integer count = portalOrderService.cancelTimeOutOrder();<br>
LOGGER.info(&ldquo;取消订单释放锁定库存：{}&quot;,count);<br>
}</p>
<p>很显然，这是一个定时计划，每 20 分钟执行一次。到这里，问题就很清楚了，原来是定时任务调用了这两个批量的查询语句，导致了两个 CPU 使用率达到 100%，并且也持续了一段时间。</p>
<p>像这样的定时任务，我们要格外关注一下，注意把它和实时业务分开部署和处理，减少批量业务对实时业务的资源争用。如果放在一起处理，那就要控制好要批量查询的数据量级，让 SQL 的查询变得合理。</p>
<p>由于数据库可用的 CPU 比较多，这个定时任务对我们的 TPS 并没有产生什么明显的影响，在这里我们不用做什么处理，以后注意分开就好了。</p>
<h2 id="总结">总结</h2>
<p>在这节课中，虽然我们的优化并没有让 TPS 明显增加，但是因为分析的技术细节不一样，我也非常完整地记录了整个分析过程。</p>
<p>在第一阶段的分析中，我们运用的还是之前提到的分析思路。不同点在于，对于一个非常成熟的固定组件，我们要想优化它，就要去了解它的架构，找到它的相关性能参数。因为在实际的性能项目中，面对这样的组件，我们往往没有时间去纠结内部的实现，需要非常快速地作出判断。如果时间允许，你倒是可以慢慢折腾。</p>
<p>其实理解一个技术组件的原理，并没有想像中的那么高不可攀、深不可测，只要耐心看下去，你总会成长。</p>
<p>在第二阶段的分析中，我们由某几个 CPU 高的现象分析到了具体的 SQL 问题。这个过程虽然简单，但是从这个问题上，我们可以看出这个系统还有很多的优化空间，比如说主从分离、定时任务拆为单独的服务等等。不过，在我们的性能分析中，重点仍然是我跟你一直灌输的分析思路，希望你记在心里了。</p>
<h2 id="课后作业">课后作业</h2>
<p>最后，我给你留两道题，请你思考一下：</p>
<ol>
<li>为什么要看全部的全局监控计数器？</li>
<li>单 CPU 高时，如何定位具体的问题点？你有什么思路？</li>
</ol>
<p>记得在留言区和我讨论、交流你的想法，每一次思考都会让你更进一步。</p>
<p>如果你读完这篇文章有所收获，也欢迎你分享给你的朋友，共同学习进步。我们下一讲再见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/">高楼的性能工程实战课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%82%B1%E5%B2%B3%E7%9A%84%E4%BA%A7%E5%93%81%E5%AE%9E%E6%88%98/21__%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2%E7%9A%84%E9%98%B4%E6%9A%97%E9%9D%A2/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">21__增长黑客的阴暗面</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BD%97%E5%89%91%E9%94%8B%E7%9A%84c&#43;&#43;%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/21__%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%E4%B8%8A%E5%B8%A6%E4%BD%A0%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E4%B9%A6%E5%BA%97%E5%BA%94%E7%94%A8/">
            <span class="next-text nav-default">21__知识串讲（上）：带你开发一个书店应用</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
