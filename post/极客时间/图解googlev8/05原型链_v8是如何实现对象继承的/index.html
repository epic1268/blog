<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>05｜原型链_V8是如何实现对象继承的？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是李兵。
在前面两节中，我们分析了什么是 JavaScript 中的对象，以及 V8 内部是怎么存储对象的，本节我们继续深入学习对象，一起来聊聊 V8 是如何实现 JavaScript 中对象继承的。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%9B%BE%E8%A7%A3googlev8/05%E5%8E%9F%E5%9E%8B%E9%93%BE_v8%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E7%9A%84/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%9B%BE%E8%A7%A3googlev8/05%E5%8E%9F%E5%9E%8B%E9%93%BE_v8%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E7%9A%84/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="05｜原型链_V8是如何实现对象继承的？">
  <meta property="og:description" content="你好，我是李兵。
在前面两节中，我们分析了什么是 JavaScript 中的对象，以及 V8 内部是怎么存储对象的，本节我们继续深入学习对象，一起来聊聊 V8 是如何实现 JavaScript 中对象继承的。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="图解GoogleV8">

  <meta itemprop="name" content="05｜原型链_V8是如何实现对象继承的？">
  <meta itemprop="description" content="你好，我是李兵。
在前面两节中，我们分析了什么是 JavaScript 中的对象，以及 V8 内部是怎么存储对象的，本节我们继续深入学习对象，一起来聊聊 V8 是如何实现 JavaScript 中对象继承的。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4943">
  <meta itemprop="keywords" content="图解GoogleV8">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="05｜原型链_V8是如何实现对象继承的？">
  <meta name="twitter:description" content="你好，我是李兵。
在前面两节中，我们分析了什么是 JavaScript 中的对象，以及 V8 内部是怎么存储对象的，本节我们继续深入学习对象，一起来聊聊 V8 是如何实现 JavaScript 中对象继承的。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">05｜原型链_V8是如何实现对象继承的？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4943 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#原型继承是如何实现的">原型继承是如何实现的？</a></li>
        <li><a href="#实践利用-__proto__-实现继承">实践：利用 __proto__ 实现继承</a></li>
        <li><a href="#构造函数是怎么创建对象的">构造函数是怎么创建对象的？</a></li>
        <li><a href="#构造函数怎么实现继承">构造函数怎么实现继承？</a></li>
        <li><a href="#一段关于-new-的历史">一段关于 new 的历史</a></li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是李兵。</p>
<p>在前面两节中，我们分析了什么是 JavaScript 中的对象，以及 V8 内部是怎么存储对象的，本节我们继续深入学习对象，一起来聊聊 V8 是如何实现 JavaScript 中对象继承的。</p>
<p>简单地理解，<strong>继承就是一个对象可以访问另外一个对象中的属性和方法</strong>，比如我有一个 B 对象，该对象继承了 A 对象，那么 B 对象便可以直接访问 A 对象中的属性和方法，你可以参看下图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%9B%BE%E8%A7%A3GoogleV8/440b1f32adcbc99779e6869f55250fe1.png" alt=""></p>
<p>什么是继承</p>
<p>观察上图，因为 B 继承了 A，那么 B 可以直接使用 A 中的 color 属性，就像这个属性是 B 自带的一样。</p>
<p>不同的语言实现继承的方式是不同的，其中最典型的两种方式是<strong>基于类的设计</strong>和<strong>基于原型继承的设计</strong>。</p>
<p>C++、Java、C# 这些语言都是基于经典的类继承的设计模式，这种模式最大的特点就是提供了非常复杂的规则，并提供了非常多的关键字，诸如 class、friend、protected、private、interface 等，通过组合使用这些关键字，就可以实现继承。</p>
<p>使用基于类的继承时，如果业务复杂，那么你需要创建大量的对象，然后需要维护非常复杂的继承关系，这会导致代码过度复杂和臃肿，另外引入了这么多关键字也给设计带来了更大的复杂度。</p>
<p>而 JavaScript 的继承方式和其他面向对象的继承方式有着很大差别，JavaScript 本身不提供一个 class 实现。虽然标准委员会在 ES2015/ES6 中引入了 class 关键字，但那只是语法糖，JavaScript 的继承依然和基于类的继承没有一点关系。所以当你看到 JavaScript 出现了 class 关键字时，不要以为 JavaScript 也是面向对象语言了。</p>
<p>JavaScript 仅仅在对象中引入了一个原型的属性，就实现了语言的继承机制，基于原型的继承省去了很多基于类继承时的繁文缛节，简洁而优美。</p>
<h2 id="原型继承是如何实现的">原型继承是如何实现的？</h2>
<p>那么，基于原型继承是如何实现的呢？我们参看下图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%9B%BE%E8%A7%A3GoogleV8/8c109b68c83377956f751aff264ebd78.png" alt=""></p>
<p>有一个对象 C，它包含了一个属性“type”，那么对象 C 是可以直接访问它自己的属性 type 的，这点毫无疑问。</p>
<p>怎样让 C 对象像访问自己的属性一样，访问 B 对象呢？</p>
<p>上节我们从 V8 的内存快照看到，JavaScript 的每个对象都包含了一个隐藏属性 __proto__，我们就把该隐藏属性 __proto__ 称之为该<strong>对象的原型 (prototype)</strong>，__proto__ 指向了内存中的另外一个对象，我们就把 __proto__ 指向的对象称为该对象的<strong>原型对象</strong>，那么该对象就可以直接访问其原型对象的方法或者属性。</p>
<p>比如我让 C 对象的原型指向 B 对象，那么便可以利用 C 对象来直接访问 B 对象中的属性或者方法了，最终的效果如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%9B%BE%E8%A7%A3GoogleV8/a474e0162e31077c547980dcbe74c29e.png" alt=""></p>
<p>观察上图，当 C 对象将它的 __proto__ 属性指向了 B 对象后，那么通过对象 C 来访问对象 B 中的 name 属性时，V8 会先从对象 C 中查找，但是并没有查找到，接下来 V8 继续在其原型对象 B 中查找，因为对象 B 中包含了 name 属性，那么 V8 就直接返回对象 B 中的 name 属性值，虽然 C 和 B 是两个不同的对象，但是使用的时候，B 的属性看上就像是 C 的属性一样。</p>
<p>同样的方式，B 也是一个对象，它也有自己的 __proto__ 属性，比如它的属性指向了内存中另外一块对象 A，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%9B%BE%E8%A7%A3GoogleV8/e0e651b77ee4d2a64ce4cc974a88171e.png" alt=""></p>
<p>从图中可以看到，对象 A 有个属性是 color，那么通过 C.color 访问 color 属性时，V8 会先在 C 对象内部查找，但是没有查找到，接着继续在 C 对象的原型对象 B 中查找，但是依然没有查找到，那么继续去对象 B 的原型对象 A 中查找，因为 color 在对象 A 中，那么 V8 就返回该属性值。</p>
<p>我们看到使用 C.name 和 C.color 时，给人的感觉属性 name 和 color 都是对象 C 本身的属性，但是实际上这些属性都是位于原型对象上，我们把这个查找属性的路径称为**原型链，**它像一个链条一样，将几个原型链接了起来。</p>
<p>在这里还要注意一点，不要将原型链接和作用域链搞混淆了，作用域链是沿着函数的作用域一级一级来查找变量的，而原型链是沿着对象的原型一级一级来查找属性的，虽然它们的实现方式是类似的，但是它们的用途是不同的，关于作用域链，我会在《06 | 作用域链：V8 是如何查找变量的？》这节课来介绍。</p>
<p>关于继承，还有一种情况，如果我有另外一个对象 D，它可以和 C 共同拥有同一个原型对象 B，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%9B%BE%E8%A7%A3GoogleV8/18dc5d70a933b5e187c964ffb878b7d2.png" alt=""></p>
<p>因为对象 C 和对象 D 的原型都指向了对象 B，所以它们共同拥有同一个原型对象，当我通过 D 去访问 name 属性或者 color 属性时，返回的值和使用对象 C 访问 name 属性和 color 属性是一样的，因为它们是同一个数据。</p>
<p>我们再来回顾下继承的概念：<strong>继承就是一个对象可以访问另外一个对象中的属性和方法，</strong> <strong>在</strong> <strong>JavaScript 中，我们通过原型和原型链的方式来实现了继承特性。</strong></p>
<p>通过上面的分析，你可以看到在 JavaScript 中的继承非常简洁，就是每个对象都有一个原型属性，该属性指向了原型对象，查找属性的时候，JavaScript 虚拟机会沿着原型一层一层向上查找，直至找到正确的属性。所以对于 JavaScript 中的原型继承，你不需要把它想得过度复杂。</p>
<h2 id="实践利用-__proto__-实现继承">实践：利用 __proto__ 实现继承</h2>
<p>了解了 JavaScript 中的原型和原型链继承之后，下面我们就可以通过一个例子，看看原型是怎么应用在 JavaScript 中的，你可以先看下面这段代码：</p>
<p>var animal = {<br>
type: &ldquo;Default&rdquo;,<br>
color: &ldquo;Default&rdquo;,<br>
getInfo: function () {<br>
return <code>Type is: ${this.type}，color is ${this.color}.</code><br>
}<br>
}<br>
var dog = {<br>
type: &ldquo;Dog&rdquo;,<br>
color: &ldquo;Black&rdquo;,<br>
}</p>
<p>在这段代码中，我创建了两个对象 animal 和 dog，我想让 dog 对象继承于 animal 对象，那么最直接的方式就是将 dog 的原型指向对象 animal，应该怎么操作呢？</p>
<p>我们可以通过设置 dog 对象中的 __proto__ 属性，将其指向 animal，代码是这样的：</p>
<p>dog.<strong>proto</strong> = animal</p>
<p>设置之后，我们就可以使用 dog 来调用 animal 中的 getInfo 方法了。</p>
<p>dog.getInfo()</p>
<p>你可以尝试调用下，看看输出的内容。在这里留给你一个关于“this”的小思考题：调用 dog.getInfo() 时，getInfo 函数中的 this.type 和 this.color 都是什么值？为什么？</p>
<p>还有一点我们要注意，通常隐藏属性是不能使用 JavaScript 来直接与之交互的。虽然现代浏览器都开了一个口子，让 JavaScript 可以访问隐藏属性 _proto_，但是在实际项目中，我们不应该直接通过 _proto_ 来访问或者修改该属性，其主要原因有两个：</p>
<ol>
<li>首先，这是隐藏属性，并不是标准定义的 ;</li>
<li>其次，使用该属性会造成严重的性能问题。</li>
</ol>
<p>我们之所以在课程中使用 _proto_ 属性，主要是为了方便教学，将其他的一些复杂的概念先抛到一边，这样有利于你循序渐进地掌握我们的课程内容，但是我并不推荐你这么做。那应该怎么去正确地设置对象的原型对象呢？</p>
<p>答案是使用构造函数来创建对象，下面我们就来详细解释这个过程。</p>
<h2 id="构造函数是怎么创建对象的">构造函数是怎么创建对象的？</h2>
<p>比如我们要创建一个 dog 对象，我可以先创建一个 DogFactory 的函数，属性通过参数就行传递，在函数体内，通过 this 设置属性值。代码如下所示：</p>
<p>function DogFactory(type,color){<br>
this.type = type<br>
this.color = color<br>
}</p>
<p>然后再结合关键字“new”就可以创建对象了，创建对象的代码如下所示：</p>
<p>var dog = new DogFactory(&lsquo;Dog&rsquo;,&lsquo;Black&rsquo;)</p>
<p>通过这种方式，我们就把后面的函数称为构造函数，因为通过执行 new 配合一个函数，JavaScript 虚拟机便会返回一个对象。如果你没有详细研究过这个问题，很可能对这种操作感到迷惑，为什么通过 new 关键字配合一个函数，就会返回一个对象呢？</p>
<p>关于 JavaScript 为什么要采用这种怪异的写法，我们文章最后再来介绍，先来看看这段代码的深层含义。</p>
<p>其实当 V8 执行上面这段代码时，V8 会在背后悄悄地做了以下几件事情，模拟代码如下所示：</p>
<p>var dog = {} <br>
dog.<strong>proto</strong> = DogFactory.prototype<br>
DogFactory.call(dog,&lsquo;Dog&rsquo;,&lsquo;Black&rsquo;)</p>
<p>为了加深你的理解，我画了上面这段代码的执行流程图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%9B%BE%E8%A7%A3GoogleV8/f230b03ecac08a41d8c387158056a691.png" alt=""></p>
<p>观察上图，我们可以看到执行流程分为三步：</p>
<ol>
<li>首先，创建了一个空白对象 dog；</li>
<li>然后，将 DogFactory 的 prototype 属性设置为 dog 的原型对象，这就是给 dog 对象设置原型对象的关键一步，我们后面来介绍；</li>
<li>最后，再使用 dog 来调用 DogFactory，这时候 DogFactory 函数中的 this 就指向了对象 dog，然后在 DogFactory 函数中，利用 this 对对象 dog 执行属性填充操作，最终就创建了对象 dog。</li>
</ol>
<h2 id="构造函数怎么实现继承">构造函数怎么实现继承？</h2>
<p>好了，现在我们可以通过构造函数来创建对象了，接下来我们就看看构造函数是如何实现继承的？你可以先看下面这段代码：</p>
<p>function DogFactory(type,color){<br>
this.type = type<br>
this.color = color<br>
//Mammalia<br>
//恒温<br>
this.constant_temperature = 1<br>
}<br>
var dog1 = new DogFactory(&lsquo;Dog&rsquo;,&lsquo;Black&rsquo;)<br>
var dog2 = new DogFactory(&lsquo;Dog&rsquo;,&lsquo;Black&rsquo;)<br>
var dog3 = new DogFactory(&lsquo;Dog&rsquo;,&lsquo;Black&rsquo;)</p>
<p>我利用上面这段代码创建了三个 dog 对象，每个对象都占用了一块空间，占用空间示意图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%9B%BE%E8%A7%A3GoogleV8/f9cc591b2a96ed274a8b45578c8aae47.png" alt=""></p>
<p>从图中可以看出来，对象 dog1 到 dog3 中的 constant_temperature 属性都占用了一块空间，但是这是一个通用的属性，表示所有的 dog 对象都是恒温动物，所以没有必要在每个对象中都为该属性分配一块空间，我们可以将该属性设置公用的。</p>
<p>怎么设置呢？</p>
<p>还记得我们介绍函数时提到关于函数有两个隐藏属性吗？这两个隐藏属性就是 name 和 code，其实函数还有另外一个隐藏属性，那就是 prototype，刚才介绍构造函数时我们也提到过。一个函数有以下几个隐藏属性：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%9B%BE%E8%A7%A3GoogleV8/51b26e4ff3cee8ffba4c12a8c44959d8.png" alt=""></p>
<p>每个函数对象中都有一个公开的 prototype 属性，当你将这个函数作为构造函数来创建一个新的对象时，新创建对象的原型对象就指向了该函数的 prototype 属性。当然了，如果你只是正常调用该函数，那么 prototype 属性将不起作用。</p>
<p>现在我们知道了新对象的原型对象指向了构造函数的 prototype 属性，当你通过一个构造函数创建多个对象的时候，这几个对象的原型都指向了该函数的 prototype 属性，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%9B%BE%E8%A7%A3GoogleV8/f3c7812e9135b8de2cf69772c201ac98.png" alt=""></p>
<p>这时候我们可以将 constant_temperature 属性添加到 DogFactory 的 prototype 属性上，代码如下所示：</p>
<p>function DogFactory(type,color){<br>
this.type = type<br>
this.color = color<br>
//Mammalia<br>
}<br>
DogFactory. prototype.constant_temperature = 1<br>
var dog1 = new DogFactory(&lsquo;Dog&rsquo;,&lsquo;Black&rsquo;)<br>
var dog2 = new DogFactory(&lsquo;Dog&rsquo;,&lsquo;Black&rsquo;)<br>
var dog3 = new DogFactory(&lsquo;Dog&rsquo;,&lsquo;Black&rsquo;)</p>
<p>这样我们三个 dog 对象的原型对象都指向了 prototype，而 prototype 又包含了 constant_temperature 属性，这就是我们实现继承的正确方式。</p>
<h2 id="一段关于-new-的历史">一段关于 new 的历史</h2>
<p>现在我们知道 new 关键字结合构造函数，就能生成一个对象，不过这种方式很怪异，为什么要这样呢？要了解这背后的原因，我们需要了解一段关于关于 JavaScript 的历史。</p>
<p>JavaScript 是 Brendan Eich 发明的，那是个“战乱”的时代，各种大公司相互争霸，有 Sun、微软、网景、甲骨文等公司，它们都有推出自己的语言，其中最如日中天的编程语言是 Sun 的 Java，而 JavaScript 就是这个时候诞生的。当时创造 JavaScript 的目的仅仅是为了让浏览器页面可以动起来，所以尽可能采用简化的方式来设计 JavaScript，所以本质上来说，Java 和 JavaScript 的关系就像雷锋和雷峰塔的关系。</p>
<p>那么之所以叫 JavaScript 是出于市场原因考量的，因为一门新的语言需要吸引新的开发者，而当时最大的开发者群体就是 Java，于是 JavaScript 就蹭了 Java 的热度，事后，这一招被证明的确有效果。</p>
<p>虽然叫 JavaScript，但是其编程方式和 Java 比起来，依然存在着非常大的差异，其中 Java 中使用最频繁的代码就是创建一个对象，如下所示：</p>
<p>CreateInstance instance = new CreateInstance();</p>
<p>当时 JavaScript 并没有使用这种方式来创建对象，因为 JavaScript 中的对象和 Java 中的对象是完全不一样的，因此，完全没有必要使用关键字 new 来创建一个新对象的，但是为了进一步吸引 Java 程序员，依然需要在语法层面去蹭 Java 热点，所以 JavaScript 中就被硬生生地强制加入了非常不协调的关键字 new，然后使用 new 来创造对象就变成这样了：</p>
<p>var bar = new Foo()</p>
<p>Java 程序员看到这段代码时，当然会感到倍感亲切，觉得 Java 和 JavaScript 非常相似，那么使用 JavaScript 也就天经地义了。不过代码形式只是表象，其背后原理是完全不同的。</p>
<p>了解了这段历史之后，我们知道 JavaScript 的 new 关键字设计并不合理，但是站在市场角度来说，它的出现又是非常成功的，成功地推广了 JavaScript。</p>
<h2 id="总结">总结</h2>
<p>好了，今天的主要内容就介绍到这里，下面我们来回顾下。</p>
<p>今天我们的主要目的是介绍清楚 JavaScript 中的继承机制，这涉及到了原型继承机制，虽然基于原型的继承机制本身比较简单，但是在 JavaScript 中，这是通过关键字 new 加上构造函数来体现的。这种方式非常绕，且不符合人的直觉，如果直接上来就介绍 new 加构造函数是怎么工作的，可能会把你给绕晕了。</p>
<p>于是我先通过每个对象中都有的隐含属性 __proto__，来介绍了什么是原型和原型链。V8 为每个对象都设置了一个 __proto__ 属性，该属性直接指向了该对象的原型对象，原型对象也有自己的 __proto__ 属性，这些属性串连在一起就成了原型链。</p>
<p>不过在 JavaScript 中，并不建议直接使用 __proto__ 属性，主要有两个原因。</p>
<ol>
<li>一，这是隐藏属性，并不是标准定义的；</li>
<li>二，使用该属性会造成严重的性能问题。</li>
</ol>
<p>所以，而是在 JavaScript 中，是使用 new 加上构造函数的这种组合来创建对象和实现对象的继承。不过使用这种方式隐含的语义过于隐晦，所以理解起来有点难度。</p>
<p>为什么 JavaScript 中要使用这种怪异的方式来创建对象？为了理解这个问题，我们回顾了一段 JavaScript 的历史。由于当前的 Java 非常流行，基于市场推广的考虑，JavaScript 采取了蹭 Java 热度的策略，在语言命名上使用了 Java 字样，在语法形式上也模仿了 Java。事实上通过这些策略，确实为 JavaScript 带来了市场上的成功。不过你依然要记住，JavaScript 和 Java 是完全两种不同的语言。</p>
<h2 id="思考题">思考题</h2>
<p>我们知道函数也是一个对象，所以函数也有自己的 __proto__ 属性，那么今天留给你的思考题是：DogFactory 是一个函数，那么“DogFactory.prototype”和“DogFactory._proto_”这两个属性之间有关联吗？欢迎你在留言区与我分享讨论。</p>
<p>感谢你的阅读，如果你觉得这篇文章对你有所启发，也欢迎把它分享给你的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%9B%BE%E8%A7%A3googlev8/">图解GoogleV8</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/ab%E6%B5%8B%E8%AF%95%E4%BB%8E0%E5%88%B01/05%E9%80%89%E5%8F%96%E5%AE%9E%E9%AA%8C%E5%8D%95%E4%BD%8D%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%AE%9E%E9%AA%8C%E5%8D%95%E4%BD%8D%E6%98%AF%E5%90%88%E9%80%82%E7%9A%84/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">05｜选取实验单位：什么样的实验单位是合适的？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A1%88%E4%BE%8B%E8%A7%A3%E8%AF%BB/050__%E4%BA%9A%E9%A9%AC%E9%80%8A%E9%A2%86%E5%AF%BC%E5%8A%9B%E5%87%86%E5%88%99%E4%B9%8B%E5%8B%A4%E4%BF%AD%E8%8A%82%E7%BA%A6/">
            <span class="next-text nav-default">050__亚马逊领导力准则之勤俭节约</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
