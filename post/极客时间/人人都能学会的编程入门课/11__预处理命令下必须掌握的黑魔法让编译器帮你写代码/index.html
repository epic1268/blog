<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>11__预处理命令（下）：必须掌握的“黑魔法”，让编译器帮你写代码 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是胡光，欢迎回来。最近为了防范疫情，很多人应该都窝在家里吧？春节假期除了娱乐放松，也不要忘记学习提高呀！
上次呢，我们知道了，原来程序的编译，是一个复杂的过程，其中重要的是三个阶段：预处理阶段，编译阶段和链接阶段 。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E8%AF%BE/11__%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E4%B8%8B%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95%E8%AE%A9%E7%BC%96%E8%AF%91%E5%99%A8%E5%B8%AE%E4%BD%A0%E5%86%99%E4%BB%A3%E7%A0%81/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E8%AF%BE/11__%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E4%B8%8B%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95%E8%AE%A9%E7%BC%96%E8%AF%91%E5%99%A8%E5%B8%AE%E4%BD%A0%E5%86%99%E4%BB%A3%E7%A0%81/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="11__预处理命令（下）：必须掌握的“黑魔法”，让编译器帮你写代码">
  <meta property="og:description" content="你好，我是胡光，欢迎回来。最近为了防范疫情，很多人应该都窝在家里吧？春节假期除了娱乐放松，也不要忘记学习提高呀！
上次呢，我们知道了，原来程序的编译，是一个复杂的过程，其中重要的是三个阶段：预处理阶段，编译阶段和链接阶段 。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="人人都能学会的编程入门课">

  <meta itemprop="name" content="11__预处理命令（下）：必须掌握的“黑魔法”，让编译器帮你写代码">
  <meta itemprop="description" content="你好，我是胡光，欢迎回来。最近为了防范疫情，很多人应该都窝在家里吧？春节假期除了娱乐放松，也不要忘记学习提高呀！
上次呢，我们知道了，原来程序的编译，是一个复杂的过程，其中重要的是三个阶段：预处理阶段，编译阶段和链接阶段 。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4889">
  <meta itemprop="keywords" content="人人都能学会的编程入门课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="11__预处理命令（下）：必须掌握的“黑魔法”，让编译器帮你写代码">
  <meta name="twitter:description" content="你好，我是胡光，欢迎回来。最近为了防范疫情，很多人应该都窝在家里吧？春节假期除了娱乐放松，也不要忘记学习提高呀！
上次呢，我们知道了，原来程序的编译，是一个复杂的过程，其中重要的是三个阶段：预处理阶段，编译阶段和链接阶段 。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">11__预处理命令（下）：必须掌握的“黑魔法”，让编译器帮你写代码</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4889 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#本次任务">本次任务</a></li>
        <li><a href="#必知必会查缺补漏">必知必会，查缺补漏</a>
          <ul>
            <li></li>
          </ul>
        </li>
        <li><a href="#一起动手搞事情">一起动手，搞事情</a>
          <ul>
            <li></li>
          </ul>
        </li>
        <li><a href="#输出漂亮的日志格式">输出漂亮的日志格式</a></li>
        <li><a href="#课程小结">课程小结</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是胡光，欢迎回来。最近为了防范疫情，很多人应该都窝在家里吧？春节假期除了娱乐放松，也不要忘记学习提高呀！</p>
<p>上次呢，我们知道了，原来程序的编译，是一个复杂的过程，其中重要的是三个阶段：<strong>预处理阶段</strong>，<strong>编译阶段</strong>和<strong>链接阶段</strong> 。</p>
<p>同时，我们也搞清楚了“源代码”和“待编译源码”两个概念的区别，其中“待编译源码”是由“源代码”经过预处理阶段所产生的代码，并且“待编译源码”才是决定程序最终功能的终版代码。</p>
<p>今天呢，我们继续上节课的知识，来具体学习几个重要的，能够影响“待编译源码”内容的预处理命令吧。</p>
<h2 id="本次任务">本次任务</h2>
<p>在正式开始今天课程之前，我们先来回顾一下任务内容：实现一个使用方法和 printf 函数一样的，但是输出信息却比 printf 更加人性化的，更加具体的 log 方法。</p>
<p>具体代码及事例，参考如下：</p>
<p>#include &lt;stdio.h&gt;</p>
<p>void func(int a) {<br>
log(&ldquo;a = %d\n&rdquo;, a);<br>
}</p>
<p>int main() {<br>
int a = 123;<br>
printf(&ldquo;a = %d\n&rdquo;, a);<br>
log(&ldquo;a = %d\n&rdquo;, a);<br>
func(a);<br>
return 0;</p>
<p>a = 123<br>
[main, 10] a = 123<br>
[func, 4] a = 123</p>
<p>通过文稿代码可以看到，经过 log 方法后，我们获得了更多程序信息。但我们的任务是设计完 log 方法以后，请再给这个 log 方法提供一个小开关，使其很方便的打开或者关闭程序中所有 log 的输出信息。</p>
<p>回顾完了任务以后，就让我们一起来进行具体的预处理命令的学习吧。</p>
<h2 id="必知必会查缺补漏">必知必会，查缺补漏</h2>
<p>在上一节，我们明确了 include 文件包含预处理命令的作用。今天，我们将来着重讲解两种预处理命令<strong>宏定义</strong>与<strong>条件编译</strong>。它们是什么意思呢？不要着急，听我一个个给你解释。</p>
<h4 id="1-初识宏定义">1. 初识宏定义</h4>
<p>宏定义在预处理阶段的作用，就是做简单的替换，将 A 内容，替换成 B 内容，这里需要你特别注意的是，一个宏定义只能占一行代码，这可不是你所认为的一行代码，而是编译器所认为的一行代码，这里在后面，我们会详细来介绍一下。</p>
<p>这里先给你准备了一张示意图，用来说明宏定义的基本用法：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E8%AF%BE/5c176b4511f5f33966ac695d3e93b78c.png" alt=""></p>
<p>图 1:宏定义语法结构示意图</p>
<p>正如上图所示，宏定义以 #define 作为语句的开头，之后两部分，用空格分隔，在预处理阶段期间，会把代码中的 A 内容替换成 B 内容，以此来最终生成“待编译源码”。</p>
<p>下面我们就使用宏来实现一个读入圆的半径，输出圆面积的程序：</p>
<p>#include &lt;stdio.h&gt;<br>
#define PI 3.1415926</p>
<p>int main() {<br>
double r;<br>
scanf(&quot;%lf&quot;, &amp;r);<br>
printf(&quot;%lf\n&quot;, PI * r * r);<br>
return 0;<br>
}</p>
<p>在上面程序中，我们定义了一个名字为 PI 的宏，其替换内容为 3.1415926，也就是圆周率π的相似值。在主函数中，我们读入一个圆的半径值，存储在 r 变量中，然后输出圆的面积，在计算圆面积公式的时候，我们没有使用圆周率本来值来进行程序书写，而是使用刚刚上面定义的宏 PI 代替了圆周率的作用。</p>
<p>面对这份源代码，在预处理阶段的时候，编译器会把代码中所有使用 PI 的地方，都替换成 3.1415926，也就是说，上述代码中的输出函数中，原本的 PI * r * r 的代码内容，会被编译器改写成为 3.1415926 * r * r 作为“待编译源码”。</p>
<p>通过这个例子，我想你就能差不多明白了，什么叫做“宏定义在预处理阶段做的就是简单的替换”以及“宏定义在代码中，只能占一行”，简单来说，就是<strong>宏定义关键字</strong>、<strong>原内容和替换内容</strong> <strong>三者必须写到一行</strong>。</p>
<h4 id="2-宏定义之傻瓜表达式">2. 宏定义之傻瓜表达式</h4>
<p>前面呢，我们说的是宏定义的最基本用法。其实，宏定义中的“原内容”的形式，不仅仅有刚才的类似于 PI 这种简单符号，还有一种更加灵活实用的带参数的形式，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E8%AF%BE/22f57080aa13a88bd03c4c8abb9252e1.png" alt=""></p>
<p>图 2:傻瓜表达式结构示意图</p>
<p>可以看到，我们定义了一个支持两个参数的宏，名字为 mul，替换的内容为 a * b。注意，替换内容中的 a 是宏参数中的 a，b 也是宏参数中的 b。这里我再强调一下，理解宏的工作过程，始终离不开那句话：<strong>宏做的就是简单替换</strong>。</p>
<p>下面给你举个例子：</p>
<p>#include &lt;stdio.h&gt;<br>
#define mul(a, b) a * b</p>
<p>int main() {<br>
printf(&ldquo;mul(3, 5) = %d\n&rdquo;, mul(3, 5));<br>
printf(&ldquo;mul(3 + 4, 5) = %d\n&rdquo;, mul(3 + 4, 5));<br>
return 0;<br>
}</p>
<p>上面代码中，使用了 mul 宏，分别输出了 mul(3, 5) 的值，和 mul(3 + 4, 5) 的值。如果你把 mul 当成函数看待的话，你应该会觉得，第一行输出的值应该是 15，即 35 结果；第二行应该是 35，计算的应该是 75 的结果。</p>
<p>可如果你在你的环境中运行这个代码，你会看到第一行输出的结果确实是 15，和我们的预期一样，可第二行输出的却是 23，这个离我们预想的可就有点儿不一样了。</p>
<p>想要理解为什么输出的是 23，而不是 35 的话，我们需要综合以下两点来进行思考：</p>
<ol>
<li>“待编译源码”决定了最终程序的功能。</li>
<li>宏做的就是简单的替换。</li>
</ol>
<p>宏在预处理阶段将被展开，变成“待编译源码”中的内容，并且做的仅仅是简单的替换。也就是说，mul(a, b) 这个宏，替换的形式是 ab；而 mul(3 + 4, 5) 中 3 + 4 是参数 a 的内容，5 是 b 的内容，依次替换为 ab 式中的 a，b 的话，最终得到的替换内容应该是“3 + 4*5”，这个才是“待编译源码”中真正的内容。面对这个替换以后的表达式，你就知道为什么输出的结果是 23，而不是 35 了吧。</p>
<p>所以，正如你所看到的，<strong>mul 的使用形式虽然和函数类似，可实际运行原理和函数完全不一样</strong>，甚至显得有些机械化。因为 mul 是宏，而宏做的就是简单的替换操作，变成最终的“待编译源码”中的内容。这个过程机械且简单，所以，我们有时也称其为<strong>傻瓜表达式</strong>。</p>
<p>再回来看上面的 mul 宏，使用形式像函数，但函数可以在代码中写成多行的一段代码。可宏呢，只能写成一行，就会使得当我们面对稍微复杂一点的替换内容，宏代码的可读性就会变得特别差。</p>
<p>还好，C 语言给我们提供了一种在行尾加 \（反斜杠）的语法，以此来告诉编译器，本行和下一行其实是同一行内容。这样就做到了：人在阅读代码的时候，看到的是两行代码，而编译器在解析的时候，会认为是一行代码，也就解决了复杂的宏定义的可读性的问题。</p>
<p>具体事例，看如下代码：</p>
<p>#include &lt;stdio.h&gt;<br>
#define swap(a, b) { \<br>
__typeof(a) __temp = a; \<br>
a = b, b = __temp; \<br>
}</p>
<p>int main() {<br>
int num_a = 123, num_b = 456;<br>
swap(num_a, num_b);<br>
printf(&ldquo;num_a = %d\n&rdquo;, num_a);<br>
printf(&ldquo;num_b = %d\n&rdquo;, num_b);<br>
return 0;<br>
}</p>
<p>如上代码中，我们定义了一个用于交换两个变量值的宏 swap，代码的第 2、3、4 行的末尾都有一个反斜杠，编译器就会认为把程序的这几行内容当成一行内容来对待。这样，既保证了宏定义的只占用一行的语法要求，又兼顾了代码可读性。</p>
<p>需要特别注意的是，<strong>代码中反斜杠的后面，不能出现任何其他内容</strong>。作为新手的话，这里是最容易出错的，很多人会在反斜杠后面多打一个空格，会导致反斜杠失去原本的作用，代码查错的时候，也不容易被发现，这里一定要十分小心。</p>
<p>此外，你看到上述代码中，多了一个 __typeof 方法，关于这个方法的作用呢，给你留个小的作业题，请你自行查阅相关资料，并用一句话描述 __typeof 的作用。欢迎在专栏的留言区里面写下你认为足够简洁的 __typeof 的功能描述。</p>
<h4 id="3-初识条件编译">3. 初识条件编译</h4>
<p>看完了宏定义之后，下面来让我们看看另一个使用的比较频繁的预处理命令：条件编译。说到条件编译，光看名字，你也许会联想到 if 条件分支语句。对，条件编译，就是预处理阶段的条件分支语句，其主要作用是根据条件，决定“源代码”中的哪些代码，接下来会被预处理继续进行处理。</p>
<p>我们先来从最容易理解的条件编译开始看起，来了解一下条件编译的语法格式：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E8%AF%BE/bd7043c9e0458612e83e141096434525.png" alt=""></p>
<p>图 3:条件编译的语法结构示意图</p>
<p>如图所示，这个条件编译以指令 #ifdef 作为开头，后面接了一个 Debug。意思是如果定义了 Debug 这个宏，就让预处理器继续处理“代码内容 1”，否则就处理“代码内容 2”。记住，条件编译，可以没有 #else 部分，可最后一定要以 #endif 作为结束。</p>
<p>下面给你举个简单的例子：</p>
<p>#include &lt;stdio.h&gt;<br>
#define Debug<br>
#ifdef Debug<br>
#define MAX_N 1000<br>
#else<br>
#define MAX_N 5000<br>
#endif</p>
<p>int main() {<br>
printf(&ldquo;MAX_N = %d\n&rdquo;, MAX_N);<br>
return 0;<br>
}</p>
<p>如果你运行上面这段代码，你的程序一定会输出 MAX_N = 1000，那是因为当代码运行到条件编译的时候，由于之前定义了 Debug 宏，条件编译的条件成立，保留的是第 4 行代码内容，所以主函数中的 MAX_N 宏最终就会被替换成为 1000。</p>
<p>如果你将第 2 行代码去掉的话，那么条件编译的条件就不成立了，最终被保留下来的是第 6 行代码，程序就会输出 MAX_N = 5000，关于这点，你可以自行尝试一下。</p>
<p>其实在条件编译中，除了我们刚才讲到的三个指令：#ifdef、#else、#endif 之外，还有 #if、#ifndef 以及 #elif 等指令。关于剩下的三个指令的含义和作用，有了这个基础之后，你就可以很轻松的学会了，我就不再赘述了。</p>
<p>我在这里给你准备了一张对照表，以说明这 6 个指令各自的作用：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E8%AF%BE/00c2db5ce6a99d188e127c2c67125b37.png" alt=""></p>
<h2 id="一起动手搞事情">一起动手，搞事情</h2>
<h4 id="思考题没有-bug-的-max-宏">思考题：没有 Bug 的 MAX 宏</h4>
<blockquote>
<p>请你完善下面代码中的 MAX 宏，MAX 宏的作用，就是接受两个元素，选择出两个元素中的最大值。完善以后的 MAX 宏，输出需要与如下给出的输出样例一致，注意，只能修改 MAX 宏的定义内容，不可以修改主函数中的内容。</p>
</blockquote>
<p>#include &lt;stdio.h&gt;<br>
#define P(item) printf(&quot;%s = %d\n&quot;, #item, item);<br>
#define MAX(a, b) // TODO</p>
<p>int main() {<br>
int a = 6;<br>
P(MAX(2, 3));<br>
P(5 + MAX(2, 3));<br>
P(MAX(2, MAX(3, 4)));<br>
P(MAX(2, 3 &gt; 4 ? 3 : 4));<br>
P(MAX(a++, 5));<br>
P(a);<br>
return 0;<br>
}</p>
<p>输出结果参考：</p>
<p>MAX(2, 3) = 3<br>
5 + MAX(2, 3) = 8<br>
MAX(2, MAX(3, 4)) = 4<br>
MAX(2, 3 &gt; 4 ? 3 : 4) = 4<br>
MAX(a++, 5) = 6<br>
a = 7</p>
<h2 id="输出漂亮的日志格式">输出漂亮的日志格式</h2>
<p>准备完了上面的这些基础知识以后，下面来让我们回到最开始的那个任务。</p>
<p>首先我们来思考，要实现一个和 printf 使用方式一样的 log 方法，printf 函数是一个变参函数，那么 log 也需要支持变参，而 log 方法又比 printf 输出的更人性化一些，其中包括了可以输出所在的函数信息，以及所在的代码位置信息。这里，我们选择使用宏定义来实现所谓的 log 方法。</p>
<p>下面，就给你再补充一个小知识点，就是如何定义一个支持可变参数的 log 宏，看如下代码：</p>
<p>#define log(frm, args&hellip;) // 假装这里有内容，后续展开讲解</p>
<p>如上代码所示，在最后一个参数后面，加上三个点，就代表，这个宏除了第一个 frm 参数以外，后面接收的参数个数是可变的，那么后面的参数内容，统一存放在参数 args 中。</p>
<p>这样，我们就可以设计如下代码，使得 log 方法的使用方式与 printf 类似了：</p>
<p>#define log(frm, args&hellip;) printf(frm, args)</p>
<p>此时，log 方法的输出内容，只是和 printf 方法的输出内容是一致的，还无法输出所在函数以及所在代码位置的相关信息。</p>
<p>下面，我们来补充最后一个知识点，就是编译器会预设一些宏，这些宏会为我们提供很多与代码相关的有用信息，具体如下表所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E8%AF%BE/d6bae297d3d5caf676f1082a07fec09d.png" alt=""></p>
<p>我们看到表中有两个宏，是我们这个任务所需要的，一个是 __func__ 代表了当前所在的函数名，另一个是 __LINE__ 代表了当前行号。</p>
<p>其中宏 __func__ 后面的说明中，注明了是“非标准”，什么叫做非标准呢，也就是说，在不同的编译器中，这个宏的名称可能是不同的，甚至某些编译器不提供这个宏，也是有可能的。例如在 VC 6.0 的环境中就没有 __func__ 宏，因为这个宏不是 C 语言标准里面的东西。</p>
<p>通过这个 __func__ 宏，我想让你初步认识到什么是代码的 <strong>“可移植性”</strong>，也就是说，你写了一份代码，当你的运行环境发生改变时，你的代码到底要不要做修改？如果要做修改，到底要做多少修改？这是代码的可移植性所讨论的问题。</p>
<p>放到今天这个例子中，就是说，如果你在你的代码中，不做任何处理的，直接使用 __func__ 宏，那么就会影响你代码的可移植性。如果还不清楚什么是代码的可移植性，你就回想一下，当初我们输出彩色文字的那个代码，是不是在有些人的环境中，无法输出彩色文字？</p>
<p>最后，有了这些基础知识以后，就不难完成这个任务了，下面是我给出的 log 宏的参考代码：</p>
<p>#define log(frm, args&hellip;) {<br>
printf(&quot;[%s : %d] &ldquo;,<strong>func</strong>,<strong>LINE</strong>); \<br>
printf(frm, args); \<br>
}</p>
<p>正如你看到的，log 宏的定义中，使用了编写多行宏的技巧，就是在行尾添加反斜杠，以达到增强代码可读性的目的。然后 log 宏中，包含两个 printf 输出语句，第一个 printf 语句，输出函数以及代码位置信息；第二个 printf 语句，输出 log 宏所接收的内容。</p>
<p>至此，我们看似完成了最初的任务，可不要高兴太早，所有与宏相关的东西，都没那么简单。上面的这个实现，其实是有 Bug，不信的话，你就在你的环境中，尝试像如下代码一样调用 log 宏：</p>
<p>log(&ldquo;hello world\n&rdquo;);</p>
<p>这个就是今天给你留的最后一个需要自己独立解决的小 Bug，记住，勤用及善用搜索引擎，会大大提升你的学习效率和效果。至于如何方便的开关日志输出，参考今天的条件编译，思考一下，我相信这个难不倒你。</p>
<h2 id="课程小结">课程小结</h2>
<p>通过这个任务呢，我们大体的认识了预处理命令家族，算是全方位地了解了宏及条件编译相关的内容。下面呢，我来给你做一下今天这节课的课程小结：</p>
<ol>
<li>宏定义只占用一行代码，为了增强宏定义的代码可读性，我们可以采用在行尾加反斜杠的技巧，来使得上下两行代码，变成编译器眼中的一行代码。</li>
<li>宏的作用，就是替换，要想理解最终的代码行为，必须从宏替换以后的代码入手分析。</li>
<li>条件编译相当于一种预处理阶段的代码剪裁技巧。</li>
<li>编译器预设的宏，有标准的，也有非标准的，非标准的代码会影响其可移植性。</li>
</ol>
<p>至此，我们就完成了“语言基础篇”的全部内容，从下一节开始呢，我们将进入注重培养编程思维“编码能力训练篇”的学习。届时，我们的学习更偏重于思维方式的训练和讲解，不会像语言基础篇一样，有这么多零零碎碎的知识点。我也相信，只要你勤于思考，就一定跟得上学习节奏。</p>
<p>好了，今天就到这里了，我是胡光，我们“编码能力训练篇”，不见不散。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E8%AF%BE/">人人都能学会的编程入门课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%B9%E9%87%8F%E4%BF%9D%E9%9A%9C%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/11__%E4%B8%8E%E6%97%B6%E4%BF%B1%E8%BF%9B%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B8%8B%E7%9A%84%E5%AE%B9%E9%87%8F%E4%BF%9D%E9%9A%9C%E6%96%B0%E8%B6%8B%E5%8A%BF/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">11__与时俱进：云原生下的容量保障新趋势</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B%E8%AF%BE/11__%E5%91%98%E5%B7%A5%E5%85%B3%E6%80%80%E5%8F%91%E8%87%AA%E5%86%85%E5%BF%83%E5%9C%B0%E5%85%B3%E5%BF%83%E4%BA%BA%E6%98%AF%E4%B8%80%E5%88%87%E7%9A%84%E5%9F%BA%E7%A1%80/">
            <span class="next-text nav-default">11__员工关怀：发自内心地关心人，是一切的基础</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
