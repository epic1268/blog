<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>做好闭环（二）：函数是压缩的数组，数组是展开的函数 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是胡光。
不知不觉，我们已经学完了语言基础篇的全部内容。其实还有很多东西想给你讲，可限于篇幅，所以咱们整个语言基础篇中的内容，都是那些，我认为你自学容易忽视的，容易学错的知识点。有道是，授之以鱼，不如授之以渔，我也相信只要你跟着课程学习，一定会感觉到自己收获到了“渔具”。如果能引发你的主动思考，进而触类旁通，举一反三，那这场学习过程就更加有意义啦。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E8%AF%BE/%E5%81%9A%E5%A5%BD%E9%97%AD%E7%8E%AF%E4%BA%8C%E5%87%BD%E6%95%B0%E6%98%AF%E5%8E%8B%E7%BC%A9%E7%9A%84%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E6%98%AF%E5%B1%95%E5%BC%80%E7%9A%84%E5%87%BD%E6%95%B0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E8%AF%BE/%E5%81%9A%E5%A5%BD%E9%97%AD%E7%8E%AF%E4%BA%8C%E5%87%BD%E6%95%B0%E6%98%AF%E5%8E%8B%E7%BC%A9%E7%9A%84%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E6%98%AF%E5%B1%95%E5%BC%80%E7%9A%84%E5%87%BD%E6%95%B0/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="做好闭环（二）：函数是压缩的数组，数组是展开的函数">
  <meta property="og:description" content="你好，我是胡光。
不知不觉，我们已经学完了语言基础篇的全部内容。其实还有很多东西想给你讲，可限于篇幅，所以咱们整个语言基础篇中的内容，都是那些，我认为你自学容易忽视的，容易学错的知识点。有道是，授之以鱼，不如授之以渔，我也相信只要你跟着课程学习，一定会感觉到自己收获到了“渔具”。如果能引发你的主动思考，进而触类旁通，举一反三，那这场学习过程就更加有意义啦。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="人人都能学会的编程入门课">

  <meta itemprop="name" content="做好闭环（二）：函数是压缩的数组，数组是展开的函数">
  <meta itemprop="description" content="你好，我是胡光。
不知不觉，我们已经学完了语言基础篇的全部内容。其实还有很多东西想给你讲，可限于篇幅，所以咱们整个语言基础篇中的内容，都是那些，我认为你自学容易忽视的，容易学错的知识点。有道是，授之以鱼，不如授之以渔，我也相信只要你跟着课程学习，一定会感觉到自己收获到了“渔具”。如果能引发你的主动思考，进而触类旁通，举一反三，那这场学习过程就更加有意义啦。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4335">
  <meta itemprop="keywords" content="人人都能学会的编程入门课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="做好闭环（二）：函数是压缩的数组，数组是展开的函数">
  <meta name="twitter:description" content="你好，我是胡光。
不知不觉，我们已经学完了语言基础篇的全部内容。其实还有很多东西想给你讲，可限于篇幅，所以咱们整个语言基础篇中的内容，都是那些，我认为你自学容易忽视的，容易学错的知识点。有道是，授之以鱼，不如授之以渔，我也相信只要你跟着课程学习，一定会感觉到自己收获到了“渔具”。如果能引发你的主动思考，进而触类旁通，举一反三，那这场学习过程就更加有意义啦。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">做好闭环（二）：函数是压缩的数组，数组是展开的函数</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4335 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#函数自己动手实现低配版-scanf-函数">函数：自己动手实现低配版 scanf 函数</a>
          <ul>
            <li></li>
          </ul>
        </li>
        <li><a href="#预处理命令必须掌握的黑魔法让编译器帮你写代码">预处理命令：必须掌握的“黑魔法”，让编译器帮你写代码</a>
          <ul>
            <li></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是胡光。</p>
<p>不知不觉，我们已经学完了语言基础篇的全部内容。其实还有很多东西想给你讲，可限于篇幅，所以咱们整个语言基础篇中的内容，都是那些，我认为你自学容易忽视的，容易学错的知识点。有道是，授之以鱼，不如授之以渔，我也相信只要你跟着课程学习，一定会感觉到自己收获到了“渔具”。如果能引发你的主动思考，进而触类旁通，举一反三，那这场学习过程就更加有意义啦。</p>
<p>我也非常高兴，看到很多同学都在紧跟着专栏更新节奏，坚持学习。每每在专栏上线的第一时间，这些同学就给我留言，提出自己的疑惑。大部分留言，我都在相对应的文章中回复过了，而对于文章中的思考题呢，由于要给你充足的思考时间，所以我选择在今天这样一篇文章中，给你进行一一的解答。</p>
<p>看一看我的参考答案，和你的思考结果之间，有什么不同吧。也欢迎你在留言区中，给出一些你感兴趣的题目的思考结果，我希望我们能在这个过程中，碰撞出更多智慧的火花。</p>
<h2 id="函数自己动手实现低配版-scanf-函数">函数：自己动手实现低配版 scanf 函数</h2>
<p>在这一节里面呢《函数：自己动手实现低配版 scanf 函数》，我们讲了函数的基本概念，明确了“实参”和“形参”两个概念，并且知道了函数传参的过程，就是“实参”给“形参”赋值的过程。</p>
<p>还有，我们介绍了“传入参数”和“传出参数”两个概念，弄懂这两个概念，对于设计一个函数来说，还是非常重要的。“传入参数”是从外部，传入到函数内部，影响函数内部执行逻辑的参数，“传出参数”呢，就是由函数内部，传出到函数外部的参数，一般是以传送地址为主要形式。</p>
<p>最后呢，我留了两个开放性的思考题，我选择其中一个你可能会不知所措的题目，来讲解一下如何完成这个题目。下面就看看我的答案吧。</p>
<h4 id="思考题1数组和函数的思考">思考题（1）：数组和函数的思考</h4>
<p>关于这个问题呢，我们首先来具象化一下，我们设想一种具体的问题情况，比如说：arr 数组里面，arr[i] 存储的是 2 * i 的值，你可以认为是第 i 个偶数的值；func 函数的功能呢，func(x) = 2*x，就是计算得到第 x 个偶数的值。如下述示意代码所示：</p>
<p>int arr[100] = {0, 2, 4, 6, 8, 10, &hellip;};<br>
int func(int x) {<br>
return 2 * x;<br>
}</p>
<p>解析这个示例代码，我们先从数组 arr 和函数 func 的不同处开始说起。</p>
<p>很明显，两者的本质不一样，arr 是数组，对于代码 arr[36]，相当于访问数组下标 36 的位置中存储的值；而 func 是函数，对于代码 func(36) 来说，也会得到一个整型值，但是这个整型值，却是由 func 的函数逻辑代码计算得到的。简单来说，就是对于 arr 中的值进行访问，是一个静态的过程，而对于 func 函数得到返回值的过程来说，是一个动态计算的过程。</p>
<p>我们再来看看两者的时间和空间效率，也就是代码运行速度以及所需要的存储空间之间的比较。</p>
<ol>
<li>关于时间效率方面，通常来说是数组访问速度要比函数计算速度快很多。</li>
<li>而空间效率的话，函数通常要比数组节省很多存储空间，就像 func 函数的值，是动态计算得到的，通常情况下，不管我们代码中执行 func(100) 还是 func(10000)，我们不需要修改函数的代码。但对于 arr 数组来说，当我们需要访问 arr[100] 的时候，数组最起码要有 101 个元素空间，而当我们想要访问 arr[10000] 的时候，数组最起码要有 10001 个元素空间。总的来说，就是函数比数组更加节省空间，数组比函数呢，得到结果的速度更快。</li>
</ol>
<p>说完二者的不同以后，我们再来看看二者的相同之处。</p>
<p>站在使用者的角度来看，当你盯着 arr[100] 和 func(100) 这两段代码看的时候，你没觉得这两个代码的异常的相似？func 和 arr 就是名字不一样，如果这个时候我将 func 后面的小括号换成中括号，你是不是就会觉得 func 是一个数组？</p>
<p>对！你可能发现了，在使用者看来，func(100) 和 arr[100] 的作用是完全一样的，区别可能只是中括号和小括号的区别。你不觉得站在使用者的角度，考虑这个问题很有趣么？本质区别很大的两个东西，一个函数，一个数组，突然发现它俩的区别根本没有那么大。</p>
<p>简单来说，就是在数学里，函数做的事情就是“映射”，传入一个值，传出一个值。在程序中也不例外，函数做的事情，就是从传入值到传出值的映射。而数组做的事情呢，其实是从下标到存储值的映射。你会发现，数组和函数做的事情，本质上都是映射！</p>
<p>最后，我来总结一下，这个总结讲对你日后的程序设计思维有巨大的帮助，这句话就是“<strong>函数是压缩的数组，数组是展开的函数</strong>”，也就是说当你可以用数组进行程序的时候，你也可以使用某个能够完成相同映射功能的函数来进行替代。</p>
<p>二者在程序设计方面的差别，就在于时间和空间的使用效率，数组在时间效率方面占优势，函数在空间效率方面占优势。当你理解了这些事情以后，你就可以更好的理解某些资料里面经常讲的“<strong>时间换空间</strong>”或者“<strong>空间换时间</strong>”的概念了。你现在可以简单的理解成为是数组思维和函数思维之间的互相转换。</p>
<h2 id="预处理命令必须掌握的黑魔法让编译器帮你写代码">预处理命令：必须掌握的“黑魔法”，让编译器帮你写代码</h2>
<p>关于预处理命令这个知识点，我们用了两节课的篇幅来讲解，《预处理命令（上）：必须掌握的“黑魔法”，让编译器帮你写代码》 和《预处理命令（下）：必须掌握的“黑魔法”，让编译器帮你写代码》。其中讲了两种使用比较多的预处理命令，宏定义和条件编译。并且强调了，宏定义就是做简单替换，条件编译做的事情，就是代码剪裁，根据条件是否成立，决定哪段代码最终留在“待编译源码”中。</p>
<p>其中，用户 @一步 问到：有没有什么办法可以看到预处理阶段后的待编译源代码的内容？这个应该是很多小伙伴的共同问题吧，在这里我就来讲一下。</p>
<p>在 Linux/Mac 的编程环境下呢，操作比较简单，原本的程序编译命令是 gcc 加源文件名，如果你想看到待编译源码的内容，你只需要在中间加一个 -E 编译选项即可，例如：gcc -E test.c。如果你用的是集成开发环境，那你就需要自己搜索解决办法了，你可以搜索关键词如：XXX 下如何查看宏展开内容。XXX 就代表了你的集成开发环境。</p>
<p>对于课后的思考题，这里必须为用户 @Geek_Andy_Lee00 和 用户 @Aaren Shan 的回答点赞。答案虽然不是很完美，可我想说，答案不重要，重要的是思考过程。下面就来看看我给出的参考答案吧。</p>
<h4 id="思考题没有-bug-的-max-宏">思考题：没有 Bug 的 MAX 宏</h4>
<p>就像之前所说的，对于这个问题呢，能否满分通过，是不重要的，重要的是你在解决这个问题过程中遇到的一个又一个 Bug，以及你对于这些 Bug 的思考过程。下面我就将带你一步一步地解决，这个问题中，你可能遇到的几个典型的 Bug，以及解决办法。</p>
<p>首先，让我们先对样例输出的每一行编上序号，如下所示：</p>
<p>①：MAX(2, 3) = 3<br>
②：5 + MAX(2, 3) = 8<br>
③：MAX(2, MAX(3, 4)) = 4<br>
④：MAX(2, 3 &gt; 4 ? 3 : 4) = 4<br>
⑤：MAX(a++, 5) = 6<br>
⑥：a = 7</p>
<p>我们先来实现一个最简单的 MAX 宏，如下所示：</p>
<p>#define MAX(a, b) a &gt; b ? a : b</p>
<p>如上所示，MAX 宏的实现，利用了三目运算符，问号冒号表达式，a &gt; b 条件如果成立，表达式的值等于 a 的值，否则等于 b 的值。看似没问题，但如果你要是运行代码，你会发现，程序的输出可能会如下所示：</p>
<p>MAX(2, 3) = 3<br>
❌5 + MAX(2, 3) = 2<br>
❌MAX(2, MAX(3, 4)) = 2<br>
❌MAX(2, 3 &gt; 4 ? 3 : 4) = 2<br>
❌MAX(a++, 5) = 7<br>
❌a = 8</p>
<p>你会发现，这种实现，只有第一行是对的，其余几行都是错的。我们就来首先分析一下第 3 行到底是什么错误。按照宏展开的替换原则，最外层的 MAX 宏会被替换成：2 &gt; MAX(3, 4) ? 2 : MAX(3, 4)。然后我们再将里面的 MAX(3, 4) 宏展开，就变成了：</p>
<p>2 &gt; 3 &gt; 4 ? 3 : 4 ? 2 : 3 &gt; 4 ? 3 : 4</p>
<p>这段表达式代码，看着有点儿乱，别急，我来帮你分析。首先我们从左向右看，先分离出来第一个问号冒号表达式的结构：</p>
<p>(2 &gt; 3 &gt; 4) ? (3) : (4 ? 2 : 3 &gt; 4 ? 3 : 4)</p>
<p>我们看到在这个里面，第一部分 2 &gt; 3 &gt; 4 是条件；第二部分 3 是在表达式为真时候的返回值；第三部分，是包含两个问号冒号表达式结构的式子。我们继续对第三部分进行拆解：</p>
<p>(4) ? (2) : (3 &gt; 4 ? 3 : 4)</p>
<p>继续拆解后，我们发现，第一部分 4 是条件；第二部分的 2 是表达式为真时的返回值；第三部分，就是一个单独的问号冒号表达式。拆解到现在为止，已经不需要再继续拆解了。</p>
<p>要想理解原表达式，我们需要先了解 2 &gt; 3 &gt; 4 这个“惨无人道”的表达式的值。这个表达式，从左向右执行，首先执行 2 &gt; 3 这个条件表达式的判断。之前我们讲过，条件表达式的值，只有 1 和 0，那么 2 &gt; 3 这个表达式的值，显然是 0，之后其实是在做 0 &gt; 4 的判断，结果也是 0。</p>
<p>所以 2 &gt; 3 &gt; 4 这个表达式的值，就是 0，也就是假值，代表条件不成立，之后的事情，就是转到了两个问号冒号表达式的部分，剩下的事情，你自己就可以理解，最终原表达式的值为什么是 2 了。</p>
<p>理解了原表达式值计算的原理以后，下面让我们来分析一下，为什么会出现这种问题。本质原因，就在于我们实现的宏中，参数 a，b 原本都是独立的表达式部分，而我们却简单的把它们放到问号冒号表达式中，导致展开以后的内容前后连接到一起后，改变了原本我们想要的计算顺序。</p>
<p>所以针对这种情况，我们在实现宏的时候，可以给每个参数部分，都加上一个括号，就变成了如下所示的实现方式：</p>
<p>#define MAX(a, b) (a) &gt; (b) ? (a) : (b)</p>
<p>至此，你就会得到如下的输出：</p>
<p>MAX(2, 3) = 3<br>
❌5 + MAX(2, 3) = 2<br>
MAX(2, MAX(3, 4)) = 4<br>
MAX(2, 3 &gt; 4 ? 3 : 4) = 4<br>
❌MAX(a++, 5) = 7<br>
❌a = 8</p>
<p>在这份输出中，第 1 行、第 3 行、第 4 行均已正确。如果你自己，仿照我上面说的方式对第二行内容的输出，加以分析，你一定可以知道如何修正第 2 行的结果错误。如果你努力以后，还是想不到的话，可以参考用户 @Aaren Shan 的留言。这样做以后呢，你程序的输出，就会变成如下输出：</p>
<p>MAX(2, 3) = 3<br>
5 + MAX(2, 3) = 8<br>
MAX(2, MAX(3, 4)) = 4<br>
MAX(2, 3 &gt; 4 ? 3 : 4) = 4<br>
❌MAX(a++, 5) = 7<br>
❌a = 8</p>
<p>其中还是有两行是错误的，你如果试着展开第 5 行的宏，你会得到如下的代码：</p>
<p>a++ &gt; 5 ? a++ : 5</p>
<p>在这行代码中，如果 a++ 表达式的值真的大于 5 的话，那么 a++ 就会被执行两次。而原本使用者的意图，是执行一次 a++，如何让 a++ 只执行一次呢？这需要用到之前我跟你提过的 __typeof 相关的技巧了，下面是我给你准备的参考代码：</p>
<p>#define MAX(a, b) ({ \<br>
__typeof(a) __a = (a), __b = (b); \<br>
__a &gt; __b ? __a : __b; \<br>
})</p>
<p>在这段代码中，我们定义了两个中间变量，__a 和 __b 用来存储宏参数中 a 和 b 部分的原本的值，之后判断大小的部分呢，我们使用新的变量 __a 和 __b 即可。</p>
<p>这段代码中，我们看到了，无论是 a 部分，还是 b 部分的表达式，只被使用了一次，也就保证了只被计算了一次。而这个里面，用小括号括起来了大括号，实际作用是把一个代码段，变成一个表达式。根据任何表达式都有值的特性，这个代码段表达式的值，等于其中最后一行代码表达式的值，也就是等于最后那行问号冒号表达式的值。</p>
<p>第 6 行的错误，其实和第 5 行的一样，解决了第 5 行的错误，这一行的 Bug 也就解了。</p>
<p>至此，我们就几乎完美地解决了 MAX 宏的问题了。通过这个问题，你会看到，预处理命令虽然强大，可你需要拥有掌握这种强大的力量。这份力量，包括了你的基础知识储量，还包括了你严谨的思维逻辑。</p>
<p>想要掌握强大，必先变得强大，记住，一步一个脚印，才是最快、最靠谱的成长路线，学习过程中，没有捷径。</p>
<p>好了今天的思考题答疑就结束了，如果你还有什么不清楚的，或者有更好的想法的，欢迎告诉我，我们留言区见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E8%AF%BE/">人人都能学会的编程入门课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%80%BB%E7%BB%93%E8%AF%BE__%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9D%83%E8%A1%A1%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">总结课__在实际开发中，如何权衡选择使用哪种数据结构和算法？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E8%AF%BE/%E5%81%9A%E5%A5%BD%E9%97%AD%E7%8E%AF%E4%B8%89%E7%BC%96%E7%A0%81%E8%83%BD%E5%8A%9B%E8%AE%AD%E7%BB%83%E7%AF%87%E7%9A%84%E6%80%9D%E8%80%83%E9%A2%98%E7%AD%94%E6%A1%88%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E5%95%A6/">
            <span class="next-text nav-default">做好闭环（三）：编码能力训练篇的思考题答案都在这里啦！</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
