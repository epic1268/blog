<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>01｜Spring_Bean_定义常见错误 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是傅健。
从导读中我们已知，Spring 的核心是围绕 Bean 进行的。不管是 Spring Boot 还是 Spring Cloud，只要名称中带有 Spring 关键字的技术都脱离不了 Bean，而要使用一个 Bean 少不了要先定义出来，所以定义一个 Bean 就变得格外重要了。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/01spring_bean_%E5%AE%9A%E4%B9%89%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/01spring_bean_%E5%AE%9A%E4%B9%89%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="01｜Spring_Bean_定义常见错误">
  <meta property="og:description" content="你好，我是傅健。
从导读中我们已知，Spring 的核心是围绕 Bean 进行的。不管是 Spring Boot 还是 Spring Cloud，只要名称中带有 Spring 关键字的技术都脱离不了 Bean，而要使用一个 Bean 少不了要先定义出来，所以定义一个 Bean 就变得格外重要了。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Spring编程常见错误50例">

  <meta itemprop="name" content="01｜Spring_Bean_定义常见错误">
  <meta itemprop="description" content="你好，我是傅健。
从导读中我们已知，Spring 的核心是围绕 Bean 进行的。不管是 Spring Boot 还是 Spring Cloud，只要名称中带有 Spring 关键字的技术都脱离不了 Bean，而要使用一个 Bean 少不了要先定义出来，所以定义一个 Bean 就变得格外重要了。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5527">
  <meta itemprop="keywords" content="Spring编程常见错误50例">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="01｜Spring_Bean_定义常见错误">
  <meta name="twitter:description" content="你好，我是傅健。
从导读中我们已知，Spring 的核心是围绕 Bean 进行的。不管是 Spring Boot 还是 Spring Cloud，只要名称中带有 Spring 关键字的技术都脱离不了 Bean，而要使用一个 Bean 少不了要先定义出来，所以定义一个 Bean 就变得格外重要了。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">01｜Spring_Bean_定义常见错误</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5527 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#案例-1隐式扫描不到-bean-的定义">案例 1：隐式扫描不到 Bean 的定义</a>
          <ul>
            <li><a href="#案例解析">案例解析</a></li>
            <li><a href="#问题修正">问题修正</a></li>
          </ul>
        </li>
        <li><a href="#案例-2定义的-bean-缺少隐式依赖">案例 2：定义的 Bean 缺少隐式依赖</a>
          <ul>
            <li><a href="#案例解析-1">案例解析</a></li>
            <li><a href="#问题修正-1">问题修正</a></li>
          </ul>
        </li>
        <li><a href="#案例-3原型-bean-被固定">案例 3：原型 Bean 被固定</a>
          <ul>
            <li><a href="#案例解析-2">案例解析</a></li>
            <li><a href="#问题修正-2">问题修正</a></li>
          </ul>
        </li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是傅健。</p>
<p>从导读中我们已知，Spring 的核心是围绕 Bean 进行的。不管是 Spring Boot 还是 Spring Cloud，只要名称中带有 Spring 关键字的技术都脱离不了 Bean，而要使用一个 Bean 少不了要先定义出来，所以<strong>定义一个 Bean 就变得格外重要了</strong>。</p>
<p>当然，对于这么重要的工作，Spring 自然给我们提供了很多简单易用的方式。然而，这种简单易用得益于 Spring 的“<strong>约定大于配置</strong>”，但我们往往不见得会对所有的约定都了然于胸，所以仍然会在 Bean 的定义上犯一些经典的错误。</p>
<p>接下来我们就来了解下那些经典错误以及它们背后的原理，你也可以对照着去看看自己是否也曾犯过，后来又是如何解决的。</p>
<h2 id="案例-1隐式扫描不到-bean-的定义">案例 1：隐式扫描不到 Bean 的定义</h2>
<p>在构建 Web 服务时，我们常使用 Spring Boot 来快速构建。例如，使用下面的包结构和相关代码来完成一个简易的 Web 版 HelloWorld：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/f405fb2f0229d6b88920ce8002559d99.png" alt=""></p>
<p>其中，负责启动程序的 Application 类定义如下：</p>
<p>package com.spring.puzzle.class1.example1.application<br>
//省略 import<br>
@SpringBootApplication<br>
public class Application {<br>
public static void main(String[] args) {<br>
SpringApplication.run(Application.class, args);<br>
}<br>
}</p>
<p>提供接口的 HelloWorldController 代码如下：</p>
<p>package com.spring.puzzle.class1.example1.application<br>
//省略 import<br>
@RestController<br>
public class HelloWorldController {<br>
@RequestMapping(path = &ldquo;hi&rdquo;, method = RequestMethod.GET)<br>
public String hi(){<br>
return &ldquo;helloworld&rdquo;;<br>
};<br>
}</p>
<p>上述代码即可实现一个简单的功能：访问http://localhost:8080/hi 返回 helloworld。两个关键类位于同一个包（即 application）中。其中 HelloWorldController 因为添加了 @RestController，最终被识别成一个 Controller 的 Bean。</p>
<p>但是，假设有一天，当我们需要添加多个类似的 Controller，同时又希望用更清晰的包层次和结构来管理时，我们可能会去单独建立一个独立于 application 包之外的 Controller 包，并调整类的位置。调整后结构示意如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/2b19501fe1c82aeffc20c7ba3e57b8a1.png" alt=""></p>
<p>实际上，我们没有改变任何代码，只是改变了包的结构，但是我们会发现这个 Web 应用失效了，即不能识别出 HelloWorldController 了。也就是说，我们找不到 HelloWorldController 这个 Bean 了。这是为何？</p>
<h3 id="案例解析">案例解析</h3>
<p>要了解 HelloWorldController 为什么会失效，就需要先了解之前是如何生效的。对于 Spring Boot 而言，关键点在于 Application.java 中使用了 SpringBootApplication 注解。而这个注解继承了另外一些注解，具体定义如下：</p>
<p>@Target(ElementType.TYPE)<br>
@Retention(RetentionPolicy.RUNTIME)<br>
@Documented<br>
@Inherited<br>
@SpringBootConfiguration<br>
@EnableAutoConfiguration<br>
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),<br>
@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })<br>
public @interface SpringBootApplication {<br>
//省略非关键代码<br>
}</p>
<p>从定义可以看出，SpringBootApplication 开启了很多功能，其中一个关键功能就是 ComponentScan，参考其配置如下：</p>
<blockquote>
<p>@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class)</p>
</blockquote>
<p>当 Spring Boot 启动时，ComponentScan 的启用意味着会去扫描出所有定义的 Bean，那么扫描什么位置呢？这是由 ComponentScan 注解的 basePackages 属性指定的，具体可参考如下定义：</p>
<p>public @interface ComponentScan {</p>
<p>/**</p>
<ul>
<li>Base packages to scan for annotated components.</li>
<li>
<p>{@link #value} is an alias for (and mutually exclusive with) this  
</li>
<li>attribute.</li>
<li>
<p>Use {@link #basePackageClasses} for a type-safe alternative to  
</li>
<li>String-based package names.<br>
*/<br>
@AliasFor(&ldquo;value&rdquo;)<br>
String[] basePackages() default {};<br>
//省略其他非关键代码<br>
}</li>
</ul>
<p>而在我们的案例中，我们直接使用的是 SpringBootApplication 注解定义的 ComponentScan，它的 basePackages 没有指定，所以默认为空（即{}）。此时扫描的是什么包？这里不妨带着这个问题去调试下（调试位置参考 ComponentScanAnnotationParser#parse 方法），调试视图如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/a833687991ee17e9e9f484432f25abb7.png" alt=""></p>
<p>从上图可以看出，当 basePackages 为空时，扫描的包会是 declaringClass 所在的包，在本案例中，declaringClass 就是 Application.class，所以扫描的包其实就是它所在的包，即 com.spring.puzzle.class1.example1.application。</p>
<p>对比我们重组包结构前后，我们自然就找到了这个问题的根源：在调整前，HelloWorldController 在扫描范围内，而调整后，它已经远离了扫描范围（不和 Application.java 一个包了），虽然代码没有一丝丝改变，但是这个功能已经失效了。</p>
<p>所以，综合来看，这个问题是因为我们不够了解 Spring Boot 的默认扫描规则引起的。我们仅仅享受了它的便捷，但是并未了解它背后的故事，所以稍作变化，就可能玩不转了。</p>
<h3 id="问题修正">问题修正</h3>
<p>针对这个案例，有了源码的剖析，我们可以快速找到解决方案了。当然了，我们所谓的解决方案肯定不是说把 HelloWorldController 移动回原来的位置，而是<strong>真正去满足需求</strong>。在这里，真正解决问题的方式是显式配置 @ComponentScan。具体修改方式如下：</p>
<p>@SpringBootApplication<br>
@ComponentScan(&ldquo;com.spring.puzzle.class1.example1.controller&rdquo;)<br>
public class Application {<br>
public static void main(String[] args) {<br>
SpringApplication.run(Application.class, args);<br>
}<br>
}</p>
<p>通过上述修改，我们显式指定了扫描的范围为 com.spring.puzzle.class1.example1.controller。不过需要注意的是，显式指定后，默认的扫描范围（即 com.spring.puzzle.class1.example1.application）就不会被添加进去了。另外，我们也可以使用 @ComponentScans 来修复问题，使用方式如下：</p>
<blockquote>
<p>@ComponentScans(value = { @ComponentScan(value = &ldquo;com.spring.puzzle.class1.example1.controller&rdquo;) })</p>
</blockquote>
<p>顾名思义，可以看出 ComponentScans 相比较 ComponentScan 多了一个 s，支持多个包的扫描范围指定。</p>
<p>此时，细心的你可能会发现：如果对源码缺乏了解，很容易会顾此失彼。以 ComponentScan 为例，原有的代码扫描了默认包而忽略了其它包；而<strong>一旦显式指定其它包，原来的默认扫描包就被忽略了。</strong></p>
<h2 id="案例-2定义的-bean-缺少隐式依赖">案例 2：定义的 Bean 缺少隐式依赖</h2>
<p>初学 Spring 时，我们往往不能快速转化思维。例如，在程序开发过程中，有时候，一方面我们把一个类定义成 Bean，同时又觉得这个 Bean 的定义除了加了一些 Spring 注解外，并没有什么不同。所以在后续使用时，有时候我们会不假思索地去随意定义它，例如我们会写出下面这样的代码：</p>
<p>@Service<br>
public class ServiceImpl {</p>
<pre><code>private String serviceName;  

public ServiceImpl(String serviceName){  
    this.serviceName = serviceName;  
}  
</code></pre>
<p>}</p>
<p>ServiceImpl 因为标记为 @Service 而成为一个 Bean。另外我们 ServiceImpl 显式定义了一个构造器。但是，上面的代码不是永远都能正确运行的，有时候会报下面这种错误：</p>
<blockquote>
<p>Parameter 0 of constructor in com.spring.puzzle.class1.example2.ServiceImpl required a bean of type &lsquo;java.lang.String&rsquo; that could not be found.</p>
</blockquote>
<p>那这种错误是怎么发生的呢？下面我们来分析一下。</p>
<h3 id="案例解析-1">案例解析</h3>
<p>当创建一个 Bean 时，调用的方法是 AbstractAutowireCapableBeanFactory#createBeanInstance。它主要包含两大基本步骤：寻找构造器和通过反射调用构造器创建实例。对于这个案例，最核心的代码执行，你可以参考下面的代码片段：</p>
<p>// Candidate constructors for autowiring?<br>
Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);<br>
if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||<br>
mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {<br>
return autowireConstructor(beanName, mbd, ctors, args);<br>
}</p>
<p>Spring 会先执行 determineConstructorsFromBeanPostProcessors 方法来获取构造器，然后通过 autowireConstructor 方法带着构造器去创建实例。很明显，在本案例中只有一个构造器，所以非常容易跟踪这个问题。</p>
<p>autowireConstructor 方法要创建实例，不仅需要知道是哪个构造器，还需要知道构造器对应的参数，这点从最后创建实例的方法名也可以看出，参考如下（即 ConstructorResolver#instantiate）：</p>
<p>private Object instantiate(<br>
String beanName, RootBeanDefinition mbd, Constructor<?> constructorToUse, Object[] argsToUse)</p>
<p>那么上述方法中存储构造参数的 argsToUse 如何获取呢？换言之，当我们已经知道构造器 ServiceImpl(String serviceName)，要创建出 ServiceImpl 实例，如何确定 serviceName 的值是多少？</p>
<p>很明显，这里是在使用 Spring，我们<strong>不能直接显式使用 new 关键字来创建实例</strong>。Spring 只能是去寻找依赖来作为构造器调用参数。</p>
<p>那么这个参数如何获取呢？可以参考下面的代码片段（即 ConstructorResolver#autowireConstructor）：</p>
<p>argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,<br>
getUserDeclaredConstructor(candidate), autowiring, candidates.length == 1);</p>
<p>我们可以调用 createArgumentArray 方法来构建调用构造器的参数数组，而这个方法的最终实现是从 BeanFactory 中获取 Bean，可以参考下述调用：</p>
<p>return this.beanFactory.resolveDependency(<br>
new DependencyDescriptor(param, true), beanName, autowiredBeanNames, typeConverter);</p>
<p>如果用调试视图，我们则可以看到更多的信息：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/5b8e7dce12378b872ac0f6fb788a5244.png" alt=""></p>
<p>如图所示，上述的调用即是根据参数来寻找对应的 Bean，在本案例中，如果找不到对应的 Bean 就会抛出异常，提示装配失败。</p>
<h3 id="问题修正-1">问题修正</h3>
<p>从源码级别了解了错误的原因后，现在反思为什么会出现这个错误。追根溯源，正如开头所述，因为不了解很多隐式的规则：我们定义一个类为 Bean，如果再显式定义了构造器，那么这个 Bean 在构建时，会自动根据构造器参数定义寻找对应的 Bean，然后反射创建出这个 Bean。</p>
<p>了解了这个隐式规则后，解决这个问题就简单多了。我们可以直接定义一个能让 Spring 装配给 ServiceImpl 构造器参数的 Bean，例如定义如下：</p>
<p>//这个 bean 装配给 ServiceImpl 的构造器参数“serviceName”<br>
@Bean<br>
public String serviceName(){<br>
return &ldquo;MyServiceName&rdquo;;<br>
}</p>
<p>再次运行程序，发现一切正常了。</p>
<p>所以，我们在使用 Spring 时，<strong>不要总想着定义的 Bean 也可以在非 Spring 场合直接用 new 关键字显式使用，这种思路是不可取的</strong>。</p>
<p>另外，类似的，假设我们不了解 Spring 的隐式规则，在修正问题后，我们可能写出更多看似可以运行的程序，代码如下：</p>
<p>@Service<br>
public class ServiceImpl {<br>
private String serviceName;<br>
public ServiceImpl(String serviceName){<br>
this.serviceName = serviceName;<br>
}<br>
public ServiceImpl(String serviceName, String otherStringParameter){<br>
this.serviceName = serviceName;<br>
}<br>
}</p>
<p>如果我们仍用非 Spring 的思维去审阅这段代码，可能不会觉得有什么问题，毕竟 String 类型可以自动装配了，无非就是增加了一个 String 类型的参数而已。</p>
<p>但是如果你了解 Spring 内部是用反射来构建 Bean 的话，就不难发现问题所在：存在两个构造器，都可以调用时，到底应该调用哪个呢？最终 Spring 无从选择，只能尝试去调用默认构造器，而这个默认构造器又不存在，所以测试这个程序它会出错。</p>
<h2 id="案例-3原型-bean-被固定">案例 3：原型 Bean 被固定</h2>
<p>接下来，我们再来看另外一个关于 Bean 定义不生效的案例。在定义 Bean 时，有时候我们会使用原型 Bean，例如定义如下：</p>
<p>@Service<br>
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)<br>
public class ServiceImpl {<br>
}</p>
<p>然后我们按照下面的方式去使用它：</p>
<p>@RestController<br>
public class HelloWorldController {</p>
<pre><code>@Autowired  
private ServiceImpl serviceImpl;  

@RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)  
public String hi(){  
     return &quot;helloworld, service is : &quot; + serviceImpl;  
};  
</code></pre>
<p>}</p>
<p>结果，我们会发现，不管我们访问多少次http://localhost:8080/hi，访问的结果都是不变的，如下：</p>
<blockquote>
<p>helloworld, service is : com.spring.puzzle.class1.example3.error.ServiceImpl@4908af</p>
</blockquote>
<p>很明显，这很可能和我们定义 ServiceImpl 为原型 Bean 的初衷背道而驰，如何理解这个现象呢？</p>
<h3 id="案例解析-2">案例解析</h3>
<p>当一个属性成员 serviceImpl 声明为 @Autowired 后，那么在创建 HelloWorldController 这个 Bean 时，会先使用构造器反射出实例，然后来装配各个标记为 @Autowired 的属性成员（装配方法参考 AbstractAutowireCapableBeanFactory#populateBean）。</p>
<p>具体到执行过程，它会使用很多 BeanPostProcessor 来做完成工作，其中一种是 AutowiredAnnotationBeanPostProcessor，它会通过 DefaultListableBeanFactory#findAutowireCandidates 寻找到 ServiceImpl 类型的 Bean，然后设置给对应的属性（即 serviceImpl 成员）。</p>
<p>关键执行步骤可参考 AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject：</p>
<p>protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {<br>
Field field = (Field) this.member;<br>
Object value;<br>
//寻找“bean”<br>
if (this.cached) {<br>
value = resolvedCachedArgument(beanName, this.cachedFieldValue);<br>
}<br>
else {<br>
//省略其他非关键代码<br>
value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);<br>
}<br>
if (value != null) {<br>
//将 bean 设置给成员字段<br>
ReflectionUtils.makeAccessible(field);<br>
field.set(bean, value);<br>
}<br>
}</p>
<p>待我们寻找到要自动注入的 Bean 后，即可通过反射设置给对应的 field。这个 field 的执行只发生了一次，所以后续就固定起来了，它并不会因为 ServiceImpl 标记了 SCOPE_PROTOTYPE 而改变。</p>
<p>所以，<strong>当一个单例的 Bean，使用 autowired 注解标记其属性时，你一定要注意这个属性值会被固定下来。</strong></p>
<h3 id="问题修正-2">问题修正</h3>
<p>通过上述源码分析，我们可以知道要修正这个问题，肯定是不能将 ServiceImpl 的 Bean 固定到属性上的，而应该是每次使用时都会重新获取一次。所以这里我提供了两种修正方式：</p>
<p><strong>1. 自动注入 Context</strong></p>
<p>即自动注入 ApplicationContext，然后定义 getServiceImpl() 方法，在方法中获取一个新的 ServiceImpl 类型实例。修正代码如下：</p>
<p>@RestController<br>
public class HelloWorldController {</p>
<pre><code>@Autowired  
private ApplicationContext applicationContext;  

@RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)  
public String hi(){  
     return &quot;helloworld, service is : &quot; + getServiceImpl();  
};  

public ServiceImpl getServiceImpl(){  
    return applicationContext.getBean(ServiceImpl.class);  
}  
</code></pre>
<p>}</p>
<p><strong>2. 使用 Lookup 注解</strong></p>
<p>类似修正方法 1，也添加一个 getServiceImpl 方法，不过这个方法是被 Lookup 标记的。修正代码如下：</p>
<p>@RestController<br>
public class HelloWorldController {</p>
<pre><code>@RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)  
public String hi(){  
     return &quot;helloworld, service is : &quot; + getServiceImpl();  
};  

@Lookup  
public ServiceImpl getServiceImpl(){  
    return null;  
}    
</code></pre>
<p>}</p>
<p>通过这两种修正方式，再次测试程序，我们会发现结果已经符合预期（每次访问这个接口，都会创建新的 Bean）。</p>
<p>这里我们不妨再拓展下，讨论下 Lookup 是如何生效的。毕竟在修正代码中，我们看到 getServiceImpl 方法的实现返回值是 null，这或许很难说服自己。</p>
<p>首先，我们可以通过调试方式看下方法的执行，参考下图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/3b40969856f434cab56fbcb64ad285d1.png" alt=""></p>
<p>从上图我们可以看出，我们最终的执行因为标记了 Lookup 而走入了 CglibSubclassingInstantiationStrategy.LookupOverrideMethodInterceptor，这个方法的关键实现参考 LookupOverrideMethodInterceptor#intercept：</p>
<p>private final BeanFactory owner;</p>
<p>public Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {<br>
LookupOverride lo = (LookupOverride) getBeanDefinition().getMethodOverrides().getOverride(method);<br>
Assert.state(lo != null, &ldquo;LookupOverride not found&rdquo;);<br>
Object[] argsToUse = (args.length &gt; 0 ? args : null);  // if no-arg, don&rsquo;t insist on args at all<br>
if (StringUtils.hasText(lo.getBeanName())) {<br>
return (argsToUse != null ? this.owner.getBean(lo.getBeanName(), argsToUse) :<br>
this.owner.getBean(lo.getBeanName()));<br>
}<br>
else {<br>
return (argsToUse != null ? this.owner.getBean(method.getReturnType(), argsToUse) :<br>
this.owner.getBean(method.getReturnType()));<br>
}<br>
}</p>
<p>我们的方法调用最终并没有走入案例代码实现的 return null 语句，而是通过 BeanFactory 来获取 Bean。所以从这点也可以看出，其实<strong>在我们的 getServiceImpl 方法实现中，随便怎么写都行，这不太重要。</strong></p>
<p>例如，我们可以使用下面的实现来测试下这个结论：</p>
<p>@Lookup<br>
public ServiceImpl getServiceImpl(){<br>
//下面的日志会输出么？<br>
log.info(&ldquo;executing this method&rdquo;);<br>
return null;<br>
}</p>
<p>以上代码，添加了一行代码输出日志。测试后，我们会发现并没有日志输出。这也验证了，当使用 Lookup 注解一个方法时，这个方法的具体实现已并不重要。</p>
<p>再回溯下前面的分析，为什么我们走入了 CGLIB 搞出的类，这是因为我们有方法标记了 Lookup。我们可以从下面的这段代码得到验证，参考 SimpleInstantiationStrategy#instantiate：</p>
<p>@Override<br>
public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {<br>
// Don&rsquo;t override the class with CGLIB if no overrides.<br>
if (!bd.hasMethodOverrides()) {<br>
//<br>
return BeanUtils.instantiateClass(constructorToUse);<br>
}<br>
else {<br>
// Must generate CGLIB subclass.<br>
return instantiateWithMethodInjection(bd, beanName, owner);<br>
}<br>
}</p>
<p>在上述代码中，当 hasMethodOverrides 为 true 时，则使用 CGLIB。而在本案例中，这个条件的成立在于解析 HelloWorldController 这个 Bean 时，我们会发现有方法标记了 Lookup，此时就会添加相应方法到属性 methodOverrides 里面去（此过程由 AutowiredAnnotationBeanPostProcessor#determineCandidateConstructors 完成）。</p>
<p>添加后效果图如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/3bbbe15fa3d80da5ebdfe6adfe890dd3.png" alt=""></p>
<p>以上即为 Lookup 的一些关键实现思路。还有很多细节，例如 CGLIB 子类如何产生，无法一一解释，有兴趣的话，可以进一步深入研究，留言区等你。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>这节课我们介绍了 3 个关于 Bean 定义的经典错误，并分析了其背后原理。</p>
<p>不难发现，要使用好 Spring，就<strong>一定要了解它的一些潜规则</strong>，例如默认扫描 Bean 的范围、自动装配构造器等等。如果我们不了解这些规则，大多情况下虽然也能工作，但是稍微变化，则可能完全失效，例如在案例 1 中，我们也只是把 Controller 从一个包移动到另外一个包，接口就失效了。</p>
<p>另外，通过这三个案例的分析，我们也能感受到 <strong>Spring 的很多实现是通过反射来完成的</strong>，了解了这点，对于理解它的源码实现会大有帮助。例如在案例 2 中，为什么定义了多个构造器就可能报错，因为使用反射方式来创建实例必须要明确使用的是哪一个构造器。</p>
<p>最后，我想说，在 Spring 框架中，解决问题的方式往往有多种，不要拘泥于套路。就像案例 3，使用 ApplicationContext 和 Lookup 注解，都能解决原型 Bean 被固定的问题一样。</p>
<h2 id="思考题">思考题</h2>
<p>在案例 2 中，显示定义构造器，这会发生根据构造器参数寻找对应 Bean 的行为。这里请你思考一个问题，假设寻找不到对应的 Bean，一定会如案例 2 那样直接报错么？</p>
<p>尝试解决一下，我们留言区见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/">Spring编程常见错误50例</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A6%82%E4%BD%95%E8%AF%BB%E6%87%82%E4%B8%80%E9%A6%96%E8%AF%97/01_%E8%AF%BB%E8%AF%97%E5%8F%A5%E6%BA%AA%E6%9F%B4%E7%81%AB%E8%BD%AF%E8%9B%AE%E6%AF%A1%E6%9A%96%E8%BF%98%E6%98%AF%E7%81%AB%E8%BD%AF%E6%BA%AA%E6%9F%B4%E8%9B%AE%E6%AF%A1%E6%9A%96/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">01｜_读诗句：溪柴火软蛮毡暖，还是火软溪柴蛮毡暖？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/sre%E5%AE%9E%E6%88%98%E6%89%8B%E5%86%8C/01sre%E8%BF%B7%E6%80%9D%E6%97%A0%E6%89%80%E4%B8%8D%E8%83%BD%E7%9A%84%E8%A7%92%E8%89%B2%E8%BF%98%E6%98%AF%E8%BF%90%E7%BB%B4%E7%9A%84%E5%8D%87%E7%BA%A7/">
            <span class="next-text nav-default">01｜SRE迷思：无所不能的角色？还是运维的升级？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
