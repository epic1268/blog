<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>09｜Spring_Web_URL_解析常见错误 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是傅健。
上一章节我们讲解了各式各样的错误案例，这些案例都是围绕 Spring 的核心功能展开的，例如依赖注入、AOP 等诸多方面。然而，从现实情况来看，在使用上，我们更多地是使用 Spring 来构建一个 Web 服务，所以从这节课开始，我们会重点解析在 Spring Web 开发中经常遇到的一些错误，帮助你规避这些问题。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/09spring_web_url_%E8%A7%A3%E6%9E%90%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/09spring_web_url_%E8%A7%A3%E6%9E%90%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="09｜Spring_Web_URL_解析常见错误">
  <meta property="og:description" content="你好，我是傅健。
上一章节我们讲解了各式各样的错误案例，这些案例都是围绕 Spring 的核心功能展开的，例如依赖注入、AOP 等诸多方面。然而，从现实情况来看，在使用上，我们更多地是使用 Spring 来构建一个 Web 服务，所以从这节课开始，我们会重点解析在 Spring Web 开发中经常遇到的一些错误，帮助你规避这些问题。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Spring编程常见错误50例">

  <meta itemprop="name" content="09｜Spring_Web_URL_解析常见错误">
  <meta itemprop="description" content="你好，我是傅健。
上一章节我们讲解了各式各样的错误案例，这些案例都是围绕 Spring 的核心功能展开的，例如依赖注入、AOP 等诸多方面。然而，从现实情况来看，在使用上，我们更多地是使用 Spring 来构建一个 Web 服务，所以从这节课开始，我们会重点解析在 Spring Web 开发中经常遇到的一些错误，帮助你规避这些问题。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7824">
  <meta itemprop="keywords" content="Spring编程常见错误50例">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="09｜Spring_Web_URL_解析常见错误">
  <meta name="twitter:description" content="你好，我是傅健。
上一章节我们讲解了各式各样的错误案例，这些案例都是围绕 Spring 的核心功能展开的，例如依赖注入、AOP 等诸多方面。然而，从现实情况来看，在使用上，我们更多地是使用 Spring 来构建一个 Web 服务，所以从这节课开始，我们会重点解析在 Spring Web 开发中经常遇到的一些错误，帮助你规避这些问题。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">09｜Spring_Web_URL_解析常见错误</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7824 字 </span>
          <span class="more-meta"> 预计阅读 16 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#案例-1当-pathvariable-遇到-">案例 1：当 @PathVariable 遇到 /</a>
          <ul>
            <li><a href="#案例解析">案例解析</a></li>
            <li><a href="#问题修正">问题修正</a></li>
          </ul>
        </li>
        <li><a href="#案例-2错误使用-requestparampathvarible-等注解">案例 2：错误使用 @RequestParam、@PathVarible 等注解</a>
          <ul>
            <li><a href="#案例解析-1">案例解析</a></li>
            <li><a href="#问题修正-1">问题修正</a></li>
          </ul>
        </li>
        <li><a href="#案例-3未考虑参数是否可选">案例 3：未考虑参数是否可选</a>
          <ul>
            <li><a href="#案例解析-2">案例解析</a></li>
            <li><a href="#问题修正-2">问题修正</a></li>
          </ul>
        </li>
        <li><a href="#案例-4请求参数格式错误">案例 4：请求参数格式错误</a>
          <ul>
            <li><a href="#案例解析-3">案例解析</a></li>
            <li><a href="#问题修正-3">问题修正</a></li>
          </ul>
        </li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是傅健。</p>
<p>上一章节我们讲解了各式各样的错误案例，这些案例都是围绕 Spring 的核心功能展开的，例如依赖注入、AOP 等诸多方面。然而，从现实情况来看，在使用上，我们更多地是使用 Spring 来构建一个 Web 服务，所以从这节课开始，我们会重点解析在 Spring Web 开发中经常遇到的一些错误，帮助你规避这些问题。</p>
<p>不言而喻，这里说的 Web 服务就是指使用 HTTP 协议的服务。而对于 HTTP 请求，首先要处理的就是 URL，所以今天我们就先来介绍下，在 URL 的处理上，Spring 都有哪些经典的案例。闲话少叙，下面我们直接开始演示吧。</p>
<h2 id="案例-1当-pathvariable-遇到-">案例 1：当 @PathVariable 遇到 /</h2>
<p>在解析一个 URL 时，我们经常会使用 @PathVariable 这个注解。例如我们会经常见到如下风格的代码：</p>
<p>@RestController<br>
@Slf4j<br>
public class HelloWorldController {<br>
@RequestMapping(path = &ldquo;/hi1/{name}&rdquo;, method = RequestMethod.GET)<br>
public String hello1(@PathVariable(&ldquo;name&rdquo;) String name){<br>
return name;</p>
<pre><code>};    
</code></pre>
<p>}</p>
<p>当我们使用 http://localhost:8080/hi1/xiaoming 访问这个服务时，会返回&quot;xiaoming&quot;，即 Spring 会把 name 设置为 URL 中对应的值。</p>
<p>看起来顺风顺水，但是假设这个 name 中含有特殊字符 / 时（例如http://localhost:8080/hi1/xiao/ming ），会如何？如果我们不假思索，或许答案是&quot;xiao/ming&quot;？然而稍微敏锐点的程序员都会判定这个访问是会报错的，具体错误参考：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/015ed0cb6d2bf81a5f773e3c79190aff.png" alt=""></p>
<p>如图所示，当 name 中含有 /，这个接口不会为 name 获取任何值，而是直接报 Not Found 错误。当然这里的“找不到”并不是指 name 找不到，而是指服务于这个特殊请求的接口。</p>
<p>实际上，这里还存在另外一种错误，即当 name 的字符串以 / 结尾时，/ 会被自动去掉。例如我们访问 http://localhost:8080/hi1/xiaoming/，Spring 并不会报错，而是返回 xiaoming。</p>
<p>针对这两种类型的错误，应该如何理解并修正呢？</p>
<h3 id="案例解析">案例解析</h3>
<p>实际上，这两种错误都是 URL 匹配执行方法的相关问题，所以我们有必要先了解下 URL 匹配执行方法的大致过程。参考 AbstractHandlerMethodMapping#lookupHandlerMethod：</p>
<p>@Nullable<br>
protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {<br>
List<Match> matches = new ArrayList&lt;&gt;();<br>
//尝试按照 URL 进行精准匹配<br>
List<T> directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath);<br>
if (directPathMatches != null) {<br>
//精确匹配上，存储匹配结果<br>
addMatchingMappings(directPathMatches, matches, request);<br>
}<br>
if (matches.isEmpty()) {<br>
//没有精确匹配上，尝试根据请求来匹配<br>
addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request);<br>
}</p>
<p>if (!matches.isEmpty()) {<br>
Comparator<Match> comparator = new MatchComparator(getMappingComparator(request));<br>
matches.sort(comparator);<br>
Match bestMatch = matches.get(0);<br>
if (matches.size() &gt; 1) {<br>
//处理多个匹配的情况<br>
}<br>
//省略其他非关键代码<br>
return bestMatch.handlerMethod;<br>
}<br>
else {<br>
//匹配不上，直接报错<br>
return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request);<br>
}</p>
<p>大体分为这样几个基本步骤。</p>
<p><strong>1. 根据 Path 进行精确匹配</strong></p>
<p>这个步骤执行的代码语句是&quot;this.mappingRegistry.getMappingsByUrl(lookupPath)&quot;，实际上，它是查询 MappingRegistry#urlLookup，它的值可以用调试视图查看，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/e251faea257feb36d7d3bd618b4ec4a2.png" alt=""></p>
<p>查询 urlLookup 是一个精确匹配 Path 的过程。很明显，http://localhost:8080/hi1/xiao/ming 的 lookupPath 是&quot;/hi1/xiao/ming&quot;，并不能得到任何精确匹配。这里需要补充的是，&quot;/hi1/{name}&ldquo;这种定义本身也没有出现在 urlLookup 中。</p>
<p><strong>2. 假设 Path 没有精确匹配上，则执行模糊匹配</strong></p>
<p>在步骤 1 匹配失败时，会根据请求来尝试模糊匹配，待匹配的匹配方法可参考下图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/ea970c797c056ac4d701e0ebc157c9f4.png" alt=""></p>
<p>显然，&quot;/hi1/{name}&ldquo;这个匹配方法已经出现在待匹配候选中了。具体匹配过程可以参考方法 RequestMappingInfo#getMatchingCondition：</p>
<p>public RequestMappingInfo getMatchingCondition(HttpServletRequest request) {<br>
RequestMethodsRequestCondition methods = this.methodsCondition.getMatchingCondition(request);<br>
if (methods == null) {<br>
return null;<br>
}<br>
ParamsRequestCondition params = this.paramsCondition.getMatchingCondition(request);<br>
if (params == null) {<br>
return null;<br>
}<br>
//省略其他匹配条件<br>
PatternsRequestCondition patterns = this.patternsCondition.getMatchingCondition(request);<br>
if (patterns == null) {<br>
return null;<br>
}<br>
//省略其他匹配条件<br>
return new RequestMappingInfo(this.name, patterns,<br>
methods, params, headers, consumes, produces, custom.getCondition());<br>
}</p>
<p>现在我们知道<strong>匹配会查询所有的信息</strong>，例如 Header、Body 类型以及 URL 等。如果有一项不符合条件，则不匹配。</p>
<p>在我们的案例中，当使用 http://localhost:8080/hi1/xiaoming 访问时，其中 patternsCondition 是可以匹配上的。实际的匹配方法执行是通过 AntPathMatcher#match 来执行，判断的相关参数可参考以下调试视图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/6960eff6b5fcbc6f1ff68c895900fddd.png" alt=""></p>
<p>但是当我们使用 http://localhost:8080/hi1/xiao/ming 来访问时，AntPathMatcher 执行的结果是&rdquo;/hi1/xiao/ming&quot;匹配不上&rdquo;/hi1/{name}&quot;。</p>
<p><strong>3. 根据匹配情况返回结果</strong></p>
<p>如果找到匹配的方法，则返回方法；如果没有，则返回 null。</p>
<p>在本案例中，http://localhost:8080/hi1/xiao/ming 因为找不到匹配方法最终报 404 错误。追根溯源就是 AntPathMatcher 匹配不了&quot;/hi1/xiao/ming&quot;和&quot;/hi1/{name}&quot;。</p>
<p>另外，我们再回头思考 http://localhost:8080/hi1/xiaoming/ 为什么没有报错而是直接去掉了 /。这里我直接贴出了负责执行 AntPathMatcher 匹配的 PatternsRequestCondition#getMatchingPattern 方法的部分关键代码：</p>
<p>private String getMatchingPattern(String pattern, String lookupPath) {<br>
//省略其他非关键代码<br>
if (this.pathMatcher.match(pattern, lookupPath)) {<br>
return pattern;<br>
}<br>
//尝试加一个/来匹配<br>
if (this.useTrailingSlashMatch) {<br>
if (!pattern.endsWith(&quot;/&quot;) &amp;&amp; this.pathMatcher.match(pattern + &ldquo;/&rdquo;, lookupPath)) {<br>
return pattern + &ldquo;/&rdquo;;<br>
}<br>
}<br>
return null;<br>
}</p>
<p>在这段代码中，AntPathMatcher 匹配不了&quot;/hi1/xiaoming/&ldquo;和&rdquo;/hi1/{name}&quot;，所以不会直接返回。进而，在 useTrailingSlashMatch 这个参数启用时（默认启用），会把 Pattern 结尾加上 / 再尝试匹配一次。如果能匹配上，在最终返回 Pattern 时就隐式自动加 /。</p>
<p>很明显，我们的案例符合这种情况，等于说我们最终是用了&quot;/hi1/{name}/&ldquo;这个 Pattern，而不再是&rdquo;/hi1/{name}&quot;。所以自然 URL 解析 name 结果是去掉 / 的。</p>
<h3 id="问题修正">问题修正</h3>
<p>针对这个案例，有了源码的剖析，我们可能会想到可以先用&quot;**&ldquo;匹配上路径，等进入方法后再尝试去解析，这样就可以万无一失吧。具体修改代码如下：</p>
<p>@RequestMapping(path = &ldquo;/hi1/**&rdquo;, method = RequestMethod.GET)<br>
public String hi1(HttpServletRequest request){<br>
String requestURI = request.getRequestURI();<br>
return requestURI.split(&quot;/hi1/&rdquo;)[1];<br>
};</p>
<p>但是这种修改方法还是存在漏洞，假设我们路径的 name 中刚好又含有&quot;/hi1/&quot;，则 split 后返回的值就并不是我们想要的。实际上，更合适的修订代码示例如下：</p>
<p>private AntPathMatcher antPathMatcher = new AntPathMatcher();</p>
<p>@RequestMapping(path = &ldquo;/hi1/<strong>&rdquo;, method = RequestMethod.GET)<br>
public String hi1(HttpServletRequest request){<br>
String path = (String) request.getAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE);<br>
//matchPattern 即为&quot;/hi1/</strong>&quot;<br>
String matchPattern = (String) request.getAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE);<br>
return antPathMatcher.extractPathWithinPattern(matchPattern, path);<br>
};</p>
<p>经过修改，两个错误都得以解决了。当然也存在一些其他的方案，例如对传递的参数进行 URL 编码以避免出现 /，或者干脆直接把这个变量作为请求参数、Header 等，而不是作为 URL 的一部分。你完全可以根据具体情况来选择合适的方案。</p>
<h2 id="案例-2错误使用-requestparampathvarible-等注解">案例 2：错误使用 @RequestParam、@PathVarible 等注解</h2>
<p>我们常常使用 @RequestParam 和 @PathVarible 来获取请求参数（request parameters）以及 path 中的部分。但是在频繁使用这些参数时，不知道你有没有觉得它们的使用方式并不友好，例如我们去获取一个请求参数 name，我们会定义如下：</p>
<blockquote>
<p>@RequestParam(&ldquo;name&rdquo;) String name</p>
</blockquote>
<p>此时，我们会发现变量名称大概率会被定义成 RequestParam 值。所以我们是不是可以用下面这种方式来定义：</p>
<blockquote>
<p>@RequestParam String name</p>
</blockquote>
<p>这种方式确实是可以的，本地测试也能通过。这里我还给出了完整的代码，你可以感受下这两者的区别。</p>
<p>@RequestMapping(path = &ldquo;/hi1&rdquo;, method = RequestMethod.GET)<br>
public String hi1(@RequestParam(&ldquo;name&rdquo;) String name){<br>
return name;<br>
};</p>
<p>@RequestMapping(path = &ldquo;/hi2&rdquo;, method = RequestMethod.GET)<br>
public String hi2(@RequestParam String name){<br>
return name;<br>
};</p>
<p>很明显，对于喜欢追究极致简洁的同学来说，这个酷炫的功能是一个福音。但当我们换一个项目时，有可能上线后就失效了，然后报错 500，提示匹配不上。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/9898e5084016c9d9c64c6ad84a4bc538.png" alt=""></p>
<h3 id="案例解析-1">案例解析</h3>
<p>要理解这个问题出现的原因，首先我们需要把这个问题复现出来。例如我们可以修改下 pom.xml 来关掉两个选项：</p>
<plugin>  
    <groupId>org.apache.maven.plugins</groupId>  
    <artifactId>maven-compiler-plugin</artifactId>  
   <configuration>  
        <debug>false</debug>  
        <parameters>false</parameters>  
    </configuration>  
</plugin>
<p>上述配置显示关闭了 parameters 和 debug，这 2 个参数的作用你可以参考下面的表格：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/46673df473aeffb8b150fae27933ef81.png" alt=""></p>
<p>通过上述描述，我们可以看出这 2 个参数控制了一些 debug 信息是否加进 class 文件中。我们可以开启这两个参数来编译，然后使用下面的命令来查看信息：</p>
<blockquote>
<p>javap -verbose HelloWorldController.class</p>
</blockquote>
<p>执行完命令后，我们会看到以下 class 信息：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/f5079896e1683912ab0df340395f416a.png" alt=""></p>
<p>debug 参数开启的部分信息就是 LocalVaribleTable，而 paramters 参数开启的信息就是 MethodParameters。观察它们的信息，你会发现它们都含有参数名 name。</p>
<p>如果你关闭这两个参数，则 name 这个名称自然就没有了。而这个方法本身在 @RequestParam 中又没有指定名称，那么 Spring 此时还能找到解析的方法么？</p>
<p>答案是否定的，这里我们可以顺带说下 Spring 解析请求参数名称的过程，参考代码 AbstractNamedValueMethodArgumentResolver#updateNamedValueInfo：</p>
<p>private NamedValueInfo updateNamedValueInfo(MethodParameter parameter, NamedValueInfo info) {<br>
String name = info.name;<br>
if (info.name.isEmpty()) {<br>
name = parameter.getParameterName();<br>
if (name == null) {<br>
throw new IllegalArgumentException(<br>
&ldquo;Name for argument type [&rdquo; + parameter.getNestedParameterType().getName() +<br>
&ldquo;] not available, and parameter name information not found in class file either.&rdquo;);<br>
}<br>
}<br>
String defaultValue = (ValueConstants.DEFAULT_NONE.equals(info.defaultValue) ? null : info.defaultValue);<br>
return new NamedValueInfo(name, info.required, defaultValue);<br>
}</p>
<p>其中 NamedValueInfo 的 name 为 @RequestParam 指定的值。很明显，在本案例中，为 null。</p>
<p>所以这里我们就会尝试调用 parameter.getParameterName() 来获取参数名作为解析请求参数的名称。但是，很明显，关掉上面两个开关后，就不可能在 class 文件中找到参数名了，这点可以从下面的调试试图中得到验证：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/9cebac2bdf70a3858dc25a1510aca3c8.png" alt=""></p>
<p>当参数名不存在，@RequestParam 也没有指明，自然就无法决定到底要用什么名称去获取请求参数，所以就会报本案例的错误。</p>
<h3 id="问题修正-1">问题修正</h3>
<p>模拟出了问题是如何发生的，我们自然可以通过开启这两个参数让其工作起来。但是思考这两个参数的作用，很明显，它可以让我们的程序体积更小，所以很多项目都会青睐去关闭这两个参数。</p>
<p>为了以不变应万变，正确的修正方式是<strong>必须显式在 @RequestParam 中指定请求参数名</strong>。具体修改如下：</p>
<blockquote>
<p>@RequestParam(&ldquo;name&rdquo;) String name</p>
</blockquote>
<p>通过这个案例，我们可以看出：很多功能貌似可以永远工作，但是实际上，只是在特定的条件下而已。另外，这里再拓展下，IDE 都喜欢开启相关 debug 参数，所以 IDE 里运行的程序不见得对产线适应，例如针对 parameters 这个参数，IDEA 默认就开启了。</p>
<p>另外，本案例围绕的都是 @RequestParam，其实 @PathVarible 也有一样的问题。这里你要注意。</p>
<p>那么说到这里，我顺带提一个可能出现的小困惑：我们这里讨论的参数，和 @QueryParam、@PathParam 有什么区别？实际上，后者都是 JAX-RS 自身的注解，不需要额外导包。而 @RequestParam 和 @PathVariable 是 Spring 框架中的注解，需要额外导入依赖包。另外不同注解的参数也不完全一致。</p>
<h2 id="案例-3未考虑参数是否可选">案例 3：未考虑参数是否可选</h2>
<p>在上面的案例中，我们提到了 @RequestParam 的使用。而对于它的使用，我们常常会遇到另外一个问题。当需要特别多的请求参数时，我们往往会忽略其中一些参数是否可选。例如存在类似这样的代码：</p>
<p>@RequestMapping(path = &ldquo;/hi4&rdquo;, method = RequestMethod.GET)<br>
public String hi4(@RequestParam(&ldquo;name&rdquo;) String name, @RequestParam(&ldquo;address&rdquo;) String address){<br>
return name + &ldquo;:&rdquo; + address;<br>
};</p>
<p>在访问 http://localhost:8080/hi4?name=xiaoming&amp;address=beijing 时并不会出问题，但是一旦用户仅仅使用 name 做请求（即 http://localhost:8080/hi4?name=xiaoming ）时，则会直接报错如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/2729c61ac02fc6bbb12908ceb2ce1596.png" alt=""></p>
<p>此时，返回错误码 400，提示请求格式错误：此处缺少 address 参数。</p>
<p>实际上，部分初学者即使面对这个错误，也会觉得惊讶，既然不存在 address，address 应该设置为 null，而不应该是直接报错不是么？接下来我们就分析下。</p>
<h3 id="案例解析-2">案例解析</h3>
<p>要了解这个错误出现的根本原因，你就需要了解请求参数的发生位置。</p>
<p>实际上，这里我们也能按注解名（@RequestParam）来确定解析发生的位置是在 RequestParamMethodArgumentResolver 中。为什么是它？</p>
<p>追根溯源，针对当前案例，当根据 URL 匹配上要执行的方法是 hi4 后，要反射调用它，必须解析出方法参数 name 和 address 才可以。而它们被 @RequestParam 注解修饰，所以解析器借助 RequestParamMethodArgumentResolver 就成了很自然的事情。</p>
<p>接下来我们看下 RequestParamMethodArgumentResolver 对参数解析的一些关键操作，参考其父类方法 AbstractNamedValueMethodArgumentResolver#resolveArgument：</p>
<p>public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,<br>
NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {<br>
NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);<br>
MethodParameter nestedParameter = parameter.nestedIfOptional();<br>
//省略其他非关键代码<br>
//获取请求参数<br>
Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);<br>
if (arg == null) {<br>
if (namedValueInfo.defaultValue != null) {<br>
arg = resolveStringValue(namedValueInfo.defaultValue);<br>
}<br>
else if (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) {<br>
handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);<br>
}<br>
arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());<br>
}<br>
//省略后续代码：类型转化等工作<br>
return arg;<br>
}</p>
<p>如代码所示，当缺少请求参数的时候，通常我们会按照以下几个步骤进行处理。</p>
<p><strong>1. 查看 namedValueInfo 的默认值，如果存在则使用它</strong></p>
<p>这个变量实际是通过下面的方法来获取的，参考 RequestParamMethodArgumentResolver#createNamedValueInfo：</p>
<p>@Override<br>
protected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {<br>
RequestParam ann = parameter.getParameterAnnotation(RequestParam.class);<br>
return (ann != null ? new RequestParamNamedValueInfo(ann) : new RequestParamNamedValueInfo());<br>
}</p>
<p>实际上就是 @RequestParam 的相关信息，我们调试下，就可以验证这个结论，具体如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/80efaef4b308724e2e56ebe8beb7dafc.png" alt=""></p>
<p><strong>2. 在 @RequestParam 没有指明默认值时，会查看这个参数是否必须，如果必须，则按错误处理</strong></p>
<p>判断参数是否必须的代码即为下述关键代码行：</p>
<blockquote>
<p>namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()</p>
</blockquote>
<p>很明显，若要判定一个参数是否是必须的，需要同时满足两个条件：条件 1 是 @RequestParam 指明了必须（即属性 required 为 true，实际上它也是默认值），条件 2 是要求 @RequestParam 标记的参数本身不是可选的。</p>
<p>我们可以通过 MethodParameter#isOptional 方法看下可选的具体含义：</p>
<p>public boolean isOptional() {<br>
return (getParameterType() == Optional.class || hasNullableAnnotation() ||<br>
(KotlinDetector.isKotlinReflectPresent() &amp;&amp;<br>
KotlinDetector.isKotlinType(getContainingClass()) &amp;&amp;<br>
KotlinDelegate.isOptional(this)));<br>
}</p>
<p>在不使用 Kotlin 的情况下，所谓可选，就是参数的类型为 Optional，或者任何标记了注解名为 Nullable 且 RetentionPolicy 为 RUNTIM 的注解。</p>
<p><strong>3. 如果不是必须，则按 null 去做具体处理</strong></p>
<p>如果接受类型是 boolean，返回 false，如果是基本类型则直接报错，这里不做展开。</p>
<p>结合我们的案例，我们的参数符合步骤 2 中判定为必选的条件，所以最终会执行方法 AbstractNamedValueMethodArgumentResolver#handleMissingValue：</p>
<p>protected void handleMissingValue(String name, MethodParameter parameter) throws ServletException {<br>
throw new ServletRequestBindingException(&ldquo;Missing argument &lsquo;&rdquo; + name +<br>
&ldquo;&rsquo; for method parameter of type &quot; + parameter.getNestedParameterType().getSimpleName());<br>
}</p>
<h3 id="问题修正-2">问题修正</h3>
<p>通过案例解析，我们很容易就能修正这个问题，就是让参数有默认值或为非可选即可，具体方法包含以下几种。</p>
<p><strong>1. 设置 @RequestParam 的默认值</strong></p>
<p>修改代码如下：</p>
<blockquote>
<p>@RequestParam(value = &ldquo;address&rdquo;, defaultValue = &ldquo;no address&rdquo;) String address</p>
</blockquote>
<p><strong>2. 设置 @RequestParam 的 required 值</strong></p>
<p>修改代码如下：</p>
<blockquote>
<p>@RequestParam(value = &ldquo;address&rdquo;, required = false) String address)</p>
</blockquote>
<p><strong>3. 标记任何名为 Nullable 且 RetentionPolicy 为 RUNTIME 的注解</strong></p>
<p>修改代码如下：</p>
<blockquote>
<p>//org.springframework.lang.Nullable 可以</p>
<p>//edu.umd.cs.findbugs.annotations.Nullable 可以</p>
<p>@RequestParam(value = &ldquo;address&rdquo;) @Nullable String address</p>
</blockquote>
<p><strong>4. 修改参数类型为 Optional</strong></p>
<p>修改代码如下：</p>
<blockquote>
<p>@RequestParam(value = &ldquo;address&rdquo;) Optionaladdress</p>
</blockquote>
<p>从这些修正方法不难看出：假设你不学习源码，解决方法就可能只局限于一两种，但是深入源码后，解决方法就变得格外多了。这里要特别强调的是：<strong>在 Spring Web 中，默认情况下，请求参数是必选项。</strong></p>
<h2 id="案例-4请求参数格式错误">案例 4：请求参数格式错误</h2>
<p>当我们使用 Spring URL 相关的注解，会发现 Spring 是能够完成自动转化的。例如在下面的代码中，age 可以被直接定义为 int 这种基本类型（Integer 也可以），而不是必须是 String 类型。</p>
<p>@RequestMapping(path = &ldquo;/hi5&rdquo;, method = RequestMethod.GET)<br>
public String hi5(@RequestParam(&ldquo;name&rdquo;) String name, @RequestParam(&ldquo;age&rdquo;) int age){<br>
return name + &quot; is &quot; + age + &quot; years old&rdquo;;<br>
};</p>
<p>鉴于 Spring 的强大转化功能，我们断定 Spring 也支持日期类型的转化（也确实如此），于是我们可能会写出类似下面这样的代码：</p>
<p>@RequestMapping(path = &ldquo;/hi6&rdquo;, method = RequestMethod.GET)<br>
public String hi6(@RequestParam(&ldquo;Date&rdquo;) Date date){<br>
return &ldquo;date is &quot; + date ;<br>
};</p>
<p>然后，我们使用一些看似明显符合日期格式的 URL 来访问，例如 http://localhost:8080/hi6?date=2021-5-1 20:26:53，我们会发现 Spring 并不能完成转化，而是报错如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/c655262b7938284d089af63555687289.png" alt=""></p>
<p>此时，返回错误码 400，错误信息为&quot;Failed to convert value of type &lsquo;java.lang.String&rsquo; to required type &lsquo;java.util.Date&rdquo;。</p>
<p>如何理解这个案例？如果实现自动转化，我们又需要做什么？</p>
<h3 id="案例解析-3">案例解析</h3>
<p>不管是使用 @PathVarible 还是 @RequetParam，我们一般解析出的结果都是一个 String 或 String 数组。例如，使用 @RequetParam 解析的关键代码参考 RequestParamMethodArgumentResolver#resolveName 方法：</p>
<p>@Nullable<br>
protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception {<br>
//省略其他非关键代码<br>
if (arg == null) {<br>
String[] paramValues = request.getParameterValues(name);<br>
if (paramValues != null) {<br>
arg = (paramValues.length == 1 ? paramValues[0] : paramValues);<br>
}<br>
}<br>
return arg;<br>
}</p>
<p>这里我们调用的&quot;request.getParameterValues(name)&quot;，返回的是一个 String 数组，最终给上层调用者返回的是单个 String（如果只有一个元素时）或者 String 数组。</p>
<p>所以很明显，在这个测试程序中，我们给上层返回的是一个 String，这个 String 的值最终是需要做转化才能赋值给其他类型。例如对于案例中的&quot;int age&quot;定义，是需要转化为 int 基本类型的。这个基本流程可以通过 AbstractNamedValueMethodArgumentResolver#resolveArgument 的关键代码来验证：</p>
<p>public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,<br>
NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {<br>
//省略其他非关键代码<br>
Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);<br>
//以此为界，前面代码为解析请求参数，后续代码为转化解析出的参数<br>
if (binderFactory != null) {<br>
WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name);<br>
try {<br>
arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);<br>
}<br>
//省略其他非关键代码<br>
}<br>
//省略其他非关键代码<br>
return arg;<br>
}</p>
<p>实际上在前面我们曾经提到过这个转化的基本逻辑，所以这里不再详述它具体是如何发生的。</p>
<p>在这里你只需要回忆出它是需要<strong>根据源类型和目标类型寻找转化器来执行转化的</strong>。在这里，对于 age 而言，最终找出的转化器是 StringToNumberConverterFactory。而对于 Date 型的 Date 变量，在本案例中，最终找到的是 ObjectToObjectConverter。它的转化过程参考下面的代码：</p>
<p>public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {<br>
if (source == null) {<br>
return null;<br>
}<br>
Class<?> sourceClass = sourceType.getType();<br>
Class<?> targetClass = targetType.getType();<br>
//根据源类型去获取构建出目标类型的方法：可以是工厂方法（例如 valueOf、from 方法）也可以是构造器<br>
Member member = getValidatedMember(targetClass, sourceClass);<br>
try {<br>
if (member instanceof Method) {<br>
//如果是工厂方法，通过反射创建目标实例<br>
}<br>
else if (member instanceof Constructor) {<br>
//如果是构造器，通过反射创建实例<br>
Constructor<?> ctor = (Constructor<?>) member;<br>
ReflectionUtils.makeAccessible(ctor);<br>
return ctor.newInstance(source);<br>
}<br>
}<br>
catch (InvocationTargetException ex) {<br>
throw new ConversionFailedException(sourceType, targetType, source, ex.getTargetException());<br>
}<br>
catch (Throwable ex) {<br>
throw new ConversionFailedException(sourceType, targetType, source, ex);<br>
}</p>
<p>当使用 ObjectToObjectConverter 进行转化时，是根据反射机制带着源目标类型来查找可能的构造目标实例方法，例如构造器或者工厂方法，然后再次通过反射机制来创建一个目标对象。所以对于 Date 而言，最终调用的是下面的 Date 构造器：</p>
<p>public Date(String s) {<br>
this(parse(s));<br>
}</p>
<p>然而，我们传入的 2021-5-1 20:26:53 虽然确实是一种日期格式，但用来作为 Date 构造器参数是不支持的，最终报错，并被上层捕获，转化为 ConversionFailedException 异常。这就是这个案例背后的故事了。</p>
<h3 id="问题修正-3">问题修正</h3>
<p>那么怎么解决呢？提供两种方法。</p>
<p><strong>1. 使用 Date 支持的格式</strong></p>
<p>例如下面的测试 URL 就可以工作起来：</p>
<blockquote>
<p>http://localhost:8080/hi6?date=Sat, 12 Aug 1995 13:30:00 GMT</p>
</blockquote>
<p><strong>2. 使用好内置格式转化器</strong></p>
<p>实际上，在 Spring 中，要完成 String 对于 Date 的转化，ObjectToObjectConverter 并不是最好的转化器。我们可以使用更强大的 AnnotationParserConverter。**在 Spring 初始化时，会构建一些针对日期型的转化器，即相应的一些 AnnotationParserConverter 的实例。**但是为什么有时候用不上呢？</p>
<p>这是因为 AnnotationParserConverter 有目标类型的要求，这点我们可以通过调试角度来看下，参考 FormattingConversionService#addFormatterForFieldAnnotation 方法的调试试图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/6ade53b36d9fcdc5d855b3fbcd611d61.png" alt=""></p>
<p>这是适应于 String 到 Date 类型的转化器 AnnotationParserConverter 实例的构造过程，其需要的 annototationType 参数为 DateTimeFormat。</p>
<p>annototationType 的作用正是为了帮助判断是否能用这个转化器，这一点可以参考代码 AnnotationParserConverter#matches：</p>
<p>@Override<br>
public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {<br>
return targetType.hasAnnotation(this.annotationType);<br>
}</p>
<p>最终构建出来的转化器相关信息可以参考下图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/6eb3fd64747ab5dbad15ddf25758318e.png" alt=""></p>
<p>图中构造出的转化器是可以用来转化 String 到 Date，但是它要求我们标记 @DateTimeFormat。很明显，我们的参数 Date 并没有标记这个注解，所以这里为了使用这个转化器，我们可以使用上它并提供合适的格式。这样就可以让原来不工作的 URL 工作起来，具体修改代码如下：</p>
<p>@DateTimeFormat(pattern=&ldquo;yyyy-MM-dd HH:mm:ss&rdquo;) Date date</p>
<p>以上即为本案例的解决方案。除此之外，我们完全可以制定一个转化器来帮助我们完成转化，这里不再赘述。另外，通过这个案例，我们可以看出：尽管 Spring 给我们提供了很多内置的转化功能，但是我们一定要注意，格式是否符合对应的要求，否则代码就可能会失效。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>通过这一讲的学习，我们了解到了在 Spring 解析 URL 中的一些常见错误及其背后的深层原因。这里再次回顾下重点：</p>
<ol>
<li>当我们使用 @PathVariable 时，一定要注意传递的值是不是含有 / ;</li>
<li>当我们使用 @RequestParam、@PathVarible 等注解时，一定要意识到一个问题，虽然下面这两种方式（以 @RequestParam 使用示例）都可以，但是后者在一些项目中并不能正常工作，因为很多产线的编译配置会去掉不是必须的调试信息。</li>
</ol>
<p>@RequestMapping(path = &ldquo;/hi1&rdquo;, method = RequestMethod.GET)<br>
public String hi1(@RequestParam(&ldquo;name&rdquo;) String name){<br>
return name;<br>
};<br>
//方式 2：没有显式指定 RequestParam 的“name”，这种方式有时候会不行<br>
@RequestMapping(path = &ldquo;/hi2&rdquo;, method = RequestMethod.GET)<br>
public String hi2(@RequestParam String name){<br>
return name;<br>
};</p>
<ol>
<li>任何一个参数，我们都需要考虑它是可选的还是必须的。同时，你一定要想到参数类型的定义到底能不能从请求中自动转化而来。Spring 本身给我们内置了很多转化器，但是我们要以合适的方式使用上它。另外，Spring 对很多类型的转化设计都很贴心，例如使用下面的注解就能解决自定义日期格式参数转化问题。</li>
</ol>
<p>@DateTimeFormat(pattern=&ldquo;yyyy-MM-dd HH:mm:ss&rdquo;) Date date</p>
<p>希望这些核心知识点，能帮助你高效解析 URL。</p>
<h2 id="思考题">思考题</h2>
<p>关于 URL 解析，其实还有许多让我们惊讶的地方，例如案例 2 的部分代码：</p>
<p>@RequestMapping(path = &ldquo;/hi2&rdquo;, method = RequestMethod.GET)<br>
public String hi2(@RequestParam(&ldquo;name&rdquo;) String name){<br>
return name;<br>
};</p>
<p>在上述代码的应用中，我们可以使用 http://localhost:8080/hi2?name=xiaoming&amp;name=hanmeimei 来测试下，结果会返回什么呢？你猜会是xiaoming&amp;name=hanmeimei 么？</p>
<p>我们留言区见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/">Spring编程常见错误50例</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E5%AE%9E%E6%88%98%E8%AF%BE/09%E4%BA%8C__%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1%E9%9A%BE%E9%81%93%E5%B0%B1%E6%98%AF%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B%E4%B8%AAapi%E5%90%97/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">09（二）__数据服务难道就是对外提供个API吗？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/sre%E5%AE%9E%E6%88%98%E6%89%8B%E5%86%8C/09%E6%A1%88%E4%BE%8B%E4%BA%92%E8%81%94%E7%BD%91%E5%85%B8%E5%9E%8B%E7%9A%84sre%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/">
            <span class="next-text nav-default">09｜案例：互联网典型的SRE组织架构是怎样的？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
