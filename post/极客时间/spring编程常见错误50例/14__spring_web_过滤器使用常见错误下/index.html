<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>14__Spring_Web_过滤器使用常见错误（下） - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是傅健。
通过上节课的两个案例，我们了解了容器运行时过滤器的工作原理，那么这节课我们还是通过两个错误案例，来学习下容器启动时过滤器初始化以及排序注册等相关逻辑。了解了它们，你会对如何使用好过滤器更有信心。下面，我们具体来看一下。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/14__spring_web_%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%B8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/14__spring_web_%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%B8%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="14__Spring_Web_过滤器使用常见错误（下）">
  <meta property="og:description" content="你好，我是傅健。
通过上节课的两个案例，我们了解了容器运行时过滤器的工作原理，那么这节课我们还是通过两个错误案例，来学习下容器启动时过滤器初始化以及排序注册等相关逻辑。了解了它们，你会对如何使用好过滤器更有信心。下面，我们具体来看一下。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Spring编程常见错误50例">

  <meta itemprop="name" content="14__Spring_Web_过滤器使用常见错误（下）">
  <meta itemprop="description" content="你好，我是傅健。
通过上节课的两个案例，我们了解了容器运行时过滤器的工作原理，那么这节课我们还是通过两个错误案例，来学习下容器启动时过滤器初始化以及排序注册等相关逻辑。了解了它们，你会对如何使用好过滤器更有信心。下面，我们具体来看一下。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6214">
  <meta itemprop="keywords" content="Spring编程常见错误50例">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="14__Spring_Web_过滤器使用常见错误（下）">
  <meta name="twitter:description" content="你好，我是傅健。
通过上节课的两个案例，我们了解了容器运行时过滤器的工作原理，那么这节课我们还是通过两个错误案例，来学习下容器启动时过滤器初始化以及排序注册等相关逻辑。了解了它们，你会对如何使用好过滤器更有信心。下面，我们具体来看一下。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">14__Spring_Web_过滤器使用常见错误（下）</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6214 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#案例-1webfilter-过滤器使用-order-无效">案例 1：@WebFilter 过滤器使用 @Order 无效</a>
          <ul>
            <li><a href="#案例解析">案例解析</a></li>
            <li><a href="#问题修正">问题修正</a></li>
          </ul>
        </li>
        <li><a href="#案例-2过滤器被多次执行">案例 2：过滤器被多次执行</a>
          <ul>
            <li><a href="#案例解析-1">案例解析</a></li>
            <li><a href="#问题修正-1">问题修正</a></li>
          </ul>
        </li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是傅健。</p>
<p>通过上节课的两个案例，我们了解了容器运行时过滤器的工作原理，那么这节课我们还是通过两个错误案例，来学习下容器启动时过滤器初始化以及排序注册等相关逻辑。了解了它们，你会对如何使用好过滤器更有信心。下面，我们具体来看一下。</p>
<h2 id="案例-1webfilter-过滤器使用-order-无效">案例 1：@WebFilter 过滤器使用 @Order 无效</h2>
<p>假设我们还是基于 Spring Boot 去开发上节课的学籍管理系统，这里我们简单复习下上节课用到的代码。</p>
<p>首先，创建启动程序的代码如下：</p>
<p>@SpringBootApplication<br>
@ServletComponentScan<br>
@Slf4j<br>
public class Application {<br>
public static void main(String[] args) {<br>
SpringApplication.run(Application.class, args);<br>
log.info(&ldquo;启动成功&rdquo;);<br>
}<br>
}</p>
<p>实现的 Controller 代码如下：</p>
<p>@Controller<br>
@Slf4j<br>
public class StudentController {<br>
@PostMapping(&quot;/regStudent/{name)}&quot;)<br>
@ResponseBody<br>
public String saveUser(String name) throws Exception {<br>
System.out.println(&quot;&hellip;&hellip;用户注册成功&quot;);<br>
return &ldquo;success&rdquo;;<br>
}<br>
}</p>
<p>上述代码提供了一个 Restful 接口 &ldquo;/regStudent&rdquo;。该接口只有一个参数 name，注册成功会返回&quot;success&quot;。</p>
<p>现在，我们来实现两个新的过滤器，代码如下：</p>
<p>AuthFilter：例如，限制特定 IP 地址段（例如校园网内）的用户方可注册为新用户，当然这里我们仅仅 Sleep 1 秒来模拟这个过程。</p>
<p>@WebFilter<br>
@Slf4j<br>
@Order(2)<br>
public class AuthFilter implements Filter {<br>
@SneakyThrows<br>
@Override<br>
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {<br>
if(isPassAuth()){<br>
System.out.println(&ldquo;通过授权&rdquo;);<br>
chain.doFilter(request, response);<br>
}else{<br>
System.out.println(&ldquo;未通过授权&rdquo;);<br>
((HttpServletResponse)response).sendError(401);<br>
}<br>
}<br>
private boolean isPassAuth() throws InterruptedException {<br>
System.out.println(&ldquo;执行检查权限&rdquo;);<br>
Thread.sleep(1000);<br>
return true;<br>
}<br>
}</p>
<p>TimeCostFilter：计算注册学生的执行耗时，需要包括授权过程。</p>
<p>@WebFilter<br>
@Slf4j<br>
@Order(1)<br>
public class TimeCostFilter implements Filter {<br>
@Override<br>
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {<br>
System.out.println(&quot;#开始计算接口耗时&quot;);<br>
long start = System.currentTimeMillis();<br>
chain.doFilter(request, response);<br>
long end = System.currentTimeMillis();<br>
long time = end - start;<br>
System.out.println(&quot;#执行时间 (ms)：&quot; + time);<br>
}<br>
}</p>
<p>在上述代码中，我们使用了 @Order，期望 TimeCostFilter 先被执行，因为 TimeCostFilter 设计的初衷是统计这个接口的性能，所以是需要统计 AuthFilter 执行的授权过程的。</p>
<p>全部代码实现完毕，执行结果如下：</p>
<p>执行检查权限<br>
通过授权<br>
#开始计算接口耗时<br>
&hellip;&hellip;用户注册成功<br>
#执行时间 (ms)：33</p>
<p>从结果来看，执行时间并不包含授权过程，所以这并不符合我们的预期，毕竟我们是加了 @Order 的。但是如果我们交换 Order 指定的值，你会发现也不见效果，为什么会如此？难道 Order 不能用来排序 WebFilter 么？下面我们来具体解析下这个问题及其背后的原理。</p>
<h3 id="案例解析">案例解析</h3>
<p>通过上节课的学习，我们得知：当一个请求来临时，会执行到 StandardWrapperValve 的 invoke()，这个方法会创建 ApplicationFilterChain，并通过 ApplicationFilterChain#doFilter() 触发过滤器执行，并最终执行到内部私有方法 internalDoFilter()，我们可以尝试在 internalDoFilter() 中寻找一些启示：</p>
<p>private void internalDoFilter(ServletRequest request,<br>
ServletResponse response)<br>
throws IOException, ServletException {</p>
<pre><code>// Call the next filter if there is one  
if (pos &lt; n) {  
    ApplicationFilterConfig filterConfig = filters[pos++];  
    try {  
        Filter filter = filterConfig.getFilter();
</code></pre>
<p>从上述代码我们得知：过滤器的执行顺序是由类成员变量 Filters 决定的，而 Filters 变量则是 createFilterChain() 在容器启动时顺序遍历 StandardContext 中的成员变量 FilterMaps 获得的：</p>
<p>public static ApplicationFilterChain createFilterChain(ServletRequest request,<br>
Wrapper wrapper, Servlet servlet) {</p>
<pre><code>// 省略非关键代码  
// Acquire the filter mappings for this Context  
StandardContext context = (StandardContext) wrapper.getParent();  
FilterMap filterMaps[] = context.findFilterMaps();  
// 省略非关键代码  
// Add the relevant path-mapped filters to this filter chain  
for (int i = 0; i &lt; filterMaps.length; i++) {  
    if (!matchDispatcher(filterMaps[i] ,dispatcher)) {  
        continue;  
    }  
    if (!matchFiltersURL(filterMaps[i], requestPath))  
        continue;  
    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)  
        context.findFilterConfig(filterMaps[i].getFilterName());  
    if (filterConfig == null) {  
        continue;  
    }  
    filterChain.addFilter(filterConfig);  
}  
// 省略非关键代码  
// Return the completed filter chain  
return filterChain;  
</code></pre>
<p>}</p>
<p>下面继续查找对 StandardContext 成员变量 FilterMaps 的写入引用，我们找到了 addFilterMapBefore()：</p>
<p>public void addFilterMapBefore(FilterMap filterMap) {<br>
validateFilterMap(filterMap);<br>
// Add this filter mapping to our registered set<br>
filterMaps.addBefore(filterMap);<br>
fireContainerEvent(&ldquo;addFilterMap&rdquo;, filterMap);<br>
}</p>
<p>到这，我们已经知道过滤器的执行顺序是由 StandardContext 类成员变量 FilterMaps 的顺序决定，而 FilterMaps 则是一个包装过的数组，所以我们只要进一步弄清楚 <strong>FilterMaps 中各元素的排列顺序</strong>即可。</p>
<p>我们继续在 addFilterMapBefore() 中加入断点，尝试从调用栈中找到一些线索：</p>
<p>addFilterMapBefore:2992, StandardContext<br>
addMappingForUrlPatterns:107, ApplicationFilterRegistration<br>
configure:229, AbstractFilterRegistrationBean<br>
configure:44, AbstractFilterRegistrationBean<br>
register:113, DynamicRegistrationBean<br>
onStartup:53, RegistrationBean<br>
selfInitialize:228, ServletWebServerApplicationContext<br>
// 省略非关键代码</p>
<p>可知，Spring 从 selfInitialize() 一直依次调用到 addFilterMapBefore()，稍微分析下 selfInitialize()，我们可以了解到，这里是通过调用 getServletContextInitializerBeans()，获取所有的 ServletContextInitializer 类型的 Bean，并调用该 Bean 的 onStartup()，从而一步步以调用栈显示的顺序，最终调用到 addFilterMapBefore()。</p>
<p>private void selfInitialize(ServletContext servletContext) throws ServletException {<br>
prepareWebApplicationContext(servletContext);<br>
registerApplicationScope(servletContext);<br>
WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext);<br>
for (ServletContextInitializer beans : getServletContextInitializerBeans()) {<br>
beans.onStartup(servletContext);<br>
}<br>
}</p>
<p>那么上述的 selfInitialize() 又从何处调用过来呢？这里你可以先想想，我会在思考题中给你做进一步解释。</p>
<p>现在我们继续查看 selfInitialize() 的细节。</p>
<p>首先，查看上述代码中的 getServletContextInitializerBeans()，因为此方法返回的 ServletContextInitializer 类型的 Bean 集合顺序决定了 addFilterMapBefore() 调用的顺序，从而决定了 FilterMaps 内元素的顺序，最终决定了过滤器的执行顺序。</p>
<p>getServletContextInitializerBeans() 的实现非常简单，只是返回了 ServletContextInitializerBeans 类的一个实例，参考代码如下：</p>
<p>protected Collection<ServletContextInitializer> getServletContextInitializerBeans() {<br>
return new ServletContextInitializerBeans(getBeanFactory());<br>
}</p>
<p>上述方法的返回值是个 Collection，可见 ServletContextInitializerBeans 类是一个集合类，它继承了 AbstractCollection 抽象类。也因为如此，上述 selfInitialize() 才可以遍历 ServletContextInitializerBeans 的实例对象。</p>
<p>既然 ServletContextInitializerBeans 是集合类，那么我们就可以先查看其 iterator()，看看它遍历的是什么。</p>
<p>@Override<br>
public Iterator<ServletContextInitializer> iterator() {<br>
return this.sortedList.iterator();<br>
}</p>
<p>此集合类对外暴露的集合遍历元素为 sortedList 成员变量，也就是说，上述 selfInitialize() 最终遍历的即为 sortedList 成员变量。</p>
<p>到这，我们可以进一步确定下结论：selfInitialize() 中是通过 getServletContextInitializerBeans() 获取到的 ServletContextInitializer 类型的 Beans 集合，即为 ServletContextInitializerBeans 的类型成员变量 sortedList。反过来说，<strong>sortedList 中的过滤器 Bean 元素顺序，决定了最终过滤器的执行顺序</strong>。</p>
<p>现在我们继续查看 ServletContextInitializerBeans 的构造方法如下：</p>
<p>public ServletContextInitializerBeans(ListableBeanFactory beanFactory,<br>
Class&lt;? extends ServletContextInitializer&gt;&hellip; initializerTypes) {<br>
this.initializers = new LinkedMultiValueMap&lt;&gt;();<br>
this.initializerTypes = (initializerTypes.length != 0) ? Arrays.asList(initializerTypes)<br>
: Collections.singletonList(ServletContextInitializer.class);<br>
addServletContextInitializerBeans(beanFactory);<br>
addAdaptableBeans(beanFactory);<br>
List<ServletContextInitializer> sortedInitializers = this.initializers.values().stream()<br>
.flatMap((value) -&gt; value.stream().sorted(AnnotationAwareOrderComparator.INSTANCE))<br>
.collect(Collectors.toList());<br>
this.sortedList = Collections.unmodifiableList(sortedInitializers);<br>
logMappings(this.initializers);<br>
}</p>
<p>通过第 8 行，可以得知：我们关心的类成员变量 this.sortedList，其元素顺序是由类成员变量 this.initializers 的 values 通过比较器 AnnotationAwareOrderComparator 进行排序的。</p>
<p>继续查看 AnnotationAwareOrderComparator 比较器，忽略比较器调用的细节过程，其最终是通过两种方式获取比较器需要的 order 值，来决定 sortedInitializers 的排列顺序：</p>
<ol>
<li>待排序的对象元素自身实现了 Order 接口，则直接通过 getOrder() 获取 order 值；</li>
<li>否则执行 OrderUtils.findOrder() 获取该对象类 @Order 的属性。</li>
</ol>
<p>这里多解释一句，因为 this.initializers 的 values 类型为 ServletContextInitializer，其实现了 Ordered 接口，所以这里的比较器显然是使用了 getOrder() 获取比较器所需的 order 值，对应的类成员变量即为 order。</p>
<p>继续查看 this.initializers 中的元素在何处被添加，我们最终得知，addServletContextInitializerBeans() 以及 addAdaptableBeans() 这两个方法均构建了 ServletContextInitializer 子类的实例，并添加到了 this.initializers 成员变量中。在这里，我们只研究 addServletContextInitializerBeans，毕竟我们使用的添加过滤器方式（使用 @WebFilter 标记）最终只会通过这个方法生效。</p>
<p>在这个方法中，Spring 通过 getOrderedBeansOfType() 实例化了所有 ServletContextInitializer 的子类：</p>
<p>private void addServletContextInitializerBeans(ListableBeanFactory beanFactory) {<br>
for (Class&lt;? extends ServletContextInitializer&gt; initializerType : this.initializerTypes) {<br>
for (Entry&lt;String, ? extends ServletContextInitializer&gt; initializerBean : getOrderedBeansOfType(beanFactory,<br>
initializerType)) {<br>
addServletContextInitializerBean(initializerBean.getKey(), initializerBean.getValue(), beanFactory);<br>
}<br>
}<br>
}</p>
<p>根据其不同类型，调用 addServletContextInitializerBean()，我们可以看出 ServletContextInitializer 的子类包括了 ServletRegistrationBean、FilterRegistrationBean 以及 ServletListenerRegistrationBean，正好对应了 Servlet 的三大要素。</p>
<p>而这里我们只需要关心对应于 Filter 的 FilterRegistrationBean，显然，FilterRegistrationBean 是 ServletContextInitializer 的子类（实现了 Ordered 接口），同样由<strong>成员变量 order 的值决定其执行的优先级。</strong></p>
<p>private void addServletContextInitializerBean(String beanName, ServletContextInitializer initializer,<br>
ListableBeanFactory beanFactory) {<br>
if (initializer instanceof ServletRegistrationBean) {<br>
Servlet source = ((ServletRegistrationBean<?>) initializer).getServlet();<br>
addServletContextInitializerBean(Servlet.class, beanName, initializer, beanFactory, source);<br>
}<br>
else if (initializer instanceof FilterRegistrationBean) {<br>
Filter source = ((FilterRegistrationBean<?>) initializer).getFilter();<br>
addServletContextInitializerBean(Filter.class, beanName, initializer, beanFactory, source);<br>
}<br>
else if (initializer instanceof DelegatingFilterProxyRegistrationBean) {<br>
String source = ((DelegatingFilterProxyRegistrationBean) initializer).getTargetBeanName();<br>
addServletContextInitializerBean(Filter.class, beanName, initializer, beanFactory, source);<br>
}<br>
else if (initializer instanceof ServletListenerRegistrationBean) {<br>
EventListener source = ((ServletListenerRegistrationBean<?>) initializer).getListener();<br>
addServletContextInitializerBean(EventListener.class, beanName, initializer, beanFactory, source);<br>
}<br>
else {<br>
addServletContextInitializerBean(ServletContextInitializer.class, beanName, initializer, beanFactory,<br>
initializer);<br>
}<br>
}</p>
<p>最终添加到 this.initializers 成员变量中：</p>
<p>private void addServletContextInitializerBean(Class<?> type, String beanName, ServletContextInitializer initializer,<br>
ListableBeanFactory beanFactory, Object source) {<br>
this.initializers.add(type, initializer);<br>
// 省略非关键代码<br>
}</p>
<p>通过上述代码，我们再次看到了 FilterRegistrationBean。但问题来了，我们没有定义 FilterRegistrationBean，那么这里的 FilterRegistrationBean 是在哪里被定义的呢？其 order 类成员变量是否有特定的取值逻辑？</p>
<p>不妨回想下上节课的案例 1，它是在 WebFilterHandler 类的 doHandle() 动态构建了 FilterRegistrationBean 的 BeanDefinition：</p>
<p>class WebFilterHandler extends ServletComponentHandler {</p>
<p>WebFilterHandler() {<br>
super(WebFilter.class);<br>
}</p>
<p>@Override<br>
public void doHandle(Map&lt;String, Object&gt; attributes, AnnotatedBeanDefinition beanDefinition,<br>
BeanDefinitionRegistry registry) {<br>
BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(FilterRegistrationBean.class);<br>
builder.addPropertyValue(&ldquo;asyncSupported&rdquo;, attributes.get(&ldquo;asyncSupported&rdquo;));<br>
builder.addPropertyValue(&ldquo;dispatcherTypes&rdquo;, extractDispatcherTypes(attributes));<br>
builder.addPropertyValue(&ldquo;filter&rdquo;, beanDefinition);<br>
builder.addPropertyValue(&ldquo;initParameters&rdquo;, extractInitParameters(attributes));<br>
String name = determineName(attributes, beanDefinition);<br>
builder.addPropertyValue(&ldquo;name&rdquo;, name);<br>
builder.addPropertyValue(&ldquo;servletNames&rdquo;, attributes.get(&ldquo;servletNames&rdquo;));<br>
builder.addPropertyValue(&ldquo;urlPatterns&rdquo;, extractUrlPatterns(attributes));<br>
registry.registerBeanDefinition(name, builder.getBeanDefinition());<br>
}<br>
// 省略非关键代码</p>
<p>这里我再次贴出了 WebFilterHandler 中 doHandle() 的逻辑（即通过 BeanDefinitionBuilder 动态构建了 FilterRegistrationBean 类型的 BeanDefinition）。然而遗憾的是，<strong>此处并没有设置 order 的值，更没有根据 @Order 指定的值去设置。</strong></p>
<p>到这里我们终于看清楚了问题的本质，所有被 @WebFilter 注解的类，最终都会在此处被包装为 FilterRegistrationBean 类的 BeanDefinition。虽然 FilterRegistrationBean 也拥有 Ordered 接口，但此处却并没有填充值，因为这里所有的属性都是从 @WebFilter 对应的属性获取的，而 @WebFilter 本身没有指定可以辅助排序的属性。</p>
<p>现在我们来总结下，过滤器的执行顺序是由下面这个串联决定的：</p>
<blockquote>
<p>RegistrationBean 中 order 属性的值 -&gt;</p>
<p>ServletContextInitializerBeans 类成员变量 sortedList 中元素的顺序 -&gt;</p>
<p>ServletWebServerApplicationContext 中 selfInitialize() 遍历 FilterRegistrationBean 的顺序 -&gt;</p>
<p>addFilterMapBefore() 调用的顺序 -&gt;</p>
<p>filterMaps 内元素的顺序 -&gt;</p>
<p>过滤器的执行顺序</p>
</blockquote>
<p>可见，RegistrationBean 中 order 属性的值最终可以决定过滤器的执行顺序。但是可惜的是：当使用 @WebFilter 时，构建的 FilterRegistrationBean 并没有依据 @Order 的值去设置 order 属性，所以 @Order 失效了。</p>
<h3 id="问题修正">问题修正</h3>
<p>现在，我们理清了 Spring 启动 Web 服务之前的一些必要类的初始化流程，同时也弄清楚了 @Order 和 @WebFilter 同时使用失效的原因，但这个问题想要解决却并非那么简单。</p>
<p>这里我先提供给你一个常见的做法，即实现自己的 FilterRegistrationBean 来配置添加过滤器，不再使用 @WebFilter。具体代码如下：</p>
<p>@Configuration<br>
public class FilterConfiguration {<br>
@Bean<br>
public FilterRegistrationBean authFilter() {<br>
FilterRegistrationBean registration = new FilterRegistrationBean();<br>
registration.setFilter(new AuthFilter());<br>
registration.addUrlPatterns(&quot;/*&quot;);<br>
registration.setOrder(2);<br>
return registration;<br>
}</p>
<pre><code>@Bean  
public FilterRegistrationBean timeCostFilter() {  
    FilterRegistrationBean registration = new FilterRegistrationBean();  
    registration.setFilter(new TimeCostFilter());  
    registration.addUrlPatterns(&quot;/*&quot;);  
    registration.setOrder(1);  
    return registration;  
}  
</code></pre>
<p>}</p>
<p>按照我们查看的源码中的逻辑，虽然 WebFilterHandler 中 doHandle() 构建了 FilterRegistrationBean 类型的 BeanDefinition，但<strong>没有设置 order 的值</strong>。</p>
<p>所以在这里，我们直接手工实例化了 FilterRegistrationBean 实例，而且设置了其 setOrder()。同时不要忘记去掉 AuthFilter 和 TimeCostFilter 类中的 @WebFilter，这样问题就得以解决了。</p>
<h2 id="案例-2过滤器被多次执行">案例 2：过滤器被多次执行</h2>
<p>我们继续沿用上面的案例代码，要解决排序问题，可能有人就想了是不是有其他的解决方案呢？比如我们能否在两个过滤器中增加 @Component，从而让 @Order 生效呢？代码如下。</p>
<p>AuthFilter：</p>
<p>@WebFilter<br>
@Slf4j<br>
@Order(2)<br>
@Component<br>
public class AuthFilter implements Filter {<br>
@SneakyThrows<br>
@Override<br>
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain){<br>
if(isPassAuth()){<br>
System.out.println(&ldquo;通过授权&rdquo;);<br>
chain.doFilter(request, response);<br>
}else{<br>
System.out.println(&ldquo;未通过授权&rdquo;);<br>
((HttpServletResponse)response).sendError(401);<br>
}<br>
}<br>
private boolean isPassAuth() throws InterruptedException {<br>
System.out.println(&ldquo;执行检查权限&rdquo;);<br>
Thread.sleep(1000);<br>
return true;<br>
}<br>
}</p>
<p>TimeCostFilter 类如下：</p>
<p>@WebFilter<br>
@Slf4j<br>
@Order(1)<br>
@Component<br>
public class TimeCostFilter implements Filter {<br>
@Override<br>
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {<br>
System.out.println(&quot;#开始计算接口耗时&quot;);<br>
long start = System.currentTimeMillis();<br>
chain.doFilter(request, response);<br>
long end = System.currentTimeMillis();<br>
long time = end - start;<br>
System.out.println(&quot;#执行时间 (ms)：&quot; + time);<br>
}<br>
}</p>
<p>最终执行结果如下：</p>
<p>#开始计算接口耗时<br>
执行检查权限<br>
通过授权<br>
执行检查权限<br>
通过授权<br>
#开始计算接口耗时<br>
&hellip;&hellip;用户注册成功<br>
#执行时间 (ms)：73<br>
#执行时间 (ms)：2075</p>
<p>更改 AuthFilter 类中的 Order 值为 0，继续测试，得到结果如下：</p>
<p>执行检查权限<br>
通过授权<br>
#开始计算接口耗时<br>
执行检查权限<br>
通过授权<br>
#开始计算接口耗时<br>
&hellip;&hellip;用户注册成功<br>
#执行时间 (ms)：96<br>
#执行时间 (ms)：1100</p>
<p>显然，通过 Order 的值，我们已经可以随意调整 Filter 的执行顺序，但是我们会惊奇地发现，过滤器本身被执行了 2 次，这明显不符合我们的预期！那么如何理解这个现象呢？</p>
<h3 id="案例解析-1">案例解析</h3>
<p>从案例 1 中我们已经得知被 @WebFilter 的过滤器，会在 WebServletHandler 类中被重新包装为 FilterRegistrationBean 类的 BeanDefinition，而并非是 Filter 类型。</p>
<p>而当我们在自定义过滤器中增加 @Component 时，我们可以大胆猜测下：理论上 Spring 会根据当前类再次包装一个新的过滤器，因而 doFIlter() 被执行两次。因此看似奇怪的测试结果，也在情理之中了。</p>
<p>我们继续从源码中寻找真相，继续查阅 ServletContextInitializerBeans 的构造方法如下：</p>
<p>public ServletContextInitializerBeans(ListableBeanFactory beanFactory,<br>
Class&lt;? extends ServletContextInitializer&gt;&hellip; initializerTypes) {<br>
this.initializers = new LinkedMultiValueMap&lt;&gt;();<br>
this.initializerTypes = (initializerTypes.length != 0) ? Arrays.asList(initializerTypes)<br>
: Collections.singletonList(ServletContextInitializer.class);<br>
addServletContextInitializerBeans(beanFactory);<br>
addAdaptableBeans(beanFactory);<br>
List<ServletContextInitializer> sortedInitializers = this.initializers.values().stream()<br>
.flatMap((value) -&gt; value.stream().sorted(AnnotationAwareOrderComparator.INSTANCE))<br>
.collect(Collectors.toList());<br>
this.sortedList = Collections.unmodifiableList(sortedInitializers);<br>
logMappings(this.initializers);<br>
}</p>
<p>上一个案例中，我们关注了 addServletContextInitializerBeans()，了解了它的作用是实例化并注册了所有 FilterRegistrationBean 类型的过滤器（严格说，是实例化并注册了所有的 ServletRegistrationBean、FilterRegistrationBean 以及 ServletListenerRegistrationBean，但这里我们只关注 FilterRegistrationBean）。</p>
<p>而第 7 行的 addAdaptableBeans()，其作用则是实例化所有实现 Filter 接口的类（严格说，是实例化并注册了所有实现 Servlet、Filter 以及 EventListener 接口的类），然后再逐一包装为 FilterRegistrationBean。</p>
<p>之所以 Spring 能够直接实例化 FilterRegistrationBean 类型的过滤器，这是因为：</p>
<ol>
<li>WebFilterHandler 相关类通过扫描 @WebFilter，动态构建了 FilterRegistrationBean 类型的 BeanDefinition，并注册到 Spring；</li>
<li>或者我们自己使用 @Bean 来显式实例化 FilterRegistrationBean 并注册到 Spring，如案例 1 中的解决方案。</li>
</ol>
<p>但 Filter 类型的过滤器如何才能被 Spring 直接实例化呢？相信你已经有答案了：<strong>任何通过 @Component 修饰的的类，都可以自动注册到 Spring，且能被 Spring 直接实例化。</strong></p>
<p>现在我们直接查看 addAdaptableBeans()，其调用了 addAsRegistrationBean()，其 beanType 为 Filter.class：</p>
<p>protected void addAdaptableBeans(ListableBeanFactory beanFactory) {<br>
// 省略非关键代码<br>
addAsRegistrationBean(beanFactory, Filter.class, new FilterRegistrationBeanAdapter());<br>
// 省略非关键代码<br>
}</p>
<p>继续查看最终调用到的方法 addAsRegistrationBean()：</p>
<p>private &lt;T, B extends T&gt; void addAsRegistrationBean(ListableBeanFactory beanFactory, Class<T> type,<br>
Class<B> beanType, RegistrationBeanAdapter<T> adapter) {<br>
List&lt;Map.Entry&lt;String, B&raquo; entries = getOrderedBeansOfType(beanFactory, beanType, this.seen);<br>
for (Entry&lt;String, B&gt; entry : entries) {<br>
String beanName = entry.getKey();<br>
B bean = entry.getValue();<br>
if (this.seen.add(bean)) {<br>
// One that we haven&rsquo;t already seen<br>
RegistrationBean registration = adapter.createRegistrationBean(beanName, bean, entries.size());<br>
int order = getOrder(bean);<br>
registration.setOrder(order);<br>
this.initializers.add(type, registration);<br>
if (logger.isTraceEnabled()) {<br>
logger.trace(&ldquo;Created &quot; + type.getSimpleName() + &quot; initializer for bean &lsquo;&rdquo; + beanName + &ldquo;&rsquo;; order=&rdquo;<br>
+ order + &ldquo;, resource=&rdquo; + getResourceDescription(beanName, beanFactory));<br>
}<br>
}<br>
}<br>
}</p>
<p>主要逻辑如下：</p>
<ol>
<li>通过 getOrderedBeansOfType() 创建了所有 Filter 子类的实例，即所有实现 Filter 接口且被 @Component 修饰的类；</li>
<li>依次遍历这些 Filter 类实例，并通过 RegistrationBeanAdapter 将这些类包装为 RegistrationBean；</li>
<li>获取 Filter 类实例的 Order 值，并设置到包装类 RegistrationBean 中；</li>
<li>将 RegistrationBean 添加到 this.initializers。</li>
</ol>
<p>到这，我们了解到，当过滤器同时被 @WebFilter 和 @Component 修饰时，会导致两个 FilterRegistrationBean 实例的产生。addServletContextInitializerBeans() 和 addAdaptableBeans() 最终都会创建 FilterRegistrationBean 的实例，但不同的是：</p>
<ol>
<li>@WebFilter 会让 addServletContextInitializerBeans() 实例化，并注册所有动态生成的 FilterRegistrationBean 类型的过滤器；</li>
<li>@Component 会让 addAdaptableBeans() 实例化所有实现 Filter 接口的类，然后再逐一包装为 FilterRegistrationBean 类型的过滤器。</li>
</ol>
<h3 id="问题修正-1">问题修正</h3>
<p>解决这个问题提及的顺序问题，自然可以继续参考案例 1 的问题修正部分。另外我们也可以去掉 @WebFilter 保留 @Component 的方式进行修改，修改后的 Filter 示例如下：</p>
<p>//@WebFilter<br>
@Slf4j<br>
@Order(1)<br>
@Component<br>
public class TimeCostFilter implements Filter {<br>
//省略非关键代码<br>
}</p>
<h2 id="重点回顾">重点回顾</h2>
<p>这节课我们分析了过滤器在 Spring 框架中注册、包装以及实例化的整个流程，最后我们再次回顾下重点。</p>
<p>@WebFilter 和 @Component 的相同点是：</p>
<ol>
<li>它们最终都被包装并实例化成为了 FilterRegistrationBean；</li>
<li>它们最终都是在 ServletContextInitializerBeans 的构造器中开始被实例化。</li>
</ol>
<p>@WebFilter 和 @Component 的不同点是：</p>
<ol>
<li>被 @WebFilter 修饰的过滤器会被提前在 BeanFactoryPostProcessors 扩展点包装成 FilterRegistrationBean 类型的 BeanDefinition，然后在 ServletContextInitializerBeans.addServletContextInitializerBeans() 进行实例化；而使用 @Component 修饰的过滤器类，是在 ServletContextInitializerBeans.addAdaptableBeans() 中被实例化成 Filter 类型后，再包装为 RegistrationBean 类型。</li>
<li>被 @WebFilter 修饰的过滤器不会注入 Order 属性，但被 @Component 修饰的过滤器会在 ServletContextInitializerBeans.addAdaptableBeans() 中注入 Order 属性。</li>
</ol>
<h2 id="思考题">思考题</h2>
<p>这节课的两个案例，它们都是在 Tomcat 容器启动时发生的，但你了解 Spring 是如何整合 Tomcat，使其在启动时注册这些过滤器吗？</p>
<p>期待你的思考，我们留言区见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/">Spring编程常见错误50例</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/14__sfinae%E4%B8%8D%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%E6%9B%BF%E6%8D%A2%E5%A4%B1%E8%B4%A5%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B_/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">14__SFINAE：不是错误的替换失败是怎么回事_</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/14__super.xxx%E8%99%BD%E7%84%B6%E7%9B%B4%E5%88%B0es10%E8%BF%98%E6%98%AF%E4%B8%AA%E5%8D%8A%E5%90%8A%E5%AD%90%E5%AE%9E%E7%8E%B0%E5%8D%B4%E4%B9%9F%E5%80%BC%E5%BE%97%E4%B8%80%E8%AE%B2/">
            <span class="next-text nav-default">14__super.xxx()：虽然直到ES10还是个半吊子实现，却也值得一讲</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
