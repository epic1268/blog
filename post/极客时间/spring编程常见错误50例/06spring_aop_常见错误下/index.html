<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>06｜Spring_AOP_常见错误（下） - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是傅健。
上一节课，我们介绍了 Spring AOP 常遇到的几个问题，通过具体的源码解析，相信你对 Spring AOP 的基本原理已经有所了解了。不过，AOP 毕竟是 Spring 的核心功能之一，不可能规避那零散的两三个问题就一劳永逸了。所以这节课，我们继续聊聊 Spring AOP 中还会有哪些易错点。实际上，当一个系统采用的切面越来越多时，因为执行顺序而导致的问题便会逐步暴露出来，下面我们就重点看一下。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/06spring_aop_%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%B8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/06spring_aop_%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%B8%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="06｜Spring_AOP_常见错误（下）">
  <meta property="og:description" content="你好，我是傅健。
上一节课，我们介绍了 Spring AOP 常遇到的几个问题，通过具体的源码解析，相信你对 Spring AOP 的基本原理已经有所了解了。不过，AOP 毕竟是 Spring 的核心功能之一，不可能规避那零散的两三个问题就一劳永逸了。所以这节课，我们继续聊聊 Spring AOP 中还会有哪些易错点。实际上，当一个系统采用的切面越来越多时，因为执行顺序而导致的问题便会逐步暴露出来，下面我们就重点看一下。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Spring编程常见错误50例">

  <meta itemprop="name" content="06｜Spring_AOP_常见错误（下）">
  <meta itemprop="description" content="你好，我是傅健。
上一节课，我们介绍了 Spring AOP 常遇到的几个问题，通过具体的源码解析，相信你对 Spring AOP 的基本原理已经有所了解了。不过，AOP 毕竟是 Spring 的核心功能之一，不可能规避那零散的两三个问题就一劳永逸了。所以这节课，我们继续聊聊 Spring AOP 中还会有哪些易错点。实际上，当一个系统采用的切面越来越多时，因为执行顺序而导致的问题便会逐步暴露出来，下面我们就重点看一下。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5342">
  <meta itemprop="keywords" content="Spring编程常见错误50例">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="06｜Spring_AOP_常见错误（下）">
  <meta name="twitter:description" content="你好，我是傅健。
上一节课，我们介绍了 Spring AOP 常遇到的几个问题，通过具体的源码解析，相信你对 Spring AOP 的基本原理已经有所了解了。不过，AOP 毕竟是 Spring 的核心功能之一，不可能规避那零散的两三个问题就一劳永逸了。所以这节课，我们继续聊聊 Spring AOP 中还会有哪些易错点。实际上，当一个系统采用的切面越来越多时，因为执行顺序而导致的问题便会逐步暴露出来，下面我们就重点看一下。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">06｜Spring_AOP_常见错误（下）</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5342 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#案例-1错乱混合不同类型的增强">案例 1：错乱混合不同类型的增强</a>
          <ul>
            <li><a href="#案例解析">案例解析</a></li>
            <li><a href="#问题修正">问题修正</a></li>
          </ul>
        </li>
        <li><a href="#案例-2错乱混合同类型增强">案例 2：错乱混合同类型增强</a>
          <ul>
            <li><a href="#案例解析-1">案例解析</a></li>
            <li><a href="#问题修正-1">问题修正</a></li>
          </ul>
        </li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是傅健。</p>
<p>上一节课，我们介绍了 Spring AOP 常遇到的几个问题，通过具体的源码解析，相信你对 Spring AOP 的基本原理已经有所了解了。不过，AOP 毕竟是 Spring 的核心功能之一，不可能规避那零散的两三个问题就一劳永逸了。所以这节课，我们继续聊聊 Spring AOP 中还会有哪些易错点。实际上，当一个系统采用的切面越来越多时，因为执行顺序而导致的问题便会逐步暴露出来，下面我们就重点看一下。</p>
<h2 id="案例-1错乱混合不同类型的增强">案例 1：错乱混合不同类型的增强</h2>
<p>还是沿用上节课的宿舍管理系统开发场景。</p>
<p>这里我们先回顾下，你就不用去翻代码了。这个宿舍管理系统保护了一个电费充值模块，它包含了一个负责电费充值的类 ElectricService，还有一个充电方法 charge()：</p>
<p>@Service<br>
public class ElectricService {<br>
public void charge() throws Exception {<br>
System.out.println(&ldquo;Electric charging &hellip;&rdquo;);<br>
}<br>
}</p>
<p>为了在执行 charge() 之前，鉴定下调用者的权限，我们增加了针对于 Electric 的切面类 AopConfig，其中包含一个 @Before 增强。这里的增强没有做任何事情，仅仅是打印了一行日志，然后模拟执行权限校验功能（占用 1 秒钟）。</p>
<p>//省略 imports<br>
@Aspect<br>
@Service<br>
@Slf4j<br>
public class AspectService {<br>
@Before(&ldquo;execution(* com.spring.puzzle.class6.example1.ElectricService.charge()) &ldquo;)<br>
public void checkAuthority(JoinPoint pjp) throws Throwable {<br>
System.out.println(&ldquo;validating user authority&rdquo;);<br>
Thread.sleep(1000);<br>
}<br>
}</p>
<p>执行后，我们得到以下 log，接着一切按照预期继续执行：</p>
<p>validating user authority<br>
Electric charging &hellip;</p>
<p>一段时间后，由于业务发展，ElectricService 中的 charge() 逻辑变得更加复杂了，我们需要仅仅针对 ElectricService 的 charge() 做性能统计。为了不影响原有的业务逻辑，我们在 AopConfig 中添加了另一个增强，代码更改后如下：</p>
<p>//省略 imports<br>
@Aspect<br>
@Service<br>
public class AopConfig {<br>
@Before(&ldquo;execution(* com.spring.puzzle.class6.example1.ElectricService.charge()) &ldquo;)<br>
public void checkAuthority(JoinPoint pjp) throws Throwable {<br>
System.out.println(&ldquo;validating user authority&rdquo;);<br>
Thread.sleep(1000);<br>
}</p>
<pre><code>@Around(&quot;execution(* com.spring.puzzle.class6.example1.ElectricService.charge()) &quot;)  
public void recordPerformance(ProceedingJoinPoint pjp) throws Throwable {  
    long start = System.currentTimeMillis();  
    pjp.proceed();  
    long end = System.currentTimeMillis();  
    System.out.println(&quot;charge method time cost: &quot; + (end - start));  
}  
</code></pre>
<p>}</p>
<p>执行后得到日志如下：</p>
<blockquote>
<p>validating user authority</p>
<p>Electric charging &hellip;</p>
<p>charge method time cost 1022 (ms)</p>
</blockquote>
<p>通过性能统计打印出的日志，我们可以得知 charge() 执行时间超过了 1 秒钟。然而，该方法仅打印了一行日志，它的执行不可能需要这么长时间。</p>
<p>因此我们很容易看出问题所在：当前 ElectricService 中 charge() 的执行时间，包含了权限验证的时间，即包含了通过 @Around 增强的 checkAuthority() 执行的所有时间。这并不符合我们的初衷，我们需要统计的仅仅是 ElectricService.charge() 的性能统计，它并不包含鉴权过程。</p>
<p>当然，这些都是从日志直接观察出的现象。实际上，这个问题出现的根本原因和 AOP 的执行顺序有关。针对这个案例而言，当同一个切面（Aspect）中同时包含多个不同类型的增强时（Around、Before、After、AfterReturning、AfterThrowing 等），它们的执行是有顺序的。那么顺序如何？我们不妨来解析下。</p>
<h3 id="案例解析">案例解析</h3>
<p>其实一切都可以从源码中得到真相！在第 04 课我们曾经提到过，Spring 初始化单例类的一般过程，基本都是 getBean()-&gt;doGetBean()-&gt;getSingleton()，如果发现 Bean 不存在，则调用 createBean()-&gt;doCreateBean() 进行实例化。</p>
<p>而如果我们的代码里使用了 Spring AOP，doCreateBean() 最终会返回一个代理对象。至于代理对象如何创建，大体流程我们在上一讲已经概述过了。如果你记忆力比较好的话，应该记得在代理对象的创建过程中，我们贴出过这样一段代码（参考 AbstractAutoProxyCreator#createProxy）：</p>
<p>protected Object createProxy(Class<?> beanClass, @Nullable String beanName,<br>
@Nullable Object[] specificInterceptors, TargetSource targetSource) {<br>
//省略非关键代码<br>
Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);<br>
proxyFactory.addAdvisors(advisors);<br>
proxyFactory.setTargetSource(targetSource);<br>
//省略非关键代码<br>
return proxyFactory.getProxy(getProxyClassLoader());<br>
}</p>
<p>其中 advisors 就是增强方法对象，它的顺序决定了面临多个增强时，到底先执行谁。而这个集合对象本身是由 specificInterceptors 构建出来的，而 specificInterceptors 又是由 AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean 方法构建：</p>
<p>@Override<br>
@Nullable<br>
protected Object[] getAdvicesAndAdvisorsForBean(<br>
Class<?> beanClass, String beanName, @Nullable TargetSource targetSource) {<br>
List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);<br>
if (advisors.isEmpty()) {<br>
return DO_NOT_PROXY;<br>
}<br>
return advisors.toArray();<br>
}</p>
<p>简单说，其实就是根据当前的 beanClass、beanName 等信息，结合所有候选的 advisors，最终找出匹配（Eligible）的 Advisor，为什么如此？毕竟 AOP 拦截点可能会配置多个，而我们执行的方法不见得会被所有的拦截配置拦截。寻找匹配 Advisor 的逻辑参考 AbstractAdvisorAutoProxyCreator#findEligibleAdvisors：</p>
<p>protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {<br>
//寻找候选的 Advisor<br>
List<Advisor> candidateAdvisors = findCandidateAdvisors();<br>
//根据候选的 Advisor 和当前 bean 算出匹配的 Advisor<br>
List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);<br>
extendAdvisors(eligibleAdvisors);<br>
if (!eligibleAdvisors.isEmpty()) {<br>
//排序<br>
eligibleAdvisors = sortAdvisors(eligibleAdvisors);<br>
}<br>
return eligibleAdvisors;<br>
}</p>
<p>通过研读代码，最终 Advisors 的顺序是由两点决定：</p>
<ol>
<li>candidateAdvisors 的顺序；</li>
<li>sortAdvisors 进行的排序。</li>
</ol>
<p>这里我们可以重点看下对本案例起关键作用的 candidateAdvisors 排序。实际上，它的顺序是在 @Aspect 标记的 AopConfig Bean 构建时就决定了。具体而言，就是在初始化过程中会排序自己配置的 Advisors，并把排序结果存入了缓存（BeanFactoryAspectJAdvisorsBuilder#advisorsCache）。</p>
<p>后续 Bean 创建代理时，直接拿出这个排序好的候选 Advisors。候选 Advisors 排序发生在 Bean 构建这个结论时，我们也可以通过 AopConfig Bean 构建中的堆栈信息验证：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/a1ed508a186abf00852cd6beef01acd1.png" alt=""></p>
<p>可以看到，排序是在 Bean 的构建中进行的，而最后排序执行的关键代码位于下面的方法中（参考 ReflectiveAspectJAdvisorFactory#getAdvisorMethods）：</p>
<p>private List<Method> getAdvisorMethods(Class<?> aspectClass) {<br>
final List<Method> methods = new ArrayList&lt;&gt;();<br>
ReflectionUtils.doWithMethods(aspectClass, method -&gt; {<br>
// Exclude pointcuts<br>
if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) {<br>
methods.add(method);<br>
}<br>
}, ReflectionUtils.USER_DECLARED_METHODS);<br>
// 排序<br>
methods.sort(METHOD_COMPARATOR);<br>
return methods;<br>
}</p>
<p>上述代码的重点是第九行 methods.sort(METHOD_COMPARATOR) 方法。</p>
<p>我们来查看 METHOD_COMPARATOR 的代码，会发现它是定义在 ReflectiveAspectJAdvisorFactory 类中的静态方法块，代码如下：</p>
<p>static {<br>
Comparator<Method> adviceKindComparator = new ConvertingComparator&lt;&gt;(<br>
new InstanceComparator&lt;&gt;(<br>
Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class),<br>
(Converter&lt;Method, Annotation&gt;) method -&gt; {<br>
AspectJAnnotation<?> annotation =<br>
AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);<br>
return (annotation != null ? annotation.getAnnotation() : null);<br>
});<br>
Comparator<Method> methodNameComparator = new ConvertingComparator&lt;&gt;(Method::getName);<br>
//合并上面两者比较器<br>
METHOD_COMPARATOR = adviceKindComparator.thenComparing(methodNameComparator);<br>
}</p>
<p>METHOD_COMPARATOR 本质上是一个连续比较器，由 adviceKindComparator 和 methodNameComparator 这两个比较器通过 thenComparing() 连接而成。</p>
<p>通过这个案例，我们重点了解 adviceKindComparator 这个比较器，此对象通过实例化 ConvertingComparator 类而来，而 ConvertingComparator 类是 Spring 中较为经典的一个实现。顾名思义，先转化再比较，它构造参数接受以下这两个参数：</p>
<ol>
<li>第一个参数是基准比较器，即在 adviceKindComparator 中最终要调用的比较器，在构造函数中赋值于 this.comparator；</li>
<li>第二个参数是一个 lambda 回调函数，用来将传递的参数转化为基准比较器需要的参数类型，在构造函数中赋值于 this.converter。</li>
</ol>
<p>查看 ConvertingComparator 比较器核心方法 compare 如下：</p>
<p>public int compare(S o1, S o2) {<br>
T c1 = this.converter.convert(o1);<br>
T c2 = this.converter.convert(o2);<br>
return this.comparator.compare(c1, c2);<br>
}</p>
<p>可知，这里是先调用从构造函数中获取到的 lambda 回调函数 this.converter，将需要比较的参数进行转化。我们可以从之前的代码中找出这个转化工作：</p>
<p>(Converter&lt;Method, Annotation&gt;) method -&gt; {<br>
AspectJAnnotation<?> annotation =<br>
AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);<br>
return (annotation != null ? annotation.getAnnotation() : null);<br>
});</p>
<p>转化功能的代码逻辑较为简单，就是返回传入方法（method）上标记的增强注解（Pointcut,Around,Before,After,AfterReturning 以及 AfterThrowing）：</p>
<p>private static final Class<?>[] ASPECTJ_ANNOTATION_CLASSES = new Class<?>[] {<br>
Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class};</p>
<p>protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {<br>
for (Class<?> clazz : ASPECTJ_ANNOTATION_CLASSES) {<br>
AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) clazz);<br>
if (foundAnnotation != null) {<br>
return foundAnnotation;<br>
}<br>
}<br>
return null;<br>
}</p>
<p>经过转化后，我们获取到的待比较的数据其实就是注解了。而它们的排序依赖于 ConvertingComparator 的第一个参数，即最终会调用的基准比较器，以下是它的关键实现代码：</p>
<p>new InstanceComparator&lt;&gt;(<br>
Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class)</p>
<p>最终我们要调用的基准比较器本质上就是一个 InstanceComparator 类，我们先重点注意下这几个增强注解的传递顺序。继续查看它的构造方法如下：</p>
<p>public InstanceComparator(Class<?>&hellip; instanceOrder) {<br>
Assert.notNull(instanceOrder, &ldquo;&lsquo;instanceOrder&rsquo; array must not be null&rdquo;);<br>
this.instanceOrder = instanceOrder;<br>
}</p>
<p>构造方法也是较为简单的，只是将传递进来的 instanceOrder 赋予了类成员变量，继续查看 InstanceComparator 比较器核心方法 compare 如下，也就是最终要调用的比较方法：</p>
<p>public int compare(T o1, T o2) {<br>
int i1 = getOrder(o1);<br>
int i2 = getOrder(o2);<br>
return (i1 &lt; i2 ? -1 : (i1 == i2 ? 0 : 1));<br>
}</p>
<p>一个典型的 Comparator，代码逻辑按照 i1、i2 的升序排列，即 getOrder() 返回的值越小，排序越靠前。</p>
<p>查看 getOrder() 的逻辑如下：</p>
<p>private int getOrder(@Nullable T object) {<br>
if (object != null) {<br>
for (int i = 0; i &lt; this.instanceOrder.length; i++) {<br>
//instance 在 instanceOrder 中的“排号”<br>
if (this.instanceOrder[i].isInstance(object)) {<br>
return i;<br>
}<br>
}<br>
}<br>
return this.instanceOrder.length;<br>
}</p>
<p>返回当前传递的增强注解在 this.instanceOrder 中的序列值，序列值越小，则越靠前。而结合之前构造参数传递的顺序，我们很快就能判断出：最终的排序结果依次是 Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class。</p>
<p>到此为止，答案也呼之欲出：this.instanceOrder 的排序，即为不同类型增强的优先级，<strong>排序越靠前，优先级越高</strong>。</p>
<p>结合之前的讨论，我们可以得出一个结论：同一个切面中，不同类型的增强方法被调用的顺序依次为 Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class。</p>
<h3 id="问题修正">问题修正</h3>
<p>从上述案例解析中，我们知道 Around 类型的增强被调用的优先级高于 Before 类型的增强，所以上述案例中性能统计所花费的时间，包含权限验证的时间，也在情理之中。</p>
<p>知道了原理，修正起来也就简单了。假设不允许我们去拆分类，我们可以按照下面的思路来修改：</p>
<ol>
<li>将 ElectricService.charge() 的业务逻辑全部移动到 doCharge()，在 charge() 中调用 doCharge()；</li>
<li>性能统计只需要拦截 doCharge()；</li>
<li>权限统计增强保持不变，依然拦截 charge()。</li>
</ol>
<p>ElectricService 类代码更改如下：</p>
<p>@Service<br>
public class ElectricService {</p>
<pre><code>public void charge() {  
    doCharge();  
}  
public void doCharge() {  
    System.out.println(&quot;Electric charging ...&quot;);  
}  
</code></pre>
<p>}</p>
<p>切面代码更改如下：</p>
<p>//省略 imports<br>
@Aspect<br>
@Service<br>
public class AopConfig {<br>
@Before(&ldquo;execution(* com.spring.puzzle.class6.example1.ElectricService.charge()) &ldquo;)<br>
public void checkAuthority(JoinPoint pjp) throws Throwable {<br>
System.out.println(&ldquo;validating user authority&rdquo;);<br>
Thread.sleep(1000);<br>
}</p>
<pre><code>@Around(&quot;execution(* com.spring.puzzle.class6.example1.ElectricService.doCharge()) &quot;)  
public void recordPerformance(ProceedingJoinPoint pjp) throws Throwable {  
long start = System.currentTimeMillis();  
pjp.proceed();  
long end = System.currentTimeMillis();  
System.out.println(&quot;charge method time cost: &quot; + (end - start));  
</code></pre>
<p>}<br>
}</p>
<h2 id="案例-2错乱混合同类型增强">案例 2：错乱混合同类型增强</h2>
<p>那学到这里，你可能还有疑问，如果同一个切面里的多个增强方法其增强都一样，那调用顺序又如何呢？我们继续看下一个案例。</p>
<p>这里业务逻辑类 ElectricService 没有任何变化，仅包含一个 charge()：</p>
<p>import org.springframework.stereotype.Service;<br>
@Service<br>
public class ElectricService {<br>
public void charge() {<br>
System.out.println(&ldquo;Electric charging &hellip;&rdquo;);<br>
}<br>
}</p>
<p>切面类 AspectService 包含两个方法，都是 Before 类型增强。</p>
<p>第一个方法 logBeforeMethod()，目的是在 run() 执行之前希望能输入日志，表示当前方法被调用一次，方便后期统计。另一个方法 validateAuthority()，目的是做权限验证，其作用是在调用此方法之前做权限验证，如果不符合权限限制要求，则直接抛出异常。这里为了方便演示，此方法将直接抛出异常：</p>
<p>//省略 imports<br>
@Aspect<br>
@Service<br>
public class AopConfig {<br>
@Before(&ldquo;execution(* com.spring.puzzle.class5.example2.ElectricService.charge())&rdquo;)<br>
public void logBeforeMethod(JoinPoint pjp) throws Throwable {<br>
System.out.println(&ldquo;step into -&gt;&quot;+pjp.getSignature());<br>
}<br>
@Before(&ldquo;execution(* com.spring.puzzle.class5.example2.ElectricService.charge()) &ldquo;)<br>
public void validateAuthority(JoinPoint pjp) throws Throwable {<br>
throw new RuntimeException(&ldquo;authority check failed&rdquo;);<br>
}<br>
}</p>
<p>我们对代码的执行预期为：当鉴权失败时，由于 ElectricService.charge() 没有被调用，那么 run() 的调用日志也不应该被输出，即 logBeforeMethod() 不应该被调用，但事实总是出乎意料，执行结果如下：</p>
<blockquote>
<p>step into -&gt;void com.spring.puzzle.class6.example2.Electric.charge()</p>
<p>Exception in thread &ldquo;main&rdquo; java.lang.RuntimeException: authority check failed</p>
</blockquote>
<p>虽然鉴权失败，抛出了异常且 ElectricService.charge() 没有被调用，但是 logBeforeMethod() 的调用日志却被输出了，这将导致后期针对于 ElectricService.charge() 的调用数据统计严重失真。</p>
<p>这里我们就需要搞清楚一个问题：当同一个切面包含多个同一种类型的多个增强，且修饰的都是同一个方法时，这多个增强的执行顺序是怎样的？</p>
<h3 id="案例解析-1">案例解析</h3>
<p>我们继续从源代码中寻找真相！你应该还记得上述代码中，定义 METHOD_COMPARATOR 的静态代码块吧。</p>
<p>METHOD_COMPARATOR 本质是一个连续比较器，而上个案例中我们仅仅只看了第一个比较器，细心的你肯定发现了这里还有第二个比较器 methodNameComparator，任意两个比较器都可以通过其内置的 thenComparing() 连接形成一个连续比较器，从而可以让我们按照比较器的连接顺序依次比较：</p>
<p>static {<br>
//第一个比较器，用来按照增强类型排序<br>
Comparator<Method> adviceKindComparator = new ConvertingComparator&lt;&gt;(<br>
new InstanceComparator&lt;&gt;(<br>
Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class),<br>
(Converter&lt;Method, Annotation&gt;) method -&gt; {<br>
AspectJAnnotation<?> annotation =<br>
AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);<br>
return (annotation != null ? annotation.getAnnotation() : null);<br>
})<br>
//第二个比较器，用来按照方法名排序<br>
Comparator<Method> methodNameComparator = new ConvertingComparator&lt;&gt;(Method::getName);<br>
METHOD_COMPARATOR = adviceKindComparator.thenComparing(methodNameComparator);<br>
}</p>
<p>我们可以看到，在第 12 行代码中，第 2 个比较器 methodNameComparator 依然使用的是 ConvertingComparator，传递了方法名作为参数。我们基本可以猜测出该比较器是按照方法名进行排序的，这里可以进一步查看构造器方法及构造器调用的内部 comparable()：</p>
<p>public ConvertingComparator(Converter&lt;S, T&gt; converter) {<br>
this(Comparators.comparable(), converter);<br>
}<br>
// 省略非关键代码<br>
public static <T> Comparator<T> comparable() {<br>
return ComparableComparator.INSTANCE;<br>
}</p>
<p>上述代码中的 ComparableComparator 实例其实极其简单，代码如下：</p>
<p>public class ComparableComparator&lt;T extends Comparable<T>&gt; implements Comparator<T> {</p>
<p>public static final ComparableComparator INSTANCE = new ComparableComparator();</p>
<p>@Override<br>
public int compare(T o1, T o2) {<br>
return o1.compareTo(o2);<br>
}<br>
}</p>
<p>答案和我们的猜测完全一致，methodNameComparator 最终调用了 String 类自身的 compareTo()，代码如下：</p>
<p>public int compareTo(String anotherString) {<br>
int len1 = value.length;<br>
int len2 = anotherString.value.length;<br>
int lim = Math.min(len1, len2);<br>
char v1[] = value;<br>
char v2[] = anotherString.value;</p>
<pre><code>int k = 0;  
while (k &lt; lim) {  
    char c1 = v1[k];  
    char c2 = v2[k];  
    if (c1 != c2) {  
        return c1 - c2;  
    }  
    k++;  
}  
return len1 - len2;  
</code></pre>
<p>}</p>
<p>到这，答案揭晓：如果两个方法名长度相同，则依次比较每一个字母的 ASCII 码，ASCII 码越小，排序越靠前；若长度不同，且短的方法名字符串是长的子集时，短的排序靠前。</p>
<h3 id="问题修正-1">问题修正</h3>
<p>从上述分析我们得知，在同一个切面配置类中，针对同一个方法存在多个同类型增强时，其执行顺序仅和当前增强方法的名称有关，而不是由谁代码在先、谁代码在后来决定。了解了这点，我们就可以直接通过调整方法名的方式来修正程序：</p>
<p>//省略 imports<br>
@Aspect<br>
@Service<br>
public class AopConfig {<br>
@Before(&ldquo;execution(* com.spring.puzzle.class6.example2.ElectricService.charge())&rdquo;)<br>
public void logBeforeMethod(JoinPoint pjp) throws Throwable {<br>
System.out.println(&ldquo;step into -&gt;&quot;+pjp.getSignature());<br>
}<br>
@Before(&ldquo;execution(* com.spring.puzzle.class6.example2.ElectricService.charge()) &ldquo;)<br>
public void checkAuthority(JoinPoint pjp) throws Throwable {<br>
throw new RuntimeException(&ldquo;authority check failed&rdquo;);<br>
}<br>
}</p>
<p>我们可以将原来的 validateAuthority() 改为 checkAuthority()，这种情况下，<strong>对增强（Advisor）的排序，其实最后就是在比较字符 l 和 字符 c</strong>。显然易见，checkAuthority() 的排序会靠前，从而被优先执行，最终问题得以解决。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>通过学习这两个案例，相信你对 Spring AOP 增强方法的执行顺序已经有了较为深入的理解。这里我来总结下关键点：</p>
<ol>
<li>在同一个切面配置中，如果存在多个不同类型的增强，那么其执行优先级是按照增强类型的特定顺序排列，依次的增强类型为 Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class；</li>
<li>在同一个切面配置中，如果存在多个相同类型的增强，那么其执行优先级是按照该增强的方法名排序，排序方式依次为比较方法名的每一个字母，直到发现第一个不相同且 ASCII 码较小的字母。</li>
</ol>
<p>同时，这节课我们也拓展了一些比较器相关的知识：</p>
<ol>
<li>任意两个比较器（Comparator）可以通过 thenComparing() 连接合成一个新的连续比较器；</li>
<li>比较器的比较规则有一个简单的方法可以帮助你理解，就是最终一定需要对象两两比较，而比较的过程一定是比较这两个对象的同种属性。你只要抓住这两点：比较了什么属性以及比较的结果是什么就可以了，若比较结果为正数，则按照该属性的升序排列；若为负数，则按属性降序排列。</li>
</ol>
<h2 id="思考题">思考题</h2>
<p>实际上，审阅上面两个案例的修正方案，你会发现它们虽然改动很小，但是都还不够优美。那么有没有稍微优美点的替代方案呢？如果有，你知道背后的原理及关键源码吗？顺便你也可以想想，我为什么没有用更优美的方案呢？</p>
<p>期待在留言区看到你的思考，我们下节课再见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/">Spring编程常见错误50例</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2/06-mysql%E5%AE%9E%E6%88%9845%E8%AE%B2/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">06-MySQL实战45讲</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/vim%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/06%E7%AA%97%E5%8F%A3%E5%92%8C%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%BF%AE%E6%94%B9%E5%AF%B9%E6%AF%94%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/">
            <span class="next-text nav-default">06｜窗口和标签页：修改、对比多个文件的正确姿势</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
