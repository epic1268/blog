<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>16｜Spring_Exception_常见错误 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是傅健。
今天，我们来学习 Spring 的异常处理机制。Spring 提供了一套健全的异常处理框架，以便我们在开发应用的时候对异常进行处理。但是，我们也会在使用的时候遇到一些麻烦，接下来我将通过两个典型的错误案例，带着你结合源码进行深入了解。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/16spring_exception_%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/16spring_exception_%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="16｜Spring_Exception_常见错误">
  <meta property="og:description" content="你好，我是傅健。
今天，我们来学习 Spring 的异常处理机制。Spring 提供了一套健全的异常处理框架，以便我们在开发应用的时候对异常进行处理。但是，我们也会在使用的时候遇到一些麻烦，接下来我将通过两个典型的错误案例，带着你结合源码进行深入了解。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Spring编程常见错误50例">

  <meta itemprop="name" content="16｜Spring_Exception_常见错误">
  <meta itemprop="description" content="你好，我是傅健。
今天，我们来学习 Spring 的异常处理机制。Spring 提供了一套健全的异常处理框架，以便我们在开发应用的时候对异常进行处理。但是，我们也会在使用的时候遇到一些麻烦，接下来我将通过两个典型的错误案例，带着你结合源码进行深入了解。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4842">
  <meta itemprop="keywords" content="Spring编程常见错误50例">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="16｜Spring_Exception_常见错误">
  <meta name="twitter:description" content="你好，我是傅健。
今天，我们来学习 Spring 的异常处理机制。Spring 提供了一套健全的异常处理框架，以便我们在开发应用的时候对异常进行处理。但是，我们也会在使用的时候遇到一些麻烦，接下来我将通过两个典型的错误案例，带着你结合源码进行深入了解。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">16｜Spring_Exception_常见错误</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4842 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#案例-1小心过滤器异常">案例 1：小心过滤器异常</a>
          <ul>
            <li><a href="#案例解析">案例解析</a></li>
            <li><a href="#问题修正">问题修正</a></li>
          </ul>
        </li>
        <li><a href="#案例-2特殊的-404-异常">案例 2：特殊的 404 异常</a>
          <ul>
            <li><a href="#案例解析-1">案例解析</a></li>
            <li><a href="#问题修正-1">问题修正</a></li>
          </ul>
        </li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是傅健。</p>
<p>今天，我们来学习 Spring 的异常处理机制。Spring 提供了一套健全的异常处理框架，以便我们在开发应用的时候对异常进行处理。但是，我们也会在使用的时候遇到一些麻烦，接下来我将通过两个典型的错误案例，带着你结合源码进行深入了解。</p>
<h2 id="案例-1小心过滤器异常">案例 1：小心过滤器异常</h2>
<p>为了方便讲解，我们还是沿用之前在事务处理中用到的学生注册的案例，来讨论异常处理的问题：</p>
<p>@Controller<br>
@Slf4j<br>
public class StudentController {<br>
public StudentController(){<br>
System.out.println(&ldquo;construct&rdquo;);<br>
}</p>
<pre><code>@PostMapping(&quot;/regStudent/{name}&quot;)  
@ResponseBody  
public String saveUser(String name) throws Exception {  
    System.out.println(&quot;......用户注册成功&quot;);  
    return &quot;success&quot;;  
}  
</code></pre>
<p>}</p>
<p>​为了保证安全，这里需要给请求加一个保护，通过验证 Token 的方式来验证请求的合法性。这个 Token 需要在每次发送请求的时候带在请求的 header 中，header 的 key 是 Token。</p>
<p>为了校验这个 Token，我们引入了一个 Filter 来处理这个校验工作，这里我使用了一个最简单的 Token：111111。</p>
<p>当 Token 校验失败时，就会抛出一个自定义的 NotAllowException，交由 Spring 处理：</p>
<p>@WebFilter<br>
@Component<br>
public class PermissionFilter implements Filter {<br>
@Override<br>
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {<br>
HttpServletRequest httpServletRequest = (HttpServletRequest) request;<br>
String token = httpServletRequest.getHeader(&ldquo;token&rdquo;);</p>
<pre><code>    if (!&quot;111111&quot;.equals(token)) {  
        System.out.println(&quot;throw NotAllowException&quot;);  
        throw new NotAllowException();  
    }  
    chain.doFilter(request, response);  
}  


@Override  
public void init(FilterConfig filterConfig) throws ServletException {  
}  


@Override  
public void destroy() {  
}
</code></pre>
<p>NotAllowException 就是一个简单的 RuntimeException 的子类：</p>
<p>public class NotAllowException extends RuntimeException {<br>
public NotAllowException() {<br>
super();<br>
}<br>
}</p>
<p>同时，新增了一个 RestControllerAdvice 来处理这个异常，处理方式也很简单，就是返回一个 403 的 resultCode：</p>
<p>@RestControllerAdvice<br>
public class NotAllowExceptionHandler {<br>
@ExceptionHandler(NotAllowException.class)<br>
@ResponseBody<br>
public String handle() {<br>
System.out.println(&ldquo;403&rdquo;);<br>
return &ldquo;{&quot;resultCode&quot;: 403}&rdquo;;<br>
}<br>
}</p>
<p>为了验证一下失败的情况，我们模拟了一个请求，在 HTTP 请求头里加上一个 Token，值为 111，这样就会引发错误了，我们可以看看会不会被 NotAllowExceptionHandler 处理掉。</p>
<p>然而，在控制台上，我们只看到了下面这样的输出，这其实就说明了 NotAllowExceptionHandler 并没有生效。</p>
<p>throw NotAllowException</p>
<p>想下问题出在哪呢？我们不妨对 Spring 的异常处理过程先做一个了解。</p>
<h3 id="案例解析">案例解析</h3>
<p>我们先来回顾一下第 13 课讲过的过滤器执行流程图，这里我细化了一下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/abc0a9c2adcb2d121eee9adaa82cca40.png" alt=""></p>
<p>从这张图中可以看出，当所有的过滤器被执行完毕以后，Spring 才会进入 Servlet 相关的处理，而 DispatcherServlet 才是整个 Servlet 处理的核心，它是前端控制器设计模式的实现，提供 Spring Web MVC 的集中访问点并负责职责的分派。正是在这里，Spring 处理了请求和处理器之间的对应关系，以及这个案例我们所关注的问题——统一异常处理。</p>
<p>其实说到这里，我们已经了解到过滤器内异常无法被统一处理的大致原因，就是因为异常处理发生在上图的红色区域，即 DispatcherServlet 中的 doDispatch()，而此时，过滤器已经全部执行完毕了。</p>
<p>下面我们将深入分析 Spring Web 对异常统一处理的逻辑，深刻理解其内部原理。</p>
<p>**首先我们来了解下 ControllerAdvice 是如何被 Spring 加载并对外暴露的。**在 Spring Web 的核心配置类 WebMvcConfigurationSupport 中，被 @Bean 修饰的 handlerExceptionResolver()，会调用 addDefaultHandlerExceptionResolvers() 来添加默认的异常解析器。</p>
<p>@Bean<br>
public HandlerExceptionResolver handlerExceptionResolver(<br>
@Qualifier(&ldquo;mvcContentNegotiationManager&rdquo;) ContentNegotiationManager contentNegotiationManager) {<br>
List<HandlerExceptionResolver> exceptionResolvers = new ArrayList&lt;&gt;();<br>
configureHandlerExceptionResolvers(exceptionResolvers);<br>
if (exceptionResolvers.isEmpty()) {<br>
addDefaultHandlerExceptionResolvers(exceptionResolvers, contentNegotiationManager);<br>
}<br>
extendHandlerExceptionResolvers(exceptionResolvers);<br>
HandlerExceptionResolverComposite composite = new HandlerExceptionResolverComposite();<br>
composite.setOrder(0);<br>
composite.setExceptionResolvers(exceptionResolvers);<br>
return composite;<br>
}</p>
<p>最终按照下图的调用栈，Spring 实例化了 ExceptionHandlerExceptionResolver 类。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/de551a65faa19c7562a51130b668e2c5.png" alt=""></p>
<p>从源码中我们可以看出，ExceptionHandlerExceptionResolver 类实现了 InitializingBean 接口，并覆写了 afterPropertiesSet()。</p>
<p>public void afterPropertiesSet() {<br>
// Do this first, it may add ResponseBodyAdvice beans<br>
initExceptionHandlerAdviceCache();<br>
//省略非关键代码<br>
}</p>
<p>并在 initExceptionHandlerAdviceCache() 中完成了所有 ControllerAdvice 中的 ExceptionHandler 的初始化。其具体操作，就是查找所有 @ControllerAdvice 注解的 Bean，把它们放到成员变量 exceptionHandlerAdviceCache 中。</p>
<p>在我们这个案例里，就是指 NotAllowExceptionHandler 这个异常处理器。</p>
<p>private void initExceptionHandlerAdviceCache() {<br>
//省略非关键代码<br>
List<ControllerAdviceBean> adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());<br>
for (ControllerAdviceBean adviceBean : adviceBeans) {<br>
Class<?> beanType = adviceBean.getBeanType();<br>
if (beanType == null) {<br>
throw new IllegalStateException(&ldquo;Unresolvable type for ControllerAdviceBean: &quot; + adviceBean);<br>
}<br>
ExceptionHandlerMethodResolver resolver = new ExceptionHandlerMethodResolver(beanType);<br>
if (resolver.hasExceptionMappings()) {<br>
this.exceptionHandlerAdviceCache.put(adviceBean, resolver);<br>
}<br>
//省略非关键代码<br>
}</p>
<p>到这，我们可以总结一下，WebMvcConfigurationSupport 中的 handlerExceptionResolver() 实例化并注册了一个 ExceptionHandlerExceptionResolver 的实例，而所有被 @ControllerAdvice 注解修饰的异常处理器，都会在 ExceptionHandlerExceptionResolver 实例化的时候自动扫描并装载在其类成员变量 exceptionHandlerAdviceCache 中。</p>
<p>当第一次请求发生时，DispatcherServlet 中的 initHandlerExceptionResolvers() 将获取所有注册到 Spring 的 HandlerExceptionResolver 类型的实例，而 ExceptionHandlerExceptionResolver 恰好实现了 HandlerExceptionResolver 接口，这些 HandlerExceptionResolver 类型的实例则会被写入到类成员变量 handlerExceptionResolvers 中。</p>
<p>private void initHandlerExceptionResolvers(ApplicationContext context) {<br>
this.handlerExceptionResolvers = null;</p>
<p>if (this.detectAllHandlerExceptionResolvers) {<br>
// Find all HandlerExceptionResolvers in the ApplicationContext, including ancestor contexts.<br>
Map&lt;String, HandlerExceptionResolver&gt; matchingBeans = BeanFactoryUtils<br>
.beansOfTypeIncludingAncestors(context, HandlerExceptionResolver.class, true, false);<br>
if (!matchingBeans.isEmpty()) {<br>
this.handlerExceptionResolvers = new ArrayList&lt;&gt;(matchingBeans.values());<br>
// We keep HandlerExceptionResolvers in sorted order.<br>
AnnotationAwareOrderComparator.sort(this.handlerExceptionResolvers);<br>
}<br>
//省略非关键代码<br>
}</p>
<p>**接着我们再来了解下 ControllerAdvice 是如何被 Spring 消费并处理异常的。**下文贴出的是核心类 DispatcherServlet 中的核心方法 doDispatch() 的部分代码：</p>
<p>protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {<br>
//省略非关键代码</p>
<p>try {<br>
ModelAndView mv = null;<br>
Exception dispatchException = null;<br>
try {<br>
//省略非关键代码<br>
//查找当前请求对应的 handler，并执行<br>
//省略非关键代码<br>
}<br>
catch (Exception ex) {<br>
dispatchException = ex;<br>
}<br>
catch (Throwable err) {<br>
dispatchException = new NestedServletException(&ldquo;Handler dispatch failed&rdquo;, err);<br>
}<br>
processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);<br>
}<br>
//省略非关键代码</p>
<p>Spring 在执行用户请求时，当在“查找”和“执行”请求对应的 handler 过程中发生异常，就会把异常赋值给 dispatchException，再交给 processDispatchResult() 进行处理。</p>
<p>private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,<br>
@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,<br>
@Nullable Exception exception) throws Exception {<br>
boolean errorView = false;<br>
if (exception != null) {<br>
if (exception instanceof ModelAndViewDefiningException) {<br>
mv = ((ModelAndViewDefiningException) exception).getModelAndView();<br>
}<br>
else {<br>
Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);<br>
mv = processHandlerException(request, response, handler, exception);<br>
errorView = (mv != null);<br>
}<br>
}<br>
//省略非关键代码</p>
<p>进一步处理后，即当 Exception 不为 null 时，继续交给 processHandlerException 处理。</p>
<p>protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,<br>
@Nullable Object handler, Exception ex) throws Exception {<br>
//省略非关键代码<br>
ModelAndView exMv = null;<br>
if (this.handlerExceptionResolvers != null) {<br>
for (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) {<br>
exMv = resolver.resolveException(request, response, handler, ex);<br>
if (exMv != null) {<br>
break;<br>
}<br>
}<br>
}<br>
//省略非关键代码<br>
}</p>
<p>然后，processHandlerException 会从类成员变量 handlerExceptionResolvers 中获取有效的异常解析器，对异常进行解析。</p>
<p>显然，这里的 handlerExceptionResolvers 一定包含我们声明的 NotAllowExceptionHandler#NotAllowException 的异常处理器的 ExceptionHandlerExceptionResolver 包装类。</p>
<h3 id="问题修正">问题修正</h3>
<p>为了利用 Spring MVC 的异常处理机制，我们需要对 Filter 做一些改造。手动捕获异常，并将异常 HandlerExceptionResolver 进行解析处理。</p>
<p>我们可以这样修改 PermissionFilter，注入 HandlerExceptionResolver：</p>
<p>@Autowired<br>
@Qualifier(&ldquo;handlerExceptionResolver&rdquo;)<br>
private HandlerExceptionResolver resolver;</p>
<p>然后，在 doFilter 里捕获异常并交给 HandlerExceptionResolver 处理：</p>
<pre><code>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {  
    HttpServletRequest httpServletRequest = (HttpServletRequest) request;  
    HttpServletResponse httpServletResponse = (HttpServletResponse) response;  
    String token = httpServletRequest.getHeader(&quot;token&quot;);  
    if (!&quot;111111&quot;.equals(token)) {  
        System.out.println(&quot;throw NotAllowException&quot;);  
        resolver.resolveException(httpServletRequest, httpServletResponse, null, new NotAllowException());  
        return;  
    }  
    chain.doFilter(request, response);  
}
</code></pre>
<p>当我们尝试用错误的 Token 请求，控制台得到了以下信息：</p>
<p>throw NotAllowException<br>
403</p>
<p>返回的 JSON 是：</p>
<p>{&ldquo;resultCode&rdquo;: 403}</p>
<p>再换成正确的 Token 请求，这些错误信息就都没有了，到这，问题解决了。</p>
<h2 id="案例-2特殊的-404-异常">案例 2：特殊的 404 异常</h2>
<p>继续沿用学生注册的案例，为了防止一些异常的访问，我们需要记录所有 404 状态的访问记录，并返回一个我们的自定义结果。</p>
<p>一般使用 RESTful 接口时我们会统一返回 JSON 数据，返回值格式如下：</p>
<p>{&ldquo;resultCode&rdquo;: 404}</p>
<p>但是 Spring 对 404 异常是进行了默认资源映射的，并不会返回我们想要的结果，也不会对这种错误做记录。</p>
<p>于是我们添加了一个 ExceptionHandlerController，它被声明成 @RestControllerAdvice 来全局捕获 Spring MVC 中抛出的异常。</p>
<p>ExceptionHandler 的作用正是用来捕获指定的异常：</p>
<p>@RestControllerAdvice<br>
public class MyExceptionHandler {<br>
@ResponseStatus(HttpStatus.NOT_FOUND)<br>
@ExceptionHandler(Exception.class)<br>
@ResponseBody<br>
public String handle404() {<br>
System.out.println(&ldquo;404&rdquo;);<br>
return &ldquo;{&quot;resultCode&quot;: 404}&rdquo;;<br>
}<br>
}</p>
<p>我们尝试发送一个错误的 URL 请求到之前实现过的 /regStudent 接口，并把请求地址换成 /regStudent1，得到了以下结果：</p>
<p>{&ldquo;timestamp&rdquo;:&ldquo;2021-05-19T22:24:01.559+0000&rdquo;,&ldquo;status&rdquo;:404,&ldquo;error&rdquo;:&ldquo;Not Found&rdquo;,&ldquo;message&rdquo;:&ldquo;No message available&rdquo;,&ldquo;path&rdquo;:&quot;/regStudent1&rdquo;}</p>
<p>很显然，这个结果不是我们想要的，看起来应该是 Spring 默认的返回结果。那是什么原因导致 Spring 没有使用我们定义的异常处理器呢？</p>
<h3 id="案例解析-1">案例解析</h3>
<p>我们可以从异常处理的核心处理代码开始分析，DispatcherServlet 中的 doDispatch() 核心代码如下：</p>
<p>protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {<br>
//省略非关键代码<br>
mappedHandler = getHandler(processedRequest);<br>
if (mappedHandler == null) {<br>
noHandlerFound(processedRequest, response);<br>
return;<br>
}<br>
//省略非关键代码<br>
}</p>
<p>首先调用 getHandler() 获取当前请求的处理器，如果获取不到，则调用 noHandlerFound()：</p>
<p>protected void noHandlerFound(HttpServletRequest request, HttpServletResponse response) throws Exception {<br>
if (this.throwExceptionIfNoHandlerFound) {<br>
throw new NoHandlerFoundException(request.getMethod(), getRequestUri(request),<br>
new ServletServerHttpRequest(request).getHeaders());<br>
}<br>
else {<br>
response.sendError(HttpServletResponse.SC_NOT_FOUND);<br>
}<br>
}</p>
<p>noHandlerFound() 的逻辑非常简单，如果 throwExceptionIfNoHandlerFound 属性为 true，则直接抛出 NoHandlerFoundException 异常，反之则会进一步获取到对应的请求处理器执行，并将执行结果返回给客户端。</p>
<p>到这，真相离我们非常近了，我们只需要将 throwExceptionIfNoHandlerFound 默认设置为 true 即可，这样就会抛出 NoHandlerFoundException 异常，从而被 doDispatch() 内的 catch 俘获。进而就像案例 1 介绍的一样，最终能够执行我们自定义的异常处理器 MyExceptionHandler。</p>
<p>于是，我们开始尝试，因为 throwExceptionIfNoHandlerFound 对应的 Spring 配置项为 throw-exception-if-no-handler-found，我们将其加入到 application.properties 配置文件中，设置其值为 true。</p>
<p>设置完毕后，重启服务并再次尝试，你会发现结果没有任何变化，这个问题也没有被解决。</p>
<p>实际上这里还存在另一个坑，在 Spring Web 的 WebMvcAutoConfiguration 类中，其默认添加的两个 ResourceHandler，一个是用来处理请求路径 /webjars/**，而另一个是 /**。</p>
<p>即便当前请求没有定义任何对应的请求处理器，getHandler() 也一定会获取到一个 Handler 来处理当前请求，因为第二个匹配 /** 路径的 ResourceHandler 决定了任何请求路径都会被其处理。mappedHandler == null 判断条件永远不会成立，显然就不可能走到 noHandlerFound()，那么就不会抛出 NoHandlerFoundException 异常，也无法被后续的异常处理器进一步处理。</p>
<p>下面让我们通过源码进一步了解下这个默认被添加的 ResourceHandler 的详细逻辑。</p>
<p><strong>首先我们来了解下 ControllerAdvice 是如何被 Spring 加载并对外暴露的。</strong></p>
<p>同样是在 WebMvcConfigurationSupport 类中，被 @Bean 修饰的 resourceHandlerMapping()，它新建了 ResourceHandlerRegistry 类实例，并通过 addResourceHandlers() 将 ResourceHandler 注册到 ResourceHandlerRegistry 类实例中：</p>
<p>@Bean<br>
@Nullable<br>
public HandlerMapping resourceHandlerMapping(<br>
@Qualifier(&ldquo;mvcUrlPathHelper&rdquo;) UrlPathHelper urlPathHelper,<br>
@Qualifier(&ldquo;mvcPathMatcher&rdquo;) PathMatcher pathMatcher,<br>
@Qualifier(&ldquo;mvcContentNegotiationManager&rdquo;) ContentNegotiationManager contentNegotiationManager,<br>
@Qualifier(&ldquo;mvcConversionService&rdquo;) FormattingConversionService conversionService,<br>
@Qualifier(&ldquo;mvcResourceUrlProvider&rdquo;) ResourceUrlProvider resourceUrlProvider) {</p>
<p>Assert.state(this.applicationContext != null, &ldquo;No ApplicationContext set&rdquo;);<br>
Assert.state(this.servletContext != null, &ldquo;No ServletContext set&rdquo;);</p>
<p>ResourceHandlerRegistry registry = new ResourceHandlerRegistry(this.applicationContext,<br>
this.servletContext, contentNegotiationManager, urlPathHelper);<br>
addResourceHandlers(registry);</p>
<p>AbstractHandlerMapping handlerMapping = registry.getHandlerMapping();<br>
if (handlerMapping == null) {<br>
return null;<br>
}<br>
handlerMapping.setPathMatcher(pathMatcher);<br>
handlerMapping.setUrlPathHelper(urlPathHelper);<br>
handlerMapping.setInterceptors(getInterceptors(conversionService, resourceUrlProvider));<br>
handlerMapping.setCorsConfigurations(getCorsConfigurations());<br>
return handlerMapping;<br>
}</p>
<p>最终通过 ResourceHandlerRegistry 类实例中的 getHandlerMapping() 返回了 SimpleUrlHandlerMapping 实例，它装载了所有 ResourceHandler 的集合并注册到了 Spring 容器中：</p>
<p>protected AbstractHandlerMapping getHandlerMapping() {<br>
//省略非关键代码<br>
Map&lt;String, HttpRequestHandler&gt; urlMap = new LinkedHashMap&lt;&gt;();<br>
for (ResourceHandlerRegistration registration : this.registrations) {<br>
for (String pathPattern : registration.getPathPatterns()) {<br>
ResourceHttpRequestHandler handler = registration.getRequestHandler();<br>
//省略非关键代码<br>
urlMap.put(pathPattern, handler);<br>
}<br>
}<br>
return new SimpleUrlHandlerMapping(urlMap, this.order);<br>
}</p>
<p>我们查看以下调用栈截图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/6811068a3b9992b83611d96bc09689ff.png" alt=""></p>
<p>可以了解到，当前方法中的 addResourceHandlers() 最终执行到了 WebMvcAutoConfiguration 类中的 addResourceHandlers()，通过这个方法，我们可以知道当前有哪些 ResourceHandler 的集合被注册到了 Spring 容器中：</p>
<p>public void addResourceHandlers(ResourceHandlerRegistry registry) {<br>
if (!this.resourceProperties.isAddMappings()) {<br>
logger.debug(&ldquo;Default resource handling disabled&rdquo;);<br>
return;<br>
}<br>
Duration cachePeriod = this.resourceProperties.getCache().getPeriod();<br>
CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();<br>
if (!registry.hasMappingForPattern(&quot;/webjars/<strong>&quot;)) {<br>
customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/</strong>&quot;)<br>
.addResourceLocations(&ldquo;classpath:/META-INF/resources/webjars/&rdquo;)<br>
.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));<br>
}<br>
String staticPathPattern = this.mvcProperties.getStaticPathPattern();<br>
if (!registry.hasMappingForPattern(staticPathPattern)) {<br>
customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)<br>
.addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))<br>
.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));<br>
}<br>
}</p>
<p>从而验证我们一开始得出的结论，此处添加了两个 ResourceHandler，一个是用来处理请求路径 /webjars/**，而另一个是 /**。</p>
<p>这里你可以注意一下方法最开始的判断语句，如果 this.resourceProperties.isAddMappings() 为 false，那么会直接返回，后续的两个 ResourceHandler 也不会被添加。</p>
<p>if (!this.resourceProperties.isAddMappings()) {<br>
logger.debug(&ldquo;Default resource handling disabled&rdquo;);<br>
return;<br>
}</p>
<p>​至此，有两个 ResourceHandler 被实例化且注册到了 Spirng 容器中，一个处理路径为 /webjars/** 的请求，另一个处理路径为 /** 的请求。</p>
<p>同样，当第一次请求发生时，DispatcherServlet 中的 initHandlerMappings() 将会获取所有注册到 Spring 的 HandlerMapping 类型的实例，而 SimpleUrlHandlerMapping 恰好实现了 HandlerMapping 接口，这些 SimpleUrlHandlerMapping 类型的实例则会被写入到类成员变量 handlerMappings 中。</p>
<p>private void initHandlerMappings(ApplicationContext context) {<br>
this.handlerMappings = null;<br>
//省略非关键代码<br>
if (this.detectAllHandlerMappings) {<br>
// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.<br>
Map&lt;String, HandlerMapping&gt; matchingBeans =<br>
BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);<br>
if (!matchingBeans.isEmpty()) {<br>
this.handlerMappings = new ArrayList&lt;&gt;(matchingBeans.values());<br>
// We keep HandlerMappings in sorted order.<br>
AnnotationAwareOrderComparator.sort(this.handlerMappings);<br>
}<br>
}<br>
//省略非关键代码<br>
}</p>
<p>接着我们再来了解下被包装为 handlerMappings 的 ResourceHandler 是如何被 Spring 消费并处理的。</p>
<p>我们来回顾一下 DispatcherServlet 中的 doDispatch() 核心代码：</p>
<p>protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {<br>
//省略非关键代码<br>
mappedHandler = getHandler(processedRequest);<br>
if (mappedHandler == null) {<br>
noHandlerFound(processedRequest, response);<br>
return;<br>
}<br>
//省略非关键代码<br>
}</p>
<p>这里的 getHandler() 将会遍历成员变量 handlerMappings：</p>
<p>protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {<br>
if (this.handlerMappings != null) {<br>
for (HandlerMapping mapping : this.handlerMappings) {<br>
HandlerExecutionChain handler = mapping.getHandler(request);<br>
if (handler != null) {<br>
return handler;<br>
}<br>
}<br>
}<br>
return null;<br>
}</p>
<p>因为此处有一个 SimpleUrlHandlerMapping，它会拦截所有路径的请求：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/964f860e9a0ac77c31c221de4c4d2285.png" alt=""></p>
<p>所以最终在 doDispatch() 的 getHandler() 将会获取到此 handler，从而 mappedHandler==null 条件不能得到满足，因而无法走到 noHandlerFound()，不会抛出 NoHandlerFoundException 异常，进而无法被后续的异常处理器进一步处理。</p>
<h3 id="问题修正-1">问题修正</h3>
<p>那如何解决这个问题呢？还记得 WebMvcAutoConfiguration 类中 addResourceHandlers() 的前两行代码吗？如果 this.resourceProperties.isAddMappings() 为 false，那么此处直接返回，后续的两个 ResourceHandler 也不会被添加。</p>
<p>public void addResourceHandlers(ResourceHandlerRegistry registry) {<br>
if (!this.resourceProperties.isAddMappings()) {<br>
logger.debug(&ldquo;Default resource handling disabled&rdquo;);<br>
return;<br>
}<br>
//省略非关键代码<br>
}</p>
<p>其调用 ResourceProperties 中的 isAddMappings() 的代码如下：</p>
<p>public boolean isAddMappings() {<br>
return this.addMappings;<br>
}</p>
<p>到这，答案也就呼之欲出了，增加两个配置文件如下：</p>
<p>spring.resources.add-mappings=false<br>
spring.mvc.throwExceptionIfNoHandlerFound=true</p>
<p>修改 MyExceptionHandler 的 @ExceptionHandler 为 NoHandlerFoundException 即可：</p>
<p>@ExceptionHandler(NoHandlerFoundException.class)</p>
<p>这个案例在真实的产线环境遇到的概率还是比较大的，知道如何解决是第一步，了解其内部原理则更为重要。而且当你进一步去研读代码后，你会发现这里的解决方案并不会只有这一种，而剩下的就留给你去探索了。</p>
<h2 id="重点回顾">重点回顾</h2>
<p>通过以上两个案例的介绍，相信你对 Spring MVC 的异常处理机制，已经有了进一步的了解，这里我们再次回顾下重点：</p>
<ol>
<li>DispatcherServlet 类中的 doDispatch() 是整个 Servlet 处理的核心，它不仅实现了请求的分发，也提供了异常统一处理等等一系列功能；</li>
<li>WebMvcConfigurationSupport 是 Spring Web 中非常核心的一个配置类，无论是异常处理器的包装注册（HandlerExceptionResolver），还是资源处理器的包装注册（SimpleUrlHandlerMapping），都是依靠这个类来完成的。</li>
</ol>
<h2 id="思考题">思考题</h2>
<p>这节课的两个案例，在第一次发送请求的时候，会遍历对应的资源处理器和异常处理器，并注册到 DispatcherServlet 对应的类成员变量中，你知道它是如何被触发的吗？</p>
<p>期待你的思考，我们留言区见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/">Spring编程常见错误50例</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0%E4%B8%9A%E5%8A%A1%E5%BB%BA%E6%A8%A1/168x_flow%E4%B8%8B%E5%A4%9A%E4%BA%8E%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">16｜8X_Flow（下）：多于一个例子</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%BA%E7%9A%84%E8%8B%B1%E8%AF%AD%E7%A7%81%E6%95%99%E8%AF%BE/16%E5%8A%A8%E8%AF%8D%E8%8B%B1%E8%AF%AD%E5%AE%87%E5%AE%99%E7%9A%84%E4%B8%AD%E5%BF%83/">
            <span class="next-text nav-default">16｜动词：英语宇宙的中心</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
