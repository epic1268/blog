<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>20__Spring_事务常见错误（下） - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是傅健。
通过上一节课的学习，我们了解了 Spring 事务的原理，并解决了几个常见的问题。这节课我们将继续讨论事务中的另外两个问题，一个是关于事务的传播机制，另一个是关于多数据源的切换问题，通过这两个问题，你可以更加深入地了解 Spring 事务的核心机制。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/20__spring_%E4%BA%8B%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%B8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/20__spring_%E4%BA%8B%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%B8%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="20__Spring_事务常见错误（下）">
  <meta property="og:description" content="你好，我是傅健。
通过上一节课的学习，我们了解了 Spring 事务的原理，并解决了几个常见的问题。这节课我们将继续讨论事务中的另外两个问题，一个是关于事务的传播机制，另一个是关于多数据源的切换问题，通过这两个问题，你可以更加深入地了解 Spring 事务的核心机制。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Spring编程常见错误50例">

  <meta itemprop="name" content="20__Spring_事务常见错误（下）">
  <meta itemprop="description" content="你好，我是傅健。
通过上一节课的学习，我们了解了 Spring 事务的原理，并解决了几个常见的问题。这节课我们将继续讨论事务中的另外两个问题，一个是关于事务的传播机制，另一个是关于多数据源的切换问题，通过这两个问题，你可以更加深入地了解 Spring 事务的核心机制。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6553">
  <meta itemprop="keywords" content="Spring编程常见错误50例">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="20__Spring_事务常见错误（下）">
  <meta name="twitter:description" content="你好，我是傅健。
通过上一节课的学习，我们了解了 Spring 事务的原理，并解决了几个常见的问题。这节课我们将继续讨论事务中的另外两个问题，一个是关于事务的传播机制，另一个是关于多数据源的切换问题，通过这两个问题，你可以更加深入地了解 Spring 事务的核心机制。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">20__Spring_事务常见错误（下）</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6553 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#案例-1嵌套事务回滚错误">案例 1：嵌套事务回滚错误</a>
          <ul>
            <li><a href="#案例解析">案例解析</a></li>
            <li><a href="#问题修正">问题修正</a></li>
          </ul>
        </li>
        <li><a href="#案例-2多数据源间切换之谜">案例 2：多数据源间切换之谜</a>
          <ul>
            <li><a href="#案例解析-1">案例解析</a></li>
            <li><a href="#问题修正-1">问题修正</a></li>
          </ul>
        </li>
        <li><a href="#重点回顾">重点回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是傅健。</p>
<p>通过上一节课的学习，我们了解了 Spring 事务的原理，并解决了几个常见的问题。这节课我们将继续讨论事务中的另外两个问题，一个是关于事务的传播机制，另一个是关于多数据源的切换问题，通过这两个问题，你可以更加深入地了解 Spring 事务的核心机制。</p>
<h2 id="案例-1嵌套事务回滚错误">案例 1：嵌套事务回滚错误</h2>
<p>上一节课我们完成了学生注册功能，假设我们需要对这个功能继续进行扩展，当学生注册完成后，需要给这个学生登记一门英语必修课，并更新这门课的登记学生数。为此，我添加了两个表。</p>
<ol>
<li>课程表 course，记录课程名称和注册的学生数。</li>
</ol>
<p>CREATE TABLE <code>course</code> (<br>
<code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>
<code>course_name</code> varchar(64) DEFAULT NULL,<br>
<code>number</code> int(11) DEFAULT NULL,<br>
PRIMARY KEY (<code>id</code>)<br>
) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p>
<ol>
<li>学生选课表 student_course，记录学生表 student 和课程表 course 之间的多对多关联。</li>
</ol>
<p>CREATE TABLE <code>student_course</code> (<br>
<code>student_id</code> int(11) NOT NULL,<br>
<code>course_id</code> int(11) NOT NULL<br>
) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p>
<p>同时我为课程表初始化了一条课程信息，id = 1，course_name = &ldquo;英语&rdquo;，number = 0。</p>
<p>接下来我们完成用户的相关操作，主要包括两部分。</p>
<ol>
<li>新增学生选课记录</li>
</ol>
<p>@Mapper<br>
public interface StudentCourseMapper {<br>
@Insert(&ldquo;INSERT INTO <code>student_course</code>(<code>student_id</code>, <code>course_id</code>) VALUES (#{studentId}, #{courseId})&rdquo;)<br>
void saveStudentCourse(@Param(&ldquo;studentId&rdquo;) Integer studentId, @Param(&ldquo;courseId&rdquo;) Integer courseId);<br>
}</p>
<ol>
<li>课程登记学生数 + 1</li>
</ol>
<p>@Mapper<br>
public interface CourseMapper {<br>
@Update(&ldquo;update <code>course</code> set number = number + 1 where id = #{id}&rdquo;)<br>
void addCourseNumber(int courseId);<br>
}</p>
<p>我们增加了一个新的业务类 CourseService，用于实现相关业务逻辑。分别调用了上述两个方法来保存学生与课程的关联关系，并给课程注册人数 +1。最后，别忘了给这个方法加上事务注解。</p>
<p>@Service<br>
public class CourseService {<br>
@Autowired<br>
private CourseMapper courseMapper;</p>
<pre><code>@Autowired  
private StudentCourseMapper studentCourseMapper;  

//注意这个方法标记了“Transactional”  
@Transactional(rollbackFor = Exception.class)  
public void regCourse(int studentId) throws Exception {  
    studentCourseMapper.saveStudentCourse(studentId, 1);  
    courseMapper.addCourseNumber(1);  
}  
</code></pre>
<p>}</p>
<p>我们在之前的 StudentService.saveStudent() 中调用了 regCourse()，实现了完整的业务逻辑。为了避免注册课程的业务异常导致学生信息无法保存，在这里 catch 了注册课程方法中抛出的异常。我们希望的结果是，当注册课程发生错误时，只回滚注册课程部分，保证学生信息依然正常。</p>
<p>@Service<br>
public class StudentService {<br>
//省略非关键代码<br>
@Transactional(rollbackFor = Exception.class)<br>
public void saveStudent(String realname) throws Exception {<br>
Student student = new Student();<br>
student.setRealname(realname);<br>
studentService.doSaveStudent(student);<br>
try {<br>
courseService.regCourse(student.getId());<br>
} catch (Exception e) {<br>
e.printStackTrace();<br>
}<br>
}<br>
//省略非关键代码<br>
}</p>
<p>为了验证异常是否符合预期，我们在 regCourse() 里抛出了一个注册失败的异常：</p>
<p>@Transactional(rollbackFor = Exception.class)<br>
public void regCourse(int studentId) throws Exception {<br>
studentCourseMapper.saveStudentCourse(studentId, 1);<br>
courseMapper.addCourseNumber(1);<br>
throw new Exception(&ldquo;注册失败&rdquo;);<br>
}</p>
<p>运行一下这段代码，在控制台里我们看到了以下提示信息：</p>
<p>java.lang.Exception: 注册失败<br>
at com.spring.puzzle.others.transaction.example3.CourseService.regCourse(CourseService.java:22)<br>
//&hellip;&hellip;省略非关键代码&hellip;..<br>
Exception in thread &ldquo;main&rdquo; org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only<br>
at org.springframework.transaction.support.AbstractPlatformTransactionManager.processRollback(AbstractPlatformTransactionManager.java:873)<br>
at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:710)<br>
at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:533)<br>
at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:304)<br>
at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98)<br>
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)<br>
at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688)<br>
at com.spring.puzzle.others.transaction.example3.StudentService$$EnhancerBySpringCGLIB$$50cda404.saveStudent(<generated>)<br>
at com.spring.puzzle.others.transaction.example3.AppConfig.main(AppConfig.java:22)</p>
<p>其中，注册失败部分的异常符合预期，但是后面又多了一个这样的错误提示：Transaction rolled back because it has been marked as rollback-only。</p>
<p>最后的结果是，学生和选课的信息都被回滚了，显然这并不符合我们的预期。我们期待的结果是即便内部事务 regCourse() 发生异常，外部事务 saveStudent() 俘获该异常后，内部事务应自行回滚，不影响外部事务。那么这是什么原因造成的呢？我们需要研究一下 Spring 的源码，来找找答案。</p>
<h3 id="案例解析">案例解析</h3>
<p>在做进一步的解析之前，我们可以先通过伪代码把整个事务的结构梳理一下：</p>
<p>// 外层事务<br>
@Transactional(rollbackFor = Exception.class)<br>
public void saveStudent(String realname) throws Exception {<br>
//&hellip;&hellip;省略逻辑代码&hellip;..<br>
studentService.doSaveStudent(student);<br>
try {<br>
// 嵌套的内层事务<br>
@Transactional(rollbackFor = Exception.class)<br>
public void regCourse(int studentId) throws Exception {<br>
//&hellip;&hellip;省略逻辑代码&hellip;..<br>
}<br>
} catch (Exception e) {<br>
e.printStackTrace();<br>
}<br>
}</p>
<p>可以看出来，整个业务是包含了 2 层事务，外层的 saveStudent() 的事务和内层的 regCourse() 事务。</p>
<p>在 Spring 声明式的事务处理中，有一个属性 propagation，表示打算对这些方法怎么使用事务，即一个带事务的方法调用了另一个带事务的方法，被调用的方法它怎么处理自己事务和调用方法事务之间的关系。</p>
<p>其中 propagation 有 7 种配置：REQUIRED、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED。默认是 REQUIRED，它的含义是：如果本来有事务，则加入该事务，如果没有事务，则创建新的事务。</p>
<p>结合我们的伪代码示例，因为在 saveStudent() 上声明了一个外部的事务，就已经存在一个事务了，在 propagation 值为默认的 REQUIRED 的情况下，regCourse() 就会加入到已有的事务中，两个方法共用一个事务。</p>
<p>我们再来看下 Spring 事务处理的核心，其关键实现参考 TransactionAspectSupport.invokeWithinTransaction()：</p>
<p>protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,<br>
final InvocationCallback invocation) throws Throwable {</p>
<p>TransactionAttributeSource tas = getTransactionAttributeSource();<br>
final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);<br>
final PlatformTransactionManager tm = determineTransactionManager(txAttr);<br>
final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);<br>
if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {<br>
// 是否需要创建一个事务<br>
TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);<br>
Object retVal = null;<br>
try {<br>
// 调用具体的业务方法<br>
retVal = invocation.proceedWithInvocation();<br>
}<br>
catch (Throwable ex) {<br>
// 当发生异常时进行处理<br>
completeTransactionAfterThrowing(txInfo, ex);<br>
throw ex;<br>
}<br>
finally {<br>
cleanupTransactionInfo(txInfo);<br>
}<br>
// 正常返回时提交事务<br>
commitTransactionAfterReturning(txInfo);<br>
return retVal;<br>
}<br>
//&hellip;&hellip;省略非关键代码&hellip;..<br>
}</p>
<p>整个方法完成了事务的一整套处理逻辑，如下：</p>
<ol>
<li>检查是否需要创建事务；</li>
<li>调用具体的业务方法进行处理；</li>
<li>提交事务；</li>
<li>处理异常。</li>
</ol>
<p>这里要格外注意的是，当前案例是两个事务嵌套的场景，外层事务 doSaveStudent() 和内层事务 regCourse()，每个事务都会调用到这个方法。所以，这个方法会被调用两次。下面我们来具体来看下内层事务对异常的处理。</p>
<p>当捕获了异常，会调用 TransactionAspectSupport.completeTransactionAfterThrowing() 进行异常处理：</p>
<p>protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) {<br>
if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) {<br>
if (txInfo.transactionAttribute != null &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) {<br>
try {<br>
txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());<br>
}<br>
catch (TransactionSystemException ex2) {<br>
logger.error(&ldquo;Application exception overridden by rollback exception&rdquo;, ex);<br>
ex2.initApplicationException(ex);<br>
throw ex2;<br>
}<br>
catch (RuntimeException | Error ex2) {<br>
logger.error(&ldquo;Application exception overridden by rollback exception&rdquo;, ex);<br>
throw ex2;<br>
}<br>
}<br>
//&hellip;&hellip;省略非关键代码&hellip;..<br>
}<br>
}</p>
<p>在这个方法里，我们对异常类型做了一些检查，当符合声明中的定义后，执行了具体的 rollback 操作，这个操作是通过 TransactionManager.rollback() 完成的：</p>
<p>public final void rollback(TransactionStatus status) throws TransactionException {<br>
if (status.isCompleted()) {<br>
throw new IllegalTransactionStateException(<br>
&ldquo;Transaction is already completed - do not call commit or rollback more than once per transaction&rdquo;);<br>
}</p>
<p>DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;<br>
processRollback(defStatus, false);<br>
}</p>
<p>而 rollback() 是在 AbstractPlatformTransactionManager 中实现的，继续调用了 processRollback()：</p>
<p>private void processRollback(DefaultTransactionStatus status, boolean unexpected) {<br>
try {<br>
boolean unexpectedRollback = unexpected;</p>
<pre><code>  if (status.hasSavepoint()) {  
     // 有保存点  
     status.rollbackToHeldSavepoint();  
  }  
  else if (status.isNewTransaction()) {  
     // 是否为一个新的事务  
     doRollback(status);  
  }  
  else {  
    // 处于一个更大的事务中  
    if (status.hasTransaction()) {  
       // 分支 1  
       if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {  
          doSetRollbackOnly(status);  
       }  
    }  
    if (!isFailEarlyOnGlobalRollbackOnly()) {  
       unexpectedRollback = false;  
    }  
  }  

  // 省略非关键代码   
  if (unexpectedRollback) {  
     throw new UnexpectedRollbackException(  
           &quot;Transaction rolled back because it has been marked as rollback-only&quot;);  
  }  
</code></pre>
<p>}<br>
finally {<br>
cleanupAfterCompletion(status);<br>
}<br>
}</p>
<p>这个方法里区分了三种不同类型的情况：</p>
<ol>
<li>是否有保存点；</li>
<li>是否为一个新的事务；</li>
<li>是否处于一个更大的事务中。</li>
</ol>
<p>在这里，因为我们用的是默认的传播类型 REQUIRED，嵌套的事务并没有开启一个新的事务，所以在这种情况下，当前事务是处于一个更大的事务中，所以会走到情况 3 分支 1 的代码块下。</p>
<p>这里有两个判断条件来确定是否设置为仅回滚：</p>
<p>if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure())</p>
<p>满足任何一个，都会执行 doSetRollbackOnly() 操作。isLocalRollbackOnly 在当前的情况下是 false，所以是否分设置为仅回滚就由 isGlobalRollbackOnParticipationFailure() 这个方法来决定了，其默认值为 true，即是否回滚交由外层事务统一决定。</p>
<p>显然这里的条件得到了满足，从而执行 doSetRollbackOnly：</p>
<p>protected void doSetRollbackOnly(DefaultTransactionStatus status) {<br>
DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();<br>
txObject.setRollbackOnly();<br>
}</p>
<p>以及最终调用到的 <strong>DataSourceTransactionObject 中的 setRollbackOnly()：</strong></p>
<p>public void setRollbackOnly() {<br>
getConnectionHolder().setRollbackOnly();<br>
}</p>
<p>到这一步，内层事务的操作基本执行完毕，它处理了异常，并最终调用到了 <strong>DataSourceTransactionObject 中的 setRollbackOnly()</strong>。</p>
<p>接下来，我们来看外层事务。因为在外层事务中，我们自己的代码捕获了内层抛出来的异常，所以这个异常不会继续往上抛，最后的事务会在 TransactionAspectSupport.invokeWithinTransaction() 中的 commitTransactionAfterReturning() 中进行处理：</p>
<p>protected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) {<br>
if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) {     txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());<br>
}<br>
}</p>
<p>在这个方法里我们执行了 commit 操作，代码如下：</p>
<p>public final void commit(TransactionStatus status) throws TransactionException {<br>
//&hellip;&hellip;省略非关键代码&hellip;..<br>
if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) {<br>
processRollback(defStatus, true);<br>
return;<br>
}</p>
<p>processCommit(defStatus);<br>
}</p>
<p>在 AbstractPlatformTransactionManager.commit() 中，当满足了 shouldCommitOnGlobalRollbackOnly() 和 defStatus.isGlobalRollbackOnly()，就会回滚，否则会继续提交事务。其中 shouldCommitOnGlobalRollbackOnly() 的作用为，如果发现了事务被标记了全局回滚，并且在发生了全局回滚的情况下，判断是否应该提交事务，这个方法的默认实现是返回了 false，这里我们不需要关注它，继续查看 isGlobalRollbackOnly() 的实现：</p>
<p>public boolean isGlobalRollbackOnly() {<br>
return ((this.transaction instanceof SmartTransactionObject) &amp;&amp;<br>
((SmartTransactionObject) this.transaction).isRollbackOnly());<br>
}</p>
<p>这个方法最终进入了 <strong>DataSourceTransactionObject 类中的 isRollbackOnly()：</strong></p>
<p>public boolean isRollbackOnly() {<br>
return getConnectionHolder().isRollbackOnly();<br>
}</p>
<p>现在让我们再次回顾一下之前的内部事务处理结果，其最终调用到的是 <strong>DataSourceTransactionObject 中的 setRollbackOnly()：</strong></p>
<p>public void setRollbackOnly() {<br>
getConnectionHolder().setRollbackOnly();<br>
}</p>
<p>isRollbackOnly() 和 setRollbackOnly() 这两个方法的执行本质都是对 ConnectionHolder 中 rollbackOnly 属性标志位的存取，而 ConnectionHolder 则存在于 DefaultTransactionStatus 类实例的 transaction 属性之中。</p>
<p>至此，答案基本浮出水面了，我们把整个逻辑串在一起就是：外层事务是否回滚的关键，最终取决于 <strong>DataSourceTransactionObject 类中的 isRollbackOnly()，而该方法的返回值，正是我们在内层异常的时候设置的</strong>。</p>
<p>所以最终外层事务也被回滚了，从而在控制台中打印出异常信息：&ldquo;Transaction rolled back because it has been marked as rollback-only&rdquo;。</p>
<p>所以到这里，问题也就清楚了，Spring 默认的事务传播属性为 REQUIRED，如我们之前介绍的，它的含义是：如果本来有事务，则加入该事务，如果没有事务，则创建新的事务，因而内外两层事务都处于同一个事务中。所以，当我们在 regCourse() 中抛出异常，并触发了回滚操作时，这个回滚会进一步传播，从而把 saveStudent() 也回滚了。最终导致整个事务都被回滚了。</p>
<h3 id="问题修正">问题修正</h3>
<p>从上述案例解析中，我们了解到，Spring 在处理事务过程中，有个默认的传播属性 REQUIRED，在整个事务的调用链上，任何一个环节抛出的异常都会导致全局回滚。</p>
<p>知道了这个结论，修改方法也就很简单了，我们只需要对传播属性进行修改，把类型改成 REQUIRES_NEW 就可以了。于是这部分代码就修改成这样：</p>
<p>@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)<br>
public void regCourse(int studentId) throws Exception {<br>
studentCourseMapper.saveStudentCourse(studentId, 1);<br>
courseMapper.addCourseNumber(1);<br>
throw new Exception(&ldquo;注册失败&rdquo;);<br>
}</p>
<p>运行一下看看：</p>
<p>java.lang.Exception: 注册失败<br>
at com.spring.puzzle.others.transaction.example3.CourseService.regCourse(CourseService.java:22)</p>
<p>异常正常抛出，注册课程部分的数据没有保存，但是学生还是正常注册成功。这意味着此时 Spring 只对注册课程这部分的数据进行了回滚，并没有传播到上一级。</p>
<p>这里我简单解释下这个过程：</p>
<ol>
<li>当子事务声明为 Propagation.REQUIRES_NEW 时，在 TransactionAspectSupport.invokeWithinTransaction() 中调用 createTransactionIfNecessary() 就会创建一个新的事务，独立于外层事务。</li>
<li>而在 AbstractPlatformTransactionManager.processRollback() 进行 rollback 处理时，因为 status.isNewTransaction() 会因为它处于一个新的事务中而返回 true，所以它走入到了另一个分支，执行了 doRollback() 操作，让这个子事务单独回滚，不会影响到主事务。</li>
</ol>
<p>至此，这个问题得到了很好的解决。</p>
<h2 id="案例-2多数据源间切换之谜">案例 2：多数据源间切换之谜</h2>
<p>在前面的案例中，我们完成了学生注册功能和课程注册功能。假设新需求又来了，每个学生注册的时候，需要给他们发一张校园卡，并给校园卡里充入 50 元钱。但是这个校园卡管理系统是一个第三方系统，使用的是另一套数据库，这样我们就需要在一个事务中同时操作两个数据库。</p>
<p>第三方的 Card 表如下：</p>
<p>CREATE TABLE <code>card</code> (<br>
<code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>
<code>student_id</code> int(11) DEFAULT NULL,<br>
<code>balance</code> int(11) DEFAULT NULL,<br>
PRIMARY KEY (<code>id</code>)<br>
) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p>
<p>对应的 Card 对象如下：</p>
<p>public class Card {<br>
private Integer id;<br>
private Integer studentId;<br>
private Integer balance;<br>
//省略 Get/Set 方法<br>
}</p>
<p>对应的 Mapper 接口如下，里面包含了一个 saveCard 的 insert 语句，用于创建一条校园卡记录：</p>
<p>@Mapper<br>
public interface CardMapper {<br>
@Insert(&ldquo;INSERT INTO <code>card</code>(<code>student_id</code>, <code>balance</code>) VALUES (#{studentId}, #{balance})&rdquo;)<br>
@Options(useGeneratedKeys = true, keyProperty = &ldquo;id&rdquo;)<br>
int saveCard(Card card);<br>
}</p>
<p>Card 的业务类如下，里面实现了卡与学生 ID 关联，以及充入 50 元的操作：</p>
<p>@Service<br>
public class CardService {<br>
@Autowired<br>
private CardMapper cardMapper;</p>
<pre><code>@Transactional  
public void createCard(int studentId) throws Exception {  
    Card card = new Card();  
    card.setStudentId(studentId);  
    card.setBalance(50);  
    cardMapper.saveCard(card);  
}  
</code></pre>
<p>}</p>
<h3 id="案例解析-1">案例解析</h3>
<p>这是一个相对常见的需求，学生注册和发卡都要在一个事务里完成，但是我们都默认只会连一个数据源，之前我们一直连的都是学生信息这个数据源，在这里，我们还需要对校园卡的数据源进行操作。于是，我们需要在一个事务里完成对两个数据源的操作，该如何实现这样的功能呢？</p>
<p>我们继续从 Spring 的源码中寻找答案。在 Spring 里有这样一个抽象类 AbstractRoutingDataSource，这个类相当于 DataSource 的路由中介，在运行时根据某种 key 值来动态切换到所需的 DataSource 上。通过实现这个类就可以实现我们期望的动态数据源切换。</p>
<p>这里强调一下，这个类里有这么几个关键属性：</p>
<ol>
<li>targetDataSources 保存了 key 和数据库连接的映射关系；</li>
<li>defaultTargetDataSource 标识默认的连接；</li>
<li>resolvedDataSources 存储数据库标识和数据源的映射关系。</li>
</ol>
<p>public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean {</p>
<p>@Nullable<br>
private Map&lt;Object, Object&gt; targetDataSources;</p>
<p>@Nullable<br>
private Object defaultTargetDataSource;</p>
<p>private boolean lenientFallback = true;</p>
<p>private DataSourceLookup dataSourceLookup = new JndiDataSourceLookup();</p>
<p>@Nullable<br>
private Map&lt;Object, DataSource&gt; resolvedDataSources;</p>
<p>@Nullable<br>
private DataSource resolvedDefaultDataSource;</p>
<p>//省略非关键代码<br>
}</p>
<p>AbstractRoutingDataSource 实现了 InitializingBean 接口，并覆写了 afterPropertiesSet()。该方法会在初始化 Bean 的时候执行，将多个 DataSource 初始化到 resolvedDataSources。这里的 targetDataSources 属性存储了将要切换的多数据源 Bean 信息。</p>
<p>@Override<br>
public void afterPropertiesSet() {<br>
if (this.targetDataSources == null) {<br>
throw new IllegalArgumentException(&ldquo;Property &rsquo;targetDataSources&rsquo; is required&rdquo;);<br>
}<br>
this.resolvedDataSources = new HashMap&lt;&gt;(this.targetDataSources.size());<br>
this.targetDataSources.forEach((key, value) -&gt; {<br>
Object lookupKey = resolveSpecifiedLookupKey(key);<br>
DataSource dataSource = resolveSpecifiedDataSource(value);<br>
this.resolvedDataSources.put(lookupKey, dataSource);<br>
});<br>
if (this.defaultTargetDataSource != null) {<br>
this.resolvedDefaultDataSource = resolveSpecifiedDataSource(this.defaultTargetDataSource);<br>
}<br>
}</p>
<p>获取数据库连接的是 getConnection()，它调用了 determineTargetDataSource() 来创建连接：</p>
<p>@Override<br>
public Connection getConnection() throws SQLException {<br>
return determineTargetDataSource().getConnection();<br>
}</p>
<p>@Override<br>
public Connection getConnection(String username, String password) throws SQLException {<br>
return determineTargetDataSource().getConnection(username, password);<br>
}</p>
<p>determineTargetDataSource() 是整个部分的核心，它的作用就是动态切换数据源。有多少个数据源，就存多少个数据源在 targetDataSources 中。</p>
<p>targetDataSources 是一个 Map 类型的属性，key 表示每个数据源的名字，value 对应的是每个数据源 DataSource。</p>
<p>protected DataSource determineTargetDataSource() {<br>
Assert.notNull(this.resolvedDataSources, &ldquo;DataSource router not initialized&rdquo;);<br>
Object lookupKey = determineCurrentLookupKey();<br>
DataSource dataSource = this.resolvedDataSources.get(lookupKey);<br>
if (dataSource == null &amp;&amp; (this.lenientFallback || lookupKey == null)) {<br>
dataSource = this.resolvedDefaultDataSource;<br>
}<br>
if (dataSource == null) {<br>
throw new IllegalStateException(&ldquo;Cannot determine target DataSource for lookup key [&rdquo; + lookupKey + &ldquo;]&rdquo;);<br>
}<br>
return dataSource;<br>
}</p>
<p>而选择哪个数据源又是由 determineCurrentLookupKey() 来决定的，此方法是抽象方法，需要我们继承 AbstractRoutingDataSource 抽象类来重写此方法。该方法返回一个 key，该 key 是 Bean 中的 beanName，并赋值给 lookupKey，由此 key 可以通过 resolvedDataSources 属性的键来获取对应的 DataSource 值，从而达到数据源切换的效果。</p>
<p>protected abstract Object determineCurrentLookupKey();</p>
<p>这样看来，这个方法的实现就得由我们完成了。接下来我们将会完成一系列相关的代码，解决这个问题。</p>
<h3 id="问题修正-1">问题修正</h3>
<p>首先，我们创建一个 MyDataSource 类，继承了 AbstractRoutingDataSource，并覆写了 determineCurrentLookupKey()：</p>
<p>public class MyDataSource extends AbstractRoutingDataSource {<br>
private static final ThreadLocal<String> key = new ThreadLocal<String>();</p>
<pre><code>@Override  
protected Object determineCurrentLookupKey() {  
    return key.get();  
}  

public static void setDataSource(String dataSource) {  
    key.set(dataSource);  
}  

public static String getDatasource() {  
    return key.get();  
}  

public static void clearDataSource() {  
    key.remove();  
}  
</code></pre>
<p>}</p>
<p>其次，我们需要修改 JdbcConfig。这里我新写了一个 dataSource，将原来的 dataSource 改成 dataSourceCore，再将新定义的 dataSourceCore 和 dataSourceCard 放进一个 Map，对应的 key 分别是 core 和 card，并把 Map 赋值给 setTargetDataSources</p>
<p>public class JdbcConfig {<br>
//省略非关键代码<br>
@Value(&quot;${card.driver}&quot;)<br>
private String cardDriver;</p>
<pre><code>@Value(&quot;${card.url}&quot;)  
private String cardUrl;  

@Value(&quot;${card.username}&quot;)  
private String cardUsername;  

@Value(&quot;${card.password}&quot;)  
private String cardPassword;  

@Autowired  
@Qualifier(&quot;dataSourceCard&quot;)  
private DataSource dataSourceCard;  

@Autowired  
@Qualifier(&quot;dataSourceCore&quot;)  
private DataSource dataSourceCore;  

//省略非关键代码  

@Bean(name = &quot;dataSourceCore&quot;)  
public DataSource createCoreDataSource() {  
    DriverManagerDataSource ds = new DriverManagerDataSource();  
    ds.setDriverClassName(driver);  
    ds.setUrl(url);  
    ds.setUsername(username);  
    ds.setPassword(password);  
    return ds;  
}  

@Bean(name = &quot;dataSourceCard&quot;)  
public DataSource createCardDataSource() {  
    DriverManagerDataSource ds = new DriverManagerDataSource();  
    ds.setDriverClassName(cardDriver);  
    ds.setUrl(cardUrl);  
    ds.setUsername(cardUsername);  
    ds.setPassword(cardPassword);  
    return ds;  
}  

@Bean(name = &quot;dataSource&quot;)  
public MyDataSource createDataSource() {  
    MyDataSource myDataSource = new MyDataSource();  
    Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;();  
    map.put(&quot;core&quot;, dataSourceCore);  
    map.put(&quot;card&quot;, dataSourceCard);  
    myDataSource.setTargetDataSources(map);  
    myDataSource.setDefaultTargetDataSource(dataSourceCore);  
    return myDataSource;  
}  

//省略非关键代码  
</code></pre>
<p>}</p>
<p>最后还剩下一个问题，setDataSource 这个方法什么时候执行呢？</p>
<p>我们可以用 Spring AOP 来设置，把配置的数据源类型都设置成注解标签，Service 层中在切换数据源的方法上加上注解标签，就会调用相应的方法切换数据源。</p>
<p>我们定义了一个新的注解 @DataSource，可以直接加在 Service() 上，实现数据库切换：</p>
<p>@Documented<br>
@Target({ElementType.TYPE, ElementType.METHOD})<br>
@Retention(RetentionPolicy.RUNTIME)<br>
public @interface DataSource {<br>
String value();</p>
<pre><code>String core = &quot;core&quot;;  

String card = &quot;card&quot;;  
</code></pre>
<p>}</p>
<p>声明方法如下：</p>
<p>@DataSource(DataSource.card)</p>
<p>另外，我们还需要写一个 Spring AOP 来对相应的服务方法进行拦截，完成数据源的切换操作。特别要注意的是，这里要加上一个 @Order(1) 标记它的初始化顺序。这个 Order 值一定要比事务的 AOP 切面的值小，这样可以获得更高的优先级，否则自动切换数据源将会失效。</p>
<p>@Aspect<br>
@Service<br>
@Order(1)<br>
public class DataSourceSwitch {<br>
@Around(&ldquo;execution(* com.spring.puzzle.others.transaction.example3.CardService.*(..))&rdquo;)<br>
public void around(ProceedingJoinPoint point) throws Throwable {<br>
Signature signature = point.getSignature();<br>
MethodSignature methodSignature = (MethodSignature) signature;<br>
Method method = methodSignature.getMethod();<br>
if (method.isAnnotationPresent(DataSource.class)) {<br>
DataSource dataSource = method.getAnnotation(DataSource.class);<br>
MyDataSource.setDataSource(dataSource.value());<br>
System.out.println(&ldquo;数据源切换至：&rdquo; + MyDataSource.getDatasource());<br>
}<br>
point.proceed();<br>
MyDataSource.clearDataSource();<br>
System.out.println(&ldquo;数据源已移除！&rdquo;);<br>
}<br>
}</p>
<p>最后，我们实现了 Card 的发卡逻辑，在方法前声明了切换数据库：</p>
<p>@Service<br>
public class CardService {<br>
@Autowired<br>
private CardMapper cardMapper;</p>
<pre><code>@Transactional(propagation = Propagation.REQUIRES_NEW)  
@DataSource(DataSource.card)  
public void createCard(int studentId) throws Exception {  
    Card card = new Card();  
    card.setStudentId(studentId);  
    card.setBalance(50);  
    cardMapper.saveCard(card);  
}  
</code></pre>
<p>}</p>
<p>并在 saveStudent() 里调用了发卡逻辑：</p>
<p>@Transactional(rollbackFor = Exception.class)<br>
public void saveStudent(String realname) throws Exception {<br>
Student student = new Student();<br>
student.setRealname(realname);<br>
studentService.doSaveStudent(student);<br>
try {<br>
courseService.regCourse(student.getId());<br>
cardService.createCard(student.getId());<br>
} catch (Exception e) {<br>
e.printStackTrace();<br>
}<br>
}</p>
<p>执行一下，一切正常，两个库的数据都可以正常保存了。</p>
<p>最后我们来看一下整个过程的调用栈，重新过一遍流程（这里我略去了不重要的部分）。</p>
<p>在创建了事务以后，会通过 DataSourceTransactionManager.doBegin() 获取相应的数据库连接：</p>
<p>protected void doBegin(Object transaction, TransactionDefinition definition) {<br>
DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;<br>
Connection con = null;</p>
<p>try {<br>
if (!txObject.hasConnectionHolder() ||<br>
txObject.getConnectionHolder().isSynchronizedWithTransaction()) {<br>
Connection newCon = obtainDataSource().getConnection();<br>
txObject.setConnectionHolder(new ConnectionHolder(newCon), true);<br>
}</p>
<pre><code>  //省略非关键代码  
</code></pre>
<p>}</p>
<p>这里的 obtainDataSource().getConnection() 调用到了 AbstractRoutingDataSource.getConnection()，这就与我们实现的功能顺利会师了。</p>
<p>public Connection getConnection() throws SQLException {<br>
return determineTargetDataSource().getConnection();<br>
}</p>
<h2 id="重点回顾">重点回顾</h2>
<p>通过以上两个案例，相信你对 Spring 的事务机制已经有了深刻的认识，最后总结下重点：</p>
<ol>
<li>Spring 在事务处理中有一个很重要的属性 Propagation，主要用来配置当前需要执行的方法如何使用事务，以及与其它事务之间的关系。</li>
<li>Spring 默认的传播属性是 REQUIRED，在有事务状态下执行，如果当前没有事务，则创建新的事务；</li>
<li>Spring 事务是可以对多个数据源生效，它提供了一个抽象类 AbstractRoutingDataSource，通过实现这个抽象类，我们可以实现自定义的数据库切换。</li>
</ol>
<h2 id="思考题">思考题</h2>
<p>结合案例 2，请你思考这样一个问题：在这个案例中，我们在 CardService 类方法上声明了这样的事务传播属性，@Transactional(propagation = Propagation.REQUIRES_NEW)，如果使用 Spring 的默认声明行不行，为什么？</p>
<p>期待你的思考，我们留言区见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/">Spring编程常见错误50例</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%AB%98%E6%89%8B%E8%AF%BE/20__rocketmq_producer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">20__RocketMQ_Producer源码分析：消息生产的实现过程</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/20__spring%E6%A1%86%E6%9E%B6%E6%A1%86%E6%9E%B6%E5%B8%AE%E6%88%91%E4%BB%AC%E5%81%9A%E4%BA%86%E5%BE%88%E5%A4%9A%E5%B7%A5%E4%BD%9C%E4%B9%9F%E5%B8%A6%E6%9D%A5%E4%BA%86%E5%A4%8D%E6%9D%82%E5%BA%A6/">
            <span class="next-text nav-default">20__Spring框架：框架帮我们做了很多工作也带来了复杂度</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
