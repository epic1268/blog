<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>2320丨JavaC代码级监控及常用计数器解析下 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="20丨Java &amp; C &#43;&#43;：代码级监控及常用计数器解析（下）
在上一篇文章中，我们描述了在 Java 开发语言中如何抓取方法的执行时间，其中描述的操作也是我们在分析时经常使用的。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%9830%E8%AE%B2/2320%E4%B8%A8javac%E4%BB%A3%E7%A0%81%E7%BA%A7%E7%9B%91%E6%8E%A7%E5%8F%8A%E5%B8%B8%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A3%E6%9E%90%E4%B8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%9830%E8%AE%B2/2320%E4%B8%A8javac%E4%BB%A3%E7%A0%81%E7%BA%A7%E7%9B%91%E6%8E%A7%E5%8F%8A%E5%B8%B8%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A3%E6%9E%90%E4%B8%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="2320丨JavaC代码级监控及常用计数器解析下">
  <meta property="og:description" content="20丨Java &amp; C &#43;&#43;：代码级监控及常用计数器解析（下）
在上一篇文章中，我们描述了在 Java 开发语言中如何抓取方法的执行时间，其中描述的操作也是我们在分析时经常使用的。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="性能测试实战30讲">

  <meta itemprop="name" content="2320丨JavaC代码级监控及常用计数器解析下">
  <meta itemprop="description" content="20丨Java &amp; C &#43;&#43;：代码级监控及常用计数器解析（下）
在上一篇文章中，我们描述了在 Java 开发语言中如何抓取方法的执行时间，其中描述的操作也是我们在分析时经常使用的。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3992">
  <meta itemprop="keywords" content="性能测试实战30讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="2320丨JavaC代码级监控及常用计数器解析下">
  <meta name="twitter:description" content="20丨Java &amp; C &#43;&#43;：代码级监控及常用计数器解析（下）
在上一篇文章中，我们描述了在 Java 开发语言中如何抓取方法的执行时间，其中描述的操作也是我们在分析时经常使用的。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">2320丨JavaC代码级监控及常用计数器解析下</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3992 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>20丨Java &amp; C ++：代码级监控及常用计数器解析（下）</p>
<p>在上一篇文章中，我们描述了在 Java 开发语言中如何抓取方法的执行时间，其中描述的操作也是我们在分析时经常使用的。</p>
<p>今天我们将接着描述如下几点内容：</p>
<p>Java 语言中如何查找有问题的内存对象。</p>
<p>简单介绍一下在 C/C++ 语言中如何查找方法执行时间和对象的内存消耗。</p>
<p>之所以要描述 C/C++ 语言的相关内容，就是为了告诉你，几乎在任何一语言中都有相应的工具，都有办法捕获到相应的内容。</p>
<p>下面我们来看看如何抓取 Java 应用中对象占用多大内存，以及如何分辨占用是合理的和不合理的。</p>
<p>Java 类应用查找对象内存消耗</p>
<p>对 Java 的内存分析通常都落在对 JVM 的使用上（不要认为我这句话说得片面），再具体一点，说的就是内存泄露和内存溢出。由于现在对象都是可变长的，内存溢出就不常见了；而由于底层框架的慢慢成熟，内存泄露现在也不常见了。</p>
<p>有人说了，那你还啰嗦个什么劲呢？别捉急呀，不常见不等于没有。只是说它不再是 No.1 级的问题，但是排在 No.2 级还是没问题的。</p>
<p>如果你的应用有了问题，看到了像这样的图：</p>
<p>这是我在一个项目中遇到的问题，图片不够清晰，我们只要关注黄线的趋势就好。</p>
<p>之所以把它拿出来说事，是因为这个问题太极端了。上图是近 20 天的 JVM 使用率，从曲线的趋势上就可以看出来，它存在明显的内存泄露，但是又泄露得非常非常慢。这个系统要求 24x365 运行。</p>
<p>做过运维的人会知道，如此长时间的运行，运维时间长了之后，只会对这样的系统做常规的健康检查，因为前期天天关注它，又不出问题，眼睛都看瞎了，也不值得，于是后期就放松了警惕，慢慢懈怠。</p>
<p>而这个系统在生产上出现事故是在正常运行快到一年的时候，这个系统的业务量不大，十几个 TPS 的业务量级。这是一个外贸的系统，业务量虽然不大，但每个业务涉及的金额很大。其实出故障时间倒也不长，才几个小时，但是也干掉了几个总监级职位及相关人员。</p>
<p>如何对内存进行分析，仍然是性能测试分析的从业人员应该知道的知识点。</p>
<p>我们从技术的角度来说一下内存问题的排查思路。</p>
<p>这下我换个实例程序。我们照样用 jvisualvm，记住哦，这时候 Arthas 之类的工具就没得玩了，因为 Arthas 只会操作栈，有很多在 Java 方面做性能分析的工具都是只分析栈的。在 Java 中动态操作对象，其实资源消耗非常高。打个比方，你可以想像一下，在一个课间休息的校园，像寻找一个特定的孩子有多难。</p>
<p>其实操作一个对象还有迹可循，但是内存中那么多对象，要想全都控制，那几乎是不理智的。所以，我们首先要看内存整体的健康状态。</p>
<p>内存趋势判断</p>
<p>场景一：典型的正常内存的场景</p>
<p>看了这个图后，要有如下几个反应：</p>
<p>内存使用很正常，回收健康。</p>
<p>内存从目前的压力级别上来看，够用，无需再增加。</p>
<p>无内存泄露的情况，因为回收之后基本回到了同一水位上。</p>
<p>基本也能看得出来 GC 够快。为什么说基本呢？因为最好还是看一下这张图。</p>
<p>从这张图可以看到，当应用在压力场景之后，GC 并没有消耗过多的 CPU。</p>
<p>场景二：典型的内存分配过多的场景</p>
<p>从这张图我们可以看出来：</p>
<p>内存使用很正常，回收健康。</p>
<p>从目前的压力级别上来看，内存不仅够用，而且过多。</p>
<p>无内存泄露的情况。</p>
<p>场景三：典型的内存不够用的场景</p>
<p>从这张图我们可以看出来：</p>
<p>内存使用很正常，回收健康。</p>
<p>从目前的压力级别上来看，内存不够用，需再增加。</p>
<p>CPU 可看可不看，因为现在看似乎没多大意义，先加了内存再说。</p>
<p>无内存泄露的情况，因为回收之后基本回到了同一水位上。</p>
<p>场景四：典型的内存泄露到爆的场景</p>
<p>为了显示我能力的多样性，我换个工具的监控结果。</p>
<p>看到上面这张图，你可能觉得人生面对着挑战：“啥玩意？”</p>
<p>实际上，这张图说明以下四点：</p>
<p>年轻代（第三列）、年老代（第四列）全满了，持久代在不断增加，并且也没有释放过。</p>
<p>两个保留区（第一列、第二列）都是空的。</p>
<p>Yonug GC（第六列）已经不做了。</p>
<p>Full GC（第八列）一直都在尝试做回收的动作，但是一直也没成功，因为年轻代、年老代都没回收下来，持久代也在不停涨。</p>
<p>如果出现了 1 和 2 的话，不用看什么具体对象内存的消耗，只要像网上那些只玩 JVM 参数的人一样，调调参数就行了。</p>
<p>但是如果出现 3 和 4，对于 3 还要再判断一下，之前的内存是不是设置得太小了？如果是，就调大，看能不能到场景一的状态。如果不是，那就得像场景四一样，查一下内存到底消耗在哪个对象上了。</p>
<p>查找增加的内存</p>
<p>逻辑一</p>
<p>下面我们来说说如何判断性能测试过程中内存的变化。</p>
<p>我们在内存中经常看到的对象是这样的。</p>
<p>如果你用 jmap 的话，会看到如下信息。</p>
<p>你可能会问，这么多的内容，我到底要看什么呢？这也是性能测试人员经常遇到的问题，明明数据都在眼前，就是不知道从哪下嘴。</p>
<p>我建议你不要看这些底层的对象类型，因为实在是有点多哇。在这里我们最好是看自己代码调用的对象的内存占用大小增量。</p>
<p>先过滤下我们自己的包。</p>
<p>点击一下 Deltas，就能看到下面的截图。</p>
<p>在刚开始点击 Deltas 之后，会看到全是零的对象。</p>
<p>下面我们来做下压力，观察一下。</p>
<p>你看现在对象的实体都在往上增加对吧？但是当压力停止之后，该回收的都回收了，而有些必须长久使用的对象，在架构设计上也应该清晰地判断增量，不然就有可能导致内存不够。出现这种情况一般是架构师的失职。像这类东西应该写到公司的代码规范里。</p>
<p>当内存正常回收之后，再观察 Deltas，应该会看到大部分对象都回收了的状态。如下所示：</p>
<p>临时的对象也都清理了。 这就是正常的结果。</p>
<p>如果停止压力之后，又做了正常的 FullGC 回收了之后，还是像下面这样。</p>
<p>那就显然有问题了。回收不了的对象就是典型的内存泄露了。</p>
<p>逻辑二</p>
<p>我们看下面这个图。这是 jmap 做出来的 heapdump，然后用 MAT 打开的。</p>
<p>1. 第一个可疑的内存泄露点占了 466.4MB 的内存。</p>
<p>2. 找到内存消耗点的多的内容。如下所示。</p>
<p>这是一个实体 bean。每个倒是不大，但是架不住有 79 万个。</p>
<p>3. 看它对应的栈。</p>
<p>就是一个数据库操作。</p>
<p>4. 取出 SQL，查看执行计划如下。</p>
<p>这是曲线的 SQL 查询数据过多，导致内存不够用。这个不叫泄露，这是溢出。因为要是一个人查询，就可能没事嘛，但是多个人一起查了，才会出问题。从业务的代码实现的角度上说，这绝对是个有问题的设计逻辑。如果真是必须全表扫描的，你得规定这个功能怎么用呀。如果不用全表扫描，干嘛不做过滤呢？</p>
<p>其实在 Java 中查找内存消耗的手段还有很多。你喜欢怎么玩就怎么玩，只要找得到就好。我只是给两种我觉得常用又易用的方式。</p>
<p>C/C++ 类应用查找方法执行时间</p>
<p>对 C/C++ 的应用来说，我们可以用 google-perftools 查找方法执行时间。当然，在这之时，你需要先安装配置好 google-perftools 和 libunwind。</p>
<p>google-perftools 是针对 C/C++ 程序的性能分析工具。使用它，可以对 CPU 时间片、内存等系统资源的分配和使用进行分析。</p>
<p>使用步骤如下：</p>
<p>编译目标程序，加入对 google-perftools 库的依赖。</p>
<p>运行目标程序，在代码中加入启动 / 终止剖析的开关。</p>
<p>将生成的结果通过剖析工具生成相应的调用图。</p>
<p>你可以在代码中加入固定输出剖析数据的开关，当运行到某段代码时就会执行。当然你也可以在代码中只加入接收信号的功能，然后在运行的过程中，通过 kill 命令给正在运行的程序发送指令，从而控制开关。</p>
<p>我来举个例子。如果我们有一个函数 f，我想知道它的执行效率。硬编码的方式就是在调用这个函数的前后加上剖析开关。</p>
<p><code>ProfilerStart(&quot;test.prof&quot;);//开启性能分析f();ProfilerStop();//停止性能分析</code></p>
<p>在程序编译之后，会在同目录生成一个叫 a.out 的可执行文件。</p>
<p>执行这个文件，就会生成 test.prof 文件。</p>
<p>然后执行命令：</p>
<p><code>pprof --pdf a.out test.prof &gt;test.pdf </code></p>
<p>打开这个 PDF 就可以看到如下图：</p>
<p>你看到上面有很多只有地址而没有函数名的调用吗？那是没有符号表。这里我们不分析那些不是我们自己的函数，我们只看自己的函数 f。</p>
<p>看这一段，它有三行。</p>
<p>第一行：函数名；</p>
<p>第二行：不包含内部函数调用的样本数 (百分比) ；</p>
<p>第三行：of 包含内部函数调用的样本数 (百分比)。</p>
<p>是不是和 Java 中 self time/total time 有异曲同工之妙？它也可以实现从 CPU 使用率高到具体函数的定位。</p>
<p>你也许会说，这个有点复杂，还要在代码里加这么多，编译还要加上动态库啥的。当然了，你还可以用 perf 工具来跟踪 CPU clock，在代码编译时加上调试参数，就可以直接用 perf top -g 看调用过程由每个函数所消耗的 CPU 时钟。你还可以用 systemtap 来自己写代码进行动态跟踪。</p>
<p>C/C++ 类应用查找对象内存消耗</p>
<p>其实 googler perftools 也可以分析内存，但是我觉得它没有 Valgrind 好使。所以在这一部分，我用 valgrind 来告诉你如何查找到 C/C++ 的内存消耗。</p>
<p>valgrind 能实现这些功能：</p>
<p>这里举一个内存泄露的小例子。这是一段再无聊不过的代码：</p>
<p><code> #include &lt;stdlib.h&gt;  void f(void)  {     int\* x = malloc(10 \* sizeof(int));     x\[10\] = 0;        // problem 1: heap block overrun  }                    // problem 2: memory leak -- x not freed  int main(void)  {     f();     return 0;</code></p>
<p>我们不断分配，而不释放。</p>
<p>编译运行之后，我们可以看到如下结果。</p>
<p><code>\[root@7dgroup Sample10\]# gcc -Wall -o test5 test5.c \[root@7dgroup Sample10\]# valgrind --tool=memcheck --leak-check=full ./test5\==318== Memcheck, a memory error detector\==318== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.\==318== Using Valgrind-3.10.0 and LibVEX; rerun with -h for copyright info\==318== Command: ./test5\==318== \==318== Invalid write of size 4\==318==    at 0x40054E: f (in /root/GDB/Sample10/test5)\==318==    by 0x40055E: main (in /root/GDB/Sample10/test5)\==318==  Address 0x51f7068 is 0 bytes after a block of size 40 alloc'd\==318==    at 0x4C29BFD: malloc (in /usr/lib64/valgrind/vgpreload\_memcheck-amd64-linux.so)\==318==    by 0x400541: f (in /root/GDB/Sample10/test5)\==318==    by 0x40055E: main (in /root/GDB/Sample10/test5)\==318== \==318== \==318== HEAP SUMMARY:\==318==     in use at exit: 40 bytes in 1 blocks\==318==   total heap usage: 1 allocs, 0 frees, 40 bytes allocated\==318== \==318== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1\==318==    at 0x4C29BFD: malloc (in /usr/lib64/valgrind/vgpreload\_memcheck-amd64-linux.so)\==318==    by 0x400541: f (in /root/GDB/Sample10/test5)\==318==    by 0x40055E: main (in /root/GDB/Sample10/test5)\==318== \==318== LEAK SUMMARY:\==318==    definitely lost: 40 bytes in 1 blocks\==318==    indirectly lost: 0 bytes in 0 blocks\==318==      possibly lost: 0 bytes in 0 blocks\==318==    still reachable: 0 bytes in 0 blocks\==318==         suppressed: 0 bytes in 0 blocks\==318== \==318== For counts of detected and suppressed errors, rerun with: -v\==318== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 1 from 1)\[root@7dgroup Sample10\]# </code></p>
<p>主要看一下这行。</p>
<p><code>\==318==   total heap usage: 1 allocs, 0 frees, 40 bytes allocated</code></p>
<p>这里分配了 40 个字节的一块内存，但是 0 释放，所以就泄露了。</p>
<p>请你注意，在调试自己的程序时，要像 Java 一样，分析内存的泄露，在压力前和压力后做内存的比对。在压力中则不用做。</p>
<p>总结</p>
<p>不管是什么语言的应用，在性能分析的过程中，都是分析两个方法。</p>
<p>执行速度够不够快。只有够快才能满足更高的 TPS。</p>
<p>执行过程中内存用得多不多。内存用得少，才可以同时支持更多的请求。</p>
<p>我觉得对性能测试过程中的分析来说，这两点足够你解决代码上的问题了。有人说，为什么不说 I/O 的事情呢。其实 I/O 仍然是读写量的多少，也会反应用内存中。至于磁盘本身性能跟不上，那是另一个话题。</p>
<p>思考题</p>
<p>最后给你留两个思考题吧。对代码的性能分析过程中，主要是哪两点呢？针对代码分析的这两点，有什么样的分析链路？</p>
<p>欢迎你在评论区写下自己的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%9830%E8%AE%B2/">性能测试实战30讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/2318widedeep%E6%80%8E%E6%A0%B7%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%97%A2%E6%9C%89%E6%83%B3%E8%B1%A1%E5%8A%9B%E5%8F%88%E6%9C%89%E8%AE%B0%E5%BF%86%E5%8A%9B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">2318｜WideDeep怎样让你的模型既有想象力又有记忆力</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%9845%E8%AE%B2/2322%E4%B8%A8svm%E4%B8%8A%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%80%E6%A0%B9%E6%A3%8D%E5%AD%90%E5%B0%86%E8%93%9D%E7%BA%A2%E4%B8%A4%E8%89%B2%E7%90%83%E5%88%86%E5%BC%80/">
            <span class="next-text nav-default">2322丨SVM上如何用一根棍子将蓝红两色球分开</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
