<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>15__面向对象之继承：继承是代码复用的合理方式吗？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好！我是郑晔。
上一讲，我们讨论了面向对象的第一个特点：封装。这一讲，我们继续来看面向对象的第二个特点：继承。首先，你对继承的第一印象是什么呢？
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%BE%8E/15__%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%BB%A7%E6%89%BF%E6%98%AF%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E7%9A%84%E5%90%88%E7%90%86%E6%96%B9%E5%BC%8F%E5%90%97/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%BE%8E/15__%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%BB%A7%E6%89%BF%E6%98%AF%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E7%9A%84%E5%90%88%E7%90%86%E6%96%B9%E5%BC%8F%E5%90%97/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="15__面向对象之继承：继承是代码复用的合理方式吗？">
  <meta property="og:description" content="你好！我是郑晔。
上一讲，我们讨论了面向对象的第一个特点：封装。这一讲，我们继续来看面向对象的第二个特点：继承。首先，你对继承的第一印象是什么呢？">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="软件设计之美">

  <meta itemprop="name" content="15__面向对象之继承：继承是代码复用的合理方式吗？">
  <meta itemprop="description" content="你好！我是郑晔。
上一讲，我们讨论了面向对象的第一个特点：封装。这一讲，我们继续来看面向对象的第二个特点：继承。首先，你对继承的第一印象是什么呢？">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3519">
  <meta itemprop="keywords" content="软件设计之美">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="15__面向对象之继承：继承是代码复用的合理方式吗？">
  <meta name="twitter:description" content="你好！我是郑晔。
上一讲，我们讨论了面向对象的第一个特点：封装。这一讲，我们继续来看面向对象的第二个特点：继承。首先，你对继承的第一印象是什么呢？">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">15__面向对象之继承：继承是代码复用的合理方式吗？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3519 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#代码复用">代码复用</a></li>
      </ul>
    </li>
    <li><a href="#获取相应的产品信息">获取相应的产品信息</a></li>
    <li><a href="#生成报表服务">生成报表服务</a>
      <ul>
        <li><a href="#面向组合编程">面向组合编程</a></li>
      </ul>
    </li>
    <li><a href="#增加了-productenhancer">增加了 ProductEnhancer</a></li>
    <li><a href="#可以调用-enhance-方法">可以调用 enhance 方法</a>
      <ul>
        <li><a href="#总结时刻">总结时刻</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好！我是郑晔。</p>
<p>上一讲，我们讨论了面向对象的第一个特点：封装。这一讲，我们继续来看面向对象的第二个特点：继承。首先，你对继承的第一印象是什么呢？</p>
<p>说到继承，很多讲面向对象的教材一般会这么讲，给你画一棵树，父类是根节点，而子类是叶子节点，显然，一个父类可以有许多个子类。</p>
<p>父类是干什么用的呢？就是把一些公共代码放进去，之后在实现其他子类时，可以少写一些代码。讲程序库的时候，我们说过，设计的职责之一就是消除重复，代码复用。所以，在很多人的印象中，继承就是一种代码复用的方式。</p>
<p>如果我们把继承理解成一种代码复用方式，更多地是站在子类的角度向上看。在客户端代码使用的时候，面对的是子类，这种继承叫实现继承：</p>
<p>Child object = new Child();</p>
<p>其实，还有一种看待继承的角度，就是从父类的角度往下看，客户端使用的时候，面对的是父类，这种继承叫接口继承：</p>
<p>Parent object = new Child();</p>
<p>不过，接口继承更多是与多态相关，我们暂且放一放，留到下一讲再来讨论。这一讲，我们还是主要来说说实现继承。其实，实现继承并不是一种好的做法。</p>
<p>也就是说，<strong>把实现继承当作一种代码复用的方式，并不是一种值得鼓励的做法</strong>。一方面，继承是很宝贵的，尤其是 Java 这种单继承的程序设计语言。每个类只能有一个父类，一旦继承的位置被实现继承占据了，再想做接口继承就很难了。</p>
<p>另一方面，实现继承通常也是一种受程序设计语言局限的思维方式，有很多程序设计语言，即使不使用继承，也有自己的代码复用方式。</p>
<p>可能这么说你还不太理解，接下来，我就用一个例子来帮你更好地理解继承。</p>
<h2 id="代码复用">代码复用</h2>
<p>假设，我要做一个产品报表服务，其中有个服务是要查询产品信息，这个查询过程是通用的，别的服务也可以用，所以，我把它放到父类里面。这就是代码复用的做法，代码用 Java 写出来是这样的：</p>
<p>class BaseService {<br>
// 获取相应的产品信息<br>
protected List<Product> getProducts(List<String> product) {<br>
&hellip;<br>
}<br>
}</p>
<p>// 生成报表服务<br>
class ReportService extends BaseService {<br>
public void report() {<br>
List<Product> product = getProduct(&hellip;);<br>
// 生成报表<br>
&hellip;<br>
}<br>
}</p>
<p>如果采用 Ruby 的 mixin 机制，我们还可以这样实现，先定义一个模块（module）：</p>
<p>module ProductFetcher</p>
<h1 id="获取相应的产品信息">获取相应的产品信息</h1>
<p>def getProducts(products)<br>
&hellip;<br>
end<br>
end</p>
<p>然后，在自己的类定义中，将它包含（include）进来：</p>
<h1 id="生成报表服务">生成报表服务</h1>
<p>class ReportService<br>
include ProductFetcher</p>
<p>def report<br>
products = getProducts(&hellip;)<br>
# 生成报表<br>
..<br>
end<br>
end</p>
<p>在这个例子中，ReportService 并没有继承任何类，获取产品信息的代码也是可以复用的，也就是这里的 ProductFetcher 这个模块。这样一来，如果我需要有一个获取产品信息的地方，它不必非得是一个什么服务，无需继承任何类。</p>
<p>这是 Ruby 的做法，类似的语言特性还有 Scala 里的 trait。</p>
<p>在 C++ 中，虽然语法并没有严格地区分实现继承，但《Effective C++》这本行业的名著，给出了一个实用的建议：实现继承采用私有继承的方式实现：</p>
<p>class ReportService: private ProductFetcher {<br>
&hellip;<br>
}</p>
<p>请注意，在这个实现里，我的私有继承类名是 ProductFetcher。是的，它并不需要和这个报表服务有什么直接的关系，使用私有继承，就是为了复用它的代码。</p>
<p>从前面的分析中，我们也不难看出，获取产品信息和生成报表其实是两件事，只是因为在生成报表的过程中，需要获取产品信息，所以，它有了一个基类。</p>
<p>其实，在 Java 里面，我们不用继承的方式也能实现，也许你已经想到了，代码可以写成这样：</p>
<p>class ProductFetcher {<br>
// 获取相应的产品信息<br>
public List<Product> getProducts(List<String> product) {<br>
&hellip;<br>
}<br>
}</p>
<p>// 生成报表服务<br>
class ReportService {<br>
private ProductFetcher fetcher;</p>
<p>public void report() {<br>
List<Product> product = fetcher.getProducts(&hellip;);<br>
// 生成报表<br>
&hellip;<br>
}<br>
}</p>
<p>这种实现方案叫作组合，也就是说 ReportService 里组合进一个 ProductFetcher。在设计上，有一个通用的原则叫做：<strong>组合优于继承</strong>。也就是说，如果一个方案既能用组合实现，也能用继承实现，那就选择用组合实现。</p>
<p>好，到这里你已经清楚了，代码复用并不是使用继承的好场景。所以，<strong>要写继承的代码时，先问自己，这是接口继承，还是实现继承？如果是实现继承，那是不是可以写成组合？</strong></p>
<h2 id="面向组合编程">面向组合编程</h2>
<p>之所以可以用组合的方式实现，本质的原因是，获取产品信息和生成报表服务本来就是两件事。还记得我们在第 3 讲里讲过的“分离关注点”吗？如果你能看出它们是两件事，就不会把它们放到一起了。</p>
<p>我还讲过，分解是设计的第一步，而且分解的粒度越小越好。当你可以分解出来多个关注点，每一个关注点就应该是一个独立的模块。最终的<strong>类是由这些一个一个的小模块组合而成，这种编程的方式就是面向组合编程</strong>。它相当于换了一个视角：类是由多个小模块组合而成。</p>
<p>还以前面的报表服务为例，如果使用 Java，按照面向组合的思路写出来，大概是下面这样的。其中，为了增加复杂度，我增加了一个报表生成器（ReportGenerator），在获取产品信息之后，还要生成报表：</p>
<p>class ReportService {<br>
private ProductFetcher fetcher;<br>
private ReportGenerator generator;</p>
<p>public void report() {<br>
List<Product> product = fetcher.getProducts(&hellip;);<br>
// 生成报表<br>
generator.generate(product);<br>
}<br>
}</p>
<p>请注意，我在前面的表述中，故意用了模块这个词，而不是类。因为 ProductFetcher 和 ReportGenerator 只是因为我们用的是 Java，才写成了类；如果用 Ruby，它们的表现形式就会是一个 module；而在 Scala 里，就会成为一个 trait。我们再用 Ruby 示意一下：</p>
<p>class ReportService<br>
include ProductFetcher<br>
include ReportGenerator</p>
<p>def report<br>
products = getProducts(&hellip;)<br>
# 生成报表<br>
generateReport(products)<br>
end<br>
end</p>
<p>而使用 C++ 的话，表现形式则会是私有继承：</p>
<p>class ReportService: private ProductFetcher, private ReportGenerator {<br>
&hellip;<br>
}</p>
<p>C++ 本身支持宏定义，所以，我们可以自定义一些宏，将这些不同的概念区分开来：</p>
<p>#define MODULE(module) class module<br>
#define INCLUDE(module) private module</p>
<p>上面的类定义就可以变成更有表达性的写法：</p>
<p>MODULE(ProductFetcher) {<br>
&hellip;<br>
}</p>
<p>MODULE(ReportGenerator) {<br>
&hellip;<br>
}</p>
<p>class ReportService:<br>
INCLUDE(ProductFetcher),<br>
INCLUDE(ReportGenerator) {<br>
&hellip;<br>
}</p>
<p>我有一个 C++ 的高手朋友，把这种做法称之为“小类大对象”，这里面的小类就是一个一个的模块，而最终的大对象是最终组合出来的类生成的对象。</p>
<p>关于面向对象，有一点我们还没有说，就是<strong>面向对象面向的是“对象”，不是类</strong>。很多程序员习惯把对象理解成类的附属品，但在 Alan Kay 的理解中，对象本身就是一个独立的个体。所以，有些程序设计语言可以直接支持在对象上进行操作。</p>
<p>还是前面的例子，我想给报表服务增加一个接口，对产品信息做一下处理。用 Ruby 写出来会是这样：</p>
<p>module ProductEnhancer<br>
def enhance<br>
# 处理一下产品信息<br>
end<br>
end</p>
<p>service = ReportService.new</p>
<h1 id="增加了-productenhancer">增加了 ProductEnhancer</h1>
<p>service.extend(ProductEnhancer)</p>
<h1 id="可以调用-enhance-方法">可以调用 enhance 方法</h1>
<p>service.enhance</p>
<p>这样的处理只会影响这里的一个对象，而同样是这个 ReportService 的其他实例，则完全不受影响。这样做的好处是，我们不必写那么多类，而是根据需要在程序运行时组合出不同的对象。</p>
<p>在这里，相信你再一次意识到了要学习多种程序设计语言的重要性。Java 只有类这种组织方式，所以，很多有差异的概念只能用类这一个概念表示出来，思维就会受到限制，而不同的语言则提供了不同的表现形式，让概念更加清晰。</p>
<p>前面只是讲了面向组合编程在思考方式的转变，下面我们再来看设计上的差异。举个例子，我们有个字体类（Font），现在的需求是，字体能够加粗（Bold）、能够有下划线（Underline）、还要支持斜体（Italic），而且这些能力之间是任意组合的。</p>
<p>如果采用继承的方式，那就要有 8 个类：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%BE%8E/248a021696250a1800ff69e80fc3e59d.png" alt=""></p>
<p>而采用组合的方式，我们的字体类（Font）只要有三个独立的维度，也就是是否加粗（Bold）、是否有下划线（Underline）、是否是斜体（Italic）。这还不是终局，如果再来一种其他的要求，由 3 种要求变成 4 种，采用继承的方式，类的数量就会膨胀到 16 个类，而组合的方式只需要再增加一个维度就好。我们把一个 M*N 的问题，通过设计转变成了 M+N 的问题，复杂度的差别一望便知。</p>
<p>虽然我们一直在说，Java 在面向组合编程方面能力比较弱，但 Java 社区也在尝试不同的方式。早期的尝试有Qi4j，后来 Java 8 加入了 default method，在一定程度上也可以支持面向组合的编程。这里我们只是讲了面向对象社区在组合方面的探索，后面讲函数式编程时，还会讲到函数式编程在这方面的探索。</p>
<h2 id="总结时刻">总结时刻</h2>
<p>今天，我们学习了面向对象的第二个特点：继承。继承分为两种，实现继承和接口继承。实现继承是站在子类的视角看问题，接口继承则是站在父类的视角。</p>
<p>很多程序员把实现继承当作了一种代码复用的方式，但实际上，实现继承并不是一个好的代码复用的方式，之所以这种方式很常见，很大程度上是受了语言的局限。</p>
<p>Ruby 的 mixin 机制，Scala 提供的 trait 以及 C++ 提供的私有继承都是代码复用的方式。即便只使用 Java，也可以通过组合而非继承的方式进行代码复用。</p>
<p>今天我们还讲到这些复用方式背后的编程思想：面向组合编程。它给我们提供了一个不同的视角，但支撑面向组合编程的是分离关注点。将不同的关注点分离出来，每一个关注点成为一个模块，在需要的时候组装起来。面向组合编程，在设计本身上有很多优秀的地方，可以降低程序的复杂度，更是思维上的转变。</p>
<p>现在你已经知道了，在继承树上从下往上看，并不是一个好的思考方式，那从上往下看呢？下一讲，我们就来讲讲继承的另外一个方向，接口继承，也就是面向对象的第三个特点：多态。</p>
<p>如果今天的内容你只能记住一件事，那请记住：<strong>组合优于继承</strong>。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%BE%8E/2fe91789b694a3986850f370dad7c029.png" alt=""></p>
<h2 id="思考题">思考题</h2>
<p>最后，我想请你去了解一下一种叫DCI（Data，Context 和 Interaction）</p>
<p>的编程思想，结合今天的课程，分享一下你对 DCI 的理解。欢迎在留言区分享你的想法。</p>
<p>感谢阅读，如果你觉得这一讲的内容对你有帮助的话，也欢迎把它分享给你的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%BE%8E/">软件设计之美</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%9C%B1%E8%B5%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E8%AF%BE/15__%E6%AF%8F%E4%B8%AA%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">15__每个工程师都应该了解的：系统拆分</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/etcd%E5%AE%9E%E6%88%98%E8%AF%BE/15__%E5%86%85%E5%AD%98%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E7%9A%84etcd%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E9%82%A3%E4%B9%88%E9%AB%98/">
            <span class="next-text nav-default">15__内存：为什么你的etcd内存占用那么高？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
