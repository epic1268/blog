<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>18__StampedLock：有没有比读写锁更快的锁？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="在上一篇文章中，我们介绍了读写锁，学习完之后你应该已经知道“读写锁允许多个线程同时读共享变量，适用于读多写少的场景”。那在读多写少的场景中，还有没有更快的技术方案呢？还真有，Java 在 1.8 这个版本里，提供了一种叫 StampedLock 的锁，它的性能就比读写锁还要好。
下面我们就来介绍一下 StampedLock 的使用方法、内部工作原理以及在使用过程中需要注意的事项。
StampedLock 支持的三种锁模式 我们先来看看在使用上 StampedLock 和上一篇文章讲的 ReadWriteLock 有哪些区别。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/18__stampedlock%E6%9C%89%E6%B2%A1%E6%9C%89%E6%AF%94%E8%AF%BB%E5%86%99%E9%94%81%E6%9B%B4%E5%BF%AB%E7%9A%84%E9%94%81/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/18__stampedlock%E6%9C%89%E6%B2%A1%E6%9C%89%E6%AF%94%E8%AF%BB%E5%86%99%E9%94%81%E6%9B%B4%E5%BF%AB%E7%9A%84%E9%94%81/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="18__StampedLock：有没有比读写锁更快的锁？">
  <meta property="og:description" content="在上一篇文章中，我们介绍了读写锁，学习完之后你应该已经知道“读写锁允许多个线程同时读共享变量，适用于读多写少的场景”。那在读多写少的场景中，还有没有更快的技术方案呢？还真有，Java 在 1.8 这个版本里，提供了一种叫 StampedLock 的锁，它的性能就比读写锁还要好。
下面我们就来介绍一下 StampedLock 的使用方法、内部工作原理以及在使用过程中需要注意的事项。
StampedLock 支持的三种锁模式 我们先来看看在使用上 StampedLock 和上一篇文章讲的 ReadWriteLock 有哪些区别。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Java并发编程实战">

  <meta itemprop="name" content="18__StampedLock：有没有比读写锁更快的锁？">
  <meta itemprop="description" content="在上一篇文章中，我们介绍了读写锁，学习完之后你应该已经知道“读写锁允许多个线程同时读共享变量，适用于读多写少的场景”。那在读多写少的场景中，还有没有更快的技术方案呢？还真有，Java 在 1.8 这个版本里，提供了一种叫 StampedLock 的锁，它的性能就比读写锁还要好。
下面我们就来介绍一下 StampedLock 的使用方法、内部工作原理以及在使用过程中需要注意的事项。
StampedLock 支持的三种锁模式 我们先来看看在使用上 StampedLock 和上一篇文章讲的 ReadWriteLock 有哪些区别。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3008">
  <meta itemprop="keywords" content="Java并发编程实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="18__StampedLock：有没有比读写锁更快的锁？">
  <meta name="twitter:description" content="在上一篇文章中，我们介绍了读写锁，学习完之后你应该已经知道“读写锁允许多个线程同时读共享变量，适用于读多写少的场景”。那在读多写少的场景中，还有没有更快的技术方案呢？还真有，Java 在 1.8 这个版本里，提供了一种叫 StampedLock 的锁，它的性能就比读写锁还要好。
下面我们就来介绍一下 StampedLock 的使用方法、内部工作原理以及在使用过程中需要注意的事项。
StampedLock 支持的三种锁模式 我们先来看看在使用上 StampedLock 和上一篇文章讲的 ReadWriteLock 有哪些区别。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">18__StampedLock：有没有比读写锁更快的锁？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3008 字 </span>
          <span class="more-meta"> 预计阅读 7 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#stampedlock-支持的三种锁模式">StampedLock 支持的三种锁模式</a></li>
        <li><a href="#进一步理解乐观读">进一步理解乐观读</a></li>
        <li><a href="#stampedlock-使用注意事项">StampedLock 使用注意事项</a></li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#课后思考">课后思考</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>在<a href="./88909.md">上一篇文章</a>中，我们介绍了读写锁，学习完之后你应该已经知道“读写锁允许多个线程同时读共享变量，适用于读多写少的场景”。那在读多写少的场景中，还有没有更快的技术方案呢？还真有，Java 在 1.8 这个版本里，提供了一种叫 StampedLock 的锁，它的性能就比读写锁还要好。</p>
<p>下面我们就来介绍一下 StampedLock 的使用方法、内部工作原理以及在使用过程中需要注意的事项。</p>
<h2 id="stampedlock-支持的三种锁模式">StampedLock 支持的三种锁模式</h2>
<p>我们先来看看在使用上 StampedLock 和上一篇文章讲的 ReadWriteLock 有哪些区别。</p>
<p>ReadWriteLock 支持两种模式：一种是读锁，一种是写锁。而 StampedLock 支持三种模式，分别是：<strong>写锁</strong>、<strong>悲观读锁</strong>和<strong>乐观读</strong>。其中，写锁、悲观读锁的语义和 ReadWriteLock 的写锁、读锁的语义非常类似，允许多个线程同时获取悲观读锁，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的。不同的是：StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp。相关的示例代码如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">final StampedLock sl = 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  new StampedLock();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 获取 / 释放悲观读锁示意代码
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">long stamp = sl.readLock();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">try {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 省略业务相关代码
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} finally {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  sl.unlockRead(stamp);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 获取 / 释放写锁示意代码
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">long stamp = sl.writeLock();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">try {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 省略业务相关代码
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} finally {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  sl.unlockWrite(stamp);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>StampedLock 的性能之所以比 ReadWriteLock 还要好，其关键是 StampedLock 支持乐观读的方式。ReadWriteLock 支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；而 StampedLock 提供的乐观读，是允许一个线程获取写锁的，也就是说不是所有的写操作都被阻塞。</p>
<p>注意这里，我们用的是“乐观读”这个词，而不是“乐观读锁”，是要提醒你，<strong>乐观读这个操作是无锁的</strong>，所以相比较 ReadWriteLock 的读锁，乐观读的性能更好一些。</p>
<p>文中下面这段代码是出自 Java SDK 官方示例，并略做了修改。在 distanceFromOrigin() 这个方法中，首先通过调用 tryOptimisticRead() 获取了一个 stamp，这里的 tryOptimisticRead() 就是我们前面提到的乐观读。之后将共享变量 x 和 y 读入方法的局部变量中，不过需要注意的是，由于 tryOptimisticRead() 是无锁的，所以共享变量 x 和 y 读入方法局部变量时，x 和 y 有可能被其他线程修改了。因此最后读完之后，还需要再次验证一下是否存在写操作，这个验证操作是通过调用 validate(stamp) 来实现的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Point {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  private int x, y;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  final StampedLock sl = 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    new StampedLock();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 计算到原点的距离  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  int distanceFromOrigin() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 乐观读
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    long stamp = 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      sl.tryOptimisticRead();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 读入局部变量，
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 读的过程数据可能被修改
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int curX = x, curY = y;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 判断执行读操作期间，
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 是否存在写操作，如果存在，
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 则 sl.validate 返回 false
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (!sl.validate(stamp)){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      // 升级为悲观读锁
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      stamp = sl.readLock();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      try {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        curX = x;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        curY = y;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      } finally {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 释放悲观读锁
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        sl.unlockRead(stamp);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return Math.sqrt(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      curX * curX + curY * curY);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在上面这个代码示例中，如果执行乐观读操作的期间，存在写操作，会把乐观读升级为悲观读锁。这个做法挺合理的，否则你就需要在一个循环里反复执行乐观读，直到执行乐观读操作的期间没有写操作（只有这样才能保证 x 和 y 的正确性和一致性），而循环读会浪费大量的 CPU。升级为悲观读锁，代码简练且不易出错，建议你在具体实践时也采用这样的方法。</p>
<h2 id="进一步理解乐观读">进一步理解乐观读</h2>
<p>如果你曾经用过数据库的乐观锁，可能会发现 StampedLock 的乐观读和数据库的乐观锁有异曲同工之妙。的确是这样的，就拿我个人来说，我是先接触的数据库里的乐观锁，然后才接触的 StampedLock，我就觉得我前期数据库里乐观锁的学习对于后面理解 StampedLock 的乐观读有很大帮助，所以这里有必要再介绍一下数据库里的乐观锁。</p>
<p>还记得我第一次使用数据库乐观锁的场景是这样的：在 ERP 的生产模块里，会有多个人通过 ERP 系统提供的 UI 同时修改同一条生产订单，那如何保证生产订单数据是并发安全的呢？我采用的方案就是乐观锁。</p>
<p>乐观锁的实现很简单，在生产订单的表 product_doc 里增加了一个数值型版本号字段 version，每次更新 product_doc 这个表的时候，都将 version 字段加 1。生产订单的 UI 在展示的时候，需要查询数据库，此时将这个 version 字段和其他业务字段一起返回给生产订单 UI。假设用户查询的生产订单的 id=777，那么 SQL 语句类似下面这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">select id，... ，version
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">from product_doc
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">where id=777
</span></span></code></pre></td></tr></table>
</div>
</div><p>用户在生产订单 UI 执行保存操作的时候，后台利用下面的 SQL 语句更新生产订单，此处我们假设该条生产订单的 version=9。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">update product_doc 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">set version=version+1，...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">where id=777 and version=9
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果这条 SQL 语句执行成功并且返回的条数等于 1，那么说明从生产订单 UI 执行查询操作到执行保存操作期间，没有其他人修改过这条数据。因为如果这期间其他人修改过这条数据，那么版本号字段一定会大于 9。</p>
<p>你会发现数据库里的乐观锁，查询的时候需要把 version 字段查出来，更新的时候要利用 version 字段做验证。这个 version 字段就类似于 StampedLock 里面的 stamp。这样对比着看，相信你会更容易理解 StampedLock 里乐观读的用法。</p>
<h2 id="stampedlock-使用注意事项">StampedLock 使用注意事项</h2>
<p>对于读多写少的场景 StampedLock 性能很好，简单的应用场景基本上可以替代 ReadWriteLock，但是<strong>StampedLock 的功能仅仅是 ReadWriteLock 的子集</strong>，在使用的时候，还是有几个地方需要注意一下。</p>
<p>StampedLock 在命名上并没有增加 Reentrant，想必你已经猜测到 StampedLock 应该是不可重入的。事实上，的确是这样的，<strong>StampedLock 不支持重入</strong>。这个是在使用中必须要特别注意的。</p>
<p>另外，StampedLock 的悲观读锁、写锁都不支持条件变量，这个也需要你注意。</p>
<p>还有一点需要特别注意，那就是：如果线程阻塞在 StampedLock 的 readLock() 或者 writeLock() 上时，此时调用该阻塞线程的 interrupt() 方法，会导致 CPU 飙升。例如下面的代码中，线程 T1 获取写锁之后将自己阻塞，线程 T2 尝试获取悲观读锁，也会阻塞；如果此时调用线程 T2 的 interrupt() 方法来中断线程 T2 的话，你会发现线程 T2 所在 CPU 会飙升到 100%。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">final StampedLock lock
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  = new StampedLock();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Thread T1 = new Thread(()-&gt;{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 获取写锁
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  lock.writeLock();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 永远阻塞在此处，不释放写锁
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  LockSupport.park();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">});
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">T1.start();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 保证 T1 获取写锁
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Thread.sleep(100);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Thread T2 = new Thread(()-&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 阻塞在悲观读锁
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  lock.readLock()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">T2.start();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 保证 T2 阻塞在读锁
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Thread.sleep(100);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 中断线程 T2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 会导致线程 T2 所在 CPU 飙升
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">T2.interrupt();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">T2.join();
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以，<strong>使用 StampedLock 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly() 和写锁 writeLockInterruptibly()</strong>。这个规则一定要记清楚。</p>
<h2 id="总结">总结</h2>
<p>StampedLock 的使用看上去有点复杂，但是如果你能理解乐观锁背后的原理，使用起来还是比较流畅的。建议你认真揣摩 Java 的官方示例，这个示例基本上就是一个最佳实践。我们把 Java 官方示例精简后，形成下面的代码模板，建议你在实际工作中尽量按照这个模板来使用 StampedLock。</p>
<p>StampedLock 读模板：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">final StampedLock sl = 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  new StampedLock();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 乐观读
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">long stamp = 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  sl.tryOptimisticRead();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 读入方法局部变量
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 校验 stamp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if (!sl.validate(stamp)){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 升级为悲观读锁
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  stamp = sl.readLock();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  try {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 读入方法局部变量
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    .....
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  } finally {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 释放悲观读锁
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    sl.unlockRead(stamp);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 使用方法局部变量执行业务操作
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">......
</span></span></code></pre></td></tr></table>
</div>
</div><p>StampedLock 写模板：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">long stamp = sl.writeLock();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">try {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 写共享变量
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ......
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} finally {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  sl.unlockWrite(stamp);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="课后思考">课后思考</h2>
<p>StampedLock 支持锁的降级（通过 tryConvertToReadLock() 方法实现）和升级（通过 tryConvertToWriteLock() 方法实现），但是建议你要慎重使用。下面的代码也源自 Java 的官方示例，我仅仅做了一点修改，隐藏了一个 Bug，你来看看 Bug 出在哪里吧。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">private double x, y;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">final StampedLock sl = new StampedLock();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 存在问题的方法
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void moveIfAtOrigin(double newX, double newY){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> long stamp = sl.readLock();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> try {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  while(x == 0.0 &amp;&amp; y == 0.0){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    long ws = sl.tryConvertToWriteLock(stamp);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (ws != 0L) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      x = newX;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      y = newY;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      break;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      sl.unlockRead(stamp);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      stamp = sl.writeLock();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> } finally {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  sl.unlock(stamp);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/f2ae29f2a91a0266d9d86db774df526d.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">Java并发编程实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/18__spring_data_%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">18__Spring_Data_常见错误</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/tob%E5%B8%82%E5%9C%BA%E5%93%81%E7%89%8C%E5%AE%9E%E6%88%98%E8%AF%BE/18__to_b%E8%90%A5%E9%94%80%E7%9A%84%E9%98%B5%E5%9C%B0%E6%88%91%E4%BB%AC%E5%9C%A8%E5%93%AA%E9%87%8C%E8%AF%B4%E8%AF%9D%E4%B9%9F%E5%BE%88%E9%87%8D%E8%A6%81/">
            <span class="next-text nav-default">18__To_B营销的阵地：我们在哪里说话，也很重要</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
