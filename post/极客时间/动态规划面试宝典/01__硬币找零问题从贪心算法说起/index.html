<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>01__硬币找零问题：从贪心算法说起 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是卢誉声。
作为“初识动态规划”模块的第一节课，我会带着你一起从贪心算法开始了解整个知识体系的脉络。现实中，我们往往不愿意承认自己贪婪。事实上，贪婪是渴望而不知满足，它是人的一种基本驱动力。既然是基本驱动力，那它自然就不会太难。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/01__%E7%A1%AC%E5%B8%81%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98%E4%BB%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%AF%B4%E8%B5%B7/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/01__%E7%A1%AC%E5%B8%81%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98%E4%BB%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%AF%B4%E8%B5%B7/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="01__硬币找零问题：从贪心算法说起">
  <meta property="og:description" content="你好，我是卢誉声。
作为“初识动态规划”模块的第一节课，我会带着你一起从贪心算法开始了解整个知识体系的脉络。现实中，我们往往不愿意承认自己贪婪。事实上，贪婪是渴望而不知满足，它是人的一种基本驱动力。既然是基本驱动力，那它自然就不会太难。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="动态规划面试宝典">

  <meta itemprop="name" content="01__硬币找零问题：从贪心算法说起">
  <meta itemprop="description" content="你好，我是卢誉声。
作为“初识动态规划”模块的第一节课，我会带着你一起从贪心算法开始了解整个知识体系的脉络。现实中，我们往往不愿意承认自己贪婪。事实上，贪婪是渴望而不知满足，它是人的一种基本驱动力。既然是基本驱动力，那它自然就不会太难。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4191">
  <meta itemprop="keywords" content="动态规划面试宝典">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="01__硬币找零问题：从贪心算法说起">
  <meta name="twitter:description" content="你好，我是卢誉声。
作为“初识动态规划”模块的第一节课，我会带着你一起从贪心算法开始了解整个知识体系的脉络。现实中，我们往往不愿意承认自己贪婪。事实上，贪婪是渴望而不知满足，它是人的一种基本驱动力。既然是基本驱动力，那它自然就不会太难。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">01__硬币找零问题：从贪心算法说起</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4191 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#硬币找零问题">硬币找零问题</a></li>
        <li><a href="#贪心算法">贪心算法</a></li>
        <li><a href="#解题思路">解题思路</a></li>
        <li><a href="#贪心算法的局限性">贪心算法的局限性</a></li>
        <li><a href="#课程总结">课程总结</a></li>
        <li><a href="#课后思考">课后思考</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是卢誉声。</p>
<p>作为“初识动态规划”模块的第一节课，我会带着你一起从贪心算法开始了解整个知识体系的脉络。现实中，我们往往不愿意承认自己贪婪。事实上，贪婪是渴望而不知满足，它是人的一种基本驱动力。既然是基本驱动力，那它自然就不会太难。</p>
<p>所以你可能会说贪心算法很简单啊，但其实不然，这里面还真有不少门道值得我们说说。而且，它还跟动态规划问题有着千丝万缕的联系，能够帮助我们理解真正的动归问题。</p>
<p>接下来我们就从一个简单的算法问题开始探讨，那就是硬币找零。在开始前，我先提出一个问题：<strong>任何算法都有它的局限性，贪心算法也如此，那么贪心算法能解决哪些问题呢？</strong></p>
<p>你不妨带着这个问题来学习下面的内容。</p>
<h2 id="硬币找零问题">硬币找零问题</h2>
<p>移动支付已经成为了我们日常生活当中的主流支付方式，无论是在便利店购买一瓶水，还是在超市或菜市场购买瓜果蔬菜等生活用品，无处不在的二维码让我们的支付操作变得异常便捷。</p>
<p>但在移动支付成为主流支付方式之前，我们常常需要面对一个简单问题，就是找零的问题。</p>
<p>虽然说硬币找零在日常生活中越来越少，但它仍然活跃在编程领域和面试问题当中，主要还是因为它极具代表性，也能多方面考察一个开发人员或面试者解决问题的能力。</p>
<p>既然如此，我们就先来看看这个算法问题的具体描述。</p>
<p>问题：给定 n 种不同面值的硬币，分别记为 c[0], c[1], c[2], … c[n]，同时还有一个总金额 k，编写一个函数计算出<strong>最少</strong>需要几枚硬币凑出这个金额 k？每种硬币的个数不限，且如果没有任何一种硬币组合能组成总金额时，返回 -1。</p>
<p>示例 1：</p>
<p>输入：c[0]=1, c[1]=2, c[2]=5, k=12<br>
输出：3<br>
解释：12 = 5 + 5 + 2</p>
<p>示例 2：</p>
<p>输入：c[0]=5, k=7<br>
输出：-1<br>
解释：只有一种面值为 5 的硬币，怎么都无法凑出总价值为 7 的零钱。</p>
<p>题目中有一个醒目的提示词，那就是“最少”。嗯，看起来这是一个求最值的问题，其实也好理解，如果题目不在这里设定这一条件，那么所求结果就不唯一了。</p>
<p>举个简单的例子，按照示例 1 的题设，有三种不同面值的硬币，分别为 c1=1, c2=2, c3=5，在没有“最少”这一前提条件下你能罗列出几种不同的答案？我在这里随意列出几个：</p>
<p>解 1：输出：5，因为 5 + 2 + 2 + 2 + 1 = 12。<br>
解 2：输出：6，因为 2 + 2 + 2 + 2 + 2 + 2 = 12。<br>
解 3：输出：12，因为 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 12。</p>
<p>所以，这是一个求最值的问题。那么求最值的核心问题是什么呢？嗯，无非就是<strong>穷举</strong>，显然，就是把所有可能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币，那么最少的凑法，就是这道题目的答案。</p>
<p>在面试中，一般来说穷举从来都不是一个好方法。除非你要的结果就是所有的不同组合，而不是一个最值。但即便是求所有的不同组合，在计算的过程中也仍然会出现重复计算的问题，我们将这种现象称之为<strong>重叠子问题</strong>。</p>
<p>请你记住这个关键概念，它是动态规划当中的一个重要概念。但现在你只需要知道所谓重叠子问题就是：我们在罗列所有可能答案的过程中，可能存在重复计算的情况。我会在后续课程中与你深入探讨这个概念。</p>
<p>在尝试解决硬币找零问题前，我们先用较为严谨的定义来回顾一下贪心算法的概念。</p>
<h2 id="贪心算法">贪心算法</h2>
<p>所谓贪心算法，就是指它的每一步计算作出的都是在当前看起来最好的选择，也就是说它所作出的选择只是在某种意义上的局部最优选择，并不从整体最优考虑。在这里，我把这两种选择的思路称作<strong>局部最优解</strong>和<strong>整体最优解</strong>。</p>
<p>因此，我们可以得到贪心算法的基本思路：</p>
<ol>
<li>根据问题来建立数学模型，一般面试题会定义一个简单模型；</li>
<li>把待求解问题划分成若干个子问题，对每个子问题进行求解，得到子问题的局部最优解；</li>
<li>把子问题的局部最优解进行合并，得到最后基于局部最优解的一个解，即原问题的答案。</li>
</ol>
<h2 id="解题思路">解题思路</h2>
<p>现在让我们回到这个问题上来。</p>
<p>既然这道题问的是<strong>最少</strong>需要几枚硬币凑出金额 k，那么是否可以尝试使用贪心的思想来解这个问题呢？从面值最大的硬币开始兑换，最后得出的硬币总数很有可能就是最少的。</p>
<p>这个想法不错，让我们一起来试一试。</p>
<p>我用一个例子，带你看下整个贪心算法求解的过程，我们从 c[0]=5, c[1]=3 且 k=11 的情况下寻求最少硬币数。按照“贪心原则”，我们先挑选面值最大的，即为 5 的硬币放入钱包。接着，还有 6 元待解（即 11-5 = 6）。这时，我们再次“贪心”，放入 5 元面值的硬币。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/0cff08d7b964c1566ba38e098dccc964.png" alt=""></p>
<p>这样来看，贪心算法其实不难吧。我在这里把代码贴出来，你可以结合代码再理解一下算法的执行步骤。</p>
<p>Java 实现：</p>
<p>int getMinCoinCountHelper(int total, int[] values, int valueCount) {<br>
int rest = total;<br>
int count = 0;</p>
<pre><code>// 从大到小遍历所有面值  
for (int i = 0; i &lt; valueCount; ++ i) {  
    int currentCount = rest / values[i]; // 计算当前面值最多能用多少个  
    rest -= currentCount * values[i]; // 计算使用完当前面值后的余额  
    count += currentCount; // 增加当前面额用量  

    if (rest == 0) {  
        return count;  
    }  
}  

return -1; // 如果到这里说明无法凑出总价，返回 -1  
</code></pre>
<p>}</p>
<p>int getMinCoinCount() {<br>
int[] values = { 5, 3 }; // 硬币面值<br>
int total = 11; // 总价<br>
return getMinCoinCountHelper(total, values, 2); // 输出结果<br>
}</p>
<p>C++ 实现：</p>
<p>int GetMinCoinCountHelper(int total, int* values, int valueCount) {<br>
int rest = total;<br>
int count = 0;</p>
<pre><code>// 从大到小遍历所有面值  
for (int i = 0; i &lt; valueCount; ++ i) {  
    int currentCount = rest / values[i]; // 计算当前面值最多能用多少个  
    rest -= currentCount * values[i]; // 计算使用完当前面值后的余额  
    count += currentCount; // 增加当前面额用量  

    if (rest == 0) {  
        return count;  
    }  
}  

return -1; // 如果到这里说明无法凑出总价，返回 -1  
</code></pre>
<p>}</p>
<p>int GetMinCoinCount() {<br>
int values[] = { 5, 3 }; // 硬币面值<br>
int total = 11; // 总价<br>
return GetMinCoinCountHelper(total, values, 2); // 输出结果<br>
}</p>
<p>这段代码就是简单地从最大的面值开始尝试，每次都会把当前面值的硬币尽量用光，然后才会尝试下一种面值的货币。</p>
<p>嗯。。。你有没有发现问题？那就是还剩 1 元零钱待找，但是我们只有 c[0]=5, c[1]=3 两种面值的硬币，怎么办？这个问题无解了，该返回 -1 了吗？显然不是。</p>
<p>我们把第 2 步放入的 5 元硬币取出，放入面值为 3 元的硬币试试看。这时，你就会发现，我们还剩 3 元零钱待找。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/4caf0558619f1d9b8f71b281a9167820.png" alt=""></p>
<p>正好我们还有 c[1]=3 的硬币可以使用，因此解是 c[0]=5, c[1]=3, c[1]=3，即<strong>最少</strong>使用三枚硬币凑出了 k=11 这个金额。</p>
<p>我们对贪心算法做了改进，引入了回溯来解决前面碰到的“过于贪心”的问题。同样地，我把改进后的代码贴在这，你可以再看看跟之前算法实现的区别。</p>
<p>Java 实现：</p>
<p>int getMinCoinCountOfValue(int total, int[] values, int valueIndex) {<br>
int valueCount = values.length;<br>
if (valueIndex == valueCount) { return Integer.MAX_VALUE; }</p>
<pre><code>int minResult = Integer.MAX_VALUE;  
int currentValue = values[valueIndex];  
int maxCount = total / currentValue;  

for (int count = maxCount; count &gt;= 0; count --) {  
    int rest = total - count * currentValue;  

    // 如果 rest 为 0，表示余额已除尽，组合完成  
    if (rest == 0) {  
        minResult = Math.min(minResult, count);  
        break;  
    }  

    // 否则尝试用剩余面值求当前余额的硬币总数  
    int restCount = getMinCoinCountOfValue(rest, values, valueIndex + 1);  

    // 如果后续没有可用组合  
    if (restCount == Integer.MAX_VALUE) {  
        // 如果当前面值已经为 0，返回 -1 表示尝试失败  
        if (count == 0) { break; }  
        // 否则尝试把当前面值 -1  
        continue;  
    }  

    minResult = Math.min(minResult, count + restCount);  
}  

return minResult;  
</code></pre>
<p>}</p>
<p>int getMinCoinCountLoop(int total, int[] values, int k) {<br>
int minCount = Integer.MAX_VALUE;<br>
int valueCount = values.length;</p>
<pre><code>if (k == valueCount) {  
    return Math.min(minCount, getMinCoinCountOfValue(total, values, 0));  
}  

for (int i = k; i &lt;= valueCount - 1; i++) {  
    // k 位置已经排列好  
    int t = values[k];  
    values[k] = values[i];  
    values[i]=t;  
    minCount = Math.min(minCount, getMinCoinCountLoop(total, values, k + 1)); // 考虑后一位  

    // 回溯  
    t = values[k];  
    values[k] = values[i];  
    values[i]=t;  
}  

return minCount;  
</code></pre>
<p>}</p>
<p>int getMinCoinCountOfValue() {<br>
int[] values = { 5, 3 }; // 硬币面值<br>
int total = 11; // 总价<br>
int minCoin = getMinCoinCountLoop(total, values, 0);</p>
<pre><code>return (minCoin == Integer.MAX_VALUE) ? -1 : minCoin;  // 输出答案  
</code></pre>
<p>}</p>
<p>C++ 实现：</p>
<p>int GetMinCoinCountOfValue(int total, int* values, int valueIndex, int valueCount) {<br>
if (valueIndex == valueCount) { return INT_MAX; }</p>
<pre><code>int minResult = INT_MAX;  
int currentValue = values[valueIndex];  
int maxCount = total / currentValue;  

for (int count = maxCount; count &gt;= 0; count --) {  
    int rest = total - count * currentValue;  

    // 如果 rest 为 0，表示余额已除尽，组合完成  
    if (rest == 0) {  
        minResult = min(minResult, count);  
        break;  
    }  

    // 否则尝试用剩余面值求当前余额的硬币总数  
    int restCount = GetMinCoinCountOfValue(rest, values, valueIndex + 1, valueCount);  

    // 如果后续没有可用组合  
    if (restCount == INT_MAX) {  
        // 如果当前面值已经为 0，返回 -1 表示尝试失败  
        if (count == 0) { break; }  
        // 否则尝试把当前面值 -1  
        continue;  
    }  

    minResult = min(minResult, count + restCount);  
}  

return minResult;  
</code></pre>
<p>}</p>
<p>int GetMinCoinCountLoop(int total, int* values, int valueCount, int k) {<br>
int minCount = INT_MAX;<br>
if (k == valueCount) {<br>
return min(minCount, GetMinCoinCountOfValue(total, values, 0, valueCount));<br>
}</p>
<pre><code>for (int i = k; i &lt;= valueCount - 1; i++) {  
    // k 位置已经排列好  
    int t = values[k];  
    values[k] = values[i];  
    values[i]=t;  
    minCount = min(minCount, GetMinCoinCountOfValue(total, values, 0, valueCount));  
    minCount = min(minCount, GetMinCoinCountLoop(total, values, valueCount, k + 1)); // 考虑后一位  

    // 回溯  
    t = values[k];  
    values[k] = values[i];  
    values[i]=t;  
}  

return minCount;  
</code></pre>
<p>}</p>
<p>int GetMinCoinCountOfValue() {<br>
int values[] = { 5, 3 }; // 硬币面值<br>
int total = 11; // 总价<br>
int minCoin = GetMinCoinCountLoop(total, values, 2, 0);</p>
<pre><code>return (minCoin == INT_MAX) ? -1 : minCoin;  
</code></pre>
<p>}</p>
<p>改进后的算法实现在之前的基础上增加上了一个<strong>回溯</strong>过程。简单地说就是多了一个<strong>递归</strong>，不断尝试用更少的当前面值来拼凑。只要有一个组合成功，我们就返回总数，如果所有组合都尝试失败，就返回 -1。</p>
<p>嗯，这样就没问题了，对硬币找零问题来说，我们得到了理想的结果。</p>
<h2 id="贪心算法的局限性">贪心算法的局限性</h2>
<p>从上面这个例子我们可以看出，如果只是简单采用贪心的思路，那么到用完 2 个 5 元硬币的时候我们就已经黔驴技穷了——因为剩下的 1 元无论如何都没法用现在的硬币凑出来。这是什么问题导致的呢？</p>
<p>这就是贪心算法所谓的<strong>局部最优</strong>导致的问题，因为我们每一步都尽量多地使用面值最大的硬币，因为这样数量肯定最小，但是有的时候我们就进入了死胡同，就好比上面这个例子。</p>
<p>所谓<strong>局部最优</strong>，就是只考虑“当前”的最大利益，既不向前多看一步，也不向后多看一步，导致每次都只用当前阶段的最优解。</p>
<p>那么如果纯粹采用这种策略我们就永远无法达到<strong>整体最优</strong>，也就无法求得题目的答案了。至于能得到答案的情况那就是我们走狗屎运了。</p>
<p>虽然纯粹的贪心算法作用有限，但是这种求解<strong>局部最优</strong>的思路在方向上肯定是对的，毕竟所谓的<strong>整体最优</strong>肯定是从很多个<strong>局部最优</strong>中选择出来的，因此所有最优化问题的基础都是贪心算法。</p>
<p>回到前面的例子，我只不过是在贪心的基础上加入了失败后的回溯，稍微牺牲一点当前利益，仅仅是希望通过下一个硬币面值的<strong>局部最优</strong>达到最终可行的<strong>整体最优</strong>。</p>
<p>所有贪心的思路就是我们最优化求解的根本思想，所有的方法只不过是针对贪心思路的改进和优化而已。回溯解决的是正确性问题，而动态规划则是解决时间复杂度的问题。</p>
<p>贪心算法是求解整体最优的真正思路源头，这就是为什么我们要在课程的一开始就从贪心算法讲起。</p>
<h2 id="课程总结">课程总结</h2>
<p>硬币找零问题本质上是求最值问题。事实上，动态规划问题的一般形式就是求最值，而求最值的核心思想是<strong>穷举</strong>。这是因为只要我们能够找到所有可能的答案，从中挑选出最优的解就是算法问题的结果。</p>
<p>在没有优化的情况下，穷举从来就不算是一个好方法。所以我带你使用了贪心算法来解题，它是一种使用<strong>局部最优</strong>思想解题的算法（即从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的速度去求得更好的解，当达到算法中的某一步不能再继续前进时，算法停止）。</p>
<p>但是通过硬币找零问题，我们也发现了贪心算法本身的局限性：</p>
<ol>
<li>不能保证求得的最后解是最佳的；</li>
<li>不能用来求最大或最小解问题；</li>
<li>只能求满足某些约束条件的可行解的范围。</li>
</ol>
<p>我们往往需要使用<strong>回溯</strong>来优化贪心算法，否则就会导致算法失效。因此，在求解最值问题时，我们需要更好的方法来解。在后面课程讲到递归和穷举优化问题的时候，我会讲到解决最值问题的正确思路和方法：考虑<strong>整体最优</strong>的问题。</p>
<h2 id="课后思考">课后思考</h2>
<p>在递归问题中，回溯是一种经典的优化算法性能的方法。递归对动态规划来说也十分重要。你能否举出使用回溯算法来解的面试问题？并给出你的解。希望你能在课后提出问题，进行练习。</p>
<p>最后，欢迎留言和我分享你的思考，我会第一时间给你反馈。如果今天的内容对你有所启发，也欢迎把它分享给你身边的朋友，邀请他一起学习！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">动态规划面试宝典</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8%E8%AF%BE/01__%E5%BD%B1%E5%83%8F%E6%97%B6%E4%BB%A3%E7%9A%84%E8%A7%86%E8%A7%89%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%98%AF%E4%BB%80%E4%B9%88%E6%8E%A8%E5%8A%A8%E4%BA%86%E6%91%84%E5%BD%B1%E7%9A%84%E5%8F%91%E5%B1%95/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">01__影像时代的视觉语言（上）：是什么推动了摄影的发展？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B5%81%E7%A8%8B%E5%9E%8B%E7%BB%84%E7%BB%8715%E8%AE%B2/01__%E6%8B%A5%E6%8A%B1%E5%AE%A2%E6%88%B7%E8%BF%98%E6%98%AF%E8%80%81%E6%9D%BF%E8%80%81%E6%9D%BF%E5%AF%BC%E5%90%91%E5%9E%8B%E7%BB%84%E7%BB%87%E7%9A%84%E5%BC%8A%E7%AB%AF/">
            <span class="next-text nav-default">01__拥抱客户还是老板？老板导向型组织的弊端</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
