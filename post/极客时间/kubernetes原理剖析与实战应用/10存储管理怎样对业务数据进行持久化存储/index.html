<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>10存储管理：怎样对业务数据进行持久化存储？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="通过上一节课的学习，我们知道了如何在 Pod 中使用 Volume 来保存数据。Volume 跟 Pod 的生命周期是绑定的，当 Pod被删除后，Volume 中的数据有可能会一同被删除，具体需要看对应的 volume plugin 的使用要求，你可以看上节课的对比表格。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kubernetes%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/10%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%80%8E%E6%A0%B7%E5%AF%B9%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kubernetes%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/10%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%80%8E%E6%A0%B7%E5%AF%B9%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="10存储管理：怎样对业务数据进行持久化存储？">
  <meta property="og:description" content="通过上一节课的学习，我们知道了如何在 Pod 中使用 Volume 来保存数据。Volume 跟 Pod 的生命周期是绑定的，当 Pod被删除后，Volume 中的数据有可能会一同被删除，具体需要看对应的 volume plugin 的使用要求，你可以看上节课的对比表格。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Kubernetes原理剖析与实战应用">

  <meta itemprop="name" content="10存储管理：怎样对业务数据进行持久化存储？">
  <meta itemprop="description" content="通过上一节课的学习，我们知道了如何在 Pod 中使用 Volume 来保存数据。Volume 跟 Pod 的生命周期是绑定的，当 Pod被删除后，Volume 中的数据有可能会一同被删除，具体需要看对应的 volume plugin 的使用要求，你可以看上节课的对比表格。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3895">
  <meta itemprop="keywords" content="Kubernetes原理剖析与实战应用">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="10存储管理：怎样对业务数据进行持久化存储？">
  <meta name="twitter:description" content="通过上一节课的学习，我们知道了如何在 Pod 中使用 Volume 来保存数据。Volume 跟 Pod 的生命周期是绑定的，当 Pod被删除后，Volume 中的数据有可能会一同被删除，具体需要看对应的 volume plugin 的使用要求，你可以看上节课的对比表格。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">10存储管理：怎样对业务数据进行持久化存储？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3895 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>通过上一节课的学习，我们知道了如何在 Pod 中使用 Volume 来保存数据。Volume 跟 Pod 的生命周期是绑定的，当 Pod被删除后，Volume 中的数据有可能会一同被删除，具体需要看对应的 volume plugin 的使用要求，你可以看上节课的对比表格。</p>
<p>而这里我们还需要考虑如下几个问题。</p>
<p>共享 Volume。目前 Pod 内的 Volume 其实跟 Pod 是存在静态的一一绑定关系，即生命周期绑定。这导致不同 Pod 之间无法共享 Volume。</p>
<p>复用 Volume 中的数据。当 Pod 由于某种原因失败，被工作负载控制器删除重新创建后，我们需要能够复用 Volume 中的旧数据。</p>
<p>Volume 自身的一些强关联诉求。对于有状态工作负载 StatefulSet 来说，当其管理的 Pod 由于所在的宿主机出现一些硬件或软件问题，比如磁盘损坏、kernel 异常等，Pod 重新“长”到别的节点上，这时该如何保证 Volume 和 Pod 之间强关联的关系？</p>
<p>Volume 功能及语义扩展，比如容量大小、标签信息、扩缩容等。</p>
<p>为此我们在 Kubernetes 中引入了一个专门的对象 Persistent Volume（简称 PV），将计算和存储进行分离，可以使用不同的控制器来分别管理。</p>
<p>同时通过 PV，我们也可以和 Pod 自身的生命周期进行解耦。一个 PV 可以被几个 Pod 同时使用，即使 Pod 被删除后，PV 这个对象依然存在，其他新的 Pod 依然可以复用。为了更好地描述这种关联绑定关系，易于使用，并且屏蔽更多用户并不关心的细节参数（比如 PV 由谁提供、创建在哪个 zone/region、怎么去访问到，等等），我们通过一个抽象对象 Persistent Volume Claim（PVC）来使用 PV。</p>
<p>我们可以把 PV 理解成是对实际的物理存储资源描述，PVC 是便于使用的抽象 API。在 Kubernetes 中，我们都是在 Pod 中通过PVC 的方式来使用 PV 的，见下图。</p>
<p>（https://phoenixnap.com/kb/wp-content/uploads/2020/01/graphic-of-persistent-volume-bond.png）</p>
<p>在 Kubernetes 中，创建 PV（PV Provision） 有两种方式，即静态和动态，如下图所示。</p>
<p>（https://platform9.com/wp-content/uploads/2019/05/kubernetes-Persistent-volumes-claims-storage-classes.jpg）</p>
<p>静态 PV</p>
<p>（https://thenewstack.io/wp-content/uploads/2016/09/Kubernetes_PVC.png）</p>
<p>我们先来看静态 PV（Static PV），管理员通过手动的方式在后端存储平台上创建好对应的 Volume，然后通过 PV 定义到 Kubernetes 中去。开发者通过 PVC 来使用。我们来看个 HostPath 类型的 PV 例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">kind: PersistentVolume
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">  name: task-pv-volume # pv 的名字
</span></span><span class="line"><span class="cl">  labels: # pv 的一些label
</span></span><span class="line"><span class="cl">    type: local
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">  storageClassName: manual
</span></span><span class="line"><span class="cl">  capacity: # 该 pv 的容量
</span></span><span class="line"><span class="cl">    storage: 10Gi
</span></span><span class="line"><span class="cl">  accessModes: # 该 pv 的接入模式
</span></span><span class="line"><span class="cl">    - ReadWriteOnce
</span></span><span class="line"><span class="cl">  hostPath: # 该 pv 使用的 hostpath 类型，还支持通过 CSI 接入其他 plugin
</span></span><span class="line"><span class="cl">    path: &#34;/mnt/data&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里，我们定义了一个名为task-pv-volume的 PV，PV 是集群的资源，并不属于某个 namespace。其中storageClassName这个字段是某个StorageClass对象的名字。我们会在下一段动态 PV 中讲解StorageClass的作用。</p>
<p>对于每一个 PV，我们都要为其设置存储能力，目前只支持对存储空间的设置，比如我们这里设置了 10G 的空间大小。未来社区还会加入其他的配置，诸如 IOPS（Input/Output Operations Per Second，每秒输入输出次数）、吞吐量等。</p>
<p>这里头accessMode可以指定该 PV 的几种访问挂载方式：</p>
<p>ReadWriteOnce（RWO）表示该卷只可以以读写方式挂载到一个 Pod 内；</p>
<p>ReadOnlyMany（ ROX）表示该卷可以挂载到多个节点上，并被多个 Pod 以只读方式挂载；</p>
<p>ReadWriteMany（RWX）表示卷可以被多个节点以读写方式挂载供多个 Pod 同时使用。</p>
<p>注意一个 PV 只能有一种访问挂载模式。不同的 volume plugin 支持的 accessMode 并不相同，在使用的时候，你可以参照官方的这个表格进行选择。</p>
<p>我们创建好后查看这个 PV：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ kubectl get pv task-pv-volume
</span></span><span class="line"><span class="cl">NAME             CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS      CLAIM     STORAGECLASS   REASON    AGE
</span></span><span class="line"><span class="cl">task-pv-volume   10Gi       RWO           Retain          Available             manual                   4s
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，这个 PV 的状态为Available（可用）。这里我们还看到上面
kubectl get
的输出里面有个 ReclaimPolicy 字段，该字段表明对 PV 的回收策略，默认是 Retain，即 PV 使用完后数据保留，需要由管理员手动清理数据。除了 Retain 外，还支持如下策略：</p>
<p>Recycle，即回收，这个时候会清除 PV 中的数据；</p>
<p>Delete，即删除，这个策略常在云服务商的存储服务中使用到，比如 AWS EBS。</p>
<p>下面我们再创建一个 PVC：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">kind: PersistentVolumeClaim
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">  name: task-pv-claim
</span></span><span class="line"><span class="cl">  namespace: dmeo
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">  storageClassName: manual
</span></span><span class="line"><span class="cl">  accessModes:
</span></span><span class="line"><span class="cl">    - ReadWriteOnce
</span></span><span class="line"><span class="cl">  resources:
</span></span><span class="line"><span class="cl">    requests:
</span></span><span class="line"><span class="cl">      storage: 3Gi
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建好了以后，Kubernetes 会为 PVC 匹配满足条件的 PV。我们在 PVC 里面指定storageClassName为 manua，这个时候就只会去匹配storageClassName同样为 manual 的 PV。一旦发现合适的 PV 后，就可以绑定到该 PV 上。</p>
<p>PVC 是 namespace 级别的资源，我们来创建看看:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ kubectl get pvc -n demo
</span></span><span class="line"><span class="cl">NAME            STATUS   VOLUME           CAPACITY   ACCESS MODES   STORAGECLASS   AGE
</span></span><span class="line"><span class="cl">task-pv-claim   Bound    task-pv-volume   10Gi       RWO            manual         9s
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以看到 这个 PVC 已经和我们上面的 PV 绑定起来了。我们再来查看下task-pv-volume这个 PV 对象，可以看到它的状态也从Available变成了 Bound。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ kubectl get pv task-pv-volume
</span></span><span class="line"><span class="cl">NAME             CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                   STORAGECLASS   REASON   AGE
</span></span><span class="line"><span class="cl">task-pv-volume   10Gi       RWO            Retain           Bound    default/task-pv-claim   manual                  2m12s
</span></span></code></pre></td></tr></table>
</div>
</div><p>PV 一般会有如下五种状态：</p>
<p>Pending 表示目前该 PV 在后端存储系统中还没创建完成；</p>
<p>Available 即闲置可用状态，这个时候还没有被绑定到任何 PVC 上；</p>
<p>Bound 就像上面例子里似的，这个时候已经绑定到某个 PVC 上了；</p>
<p>Released 表示已经绑定的 PVC 已经被删掉了，但资源还未被回收掉；</p>
<p>Failed 表示回收失败。</p>
<p>同样，对于 PVC 来说，也有如下三种状态：</p>
<p>Pending 表示还未绑定任何 PV；</p>
<p>Bound 表示已经和某个 PV 进行了绑定；</p>
<p>Lost 表示关联的 PV 失联。</p>
<p>下面我们来看看，如何在 Pod 中使用静态的 PV。看如下的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">kind: Pod
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">  name: task-pv-pod
</span></span><span class="line"><span class="cl">  namespace: demo
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">  volumes:
</span></span><span class="line"><span class="cl">    - name: task-pv-storage
</span></span><span class="line"><span class="cl">      persistentVolumeClaim:
</span></span><span class="line"><span class="cl">        claimName: task-pv-claim
</span></span><span class="line"><span class="cl">  containers:
</span></span><span class="line"><span class="cl">    - name: task-pv-container
</span></span><span class="line"><span class="cl">      image: nginx:1.14.2
</span></span><span class="line"><span class="cl">      ports:
</span></span><span class="line"><span class="cl">        - containerPort: 80
</span></span><span class="line"><span class="cl">          name: &#34;http-server&#34;
</span></span><span class="line"><span class="cl">      volumeMounts:
</span></span><span class="line"><span class="cl">        - mountPath: &#34;/usr/share/nginx/html&#34;
</span></span><span class="line"><span class="cl">          name: task-pv-storage
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建完成以后：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ kubectl get pod task-pv-pod -n demo
</span></span><span class="line"><span class="cl">NAME          READY   STATUS    RESTARTS   AGE
</span></span><span class="line"><span class="cl">task-pv-pod   1/1     Running   1          82s
</span></span><span class="line"><span class="cl">$ kubectl exec -it task-pv-pod -n demo -- /bin/bash
</span></span><span class="line"><span class="cl">root@task-pv-pod:/# df -h
</span></span><span class="line"><span class="cl">Filesystem      Size  Used Avail Use% Mounted on
</span></span><span class="line"><span class="cl">overlay          40G  5.0G   33G  14% /
</span></span><span class="line"><span class="cl">tmpfs            64M     0   64M   0% /dev
</span></span><span class="line"><span class="cl">tmpfs           996M     0  996M   0% /sys/fs/cgroup
</span></span><span class="line"><span class="cl">/dev/vda1        40G  5.0G   33G  14% /etc/hosts
</span></span><span class="line"><span class="cl">shm              64M     0   64M   0% /dev/shm
</span></span><span class="line"><span class="cl">overlay         996M  4.0M  992M   1% /usr/share/nginx/html
</span></span><span class="line"><span class="cl">tmpfs           996M   12K  996M   1% /run/secrets/kubernetes.io/serviceaccount
</span></span><span class="line"><span class="cl">tmpfs           996M     0  996M   0% /proc/acpi
</span></span><span class="line"><span class="cl">tmpfs           996M     0  996M   0% /sys/firmware
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，PV 已经正确挂载到 Pod 内。静态 PV 最大的问题就是使用起来不够方便，都是管理员提前创建好一批指定规格的 PV，无法做到按需创建。使用过程中，经常会遇到由于资源大小不匹配，规格不对等，造成 PVC 无法绑定 PV 的情况。同时还会造成资源浪费，比如一个只需要 1G 空间的 Pod，绑定了 10G 的 PV。</p>
<p>这些问题，都可以通过动态 PV 来解决。</p>
<p>动态 PV</p>
<p>要想动态创建 PV，我们需要一些参数来帮助我们创建 PV。这里我们用StorageClass这个对象来描述，你可以在 Kubernetes 中定义很多的 StorageClass，如下就是一个 Storage 的定义例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">apiVersion: storage.k8s.io/v1
</span></span><span class="line"><span class="cl">kind: StorageClass
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">  name: fast-rbd-sc
</span></span><span class="line"><span class="cl">  annotation:
</span></span><span class="line"><span class="cl">    storageclass.kubernetes.io/is-default-class: &#34;true&#34;
</span></span><span class="line"><span class="cl">provisioner: kubernetes.io/rbd # 必填项，用来指定volume plugin来创建PV的物理资源
</span></span><span class="line"><span class="cl">parameters: # 一些参数
</span></span><span class="line"><span class="cl">  monitors: 10.16.153.105:6789
</span></span><span class="line"><span class="cl">  adminId: kube
</span></span><span class="line"><span class="cl">  adminSecretName: ceph-secret
</span></span><span class="line"><span class="cl">  adminSecretNamespace: kube-system
</span></span><span class="line"><span class="cl">  pool: kube
</span></span><span class="line"><span class="cl">  userId: kube
</span></span><span class="line"><span class="cl">  userSecretName: ceph-secret-user
</span></span><span class="line"><span class="cl">  userSecretNamespace: default
</span></span><span class="line"><span class="cl">  fsType: ext4
</span></span><span class="line"><span class="cl">  imageFormat: &#34;2&#34;
</span></span><span class="line"><span class="cl">  imageFeatures: &#34;layering&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>你可以通过注释
storageclass.kubernetes.io/is-default-class
来指定默认的 StorageClass。这样新创建出来的 PVC 中的 storageClassName 字段就会自动使用默认的 StorageClass。</p>
<p>这里有个 provisioner 字段是必填项，主要用于指定使用那个 volume plugin 来创建 PV。没错，这里正是对应我们上节课讲过的 CSI driver 的名字。</p>
<p>现在我们来讲一下动态 PV 工作的过程:</p>
<p>（https://lenadroid.github.io/posts/cassandra-kube/4.png）</p>
<p>首先我们定义了一个 StorageClass。当用户创建好 Pod 以后，指定了 PVC，这个时候 Kubernetes 就会根据 StorageClass 中定义的 Provisioner 来调用对应的 plugin 来创建 PV。PV 创建成功后，跟 PVC 进行绑定，挂载到 Pod 中使用。</p>
<p>StatefulSet 中怎么使用 PV 和 PVC？</p>
<p>还记得我们之前讲 StatefulSet 中遗留的问题吗？对于 StatefulSet 管理的 Pod，每个 Pod 使用的 Volume 中的数据都不一样，而且相互之间关系是需要强绑定的。这个时候就不能在 StatefulSet 的
spec.template
去直接指向 PV 和 PVC了。于是我们在 StatefulSet 中使用了volumeClaimTemplate，有了这个 template 我们就可以为每一个 Pod 生成一个单独的 PVC，并且绑定 PV 了，从而实现有状态服务各个 Pod 都有自己专属的存储。这里生成的 PVC 名字跟 StatefulSet 的 Pod 名字一样，都是带有特定的序列号的。</p>
<p>你可以看看这里 StatefulSet 的例子:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">apiVersion: apps/v1
</span></span><span class="line"><span class="cl">kind: StatefulSet
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">  name: web
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">  serviceName: &#34;nginx&#34;
</span></span><span class="line"><span class="cl">  replicas: 2
</span></span><span class="line"><span class="cl">  selector:
</span></span><span class="line"><span class="cl">    matchLabels:
</span></span><span class="line"><span class="cl">      app: nginx
</span></span><span class="line"><span class="cl">  template:
</span></span><span class="line"><span class="cl">    metadata:
</span></span><span class="line"><span class="cl">      labels:
</span></span><span class="line"><span class="cl">        app: nginx
</span></span><span class="line"><span class="cl">    spec:
</span></span><span class="line"><span class="cl">      containers:
</span></span><span class="line"><span class="cl">      - name: nginx
</span></span><span class="line"><span class="cl">        image: k8s.gcr.io/nginx-slim:0.8
</span></span><span class="line"><span class="cl">        ports:
</span></span><span class="line"><span class="cl">        - containerPort: 80
</span></span><span class="line"><span class="cl">          name: web
</span></span><span class="line"><span class="cl">        volumeMounts:
</span></span><span class="line"><span class="cl">        - name: www
</span></span><span class="line"><span class="cl">          mountPath: /usr/share/nginx/html
</span></span><span class="line"><span class="cl">  volumeClaimTemplates:
</span></span><span class="line"><span class="cl">  - metadata:
</span></span><span class="line"><span class="cl">      name: www
</span></span><span class="line"><span class="cl">    spec:
</span></span><span class="line"><span class="cl">      accessModes: [ &#34;ReadWriteOnce&#34; ]
</span></span><span class="line"><span class="cl">      resources:
</span></span><span class="line"><span class="cl">        requests:
</span></span><span class="line"><span class="cl">          storage: 1Gi
</span></span></code></pre></td></tr></table>
</div>
</div><p>写在最后</p>
<p>这节课我们讲了 PV、PVC 以及 StorageClass，它们直接的关系以及设计思路。你也许刚接触这几个概念的时候，有些稀里糊涂，但是通过分析各个对象要解决的问题，可以帮助你更好地掌握它们。</p>
<p>好的，如果你对本节课有什么想法或者疑问，欢迎你在留言区留言，我们一起讨论。</p>
<p>-&ndash; ### 精选评论 ##### **锋： &gt; 这节课讲的非常好，看完又加深了PV/PVC的理解。老师能否给个动态PV绑定到pod的栗子（yaml）呢？ ######     讲师回复： &gt;     官方文档有个例子 <a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-persistent-volume-storage/">https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-persistent-volume-storage/</a> ##### **伟： &gt; StatefulSet 中怎么使用 PV 和 PVC给的样例没有看明白，volumeClaimTemplates的配置是如何和PVC做关联的？ ##### **元： &gt; 假如我创建了10G的PV，已经通过PVC挂载至Pod，用过一段时间后，发现空间不够，需要扩展PV，如何将它扩展至20G？ ######     讲师回复： &gt;     修改pvc的size ##### **星： &gt; 有几个扩容的问题请教一下1、修改PVC后，已绑定的pod是不是不需要修改？2、如果是动态创建pv，修改了PVC以后会不会重新创建一个pv？原来的数据会不会丢失？3、如果是静态创建pv，扩容的时候是不是要同步修改pv和PVC？ ##### **6250： &gt; 挂载在pod内的pvc怎么扩容？</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/kubernetes%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/">Kubernetes原理剖析与实战应用</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%9821%E8%AE%B2/10%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">10案例分析：大对象复用的目标和注意点</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%9E%B6%E6%9E%8430%E8%AE%B2/10%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%E5%92%8C%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E7%BC%A9%E5%87%8Fbundleize%E6%8A%8A%E6%80%A7%E8%83%BD%E5%81%9A%E5%88%B0%E6%9E%81%E8%87%B4/">
            <span class="next-text nav-default">10代码拆分和按需加载：缩减bundleize，把性能做到极致</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
