<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>11K8Service：轻松搞定服务发现和负载均衡 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="经过前面几节课的学习，我们已经可以发布高可用的业务了，通过 PV 持久化地保存数据，通过 Deployment或Statefulset 这类工作负载来管理多实例，从而保证服务的高可用。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kubernetes%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/11k8service%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kubernetes%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/11k8service%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="11K8Service：轻松搞定服务发现和负载均衡">
  <meta property="og:description" content="经过前面几节课的学习，我们已经可以发布高可用的业务了，通过 PV 持久化地保存数据，通过 Deployment或Statefulset 这类工作负载来管理多实例，从而保证服务的高可用。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Kubernetes原理剖析与实战应用">

  <meta itemprop="name" content="11K8Service：轻松搞定服务发现和负载均衡">
  <meta itemprop="description" content="经过前面几节课的学习，我们已经可以发布高可用的业务了，通过 PV 持久化地保存数据，通过 Deployment或Statefulset 这类工作负载来管理多实例，从而保证服务的高可用。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4516">
  <meta itemprop="keywords" content="Kubernetes原理剖析与实战应用">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="11K8Service：轻松搞定服务发现和负载均衡">
  <meta name="twitter:description" content="经过前面几节课的学习，我们已经可以发布高可用的业务了，通过 PV 持久化地保存数据，通过 Deployment或Statefulset 这类工作负载来管理多实例，从而保证服务的高可用。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">11K8Service：轻松搞定服务发现和负载均衡</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4516 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>经过前面几节课的学习，我们已经可以发布高可用的业务了，通过 PV 持久化地保存数据，通过 Deployment或Statefulset 这类工作负载来管理多实例，从而保证服务的高可用。</p>
<p>想一想，这个时候如果有别的应用来访问我们的服务的话，该怎么办呢？直接访问后端的 Pod IP 吗？不，这里我们还需要做服务发现（Service Discovery）。</p>
<p>为什么需要服务发现？</p>
<p>传统的应用部署，服务实例的网络位置是固定的，即在给定的机器上进行部署，这个时候的服务地址一般是机器的 IP 加上某个特定的端口号。</p>
<p>但是在 Kubernetes 中，这是完全不同的。业务都是通过 Pod 来承载的，每个 Pod 的生命周期又很短暂，用后即焚，IP 地址也都是随机分配，动态变化的。而且，我们还经常会遇到一些高并发的流量进来，这时候往往需要快速扩容，服务的实例数也会随之动态调整。因此我们在这里就不能用传统的基于 IP 的方式去访问某个服务了。这个对于所有云上的系统，以及微服务应用体系，都是一个大难题。这时我们就需要做服务发现来确定服务的访问地址。</p>
<p>今天我们就来聊聊 Kubernetes 中的服务发现 —— Service。</p>
<p>Kubernetes 中的 Service</p>
<p>在之前的课程中，我们知道 Deployment、StatefulSet 这类工作负载都是通过 labelSelector 来管理一组 Pod 的。那么 Kubernetes 中的 Service 也采用了同样的做法，如下图。</p>
<p>（https://platform9.com/wp-content/uploads/2019/05/kubernetes-service-discovery.jpg）</p>
<p>这样一个 Service 会选择集群所有 label 中带有
app=nginx
和
env=prod
的 Pod。</p>
<p>我们来看看这样的一个 Service 是如何定义的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ cat nginx-svc.yaml
</span></span><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">kind: Service
</span></span><span class="line"><span class="cl">metadata:  
</span></span><span class="line"><span class="cl">  name: nginx-prod-svc-demo
</span></span><span class="line"><span class="cl">  namespace: demo # service 是 namespace 级别的对象
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">  selector:       # Pod选择器
</span></span><span class="line"><span class="cl">    app: nginx
</span></span><span class="line"><span class="cl">    env: prod
</span></span><span class="line"><span class="cl">  type: ClusterIP # service 的类型
</span></span><span class="line"><span class="cl">  ports:  
</span></span><span class="line"><span class="cl">  - name: http 
</span></span><span class="line"><span class="cl">    port: 80       # service 的端口号
</span></span><span class="line"><span class="cl">    targetPort: 80 # 对应到 Pod 上的端口号
</span></span><span class="line"><span class="cl">    protocol: TCP  # 还支持 udp，http 等
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在我们先来看如下一个 Deployment的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ cat nginx-deploy.yaml
</span></span><span class="line"><span class="cl">apiVersion: apps/v1
</span></span><span class="line"><span class="cl">kind: Deployment
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">  name: nginx-prod-deploy
</span></span><span class="line"><span class="cl">  namespace: demo
</span></span><span class="line"><span class="cl">  labels:
</span></span><span class="line"><span class="cl">    app: nginx
</span></span><span class="line"><span class="cl">    env: prod
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">  replicas: 3
</span></span><span class="line"><span class="cl">  selector:
</span></span><span class="line"><span class="cl">    matchLabels:
</span></span><span class="line"><span class="cl">      app: nginx
</span></span><span class="line"><span class="cl">      env: prod
</span></span><span class="line"><span class="cl">  template:
</span></span><span class="line"><span class="cl">    metadata:
</span></span><span class="line"><span class="cl">      labels:
</span></span><span class="line"><span class="cl">        app: nginx
</span></span><span class="line"><span class="cl">        env: prod
</span></span><span class="line"><span class="cl">    spec:
</span></span><span class="line"><span class="cl">      containers:
</span></span><span class="line"><span class="cl">      - name: nginx
</span></span><span class="line"><span class="cl">        image: nginx:1.14.2
</span></span><span class="line"><span class="cl">        ports:
</span></span><span class="line"><span class="cl">        - containerPort: 80
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们创建好这个 Deployment后，查看其 Pod 状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ kubectl get deploy -n demo
</span></span><span class="line"><span class="cl">NAME                READY   UP-TO-DATE   AVAILABLE   AGE
</span></span><span class="line"><span class="cl">nginx-prod-deploy   3/3     3            3           5s
</span></span><span class="line"><span class="cl">$ kubectl get pod -n demo -o wide
</span></span><span class="line"><span class="cl">NAME                                 READY   STATUS    RESTARTS   AGE   IP          NODE             NOMINATED NODE   READINESS GATES
</span></span><span class="line"><span class="cl">nginx-prod-deploy-6fb6fbb77d-h2gn4   1/1     Running   0          87s   10.1.0.31   docker-desktop   &lt;none&gt;           &lt;none&gt;
</span></span><span class="line"><span class="cl">nginx-prod-deploy-6fb6fbb77d-r78k9   1/1     Running   0          87s   10.1.0.29   docker-desktop   &lt;none&gt;           &lt;none&gt;
</span></span><span class="line"><span class="cl">nginx-prod-deploy-6fb6fbb77d-xm8tp   1/1     Running   0          87s   10.1.0.30   docker-desktop   &lt;none&gt;           &lt;none&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们再来创建下上面定义的 Service：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ kubectl create -f nginx-svc.yaml
</span></span><span class="line"><span class="cl">service/nginx-prod-svc-demo created
</span></span><span class="line"><span class="cl">$ kubectl get svc -n demo
</span></span><span class="line"><span class="cl">NAME                  TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
</span></span><span class="line"><span class="cl">nginx-prod-svc-demo   ClusterIP   10.111.193.186   &lt;none&gt;        80/TCP    6s
</span></span><span class="line"><span class="cl">可以看到，这个 Service 分配到了一个地址为10.111.193.186的 Cluster IP，这是一个虚拟 IP（VIP）地址，集群内所有的 Pod 和 Node 都可以通过这个虚拟 IP 地址加端口的方式来访问该 Service。这个 Service 会根据标签选择器，把匹配到的 Pod 的 IP 地址都挂载到后端。我们使用`kubectl describe`来看看这个 Service：
</span></span><span class="line"><span class="cl">$ kubectl describe svc -n demo nginx-prod-svc-demo
</span></span><span class="line"><span class="cl">Name:              nginx-prod-svc-demo
</span></span><span class="line"><span class="cl">Namespace:         demo
</span></span><span class="line"><span class="cl">Labels:            &lt;none&gt;
</span></span><span class="line"><span class="cl">Annotations:       &lt;none&gt;
</span></span><span class="line"><span class="cl">Selector:          app=nginx,env=prod
</span></span><span class="line"><span class="cl">Type:              ClusterIP
</span></span><span class="line"><span class="cl">IP:                10.111.193.186
</span></span><span class="line"><span class="cl">Port:              http  80/TCP
</span></span><span class="line"><span class="cl">TargetPort:        80/TCP
</span></span><span class="line"><span class="cl">Endpoints:         10.1.0.29:80,10.1.0.30:80,10.1.0.31:80
</span></span><span class="line"><span class="cl">Session Affinity:  None
</span></span><span class="line"><span class="cl">Events:            &lt;none&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，这时候 Service 关联的 Endpoints 里面有三个 IP 地址，和我们上面看到的 Pod IP 地址完全吻合。</p>
<p>我们试着来缩容 Deployment 的副本数，再来看看 Service 关联的 Pod IP 地址有什么变化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ kubectl scale --replicas=2 deploy -n demo nginx-prod-deploy
</span></span><span class="line"><span class="cl">deployment.apps/nginx-prod-deploy scaled
</span></span><span class="line"><span class="cl">$ kubectl get pod -n demo -o wide
</span></span><span class="line"><span class="cl">NAME                                 READY   STATUS    RESTARTS   AGE   IP          NODE             NOMINATED NODE   READINESS GATES
</span></span><span class="line"><span class="cl">nginx-prod-deploy-6fb6fbb77d-r78k9   1/1     Running   0          11m   10.1.0.29   docker-desktop   &lt;none&gt;           &lt;none&gt;
</span></span><span class="line"><span class="cl">nginx-prod-deploy-6fb6fbb77d-xm8tp   1/1     Running   0          11m   10.1.0.30   docker-desktop   &lt;none&gt;           &lt;none&gt;
</span></span><span class="line"><span class="cl">$ kubectl describe svc -n demo nginx-prod-svc-demo
</span></span><span class="line"><span class="cl">Name:              nginx-prod-svc-demo
</span></span><span class="line"><span class="cl">Namespace:         demo
</span></span><span class="line"><span class="cl">Labels:            &lt;none&gt;
</span></span><span class="line"><span class="cl">Annotations:       &lt;none&gt;
</span></span><span class="line"><span class="cl">Selector:          app=nginx,env=prod
</span></span><span class="line"><span class="cl">Type:              ClusterIP
</span></span><span class="line"><span class="cl">IP:                10.111.193.186
</span></span><span class="line"><span class="cl">Port:              http  80/TCP
</span></span><span class="line"><span class="cl">TargetPort:        80/TCP
</span></span><span class="line"><span class="cl">Endpoints:         10.1.0.29:80,10.1.0.30:80
</span></span><span class="line"><span class="cl">Session Affinity:  None
</span></span><span class="line"><span class="cl">Events:            &lt;none&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>可见当 Pod 的生命周期发生变化时，比如缩容或者异常退出，Service 会自动把有问题的 Pod 从后端地址中摘除。这样实现的好处在于，我们可以始终通过一个虚拟的稳定 IP 地址来访问服务，而不用关心其后端真正实例的变化。Kubernetes 中 Service 一共有四种类型，除了上面讲的 ClusterIP，还有 NodePort、LoadBalancer 和 ExternalName。</p>
<p>其中 LoadBalancer 在云上用的较多，使用的时候需要跟各家云厂商做适配，比如部署对应的 cloud-controller-manager。有兴趣的话，可以查看这个文档，看看如何在云上使用。LoadBalancer主要用于做外部的服务发现，即暴露给集群外部的访问。</p>
<p>ExternalName 类型的 Service 在实际中使用的频率不是特别高，但是对于某些特殊场景还是有一些用途的。比如在云上或者内部已经运行着一个应用服务，但是暂时没有运行在 Kubernetes 中，如果想让在 Kubernetes 集群中的 Pod 访问该服务，这时当然可以直接使用它的域名地址，也可以通过 ExternalName 类型的 Service 来解决。这样就可以直接访问 Kubernetes 内部的 Service 了。</p>
<p>这样一来方便后续服务迁移到 Kubernetes 中，二来也方便随时切换到备份的服务上，而不用更改 Pod 内的任何配置。由于使用频率并不高，我们不做重点介绍，有兴趣可以参考这篇文档。</p>
<p>我们最后来看下另外一种 NodePort 类型的 Service：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">kind: Service
</span></span><span class="line"><span class="cl">metadata:  
</span></span><span class="line"><span class="cl">  name: my-nodeport-service
</span></span><span class="line"><span class="cl">  namespace: demo
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">  selector:    
</span></span><span class="line"><span class="cl">    app: my-app
</span></span><span class="line"><span class="cl">  type: NodePort # 这里设置类型为 NodePort
</span></span><span class="line"><span class="cl">  ports:  
</span></span><span class="line"><span class="cl">  - name: http
</span></span><span class="line"><span class="cl">    port: 80
</span></span><span class="line"><span class="cl">    targetPort: 80
</span></span><span class="line"><span class="cl">    nodePort: 30000
</span></span><span class="line"><span class="cl">    protocol: TCP
</span></span></code></pre></td></tr></table>
</div>
</div><p>顾名思义，这种类型的 Service 通过任一 Node 节点的 IP 地址，再加上端口号就可以访问 Service 后端负载了。我们看下面这个流量图，方便理解。</p>
<p>（https://miro.medium.com/max/1680/1*CdyUtG-8CfGu2oFC5s0KwA.png）</p>
<p>NodePort 类型的 Service 创建好了以后，Kubernetes 会在每个 Node 节点上开个端口，比如这里的 30000 端口。这个时候我们可以访问任何一个 Node 的 IP 地址，通过 30000 端口即可访问该服务。</p>
<p>那么如果在集群内部，该如何访问这些 Service 呢？</p>
<p>集群内如何访问 Service？</p>
<p>一般来说，在 Kubernetes 集群内，我们有两种方式可以访问到一个 Service。</p>
<p>如果该 Service 有 ClusterIP，我们就可以直接用这个虚拟 IP 去访问。比如我们上面创建的 nginx-prod-svc-demo 这个 Service，我们通过
kubectl get svc nginx-prod-svc-demo -n dmeo
或
kubectl get svc nginx-prod-svc-demo -n dmeo
就可以看到其 Cluster IP 为 10.111.193.186，端口号为 80。那么我们通过 http(s)://10.111.193.186:80 就可以访问到该服务。</p>
<p>当然我们也可以使用该 Service 的域名，依赖于集群内部的 DNS 即可访问。还是以上面的例子做说明，同 namespace 下的 Pod 可以直接通过 nginx-prod-svc-demo 这个 Service 名去访问。如果是不同 namespace 下的 Pod 则需要加上该 Service 所在的 namespace 名，即
nginx-prod-svc-demo.demo
去访问。</p>
<p>如果在某个 namespace 下，Service 先于 Pod 创建出来，那么 kubelet 在创建 Pod 的时候，会自动把这些 namespace 相同的 Service 访问信息当作环境变量注入 Pod 中，即
{SVCNAME}_SERVICE_HOST
和
{SVCNAME}_SERVICE_PORT
。这里
SVCNAME
对应是各个 Service 的大写名称，名字中的横线会被自动转换成下划线。比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># env
</span></span><span class="line"><span class="cl">KUBERNETES_PORT=tcp://10.96.0.1:443
</span></span><span class="line"><span class="cl">KUBERNETES_SERVICE_PORT=443
</span></span><span class="line"><span class="cl">HOSTNAME=nginx-prod-deploy2-68d8fb9586-4m5hr
</span></span><span class="line"><span class="cl">NGINX_PROD_SVC_DEMO_SERVICE_PORT_HTTP=80
</span></span><span class="line"><span class="cl">NGINX_PROD_SVC_DEMO_SERVICE_HOST=10.111.193.186
</span></span><span class="line"><span class="cl">KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
</span></span><span class="line"><span class="cl">NGINX_PROD_SVC_DEMO_SERVICE_PORT=80
</span></span><span class="line"><span class="cl">NGINX_PROD_SVC_DEMO_PORT=tcp://10.111.193.186:80
</span></span><span class="line"><span class="cl">KUBERNETES_PORT_443_TCP_PORT=443
</span></span><span class="line"><span class="cl">KUBERNETES_PORT_443_TCP_PROTO=tcp
</span></span><span class="line"><span class="cl">NGINX_PROD_SVC_DEMO_PORT_80_TCP_ADDR=10.111.193.186
</span></span><span class="line"><span class="cl">NGINX_PROD_SVC_DEMO_PORT_80_TCP_PORT=80
</span></span><span class="line"><span class="cl">NGINX_PROD_SVC_DEMO_PORT_80_TCP_PROTO=tcp
</span></span><span class="line"><span class="cl">KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
</span></span><span class="line"><span class="cl">KUBERNETES_SERVICE_PORT_HTTPS=443
</span></span><span class="line"><span class="cl">KUBERNETES_SERVICE_HOST=10.96.0.1
</span></span><span class="line"><span class="cl">NGINX_PROD_SVC_DEMO_PORT_80_TCP=tcp://10.111.193.186:80
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>知道了这两种访问方式，我们就可以在启动 Pod 的时候，通过注入环境变量、启动参数或者挂载配置文件等方式，来指定要访问的 Service 信息。如果是同 namespace 的 Pod，可以直接从自己的环境变量中知道同 namespace 下的其他 Service 的访问方式。</p>
<p>那么这样通过该 Service 进行访问时，Kubernetes 又是如何实现负载均衡的呢，即将流量打到后端挂载的各个 Pod 上面去？</p>
<p>集群内部的负载均衡如何实现？</p>
<p>这一切都是通过 kube-proxy 来实现的。所有的节点上都会运行着一个 kube-proxy的服务，主要监听 Kubernetes 中的 Service 和 Endpoints。当 Service 或 Endpoints 发生变化时，就会调用相应的接口创建对应的规则出来，常用模式主要是 iptables 模式和 IPVS 模式。iptables 模式比较简单，使用起来也方便。而 IPVS 支持更高的吞吐量以及复杂的负载均衡策略，你可以通过官方文档了解更多 IPVS 模式的工作原理。</p>
<p>目前 kube-proxy 默认的工作方式是 iptables 模式，我们来通过如下一个 iptables 模式的例子来看一下实际访问链路是什么样的。</p>
<p>（https://d33wubrfki0l68.cloudfront.net/27b2978647a8d7bdc2a96b213f0c0d3242ef9ce0/e8c9b/images/docs/services-iptables-overview.svg）</p>
<p>当你通过 Service 的域名去访问时，会先通过 CoreDNS 解析出 Service 对应的 Cluster IP，即虚拟 IP。然后请求到达宿主机的网络后，就会被kube-proxy所配置的 iptables 规则所拦截，之后请求会被转发到每一个实际的后端 Pod 上面去，这样就实现了负载均衡。</p>
<p>Headless Service</p>
<p>如果我们在定义 Service 的时候，将spec.clusterIP设置为 None，这个时候创建出来的 Service 并不会分配到一个 Cluster IP，此时它就被称为Headless Service。</p>
<p>现在我们来通过一个例子来看看 Headless Service 有什么特殊的地方。我们在上面的 Service 基础上，增加了spec.clusterIP为None，并命名为nginx-prod-demo-headless-svc：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">kind: Service
</span></span><span class="line"><span class="cl">metadata:  
</span></span><span class="line"><span class="cl">  name: nginx-prod-demo-headless-svc
</span></span><span class="line"><span class="cl">  namespace: demo 
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">  clusterIP: None
</span></span><span class="line"><span class="cl">  selector: 
</span></span><span class="line"><span class="cl">    app: nginx
</span></span><span class="line"><span class="cl">    env: prod
</span></span><span class="line"><span class="cl">  type: ClusterIP
</span></span><span class="line"><span class="cl">  ports:  
</span></span><span class="line"><span class="cl">  - name: http 
</span></span><span class="line"><span class="cl">    port: 80 
</span></span><span class="line"><span class="cl">    targetPort: 80 
</span></span><span class="line"><span class="cl">    protocol: TCP 
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 kubectl 创建成功后，我们现在
kubectl get
一下看看：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ kubectl get svc -n demo
</span></span><span class="line"><span class="cl">NAME                           TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
</span></span><span class="line"><span class="cl">nginx-prod-demo-headless-svc   ClusterIP   None             &lt;none&gt;        80/TCP    4s
</span></span><span class="line"><span class="cl">nginx-prod-svc-demo            ClusterIP   10.111.193.186   &lt;none&gt;        80/TCP    3d5h
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到这个叫 nginx-prod-demo-headless-svc 的 Service 并没有分配到一个 ClusterIP，符合预期，毕竟我们已经设置了 spec.clusterIP 为 None。</p>
<p>我们来创建一个 Pod，看看 DNS 记录有没有什么差别。 Pod 的 yaml 文件如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">kind: Pod
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">  name: headless-svc-test-pod
</span></span><span class="line"><span class="cl">  namespace: demo
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">  containers:
</span></span><span class="line"><span class="cl">  - name: dns-test
</span></span><span class="line"><span class="cl">    image: busybox:1.28
</span></span><span class="line"><span class="cl">    command: [&#39;sh&#39;, &#39;-c&#39;, &#39;echo The app is running! &amp;&amp; sleep 3600&#39;]
</span></span></code></pre></td></tr></table>
</div>
</div><p>该 Pod 创建出来后，我们通过
kubectl exec
进入 Pod 中，运行如下两条 nslookup 查询命令，依次查看两个 Service 对应的 DNS 记录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ kubectl exec -it -n demo headless-svc-test-pod sh
</span></span><span class="line"><span class="cl">kubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl kubectl exec [POD] -- [COMMAND] instead.
</span></span><span class="line"><span class="cl">/ # nslookup nginx-prod-demo-headless-svc
</span></span><span class="line"><span class="cl">Server:    10.96.0.10
</span></span><span class="line"><span class="cl">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Name:      nginx-prod-demo-headless-svc
</span></span><span class="line"><span class="cl">Address 1: 10.1.0.32 10-1-0-32.nginx-prod-demo-headless-svc.demo.svc.cluster.local
</span></span><span class="line"><span class="cl">Address 2: 10.1.0.33 10-1-0-33.nginx-prod-demo-headless-svc.demo.svc.cluster.local
</span></span><span class="line"><span class="cl">/ # nslookup nginx-prod-svc-demo
</span></span><span class="line"><span class="cl">Server:    10.96.0.10
</span></span><span class="line"><span class="cl">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Name:      nginx-prod-svc-demo
</span></span><span class="line"><span class="cl">Address 1: 10.111.193.186 nginx-prod-svc-demo.demo.svc.cluster.local
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以看到正常 Service
nginx-prod-svc-demo
对应的 DNS 记录的是与虚拟 IP
10.111.193.166
有关的记录，而 Headless Service
nginx-prod-demo-headless-svc
则解析到所有后端的 Pod 的地址。总结下， Headless Service 主要有如下两种场景。</p>
<p>用户可以自己选择要连接哪个 Pod，通过查询 Service 的 DNS 记录来获取后端真实负载的 IP 地址，自主选择要连接哪个 IP；</p>
<p>可用于部署有状态服务。回顾下，我们在 StatefulSet 那节课也有 Headless Service 例子，每个 StatefulSet 管理的 Pod 都有一个单独的 DNS 记录，且域名保持不变，即
<PodName>.<ServiceName>.<NamespaceName>.svc.cluster.local
。这样 Statefulset 中的各个 Pod 就可以直接通过 Pod 名字解决相互间身份以及访问问题。</p>
<p>写在最后</p>
<p>Service 是 Kubernetes 很重要的对象，主要负责为各种工作负载暴露服务，方便各个服务之间互访。通过对一组 Pod 提供统一入口，Service 极大地方便了用户使用，用户只需要与 Service 打交道即可，而不用过多地关心后端实例的变动，比如扩缩容、容器异常、节点宕机，等等。</p>
<p>正是因为有了 Service 的支持，你在 Kubernetes 部署业务会非常方便，这是相比较于 Docker Swarm 以及 Mesos Marathon 巨大的技术优势，可以说，它是 Kubernetes 是运行大规模微服务的最佳载体。</p>
<p>好的，如果你对本节课有什么想法或者疑问，欢迎你在留言区留言，我们一起讨论。</p>
<p>-&ndash; ### 精选评论 ##### *星： &gt; 请教下老师，服务A使用nodeport访问，服务B使用host模式，如何访问，宿主的ip不是固定的 ######     讲师回复： &gt;     nodeport的话，可以通过任一宿主机ip+port 的方式来访问。所以服务A 和服务B可以通过任一宿主机ip来访问。 ##### *悦： &gt; apiVersion: v1kind: Podmetadata: name: headless-svc-test-pod namespace: demospec: containers: - name: dns-test image: busybox:1.28 sleep 3600&rsquo;]这个怎么和headless server 匹配麻烦老师说下 ##### *悦： &gt; apiVersion: v1kind: Servicemetadata: name: nginx-prod-demo-headless-svcspec: clusterIP: None app: nginx env: prod type: ClusterIP——pod怎么匹配的 pod没有labels标签怎么匹配 ##### **彬： &gt; 老师，你好，请教一下，配置clusterip时，通过coredns解析到虚拟IP，请求是怎么转发到宿主机上的 ######     讲师回复： &gt;     这部分官方文档讲解的比较清楚，还是图。https://kubernetes.io/zh/docs/concepts/services-networking/service/#proxy-mode-iptables</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/kubernetes%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/">Kubernetes原理剖析与实战应用</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/ai%E6%8A%80%E6%9C%AF%E5%86%85%E5%8F%82/119%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%B6%E5%BF%85%E5%A4%87%E5%A5%97%E8%B7%AF%E4%B9%8B%E4%B8%80%E6%90%9C%E7%B4%A2%E5%A5%97%E8%B7%AF/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">119数据科学家必备套路之一搜索套路</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%9E%B6%E6%9E%8430%E8%AE%B2/11treeshaking%E7%A7%BB%E9%99%A4javascript%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%9A%84%E6%9C%AA%E5%BC%95%E7%94%A8%E4%BB%A3%E7%A0%81/">
            <span class="next-text nav-default">11TreeShaking：移除JavaScript上下文中的未引用代码</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
