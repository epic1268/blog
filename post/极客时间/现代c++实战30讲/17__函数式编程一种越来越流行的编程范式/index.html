<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>17__函数式编程：一种越来越流行的编程范式 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是吴咏炜。
上一讲我们初步介绍了函数对象和 lambda 表达式，今天我们来讲讲它们的主要用途——函数式编程。
一个小例子 按惯例，我们还是从一个例子开始。想一下，如果给定一组文件名，要求数一下文件里的总文本行数，你会怎么做？
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/17__%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%80%E7%A7%8D%E8%B6%8A%E6%9D%A5%E8%B6%8A%E6%B5%81%E8%A1%8C%E7%9A%84%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/17__%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%80%E7%A7%8D%E8%B6%8A%E6%9D%A5%E8%B6%8A%E6%B5%81%E8%A1%8C%E7%9A%84%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="17__函数式编程：一种越来越流行的编程范式">
  <meta property="og:description" content="你好，我是吴咏炜。
上一讲我们初步介绍了函数对象和 lambda 表达式，今天我们来讲讲它们的主要用途——函数式编程。
一个小例子 按惯例，我们还是从一个例子开始。想一下，如果给定一组文件名，要求数一下文件里的总文本行数，你会怎么做？">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="现代C&#43;&#43;实战30讲">

  <meta itemprop="name" content="17__函数式编程：一种越来越流行的编程范式">
  <meta itemprop="description" content="你好，我是吴咏炜。
上一讲我们初步介绍了函数对象和 lambda 表达式，今天我们来讲讲它们的主要用途——函数式编程。
一个小例子 按惯例，我们还是从一个例子开始。想一下，如果给定一组文件名，要求数一下文件里的总文本行数，你会怎么做？">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4789">
  <meta itemprop="keywords" content="现代C&#43;&#43;实战30讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="17__函数式编程：一种越来越流行的编程范式">
  <meta name="twitter:description" content="你好，我是吴咏炜。
上一讲我们初步介绍了函数对象和 lambda 表达式，今天我们来讲讲它们的主要用途——函数式编程。
一个小例子 按惯例，我们还是从一个例子开始。想一下，如果给定一组文件名，要求数一下文件里的总文本行数，你会怎么做？">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">17__函数式编程：一种越来越流行的编程范式</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4789 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#一个小例子">一个小例子</a></li>
        <li><a href="#函数式编程的特点">函数式编程的特点</a>
          <ul>
            <li><a href="#高阶函数">高阶函数</a></li>
            <li><a href="#命令式编程和说明式编程">命令式编程和说明式编程</a></li>
            <li><a href="#不可变性和并发">不可变性和并发</a></li>
          </ul>
        </li>
        <li><a href="#y-组合子">Y 组合子</a></li>
        <li><a href="#内容小结">内容小结</a></li>
        <li><a href="#课后思考">课后思考</a></li>
        <li><a href="#参考资料">参考资料</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是吴咏炜。</p>
<p>上一讲我们初步介绍了函数对象和 lambda 表达式，今天我们来讲讲它们的主要用途——函数式编程。</p>
<h2 id="一个小例子">一个小例子</h2>
<p>按惯例，我们还是从一个例子开始。想一下，如果给定一组文件名，要求数一下文件里的总文本行数，你会怎么做？</p>
<p>我们先规定一下函数的原型：</p>
<p>int count_lines(const char** begin,<br>
const char** end);</p>
<p>也就是说，我们期待接受两个 C 字符串的迭代器，用来遍历所有的文件名；返回值代表文件中的总行数。</p>
<p>要测试行为是否正常，我们需要一个很小的 <code>main</code> 函数：</p>
<p>int main(int argc,<br>
const char** argv)<br>
{<br>
int total_lines = count_lines(<br>
argv + 1, argv + argc);<br>
cout &laquo; &ldquo;Total lines: &quot;<br>
&laquo; total_lines &laquo; endl;<br>
}</p>
<p>最传统的命令式编程大概会这样写代码：</p>
<p>int count_file(const char* name)<br>
{<br>
int count = 0;<br>
ifstream ifs(name);<br>
string line;<br>
for (;;) {<br>
getline(ifs, line);<br>
if (!ifs) {<br>
break;<br>
}<br>
++count;<br>
}<br>
return count;<br>
}</p>
<p>int count_lines(const char** begin,<br>
const char** end)<br>
{<br>
int count = 0;<br>
for (; begin != end; ++begin) {<br>
count += count_file(*begin);<br>
}<br>
return count;<br>
}</p>
<p>我们马上可以做一个简单的“说明式”改造。用 <code>istream_line_reader</code> 可以简化 <code>count_file</code> 成：</p>
<p>int count_file(const char* name)<br>
{<br>
int count = 0;<br>
ifstream ifs(name);<br>
for (auto&amp;&amp; line :<br>
istream_line_reader(ifs)) {<br>
++count;<br>
}<br>
return count;<br>
}</p>
<p>在这儿，要请你停一下，想一想如何进一步优化这个代码。然后再继续进行往下看。</p>
<p>如果我们使用之前已经出场过的两个函数，<code>transform</code> [1] 和 <code>accumulate</code> [2]，代码可以进一步简化为：</p>
<p>int count_file(const char* name)<br>
{<br>
ifstream ifs(name);<br>
istream_line_reader reader(ifs);<br>
return distance(reader.begin(),<br>
reader.end());<br>
}</p>
<p>int count_lines(const char** begin,<br>
const char** end)<br>
{<br>
vector<int> count(end - begin);<br>
transform(begin, end,<br>
count.begin(),<br>
count_file);<br>
return accumulate(<br>
count.begin(), count.end(),<br>
0);<br>
}</p>
<p>这个就是一个非常函数式风格的结果了。上面这个处理方式恰恰就是 map-reduce。<code>transform</code> 对应 map，<code>accumulate</code> 对应 reduce。而检查有多少行文本，也成了代表文件头尾两个迭代器之间的“距离”（distance）。</p>
<h2 id="函数式编程的特点">函数式编程的特点</h2>
<p>在我们的代码里不那么明显的一点是，函数式编程期望函数的行为像数学上的函数，而非一个计算机上的子程序。这样的函数一般被称为纯函数（pure function），要点在于：</p>
<ol>
<li>会影响函数结果的只是函数的参数，没有对环境的依赖</li>
<li>返回的结果就是函数执行的唯一后果，不产生对环境的其他影响</li>
</ol>
<p>这样的代码的最大好处是易于理解和易于推理，在很多情况下也会使代码更简单。在我们上面的代码里，<code>count_file</code> 和 <code>accumulate</code> 基本上可以看做是纯函数（虽然前者实际上有着对文件系统的依赖），但 <code>transform</code> 不行，因为它改变了某个参数，而不是返回一个结果。下一讲我们会看到，这会影响代码的组合性。</p>
<p>我们的代码中也体现了其他一些函数式编程的特点：</p>
<ol>
<li>函数就像普通的对象一样被传递、使用和返回。</li>
<li>代码为说明式而非命令式。在熟悉函数式编程的基本范式后，你会发现说明式代码的可读性通常比命令式要高，代码还短。</li>
<li>一般不鼓励（甚至完全不使用）可变量。上面代码里只有 <code>count</code> 的内容在执行过程中被修改了，而且这种修改实际是 <code>transform</code> 接口带来的。如果接口像 [第 13 讲] 展示的 <code>fmap</code> 函数一样返回一个容器的话，就可以连这个问题都消除了。（C++ 毕竟不是一门函数式编程语言，对灵活性的追求压倒了其他考虑。）</li>
</ol>
<h3 id="高阶函数">高阶函数</h3>
<p>既然函数（对象）可以被传递、使用和返回，自然就有函数会接受函数作为参数或者把函数作为返回值，这样的函数就被称为高阶函数。我们现在已经见过不少高阶函数了，如：</p>
<ol>
<li>sort</li>
<li>transform</li>
<li>accumulate</li>
<li>fmap</li>
<li>adder</li>
</ol>
<p>事实上，C++ 里以 algorithm（算法）[3] 名义提供的很多函数都是高阶函数。</p>
<p>许多高阶函数在函数式编程中已成为基本的惯用法，在不同语言中都会出现，虽然可能是以不同的名字。我们在此介绍非常常见的三个，map（映射）、reduce（归并）和 filter（过滤）。</p>
<p>Map 在 C++ 中的直接映射是 <code>transform</code>（在 <algorithm> 头文件中提供）。它所做的事情也是数学上的映射，把一个范围里的对象转换成相同数量的另外一些对象。这个函数的基本实现非常简单，但这是一种强大的抽象，在很多场合都用得上。</p>
<p>Reduce 在 C++ 中的直接映射是 <code>accumulate</code>（在 <numeric> 头文件中提供）。它的功能是在指定的范围里，使用给定的初值和函数对象，从左到右对数值进行归并。在不提供函数对象作为第四个参数时，功能上相当于默认提供了加法函数对象，这时相当于做累加；提供了其他函数对象时，那当然就是使用该函数对象进行归并了。</p>
<p>Filter 的功能是进行过滤，筛选出符合条件的成员。它在当前 C++（C++20 之前）里的映射可以认为有两个：<code>copy_if</code> 和 <code>partition</code>。这是因为在 C++20 带来 ranges 之前，在 C++ 里实现惰性求值不太方便。上面说的两个函数里，<code>copy_if</code> 是把满足条件的元素拷贝到另外一个迭代器里；<code>partition</code> 则是根据过滤条件来对范围里的元素进行分组，把满足条件的放在返回值迭代器的前面。另外，<code>remove_if</code> 也有点相近，通常用于删除满足条件的元素。它确保把不满足条件的元素放在返回值迭代器的前面（但不保证满足条件的元素在函数返回后一定存在），然后你一般需要使用容器的 <code>erase</code> 成员函数来将待删除的元素真正删除。</p>
<h3 id="命令式编程和说明式编程">命令式编程和说明式编程</h3>
<p>传统上 C++ 属于命令式编程。命令式编程里，代码会描述程序的具体执行步骤。好处是代码显得比较直截了当；缺点就是容易让人只见树木、不见森林，只能看到代码啰嗦地怎么做（how），而不是做什么（what），更不用说为什么（why）了。</p>
<p>说明式编程则相反。以数据库查询语言 SQL 为例，SQL 描述的是类似于下面的操作：你想从什么地方（from）选择（select）满足什么条件（where）的什么数据，并可选指定排序（order by）或分组（group by）条件。你不需要告诉数据库引擎具体该如何去执行这个操作。事实上，在选择查询策略上，大部分数据库用户都不及数据库引擎“聪明”；正如大部分开发者在写出优化汇编代码上也不及编译器聪明一样。</p>
<p>这并不是说说明式编程一定就优于命令式编程。事实上，对于很多算法，命令式才是最自然的实现。以快速排序为例，很多地方在讲到函数式编程时会给出下面这个 Haskell（一种纯函数式的编程语言）的例子来说明函数式编程的简洁性：</p>
<p>quicksort []     = []<br>
quicksort (p:xs) = (quicksort left)<br>
++ [p] ++ (quicksort right)<br>
where<br>
left  = filter (&lt; p) xs<br>
right = filter (&gt;= p) xs</p>
<p>这段代码简洁性确实没话说，但问题是，上面的代码的性能其实非常糟糕。真正接近 C++ 性能的快速排序，在 Haskell 里写出来一点不优雅，反而更丑陋 [4]。</p>
<p>所以，我个人认为，说明式编程跟命令式编程可以结合起来产生既优雅又高效的代码。对于从命令式编程成长起来的大部分程序员，我的建议是：</p>
<ol>
<li>写表意的代码，不要过于专注性能而让代码难以维护——记住高德纳的名言：“过早优化是万恶之源。”</li>
<li>使用有意义的变量，但尽量不要去修改变量内容——变量的修改非常容易导致程序员的思维错误。</li>
<li>类似地，尽量使用没有副作用的函数，并让你写的代码也尽量没有副作用，用返回值来代表状态的变化——没有副作用的代码更容易推理，更不容易出错。</li>
<li>代码的隐式依赖越少越好，尤其是不要使用全局变量——隐式依赖会让代码里的错误难以排查，也会让代码更难以测试。</li>
<li>使用知名的高级编程结构，如基于范围的 for 循环、映射、归并、过滤——这可以让你的代码更简洁，更易于推理，并减少类似下标越界这种低级错误的可能性。</li>
</ol>
<p>这些跟函数式编程有什么关系呢？——这些差不多都是来自函数式编程的最佳实践。学习函数式编程，也是为了更好地体会如何从这些地方入手，写出易读而又高性能的代码。</p>
<h3 id="不可变性和并发">不可变性和并发</h3>
<p>在多核的时代里，函数式编程比以前更受青睐，一个重要的原因是函数式编程对并行并发天然友好。影响多核性能的一个重要因素是数据的竞争条件——由于共享内存数据需要加锁带来的延迟。函数式编程强调不可变性（immutability）、无副作用，天然就适合并发。更妙的是，如果你使用高层抽象的话，有时可以轻轻松松“免费”得到性能提升。</p>
<p>拿我们这一讲开头的例子来说，对代码做下面的改造，启用 C++17 的并行执行策略 [5]，就能自动获得在多核环境下的性能提升：</p>
<p>int count_lines(const char** begin,<br>
const char** end)<br>
{<br>
vector<int> count(end - begin);<br>
transform(execution::par,<br>
begin, end,<br>
count.begin(),<br>
count_file);<br>
return reduce(<br>
execution::par,<br>
count.begin(), count.end());<br>
}</p>
<p>我们可以看到，两个高阶函数的调用中都加入了 <code>execution::par</code>，来启动自动并行计算。要注意的是，我把 <code>accumulate</code> 换成了 <code>reduce</code> [6]，原因是前者已经定义成从左到右的归并，无法并行。<code>reduce</code> 则不同，初始值可以省略，操作上没有规定顺序，并反过来要求对元素的归并操作满足交换律和结合率（加法当然是满足的），即：</p>
<p>A ⊗ B(A ⊗ B) ⊗ C​=B ⊗ A=A ⊗ (B ⊗ C)​</p>
<p>当然，在这个例子里，一般我们不会有海量文件，即使有海量文件，并行读取性能一般也不会快于顺序读取，所以意义并不是很大。下面这个简单的例子展示了并行 <code>reduce</code> 的威力：</p>
<p>#include <chrono><br>
#include <execution><br>
#include <iostream><br>
#include <numeric><br>
#include <vector></p>
<p>using namespace std;</p>
<p>int main()<br>
{<br>
vector<double> v(10000000, 0.0625);</p>
<p>{<br>
auto t1 = chrono::<br>
high_resolution_clock::now();<br>
double result = accumulate(<br>
v.begin(), v.end(), 0.0);<br>
auto t2 = chrono::<br>
high_resolution_clock::now();<br>
chrono::duration&lt;double, milli&gt;<br>
ms = t2 - t1;<br>
cout &laquo; &ldquo;accumulate: result &quot;<br>
&laquo; result &laquo; &quot; took &quot;<br>
&laquo; ms.count() &laquo; &quot; ms\n&rdquo;;<br>
}</p>
<p>{<br>
auto t1 = chrono::<br>
high_resolution_clock::now();<br>
double result =<br>
reduce(execution::par,<br>
v.begin(), v.end());<br>
auto t2 = chrono::<br>
high_resolution_clock::now();<br>
chrono::duration&lt;double, milli&gt;<br>
ms = t2 - t1;<br>
cout &laquo; &ldquo;reduce:     result &quot;<br>
&laquo; result &laquo; &quot; took &quot;<br>
&laquo; ms.count() &laquo; &quot; ms\n&rdquo;;<br>
}<br>
}</p>
<p>在我的电脑（Core i7 四核八线程）上的某次执行结果是：</p>
<blockquote>
<p><code>accumulate: result 625000 took 26.122 ms</code></p>
<p><code>reduce: result 625000 took 4.485 ms</code></p>
</blockquote>
<p>执行策略还比较新，还没有被所有编译器支持。我目前测试下来，MSVC 没有问题，Clang 不行，GCC 需要外部库 TBB（Threading Building Blocks）[7] 的帮助。我上面是用 GCC 编译的，命令行是：</p>
<blockquote>
<p><code>g++-9 -std=c++17 -O3 test.cpp -ltbb</code></p>
</blockquote>
<h2 id="y-组合子">Y 组合子</h2>
<p>限于篇幅，这一讲我们只是很初浅地探讨了函数式编程。对于 C++ 的函数式编程的深入探讨是有整本书的（见参考资料 [8]），而今天讲的内容在书的最前面几章就覆盖完了。在后面，我们还会探讨部分的函数式编程话题；今天我们只再讨论一个有点有趣、也有点烧脑的话题，Y 组合子 [9]。第一次阅读的时候，如果觉得困难，可以跳过这一部分。</p>
<p>不过，我并不打算讨论 Haskell Curry 使用的 Y 组合子定义——这个比较复杂，需要写一篇完整的文章来讨论（[10]），而且在 C++ 中的实用性非常弱。我们只看它解决的问题：如何在 lambda 表达式中表现递归。</p>
<p>回想一下我们用过的阶乘的递归定义：</p>
<p>int factorial(int n)<br>
{<br>
if (n == 0) {<br>
return 1;<br>
} else {<br>
return n * factorial(n - 1);<br>
}<br>
}</p>
<p>注意里面用到了递归，所以你要把它写成 lambda 表达式是有点困难的：</p>
<p>auto factorial = <a href="./int_n.md"></a> {<br>
if (n == 0) {<br>
return 1;<br>
} else {<br>
return n * ???(n - 1);<br>
}<br>
}</p>
<p>下面我们讨论使用 Y 组合子的解决方案。</p>
<p>我们首先需要一个特殊的高阶函数，定义为：</p>
<p>y(f)=f(y(f))</p>
<p>显然，这个定义有点奇怪。事实上，它是会导致无限展开的——而它的威力也在于无限展开。我们也因此必须使用惰性求值的方式才能使用这个定义。</p>
<p>然后，我们定义阶乘为：</p>
<p>fact(n)=If IsZero(n) then 1 else n×fact(n−1)</p>
<p>假设 fact 可以表示成 y(F)，那我们可以做下面的变形：</p>
<p>y(F)(n)F(y(F))(n)​=If IsZero(n) then 1 else n×y(F)(n−1)=If IsZero(n) then 1 else n×y(F)(n−1)​</p>
<p>再把 y(F) 替换成 f，我们从上面的第二个式子得到：</p>
<p>F(f)(n)=If IsZero(n) then 1 else n×f(n−1)</p>
<p>我们得到了 F 的定义，也就自然得到了 fact 的定义。而且，这个定义是可以用 C++ 表达出来的。下面是完整的代码实现：</p>
<p>#include <functional><br>
#include <iostream><br>
#include &lt;type_traits&gt;<br>
#include <utility></p>
<p>using namespace std;</p>
<p>// Y combinator as presented by Yegor Derevenets in P0200R0<br>
// <a href="url:http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html">url:http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html</a><br>
template <class Fun><br>
class y_combinator_result {<br>
Fun fun_;<br>
public:<br>
template <class T><br>
explicit y_combinator_result(<br>
T&amp;&amp; fun)<br>
: fun_(std::forward<T>(fun))<br>
{<br>
}</p>
<p>template &lt;class&hellip; Args&gt;<br>
decltype(auto)<br>
operator()(Args&amp;&amp;&hellip; args)<br>
{<br>
// y(f) = f(y(f))<br>
return fun_(<br>
std::ref(*this),<br>
std::forward<Args>(args)&hellip;);<br>
}<br>
};</p>
<p>template <class Fun><br>
decltype(auto)<br>
y_combinator(Fun&amp;&amp; fun)<br>
{<br>
return y_combinator_result&lt;<br>
std::decay_t<Fun>&gt;(<br>
std::forward<Fun>(fun));<br>
}</p>
<p>int main()<br>
{<br>
//  上面的那个  F<br>
auto almost_fact =<br>
<a href="./auto_f,_int_n.md"></a> -&gt; int {<br>
if (n == 0)<br>
return 1;<br>
else<br>
return n * f(n - 1);<br>
};<br>
// fact = y(F)<br>
auto fact =<br>
y_combinator(almost_fact);<br>
cout &laquo; fact(10) &laquo; endl;<br>
}</p>
<p>这一节不影响后面的内容，看不懂的可以暂时略过。😝</p>
<h2 id="内容小结">内容小结</h2>
<p>本讲我们对函数式编程进行了一个入门式的介绍，希望你对函数式编程的特点、优缺点有了一个初步的了解。然后，我快速讨论了一个会烧脑的话题，Y 组合子，让你对函数式编程的威力和难度也有所了解。</p>
<h2 id="课后思考">课后思考</h2>
<p>想一想，你如何可以实现一个惰性的过滤器？一个惰性的过滤器应当让下面的代码通过编译，并且不会占用跟数据集大小相关的额外空间：</p>
<p>#include <iostream><br>
#include <numeric><br>
#include <vector></p>
<p>using namespace std;</p>
<p>// filter_view  的定义</p>
<p>int main()<br>
{<br>
vector v{1, 2, 3, 4, 5};<br>
auto&amp;&amp; fv = filter_view(<br>
v.begin(), v.end(), <a href="./int_x.md"></a> {<br>
return x % 2 == 0;<br>
});<br>
cout &laquo; accumulate(fv.begin(),<br>
fv.end(), 0)<br>
&laquo; endl;<br>
}</p>
<p>结果输出应该是 <code>6</code>。</p>
<p>**提示：**参考 <code>istream_line_reader</code> 的实现。</p>
<p>告诉我你是否成功了，或者你遇到了什么样的特别困难。</p>
<h2 id="参考资料">参考资料</h2>
<p>[1] cppreference.com, “std::transform”. <a href="https://en.cppreference.com/w/cpp/algorithm/transform">https://en.cppreference.com/w/cpp/algorithm/transform</a></p>
<p>[1a] cppreference.com, “std::transform”. <a href="https://zh.cppreference.com/w/cpp/algorithm/transform">https://zh.cppreference.com/w/cpp/algorithm/transform</a></p>
<p>[2] cppreference.com, “std::accumulate”. <a href="https://en.cppreference.com/w/cpp/algorithm/accumulate">https://en.cppreference.com/w/cpp/algorithm/accumulate</a></p>
<p>[2a] cppreference.com, “std::accumulate”. <a href="https://zh.cppreference.com/w/cpp/algorithm/accumulate">https://zh.cppreference.com/w/cpp/algorithm/accumulate</a></p>
<p>[3] cppreference.com, “Standard library header <algorithm>”. <a href="https://en.cppreference.com/w/cpp/header/algorithm">https://en.cppreference.com/w/cpp/header/algorithm</a></p>
<p>[3a] cppreference.com, “标准库头文件 <algorithm>”. <a href="https://zh.cppreference.com/w/cpp/header/algorithm">https://zh.cppreference.com/w/cpp/header/algorithm</a></p>
<p>[4] 袁英杰，“Immutability: The Dark Side”. <a href="https://www.jianshu.com/p/13cd4c650125">https://www.jianshu.com/p/13cd4c650125</a></p>
<p>[5] cppreference.com, “Standard library header <execution>”. <a href="https://en.cppreference.com/w/cpp/header/execution">https://en.cppreference.com/w/cpp/header/execution</a></p>
<p>[5a] cppreference.com, “标准库头文件 <execution>”. <a href="https://zh.cppreference.com/w/cpp/header/execution">https://zh.cppreference.com/w/cpp/header/execution</a></p>
<p>[6] cppreference.com, “std::reduce”. <a href="https://en.cppreference.com/w/cpp/algorithm/reduce">https://en.cppreference.com/w/cpp/algorithm/reduce</a></p>
<p>[6a] cppreference.com, “std::reduce”. <a href="https://zh.cppreference.com/w/cpp/algorithm/reduce">https://zh.cppreference.com/w/cpp/algorithm/reduce</a></p>
<p>[7] Intel, tbb. <a href="https://github.com/intel/tbb">https://github.com/intel/tbb</a></p>
<p>[8] Ivan Čukić, Functional Programming in C++. Manning, 2019, <a href="https://www.manning.com/books/functional-programming-in-c-plus-plus">https://www.manning.com/books/functional-programming-in-c-plus-plus</a></p>
<p>[9] Wikipedia, “Fixed-point combinator”. <a href="https://en.wikipedia.org/wiki/Fixed-point">https://en.wikipedia.org/wiki/Fixed-point</a>_combinator</p>
<p>[10] 吴咏炜，“Y Combinator and C++”. <a href="https://yongweiwu.wordpress.com/2014/12/14/y-combinator-and-cplusplus/">https://yongweiwu.wordpress.com/2014/12/14/y-combinator-and-cplusplus/</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/">现代C&#43;&#43;实战30讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%BE%8E/17__%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8D%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%80%8E%E4%B9%88%E5%86%99%E5%87%BD%E6%95%B0%E5%BC%8F%E7%9A%84%E7%A8%8B%E5%BA%8F/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">17__函数式编程：不用函数式编程语言，怎么写函数式的程序？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/17__%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E4%B8%8B/">
            <span class="next-text nav-default">17__即时编译（下）</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
