<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>02__自己动手，实现C&#43;&#43;的智能指针 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是吴咏炜。
上一讲，我们描述了一个某种程度上可以当成智能指针用的类 shape_wrapper。使用那个智能指针，可以简化资源的管理，从根本上消除资源（包括内存）泄漏的可能性。这一讲我们就来进一步讲解，如何将 shape_wrapper 改造成一个完整的智能指针。你会看到，智能指针本质上并不神秘，其实就是 RAII 资源管理功能的自然展现而已。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/02__%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0c&#43;&#43;%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/02__%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0c&#43;&#43;%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="02__自己动手，实现C&#43;&#43;的智能指针">
  <meta property="og:description" content="你好，我是吴咏炜。
上一讲，我们描述了一个某种程度上可以当成智能指针用的类 shape_wrapper。使用那个智能指针，可以简化资源的管理，从根本上消除资源（包括内存）泄漏的可能性。这一讲我们就来进一步讲解，如何将 shape_wrapper 改造成一个完整的智能指针。你会看到，智能指针本质上并不神秘，其实就是 RAII 资源管理功能的自然展现而已。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="现代C&#43;&#43;实战30讲">

  <meta itemprop="name" content="02__自己动手，实现C&#43;&#43;的智能指针">
  <meta itemprop="description" content="你好，我是吴咏炜。
上一讲，我们描述了一个某种程度上可以当成智能指针用的类 shape_wrapper。使用那个智能指针，可以简化资源的管理，从根本上消除资源（包括内存）泄漏的可能性。这一讲我们就来进一步讲解，如何将 shape_wrapper 改造成一个完整的智能指针。你会看到，智能指针本质上并不神秘，其实就是 RAII 资源管理功能的自然展现而已。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4504">
  <meta itemprop="keywords" content="现代C&#43;&#43;实战30讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="02__自己动手，实现C&#43;&#43;的智能指针">
  <meta name="twitter:description" content="你好，我是吴咏炜。
上一讲，我们描述了一个某种程度上可以当成智能指针用的类 shape_wrapper。使用那个智能指针，可以简化资源的管理，从根本上消除资源（包括内存）泄漏的可能性。这一讲我们就来进一步讲解，如何将 shape_wrapper 改造成一个完整的智能指针。你会看到，智能指针本质上并不神秘，其实就是 RAII 资源管理功能的自然展现而已。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">02__自己动手，实现C&#43;&#43;的智能指针</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4504 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#回顾">回顾</a></li>
        <li><a href="#模板化和易用性">模板化和易用性</a></li>
        <li><a href="#拷贝构造和赋值">拷贝构造和赋值</a></li>
        <li><a href="#移动指针">“移动”指针？</a></li>
        <li><a href="#子类指针向基类指针的转换">子类指针向基类指针的转换</a></li>
        <li><a href="#引用计数">引用计数</a></li>
        <li><a href="#指针类型转换">指针类型转换</a></li>
        <li><a href="#代码列表">代码列表</a></li>
        <li><a href="#内容小结">内容小结</a></li>
        <li><a href="#课后思考">课后思考</a></li>
        <li><a href="#参考资料">参考资料</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是吴咏炜。</p>
<p>上一讲，我们描述了一个某种程度上可以当成智能指针用的类 <code>shape_wrapper</code>。使用那个智能指针，可以简化资源的管理，从根本上消除资源（包括内存）泄漏的可能性。这一讲我们就来进一步讲解，如何将 <code>shape_wrapper</code> 改造成一个完整的智能指针。你会看到，智能指针本质上并不神秘，其实就是 RAII 资源管理功能的自然展现而已。</p>
<p>在学完这一讲之后，你应该会对 C++ 的 <code>unique_ptr</code> 和 <code>shared_ptr</code> 的功能非常熟悉了。同时，如果你今后要创建类似的资源管理类，也不会是一件难事。</p>
<h2 id="回顾">回顾</h2>
<p>我们上一讲给出了下面这个类：</p>
<p>class shape_wrapper {<br>
public:<br>
explicit shape_wrapper(<br>
shape* ptr = nullptr)<br>
: ptr_(ptr) {}<br>
~shape_wrapper()<br>
{<br>
delete ptr_;<br>
}<br>
shape* get() const { return ptr_; }</p>
<p>private:<br>
shape* ptr_;<br>
};</p>
<p>这个类可以完成智能指针的最基本的功能：对超出作用域的对象进行释放。<strong>但它缺了点东西：</strong></p>
<ol>
<li>这个类只适用于 <code>shape</code> 类</li>
<li>该类对象的行为不够像指针</li>
<li>拷贝该类对象会引发程序行为异常</li>
</ol>
<p>下面我们来逐一看一下怎么弥补这些问题。</p>
<h2 id="模板化和易用性">模板化和易用性</h2>
<p>要让这个类能够包装任意类型的指针，我们需要把它变成一个类模板。这实际上相当容易：</p>
<p>template <typename T><br>
class smart_ptr {<br>
public:<br>
explicit smart_ptr(T* ptr = nullptr)<br>
: ptr_(ptr) {}<br>
~smart_ptr()<br>
{<br>
delete ptr_;<br>
}<br>
T* get() const { return ptr_; }<br>
private:<br>
T* ptr_;<br>
};</p>
<p>和 <code>shape_wrapper</code> 比较一下，我们就是在开头增加模板声明 <code>template &lt;typename T&gt;</code>，然后把代码中的 <code>shape</code> 替换成模板参数 <code>T</code> 而已。这些修改非常简单自然吧？模板本质上并不是一个很复杂的概念。这个模板使用也很简单，把原来的 <code>shape_wrapper</code> 改成 <code>smart_ptr&lt;shape&gt;</code> 就行。</p>
<p>目前这个 <code>smart_ptr</code> 的行为还是和指针有点差异的：</p>
<ol>
<li>它不能用 <code>*</code> 运算符解引用</li>
<li>它不能用 <code>-&gt;</code> 运算符指向对象成员</li>
<li>它不能像指针一样用在布尔表达式里</li>
</ol>
<p>不过，这些问题也相当容易解决，加几个成员函数就可以：</p>
<p>template <typename T><br>
class smart_ptr {<br>
public:<br>
…<br>
T&amp; operator*() const { return <em>ptr_; }<br>
T</em> operator-&gt;() const { return ptr_; }<br>
operator bool() const { return ptr_; }<br>
}</p>
<h2 id="拷贝构造和赋值">拷贝构造和赋值</h2>
<p>拷贝构造和赋值，我们暂且简称为拷贝，这是个比较复杂的问题了。关键还不是实现问题，而是我们该如何定义其行为。假设有下面的代码：</p>
<p>smart_ptr<shape> ptr1{create_shape(shape_type::circle)};<br>
smart_ptr<shape> ptr2{ptr1};</p>
<p>对于第二行，究竟应当让编译时发生错误，还是可以有一个更合理的行为？我们来逐一检查一下各种可能性。</p>
<p>最简单的情况显然是禁止拷贝。我们可以使用下面的代码：</p>
<p>template <typename T><br>
class smart_ptr {<br>
…<br>
smart_ptr(const smart_ptr&amp;)<br>
= delete;<br>
smart_ptr&amp; operator=(const smart_ptr&amp;)<br>
= delete;<br>
…<br>
};</p>
<p>禁用这两个函数非常简单，但却解决了一种可能出错的情况。否则，<code>smart_ptr&lt;shape&gt; ptr2{ptr1};</code> 在编译时不会出错，但在运行时却会有未定义行为——由于会对同一内存释放两次，通常情况下会导致程序崩溃。</p>
<p>我们是不是可以考虑在拷贝智能指针时把对象拷贝一份？不行，通常人们不会这么用，因为使用智能指针的目的就是要减少对象的拷贝啊。何况，虽然我们的指针类型是 <code>shape</code>，但实际指向的却应该是 <code>circle</code> 或 <code>triangle</code> 之类的对象。在 C++ 里没有像 Java 的 <code>clone</code> 方法这样的约定；一般而言，并没有通用的方法可以通过基类的指针来构造出一个子类的对象来。</p>
<p>我们要么试试在拷贝时转移指针的所有权？大致实现如下：</p>
<p>template <typename T><br>
class smart_ptr {<br>
…<br>
smart_ptr(smart_ptr&amp; other)<br>
{<br>
ptr_ = other.release();<br>
}<br>
smart_ptr&amp; operator=(smart_ptr&amp; rhs)<br>
{<br>
smart_ptr(rhs).swap(<em>this);<br>
return <em>this;<br>
}<br>
…<br>
T</em> release()<br>
{<br>
T</em> ptr = ptr_;<br>
ptr_ = nullptr;<br>
return ptr;<br>
}<br>
void swap(smart_ptr&amp; rhs)<br>
{<br>
using std::swap;<br>
swap(ptr_, rhs.ptr_);<br>
}<br>
…<br>
};</p>
<p>在拷贝构造函数中，通过调用 <code>other</code> 的 <code>release</code> 方法来释放它对指针的所有权。在赋值函数中，则通过拷贝构造产生一个临时对象并调用 <code>swap</code> 来交换对指针的所有权。实现上是不复杂的。</p>
<p>如果你学到的赋值函数还有一个类似于 <code>if (this != &amp;rhs)</code> 的判断的话，那种用法更啰嗦，而且异常安全性不够好——如果在赋值过程中发生异常的话，this 对象的内容可能已经被部分破坏了，对象不再处于一个完整的状态。</p>
<p><strong>目前这种惯用法（见参考资料</strong> <strong>[1]</strong> **）则保证了强异常安全性：**赋值分为拷贝构造和交换两步，异常只可能在第一步发生；而第一步如果发生异常的话，this 对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。</p>
<p>如果你觉得这个实现还不错的话，那恭喜你，你达到了 C++ 委员会在 1998 年时的水平：上面给出的语义本质上就是 C++98 的 <code>auto_ptr</code> 的定义。如果你觉得这个实现很别扭的话，也恭喜你，因为 C++ 委员会也是这么觉得的：<code>auto_ptr</code> 在 C++17 时已经被正式从 C++ 标准里删除了。</p>
<p>上面实现的最大问题是，它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个 <code>smart_ptr</code>，你就不再拥有这个对象了……</p>
<h2 id="移动指针">“移动”指针？</h2>
<p>在下一讲我们将完整介绍一下移动语义。这一讲，我们先简单看一下 <code>smart_ptr</code> 可以如何使用“移动”来改善其行为。</p>
<p>我们需要对代码做两处小修改：</p>
<p>template <typename T><br>
class smart_ptr {<br>
…<br>
smart_ptr(smart_ptr&amp;&amp; other)<br>
{<br>
ptr_ = other.release();<br>
}<br>
smart_ptr&amp; operator=(smart_ptr rhs)<br>
{<br>
rhs.swap(*this);<br>
return *this;<br>
}<br>
…<br>
};</p>
<p>看到修改的地方了吗？我改了两个地方：</p>
<ol>
<li>把拷贝构造函数中的参数类型 <code>smart_ptr&amp;</code> 改成了 <code>smart_ptr&amp;&amp;</code>；现在它成了移动构造函数。</li>
<li>把赋值函数中的参数类型 <code>smart_ptr&amp;</code> 改成了 <code>smart_ptr</code>，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。</li>
</ol>
<p>根据 C++ 的规则，如果我提供了移动构造函数而没有手动提供拷贝构造函数，那后者自动被禁用（记住，C++ 里那些复杂的规则也是为方便编程而设立的）。于是，我们自然地得到了以下结果：</p>
<p>smart_ptr<shape> ptr1{create_shape(shape_type::circle)};<br>
smart_ptr<shape> ptr2{ptr1};             //  编译出错<br>
smart_ptr<shape> ptr3;<br>
ptr3 = ptr1;                             //  编译出错<br>
ptr3 = std::move(ptr1);                  // OK，可以<br>
smart_ptr<shape> ptr4{std::move(ptr3)};  // OK，可以</p>
<p>这个就自然多了。</p>
<p>这也是 C++11 的 <code>unique_ptr</code> 的基本行为。</p>
<h2 id="子类指针向基类指针的转换">子类指针向基类指针的转换</h2>
<p>哦，我撒了一个小谎。不知道你注意到没有，一个 <code>circle*</code> 是可以隐式转换成 <code>shape*</code> 的，但上面的 <code>smart_ptr&lt;circle&gt;</code> 却无法自动转换成 <code>smart_ptr&lt;shape&gt;</code>。这个行为显然还是不够“自然”。</p>
<p>不过，只需要额外加一点模板代码，就能实现这一行为。在我们目前给出的实现里，只需要修改我们的移动构造函数一处即可——这也算是我们让赋值函数使用拷贝 / 移动构造函数的好处了。</p>
<p>template <typename U><br>
smart_ptr(smart_ptr<U>&amp;&amp; other)<br>
{<br>
ptr_ = other.release();<br>
}</p>
<p>这样，我们自然而然利用了指针的转换特性：现在 <code>smart_ptr&lt;circle&gt;</code> 可以移动给 <code>smart_ptr&lt;shape&gt;</code>，但不能移动给 <code>smart_ptr&lt;triangle&gt;</code>。不正确的转换会在代码编译时直接报错。</p>
<p>至于非隐式的转换，因为本来就是要写特殊的转换函数的，我们留到这一讲的最后再讨论。</p>
<h2 id="引用计数">引用计数</h2>
<p><code>unique_ptr</code> 算是一种较为安全的智能指针了。但是，一个对象只能被单个 <code>unique_ptr</code> 所拥有，这显然不能满足所有使用场合的需求。一种常见的情况是，多个智能指针同时拥有一个对象；当它们全部都失效时，这个对象也同时会被删除。这也就是 <code>shared_ptr</code> 了。</p>
<p><code>unique_ptr</code> 和 <code>shared_ptr</code> 的主要区别如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%8E%B0%E4%BB%A3C++%E5%AE%9E%E6%88%9830%E8%AE%B2/0cbe987faf46299f46de7f206414d329.png" alt=""></p>
<p>多个不同的 <code>shared_ptr</code> 不仅可以共享一个对象，在共享同一对象时也需要同时共享同一个计数。当最后一个指向对象（和共享计数）的 <code>shared_ptr</code> 析构时，它需要删除对象和共享计数。我们下面就来实现一下。</p>
<p>我们先来写出共享计数的接口：</p>
<p>class shared_count {<br>
public:<br>
shared_count();<br>
void add_count();<br>
long reduce_count();<br>
long get_count() const;<br>
};</p>
<p>这个 <code>shared_count</code> 类除构造函数之外有三个方法：一个增加计数，一个减少计数，一个获取计数。注意上面的接口增加计数不需要返回计数值；但减少计数时需要返回计数值，以供调用者判断是否它已经是最后一个指向共享计数的 <code>shared_ptr</code> 了。由于真正多线程安全的版本需要用到我们目前还没学到的知识，我们目前先实现一个简单化的版本：</p>
<p>class shared_count {<br>
public:<br>
shared_count() : count_(1) {}<br>
void add_count()<br>
{<br>
++count_;<br>
}<br>
long reduce_count()<br>
{<br>
return &ndash;count_;<br>
}<br>
long get_count() const<br>
{<br>
return count_;<br>
}</p>
<p>private:<br>
long count_;<br>
};</p>
<p>现在我们可以实现我们的引用计数智能指针了。首先是构造函数、析构函数和私有成员变量：</p>
<p>template <typename T><br>
class smart_ptr {<br>
public:<br>
explicit smart_ptr(T* ptr = nullptr)<br>
: ptr_(ptr)<br>
{<br>
if (ptr) {<br>
shared_count_ =<br>
new shared_count();<br>
}<br>
}<br>
~smart_ptr()<br>
{<br>
if (ptr_ &amp;&amp;<br>
!shared_count_<br>
-&gt;reduce_count()) {<br>
delete ptr_;<br>
delete shared_count_;<br>
}<br>
}</p>
<p>private:<br>
T* ptr_;<br>
shared_count* shared_count_;<br>
};</p>
<p>构造函数跟之前的主要不同点是会构造一个 <code>shared_count</code> 出来。析构函数在看到 <code>ptr_</code> 非空时（此时根据代码逻辑，<code>shared_count</code> 也必然非空），需要对引用数减一，并在引用数降到零时彻底删除对象和共享计数。原理就是这样，不复杂。</p>
<p>当然，我们还有些细节要处理。为了方便实现赋值（及其他一些惯用法），我们需要一个新的 <code>swap</code> 成员函数：</p>
<p>void swap(smart_ptr&amp; rhs)<br>
{<br>
using std::swap;<br>
swap(ptr_, rhs.ptr_);<br>
swap(shared_count_,<br>
rhs.shared_count_);<br>
}</p>
<p>赋值函数可以跟前面一样，保持不变，但拷贝构造和移动构造函数是需要更新一下的：</p>
<p>template <typename U><br>
smart_ptr(const smart_ptr<U>&amp; other)<br>
{<br>
ptr_ = other.ptr_;<br>
if (ptr_) {<br>
other.shared_count_<br>
-&gt;add_count();<br>
shared_count_ =<br>
other.shared_count_;<br>
}<br>
}<br>
template <typename U><br>
smart_ptr(smart_ptr<U>&amp;&amp; other)<br>
{<br>
ptr_ = other.ptr_;<br>
if (ptr_) {<br>
shared_count_ =<br>
other.shared_count_;<br>
other.ptr_ = nullptr;<br>
}<br>
}</p>
<p>除复制指针之外，对于拷贝构造的情况，我们需要在指针非空时把引用数加一，并复制共享计数的指针。对于移动构造的情况，我们不需要调整引用数，直接把 <code>other.ptr_</code> 置为空，认为 <code>other</code> 不再指向该共享对象即可。</p>
<p>不过，上面的代码有个问题：它不能正确编译。编译器会报错，像：</p>
<blockquote>
<p>fatal error: ‘ptr_’is a private member of‘smart_ptr<circle>’</p>
</blockquote>
<p>错误原因是模板的各个实例间并不天然就有 friend 关系，因而不能互访私有成员 <code>ptr_</code> 和 <code>shared_count_</code>。我们需要在 <code>smart_ptr</code> 的定义中显式声明：</p>
<p>template <typename U><br>
friend class smart_ptr;</p>
<p>此外，我们之前的实现（类似于单一所有权的 <code>unique_ptr</code> ）中用 <code>release</code> 来手工释放所有权。在目前的引用计数实现中，它就不太合适了，应当删除。但我们要加一个对调试非常有用的函数，返回引用计数值。定义如下：</p>
<p>long use_count() const<br>
{<br>
if (ptr_) {<br>
return shared_count_<br>
-&gt;get_count();<br>
} else {<br>
return 0;<br>
}<br>
}</p>
<p>这就差不多是一个比较完整的引用计数智能指针的实现了。我们可以用下面的代码来验证一下它的功能正常：</p>
<p>class shape {<br>
public:<br>
virtual ~shape() {}<br>
};</p>
<p>class circle : public shape {<br>
public:<br>
~circle() { puts(&quot;~circle()&quot;); }<br>
};</p>
<p>int main()<br>
{<br>
smart_ptr<circle> ptr1(new circle());<br>
printf(&ldquo;use count of ptr1 is %ld\n&rdquo;,<br>
ptr1.use_count());<br>
smart_ptr<shape> ptr2;<br>
printf(&ldquo;use count of ptr2 was %ld\n&rdquo;,<br>
ptr2.use_count());<br>
ptr2 = ptr1;<br>
printf(&ldquo;use count of ptr2 is now %ld\n&rdquo;,<br>
ptr2.use_count());<br>
if (ptr1) {<br>
puts(&ldquo;ptr1 is not empty&rdquo;);<br>
}<br>
}</p>
<p>这段代码的运行结果是：</p>
<p><code>use count of ptr1 is 1</code></p>
<p><code>use count of ptr2 was 0</code></p>
<p><code>use count of ptr2 is now 2</code></p>
<p><code>ptr1 is not empty</code></p>
<p><code>~circle()</code></p>
<p>上面我们可以看到引用计数的变化，以及最后对象被成功删除。</p>
<h2 id="指针类型转换">指针类型转换</h2>
<p>对应于 C++ 里的不同的类型强制转换：</p>
<ol>
<li>static_cast</li>
<li>reinterpret_cast</li>
<li>const_cast</li>
<li>dynamic_cast</li>
</ol>
<p>智能指针需要实现类似的函数模板。实现本身并不复杂，但为了实现这些转换，我们需要添加构造函数，允许在对智能指针内部的指针对象赋值时，使用一个现有的智能指针的共享计数。如下所示：</p>
<p>template <typename U><br>
smart_ptr(const smart_ptr<U>&amp; other,<br>
T* ptr)<br>
{<br>
ptr_ = ptr;<br>
if (ptr_) {<br>
other.shared_count_<br>
-&gt;add_count();<br>
shared_count_ =<br>
other.shared_count_;<br>
}<br>
}</p>
<p>这样我们就可以实现转换所需的函数模板了。下面实现一个 <code>dynamic_pointer_cast</code> 来示例一下：</p>
<p>template &lt;typename T, typename U&gt;<br>
smart_ptr<T> dynamic_pointer_cast(<br>
const smart_ptr<U>&amp; other)<br>
{<br>
T* ptr =<br>
dynamic_cast&lt;T*&gt;(other.get());<br>
return smart_ptr<T>(other, ptr);<br>
}</p>
<p>在前面的验证代码后面我们可以加上：</p>
<p>smart_ptr<circle> ptr3 =<br>
dynamic_pointer_cast<circle>(ptr2);<br>
printf(&ldquo;use count of ptr3 is %ld\n&rdquo;,<br>
ptr3.use_count());</p>
<p>编译会正常通过，同时能在输出里看到下面的结果：</p>
<blockquote>
<p>use count of ptr3 is 3</p>
</blockquote>
<p>最后，对象仍然能够被正确删除。这说明我们的实现是正确的。</p>
<h2 id="代码列表">代码列表</h2>
<p>为了方便你参考，下面我给出了一个完整的 <code>smart_ptr</code> 代码列表：</p>
<p>#include <utility>  // std::swap</p>
<p>class shared_count {<br>
public:<br>
shared_count() noexcept<br>
: count_(1) {}<br>
void add_count() noexcept<br>
{<br>
++count_;<br>
}<br>
long reduce_count() noexcept<br>
{<br>
return &ndash;count_;<br>
}<br>
long get_count() const noexcept<br>
{<br>
return count_;<br>
}</p>
<p>private:<br>
long count_;<br>
};</p>
<p>template <typename T><br>
class smart_ptr {<br>
public:<br>
template <typename U><br>
friend class smart_ptr;</p>
<p>explicit smart_ptr(T* ptr = nullptr)<br>
: ptr_(ptr)<br>
{<br>
if (ptr) {<br>
shared_count_ =<br>
new shared_count();<br>
}<br>
}<br>
~smart_ptr()<br>
{<br>
printf(&quot;~smart_ptr(): %p\n&quot;, this);<br>
if (ptr_ &amp;&amp;<br>
!shared_count_<br>
-&gt;reduce_count()) {<br>
delete ptr_;<br>
delete shared_count_;<br>
}<br>
}</p>
<p>template <typename U><br>
smart_ptr(const smart_ptr<U>&amp; other) noexcept<br>
{<br>
ptr_ = other.ptr_;<br>
if (ptr_) {<br>
other.shared_count_-&gt;add_count();<br>
shared_count_ = other.shared_count_;<br>
}<br>
}<br>
template <typename U><br>
smart_ptr(smart_ptr<U>&amp;&amp; other) noexcept<br>
{<br>
ptr_ = other.ptr_;<br>
if (ptr_) {<br>
shared_count_ =<br>
other.shared_count_;<br>
other.ptr_ = nullptr;<br>
}<br>
}<br>
template <typename U><br>
smart_ptr(const smart_ptr<U>&amp; other,<br>
T* ptr) noexcept<br>
{<br>
ptr_ = ptr;<br>
if (ptr_) {<br>
other.shared_count_<br>
-&gt;add_count();<br>
shared_count_ =<br>
other.shared_count_;<br>
}<br>
}<br>
smart_ptr&amp;<br>
operator=(smart_ptr rhs) noexcept<br>
{<br>
rhs.swap(*this);<br>
return *this;<br>
}</p>
<p>T* get() const noexcept<br>
{<br>
return ptr_;<br>
}<br>
long use_count() const noexcept<br>
{<br>
if (ptr_) {<br>
return shared_count_<br>
-&gt;get_count();<br>
} else {<br>
return 0;<br>
}<br>
}<br>
void swap(smart_ptr&amp; rhs) noexcept<br>
{<br>
using std::swap;<br>
swap(ptr_, rhs.ptr_);<br>
swap(shared_count_,<br>
rhs.shared_count_);<br>
}</p>
<p>T&amp; operator*() const noexcept<br>
{<br>
return <em>ptr_;<br>
}<br>
T</em> operator-&gt;() const noexcept<br>
{<br>
return ptr_;<br>
}<br>
operator bool() const noexcept<br>
{<br>
return ptr_;<br>
}</p>
<p>private:<br>
T* ptr_;<br>
shared_count* shared_count_;<br>
};</p>
<p>template <typename T><br>
void swap(smart_ptr<T>&amp; lhs,<br>
smart_ptr<T>&amp; rhs) noexcept<br>
{<br>
lhs.swap(rhs);<br>
}</p>
<p>template &lt;typename T, typename U&gt;<br>
smart_ptr<T> static_pointer_cast(<br>
const smart_ptr<U>&amp; other) noexcept<br>
{<br>
T* ptr = static_cast&lt;T*&gt;(other.get());<br>
return smart_ptr<T>(other, ptr);<br>
}</p>
<p>template &lt;typename T, typename U&gt;<br>
smart_ptr<T> reinterpret_pointer_cast(<br>
const smart_ptr<U>&amp; other) noexcept<br>
{<br>
T* ptr = reinterpret_cast&lt;T*&gt;(other.get());<br>
return smart_ptr<T>(other, ptr);<br>
}</p>
<p>template &lt;typename T, typename U&gt;<br>
smart_ptr<T> const_pointer_cast(<br>
const smart_ptr<U>&amp; other) noexcept<br>
{<br>
T* ptr = const_cast&lt;T*&gt;(other.get());<br>
return smart_ptr<T>(other, ptr);<br>
}</p>
<p>template &lt;typename T, typename U&gt;<br>
smart_ptr<T> dynamic_pointer_cast(<br>
const smart_ptr<U>&amp; other) noexcept<br>
{<br>
T* ptr = dynamic_cast&lt;T*&gt;(other.get());<br>
return smart_ptr<T>(other, ptr);<br>
}</p>
<p>如果你足够细心的话，你会发现我在代码里加了不少 <code>noexcept</code>。这对这个智能指针在它的目标场景能正确使用是十分必要的。我们会在下面的几讲里回到这个话题。</p>
<h2 id="内容小结">内容小结</h2>
<p>这一讲我们从 <code>shape_wrapper</code> 出发，实现了一个基本完整的带引用计数的智能指针。这个智能指针跟标准的 <code>shared_ptr</code> 比，还缺了一些东西（见参考资料 [2]），但日常用到的智能指针功能已经包含在内。现在，你应当已经对智能指针有一个较为深入的理解了。</p>
<h2 id="课后思考">课后思考</h2>
<p>这里留几个问题，你可以思考一下：</p>
<ol>
<li>不查阅 <code>shared_ptr</code> 的文档，你觉得目前 <code>smart_ptr</code> 应当添加什么功能吗？</li>
<li>你想到的功能在标准的 <code>shared_ptr</code> 里吗？</li>
<li>你觉得智能指针应该满足什么样的线程安全性？</li>
</ol>
<p>欢迎留言和我交流你的看法。</p>
<h2 id="参考资料">参考资料</h2>
<p>[1] Stack Overflow, GManNickG’s answer to“What is the copy-and-swap idiom?”. <a href="https://stackoverflow.com/a/3279550/816999">https://stackoverflow.com/a/3279550/816999</a></p>
<p>[2] cppreference.com, “std::shared_ptr”. <a href="https://en.cppreference.com/w/cpp/memory/shared">https://en.cppreference.com/w/cpp/memory/shared</a>_ptr</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/">现代C&#43;&#43;实战30讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/02__%E5%AD%97%E6%AE%B5%E8%BF%99%E4%B9%88%E5%A4%9A%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E8%AF%A5%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">02__字段：这么多字段类型，该怎么定义？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/02_mapreduce%E5%90%8E%E8%B0%81%E4%B8%BB%E6%B2%89%E6%B5%AE%E6%80%8E%E6%A0%B7%E8%AE%BE%E8%AE%A1%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/">
            <span class="next-text nav-default">02_MapReduce后谁主沉浮：怎样设计下一代数据处理技术？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
