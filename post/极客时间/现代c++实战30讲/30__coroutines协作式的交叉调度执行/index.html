<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>30__Coroutines：协作式的交叉调度执行 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是吴咏炜。
今天是我们未来篇的最后一讲，也是这个专栏正文内容的最后一篇了。我们讨论 C&#43;&#43;20 里的又一个非常重要的新功能——协程 Coroutines。
什么是协程？ 协程是一个很早就被提出的编程概念。根据高德纳的描述，协程的概念在 1958 年就被提出了。不过，它在主流编程语言中得到的支持不那么好，因而你很可能对它并不熟悉吧。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/30__coroutines%E5%8D%8F%E4%BD%9C%E5%BC%8F%E7%9A%84%E4%BA%A4%E5%8F%89%E8%B0%83%E5%BA%A6%E6%89%A7%E8%A1%8C/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/30__coroutines%E5%8D%8F%E4%BD%9C%E5%BC%8F%E7%9A%84%E4%BA%A4%E5%8F%89%E8%B0%83%E5%BA%A6%E6%89%A7%E8%A1%8C/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="30__Coroutines：协作式的交叉调度执行">
  <meta property="og:description" content="你好，我是吴咏炜。
今天是我们未来篇的最后一讲，也是这个专栏正文内容的最后一篇了。我们讨论 C&#43;&#43;20 里的又一个非常重要的新功能——协程 Coroutines。
什么是协程？ 协程是一个很早就被提出的编程概念。根据高德纳的描述，协程的概念在 1958 年就被提出了。不过，它在主流编程语言中得到的支持不那么好，因而你很可能对它并不熟悉吧。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="现代C&#43;&#43;实战30讲">

  <meta itemprop="name" content="30__Coroutines：协作式的交叉调度执行">
  <meta itemprop="description" content="你好，我是吴咏炜。
今天是我们未来篇的最后一讲，也是这个专栏正文内容的最后一篇了。我们讨论 C&#43;&#43;20 里的又一个非常重要的新功能——协程 Coroutines。
什么是协程？ 协程是一个很早就被提出的编程概念。根据高德纳的描述，协程的概念在 1958 年就被提出了。不过，它在主流编程语言中得到的支持不那么好，因而你很可能对它并不熟悉吧。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5502">
  <meta itemprop="keywords" content="现代C&#43;&#43;实战30讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="30__Coroutines：协作式的交叉调度执行">
  <meta name="twitter:description" content="你好，我是吴咏炜。
今天是我们未来篇的最后一讲，也是这个专栏正文内容的最后一篇了。我们讨论 C&#43;&#43;20 里的又一个非常重要的新功能——协程 Coroutines。
什么是协程？ 协程是一个很早就被提出的编程概念。根据高德纳的描述，协程的概念在 1958 年就被提出了。不过，它在主流编程语言中得到的支持不那么好，因而你很可能对它并不熟悉吧。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">30__Coroutines：协作式的交叉调度执行</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5502 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#什么是协程">什么是协程？</a></li>
      </ul>
    </li>
    <li><a href="#打印头-20-项">打印头 20 项</a></li>
    <li><a href="#打印小于-10000-的数列项">打印小于 10000 的数列项</a>
      <ul>
        <li><a href="#c20-协程">C++20 协程</a>
          <ul>
            <li><a href="#co_awaitco_yieldco_return-和协程控制">co_await、co_yield、co_return 和协程控制</a></li>
            <li><a href="#定义-uint64_resumable">定义 uint64_resumable</a></li>
          </ul>
        </li>
        <li><a href="#c20-协程的高层抽象">C++20 协程的高层抽象</a>
          <ul>
            <li><a href="#cppcoro">cppcoro</a></li>
            <li><a href="#msvc">MSVC</a></li>
          </ul>
        </li>
        <li><a href="#有栈协程和无栈协程">有栈协程和无栈协程</a></li>
        <li><a href="#编译器支持">编译器支持</a></li>
        <li><a href="#内容小结">内容小结</a></li>
        <li><a href="#课后思考">课后思考</a></li>
        <li><a href="#参考资料">参考资料</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是吴咏炜。</p>
<p>今天是我们未来篇的最后一讲，也是这个专栏正文内容的最后一篇了。我们讨论 C++20 里的又一个非常重要的新功能——协程 Coroutines。</p>
<h2 id="什么是协程">什么是协程？</h2>
<p>协程是一个很早就被提出的编程概念。根据高德纳的描述，协程的概念在 1958 年就被提出了。不过，它在主流编程语言中得到的支持不那么好，因而你很可能对它并不熟悉吧。</p>
<p>如果查阅维基百科，你可以看到下面这样的定义 [1]：</p>
<blockquote>
<p>协程是计算机程序的⼀类组件，推⼴了协作式多任务的⼦程序，允许执⾏被挂起与被恢复。相对⼦例程⽽⾔，协程更为⼀般和灵活……</p>
</blockquote>
<p>等学完了这一讲，也许你可以明白这段话的意思。但对不了解协程的人来说，估计只能吐槽一句了，这是什么鬼？</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%8E%B0%E4%BB%A3C++%E5%AE%9E%E6%88%9830%E8%AE%B2/c899bfe27d73bb6234dc24b2511f6191.png" alt=""></p>
<p>图片源自网络</p>
<p>很遗憾，在 C++ 里的标准协程有点小复杂。我们还是从……Python 开始。</p>
<p>def fibonacci():<br>
a = 0<br>
b = 1<br>
while True:<br>
yield b<br>
a, b = b, a + b</p>
<p>即使你没学过 Python，上面这个生成斐波那契数列的代码应该也不难理解。唯一看起来让人会觉得有点奇怪的应该就是那个 <code>yield</code> 了。这种写法在 Python 里叫做“生成器”（generator），返回的是一个可迭代的对象，每次迭代就能得到一个 yield 出来的结果。这就是一种很常见的协程形式了。</p>
<p>如何使用这个生成器，请看下面的代码：</p>
<h1 id="打印头-20-项">打印头 20 项</h1>
<p>for i in islice(fibonacci(), 20):<br>
print(i)</p>
<h1 id="打印小于-10000-的数列项">打印小于 10000 的数列项</h1>
<p>for i in takewhile(<br>
lambda x: x &lt; 10000,<br>
fibonacci()):<br>
print(i)</p>
<p>这些代码很容易理解：<code>islice</code> 相当于 [第 29 讲] 中的 <code>take</code>，取一个范围的头若干项；<code>takewhile</code> 则在范围中逐项取出内容，直到第一个参数的条件不能被满足。两个函数的结果都可以被看作是 C++ 中的视图。</p>
<p>我们唯一需要提的是，在代码的执行过程中，<code>fibonacci</code> 和它的调用代码是交叉执行的。下面我们用代码行加注释的方式标一下：</p>
<p>a = 0  # fibonacci()<br>
b = 0  # fibonacci()<br>
yield b  # fibonacci()<br>
print(i)  # 调用者<br>
a, b = 1, 0 + 1  # fibonacci()<br>
yield b  # fibonacci()<br>
print(i)  # 调用者<br>
a, b = 1, 1 + 1  # fibonacci()<br>
yield b  # fibonacci()<br>
print(i)  # 调用者<br>
a, b = 2, 1 + 2  # fibonacci()<br>
yield b  # fibonacci()<br>
print(i)  # 调用者<br>
…</p>
<p>学到这儿的同学应该都知道我们在 C++ 里怎么完成类似的功能吧？我就不讲解了，直接给出可工作的代码。这是对应的 <code>fibonacci</code> 的定义：</p>
<p>#include &lt;stddef.h&gt;<br>
#include &lt;stdint.h&gt;</p>
<p>class fibonacci {<br>
public:<br>
class sentinel;<br>
class iterator;<br>
iterator begin() noexcept;<br>
sentinel end() noexcept;<br>
};</p>
<p>class fibonacci::sentinel {};</p>
<p>class fibonacci::iterator {<br>
public:<br>
// Required to satisfy iterator<br>
// concept<br>
typedef ptrdiff_t difference_type;<br>
typedef uint64_t value_type;<br>
typedef const uint64_t* pointer;<br>
typedef const uint64_t&amp; reference;<br>
typedef std::input_iterator_tag<br>
iterator_category;</p>
<p>value_type operator*() const<br>
{<br>
return b_;<br>
}<br>
pointer operator-&gt;() const<br>
{<br>
return &amp;b_;<br>
}<br>
iterator&amp; operator++()<br>
{<br>
auto tmp = a_;<br>
a_ = b_;<br>
b_ += tmp;<br>
return *this;<br>
}<br>
iterator operator++(int)<br>
{<br>
auto tmp = *this;<br>
++*this;<br>
return tmp;<br>
}<br>
bool<br>
operator==(const sentinel&amp;) const<br>
{<br>
return false;<br>
}<br>
bool<br>
operator!=(const sentinel&amp;) const<br>
{<br>
return true;<br>
}</p>
<p>private:<br>
uint64_t a_{0};<br>
uint64_t b_{1};<br>
};</p>
<p>// sentinel needs to be<br>
// equality_comparable_with iterator<br>
bool operator==(<br>
const fibonacci::sentinel&amp; lhs,<br>
const fibonacci::iterator&amp; rhs)<br>
{<br>
return rhs == lhs;<br>
}<br>
bool operator!=(<br>
const fibonacci::sentinel&amp; lhs,<br>
const fibonacci::iterator&amp; rhs)<br>
{<br>
return rhs != lhs;<br>
}</p>
<p>inline fibonacci::iterator<br>
fibonacci::begin() noexcept<br>
{<br>
return iterator();<br>
}</p>
<p>inline fibonacci::sentinel<br>
fibonacci::end() noexcept<br>
{<br>
return sentinel();<br>
}</p>
<p>调用代码跟 Python 的相似：</p>
<p>// 打印头 20 项<br>
for (auto i :<br>
fibonacci() | take(20)) {<br>
cout &laquo; i &laquo; endl;<br>
}</p>
<p>// 打印小于 10000 的数列项<br>
for (auto i :<br>
fibonacci() |<br>
take_while(<a href="./uint64_t_x.md"></a> {<br>
return x &lt; 10000;<br>
})) {<br>
cout &laquo; i &laquo; endl;<br>
}</p>
<p>这似乎还行。但 <code>fibonacci</code> 的定义差异就大了：在 Python 里是 6 行有效代码，在 C++ 里是 53 行。C++ 的生产率似乎有点低啊……</p>
<h2 id="c20-协程">C++20 协程</h2>
<p>C++20 协程的基础是微软提出的 Coroutines TS（可查看工作草案 [2]），它在 2019 年 7 月被批准加入到 C++20 草案中。目前，MSVC 和 Clang 已经支持协程。不过，需要提一下的是，目前被标准化的只是协程的底层语言支持，而不是上层的高级封装；稍后，我们会回到这个话题。</p>
<p>协程可以有很多不同的用途，下面列举了几种常见情况：</p>
<ol>
<li>生成器</li>
<li>异步 I/O</li>
<li>惰性求值</li>
<li>事件驱动应用</li>
</ol>
<p>这一讲中，我们主要还是沿用生成器的例子，向你展示协程的基本用法。异步 I/O 应当在协程得到广泛采用之后，成为最能有明显收益的使用场景；但目前，就我看到的，只有 Windows 平台上有较好的支持——微软目前还是做了很多努力的。</p>
<p>回到 Coroutines。我们今天采用 Coroutines TS 中的写法，包括 <code>std::experimental</code> 名空间，以确保你可以在 MSVC 和 Clang 下编译代码。首先，我们看一下协程相关的新关键字，有下面三个：</p>
<ol>
<li>co_await</li>
<li>co_yield</li>
<li>co_return</li>
</ol>
<p>这三个关键字最初是没有 <code>co_</code> 前缀的，但考虑到 <code>await</code>、<code>yield</code> 已经在很多代码里出现，就改成了目前这个样子。同时，<code>return</code> 和 <code>co_return</code> 也作出了明确的区分：一个协程里只能使用 <code>co_return</code>，不能使用 <code>return</code>。这三个关键字只要有一个出现在函数中，这个函数就是一个协程了——从外部则看不出来，没有用其他语言常用的 <code>async</code> 关键字来标记（<code>async</code> 也已经有其他用途了，见 [第 19 讲]）。C++ 认为一个函数是否是一个协程是一个实现细节，不是对外接口的一部分。</p>
<p>我们看一下用协程实现的 <code>fibonacci</code> 长什么样子：</p>
<p>uint64_resumable fibonacci()<br>
{<br>
uint64_t a = 0;<br>
uint64_t b = 1;<br>
while (true) {<br>
co_yield b;<br>
auto tmp = a;<br>
a = b;<br>
b += tmp;<br>
}<br>
}</p>
<p>这个形式跟 Python 的非常相似了吧，也非常简洁。我们稍后再讨论 <code>uint64_resumable</code> 的定义，先看一下调用代码的样子：</p>
<p>auto res = fibonacci();<br>
while (res.resume()) {<br>
auto i = res.get();<br>
if (i &gt;= 10000) {<br>
break;<br>
}<br>
cout &laquo; i &laquo; endl;<br>
}</p>
<p>这个代码也非常简单，但我们需要留意 <code>resume</code> 和 <code>get</code> 两个函数调用——这就是我们的 <code>uint64_resumable</code> 类型需要提供的接口了。</p>
<h3 id="co_awaitco_yieldco_return-和协程控制">co_await、co_yield、co_return 和协程控制</h3>
<p>在讨论该如何定义 <code>uint64_resumable</code> 之前，我们需要先讨论一下协程的这三个新关键字。</p>
<p>首先是 <code>co_await</code>。对于下面这样一个表达式：</p>
<p>auto result = co_await 表达式;</p>
<p>编译器会把它理解为：</p>
<p>auto&amp;&amp; __a = 表达式;<br>
if (!__a.await_ready()) {<br>
__a.await_suspend(协程句柄);<br>
// 挂起/恢复点<br>
}<br>
auto result = __a.await_resume();</p>
<p>也就是说，“表达式”需要支持 <code>await_ready</code>、<code>await_suspend</code> 和 <code>await_resume</code> 三个接口。如果 <code>await_ready()</code> 返回真，就代表不需要真正挂起，直接返回后面的结果就可以；否则，执行 <code>await_suspend</code> 之后即挂起协程，等待协程被唤醒之后再返回 <code>await_resume()</code> 的结果。这样一个表达式被称作是个 awaitable。</p>
<p>标准里定义了两个 awaitable，如下所示：</p>
<p>struct suspend_always {<br>
bool await_ready() const noexcept<br>
{<br>
return false;<br>
}<br>
void await_suspend(<br>
coroutine_handle&lt;&gt;)<br>
const noexcept {}<br>
void await_resume()<br>
const noexcept {}<br>
};</p>
<p>struct suspend_never {<br>
bool await_ready() const noexcept<br>
{<br>
return true;<br>
}<br>
void await_suspend(<br>
coroutine_handle&lt;&gt;)<br>
const noexcept {}<br>
void await_resume()<br>
const noexcept {}<br>
};</p>
<p>也就是说，<code>suspend_always</code> 永远告诉调用者需要挂起，而 <code>suspend_never</code> 则永远告诉调用者不需要挂起。两者的 <code>await_suspend</code> 和 <code>await_resume</code> 都是平凡实现，不做任何实际的事情。一个 awaitable 可以自行实现这些接口，以定制挂起之前和恢复之后需要执行的操作。</p>
<p>上面的 <code>coroutine_handle</code> 是 C++ 标准库提供的类模板。这个类是用户代码跟系统协程调度真正交互的地方，有下面这些成员函数我们等会就会用到：</p>
<ol>
<li><code>destroy</code>：销毁协程</li>
<li><code>done</code>：判断协程是否已经执行完成</li>
<li><code>resume</code>：让协程恢复执行</li>
<li><code>promise</code>：获得协程相关的 promise 对象（和 [第 19 讲] 中的“承诺量”有点相似，是协程和调用者的主要交互对象；一般类型名称为 <code>promise_type</code>）</li>
<li><code>from_promise</code>（静态）：通过 promise 对象的引用来生成一个协程句柄</li>
</ol>
<p>协程的执行过程大致是这个样子的：</p>
<ol>
<li>为协程调用分配一个协程帧，含协程调用的参数、变量、状态、promise 对象等所需的空间。</li>
<li>调用 <code>promise.get_return_object()</code>，返回值会在协程第一次挂起时返回给协程的调用者。</li>
<li>执行 <code>co_await promise.initial_suspsend()</code>；根据上面对 <code>co_await</code> 语义的描述，协程可能在此第一次挂起（但也可能此时不挂起，在后面的协程体执行过程中挂起）。</li>
<li>执行协程体中的语句，中间可能有挂起和恢复；如果期间发生异常没有在协程体中处理，则调用 <code>promise.unhandled_exception()</code>。</li>
<li>当协程执行到底，或者执行到 <code>co_return</code> 语句时，会根据是否有非 void 的返回值，调用 <code>promise.return_value(…)</code> 或 <code>promise.return_void()</code>，然后执行 <code>co_await promise.final_suspsend()</code>。</li>
</ol>
<p>用代码可以大致表示如下：</p>
<p>frame = operator new(…);<br>
promise_type&amp; promise =<br>
frame-&gt;promise;</p>
<p>// 在初次挂起时返回给调用者<br>
auto return_value =<br>
promise.get_return_object();</p>
<p>co_await promise<br>
.initial_suspsend();<br>
try {<br>
执行协程体;<br>
可能被 co_wait、co_yield 挂起;<br>
恢复后继续执行，直到 co_return;<br>
}<br>
catch (&hellip;) {<br>
promise.unhandled_exception();<br>
}</p>
<p>final_suspend:<br>
co_await promise.final_suspsend();</p>
<p>上面描述了 <code>co_await</code> 和 <code>co_return</code>，那 <code>co_yield</code> 呢？也很简单，<code>co_yield 表达式</code> 等价于：</p>
<p>co_await promise.yield_value(表达式);</p>
<h3 id="定义-uint64_resumable">定义 uint64_resumable</h3>
<p>了解了上述知识之后，我们就可以展示一下 uint64_resumable 的定义了：</p>
<p>class uint64_resumable {<br>
public:<br>
struct promise_type {…};</p>
<p>using coro_handle =<br>
coroutine_handle&lt;promise_type&gt;;<br>
explicit uint64_resumable(<br>
coro_handle handle)<br>
: handle_(handle)<br>
{<br>
}<br>
~uint64_resumable()<br>
{<br>
handle_.destroy();<br>
}<br>
uint64_resumable(<br>
const uint64_resumable&amp;) =<br>
delete;<br>
uint64_resumable(<br>
uint64_resumable&amp;&amp;) = default;<br>
bool resume();<br>
uint64_t get();</p>
<p>private:<br>
coro_handle handle_;<br>
};</p>
<p>这个代码相当简单，我们的结构内部有个 <code>promise_type</code>（下面会定义），而私有成员只有一个协程句柄。协程构造需要一个协程句柄，析构时将使用协程句柄来销毁协程；为简单起见，我们允许结构被移动，但不可复制（以免重复调用 <code>handle_.destroy()</code>）。除此之外，我们这个结构只提供了调用者需要的 <code>resume</code> 和 <code>get</code> 成员函数，分别定义如下：</p>
<p>bool uint64_resumable::resume()<br>
{<br>
if (!handle_.done()) {<br>
handle_.resume();<br>
}<br>
return !handle_.done();<br>
}</p>
<p>uint64_t uint64_resumable::get()<br>
{<br>
return handle_.promise().value_;<br>
}</p>
<p>也就是说，<code>resume</code> 会判断协程是否已经结束，没结束就恢复协程的执行；当协程再次挂起时（调用者恢复执行），返回协程是否仍在执行中的状态。而 <code>get</code> 简单地返回存储在 promise 对象中的数值。</p>
<p>现在我们需要看一下 promise 类型了，它里面有很多协程的定制点，可以修改协程的行为：</p>
<p>struct promise_type {<br>
uint64_t value_;<br>
using coro_handle =<br>
coroutine_handle&lt;promise_type&gt;;<br>
auto get_return_object()<br>
{<br>
return uint64_resumable{<br>
coro_handle::from_promise(<br>
*this)};<br>
}<br>
constexpr auto initial_suspend()<br>
{<br>
return suspend_always();<br>
}<br>
constexpr auto final_suspend()<br>
{<br>
return suspend_always();<br>
}<br>
auto yield_value(uint64_t value)<br>
{<br>
value_ = value;<br>
return suspend_always();<br>
}<br>
void return_void() {}<br>
void unhandled_exception()<br>
{<br>
std::terminate();<br>
}<br>
};</p>
<p>简单解说一下：</p>
<ol>
<li>结构里面只有一个数据成员 <code>value_</code>，存放供 <code>uint64_resumable::get</code> 取用的数值。</li>
<li><code>get_return_object</code> 是第一个定制点。我们前面提到过，调用协程的返回值就是 <code>get_return_object()</code> 的结果。我们这儿就是使用 promise 对象来构造一个 <code>uint64_resumable</code>。</li>
<li><code>initial_suspend</code> 是第二个定制点。我们此处返回 <code>suspend_always()</code>，即协程立即挂起，调用者马上得到 <code>get_return_object()</code> 的结果。</li>
<li><code>final_suspend</code> 是第三个定制点。我们此处返回 <code>suspend_always()</code>，即使执行到了 <code>co_return</code> 语句，协程仍处于挂起状态。如果我们返回 <code>suspend_never()</code> 的话，那一旦执行了 <code>co_return</code> 或执行到协程结束，协程就会被销毁，连同已初始化的本地变量和 promise，并释放协程帧内存。</li>
<li><code>yield_value</code> 是第四个定制点。我们这儿仅对 <code>value_</code> 进行赋值，然后让协程挂起（执行控制回到调用者）。</li>
<li><code>return_void</code> 是第五个定制点。我们的代码永不返回，这儿无事可做。</li>
<li><code>unhandled_exception</code> 是第六个定制点。我们这儿也不应该发生任何异常，所以我们简单地调用 <code>terminate</code> 来终结程序的执行。</li>
</ol>
<p>好了，这样，我们就完成了协程相关的所有定义。有没有觉得轻松点？</p>
<p>没有？那就对了。正如我在这一节开头说的，C++20 标准化的只是协程的底层语言支持（我上面还并不是一个非常完整的描述）。要用这些底层直接写应用代码，那是非常痛苦的事。这些接口的目标用户实际上也不是普通开发者，而是库的作者。</p>
<p>幸好，我们并不是没有任何高层抽象，虽然这些实现不“标准”。</p>
<h2 id="c20-协程的高层抽象">C++20 协程的高层抽象</h2>
<h3 id="cppcoro">cppcoro</h3>
<p>我们首先看一下跨平台的 cppcoro 库 [3]，它提供的高层接口就包含了 <code>generator</code>。如果使用 cppcoro，我们的 <code>fibonacci</code> 协程可以这样实现：</p>
<p>#include &lt;cppcoro/generator.hpp&gt;<br>
using cppcoro::generator;</p>
<p>generator&lt;uint64_t&gt; fibonacci()<br>
{<br>
uint64_t a = 0;<br>
uint64_t b = 1;<br>
while (true) {<br>
co_yield b;<br>
auto tmp = a;<br>
a = b;<br>
b += tmp;<br>
}<br>
}</p>
<p>使用 <code>fibonacci</code> 也比刚才的代码要方便：</p>
<p>for (auto i : fibonacci()) {<br>
if (i &gt;= 10000) {<br>
break;<br>
}<br>
cout &laquo; i &laquo; endl;<br>
}</p>
<p>除了生成器，cppcoro 还支持异步任务和异步 I/O——遗憾的是，异步 I/O 目前只有 Windows 平台上有，还没人实现 Linux 或 macOS 上的支持。</p>
<h3 id="msvc">MSVC</h3>
<p>作为协程的先行者和 Coroutines TS 的提出者，微软在协程上做了很多工作。生成器当然也在其中：</p>
<p>#include &lt;experimental/generator&gt;<br>
using std::experimental::generator;</p>
<p>generator&lt;uint64_t&gt; fibonacci()<br>
{<br>
uint64_t a = 0;<br>
uint64_t b = 1;<br>
while (true) {<br>
co_yield b;<br>
auto tmp = a;<br>
a = b;<br>
b += tmp;<br>
}<br>
}</p>
<p>微软还有一些有趣的私有扩展。比如，MSVC 把标准 C++ 的 <code>future</code> 改造成了 awaitable。下面的代码在 MSVC 下可以编译通过，简单地展示了基本用法：</p>
<p>#include &lt;experimental/coroutine&gt;<br>
using namespace std;</p>
<p>future<int> compute_value()<br>
{<br>
int result = co_await async([] {<br>
this_thread::sleep_for(1s);<br>
return 42;<br>
});<br>
co_return result;<br>
}</p>
<p>int main()<br>
{<br>
auto value = compute_value();<br>
cout &laquo; value.get() &laquo; endl;<br>
}</p>
<p>代码中有一个地方我需要提醒一下：虽然上面 <code>async</code> 返回的是 <code>future&lt;int&gt;</code>，但 <code>compute_value</code> 的调用者得到的并不是这个 <code>future</code>——它得到的是另外一个独立的 <code>future</code>，并最终由 <code>co_return</code> 把结果数值填充了进去。</p>
<h2 id="有栈协程和无栈协程">有栈协程和无栈协程</h2>
<p>我们最后需要说一下有栈（stackful）协程和无栈（stackless）协程的区别。C++ 里很早就有了有栈的协程，概念上来讲，有栈的协程跟纤程、goroutines 基本是一个概念，都是由用户自行调度的、操作系统之外的运行单元。每个这样的运行单元都有自己独立的栈空间，缺点当然就是栈的空间占用和切换栈的开销了。而无栈的协程自己没有独立的栈空间，每个协程只需要一个很小的栈帧，空间占用小，也没有栈的切换开销。</p>
<p>C++20 的协程是无栈的。部分原因是有栈的协程可以使用纯库方式实现，而无栈的协程需要一点编译器魔法帮忙。毕竟，协程里面的变量都是要放到堆上而不是栈上的。</p>
<p>一个简单的无栈协程调用的内存布局如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%8E%B0%E4%BB%A3C++%E5%AE%9E%E6%88%9830%E8%AE%B2/0bbf3d3c92ef2ef7619543d9244ac945.png" alt=""></p>
<p>可以看到，协程 C 本身的本地变量不占用栈，但当它调用其他函数时，它会使用线程原先的栈空间。在上面的函数 D 的执行过程中，协程是不可以挂起的——如果控制回到 B 继续，B 可能会使用目前已经被 D 使用的栈空间！</p>
<p>因此，无栈的协程牺牲了一定的灵活性，换来了空间的节省和性能。有栈的协程你可能起几千个就占用不少内存空间，而无栈的协程可以轻轻松松起到亿级——毕竟，维持基本状态的开销我实测下来只有一百字节左右。</p>
<p>反过来，如果无栈的协程不满足需要——比如，你的协程里需要有递归调用，并在深层挂起——你就不得不寻找一个有栈的协程的解决方案。目前已经有一些成熟的方案，比如 Boost.Coroutine2 [4]。下面的代码展示如何在 Boost.Coroutine2 里实现 <code>fibonacci</code>，让你感受一点点小区别：</p>
<p>#include <iostream><br>
#include &lt;stdint.h&gt;<br>
#include &lt;boost/coroutine2/all.hpp&gt;</p>
<p>typedef boost::coroutines2::<br>
coroutine<const uint64_t><br>
coro_t;</p>
<p>void fibonacci(<br>
coro_t::push_type&amp; yield)<br>
{<br>
uint64_t a = 0;<br>
uint64_t b = 1;<br>
while (true) {<br>
yield(b);<br>
auto tmp = a;<br>
a = b;<br>
b += tmp;<br>
}<br>
}</p>
<p>int main()<br>
{<br>
for (auto i : coro_t::pull_type(<br>
boost::coroutines2::<br>
fixedsize_stack(),<br>
fibonacci)) {<br>
if (i &gt;= 10000) {<br>
break;<br>
}<br>
std::cout &laquo; i &laquo; std::endl;<br>
}<br>
}</p>
<h2 id="编译器支持">编译器支持</h2>
<p>前面提到了，MSVC 和 Clang 目前支持协程。不过，它们都需要特殊的命令行选项来开启协程支持：</p>
<ol>
<li>MSVC 需要 <code>/await</code> 命令行选项</li>
<li>Clang 需要 <code>-fcoroutines-ts</code> 命令行选项</li>
</ol>
<p>为了满足使用 CMake 的同学的要求，也为了方便大家编译，我把示例代码放到了 GitHub 上：</p>
<p><a href="https://github.com/adah1972/geek">https://github.com/adah1972/geek</a>_time_cpp</p>
<p>第一次我只放了第 30 讲的代码，但我会把其他的代码陆续补上。</p>
<h2 id="内容小结">内容小结</h2>
<p>本讲讨论了 C++20 里的第三个重要特性：协程。协程仍然很新，但它的重要性是毋庸置疑的——尤其在生成器和异步 I/O 上。</p>
<h2 id="课后思考">课后思考</h2>
<p>请仔细比较第一个 <code>fibonacci</code> 的 C++ 实现和最后使用 <code>generator</code> 的 <code>fibonacci</code> 的实现，体会协程代码如果自行用状态机的方式来实现，是一件多麻烦的事情。</p>
<p>如果你对协程有兴趣，可以查看参考资料 [5]，里面提供了一些较为深入的原理介绍。</p>
<h2 id="参考资料">参考资料</h2>
<p>[1] 维基百科，“协程”. <a href="https://zh.wikipedia.org/zh-cn/">https://zh.wikipedia.org/zh-cn/</a> 协程</p>
<p>[2] Gor Nishanov, “Working draft, C++ extensions for coroutines”. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf</a></p>
<p>[3] Lewis Baker, CppCoro. <a href="https://github.com/lewissbaker/cppcoro">https://github.com/lewissbaker/cppcoro</a></p>
<p>[4] Oliver Kowalke, Boost.Coroutine2. <a href="https://www.boost.org/doc/libs/release/libs/coroutine2/doc/html/index.html">https://www.boost.org/doc/libs/release/libs/coroutine2/doc/html/index.html</a></p>
<p>[5] Dawid Pilarski, “Coroutines introduction”. <a href="https://blog.panicsoftware.com/coroutines-introduction/">https://blog.panicsoftware.com/coroutines-introduction/</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/">现代C&#43;&#43;实战30讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%9838%E8%AE%B2/29%E7%BB%9F%E4%B8%80%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">29统一认证与授权如何保障服务安全？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/30__gpu%E4%B8%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%A9%E6%B8%B8%E6%88%8F%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8gpu/">
            <span class="next-text nav-default">30__GPU（上）：为什么玩游戏需要使用GPU？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
