<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>11__Unicode：进入多文字支持的世界 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是吴咏炜。
这一讲我们来讲一个新话题，Unicode。我们会从编码的历史谈起，讨论编程中对中文和多语言的支持，然后重点看一下 C&#43;&#43; 中应该如何处理这些问题。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/11__unicode%E8%BF%9B%E5%85%A5%E5%A4%9A%E6%96%87%E5%AD%97%E6%94%AF%E6%8C%81%E7%9A%84%E4%B8%96%E7%95%8C/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/11__unicode%E8%BF%9B%E5%85%A5%E5%A4%9A%E6%96%87%E5%AD%97%E6%94%AF%E6%8C%81%E7%9A%84%E4%B8%96%E7%95%8C/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="11__Unicode：进入多文字支持的世界">
  <meta property="og:description" content="你好，我是吴咏炜。
这一讲我们来讲一个新话题，Unicode。我们会从编码的历史谈起，讨论编程中对中文和多语言的支持，然后重点看一下 C&#43;&#43; 中应该如何处理这些问题。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="现代C&#43;&#43;实战30讲">

  <meta itemprop="name" content="11__Unicode：进入多文字支持的世界">
  <meta itemprop="description" content="你好，我是吴咏炜。
这一讲我们来讲一个新话题，Unicode。我们会从编码的历史谈起，讨论编程中对中文和多语言的支持，然后重点看一下 C&#43;&#43; 中应该如何处理这些问题。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6608">
  <meta itemprop="keywords" content="现代C&#43;&#43;实战30讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="11__Unicode：进入多文字支持的世界">
  <meta name="twitter:description" content="你好，我是吴咏炜。
这一讲我们来讲一个新话题，Unicode。我们会从编码的历史谈起，讨论编程中对中文和多语言的支持，然后重点看一下 C&#43;&#43; 中应该如何处理这些问题。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">11__Unicode：进入多文字支持的世界</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6608 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#一些历史">一些历史</a></li>
        <li><a href="#unicode-简介">Unicode 简介</a></li>
        <li><a href="#c-中的-unicode-字符类型">C++ 中的 Unicode 字符类型</a></li>
        <li><a href="#平台区别">平台区别</a>
          <ul>
            <li><a href="#unix">Unix</a></li>
            <li><a href="#windows">Windows</a></li>
            <li><a href="#统一化处理">统一化处理</a></li>
          </ul>
        </li>
        <li><a href="#编程支持">编程支持</a>
          <ul>
            <li><a href="#windows-api">Windows API</a></li>
            <li><a href="#iconv">iconv</a></li>
            <li><a href="#icu4c">ICU4C</a></li>
            <li><a href="#codecvt">codecvt</a></li>
          </ul>
        </li>
        <li><a href="#内容小结">内容小结</a></li>
        <li><a href="#课后思考">课后思考</a></li>
        <li><a href="#参考资料">参考资料</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是吴咏炜。</p>
<p>这一讲我们来讲一个新话题，Unicode。我们会从编码的历史谈起，讨论编程中对中文和多语言的支持，然后重点看一下 C++ 中应该如何处理这些问题。</p>
<h2 id="一些历史">一些历史</h2>
<p>ASCII [1] 是一种创立于 1963 年的 7 位编码，用 0 到 127 之间的数值来代表最常用的字符，包含了控制字符（很多在今天已不再使用）、数字、大小写拉丁字母、空格和基本标点。它在编码上具有简单性，字母和数字的编码位置非常容易记忆（相比之下，设计 EBCDIC [2] 的人感觉是脑子进了水，哦不，进了穿孔卡片了；难怪它和 IBM 的那些过时老古董一起已经几乎被人遗忘）。时至今日，ASCII 可以看作是字符编码的基础，主要的编码方式都保持着与 ASCII 的兼容性。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%8E%B0%E4%BB%A3C++%E5%AE%9E%E6%88%9830%E8%AE%B2/a491733af145fb1e2013f49fac259300.png" alt=""></p>
<p>ASCII 里只有基本的拉丁字母，它既没有带变音符的拉丁字母（如 é 和 ä），也不支持像希腊字母（如 α、β、γ）、西里尔字母（如 Пушкин）这样的其他欧洲文字（也难怪，毕竟它是 American Standard Code for Information Interchange）。很多其他编码方式纷纷应运而生，包括 ISO 646 系列、ISO/IEC 8859 系列等等；大部分编码方式都是头 128 个字符与 ASCII 兼容，后 128 个字符是自己的扩展，总共最多是 256 个字符。每次只有一套方式可以生效，称之为一个代码页（code page）。这种做法，只能适用于文字相近、且字符数不多的国家。比如，下图表示了 ISO-8859-1（也称作 Latin-1）和后面的 Windows 扩展代码页 1252（下图中绿框部分为 Windows 的扩展），就只能适用于西欧国家。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%8E%B0%E4%BB%A3C++%E5%AE%9E%E6%88%9830%E8%AE%B2/9d46692cc2ba5479ba79823abf24d1a1.png" alt=""></p>
<p>最早的中文字符集标准是 1980 年的国标 GB2312 [3]，其中收录了 6763 个常用汉字和 682 个其他符号。我们平时会用到编码 GB2312，其实更正确的名字是 EUC-CN [4]，它是一种与 ASCII 兼容的编码方式。它用单字节表示 ASCII 字符而用双字节表示 GB2312 中的字符；由于 GB2312 中本身也含有 ASCII 中包含的字符，在使用中逐渐就形成了“半角”和“全角”的区别。</p>
<p>国标字符集后面又有扩展，这个扩展后的字符集就是 GBK [5]，是中文版 Windows 使用的标准编码方式。GB2312 和 GBK 所占用的编码位置可以参看下面的图（由 John M. Długosz 为 Wikipedia 绘制）：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%8E%B0%E4%BB%A3C++%E5%AE%9E%E6%88%9830%E8%AE%B2/5210800c4f95dc005b898d6283ac4775.png" alt=""></p>
<p>图中 GBK/1 和 GBK/2 为 GB2312 中已经定义的区域，其他的则是后面添加的字符，总共定义了两万多个编码点，支持了绝大部分现代汉语中还在使用的字。</p>
<p>Unicode [6] 作为一种统一编码的努力，诞生于八十年代末九十年代初，标准的第一版出版于 1991—1992 年。由于最初发明者的目标放得太低，只期望对活跃使用中的现代文字进行编码，他们认为 16 比特的“宽 ASCII”就够用了。这就导致了早期采纳 Unicode 的组织，特别是微软，在其操作系统和工具链中广泛采用了 16 比特的编码方式。在今天，微软的系统中宽字符类型 wchar_t 仍然是 16 位的，操作系统底层接口大量使用 16 位字符编码的 API，说到 Unicode 编码时仍然指的是 16 位的编码 UTF-16（这一不太正确的名字，跟中文 GBK 编码居然可以被叫做 ANSI 相比，实在是小巫见大巫了）。在微软以外的世界，Unicode 本身不作编码名称用，并且最主流的编码方式并不是 UTF-16，而是和 ASCII 全兼容的 UTF-8。</p>
<p>早期 Unicode 组织的另一个决定是不同语言里的同一个字符使用同一个编码点，来减少总编码点的数量。中日韩三国使用的汉字就这么被统一了：像“将”、“径”、“网”等字，每个字在 Unicode 中只占一个编码点。这对网页的字体选择也造成了不少麻烦，时至今日我们仍然可以看到这个问题 [10]。不过这和我们的主题无关，就不再多费笔墨了。</p>
<h2 id="unicode-简介">Unicode 简介</h2>
<p>Unicode 在今天已经大大超出了最初的目标。到 Unicode 12.1 为止，Unicode 已经包含了 137,994 个字符，囊括所有主要语言（使用中的和已经不再使用的），并包含了表情符号、数学符号等各种特殊字符。仍然要指出一下，Unicode 字符是根据含义来区分的，而非根据字形。除了前面提到过中日韩汉字没有分开，像斜体（italics）、小大写字母（small caps）等排版效果在 Unicode 里也没有独立的对应。不过，因为 Unicode 里包含了很多数学、物理等自然科学中使用的特殊符号，某些情况下你也可以找到对应的符号，可以用在聊天中耍酷，如 𝒷𝒶𝒹（但不适合严肃的排版）。</p>
<p>Unicode 的编码点是从 0x0 到 0x10FFFF，一共 1,114,112 个位置。一般用“U+”后面跟 16 进制的数值来表示一个 Unicode 字符，如 U+0020 表示空格，U+6C49 表示“汉”，U+1F600 表示“😀”，等等（不足四位的一般写四位）。</p>
<p>Unicode 字符的常见编码方式有：</p>
<ol>
<li>UTF-32 [7]：32 比特，是编码点的直接映射。</li>
<li>UTF-16 [8]：对于从 U+0000 到 U+FFFF 的字符，使用 16 比特的直接映射；对于大于 U+FFFF 的字符，使用 32 比特的特殊映射关系——在 Unicode 的 16 比特编码点中 0xD800–0xDFFF 是一段空隙，使得这种变长编码成为可能。在一个 UTF-16 的序列中，如果看到内容是 0xD800–0xDBFF，那这就是 32 比特编码的前 16 比特；如果看到内容是 0xDC00–0xDFFF，那这是 32 比特编码的后 16 比特；如果内容在 0xD800–0xDFFF 之外，那就是一个 16 比特的映射。</li>
<li>UTF-8 [9]：1 到 4 字节的变长编码。在一个合法的 UTF-8 的序列中，如果看到一个字节的最高位是 0，那就是一个单字节的 Unicode 字符；如果一个字节的最高两比特是 10，那这是一个 Unicode 字符在编码后的后续字节；否则，这就是一个 Unicode 字符在编码后的首字节，且最高位开始连续 1 的个数表示了这个字符按 UTF-8 的方式编码有几个字节。</li>
</ol>
<p>在上面三种编码方式里，只有 UTF-8 完全保持了和 ASCII 的兼容性，目前得到了最广泛的使用。在我们下面讲具体编码方式之前，我们先看一下上面提到的三个字符在这三种方式下的编码结果：</p>
<ol>
<li>UTF-32：U+0020 映射为 0x00000020，U+6C49 映射为 0x00006C49，U+1F600 映射为 0x0001F600。</li>
<li>UTF-16：U+0020 映射为 0x0020，U+6C49 映射为 0x6C49，而 U+1F600 会映射为 0xD83D DE00。</li>
<li>UTF-8：U+0020 映射为 0x20，U+6C49 映射为 0xE6 B1 89，而 U+1F600 会映射为 0xF0 9F 98 80。</li>
</ol>
<p>Unicode 有好几种（上面还不是全部）不同的编码方式，上面的 16 比特和 32 比特编码方式还有小头党和大头党之争（“汉”按字节读取时是 6C 49 呢，还是 49 6C？）；同时，任何一种编码方式还需要跟传统的编码方式容易区分。因此，Unicode 文本文件通常有一个使用 BOM（byte order mark）字符的约定，即字符 U+FEFF [11]。由于 Unicode 不使用 U+FFFE，在文件开头加一个 BOM 即可区分各种不同编码：</p>
<ol>
<li>如果文件开头是 0x00 00 FE FF，那这是大头在前的 UTF-32 编码；</li>
<li>否则如果文件开头是 0xFF FE 00 00，那这是小头在前的 UTF-32 编码；</li>
<li>否则如果文件开头是 0xFE FF，那这是大头在前的 UTF-16 编码；</li>
<li>否则如果文件开头是 0xFF FE，那这是小头在前的 UTF-16 编码（注意，这条规则和第二条的顺序不能相反）；</li>
<li>否则如果文件开头是 0xEF BB BF，那这是 UTF-8 编码；</li>
<li>否则，编码方式使用其他算法来确定。</li>
</ol>
<p>编辑器可以（有些在配置之后）根据 BOM 字符来自动决定文本文件的编码。比如，我一般在 Vim 中配置 <code>set fileencodings=ucs-bom,utf-8,gbk,latin1</code>。这样，Vim 在读入文件时，会首先检查 BOM 字符，有 BOM 字符按 BOM 字符决定文件编码；否则，试图将文件按 UTF-8 来解码（由于 UTF-8 有格式要求，非 UTF-8 编码的文件通常会导致失败）；不行，则试图按 GBK 来解码（失败的概率就很低了）；还不行，就把文件当作 Latin1 来处理（永远不会失败）。</p>
<p>在 UTF-8 编码下使用 BOM 字符并非必需，尤其在 Unix 上。但 Windows 上通常会使用 BOM 字符，以方便区分 UTF-8 和传统编码。</p>
<h2 id="c-中的-unicode-字符类型">C++ 中的 Unicode 字符类型</h2>
<p>C++98 中有 <code>char</code> 和 <code>wchar_t</code> 两种不同的字符类型，其中 <code>char</code> 的长度是单字节，而 <code>wchar_t</code> 的长度不确定。在 Windows 上它是双字节，只能代表 UTF-16，而在 Unix 上一般是四字节，可以代表 UTF-32。为了解决这种混乱，目前我们有了下面的改进：</p>
<ol>
<li>C++11 引入了 <code>char16_t</code> 和 <code>char32_t</code> 两个独立的字符类型（不是类型别名），分别代表 UTF-16 和 UTF-32。</li>
<li>C++20 将引入 <code>char8_t</code> 类型，进一步区分了可能使用传统编码的窄字符类型和 UTF-8 字符类型。</li>
<li>除了 <code>string</code> 和 <code>wstring</code>，我们也相应地有了 <code>u16string</code>、<code>u32string</code>（和将来的 <code>u8string</code>）。</li>
<li>除了传统的窄字符 / 字符串字面量（如 <code>&quot;hi&quot;</code>）和宽字符 / 字符串字面量（如 <code>L&quot;hi&quot;</code>），引入了新的 UTF-8、UTF-16 和 UTF-32 字面量，分别形如 <code>u8&quot;hi&quot;</code>、<code>u&quot;hi&quot;</code> 和 <code>U&quot;hi&quot;</code>。</li>
<li>为了确保非 ASCII 字符在源代码中可以简单地输入，引入了新的 Unicode 换码序列。比如，我们前面说到的三个字符可以这样表达成一个 UTF-32 字符串字面量：<code>U&quot; \u6C49\U0001F600&quot;</code>。要生成 UTF-16 或 UTF-8 字符串字面量只需要更改前缀即可。</li>
</ol>
<p>使用这些新的字符（串）类型，我们可以用下面的代码表达出 UTF-32 和其他两种 UTF 编码间是如何转换的：</p>
<p>#include <iomanip><br>
#include <iostream><br>
#include <stdexcept><br>
#include <string></p>
<p>using namespace std;</p>
<p>const char32_t unicode_max =<br>
0x10FFFF;</p>
<p>void to_utf_16(char32_t ch,<br>
u16string&amp; result)<br>
{<br>
if (ch &gt; unicode_max) {<br>
throw runtime_error(<br>
&ldquo;invalid code point&rdquo;);<br>
}<br>
if (ch &lt; 0x10000) {<br>
result += char16_t(ch);<br>
} else {<br>
char16_t first =<br>
0xD800 |<br>
((ch - 0x10000) &raquo; 10);<br>
char16_t second =<br>
0xDC00 | (ch &amp; 0x3FF);<br>
result += first;<br>
result += second;<br>
}<br>
}</p>
<p>void to_utf_8(char32_t ch,<br>
string&amp; result)<br>
{<br>
if (ch &gt; unicode_max) {<br>
throw runtime_error(<br>
&ldquo;invalid code point&rdquo;);<br>
}<br>
if (ch &lt; 0x80) {<br>
result += ch;<br>
} else if (ch &lt; 0x800) {<br>
result += 0xC0 | (ch &raquo; 6);<br>
result += 0x80 | (ch &amp; 0x3F);<br>
} else if (ch &lt; 0x10000) {<br>
result += 0xE0 | (ch &raquo; 12);<br>
result +=<br>
0x80 | ((ch &raquo; 6) &amp; 0x3F);<br>
result += 0x80 | (ch &amp; 0x3F);<br>
} else {<br>
result += 0xF0 | (ch &raquo; 18);<br>
result +=<br>
0x80 | ((ch &raquo; 12) &amp; 0x3F);<br>
result +=<br>
0x80 | ((ch &raquo; 6) &amp; 0x3F);<br>
result += 0x80 | (ch &amp; 0x3F);<br>
}<br>
}</p>
<p>int main()<br>
{<br>
char32_t str[] =<br>
U&quot; \u6C49\U0001F600&quot;;<br>
u16string u16str;<br>
string u8str;<br>
for (auto ch : str) {<br>
if (ch == 0) {<br>
break;<br>
}<br>
to_utf_16(ch, u16str);<br>
to_utf_8(ch, u8str);<br>
}<br>
cout &laquo; hex &laquo; setfill(&lsquo;0&rsquo;);<br>
for (char16_t ch : u16str) {<br>
cout &laquo; setw(4) &laquo; unsigned(ch)<br>
&laquo; &rsquo; &lsquo;;<br>
}<br>
cout &laquo; endl;<br>
for (unsigned char ch : u8str) {<br>
cout &laquo; setw(2) &laquo; unsigned(ch)<br>
&laquo; &rsquo; &lsquo;;<br>
}<br>
cout &laquo; endl;<br>
}</p>
<p>输出结果是：</p>
<blockquote>
<p><code>0020 6c49 d83d de00</code></p>
<p><code>20 e6 b1 89 f0 9f 98 80</code></p>
</blockquote>
<h2 id="平台区别">平台区别</h2>
<p>下面我们看一下在两个主流的平台上一般是如何处理 Unicode 编码问题的。</p>
<h3 id="unix">Unix</h3>
<p>现代 Unix 系统，包括 Linux 和 macOS 在内，已经全面转向了 UTF-8。这样的系统中一般直接使用 <code>char[]</code> 和 <code>string</code> 来代表 UTF-8 字符串，包括输入、输出和文件名，非常简单。不过，由于一个字符单位不能代表一个完整的 Unicode 字符，在需要真正进行文字处理的场合转换到 UTF-32 往往会更简单。在以前及需要和 C 兼容的场合，会使用 <code>wchar_t</code>、<code>uint32_t</code> 或某个等价的类型别名；在新的纯 C++ 代码里，就没有理由不使用 <code>char32_t</code> 和 <code>u32string</code> 了。</p>
<p>Unix 下输出宽字符串需要使用 <code>wcout</code>（这点和 Windows 相同），并且需要进行区域设置，通常使用 <code>setlocale(LC_ALL, &quot;en_US.UTF-8&quot;);</code> 即足够。由于没有什么额外好处，Unix 平台下一般只用 <code>cout</code>，不用 <code>wcout</code>。</p>
<h3 id="windows">Windows</h3>
<p>Windows 由于历史原因和保留向后兼容性的需要（Windows 为了向后兼容性已经到了大规模放弃优雅的程度了），一直用 <code>char</code> 表示传统编码（如，英文 Windows 上是 Windows-1252，简体中文 Windows 上是 GBK），用 <code>wchar_t</code> 表示 UTF-16。由于传统编码一次只有一种、且需要重启才能生效，要得到好的多语言支持，在和操作系统交互时必须使用 UTF-16。</p>
<p>对于纯 Windows 编程，全面使用宽字符（串）是最简单的处理方式。当然，源代码和文本很少用 UTF-16 存储，通常还是 UTF-8（除非是纯 ASCII，否则需要加入 BOM 字符来和传统编码相区分）。这时可能会有一个小小的令人惊讶的地方：微软的编译器会把源代码里窄字符串字面量中的非 ASCII 字符转换成传统编码。换句话说，同样的源代码在不同编码的 Windows 下编译可能会产生不同的结果！如果你希望保留 UTF-8 序列的话，就应该使用 UTF-8 字面量（并在将来使用 <code>char8_t</code> 字符类型）。</p>
<p>#include &lt;stdio.h&gt;</p>
<p>template <typename T><br>
void dump(const T&amp; str)<br>
{<br>
for (char ch : str) {<br>
printf(<br>
&ldquo;%.2x &ldquo;,<br>
static_cast<unsigned char>(ch));<br>
}<br>
putchar(&rsquo;\n&rsquo;);<br>
}</p>
<p>int main()<br>
{<br>
char str[] = &ldquo;你好&rdquo;;<br>
char u8str[] = u8&quot;你好&rdquo;;<br>
dump(str);<br>
dump(u8str);<br>
}</p>
<p>下面展示的是以上代码在 Windows 下系统传统编码设置为简体中文时的编译、运行结果：</p>
<blockquote>
<p><code>c4 e3 ba c3 00</code></p>
<p><code>e4 bd a0 e5 a5 bd 00</code></p>
</blockquote>
<p>Windows 下的 <code>wcout</code> 主要用在配合宽字符的输出，此外没什么大用处。原因一样，只有进行了正确的区域设置，才能输出含非 ASCII 字符的宽字符串。如果要输出中文，得写 <code>setlocale(LC_ALL, &quot;Chinese_China.936&quot;);</code>，这显然就让“统一码”输出失去意义了。</p>
<p>由于窄字符在大部分 Windows 系统上只支持传统编码，要打开一个当前编码不支持的文件名称，就必需使用宽字符的文件名。微软的 <code>fstream</code> 系列类及其 <code>open</code> 成员函数都支持 <code>const wchar_t*</code> 类型的文件名，这是 C++ 标准里所没有的。</p>
<h3 id="统一化处理">统一化处理</h3>
<p>要想写出跨平台的处理字符串的代码，我们一般考虑两种方式之一：</p>
<ol>
<li>源代码级兼容，但内码不同</li>
<li>源代码和内码都完全兼容</li>
</ol>
<p>微软推荐的方式一般是前者。做 Windows 开发的人很多都知道 tchar.h 和 <code>_T</code> 宏，它们就起着类似的作用（虽然目的不同）。根据预定义宏的不同，系统会在同一套代码下选择不同的编码方式及对应的函数。拿一个最小的例子来说：</p>
<p>#include &lt;stdio.h&gt;<br>
#include &lt;tchar.h&gt;</p>
<p>int _tmain(int argc, TCHAR* argv[])<br>
{<br>
_putts(_T(&ldquo;Hello world!\n&rdquo;));<br>
}</p>
<p>如果用缺省的命令行参数进行编译，上面的代码相当于：</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main(int argc, char* argv[])<br>
{<br>
puts(&ldquo;Hello world!\n&rdquo;);<br>
}</p>
<p>而如果在命令行上加上了 <code>/D_UNICODE</code>，那代码则相当于：</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int wmain(int argc, wchar_t* argv[])<br>
{<br>
_putws(L&quot;Hello world!\n&rdquo;);<br>
}</p>
<p>当然，这个代码还是只能在 Windows 上用，并且仍然不漂亮（所有的字符和字符串字面量都得套上 <code>_T</code>）。后者无解，前者则可以找到替代方案（甚至自己写也不复杂）。C++ REST SDK 中就提供了类似的封装，可以跨平台地开发网络应用。但可以说，这种方式是一种主要照顾 Windows 的开发方式。</p>
<p>相应的，对 Unix 开发者而言更自然的方式是全面使用 UTF-8，仅在跟操作系统、文件系统打交道时把字符串转换成需要的编码。利用临时对象的生命周期，我们可以像下面这样写帮助函数和宏。</p>
<p>utf8_to_native.hpp：</p>
<p>#ifndef UTF8_TO_NATIVE_HPP<br>
#define UTF8_TO_NATIVE_HPP</p>
<p>#include <string></p>
<p>#if defined(_WIN32) || \<br>
defined(_UNICODE)</p>
<p>std::wstring utf8_to_wstring(<br>
const char* str);<br>
std::wstring utf8_to_wstring(<br>
const std::string&amp; str);</p>
<p>#define NATIVE_STR(s) \<br>
utf8_to_wstring(s).c_str()</p>
<p>#else</p>
<p>inline const char*<br>
to_c_str(const char* str)<br>
{<br>
return str;<br>
}</p>
<p>inline const char*<br>
to_c_str(const std::string&amp; str)<br>
{<br>
return str.c_str();<br>
}</p>
<p>#define NATIVE_STR(s) \<br>
to_c_str(s)</p>
<p>#endif</p>
<p>#endif // UTF8_TO_NATIVE_HPP</p>
<p>utf8_to_native.cpp：</p>
<p>#include &ldquo;utf8_to_native.hpp&rdquo;</p>
<p>#if defined(_WIN32) || \<br>
defined(_UNICODE)<br>
#include &lt;windows.h&gt;<br>
#include &lt;system_error&gt;</p>
<p>namespace {</p>
<p>void throw_system_error(<br>
const char* reason)<br>
{<br>
std::string msg(reason);<br>
msg += &quot; failed&quot;;<br>
std::error_code ec(<br>
GetLastError(),<br>
std::system_category());<br>
throw std::system_error(ec, msg);<br>
}</p>
<p>} /* unnamed namespace */</p>
<p>std::wstring utf8_to_wstring(<br>
const char* str)<br>
{<br>
int len = MultiByteToWideChar(<br>
CP_UTF8, 0, str, -1,<br>
nullptr, 0);<br>
if (len == 0) {<br>
throw_system_error(<br>
&ldquo;utf8_to_wstring&rdquo;);<br>
}<br>
std::wstring result(len - 1,<br>
L&rsquo;\0&rsquo;);<br>
if (MultiByteToWideChar(<br>
CP_UTF8, 0, str, -1,<br>
result.data(), len) == 0) {<br>
throw_system_error(<br>
&ldquo;utf8_to_wstring&rdquo;);<br>
}<br>
return result;<br>
}</p>
<p>std::wstring utf8_to_wstring(<br>
const std::string&amp; str)<br>
{<br>
return utf8_to_wstring(<br>
str.c_str());<br>
}</p>
<p>#endif</p>
<p>在头文件里，定义了在 Windows 下会做 UTF-8 到 UTF-16 的转换；在其他环境下则不真正做转换，而是不管提供的是字符指针还是 <code>string</code> 都会转换成字符指针。在 Windows 下每次调用 <code>NATIVE_STR</code> 会生成一个临时对象，当前语句执行结束后这个临时对象会自动销毁。</p>
<p>使用该功能的代码是这样的：</p>
<p>#include <fstream><br>
#include &ldquo;utf8_to_native.hpp&rdquo;</p>
<p>int main()<br>
{<br>
using namespace std;<br>
const char filename[] =<br>
u8&quot;测试.txt&quot;;<br>
ifstream ifs(<br>
NATIVE_STR(filename));<br>
//  对  ifs  进行操作<br>
｝</p>
<p>上面这样的代码可以同时适用于现代 Unix 和现代 Windows（任何语言设置下），用来读取名为“测试.txt”的文件。</p>
<h2 id="编程支持">编程支持</h2>
<p>结束之前，我们快速介绍一下其他的一些支持 Unicode 及其转换的 API。</p>
<h3 id="windows-api">Windows API</h3>
<p>上一节的代码在 Windows 下用到了 <code>MultiByteToWideChar</code> [12]，从某个编码转到 UTF-16。Windows 也提供了反向的 <code>WideCharToMultiByte</code> [13]，从 UTF-16 转到某个编码。从上面可以看到，C 接口用起来并不方便，可以考虑自己封装一下。</p>
<h3 id="iconv">iconv</h3>
<p>Unix 下最常用的底层编码转换接口是 iconv [14]，提供 <code>iconv_open</code>、<code>iconv_close</code> 和 <code>iconv</code> 三个函数。这同样是 C 接口，实践中应该封装一下。</p>
<h3 id="icu4c">ICU4C</h3>
<p>ICU [15] 是一个完整的 Unicode 支持库，提供大量的方法，ICU4C 是其 C/C++ 的版本。ICU 有专门的字符串类型，内码是 UTF-16，但可以直接用于 IO streams 的输出。下面的程序应该在所有平台上都有同样的输出（但在 Windows 上要求当前系统传统编码能支持待输出的字符）：</p>
<p>#include <iostream><br>
#include <string><br>
#include &lt;unicode/unistr.h&gt;<br>
#include &lt;unicode/ustream.h&gt;</p>
<p>using namespace std;<br>
using icu::UnicodeString;</p>
<p>int main()<br>
{<br>
auto str = UnicodeString::fromUTF8(<br>
u8&quot;你好&quot;);<br>
cout &laquo; str &laquo; endl;<br>
string u8str;<br>
str.toUTF8String(u8str);<br>
cout &laquo; &ldquo;In UTF-8 it is &quot;<br>
&laquo; u8str.size() &laquo; &quot; bytes&rdquo;<br>
&laquo; endl;<br>
}</p>
<h3 id="codecvt">codecvt</h3>
<p>C++11 曾经引入了一个头文件 <codecvt> [16] 用作 UTF 编码间的转换，但很遗憾，那个头文件目前已因为存在安全性和易用性问题被宣告放弃（deprecated）[17]。<locale> 中有另外一个 codecvt 模板 [18]，本身接口不那么好用，而且到 C++20 还会发生变化，这儿也不详细介绍了。有兴趣的话可以直接看参考资料。</p>
<h2 id="内容小结">内容小结</h2>
<p>本讲我们讨论了 Unicode，以及 C++ 中对 Unicode 的支持。我们也讨论了在两大主流桌面平台上关于 Unicode 编码支持的一些惯用法。希望你在本讲之后，能清楚地知道 Unicode 和各种 UTF 编码是怎么回事。</p>
<h2 id="课后思考">课后思考</h2>
<p>请思考一下：</p>
<ol>
<li>为什么说 UTF-32 处理会比较简单？</li>
<li>你知道什么情况下 UTF-32 也并不那么简单吗？</li>
<li>哪种 UTF 编码方式空间存储效率比较高？</li>
</ol>
<p>欢迎留言一起讨论一下。</p>
<h2 id="参考资料">参考资料</h2>
<p>[1] Wikipedia, “ASCII”. <a href="https://en.wikipedia.org/wiki/ASCII">https://en.wikipedia.org/wiki/ASCII</a></p>
<p>[2] Wikipedia, “EBCDIC”. <a href="https://en.wikipedia.org/wiki/EBCDIC">https://en.wikipedia.org/wiki/EBCDIC</a></p>
<p>[3] Wikipedia, “GB 2312”. <a href="https://en.wikipedia.org/wiki/GB">https://en.wikipedia.org/wiki/GB</a>_2312</p>
<p>[3a] 维基百科，“GB 2312”. <a href="https://zh.wikipedia.org/zh-cn/GB">https://zh.wikipedia.org/zh-cn/GB</a>_2312</p>
<p>[4] Wikipedia, “EUC-CN”. <a href="https://en.wikipedia.org/wiki/Extended">https://en.wikipedia.org/wiki/Extended</a>_Unix_Code#EUC-CN</p>
<p>[4a] 维基百科，“EUC-CN”. <a href="https://zh.wikipedia.org/zh-cn/EUC#EUC-CN">https://zh.wikipedia.org/zh-cn/EUC#EUC-CN</a></p>
<p>[5] Wikipedia, “GBK”. <a href="https://en.wikipedia.org/wiki/GBK">https://en.wikipedia.org/wiki/GBK</a>_(character_encoding)</p>
<p>[5a] 维基百科，“汉字内码扩展规范”. <a href="https://zh.wikipedia.org/zh-cn/">https://zh.wikipedia.org/zh-cn/</a> 汉字内码扩展规范</p>
<p>[6] Wikipedia, “Unicode”. <a href="https://en.wikipedia.org/wiki/Unicode">https://en.wikipedia.org/wiki/Unicode</a></p>
<p>[6a] 维基百科，“Unicode”. <a href="https://zh.wikipedia.org/zh-cn/Unicode">https://zh.wikipedia.org/zh-cn/Unicode</a></p>
<p>[7] Wikipedia, “UTF-32”. <a href="https://en.wikipedia.org/wiki/UTF-32">https://en.wikipedia.org/wiki/UTF-32</a></p>
<p>[8] Wikipedia, “UTF-16”. <a href="https://en.wikipedia.org/wiki/UTF-16">https://en.wikipedia.org/wiki/UTF-16</a></p>
<p>[9] Wikipedia, “UTF-8”. <a href="https://en.wikipedia.org/wiki/UTF-8">https://en.wikipedia.org/wiki/UTF-8</a></p>
<p>[10] 吴咏炜，“Specify LANG in a UTF-8 web page”. <a href="http://wyw.dcweb.cn/lang">http://wyw.dcweb.cn/lang</a>_utf8.htm</p>
<p>[11] Wikipedia, “Byte order mark”. <a href="https://en.wikipedia.org/wiki/Byte">https://en.wikipedia.org/wiki/Byte</a>_order_mark</p>
<p>[11a] 维基百科，“字节顺序标记”. <a href="https://zh.wikipedia.org/zh-cn/">https://zh.wikipedia.org/zh-cn/</a> 位元組順序記號</p>
<p>[12] Microsoft, “MultiByteToWideChar function”. <a href="https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar">https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar</a></p>
<p>[13] Microsoft, “WideCharToMultiByte function”. <a href="https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte">https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte</a></p>
<p>[14] Wikipedia, “iconv”. <a href="https://en.wikipedia.org/wiki/Iconv">https://en.wikipedia.org/wiki/Iconv</a></p>
<p>[15] ICU Technical Committee, ICU—International Components for Unicode. <a href="http://site.icu-project.org/">http://site.icu-project.org/</a></p>
<p>[16] cppreference.com, “Standard library header <codecvt>”. <a href="https://en.cppreference.com/w/cpp/header/codecvt">https://en.cppreference.com/w/cpp/header/codecvt</a></p>
<p>[17] Alisdair Meredith, “Deprecating <codecvt>”. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0618r0.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0618r0.html</a></p>
<p>[18] cppreference.com, “std::codecvt”. <a href="https://en.cppreference.com/w/cpp/locale/codecvt">https://en.cppreference.com/w/cpp/locale/codecvt</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/">现代C&#43;&#43;实战30讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/11__throw_1%E5%AE%83%E5%9C%A8%E6%9C%80%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95%E6%A6%9C%E4%B8%8A%E6%8E%92%E5%90%8D%E7%AC%AC%E4%B8%89/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">11__throw_1;：它在“最简单语法榜”上排名第三</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/webassembly%E5%85%A5%E9%97%A8%E8%AF%BE/11__webassembly_%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E5%A4%9A%E5%AA%92%E4%BD%93%E4%B8%8E%E4%BA%91%E6%8A%80%E6%9C%AF%E6%96%B9%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5/">
            <span class="next-text nav-default">11__WebAssembly_在物联网、多媒体与云技术方面有哪些创新实践？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
