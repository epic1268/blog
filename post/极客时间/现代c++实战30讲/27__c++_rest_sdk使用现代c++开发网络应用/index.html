<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>27__C&#43;&#43;_REST_SDK：使用现代C&#43;&#43;开发网络应用 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是吴咏炜。
在实战篇，我们最后要讲解的一个库是 C&#43;&#43; REST SDK（也写作 cpprestsdk）[1]，一个支持 HTTP 协议 [2]、主要用于 RESTful [3] 接口开发的 C&#43;&#43; 库。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/27__c&#43;&#43;_rest_sdk%E4%BD%BF%E7%94%A8%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%BC%80%E5%8F%91%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/27__c&#43;&#43;_rest_sdk%E4%BD%BF%E7%94%A8%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%BC%80%E5%8F%91%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="27__C&#43;&#43;_REST_SDK：使用现代C&#43;&#43;开发网络应用">
  <meta property="og:description" content="你好，我是吴咏炜。
在实战篇，我们最后要讲解的一个库是 C&#43;&#43; REST SDK（也写作 cpprestsdk）[1]，一个支持 HTTP 协议 [2]、主要用于 RESTful [3] 接口开发的 C&#43;&#43; 库。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="现代C&#43;&#43;实战30讲">

  <meta itemprop="name" content="27__C&#43;&#43;_REST_SDK：使用现代C&#43;&#43;开发网络应用">
  <meta itemprop="description" content="你好，我是吴咏炜。
在实战篇，我们最后要讲解的一个库是 C&#43;&#43; REST SDK（也写作 cpprestsdk）[1]，一个支持 HTTP 协议 [2]、主要用于 RESTful [3] 接口开发的 C&#43;&#43; 库。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5608">
  <meta itemprop="keywords" content="现代C&#43;&#43;实战30讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="27__C&#43;&#43;_REST_SDK：使用现代C&#43;&#43;开发网络应用">
  <meta name="twitter:description" content="你好，我是吴咏炜。
在实战篇，我们最后要讲解的一个库是 C&#43;&#43; REST SDK（也写作 cpprestsdk）[1]，一个支持 HTTP 协议 [2]、主要用于 RESTful [3] 接口开发的 C&#43;&#43; 库。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">27__C&#43;&#43;_REST_SDK：使用现代C&#43;&#43;开发网络应用</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5608 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#初识-c-rest-sdk">初识 C++ REST SDK</a></li>
        <li><a href="#安装和编译">安装和编译</a></li>
        <li><a href="#概述">概述</a></li>
        <li><a href="#异步流">异步流</a></li>
        <li><a href="#json-支持">JSON 支持</a></li>
        <li><a href="#http-服务器">HTTP 服务器</a></li>
        <li><a href="#关于线程的细节">关于线程的细节</a></li>
        <li><a href="#内容小结">内容小结</a></li>
        <li><a href="#课后思考">课后思考</a></li>
        <li><a href="#参考资料">参考资料</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是吴咏炜。</p>
<p>在实战篇，我们最后要讲解的一个库是 C++ REST SDK（也写作 cpprestsdk）[1]，一个支持 HTTP 协议 [2]、主要用于 RESTful [3] 接口开发的 C++ 库。</p>
<h2 id="初识-c-rest-sdk">初识 C++ REST SDK</h2>
<p>向你提一个问题，你认为用多少行代码可以写出一个类似于 curl [4] 的 HTTP 客户端？</p>
<p>使用 C++ REST SDK 的话，答案是，只需要五十多行有效代码（即使是适配到我们目前的窄小的手机屏幕上）。请看：</p>
<p>#include <iostream><br>
#ifdef _WIN32<br>
#include &lt;fcntl.h&gt;<br>
#include &lt;io.h&gt;<br>
#endif<br>
#include &lt;cpprest/http_client.h&gt;</p>
<p>using namespace utility;<br>
using namespace web::http;<br>
using namespace web::http::client;<br>
using std::cerr;<br>
using std::endl;</p>
<p>#ifdef _WIN32<br>
#define tcout std::wcout<br>
#else<br>
#define tcout std::cout<br>
#endif</p>
<p>auto get_headers(http_response resp)<br>
{<br>
auto headers = resp.to_string();<br>
auto end =<br>
headers.find(U(&quot;\r\n\r\n&quot;));<br>
if (end != string_t::npos) {<br>
headers.resize(end + 4);<br>
};<br>
return headers;<br>
}</p>
<p>auto get_request(string_t uri)<br>
{<br>
http_client client{uri};<br>
// 用 GET 方式发起一个客户端请求<br>
auto request =<br>
client.request(methods::GET)<br>
.then(<a href="./http_response_resp.md"></a> {<br>
if (resp.status_code() !=<br>
status_codes::OK) {<br>
// 不 OK，显示当前响应信息<br>
auto headers =<br>
get_headers(resp);<br>
tcout &laquo; headers;<br>
}<br>
// 进一步取出完整响应<br>
return resp<br>
.extract_string();<br>
})<br>
.then(<a href="./string_t_str.md"></a> {<br>
// 输出到终端<br>
tcout &laquo; str;<br>
});<br>
return request;<br>
}</p>
<p>#ifdef _WIN32<br>
int wmain(int argc, wchar_t* argv[])<br>
#else<br>
int main(int argc, char* argv[])<br>
#endif<br>
{<br>
#ifdef _WIN32<br>
_setmode(_fileno(stdout),<br>
_O_WTEXT);<br>
#endif</p>
<p>if (argc != 2) {<br>
cerr &laquo; &ldquo;A URL is needed\n&rdquo;;<br>
return 1;<br>
}</p>
<p>// 等待请求及其关联处理全部完成<br>
try {<br>
auto request =<br>
get_request(argv[1]);<br>
request.wait();<br>
}<br>
// 处理请求过程中产生的异常<br>
catch (const std::exception&amp; e) {<br>
cerr &laquo; &ldquo;Error exception: &quot;<br>
&laquo; e.what() &laquo; endl;<br>
return 1;<br>
}<br>
}</p>
<p>这个代码有点复杂，需要讲解一下：</p>
<ol>
<li>第 14–18 行，我们根据平台来定义 <code>tcout</code>，确保多语言的文字能够正确输出。</li>
<li>第 20–29 行，我们定义了 <code>get_headers</code>，来从 <code>http_response</code> 中取出头部的字符串表示。</li>
<li>第 36 行，构造了一个客户端请求，并使用 <code>then</code> 方法串联了两个下一步的动作。<code>http_client::request</code> 的返回值是 <code>pplx::task&lt;http_response&gt;</code>。<code>then</code> 是 <code>pplx::task</code> 类模板的成员函数，参数是能接受其类型参数对象的函数对象。除了最后一个 <code>then</code> 块，其他每个 <code>then</code> 里都应该返回一个 <code>pplx::task</code>，而 <code>task</code> 的内部类型就是下一个 <code>then</code> 块里函数对象接受的参数的类型。</li>
<li>第 37 行开始，是第一段异步处理代码。参数类型是 <code>http_response</code>——因为<code>http_client::request</code> 的返回值是 <code>pplx::task&lt;http_response&gt;</code>。代码中判断如果响应的 HTTP 状态码不是 200 OK，就会显示响应头来帮助调试。然后，进一步取出所有的响应内容（可能需要进一步的异步处理，等待后续的 HTTP 响应到达）。</li>
<li>第 49 行开始，是第二段异步处理代码。参数类型是 <code>string_t</code>——因为上一段 <code>then</code> 块的返回值是 <code>pplx::task&lt;string_t&gt;</code>。代码中就是简单地把需要输出的内容输出到终端。</li>
<li>第 56–60 行，我们根据平台来定义合适的程序入口，确保命令行参数的正确处理。</li>
<li>第 62–65 行，在 Windows 上我们把标准输出设置成宽字符模式，来确保宽字符（串）能正确输出（参考 [第 11 讲] ）。注意 <code>string_t</code> 在 Windows 上是 <code>wstring</code>，在其他平台上是 <code>string</code>。</li>
<li>第 72–83 行，如注释所言，产生 HTTP 请求、等待 HTTP 请求完成，并处理相关的异常。</li>
</ol>
<p>整体而言，这个代码还是很简单的，虽然这种代码风格，对于之前没有接触过这种函数式编程风格的人来讲会有点奇怪——这被称作持续传递风格（continuation-passing style），显式地把上一段处理的结果传递到下一个函数中。这个代码已经处理了 Windows 环境和 Unix 环境的差异，底下是相当复杂的。</p>
<p>另外提醒一下，在 Windows 上如果你把源代码存成 UTF-8 的话，需要确保文件以 BOM 字符打头。Windows 的编辑器通常缺省就会做到；在 Vim 里，可以通过 <code>set bomb</code> 命令做到这一点。</p>
<h2 id="安装和编译">安装和编译</h2>
<p>上面的代码本身虽然简单，但要把它编译成可执行文件比我们之前讲的代码都要复杂——C++ REST SDK 有外部依赖，在 Windows 上和 Unix 上还不太一样。它的编译和安装也略复杂，如果你没有这方面的经验的话，建议尽量使用平台推荐的二进制包的安装方式。</p>
<p>由于其依赖较多，使用它的编译命令行也较为复杂。正式项目中绝对是需要使用项目管理软件的（如 cmake）。此处，我给出手工编译的典型命令行，仅供你尝试编译上面的例子作参考。</p>
<p>Windows MSVC：</p>
<blockquote>
<p><code>cl /EHsc /std:c++17 test.cpp cpprest.lib zlib.lib libeay32.lib ssleay32.lib winhttp.lib httpapi.lib bcrypt.lib crypt32.lib advapi32.lib gdi32.lib user32.lib</code></p>
</blockquote>
<p>Linux GCC：</p>
<blockquote>
<p><code>g++ -std=c++17 -pthread test.cpp -lcpprest -lcrypto -lssl -lboost_thread -lboost_chrono -lboost_system</code></p>
</blockquote>
<p>macOS Clang：</p>
<blockquote>
<p><code>clang++ -std=c++17 test.cpp -lcpprest -lcrypto -lssl -lboost_thread-mt -lboost_chrono-mt</code></p>
</blockquote>
<h2 id="概述">概述</h2>
<p>有了初步印象之后，现在我们可以回过头看看 C++ REST SDK 到底是什么了。它是一套用来开发 HTTP 客户端和服务器的现代异步 C++ 代码库，支持以下特性（随平台不同会有所区别）：</p>
<ol>
<li>HTTP 客户端</li>
<li>HTTP 服务器</li>
<li>任务</li>
<li>JSON</li>
<li>URI</li>
<li>异步流</li>
<li>WebSocket 客户端</li>
<li>OAuth 客户端</li>
</ol>
<p>上面的例子里用到了 HTTP 客户端、任务和 URI（实际上是由 <code>string_t</code> 隐式构造了 <code>uri</code>），我们下面再介绍一下异步流、JSON 和 HTTP 服务器。</p>
<h2 id="异步流">异步流</h2>
<p>C++ REST SDK 里实现了一套异步流，能够实现对文件的异步读写。下面的例子展示了我们如何把网络请求的响应异步地存储到文件 results.html 中：</p>
<p>#include <iostream><br>
#include <utility><br>
#ifdef _WIN32<br>
#include &lt;fcntl.h&gt;<br>
#include &lt;io.h&gt;<br>
#endif<br>
#include &lt;stddef.h&gt;<br>
#include &lt;cpprest/http_client.h&gt;<br>
#include &lt;cpprest/filestream.h&gt;</p>
<p>using namespace utility;<br>
using namespace web::http;<br>
using namespace web::http::client;<br>
using namespace concurrency::streams;<br>
using std::cerr;<br>
using std::endl;</p>
<p>#ifdef _WIN32<br>
#define tcout std::wcout<br>
#else<br>
#define tcout std::cout<br>
#endif</p>
<p>auto get_headers(http_response resp)<br>
{<br>
auto headers = resp.to_string();<br>
auto end =<br>
headers.find(U(&quot;\r\n\r\n&rdquo;));<br>
if (end != string_t::npos) {<br>
headers.resize(end + 4);<br>
};<br>
return headers;<br>
}</p>
<p>auto get_request(string_t uri)<br>
{<br>
http_client client{uri};<br>
// 用 GET 方式发起一个客户端请求<br>
auto request =<br>
client.request(methods::GET)<br>
.then(<a href="./http_response_resp.md"></a> {<br>
if (resp.status_code() ==<br>
status_codes::OK) {<br>
// 正常的话<br>
tcout &laquo; U(&ldquo;Saving&hellip;\n&rdquo;);<br>
ostream fs;<br>
fstream::open_ostream(<br>
U(&ldquo;results.html&rdquo;),<br>
std::ios_base::out |<br>
std::ios_base::trunc)<br>
.then(<br>
<a href="./ostream_os.md">&amp;fs,<br>
resp</a> {<br>
fs = os;<br>
// 读取网页内容到流<br>
return resp.body()<br>
.read_to_end(<br>
fs.streambuf());<br>
})<br>
.then(<br>
<a href="./size_t_size.md">&amp;fs</a> {<br>
// 然后关闭流<br>
fs.close();<br>
tcout<br>
&laquo; size<br>
&laquo; U(&quot; bytes &quot;<br>
&ldquo;saved\n&rdquo;);<br>
})<br>
.wait();<br>
} else {<br>
// 否则显示当前响应信息<br>
auto headers =<br>
get_headers(resp);<br>
tcout &laquo; headers;<br>
tcout<br>
&laquo; resp.extract_string()<br>
.get();<br>
}<br>
});<br>
return request;<br>
}</p>
<p>#ifdef _WIN32<br>
int wmain(int argc, wchar_t* argv[])<br>
#else<br>
int main(int argc, char* argv[])<br>
#endif<br>
{<br>
#ifdef _WIN32<br>
_setmode(_fileno(stdout),<br>
_O_WTEXT);<br>
#endif</p>
<p>if (argc != 2) {<br>
cerr &laquo; &ldquo;A URL is needed\n&rdquo;;<br>
return 1;<br>
}</p>
<p>// 等待请求及其关联处理全部完成<br>
try {<br>
auto request =<br>
get_request(argv[1]);<br>
request.wait();<br>
}<br>
// 处理请求过程中产生的异常<br>
catch (const std::exception&amp; e) {<br>
cerr &laquo; &ldquo;Error exception: &quot;<br>
&laquo; e.what() &laquo; endl;<br>
}<br>
}</p>
<p>跟上一个例子比，我们去掉了原先的第二段处理统一输出的异步处理代码，但加入了一段嵌套的异步代码。有几个地方需要注意一下：</p>
<ol>
<li>C++ REST SDK 的对象基本都是基于 <code>shared_ptr</code> 用引用计数实现的，因而可以轻松大胆地进行复制。</li>
<li>虽然 <code>string_t</code> 在 Windows 上是 <code>wstring</code>，但文件流无论在哪个平台上都是以 UTF-8 的方式写入，符合目前的主流处理方式（<code>wofstream</code> 的行为跟平台和环境相关）。</li>
<li><code>extract_string</code> 的结果这次没有传递到下一段，而是直接用 <code>get</code> 获得了最终结果（类似于 [第 19 讲] 中的 <code>future</code>）。</li>
</ol>
<p>这个例子的代码是基于 cpprestsdk 官方的例子改编的。但我做的下面这些更动值得提一下：</p>
<ol>
<li>去除了不必要的 <code>shared_ptr</code> 的使用。</li>
<li><code>fstream::open_ostream</code> 缺省的文件打开方式是 <code>std::ios_base::out</code>，官方例子没有用 <code>std::ios_base::trunc</code>，导致不能清除文件中的原有内容。此处 C++ REST SDK 的 <code>file_stream</code> 行为跟标准 C++ 的 <code>ofstream</code> 是不一样的：后者缺省打开方式也是 <code>std::ios_base::out</code>，但此时文件内容<strong>会</strong>被自动清除。</li>
<li>沿用我的前一个例子，先进行请求再打开文件流，而不是先打开文件流再发送网络请求，符合实际流程。</li>
<li>这样做的一个结果就是 <code>then</code> 不完全是顺序的了，有嵌套，增加了复杂度，但展示了实际可能的情况。</li>
</ol>
<h2 id="json-支持">JSON 支持</h2>
<p>在基于网页的开发中，JSON [5] 早已取代 XML 成了最主流的数据交换方式。REST 接口本身就是基于 JSON 的，自然，C++ REST SDK 需要对 JSON 有很好的支持。</p>
<p>JSON 本身可以在网上找到很多介绍的文章，我这儿就不多讲了。有几个 C++ 相关的关键点需要提一下：</p>
<ol>
<li>JSON 的基本类型是空值类型、布尔类型、数字类型和字符串类型。其中空值类型和数字类型在 C++ 里是没有直接对应物的。数字类型在 C++ 里可能映射到 <code>double</code>，也可能是 <code>int32_t</code> 或 <code>int64_t</code>。</li>
<li>JSON 的复合类型是数组（array）和对象（object）。JSON 数组像 C++ 的 <code>vector</code>，但每个成员的类型可以是任意 JSON 类型，而不像 <code>vector</code> 通常是同质的——所有成员属于同一类型。JSON 对象像 C++ 的 <code>map</code>，键类型为 JSON 字符串，值类型则为任意 JSON 类型。JSON 标准不要求对象的各项之间有顺序，不过，从实际项目的角度，我个人觉得保持顺序还是非常有用的。</li>
</ol>
<p>如果你去搜索“c++ json”的话，还是可以找到一些不同的 JSON 实现的。功能最完整、名声最响的目前似乎是 nlohmann/json [6]，而腾讯释出的 RapidJSON [7] 则以性能闻名 [8]。需要注意一下各个实现之间的区别：</p>
<ol>
<li>nlohmann/json 不支持对 JSON 的对象（object）保持赋值顺序；RapidJSON 保持赋值顺序；C++ REST SDK 可选保持赋值顺序（通过 <code>web::json::keep_object_element_order</code> 和 <code>web::json::value::object</code> 的参数）。</li>
<li>nlohmann/json 支持最友好的初始化语法，可以使用初始化列表和 JSON 字面量；C++ REST SDK 只能逐项初始化，并且一般应显式调用 <code>web::json::value</code> 的构造函数（接受布尔类型和字符串类型的构造函数有 <code>explicit</code> 标注）；RapidJSON 介于中间，不支持初始化列表和字面量，但赋值可以直接进行。</li>
<li>nlohmann/json 和 C++ REST SDK 支持直接在用方括号 <code>[]</code> 访问不存在的 JSON 数组（array）成员时改变数组的大小；RapidJSON 的接口不支持这种用法，要向 JSON 数组里添加成员要麻烦得多。</li>
<li>作为性能的代价，RapidJSON 里在初始化字符串值时，只会传递指针值；用户需要保证字符串在 JSON 值使用过程中的有效性。要复制字符串的话，接口要麻烦得多。</li>
<li>RapidJSON 的 JSON 对象没有 <code>begin</code> 和 <code>end</code> 方法，因而无法使用标准的基于范围的 for 循环。总体而言，RapidJSON 的接口显得最特别、不通用。</li>
</ol>
<p>如果你使用 C++ REST SDK 的其他功能，你当然也没有什么选择；否则，你可以考虑一下其他的 JSON 实现。下面，我们就只讨论 C++ REST SDK 里的 JSON 了。</p>
<p>在 C++ REST SDK 里，核心的类型是 <code>web::json::value</code>，这就对应到我前面说的“任意 JSON 类型”了。还是拿例子说话（改编自 RapidJSON 的例子）：</p>
<p>#include <iostream><br>
#include <string><br>
#include <utility><br>
#include &lt;assert.h&gt;<br>
#ifdef _WIN32<br>
#include &lt;fcntl.h&gt;<br>
#include &lt;io.h&gt;<br>
#endif<br>
#include &lt;cpprest/json.h&gt;</p>
<p>using namespace std;<br>
using namespace utility;<br>
using namespace web;</p>
<p>#ifdef _WIN32<br>
#define tcout std::wcout<br>
#else<br>
#define tcout std::cout<br>
#endif</p>
<p>int main()<br>
{<br>
#ifdef _WIN32<br>
_setmode(_fileno(stdout),<br>
_O_WTEXT);<br>
#endif</p>
<p>// 测试的 JSON 字符串<br>
string_t json_str = U(R&rdquo;(<br>
{<br>
&ldquo;s&rdquo;: &ldquo;你好，世界&rdquo;,<br>
&ldquo;t&rdquo;: true,<br>
&ldquo;f&rdquo;: false,<br>
&ldquo;n&rdquo;: null,<br>
&ldquo;i&rdquo;: 123,<br>
&ldquo;d&rdquo;: 3.1416,<br>
&ldquo;a&rdquo;: [1, 2, 3]<br>
})&quot;);<br>
tcout &laquo; &ldquo;Original JSON:&rdquo;<br>
&laquo; json_str &laquo; endl;</p>
<p>// 保持元素顺序并分析 JSON 字符串<br>
json::keep_object_element_order(<br>
true);<br>
auto document =<br>
json::value::parse(json_str);</p>
<p>// 遍历对象成员并输出类型<br>
static const char* type_names[] =<br>
{<br>
&ldquo;Number&rdquo;, &ldquo;Boolean&rdquo;, &ldquo;String&rdquo;,<br>
&ldquo;Object&rdquo;, &ldquo;Array&rdquo;,   &ldquo;Null&rdquo;,<br>
};<br>
for (auto&amp;&amp; value :<br>
document.as_object()) {<br>
tcout &laquo; &ldquo;Type of member &quot;<br>
&laquo; value.first &laquo; &quot; is &quot;<br>
&laquo; type_names[value.second<br>
.type()]<br>
&laquo; endl;<br>
}</p>
<p>// 检查 document 是对象<br>
assert(document.is_object());</p>
<p>// 检查 document[&ldquo;s&rdquo;] 是字符串<br>
assert(document.has_field(U(&ldquo;s&rdquo;)));<br>
assert(<br>
document[U(&ldquo;s&rdquo;)].is_string());<br>
tcout &laquo; &ldquo;s = &quot;<br>
&laquo; document[U(&ldquo;s&rdquo;)] &laquo; endl;</p>
<p>// 检查 document[&ldquo;t&rdquo;] 是字符串<br>
assert(<br>
document[U(&ldquo;t&rdquo;)].is_boolean());<br>
tcout<br>
&laquo; &ldquo;t = &quot;<br>
&laquo; (document[U(&ldquo;t&rdquo;)].as_bool()<br>
? &ldquo;true&rdquo;<br>
: &ldquo;false&rdquo;)<br>
&laquo; endl;</p>
<p>// 检查 document[&ldquo;f&rdquo;] 是字符串<br>
assert(<br>
document[U(&ldquo;f&rdquo;)].is_boolean());<br>
tcout<br>
&laquo; &ldquo;f = &quot;<br>
&laquo; (document[U(&ldquo;f&rdquo;)].as_bool()<br>
? &ldquo;true&rdquo;<br>
: &ldquo;false&rdquo;)<br>
&laquo; endl;</p>
<p>// 检查 document[&ldquo;f&rdquo;] 是空值<br>
tcout<br>
&laquo; &ldquo;n = &quot;<br>
&laquo; (document[U(&ldquo;n&rdquo;)].is_null()<br>
? &ldquo;null&rdquo;<br>
: &ldquo;?&rdquo;)<br>
&laquo; endl;</p>
<p>// 检查 document[&ldquo;i&rdquo;] 是整数<br>
assert(<br>
document[U(&ldquo;i&rdquo;)].is_number());<br>
assert(<br>
document[U(&ldquo;i&rdquo;)].is_integer());<br>
tcout &laquo; &ldquo;i = &quot;<br>
&laquo; document[U(&ldquo;i&rdquo;)] &laquo; endl;</p>
<p>// 检查 document[&ldquo;d&rdquo;] 是浮点数<br>
assert(<br>
document[U(&ldquo;d&rdquo;)].is_number());<br>
assert(<br>
document[U(&ldquo;d&rdquo;)].is_double());<br>
tcout &laquo; &ldquo;d = &quot;<br>
&laquo; document[U(&ldquo;d&rdquo;)] &laquo; endl;</p>
<p>{<br>
// 检查 document[&ldquo;a&rdquo;] 是数组<br>
auto&amp; a = document[U(&ldquo;a&rdquo;)];<br>
assert(a.is_array());</p>
<pre><code>// 测试读取数组元素并转换成整数  
int y = a[0].as_integer();  
(void)y;  

// 遍历数组成员并输出  
tcout &lt;&lt; &quot;a = &quot;;  
for (auto&amp;&amp; value :  
     a.as_array()) {  
  tcout &lt;&lt; value &lt;&lt; ' ';  
}  
tcout &lt;&lt; endl;  
</code></pre>
<p>}</p>
<p>// 修改 document[&ldquo;i&rdquo;] 为长整数<br>
{<br>
uint64_t bignum = 65000;<br>
bignum *= bignum;<br>
bignum *= bignum;<br>
document[U(&ldquo;i&rdquo;)] = bignum;</p>
<pre><code>assert(!document[U(&quot;i&quot;)]  
          .as_number()  
          .is_int32());  
assert(document[U(&quot;i&quot;)]  
         .as_number()  
         .to_uint64() ==  
       bignum);  
tcout &lt;&lt; &quot;i is changed to &quot;  
      &lt;&lt; document[U(&quot;i&quot;)]  
      &lt;&lt; endl;  
</code></pre>
<p>}</p>
<p>// 在数组里添加数值<br>
{<br>
auto&amp; a = document[U(&ldquo;a&rdquo;)];<br>
a[3] = 4;<br>
a[4] = 5;<br>
tcout &laquo; &ldquo;a is changed to &quot;<br>
&laquo; document[U(&ldquo;a&rdquo;)]<br>
&laquo; endl;<br>
}</p>
<p>// 在 JSON 文档里添加布尔值：等号<br>
// 右侧 json::value 不能省<br>
document[U(&ldquo;b&rdquo;)] =<br>
json::value(true);</p>
<p>// 构造新对象，保持多个值的顺序<br>
auto temp =<br>
json::value::object(true);<br>
// 在新对象里添加字符串：等号右侧<br>
// json::value 不能省<br>
temp[U(&ldquo;from&rdquo;)] =<br>
json::value(U(&ldquo;rapidjson&rdquo;));<br>
temp[U(&ldquo;changed for&rdquo;)] =<br>
json::value(U(&ldquo;geekbang&rdquo;));</p>
<p>// 把对象赋到文档里；json::value<br>
// 内部使用 unique_ptr，因而使用<br>
// move 可以减少拷贝<br>
document[U(&ldquo;adapted&rdquo;)] =<br>
std::move(temp);</p>
<p>// 完整输出目前的 JSON 对象<br>
tcout &laquo; document &laquo; endl;<br>
}</p>
<p>例子里我加了不少注释，应当可以帮助你看清 JSON 对象的基本用法了。唯一遗憾的是宏 <code>U</code>（类似于 [第 11 讲] 里提到过的 <code>_T</code>）的使用有点碍眼：要确保代码在 Windows 下和 Unix 下都能工作，目前这还是必要的。</p>
<p>建议你测试一下这个例子。查看一下结果。</p>
<p>C++ REST SDK 里的 <code>http_request</code> 和 <code>http_response</code> 都对 JSON 有原生支持，如可以使用 <code>extract_json</code> 成员函数来异步提取 HTTP 请求或响应体中的 JSON 内容。</p>
<h2 id="http-服务器">HTTP 服务器</h2>
<p>前面我们提到了如何使用 C++ REST SDK 来快速搭建一个 HTTP 客户端。同样，我们也可以使用 C++ REST SDK 来快速搭建一个 HTTP 服务器。在三种主流的操作系统上，C++ REST SDK 的 <code>http_listener</code> 会通过调用 Boost.Asio [9] 和操作系统的底层接口（IOCP、epoll 或 kqueue）来完成功能，向使用者隐藏这些细节、提供一个简单的编程接口。</p>
<p>我们将搭建一个最小的 REST 服务器，只能处理一个 sayHi 请求。客户端应当向服务器发送一个 HTTP 请求，URI 是：</p>
<blockquote>
<p><code>/sayHi?name=…</code></p>
</blockquote>
<p>“…”部分代表一个名字，而服务器应当返回一个 JSON 的回复，形如：</p>
<p>{&ldquo;msg&rdquo;: &ldquo;Hi, …!&rdquo;}</p>
<p>这个服务器的有效代码行同样只有六十多行，如下所示：</p>
<p>#include <exception><br>
#include <iostream><br>
#include <map><br>
#include <string><br>
#ifdef _WIN32<br>
#include &lt;fcntl.h&gt;<br>
#include &lt;io.h&gt;<br>
#endif<br>
#include &lt;cpprest/http_listener.h&gt;<br>
#include &lt;cpprest/json.h&gt;</p>
<p>using namespace std;<br>
using namespace utility;<br>
using namespace web;<br>
using namespace web::http;<br>
using namespace web::http::<br>
experimental::listener;</p>
<p>#ifdef _WIN32<br>
#define tcout std::wcout<br>
#else<br>
#define tcout std::cout<br>
#endif</p>
<p>void handle_get(http_request req)<br>
{<br>
auto&amp; uri = req.request_uri();</p>
<p>if (uri.path() != U(&quot;/sayHi&rdquo;)) {<br>
req.reply(<br>
status_codes::NotFound);<br>
return;<br>
}</p>
<p>tcout &laquo; uri::decode(uri.query())<br>
&laquo; endl;</p>
<p>auto query =<br>
uri::split_query(uri.query());<br>
auto it = query.find(U(&ldquo;name&rdquo;));<br>
if (it == query.end()) {<br>
req.reply(<br>
status_codes::BadRequest,<br>
U(&ldquo;Missing query info&rdquo;));<br>
return;<br>
}</p>
<p>auto answer =<br>
json::value::object(true);<br>
answer[U(&ldquo;msg&rdquo;)] = json::value(<br>
string_t(U(&ldquo;Hi, &ldquo;)) +<br>
uri::decode(it-&gt;second) +<br>
U(&rdquo;!&rdquo;));</p>
<p>req.reply(status_codes::OK,<br>
answer);<br>
}</p>
<p>int main()<br>
{<br>
#ifdef _WIN32<br>
_setmode(_fileno(stdout),<br>
_O_WTEXT);<br>
#endif</p>
<p>http_listener listener(<br>
U(&ldquo;http://127.0.0.1:8008/&rdquo;));<br>
listener.support(methods::GET,<br>
handle_get);</p>
<p>try {<br>
listener.open().wait();</p>
<pre><code>tcout &lt;&lt; &quot;Listening. Press &quot;  
         &quot;ENTER to exit.\n&quot;;  
string line;  
getline(cin, line);  

listener.close().wait();  
</code></pre>
<p>}<br>
catch (const exception&amp; e) {<br>
cerr &laquo; e.what() &laquo; endl;<br>
return 1;<br>
}<br>
}</p>
<p>如果你熟悉 HTTP 协议的话，上面的代码应当是相当直白的。只有少数几个细节我需要说明一下：</p>
<ol>
<li>我们调用 <code>http_request::reply</code> 的第二个参数是 <code>json::value</code> 类型，这会让 HTTP 的内容类型（Content-Type）自动置成“application/json”。</li>
<li><code>http_request::request_uri</code> 函数返回的是 <code>uri</code> 的引用，因此我用 <code>auto&amp;</code> 来接收。<code>uri::split_query</code> 函数返回的是一个普通的 <code>std::map</code>，因此我用 <code>auto</code> 来接收。</li>
<li><code>http_listener::open</code> 和 <code>http_listener::close</code> 返回的是 <code>pplx::task&lt;void&gt;</code>；当这个任务完成时（<code>wait</code> 调用返回），表示 HTTP 监听器上的对应操作（打开或关闭）真正完成了。</li>
</ol>
<p>运行程序，然后在另外一个终端里使用我们的第一个例子生成的可执行文件（或 curl）：</p>
<blockquote>
<p><code>curl &quot;http://127.0.0.1:8008/sayHi?name=Peter&quot;</code></p>
</blockquote>
<p>我们就应该会得到正确的结果：</p>
<blockquote>
<p><code>{&quot;msg&quot;:&quot;Hi, Peter!&quot;}</code></p>
</blockquote>
<p>你也可以尝试把路径和参数写错，查看一下程序对出错的处理。</p>
<h2 id="关于线程的细节">关于线程的细节</h2>
<p>C++ REST SDK 使用异步的编程模式，使得写不阻塞的代码变得相当容易。不过，底层它是使用一个线程池来实现的——在 C++20 的协程能被使用之前，并没有什么更理想的跨平台方式可用。</p>
<p>C++ REST SDK 缺省会开启 40 个线程。在目前的实现里，如果这些线程全部被用完了，会导致系统整体阻塞。反过来，如果你只是用 C++ REST SDK 的 HTTP 客户端，你就不需要这么多线程。这个线程数量目前在代码里是可以控制的。比如，下面的代码会把线程池的大小设为 10：</p>
<p>#include &lt;pplx/threadpool.h&gt;<br>
…<br>
crossplat::threadpool::<br>
initialize_with_threads(10);</p>
<p>如果你使用 C++ REST SDK 开发一个服务器，则不仅应当增加线程池的大小，还应当对并发数量进行统计，在并发数接近线程数时主动拒绝新的连接——一般可返回 <code>status_codes::ServiceUnavailable</code>——以免造成整个系统的阻塞。</p>
<h2 id="内容小结">内容小结</h2>
<p>今天我们对 C++ REST SDK 的主要功能作了一下概要的讲解和演示，让你了解了它的主要功能和这种异步的编程方式。还有很多功能没有讲，但你应该可以通过查文档了解如何使用了。</p>
<p>这只能算是我们旅程中的一站——因为随着 C++20 的到来，我相信一定会有更多好用的网络开发库出现的。</p>
<h2 id="课后思考">课后思考</h2>
<p>作为实战篇的最后一讲，内容还是略有点复杂的。如果你一下子消化不了，可以复习前面的相关内容。</p>
<p>如果对这讲的内容本身没有问题，则可以考虑一下，你觉得 C++ REST SDK 的接口好用吗？如果好用，原因是什么？如果不好用，你有什么样的改进意见？</p>
<h2 id="参考资料">参考资料</h2>
<p>[1] Microsoft, cpprestsdk. <a href="https://github.com/microsoft/cpprestsdk">https://github.com/microsoft/cpprestsdk</a></p>
<p>[2] Wikipedia, “Hypertext Transfer Protocol”. <a href="https://en.wikipedia.org/wiki/Hypertext">https://en.wikipedia.org/wiki/Hypertext</a>_Transfer_Protocol</p>
<p>[2a] 维基百科，“超文本传输协议”. <a href="https://zh.m.wikipedia.org/zh-hans/">https://zh.m.wikipedia.org/zh-hans/</a> 超文本传输协议</p>
<p>[3] RESTful. <a href="https://restfulapi.net/">https://restfulapi.net/</a></p>
<p>[4] curl. <a href="https://curl.haxx.se/">https://curl.haxx.se/</a></p>
<p>[5] JSON. <a href="https://www.json.org/">https://www.json.org/</a></p>
<p>[6] Niels Lohmann, json. <a href="https://github.com/nlohmann/json">https://github.com/nlohmann/json</a></p>
<p>[7] Tencent, rapidjson. <a href="https://github.com/Tencent/rapidjson">https://github.com/Tencent/rapidjson</a></p>
<p>[8] Milo Yip, nativejson-benchmark. <a href="https://github.com/miloyip/nativejson-benchmark">https://github.com/miloyip/nativejson-benchmark</a></p>
<p>[9] Christopher Kohlhoff, Boost.Asio. <a href="https://www.boost.org/doc/libs/release/doc/html/boost">https://www.boost.org/doc/libs/release/doc/html/boost</a>_asio.html</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/">现代C&#43;&#43;实战30讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A140%E9%97%AE/27__api%E7%BD%91%E5%85%B3%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%97%A8%E9%9D%A2%E8%A6%81%E5%A6%82%E4%BD%95%E5%81%9A%E5%91%A2/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">27__API网关：系统的门面要如何做呢？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/27__i_o%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E9%81%87%E4%B8%8A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8poll%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E6%89%80%E6%9C%89i_o%E4%BA%8B%E4%BB%B6/">
            <span class="next-text nav-default">27__I_O多路复用遇上线程：使用poll单线程处理所有I_O事件</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
