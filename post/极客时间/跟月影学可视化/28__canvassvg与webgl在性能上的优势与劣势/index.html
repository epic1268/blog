<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>28__Canvas、SVG与WebGL在性能上的优势与劣势 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是月影。
性能优化，一直以来都是前端开发的难点。
我们知道，前端性能是一块比较复杂的内容，由许多因素决定，比如，网页内容和资源文件的大小、请求数、域名、服务器配置、CDN 等等。如果你能把性能优化好，就能极大地增强用户体验。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/28__canvassvg%E4%B8%8Ewebgl%E5%9C%A8%E6%80%A7%E8%83%BD%E4%B8%8A%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/28__canvassvg%E4%B8%8Ewebgl%E5%9C%A8%E6%80%A7%E8%83%BD%E4%B8%8A%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="28__Canvas、SVG与WebGL在性能上的优势与劣势">
  <meta property="og:description" content="你好，我是月影。
性能优化，一直以来都是前端开发的难点。
我们知道，前端性能是一块比较复杂的内容，由许多因素决定，比如，网页内容和资源文件的大小、请求数、域名、服务器配置、CDN 等等。如果你能把性能优化好，就能极大地增强用户体验。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="跟月影学可视化">

  <meta itemprop="name" content="28__Canvas、SVG与WebGL在性能上的优势与劣势">
  <meta itemprop="description" content="你好，我是月影。
性能优化，一直以来都是前端开发的难点。
我们知道，前端性能是一块比较复杂的内容，由许多因素决定，比如，网页内容和资源文件的大小、请求数、域名、服务器配置、CDN 等等。如果你能把性能优化好，就能极大地增强用户体验。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4996">
  <meta itemprop="keywords" content="跟月影学可视化">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="28__Canvas、SVG与WebGL在性能上的优势与劣势">
  <meta name="twitter:description" content="你好，我是月影。
性能优化，一直以来都是前端开发的难点。
我们知道，前端性能是一块比较复杂的内容，由许多因素决定，比如，网页内容和资源文件的大小、请求数、域名、服务器配置、CDN 等等。如果你能把性能优化好，就能极大地增强用户体验。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">28__Canvas、SVG与WebGL在性能上的优势与劣势</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4996 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#可视化渲染的性能问题有哪些">可视化渲染的性能问题有哪些？</a></li>
        <li><a href="#影响-canvas-渲染性能的-2-大要素">影响 Canvas 渲染性能的 2 大要素</a></li>
        <li><a href="#影响-svg-性能的-2-大要素">影响 SVG 性能的 2 大要素</a></li>
        <li><a href="#影响-webgl-性能的要素">影响 WebGL 性能的要素</a></li>
        <li><a href="#要点总结">要点总结</a></li>
        <li><a href="#小试牛刀">小试牛刀</a></li>
        <li><a href="#源码">源码</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是月影。</p>
<p>性能优化，一直以来都是前端开发的难点。</p>
<p>我们知道，前端性能是一块比较复杂的内容，由许多因素决定，比如，网页内容和资源文件的大小、请求数、域名、服务器配置、CDN 等等。如果你能把性能优化好，就能极大地增强用户体验。</p>
<p>在可视化领域也一样，可视化因为要突出数据表达的内容，经常需要设计一些有视觉震撼力的图形效果，比如，复杂的粒子效果和大量元素的动态效果。想要实现这些效果，图形系统的渲染性能就必须非常好，能够在用户的浏览器上稳定流畅地渲染出想要的视觉效果。</p>
<p>那么针对可视化渲染，我们都要解决哪些性能问题呢？</p>
<h2 id="可视化渲染的性能问题有哪些">可视化渲染的性能问题有哪些？</h2>
<p>由于前端的可视化也是在 Web 上展现的，因此像网页大小这些因素也会影响它的性能。而且，无论是可视化还是普通 Web 前端，针对这些因素进行性能优化的原理和手段都一样。</p>
<p>所以我今天想和你聊的是，可视化方面特殊的性能问题。它们在我们熟悉的 Web 前端工作中并不常见，通常只在可视化中绘制复杂图形的时候，我们才需要重点考虑。这些问题大体上可以分为两类，一类是<strong>渲染效率问题，</strong> <strong>另一类是</strong> <strong>计算问题</strong>。</p>
<p><strong>我们先来看它们的定义，渲染效率问题指的是图形系统在绘图部分所花费的时间，而计算问题则是指绘图之外的其他处理所花费的时间，包括图形数据的计算、正常的程序逻辑处理等等</strong>。</p>
<p>我们知道，在浏览器上渲染动画，每一秒钟最高达到 60 帧左右。也就是说，我们可以在 1 秒钟内完成 60 次图像的绘制，那么完成一次图像绘制的时间就是 1000/60（1 秒 =1000 毫秒），约等于 16 毫秒。</p>
<p>换句话说，如果我们能在 16 毫秒内完成图像的计算与渲染过程，那视觉呈现就可以达到完美的 60fps（即 60 帧每秒，fps 全称是 frame per second，是帧率单位）。但是，在复杂的图形渲染时，我们的帧率很可能达不到 60fps。</p>
<p>所以，我们只能退而求其次，最低可以选择 24fps，就相当于图形系统要在大约 42 毫秒内完成一帧图像的绘制。这是在我们的感知里，达到比较流畅的动画效果的最低帧率了。要保证这个帧率，我们就必须保证计算加上渲染的时间不能超过 42 毫秒。</p>
<p>因为计算问题与数据和算法有关，所以我们后面会专门讨论。这里，我们先关注渲染效率的问题，这个问题和图形系统息息相关。</p>
<p>我们知道，Canvas2D、SVG 和 WebGL 等图形系统各自的特点不同，所以它们在绘制不同图形时的性能影响也不同，会表现出不同的性能瓶颈。其实，通过基础篇的学习，我们也大体上知道了这些图形系统的区别和优劣。那今天，我们就在此基础上，深入讨论一下影响它们各自性能的关键因素，理解了这些要素，我们针对不同图形系统，就能快速找到需要进行性能优化的点了。</p>
<h2 id="影响-canvas-渲染性能的-2-大要素">影响 Canvas 渲染性能的 2 大要素</h2>
<p>我们知道，Canvas 是指令式绘图系统，它通过绘图指令来完成图形的绘制。那么我们很容易就会想到 2 个影响因素，首先绘制图形的数量越多，我们需要的绘图指令就越多，花费的渲染时间也会越多。其次，画布上绘制的图形越大，绘图指令执行的时间也会增多，那么花费的渲染时间也会越多。</p>
<p>这些其实都是我们现阶段得出的假设，而实践是检验真理的唯一标准，所以我们一起做个实验，来证明我们刚才的假设吧。</p>
<p>const canvas = document.querySelector(&lsquo;canvas&rsquo;);<br>
const ctx = canvas.getContext(&lsquo;2d&rsquo;);</p>
<p>const WIDTH = canvas.width;<br>
const HEIGHT = canvas.height;</p>
<p>function randomColor() {<br>
return <code>hsl(${Math.random() * 360}, 100%, 50%)</code>;<br>
}</p>
<p>function drawCircle(context, radius) {<br>
const x = Math.random() * WIDTH;<br>
const y = Math.random() * HEIGHT;<br>
const fillColor = randomColor();<br>
context.fillStyle = fillColor;<br>
context.beginPath();<br>
context.arc(x, y, radius, 0, Math.PI * 2);<br>
context.fill();<br>
}</p>
<p>function draw(context, count = 500, radius = 10) {<br>
for(let i = 0; i &lt; count; i++) {<br>
drawCircle(context, radius);<br>
}<br>
}</p>
<p>requestAnimationFrame(function update() {<br>
ctx.clearRect(0, 0, WIDTH, HEIGHT);<br>
draw(ctx);<br>
requestAnimationFrame(update);<br>
});</p>
<p>如上面代码所示，我们在 Canvas 上每一帧绘制 500 个半径为 10 的小圆，效果如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/5b4d0fba2db44e534be2d075a2bf9527.png" alt=""></p>
<p>500 个小球，半径 10</p>
<p>注意，为了方便查看帧率的变化，我们在浏览器中开启了帧率检测。Chrome 开发者工具自带这个功能，我们在开发者工具的 Rendering 标签页中，勾选 FPS Meter 就可以开启这个功能查看帧率了。</p>
<p>我们现在看到，即使每帧渲染 500 个位置和颜色都随机的小圆形，Canvas 渲染的帧率依然能达到 60fps。</p>
<p>接着，我们增加小球的数量，把它增加到 1000 个。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/16811ad8c5d1bbbedde1e556d4c8fb5c.png" alt=""></p>
<p>1000 个小球，半径 10</p>
<p>这时你可以看到，因为小球数量增加一倍，所以帧率掉到了 50fps 左右，现在下降得还不算太多。而如果我们把小球的数量设置成 3000，你就能看到明显的差别了。</p>
<p>那如果我们把小球的数量保持在 500，把半径增大到很大，如 200，也会看到帧率有明显下降。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/084361dd365d0cb00c5f12b8cab2cb57.png" alt=""></p>
<p>500 个小球，半径 200</p>
<p>但是，单从上图的实验来看，图形大小对帧率的影响也不是很大。因为我们把小球的半径增加了 20 倍，帧率也就下降到 33fps。当然这也是因为画圆比较简单，如果我们绘制的图形更复杂一些，那么大小的影响会相对显著一些。</p>
<p>通过这个实验，我们能得出，影响 Canvas 的渲染性能的主要因素有两点，一是<strong>绘制图形的数量</strong>，二是**绘制图形的大小。**这正好验证了我们开头的结论。</p>
<p>总的来说，Canvas2D 绘制图形的性能还是比较高的。在普通的个人电脑上，我们要绘制的图形不太大时，只要不超过 500 个都可以达到 60fps，1000 个左右其实也能达到 50fps，就算要绘制大约 3000 个图形，也能够保持在可以接受的 24fps 以上。</p>
<p>因此，在不做特殊优化的前提下，如果我们使用 Canvas2D 来绘图，那么 3000 个左右元素是一般的应用的极限，除非这个应用运行在比个人电脑的 GPU 和显卡更好的机器上，或者采用特殊的优化手段。那具体怎么优化，我会在下节课详细来说。</p>
<h2 id="影响-svg-性能的-2-大要素">影响 SVG 性能的 2 大要素</h2>
<p>讲完了 Canvas 接下来我们看一下 SVG。</p>
<p>我们用 SVG 实现同样的绘制随机圆形的例子，代码如下：</p>
<p>function randomColor() {<br>
return <code>hsl(${Math.random() * 360}, 100%, 50%)</code>;<br>
}</p>
<p>const root = document.querySelector(&lsquo;svg&rsquo;);<br>
const COUNT = 500;<br>
const WIDTH = 500;<br>
const HEIGHT = 500;</p>
<p>function initCircles(count = COUNT) {<br>
for(let i = 0; i &lt; count; i++) {<br>
const circle = document.createElementNS(&lsquo;<a href="http://www.w3.org/2000/svg'">http://www.w3.org/2000/svg'</a>, &lsquo;circle&rsquo;);<br>
root.appendChild(circle);<br>
}<br>
return [&hellip;root.querySelectorAll(&lsquo;circle&rsquo;)];<br>
}<br>
const circles = initCircles();</p>
<p>function drawCircle(circle, radius = 10) {<br>
const x = Math.random() * WIDTH;<br>
const y = Math.random() * HEIGHT;<br>
const fillColor = randomColor();<br>
circle.setAttribute(&lsquo;cx&rsquo;, x);<br>
circle.setAttribute(&lsquo;cy&rsquo;, y);<br>
circle.setAttribute(&lsquo;r&rsquo;, radius);<br>
circle.setAttribute(&lsquo;fill&rsquo;, fillColor);<br>
}</p>
<p>function draw() {<br>
for(let i = 0; i &lt; COUNT; i++) {<br>
drawCircle(circles[i]);<br>
}<br>
requestAnimationFrame(draw);<br>
}</p>
<p>draw();</p>
<p>在我的电脑上（一台普通的 MacBook Pro，内存 8GB，独立显卡）绘制了 500 个半径为 10 的小球时，SVG 的帧率接近 60fps，会比 Canvas 稍慢，但是差别不是太大。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/b7c552042d864204739aa9e1f97b8981.png" alt=""></p>
<p>SVG 绘制 500 个小球，半径 10</p>
<p>当我们将小球数量增加到 1000 个时，SVG 的帧率就要略差一些，大概 45fps 左右。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/f99d905491f6d6ee49ff536ee1606736.png" alt=""></p>
<p>SVG 绘制 1000 个小球，半径 10</p>
<p>乍一看，似乎 SVG 和 Canvas2D 的性能差别也不是很大。不过，随着小球数量的增加，两者的差别会越来越大。比如说，当我们将小球的个数增加到 3000 个左右的时候，Canvas2D 渲染的帧率依然保持在 30fps 以上，而 SVG 渲染帧率大约只有 15fps，差距会特别明显。</p>
<p>之所以在小球个数较多的时候，二者差距很大，因为 SVG 是浏览器 DOM 来渲染的，元素个数越多，消耗就越大。</p>
<p>如果我们保证小球个数在一个小数值，然后增大每个小球的半径，那么与 Canvas 一样，SVG 的渲染效率也会明显下降。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/0ddcf8a2b76f0e2a7d7439f3cc68fada.png" alt=""></p>
<p>SVG 绘制 500 个小球，半径 200</p>
<p>如上图所示，当渲染 500 个小球时，我们把半径增加到 200，帧率下降到不到 20fps。</p>
<p>最终，我们能得到的结论与 Canvas 类似，影响 SVG 的性能因素也是相同的两点，一是<strong>绘制图形的数量</strong>，二是<strong>绘制图形的大小</strong>。但与 Canvas 不同的是，图形数量增多的时候，SVG 的帧率下降会更明显，因此，一般来说，在图形数量小于 1000 时，我们可以考虑使用 SVG，当图形数量大于 1000 但不超过 3000 时，我们考虑使用 Canvas2D。</p>
<p>那么当图形数量超过 3000 时，用 Canvas2D 也很难达到比较理想的帧率了，这时候，我们就要使用 WebGL 渲染。</p>
<h2 id="影响-webgl-性能的要素">影响 WebGL 性能的要素</h2>
<p>用 WebGL 渲染上面的例子，我们不需要一个一个小球去渲染，利用 GPU 的并行处理能力，我们可以一次完成渲染。</p>
<p>因为我们要渲染的小球形状相同，所以它们的顶点数据是可以共享的。在这里我们采用一种 WebGL 支持的批量绘制技术，叫做 <strong>InstancedDrawing（实例化渲染）</strong>。在 OGL 库中，我们只需要给几何体数据传递带有 instanced 属性的顶点数据，就可以自动使用 instanced drawing 技术来批量绘制图形。具体的操作代码如下：</p>
<p>function circleGeometry(gl, radius = 0.04, count = 30000, segments = 20) {<br>
const tau = Math.PI * 2;<br>
const position = new Float32Array(segments * 2 + 2);<br>
const index = new Uint16Array(segments * 3);<br>
const id = new Uint16Array(count);</p>
<p>for(let i = 0; i &lt; segments; i++) {<br>
const alpha = i / segments * tau;<br>
position.set([radius * Math.cos(alpha), radius * Math.sin(alpha)], i * 2 + 2);<br>
}<br>
for(let i = 0; i &lt; segments; i++) {<br>
if(i === segments - 1) {<br>
index.set([0, i + 1, 1], i * 3);<br>
} else {<br>
index.set([0, i + 1, i + 2], i * 3);<br>
}<br>
}<br>
for(let i = 0; i &lt; count; i++) {<br>
id.set([i], i);<br>
}<br>
return new Geometry(gl, {<br>
position: {<br>
data: position,<br>
size: 2,<br>
},<br>
index: {<br>
data: index,<br>
},<br>
id: {<br>
instanced: 1,<br>
size: 1,<br>
data: id,<br>
},<br>
});<br>
}</p>
<p>我们实现一个 circleGeometry 函数，用来生成指定数量的小球的定点数据。这里我们使用批量绘制的技术，一下子绘制了 30000 个小球。与绘制单个小球一样，我们计算小球的 position 数据和 index 数据，然后我们设置一个 id 数据，这个数据等于每个小球的下标。</p>
<p>我们通过 instanced:1 的方式告诉 WebGL 这是一个批量绘制的数据，让每一个值作用于一个几何体。这样我们就能区分不同的几何体，而 WebGL 在绘制的时候会根据 id 数据的个数来绘制相应多个几何体。</p>
<p>接着，我们实现顶点着色器，并且在顶点着色器代码中实现随机位置和随机颜色。</p>
<p>precision highp float;<br>
attribute vec2 position;<br>
attribute float id;<br>
uniform float uTime;</p>
<p>highp float random(vec2 co) {<br>
highp float a = 12.9898;<br>
highp float b = 78.233;<br>
highp float c = 43758.5453;<br>
highp float dt= dot(co.xy ,vec2(a,b));<br>
highp float sn= mod(dt,3.14);<br>
return fract(sin(sn) * c);<br>
}</p>
<p>vec3 hsb2rgb(vec3 c){<br>
vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0);<br>
rgb = rgb * rgb * (3.0 - 2.0 * rgb);<br>
return c.z * mix(vec3(1.0), rgb, c.y);<br>
}</p>
<p>varying vec3 vColor;</p>
<p>void main() {<br>
vec2 offset = vec2(<br>
1.0 - 2.0 * random(vec2(id + uTime, 100000.0)),<br>
1.0 - 2.0 * random(vec2(id + uTime, 200000.0))<br>
);<br>
vec3 color = vec3(<br>
random(vec2(id + uTime, 300000.0)),<br>
1.0,<br>
1.0<br>
);<br>
vColor = hsb2rgb(color);<br>
gl_Position = vec4(position + offset, 0, 1);<br>
}</p>
<p>上面的代码中的 random 函数和 hsb2rgb 函数，我们都学过了，整体逻辑也并不复杂，相信你应该能看明白。</p>
<p>最后，我们将 uTime 作为 uniform 传进去，结合 id 和 uTime，用随机数就可以渲染出与前面 Canvas 和 SVG 例子一样的效果。</p>
<p>这个 WebGL 渲染的例子的性能非常高，我们将小球的个数设置为 30000 个，依然可以轻松达到 60fps 的帧率。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/57fa76d941edd4cdbc33bf34701f6322.png" alt=""></p>
<p>WebGL，绘制 30000 个小球，半径 10</p>
<p>WebGL 渲染之所以能达到这么高的性能，是因为 WebGL 利用 GPU 并行执行的特性，无论我们批量绘制多少个小球，都能够同时完成计算并渲染出来。</p>
<p>如果我们增大小球的半径，那么帧率也会明显下降，这一点和 Canvas2D 与 SVG 一样。当我们将小球半径增加到 0.8（相当于 Canvas2D 中的 200），那么可以流畅渲染的数量就无法达到这么多，大约渲染 3000 个左右可以保持在 30fps 以上，这个效率仍比 Canvas2D 有着 5 倍以上的提升。小球半径增加导致帧率下降，是因为图形增大，片元着色器要执行的次数就会增多，就会增加 GPU 运算的开销。</p>
<p>好了，那我们来总结一下 WebGL 性能的要素。WebGL 情况比较复杂，上面的例子其实不能涵盖所有的情况，不过不要紧，我这里先说一下结论，你先记下来，我们之后还会专门讨论 WebGL 的性能优化方法。</p>
<p>首先，WebGL 和 Canvas2D 与 SVG 不同，它的性能并不直接与渲染元素的数量相关，而是取决于 WebGL 的渲染次数。有的时候，图形元素虽然很多，但是 WebGL 可以批量渲染，就像前面的例子中，虽然有上万个小球，但是通过 WebGL 的 instanced drawing 技术，可以批量完成渲染，那样它的性能就会很高。当然，元素的数量多，WebGL 渲染效率也会逐渐降低，这是因为，元素越多，本身渲染耗费的内存也越多，占用内存太多，渲染效率也会下降。</p>
<p>其次，在渲染次数相同的情况下，WebGL 的效率取决于着色器中的计算复杂度和执行次数。图形顶点越多，顶点着色器的执行次数越多，图形越大，片元着色器的执行次数越多，虽然是并行执行，但执行次数多依然会有更大的性能开销。最后，如果每次执行着色器中的计算越复杂，WebGL 渲染的性能开销自然也会越大。</p>
<p>总的来说，WebGL 的性能主要有三点决定因素，**一是渲染次数，二是着色器执行的次数，三是着色器运算的复杂度。**当然，数据的大小也会决定内存的消耗，因此也会对性能有所影响，只不过影响没有前面三点那么明显。</p>
<h2 id="要点总结">要点总结</h2>
<p>要针对可视化的渲染效率进行性能优化，我们就要先搞清影响图形系统渲染性能的主要因素。</p>
<p>对于 Canvas 和 SVG 来说，影响渲染性能的主要是绘制元素的数量和元素的大小。一般来说，Canvas 和 SVG 绘制的元素越多，性能消耗越大，绘制的图形越大，性能消耗也越大。相比较而言，Canvas 的整体性能要优于 SVG，尤其是图形越多，二者的性能差异越大。</p>
<p>WebGL 要复杂一些，它的渲染性能主要取决于三点。</p>
<p>第一点是渲染次数，渲染次数越多，性能损耗就越大。需注意，要绘制的元素个数多，不一定渲染次数就多，因为 WebGL 支持批量渲染。</p>
<p>第二点是着色器执行的次数，这里包括顶点着色器和片元着色器，前者的执行次数和几何图形的顶点数有关，后者的执行次数和图形的大小有关。</p>
<p>第三点是着色器运算的复杂度，复杂度和 glsl 代码的具体实现有关，越复杂的处理逻辑，性能的消耗就会越大。</p>
<p>最后，数据的大小会影响内存消耗，所以也会对 WebGL 的渲染性能有所影响，不过没有前面三点的影响大。</p>
<h2 id="小试牛刀">小试牛刀</h2>
<ol>
<li>刚才我们用 SVG、Canvas 和 WebGL 分别实现了随机小球，由此比较了三种图形系统的性能。但是我们并没说 HTML/CSS，你能用 HTML/CSS 来实现这个例子吗？用 HTML/CSS 来实现，在性能方面与 SVG、Canvas 和 WebGL 有什么区别呢？从中，你能得出影响 HTML/CSS 渲染性能的要素吗？</li>
<li>在 WebGL 的例子中，我们采用了批量绘制的技术。实际上我们也可以不采用这个技术，给每个小球生成一个 mesh 对象，然后让 Ogl 来渲染。你可以试着用 Ogl 不采用批量渲染来实现随机小球，然后对比它们之间的渲染方案，得出性能方面的差异吗？</li>
</ol>
<h2 id="源码">源码</h2>
<p>课程中详细示例代码</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/">跟月影学可视化</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%9E%B6%E6%9E%8430%E8%AE%B2/27%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAssr%E5%BA%94%E7%94%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">27同构渲染架构：实现一个SSR应用</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/28__concepts%E5%A6%82%E4%BD%95%E5%AF%B9%E6%A8%A1%E6%9D%BF%E8%BF%9B%E8%A1%8C%E7%BA%A6%E6%9D%9F_/">
            <span class="next-text nav-default">28__Concepts：如何对模板进行约束_</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
