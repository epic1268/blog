<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>18__如何生成简单动画让图形动起来？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是月影。
前面，我们用了 3 个模块的时间，学习了大量的图形学和数学知识，是不是让你的脑袋有一点昏沉？没关系，你只是需要一点时间来消化这些知识而已。我能给你的建议就是多思考、多练习，有了时间的积累，你一定可以掌握这些基础知识和思维方法。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/18__%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%AE%80%E5%8D%95%E5%8A%A8%E7%94%BB%E8%AE%A9%E5%9B%BE%E5%BD%A2%E5%8A%A8%E8%B5%B7%E6%9D%A5/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/18__%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%AE%80%E5%8D%95%E5%8A%A8%E7%94%BB%E8%AE%A9%E5%9B%BE%E5%BD%A2%E5%8A%A8%E8%B5%B7%E6%9D%A5/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="18__如何生成简单动画让图形动起来？">
  <meta property="og:description" content="你好，我是月影。
前面，我们用了 3 个模块的时间，学习了大量的图形学和数学知识，是不是让你的脑袋有一点昏沉？没关系，你只是需要一点时间来消化这些知识而已。我能给你的建议就是多思考、多练习，有了时间的积累，你一定可以掌握这些基础知识和思维方法。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="跟月影学可视化">

  <meta itemprop="name" content="18__如何生成简单动画让图形动起来？">
  <meta itemprop="description" content="你好，我是月影。
前面，我们用了 3 个模块的时间，学习了大量的图形学和数学知识，是不是让你的脑袋有一点昏沉？没关系，你只是需要一点时间来消化这些知识而已。我能给你的建议就是多思考、多练习，有了时间的积累，你一定可以掌握这些基础知识和思维方法。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4677">
  <meta itemprop="keywords" content="跟月影学可视化">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="18__如何生成简单动画让图形动起来？">
  <meta name="twitter:description" content="你好，我是月影。
前面，我们用了 3 个模块的时间，学习了大量的图形学和数学知识，是不是让你的脑袋有一点昏沉？没关系，你只是需要一点时间来消化这些知识而已。我能给你的建议就是多思考、多练习，有了时间的积累，你一定可以掌握这些基础知识和思维方法。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">18__如何生成简单动画让图形动起来？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4677 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#动画的三种形式">动画的三种形式</a>
          <ul>
            <li><a href="#1-实现固定帧动画">1. 实现固定帧动画</a></li>
            <li><a href="#2-实现增量动画">2. 实现增量动画</a></li>
            <li><a href="#3-实现时序动画">3. 实现时序动画</a></li>
          </ul>
        </li>
        <li><a href="#定义标准动画模型">定义标准动画模型</a></li>
        <li><a href="#插值与缓动函数">插值与缓动函数</a></li>
        <li><a href="#贝塞尔曲线缓动">贝塞尔曲线缓动</a></li>
        <li><a href="#要点总结">要点总结</a></li>
        <li><a href="#小试牛刀">小试牛刀</a></li>
        <li><a href="#源码">源码</a></li>
        <li><a href="#推荐阅读">推荐阅读</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是月影。</p>
<p>前面，我们用了 3 个模块的时间，学习了大量的图形学和数学知识，是不是让你的脑袋有一点昏沉？没关系，你只是需要一点时间来消化这些知识而已。我能给你的建议就是多思考、多练习，有了时间的积累，你一定可以掌握这些基础知识和思维方法。</p>
<p>从这一节课开始，我们要学习一个非常有意思的新模块，那就是动画和 3D 绘图。对于可视化展现来说，动画和 3D 都是用来强化数据表达，吸引用户的重要技术手段。它们往往比二维平面图形能够表达更复杂的数据，实现更吸引人的视觉效果。</p>
<p>那今天，我们先来聊聊动画的实现。实际上，我们之前也实现了不少动态效果，但你可能还是不知道怎么去实现动画。接下来，我们就来系统地梳理一下动画实现的标准方法。</p>
<h2 id="动画的三种形式">动画的三种形式</h2>
<p>什么是动画呢？简单来说，动画就是将许多帧静止的画面以固定的速率连续播放出来。一般来说，动画有三种形式，分别是固定帧动画、增量动画和时序动画。</p>
<p>第一种形式是我们预先准备好要播放的静态图像，然后将这些图依次播放，所以它叫做<strong>固定帧动画</strong>。<strong>增量动画</strong>是在动态绘制图像的过程中，我们修改每一帧中某个或某几个属性的值，给它们一定的增量。第三种形式是在动态绘制图像的过程中，我们根据时间和动画函数计算每一帧中的关键属性值，然后更新这些属性，所以它叫做<strong>时序动画</strong>。</p>
<p>这么说还是比较抽象，下面，我就以 HTML/CSS 为例，来带你熟悉这三种动画的基本形式。为什么选 HTML/CSS 呢？因为一般来说，HTML/CSS、SVG 和 Canvas2D 实现动画的方式大同小异，所以我就直接选择你最熟悉的 HTML/CSS 了。而 WebGL 实现动画的方式和其他三种图形系统都有差别，所以我会在下一节课单独来说。</p>
<h3 id="1-实现固定帧动画">1. 实现固定帧动画</h3>
<p>首先，我们来说说如何实现固定帧动画。</p>
<p>结合固定帧动画的定义，我们实现它的第一步，就是为每一帧准备一张静态图像。比如说，我们要实现一个循环播放 3 帧的动画，就要准备 3 个如下的图像。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/e22bf3200f69459018950e48fb4cad5a.png" alt=""></p>
<p>3 个静态图像</p>
<p>第二步，我们要依次播放这些图像。在 CSS 里实现的时候，我们使用图片作为背景，就可以让它们逐帧切换了。代码如下所示：</p>
<p>.bird {<br>
position: absolute;<br>
left: 100px;<br>
top: 100px;<br>
width:86px;<br>
height:60px;<br>
zoom: 0.5;<br>
background-repeat: no-repeat;<br>
background-image: url(<a href="https://p.ssl.qhimg.com/t01f265b6b6479fffc4.png);">https://p.ssl.qhimg.com/t01f265b6b6479fffc4.png);</a><br>
background-position: -178px -2px;<br>
animation: flappy .5s step-end infinite;<br>
}</p>
<p>@keyframes flappy {<br>
0% {background-position: -178px -2px;}<br>
33% {background-position: -90px -2px;}<br>
66% {background-position: -2px -2px;}<br>
}</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/e43f5b4d4db05bee99ea023e4b93052c.png" alt=""></p>
<p>动态的小鸟</p>
<p>虽然固定帧动画实现起来非常简单，但它不适合生成需要动态绘制的图像，更适合在游戏等应用场景中，生成由美术提供现成图片的动画帧图像。而对于动态绘制的图像，也就是非固定帧动画，我们通常会使用另外两种方式。</p>
<h3 id="2-实现增量动画">2. 实现增量动画</h3>
<p>我们先来说比较简单的增量动画，即每帧给属性一个增量。怎么理解呢？我举个简单的例子，我们可以创建一个蓝色的方块，然后给这个方块的每一帧增加一个 rotate 角度。这样就能实现蓝色方块旋转的动画。具体的代码和效果如下所示。</p>
<!DOCTYPE html>  
<html lang="en">  
<head>  
   <meta charset="UTF-8">  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
  <title>Document</title>  
  <style>  
    .block {  
      width: 100px;  
      height: 100px;  
      top: 100px;  
      left: 100px;  
      transform-origin: 50% 50%;  
      position: absolute;  
      background: blue;  
    }  
  </style>  
</head>  
<body>  
  <div class="block"></div>  
  <script>  
  const block = document.querySelector('.block');  
  let rotation = 0;  
  requestAnimationFrame(function update() {  
    block.style.transform = `rotate(${rotation++}deg)`;  
    requestAnimationFrame(update);  
  });  
  </script>  
</body>  
</html>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/0b19b49b30b2ec3adbe772533eaf15de.png" alt=""></p>
<p>旋转的蓝色方块</p>
<p>在上面的例子中，我们重点关注第 22 到 26 这 5 行 JavaScript 代码就行了，关键逻辑在于我们修改 rotatation 值，每次绘制的时候将它加 1。这样我们就实现增量动画，是不是也很简单？</p>
<p>确实，增量动画的优点就是实现简单。但它也有 2 个缺点。首先，因为它使用增量来控制动画，从数学角度来说，也就是我们直接使用了一阶导数来定义的动画。这样的绘图方式不太好控制动画的细节，比如动画周期、变化率、轨迹等等，所以这种方法只能用来实现简单动画。</p>
<p>其次，增量动画定义的是状态变化。如果我们要在 shader 中使用动画，就只能采用后期处理通道来实现。但是后期处理通道要进行多次渲染，实现起来比较繁琐，而且性能开销也比较大。所以，更加复杂的轨迹动画，我们一般采用第三种方式，也就是通过定义时间和动画函数来实现。</p>
<h3 id="3-实现时序动画">3. 实现时序动画</h3>
<p>还是以旋转的蓝色方块为例，我们改写一下它的 JavaScript 代码。</p>
<p>const block = document.querySelector(&rsquo;.block&rsquo;);<br>
const startAngle = 0;<br>
const T = 2000;<br>
let startTime = null;<br>
function update() {<br>
startTime = startTime == null ? Date.now() : startTime;<br>
const p = (Date.now() - startTime) / T;<br>
const angle = startAngle + p * 360;<br>
block.style.transform = <code>rotate(${angle}deg)</code>;<br>
requestAnimationFrame(update);<br>
}<br>
update();</p>
<p>首先，我们定义 2 个变量，startAnglehe 和 T。其中，startAnglehe 是起始旋转角度，T 是旋转周期。在第一次调用 update 的时候，我们设置初始旋转的时间为 startTime，那么在每次调用 update 的时候，当前经过的时间就是 Date.now() - startTime。</p>
<p>接着，我们将它除以周期 T，就能得到旋转进度 p，那么当前角度就等于 startAngle + p * 360。然后我们将当前角度设置为元素的 rotate 值，就实现了同样的旋转动画。</p>
<p>总的来说，时序动画的实现可以总结为三步：首先定义初始时间和周期，然后在 update 中计算当前经过时间和进度 p，最后通过 p 来更新动画元素的属性。虽然时序动画实现起来比增量动画写法更复杂，但我们可以更直观、精确地控制旋转动画的周期（速度）、起始角度等参数。</p>
<p>也正因为如此，这种方式在动画实现中最为常用。那为了更方便使用和拓展，我们可以把实现时序动画的三个步骤抽象成标准的动画模型。具体怎么做呢？我们接着往下看。</p>
<h2 id="定义标准动画模型">定义标准动画模型</h2>
<p>首先，我们定义一个类 Timing 用来处理时间，具体代码如下：</p>
<p>export class Timing {<br>
constructor({duration, iterations = 1} = {}) {<br>
this.startTime = Date.now();<br>
this.duration = duration;<br>
this.iterations = iterations;<br>
}</p>
<p>get time() {<br>
return Date.now() - this.startTime;<br>
}</p>
<p>get p() {<br>
const progress = Math.min(this.time / this.duration, this.iterations);<br>
return this.isFinished ? 1 : progress % 1;<br>
}</p>
<p>get isFinished() {<br>
return this.time / this.duration &gt;= this.iterations;<br>
}<br>
}</p>
<p>然后，我们实现一个 Animator 类，用来真正控制动画过程。</p>
<p>import {Timing} from &lsquo;./timing.js&rsquo;;</p>
<p>export class Animator {<br>
constructor({duration, iterations}) {<br>
this.timing = {duration, iterations};<br>
}</p>
<p>animate(target, update) {<br>
let frameIndex = 0;<br>
const timing = new Timing(this.timing);</p>
<pre><code>return new Promise((resolve) =&gt; {  
  function next() {  
    if(update({target, frameIndex, timing}) !== false &amp;&amp; !timing.isFinished) {  
      requestAnimationFrame(next);  
    } else {  
      resolve(timing);  
    }  
    frameIndex++;  
  }  
  next();  
});  
</code></pre>
<p>}<br>
}</p>
<p>Animator 构造器接受{duration, iterations}作为参数，它有一个 animate 方法，会在执行时创建一个 timing 对象，然后通过执行 update({target, frameIndex, timing}) 更新动画，并且会返回一个 promise 对象。这样，在动画结束时，resolve 这个 promise，我们就能够很方便地实现连续动画了。</p>
<p>接下来，你可以想一个动画效果，来试验一下这个模型的效果。比如说，我们可以用 Animator 实现四个方块的轮换转动，让每个方块转动的周期是 1 秒，一共旋转 1.5 个周期（即 540 度）。代码和效果如下所示。</p>
<!DOCTYPE html>  
<html lang="en">  
<head>  
  <meta charset="UTF-8">  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
  <title>Document</title>  
  <style>  
    .container {  
      display: flex;  
      flex-wrap: wrap;  
      justify-content: space-between;  
      width: 300px;  
    }  
    .block {  
      width: 100px;  
      height: 100px;  
      margin: 20px;  
      flex-shrink: 0;  
      transform-origin: 50% 50%;  
    }  
    .block:nth-child(1) {background: red;}  
    .block:nth-child(2) {background: blue;}  
    .block:nth-child(3) {background: green;}  
    .block:nth-child(4) {background: orange;}  
  </style>  
</head>  
<body>  
  <div class="container">  
    <div class="block"></div>  
    <div class="block"></div>  
    <div class="block"></div>  
    <div class="block"></div>  
  </div>  
  <script type="module">  
    import {Animator} from '../common/lib/animator/index.js';  
    const blocks = document.querySelectorAll('.block');  
    const animator = new Animator({duration: 1000, iterations: 1.5});  
    (async function () {  
      let i = 0;  
      while(true) { // eslint-disable-next-line no-await-in-loop  
        await animator.animate(blocks[i++ % 4], ({target, timing}) => {  
          target.style.transform = `rotate(${timing.p * 360}deg)`;  
        });  
      }  
    }());  
  </script>  
</body>  
</html>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/389434cfebbe537de84bccdd6d23f124.png" alt=""></p>
<p>顺序旋转的四个方块</p>
<h2 id="插值与缓动函数">插值与缓动函数</h2>
<p>我们前面说过，时序动画的好处就在于，它能更容易地控制动画的细节。那针对我们总结出的这个标准的动画模型，它又如何控制动画细节呢？</p>
<p>假设，我们已知元素的起始状态、结束状态和运动周期。如果想要让它进行不规则运动，我们可以使用插值的方式来控制每一帧的展现。比如说，我们可以先实现一个匀速运动的方块，再通过插值与缓动函数来实现变速运动。</p>
<p>首先，我们用 Animator 实现一个方块，让它从 100px 处<strong>匀速运动</strong>到 400px 处。注意，在代码实现的时候，我们使用了一个线性插值方法：left = start * (1 - p) + end * p。线性插值可以很方便地实现属性的均匀变化，所以用它来让方块做匀速运动是非常简单的。但如果是让方块非匀速运动，比如匀加速运动，我们要怎么办呢？</p>
<p>import {Animator} from &lsquo;../common/lib/animator/index.js&rsquo;;<br>
const block = document.querySelector(&rsquo;.block&rsquo;);<br>
const animator = new Animator({duration: 3000});<br>
document.addEventListener(&lsquo;click&rsquo;, () =&gt; {<br>
animator.animate({el: block, start: 100, end: 400}, ({target: {el, start, end}, timing: {p}}) =&gt; {<br>
const left = start * (1 - p) + end * p;<br>
el.style.left = <code>${left}px</code>;<br>
});<br>
});</p>
<p>实现技巧也很简单，我们仍然可以使用线性插值，只不过要对插值参数 p 做一个函数映射。比如说，如果要让方块做初速度为 0 的匀加速运动，我们可以将 p 映射为 p^2。</p>
<p>p = p ** 2;<br>
const left = start * (1 - p) + end * p;</p>
<p>再比如说，如果要让它做末速度为 0 的匀减速运动，我们可以将 p 映射为 p * (2 - p)。</p>
<p>p = p * (2 - p);<br>
const left = start * (1 - p) + end * p;</p>
<p>那为什么匀加速、匀减速的时候，p 要这样映射呢？要理解这一点，我们就得先来回忆一下，匀加速和匀减速运动的物理计算公式。</p>
<p>假设，某个物体在做初速度为 0 的匀加速运动，运动的总时间为 T，总位移为 S。那么，它在 t 时刻的位移和加速度的计算公式如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/9c7900acc5d8b006ef7c0025658d207b.png" alt=""></p>
<p>匀加速运动的计算公式</p>
<p>所以我们把 p 映射为 p 的平方。</p>
<p>还是同样的情况下，如果物体在做匀减速运动，那么，它在 t 时刻的位移和加速度的计算公式如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/a036c26a2da2a3cb1a1bb978fc3861fa.png" alt=""></p>
<p>匀变速运动的计算公式</p>
<p>所以我们把 p 映射为 p(2-p)。</p>
<p>除此以外，我们还可以将 p 映射为三次曲线 p * p * (3.0 - 2.0 * p) ，来实现 smoothstep 的插值效果等等。那为了方便使用以及实现更多的效果，我们可以抽象出一个映射函数专门处理 p 的映射，这个函数叫做<strong>缓动函数</strong>（Easing Function）。</p>
<p>我们可以在前面实现过的 Timing 类中，直接增加一个缓动函数 easing。这样在获取 p 值的时候，我们直接用 this.easing(progress) 取代之前的 progress，就可以让动画变速运动了。修改后的代码如下：</p>
<p>export class Timing {<br>
constructor({duration, iterations = 1, easing = p =&gt; p} = {}) {<br>
this.startTime = Date.now();<br>
this.duration = duration;<br>
this.iterations = iterations;<br>
this.easing = easing;<br>
}</p>
<p>get time() {<br>
return Date.now() - this.startTime;<br>
}</p>
<p>get p() {<br>
const progress = Math.min(this.time / this.duration, this.iterations);<br>
return this.isFinished ? 1 : this.easing(progress % 1);<br>
}</p>
<p>get isFinished() {<br>
return this.time / this.duration &gt;= this.iterations;<br>
}<br>
}</p>
<p>那带入到具体的例子中，我们只要多给 animator 传一个 easing 参数，就可以让一开始匀速运动的小方块变成匀加速运动了。下面就是我们使用这个缓动函数的具体代码：</p>
<p>import {Animator} from &lsquo;../common/lib/animator/index.js&rsquo;;<br>
const block = document.querySelector(&rsquo;.block&rsquo;);<br>
const animator = new Animator({duration: 3000, easing: p =&gt; p ** 2});<br>
document.addEventListener(&lsquo;click&rsquo;, () =&gt; {<br>
animator.animate({el: block, start: 100, end: 400}, ({target: {el, start, end}, timing: {p}}) =&gt; {<br>
const left = start * (1 - p) + end * p;<br>
el.style.left = <code>${left}px</code>;<br>
});<br>
});</p>
<h2 id="贝塞尔曲线缓动">贝塞尔曲线缓动</h2>
<p>现在，我们已经缓动函数的应用了。缓动函数有很多种，其中比较常用的是贝塞尔曲线缓动（Bezier-easing），准确地说，是三次贝塞尔曲线缓动函数。接下来，我们就来一起来实现一个简单的贝塞尔曲线缓动。</p>
<p>我们先来复习一下三次贝塞尔曲线的参数方程：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/5bca8323a590ead52f2ee4cbc225b41f.png" alt=""></p>
<p>对于贝塞尔曲线图形来说，t 是参数，P 是坐标。而贝塞尔曲线缓动函数，则是把 Px 作为时间参数 p，把 Py 作为 p 的映射。这样，我们就知道了参数方程和缓动函数之间映射关系了。</p>
<p><a href="https://react.rocks/example/bezier-easing-editor"><img src="./c4238e6a26b9bebcbcdaf1d195305cf2.png.md" alt=""></a></p>
<p>贝塞尔缓动函数，图盘来源：React.js</p>
<p>那要想把三次贝塞尔曲线参数方程变换成贝塞尔曲线缓动函数，我们可以使用一种数学方法，叫做<strong>牛顿迭代法</strong>（Newton’s method）。因为这个方法比较复杂，所以我就不展开细说了。</p>
<p>我们可以使用现成的 JavaScript 库bezier-easing来生成贝塞尔缓动函数，例如：</p>
<p>import {Animator} from &lsquo;../common/lib/animator/index.js&rsquo;;<br>
const block = document.querySelector(&rsquo;.block&rsquo;);<br>
const animator = new Animator({duration: 3000, easing: BezierEasing(0.5, -1.5, 0.5, 2.5)});<br>
document.addEventListener(&lsquo;click&rsquo;, () =&gt; {<br>
animator.animate({el: block, start: 100, end: 400}, ({target: {el, start, end}, timing: {p}}) =&gt; {<br>
const left = start * (1 - p) + end * p;<br>
el.style.left = <code>${left}px</code>;<br>
});<br>
});</p>
<p>这样，我们能得到如下的效果：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/f6bf10c55cbec5e00770af977d91e55a.png" alt=""></p>
<p>实际上，CSS3 动画原生支持 bezier-easing。所以上面的效果，我们也可以使用 CSS3 动画来实现。</p>
<p>.container {<br>
display: flex;<br>
flex-wrap: wrap;<br>
justify-content: space-between;<br>
width: 300px;<br>
}<br>
.block {<br>
width: 100px;<br>
height: 100px;<br>
position: absolute;<br>
top: 100px;<br>
left: 100px;<br>
background: blue;<br>
flex-shrink: 0;<br>
transform-origin: 50% 50%;<br>
}<br>
.animate {<br>
animation: mymove 3s cubic-bezier(0.5, -1.5, 0.5, 2.5) forwards;<br>
}<br>
@keyframes mymove {<br>
from {left: 100px}<br>
to {left: 400px}<br>
}</p>
<p>其实贝塞尔缓动函数还有很多种，你可以去easing.net这个网站里看一看，然后尝试利用里面提供的缓动函数，来修改我们例子代码中的效果，看看动画过程有什么不同。</p>
<h2 id="要点总结">要点总结</h2>
<p>这节课，我们讲了动画的三种形式和实现它们的基本方法，并且我们重点讨论了由时序动画衍生的标准动画模型，以及在此基础上，利用线性插值和缓动函数来控制更多动画细节。</p>
<p>首先，我们来回顾一下这三种形式的实现方法和各自的特点：</p>
<ol>
<li>第一种，固定帧动画。它实现起来最简单，只需要我们为每一帧准备一张图片，然后循环播放就可以了。</li>
<li>第二种，增量动画。虽然在实现的时候，我们需要在每帧给元素的相关属性增加一定的量，但也很好操作，就是不好精确控制动画细节。</li>
<li>第三种是使用时间和动画函数来描述的动画，也叫做时序动画。这种方法能够非常精确地控制动画的细节，所以它能实现的动画效果更丰富，应用最广泛。</li>
</ol>
<p>然后，为了更方便使用，我们根据时序动画定义了标准动画模型，实现了 Animator 类。基于此，我们就可以使用线性插值来实现动画的匀速运动，通过缓动函数来改变动画的运动速度。</p>
<p>在动画的实现中，比较常用贝塞尔曲线缓动函数。它是通过对贝塞尔曲线方程进行牛顿迭代求出，我们可以使用 bezier-easing 库来创建贝塞尔缓动函数。CSS3 动画原生支持 bezier-easing，所以如果使用 HTML/CSS 方式绘制元素，我们可以尽量使用 CSS3 动画。</p>
<h2 id="小试牛刀">小试牛刀</h2>
<p>最后，我希望你能利用我们今天学到的时序动画，来实现一个简单的动画效果。就是我们假设，有一个半径为 10px 的弹性小球，我们让它以自由落体的方式下落 200px 高度。在这个过程中，小球每次落地后弹起的高度会是之前的一半，然后它会不断重复自由下落的过程，直到静止在地面上。</p>
<p>你能试着用标准动画模型封装好的 Animator 模块，来实现这个效果吗？Animator 模块的代码你可以在 Github 仓库中找到，也可以直接按照我们前面讲解内容自己实现一下。</p>
<h2 id="源码">源码</h2>
<p>本节课的完整示例代码见GitHub 仓库</p>
<h2 id="推荐阅读">推荐阅读</h2>
<p>[1] 牛顿迭代法</p>
<p>[2] Bezier-easing</p>
<p>[3] Easing.net</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/">跟月影学可视化</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/18__%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">18__如何设置线程池大小？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%9836%E8%AE%B2/18__%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%91%98%E5%B7%A5%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%84%8F%E6%84%BF%E5%92%8C%E7%A7%AF%E6%9E%81%E6%80%A7/">
            <span class="next-text nav-default">18__如何提升员工的工作意愿和积极性？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
