<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>26__如何绘制带宽度的曲线？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是月影。
在可视化应用中，我们经常需要绘制一些带有特定宽度的曲线。比如说，在地理信息可视化中，我们会使用曲线来描绘路径，而在 3D 地球可视化中，我们会使用曲线来描述飞线、轮廓线等等。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/26__%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6%E5%B8%A6%E5%AE%BD%E5%BA%A6%E7%9A%84%E6%9B%B2%E7%BA%BF/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/26__%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6%E5%B8%A6%E5%AE%BD%E5%BA%A6%E7%9A%84%E6%9B%B2%E7%BA%BF/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="26__如何绘制带宽度的曲线？">
  <meta property="og:description" content="你好，我是月影。
在可视化应用中，我们经常需要绘制一些带有特定宽度的曲线。比如说，在地理信息可视化中，我们会使用曲线来描绘路径，而在 3D 地球可视化中，我们会使用曲线来描述飞线、轮廓线等等。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="跟月影学可视化">

  <meta itemprop="name" content="26__如何绘制带宽度的曲线？">
  <meta itemprop="description" content="你好，我是月影。
在可视化应用中，我们经常需要绘制一些带有特定宽度的曲线。比如说，在地理信息可视化中，我们会使用曲线来描绘路径，而在 3D 地球可视化中，我们会使用曲线来描述飞线、轮廓线等等。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4048">
  <meta itemprop="keywords" content="跟月影学可视化">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="26__如何绘制带宽度的曲线？">
  <meta name="twitter:description" content="你好，我是月影。
在可视化应用中，我们经常需要绘制一些带有特定宽度的曲线。比如说，在地理信息可视化中，我们会使用曲线来描绘路径，而在 3D 地球可视化中，我们会使用曲线来描述飞线、轮廓线等等。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">26__如何绘制带宽度的曲线？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4048 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#如何用-canvas2d-绘制带宽度的曲线">如何用 Canvas2D 绘制带宽度的曲线？</a></li>
        <li><a href="#如何用-webgl-绘制带宽度的曲线">如何用 WebGL 绘制带宽度的曲线</a></li>
        <li><a href="#通过挤压-extrude-曲线绘制有宽度的曲线">通过挤压 (extrude) 曲线绘制有宽度的曲线</a></li>
        <li><a href="#要点总结">要点总结</a></li>
        <li><a href="#小试牛刀">小试牛刀</a></li>
        <li><a href="#源码">源码</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是月影。</p>
<p>在可视化应用中，我们经常需要绘制一些带有特定宽度的曲线。比如说，在地理信息可视化中，我们会使用曲线来描绘路径，而在 3D 地球可视化中，我们会使用曲线来描述飞线、轮廓线等等。</p>
<p>在 Canvas2D 中，要绘制带宽度的曲线非常简单，我们直接设置上下文对象的 lineWidth 属性就行了。但在 WebGL 中，绘制带宽度的曲线是一个难点，很多开发者都在这一步被难住过。</p>
<p>那今天，我就来说说怎么用 Canvas2D 和 WebGL 分绘制曲线。我要特别强调一下，我们讲的曲线指广义的曲线，线段、折线和平滑曲线都包含在内。</p>
<h2 id="如何用-canvas2d-绘制带宽度的曲线">如何用 Canvas2D 绘制带宽度的曲线？</h2>
<p>刚才我说了，用 Canvas2D 绘制曲线非常简单。这是为什么呢？因为 Canvas2D 提供了相应的 API，能够绘制出不同宽度、具有特定<strong>连线方式</strong>和<strong>线帽形状</strong>的曲线。</p>
<p>这句话怎么理解呢？我们从两个关键词，“连线方式（lineJoin）”和“线帽形状（lineCap）”入手理解。</p>
<p>我们知道，曲线是由线段连接而成的，两个线段中间转折的部分，就是 lineJoin。如果线宽只有一个像素，那么连接处没有什么不同的形式，就是直接连接。但如果线宽超过一个像素，那么连接处的缺口，就会有不同的填充方式，而这些不同的填充方式，就对应了不同的 lineJoin。</p>
<p>比如说，你可以看我给出的这张图，上面就显示了四种不同的 lineJoin。其中，miter 是尖角，round 是圆角，bevel 是斜角，none 是不添加 lineJoin。很好理解，我就不多说了</p>
<p><a href="https://mapserver.org/mapfile/symbology/construction.html"><img src="./b17d413fdc9010a6c13cda7003da7247.png.md" alt=""></a></p>
<p>4 种不同的 lineJoin</p>
<p>说完了 lineJoin，那什么是 lineCap 呢？lineCap 就是指曲线头尾部的形状，它有三种类型。第一种是 square，方形线帽，它会在线段的头尾端延长线宽的一半。第二种 round 也叫圆弧线帽，它会在头尾端延长一个半圆。第三种是 butt，就是不添加线帽。</p>
<p><a href="http://falcon80.com/HTMLCanvas/Attributes/lineCap.html"><img src="./23cf8312eda0dc9c0fd099113df1184a.png.md" alt=""></a></p>
<p>3 种不同的 lineCap</p>
<p>理解了这两个关键词之后，我们接着尝试一下，怎么在 Canvas 的上下文中，通过设置 lineJoin 和 lineCap 属性，来实现不同的曲线效果。</p>
<p>首先，我们要实现一个 drawPolyline 函数。这个函数非常简单，就是设置 lineWidth、lingJoin、lineCap，然后根据 points 数据的内容设置绘图指令执行绘制。</p>
<p>function drawPolyline(context, points, {lineWidth = 1, lineJoin = &lsquo;miter&rsquo;, lineCap = &lsquo;butt&rsquo;} = {}) {<br>
context.lineWidth = lineWidth;<br>
context.lineJoin = lineJoin;<br>
context.lineCap = lineCap;<br>
context.beginPath();<br>
context.moveTo(&hellip;points[0]);<br>
for(let i = 1; i &lt; points.length; i++) {<br>
context.lineTo(&hellip;points[i]);<br>
}<br>
context.stroke();<br>
}</p>
<p>在设置 lingJoin、lineCap 时候，我们要注意，Canvas2D 的 lineJoin 只支持 miter、bevel 和 round，不支持 none。lineCap 支持 butt、square 和 round。</p>
<p>接着，我们就可以执行 JavaScript 代码绘制曲线了。比如，我们绘制两条线，一条宽度为 10 个像素的红线，另一条宽度为 1 个像素的蓝线，具体的代码：</p>
<p>const canvas = document.querySelector(&lsquo;canvas&rsquo;);<br>
const ctx = canvas.getContext(&lsquo;2d&rsquo;);<br>
const points = [<br>
[100, 100],<br>
[100, 200],<br>
[200, 150],<br>
[300, 200],<br>
[300, 100],<br>
];<br>
ctx.strokeStyle = &lsquo;red&rsquo;;<br>
drawPolyline(ctx, points, {lineWidth: 10});<br>
ctx.strokeStyle = &lsquo;blue&rsquo;;<br>
drawPolyline(ctx, points);</p>
<p>因为我们把连接设置成 miter、线帽设置成了 butt，所以我们绘制出来的曲线，是尖角并且不带线帽的。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/b250d326b699629b841c94f6a7b1b0f7.png" alt=""></p>
<p>其实，我们还可以修改 lineJoins 和 lineCap 参数。比如，我们将线帽设为圆的，连接设为斜角。除此之外，你还可以尝试不同的组合，我就不再举例了。</p>
<p>ctx.strokeStyle = &lsquo;red&rsquo;;<br>
drawPolyline(ctx, points, {lineWidth: 10, lineCap: &lsquo;round&rsquo;, lineJoin: &lsquo;bevel&rsquo;});</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/e9912feaa53a367378aa8e1cfa633dfa.png" alt=""></p>
<p>除了 lineJoin 和 lineCap 外，我们还可以设置 Canvas2D 上下文的 miterLimit 属性，来改变 lineJoin 等于 miter 时的连线形式，miterLimit 属性等于 miter 和线宽的最大比值。当我们把 lineJoin 设置成 miter 的时候，miterLimit 属性就会限制尖角的最大值。</p>
<p>那具体会产生什么效果呢？我们可以先修改 drawPolyline 代码添加 miterLimit。代码如下：</p>
<p>function drawPolyline(context, points, {lineWidth = 1, lineJoin = &lsquo;miter&rsquo;, lineCap = &lsquo;butt&rsquo;, miterLimit = 10} = {}) {<br>
context.lineWidth = lineWidth;<br>
context.lineJoin = lineJoin;<br>
context.lineCap = lineCap;<br>
context.miterLimit = miterLimit;<br>
context.beginPath();<br>
context.moveTo(&hellip;points[0]);<br>
for(let i = 1; i &lt; points.length; i++) {<br>
context.lineTo(&hellip;points[i]);<br>
}<br>
context.stroke();<br>
}</p>
<p>然后，我们修改参数，把 miterLimit: 设置为 1.5：</p>
<p>ctx.strokeStyle = &lsquo;red&rsquo;;<br>
drawPolyline(ctx, points, {lineWidth: 10, lineCap: &lsquo;round&rsquo;, lineJoin: &lsquo;miter&rsquo;, miterLimit: 1.5});</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/e9912feaa53a367378aa8e1cfa633dfa.png" alt=""></p>
<p>你会发现，这样渲染出来的图形，它两侧的转角由于超过了 miterLimit 限制，所以表现为斜角，而中间的转角因为没有超过 miterLimit 限制，所以是尖角。</p>
<p>总的来说，Canvas2D 绘制曲线的方法很简单，只要我们调用对应的 API 就可以了。但用 WebGL 来绘制同样的曲线会非常麻烦。在详细讲解之前，我希望你先记住 lineJoin、lineCap 以及 miterLimit 这些属性，在 WebGL 中我们需要自己去实现它们。接下来，我们一起来看一下 WebGL 中是怎么做的。</p>
<h2 id="如何用-webgl-绘制带宽度的曲线">如何用 WebGL 绘制带宽度的曲线</h2>
<p>我们先从绘制宽度为 1 的曲线开始。因为 WebGL 本身就支持线段类的图元，所以我们直接用图元就能绘制出宽度为 1 的曲线。</p>
<p>下面，我结合代码来说说具体的绘制过程。与 Canvas2D 类似，我们直接设置 position 顶点坐标，然后设置 mode 为 gl.LINE_STRIP。这里的 LINE_STRIP 是一种图元类型，表示以首尾连接的线段方式绘制。这样，我们就可以得到宽度为 1 的折线了。具体的代码和效果如下所示：</p>
<p>import {Renderer, Program, Geometry, Transform, Mesh} from &lsquo;../common/lib/ogl/index.mjs&rsquo;;</p>
<p>const vertex = `<br>
attribute vec2 position;</p>
<p>void main() {<br>
gl_PointSize = 10.0;<br>
float scale = 1.0 / 256.0;<br>
mat3 projectionMatrix = mat3(<br>
scale, 0, 0,<br>
0, -scale, 0,<br>
-1, 1, 1<br>
);<br>
vec3 pos = projectionMatrix * vec3(position, 1);<br>
gl_Position = vec4(pos.xy, 0, 1);<br>
}<br>
`;</p>
<p>const fragment = <code>  precision highp float;   void main() {   gl_FragColor = vec4(1, 0, 0, 1);   }  </code>;</p>
<p>const canvas = document.querySelector(&lsquo;canvas&rsquo;);<br>
const renderer = new Renderer({<br>
canvas,<br>
width: 512,<br>
height: 512,<br>
});</p>
<p>const gl = renderer.gl;<br>
gl.clearColor(1, 1, 1, 1);</p>
<p>const program = new Program(gl, {<br>
vertex,<br>
fragment,<br>
});</p>
<p>const geometry = new Geometry(gl, {<br>
position: {size: 2,<br>
data: new Float32Array(<br>
[<br>
100, 100,<br>
100, 200,<br>
200, 150,<br>
300, 200,<br>
300, 100,<br>
],<br>
)},<br>
});</p>
<p>const scene = new Transform();<br>
const polyline = new Mesh(gl, {geometry, program, mode: gl.LINE_STRIP});<br>
polyline.setParent(scene);</p>
<p>renderer.render({scene});</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/8bb5d0886cd79ef8846bf94430faa896.png" alt=""></p>
<p>你可能会问，我们不能直接修改 gl_PointSize，来给折线设置宽度吗？很遗憾，这是不行的。因为 gl_PointSize 只能影响 gl.POINTS 图元的显示，并不能对线段图元产生影响。</p>
<p>那我们该怎么让线的宽度大于 1 个像素呢？</p>
<h2 id="通过挤压-extrude-曲线绘制有宽度的曲线">通过挤压 (extrude) 曲线绘制有宽度的曲线</h2>
<p>我们可以用一种挤压（Extrude）曲线的技术，通过将曲线的顶点沿法线方向向两侧移出，让 1 个像素的曲线变宽。</p>
<p>那挤压曲线要怎么做呢？我们先看一张示意图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/1b23bd46b16b9cda65e1c10458b9862f.png" alt=""></p>
<p>挤压线段</p>
<p>如上图所示，黑色折线是原始的 1 个像素宽度的折线，蓝色虚线组成的是我们最终要生成的带宽度曲线，红色虚线是顶点移动的方向。因为折线两个端点的挤压只和一条线段的方向有关，而转角处顶点的挤压和相邻两条线段的方向都有关，所以顶点移动的方向，我们要分两种情况讨论。</p>
<p>首先，是折线的端点。假设线段的向量为（x, y），因为它移动方向和线段方向垂直，所以我们只要沿法线方向移动它就可以了。根据垂直向量的点积为 0，我们很容易得出顶点的两个移动方向为（-y, x）和（y, -x）。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/0da2ef734105922a75f61cf37b0e08e6.png" alt=""></p>
<p>折线端点挤压方向</p>
<p>端点挤压方向确定了，接下来要确定转角的挤压方向了，我们还是看示意图。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/b5ef844d5cc735180796d133b100f878.png" alt=""></p>
<p>转角的挤压方向示意图</p>
<p>如上图，我们假设有折线 abc，b 是转角。我们延长 ab，就能得到一个单位向量 v1，反向延长 bc，可以得到另一个单位向量 v2，那么挤压方向就是向量 v1+v2 的方向，以及相反的 -(v1+v2) 的方向。</p>
<p>现在我们得到了挤压方向，接下来就需要确定挤压向量的长度。</p>
<p>首先是折线端点的挤压长度，它等于 lineWidth 的一半。而转角的挤压长度就比较复杂了，我们需要再计算一下。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/c457871eb3b29e84308ae8cbb150a288.png" alt=""></p>
<p>计算转角挤压长度示意图</p>
<p>绿色这条辅助线应该等于 lineWidth 的一半，而它又恰好是 v1+v2 在绿色这条向量方向的投影，所以，我们可以先用向量点积求出红色虚线和绿色虚线夹角的余弦值，然后用 lineWidth 的一半除以这个值，得到的就是挤压向量的长度了。</p>
<p>具体用 JavaScript 实现的代码如下所示：</p>
<p>function extrudePolyline(gl, points, {thickness = 10} = {}) {<br>
const halfThick = 0.5 * thickness;<br>
const innerSide = [];<br>
const outerSide = [];</p>
<p>// 构建挤压顶点<br>
for(let i = 1; i &lt; points.length - 1; i++) {<br>
const v1 = (new Vec2()).sub(points[i], points[i - 1]).normalize();<br>
const v2 = (new Vec2()).sub(points[i], points[i + 1]).normalize();<br>
const v = (new Vec2()).add(v1, v2).normalize(); // 得到挤压方向<br>
const norm = new Vec2(-v1.y, v1.x); // 法线方向<br>
const cos = norm.dot(v);<br>
const len = halfThick / cos;<br>
if(i === 1) { // 起始点<br>
const v0 = new Vec2(&hellip;norm).scale(halfThick);<br>
outerSide.push((new Vec2()).add(points[0], v0));<br>
innerSide.push((new Vec2()).sub(points[0], v0));<br>
}<br>
v.scale(len);<br>
outerSide.push((new Vec2()).add(points[i], v));<br>
innerSide.push((new Vec2()).sub(points[i], v));<br>
if(i === points.length - 2) { // 结束点<br>
const norm2 = new Vec2(v2.y, -v2.x);<br>
const v0 = new Vec2(&hellip;norm2).scale(halfThick);<br>
outerSide.push((new Vec2()).add(points[points.length - 1], v0));<br>
innerSide.push((new Vec2()).sub(points[points.length - 1], v0));<br>
}<br>
}<br>
&hellip;<br>
}</p>
<p>在这段代码中，v1、v2 是线段的延长线，v 是挤压方向，我们计算法线方向与挤压方向的余弦值，就能算出挤压长度了。你还要注意，我们要把起始点和结束点这两个端点的挤压也给添加进去，也就是两个 if 条件中的处理逻辑。</p>
<p>这样一来，我们就把挤压之后的折线顶点坐标给计算出来了。向内和向外挤压的点现在分别保存在 innerSide 和 outerSide 数组中。</p>
<p>接下来，我们就要构建对应的 Geometry 对象，所以我们继续添加 extrudePolyline 函数的后半部分。</p>
<p>function extrudePolyline(gl, points, {thickness = 10} = {})<br>
&hellip;<br>
const count = innerSide.length * 4 - 4;<br>
const position = new Float32Array(count * 2);<br>
const index = new Uint16Array(6 * count / 4);</p>
<p>// 创建 geometry 对象<br>
for(let i = 0; i &lt; innerSide.length - 1; i++) {<br>
const a = innerSide[i],<br>
b = outerSide[i],<br>
c = innerSide[i + 1],<br>
d = outerSide[i + 1];</p>
<pre><code>const offset = i * 4;  
index.set([offset, offset + 1, offset + 2, offset + 2, offset + 1, offset + 3], i * 6);  
position.set([...a, ...b, ...c, ...d], i * 8);  
</code></pre>
<p>}</p>
<p>return new Geometry(gl, {<br>
position: {size: 2, data: position},<br>
index: {data: index},<br>
});<br>
}</p>
<p>这一步骤就非常简单了，我们根据 innerSide 和 outerSide 中的顶点来构建三角网格化的几何体顶点数据，最终返回 Geometry 对象。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/e761583c1af43659224015fbb0bf2a6e.png" alt=""></p>
<p>构建折线的顶点数据</p>
<p>最后，我们只要调用 extrudePolyline，传入折线顶点和宽度，然后用返回的 Geometry 对象来构建三角网格对象，将它渲染出来就可以了。</p>
<p>const geometry = extrudePolyline(gl, points, {lineWidth: 10});</p>
<p>const scene = new Transform();<br>
const polyline = new Mesh(gl, {geometry, program});<br>
polyline.setParent(scene);</p>
<p>renderer.render({scene});</p>
<p>我们最终渲染出来的效果如下图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/1e1070969c5fabee92304c27873514e1.png" alt=""></p>
<p>这样，我们就在 WebGL 中实现了，与 Canvas2D 一样带宽度的曲线。</p>
<p>当然，这里我们只实现了最基础的带宽度曲线，它对应于 Canvas2D 中的 lineJoin 为 miter，lineCap 为 butt 的曲线。不过，想要实现 lineJoins 为 bevel 或 round，lineCap 为 square 或 round 的曲线，也不会太困难。我们可以基于 extrudePolyline 函数，对它进行扩展，计算出相应属性下对应的顶点就行了。因为基本原理是一样的，我就不详细说了，我把扩展的任务留给你作为课后练习。</p>
<h2 id="要点总结">要点总结</h2>
<p>这节课，我们讲了绘制带宽度曲线的方法。</p>
<p>首先，在 Canvas2D 中，绘制这样的曲线比较简单，我们直接通过 API 设置 lineWidth 即可。而且，Canvas2D 还支持不同的 lineJoin、lineCap 设置以及 miterLimit 设置。</p>
<p>在 WebGL 中，绘制带宽度的曲线则比较麻烦，因为没有现成的 API 可以使用。这个时候，我们可以使用挤压曲线的技术来得到带宽度的曲线，挤压曲线的具体步骤可以总结为三步：</p>
<ol>
<li>确定端点和转角的挤压方向，端点可以沿线段的法线挤压，转角则通过两条线段延长线的单位向量求和的方式获得。</li>
<li>确定端点和转角挤压的长度，端点两个方向的挤压长度是线宽 lineWidth 的一半。求转角挤压长度的时候，我们要先计算方向向量和线段法线的余弦，然后将线宽 lineWidth 的一半除以我们计算出的余弦值。</li>
<li>由步骤 1、2 计算出顶点后，我们构建三角网格化的几何体顶点数据，然后将 Geometry 对象返回。</li>
</ol>
<p>这样，我们就可以用 WebGL 绘制出有宽度的曲线了。</p>
<h2 id="小试牛刀">小试牛刀</h2>
<ol>
<li>你能修改 extrudePolyline 函数，让它支持 lineCap 为 square 和 round 吗？或者让它支持 lineJoin 为 round 吗？</li>
<li>我想让你试着修改一下 extrudePolyline 函数，让它支持 lineJoin 为 bevel，以及 miterLimit。并且，当 lineJoin 为 miter 的时候，如果转角挤压长度超过了 miterLimit，我们就按照 bevel 处理向外的挤压。</li>
</ol>
<p>那通过今天的学习，你是不是已经学会绘制带宽度曲线的方法。那不妨就把这节课分享给你的朋友，也帮助他解决这个难题吧。好了，今天的内容就到这里了，我们下节课再见</p>
<h2 id="源码">源码</h2>
<p>课程完整示例代码详见GitHub 仓库</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/">跟月影学可视化</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E5%AE%9E%E6%88%98%E8%AF%BE/26__%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E4%BA%A7%E5%93%81%E7%9A%84%E6%96%87%E5%8C%96/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">26__如何打造产品的文化？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%9836%E8%AE%B2/26__%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9C%89%E6%95%88%E6%89%A7%E8%A1%8C/">
            <span class="next-text nav-default">26__如何确保项目的有效执行？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
