<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>02__指令式绘图系统：如何用Canvas绘制层次关系图？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是月影。
Canvas 是可视化领域里非常重要且常用的图形系统，在可视化项目中，它能够帮助我们将数据内容以几何图形的形式，非常方便地呈现出来。
今天，我们就在上一节课的基础上对 Canvas 进行稍微深入一些的介绍，来学习一下 Canvas 绘制基本几何图形的方法。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/02__%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%BB%98%E5%9B%BE%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E7%94%A8canvas%E7%BB%98%E5%88%B6%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/02__%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%BB%98%E5%9B%BE%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E7%94%A8canvas%E7%BB%98%E5%88%B6%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="02__指令式绘图系统：如何用Canvas绘制层次关系图？">
  <meta property="og:description" content="你好，我是月影。
Canvas 是可视化领域里非常重要且常用的图形系统，在可视化项目中，它能够帮助我们将数据内容以几何图形的形式，非常方便地呈现出来。
今天，我们就在上一节课的基础上对 Canvas 进行稍微深入一些的介绍，来学习一下 Canvas 绘制基本几何图形的方法。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="跟月影学可视化">

  <meta itemprop="name" content="02__指令式绘图系统：如何用Canvas绘制层次关系图？">
  <meta itemprop="description" content="你好，我是月影。
Canvas 是可视化领域里非常重要且常用的图形系统，在可视化项目中，它能够帮助我们将数据内容以几何图形的形式，非常方便地呈现出来。
今天，我们就在上一节课的基础上对 Canvas 进行稍微深入一些的介绍，来学习一下 Canvas 绘制基本几何图形的方法。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6428">
  <meta itemprop="keywords" content="跟月影学可视化">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="02__指令式绘图系统：如何用Canvas绘制层次关系图？">
  <meta name="twitter:description" content="你好，我是月影。
Canvas 是可视化领域里非常重要且常用的图形系统，在可视化项目中，它能够帮助我们将数据内容以几何图形的形式，非常方便地呈现出来。
今天，我们就在上一节课的基础上对 Canvas 进行稍微深入一些的介绍，来学习一下 Canvas 绘制基本几何图形的方法。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">02__指令式绘图系统：如何用Canvas绘制层次关系图？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6428 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#如何用-canvas-绘制几何图形">如何用 Canvas 绘制几何图形？</a>
          <ul>
            <li><a href="#1-canvas-元素和-2d-上下文">1. Canvas 元素和 2D 上下文</a></li>
            <li><a href="#2-canvas-的坐标系">2. Canvas 的坐标系</a></li>
            <li><a href="#3-利用-canvas-绘制几何图形">3. 利用 Canvas 绘制几何图形</a></li>
          </ul>
        </li>
        <li><a href="#如何用-canvas-绘制层次关系图">如何用 Canvas 绘制层次关系图？</a></li>
        <li><a href="#canvas-有哪些优缺点">Canvas 有哪些优缺点？</a></li>
        <li><a href="#要点总结">要点总结</a></li>
        <li><a href="#小试牛刀">小试牛刀</a></li>
        <li><a href="#源码">源码</a></li>
        <li><a href="#推荐阅读">推荐阅读</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是月影。</p>
<p>Canvas 是可视化领域里非常重要且常用的图形系统，在可视化项目中，它能够帮助我们将数据内容以几何图形的形式，非常方便地呈现出来。</p>
<p>今天，我们就在上一节课的基础上对 Canvas 进行稍微深入一些的介绍，来学习一下 Canvas 绘制基本几何图形的方法。</p>
<p>我主要会讲解如何用它的 2D 上下文来完成绘图，不过，我不会去讲和它有关的所有 Api，重点只是希望通过调用一些常用的 API 能给你讲清楚，Canvas2D 能做什么、要怎么使用，以及它的局限性是什么。最后，我还会带你用 Canvas 绘制一个表示省市关系的层次关系图（Hierarchy Graph）。希望通过这个可视化的例子，能帮你实践并掌握 Canvas 的用法。</p>
<p>在我们后面的课程中，基本上 70~80% 的图都可以用 Canvas 来绘制，所以其重要性不言而喻。话不多说，让我们正式开始今天的内容吧！</p>
<h2 id="如何用-canvas-绘制几何图形">如何用 Canvas 绘制几何图形？</h2>
<p>首先，我们通过一个绘制红色正方形的简单例子，来讲一讲 Canvas 的基本用法。</p>
<h3 id="1-canvas-元素和-2d-上下文">1. Canvas 元素和 2D 上下文</h3>
<p>对浏览器来说，Canvas 也是 HTML 元素，我们可以用 canvas 标签将它插入到 HTML 内容中。比如，我们可以在 body 里插入一个宽、高分别为 512 的 canvas 元素。</p>
<body>  
  <canvas width="512" height="512"></canvas>  
</body>
<p>这里有一点需要特别注意，Canvas 元素上的 width 和 height 属性不等同于 Canvas 元素的 CSS 样式的属性。这是因为，CSS 属性中的宽高影响 Canvas 在页面上呈现的大小，而 HTML 属性中的宽高则决定了 Canvas 的坐标系。为了区分它们，我们称 Canvas 的 HTML 属性宽高为<strong>画布宽高</strong>，CSS 样式宽高为<strong>样式宽高</strong>。</p>
<p>在实际绘制的时候，如果我们不设置 Canvas 元素的样式，那么 Canvas 元素的画布宽高就会等于它的样式宽高的像素值，也就是 512px。</p>
<p>而如果这个时候，我们通过 CSS 设置其他的值指定了它的样式宽高。比如说，我们将样式宽高设置成 256px，那么它实际的画布宽高就是样式宽高的两倍了。代码和效果如下：</p>
<p>canvas {<br>
width: 256px;<br>
height: 256px;<br>
}</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/d85632b9f5d9cd60c2110fe37be74948.png" alt=""></p>
<p>将 canvas 的样式宽高设为 256px，画布宽高设为 512px</p>
<p>因为画布宽高决定了可视区域的坐标范围，所以 Canvas 将画布宽高和样式宽高分开的做法，能更方便地适配不同的显示设备。</p>
<p>比如，我们要在画布宽高为 500<code>*</code>500 的 Canvas 画布上，绘制一个居中显示的 100<code>*</code>100 宽高的正方形。我们只要将它的坐标设置在 x = 200, y = 200 处即可。这样，不论这个 Canvas 以多大的尺寸显示在各种设备上，我们的代码都不需要修改。否则，如果 Canvas 的坐标范围（画布宽高）跟着样式宽高变化，那么当屏幕尺寸改变的时候，我们就要重新计算需要绘制的图形的所有坐标，这对于我们来说将会是一场“灾难”。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/72c2748243294a9cf97625fd812c4d11.png" alt=""></p>
<p>在画布宽高为 500X500 的 Canvas 上居中绘制一个 100`*`100 的正方形</p>
<h3 id="2-canvas-的坐标系">2. Canvas 的坐标系</h3>
<p>好了，Canvas 画布已经设置好了，接下来我们来了解一下 Canvas 的坐标系。</p>
<p>Canvas 的坐标系和浏览器窗口的坐标系类似，它们都默认左上角为坐标原点，x 轴水平向右，y 轴垂直向下。那在我们设置好的画布宽高为 512<code>*</code>512 的 Canvas 画布中，它的左上角坐标值为（0,0），右下角坐标值为（512,512） 。这意味着，坐标（0,0）到（512,512）之间的所有图形，都会被浏览器渲染到画布上。</p>
<p><a href="https://www.jianshu.com/p/ef8244cb7ec4"><img src="./d1d5559c69b1be75bd0638cfcdedf7e4.png.md" alt=""></a></p>
<p>canvas 坐标系</p>
<p>注意，上图中这个坐标系的 y 轴向下，意味着这个坐标系和笛卡尔坐标系不同，它们的 y 轴是相反的。那在实际应用的时候，如果我们想绘制一个向右上平抛小球的动画，它的抛物线轨迹，在 Canvas 上绘制出来的方向就是向下凹的。</p>
<p><a href="https://www.jianshu.com/p/ef8244cb7ec4"><img src="./0bb49cb61ae4cb8047b59513a6e538fe.png.md" alt=""></a></p>
<p>Canvas 坐标系</p>
<p>另外，如果我们再考虑旋转或者三维运动，这个坐标系就会变成“左手系”。而左手系的平面法向量的方向和旋转方向，和我们熟悉的右手系相反。如果你现在还不能完全理解它们的区别，那也没关系，在实际应用的时候，我会再讲的，这里你只需要有一个大体印象就可以了。</p>
<p><a href="https://zhuanlan.zhihu.com/p/64707259"><img src="./79c65d720b903230b7bd99d650f3da82.png.md" alt=""></a></p>
<p>左手系和右手系</p>
<h3 id="3-利用-canvas-绘制几何图形">3. 利用 Canvas 绘制几何图形</h3>
<p>有了坐标系，我们就可以将几何图形绘制到 Canvas 上了。具体的步骤可以分为两步，分别是获取 Canvas 上下文和利用 Canvas 上下文绘制图形。下面，我们一一来看。</p>
<p><strong>第一步，获取 Canvas 上下文。</strong></p>
<p>那在 JavaScript 中，我们要获取 Canvas 上下文也需要两个步骤。首先是获取 Canvas 元素。因为 Canvas 元素就是 HTML 文档中的 canvas 标签，所以，我们可以通过 DOM API 获取它，代码如下：</p>
<p>const canvas = document.querySelector(&lsquo;canvas&rsquo;);</p>
<p>获取了 canvas 元素后，我们就可以通过 getContext 方法拿到它的上下文对象。具体的操作就是，我们调用 canvas.getContext 传入参数 2d。</p>
<p>const context = canvas.getContext(&lsquo;2d&rsquo;);</p>
<p>有了 2d 上下文，我们就可以开始绘制图形了。</p>
<p><strong>第二步，用 Canvas 上下文绘制图形。</strong></p>
<p>我们拿到的 context 对象上会有许多 API，它们大体上可以分为两类：一类是设置状态的 API，可以设置或改变当前的绘图状态，比如，改变要绘制图形的颜色、线宽、坐标变换等等；另一类是绘制指令 API，用来绘制不同形状的几何图形。</p>
<p>如何使用这些 API 呢？我来举个例子，假设我们要在画布的中心位置绘制一个 100<code>*</code>100 的红色正方形。那我们该怎么做呢？</p>
<p>首先，我们要通过计算得到 Canvas 画布的中心点。前面我们已经说过，Canvas 坐标系的左上角坐标是 (0,0)，右下角是 Canvas 的画布坐标，即（canvas.width,canvas.height），所以画布的中心点坐标是（0.5 <code>*</code>canvas.width, 0.5 <code>*</code> canvas.height）。</p>
<p>如果我们要在中心点绘制一个 100 <code>*</code> 100 的正方形，那对应的 Canvas 指令是：</p>
<p>context.rect(0.5 * canvas.width, 0.5 * canvas.height, 100, 100);</p>
<p>其中，context.rect 是绘制矩形的 Canvas 指令，它的四个参数分别表示要绘制的矩形的 x、y 坐标和宽高。在这里我们要绘制的正方形宽高都是 100，所以后两个参数是 100 和 100。</p>
<p>那在实际绘制之前，我们还有一些工作要做。我要将正方形填充成红色，这一步通过调用 context.fillStyle 指令就可以完成。然后，我们要调用一个 beginPath 的指令，告诉 Canvas 我们现在绘制的路径。接着，才是调用 rect 指令完成绘图。最后，我们还要调用 fill 指令，将绘制的内容真正输出到画布中。这样我们就完整了绘制，绘制的效果和代码如下：</p>
<p>const rectSize = [100, 100];<br>
context.fillStyle = &lsquo;red&rsquo;;<br>
context.beginPath();<br>
context.rect(0.5 * canvas.width, 0.5 * canvas.height, &hellip;rectSize);<br>
context.fill();</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/3f5716a98c3773db695a3de4461ad486.png" alt=""></p>
<p>但是，看到上面这张图，我们发现了一个问题：正方形并没有居于画布的正中心。这是为什么呢？</p>
<p>你可以回想一下我们刚才的操作，在绘制正方形的时候，我们将 rect 指令的参数 x、y 设为画布宽高的一半。而 rect 指令的 x、y 的值表示的是，我们要绘制出的矩形的左上角坐标而不是中心点坐标，所以绘制出来的正方形自然就不在正中心了。</p>
<p>那我们该如何将正方形的中心点放在画布的中心呢？这就需要我们移动一下图形中心的坐标了。具体的实现方法有两种。</p>
<p><strong>第一种做法</strong>是，我们可以让 rect 指令的 x、y 参数，等于画布宽高的一半分别减去矩形自身宽高的一半。这样，我们就把正方形的中心点真正地移动到画布中心了。代码如下所示：</p>
<p>context.rect(0.5 * (canvas.width - rectSize[0]), 0.5 * (canvas.height - rectSize[1]), &hellip;rectSize);</p>
<p><strong>第二种做法</strong>是，我们可以先给画布设置一个平移变换（Translate），然后再进行绘制。代码如下所示：</p>
<p>context.translate(-0.5 * rectSize[0], -0.5 * rectSize[1]);</p>
<p>在上面的代码中，我们给画布设置了一个平移，平移距离为矩形宽高的一半，这样它的中心点就是画布的中心了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/23d59eab77e0b3edbbbf541933009c39.png" alt=""></p>
<p>既然这两种方法都能将图形绘制到画布的中心，那我们该怎么选择呢？其实，我们可以从这两种方式各自的优缺点入手，下面我就具体来说一说。</p>
<p>第一种方式很简单，它直接改变了我们要绘制的图形顶点的坐标位置，但如果我们绘制的不是矩形，而是很多顶点的多边形，我们就需要在绘图前重新计算出每个顶点的位置，这会非常麻烦。</p>
<p>第二种方式是对 Canvas 画布的整体做一个平移操作，这样我们只需要获取中心点与左上角的偏移，然后对画布设置 translate 变换就可以了，不需要再去改变图形的顶点位置。不过，这样一来我们就改变了画布的状态。如果后续还有其他的图形需要绘制，我们一定要记得把画布状态给恢复回来。好在，这也不会影响到我们已经画好的图形。</p>
<p>那怎么把画布状态恢复回来呢？恢复画布状态的方式有两种，**第一种是反向平移。**反向平移的原理也很简单，你可以直接看下面的代码。</p>
<p>// 平移<br>
context.translate(-0.5 * rectSize[0], -0.5 * rectSize[1]);</p>
<p>&hellip; 执行绘制</p>
<p>// 恢复<br>
context.translate(0.5 * rectSize[0], 0.5 * rectSize[1]);</p>
<p>除了使用反向平移的恢复方式以外，Canvas 上下文还提供了 <strong>save 和 restore</strong> 方法，可以暂存和恢复画布某个时刻的状态。其中，save 指令不仅可以保存当前的 translate 状态，还可以保存其他的信息，比如，fillStyle 等颜色信息。而 restore 指令则可以将状态指令恢复成 save 指令前的设置。操作代码如下：</p>
<p>context.save(); // 暂存状态<br>
// 平移<br>
context.translate(-0.5 * rectSize[0], -0.5 * rectSize[1]);</p>
<p>&hellip; 执行绘制</p>
<p>context.restore(); // 恢复状态</p>
<p>好了，把一个简单矩形绘制到画布中心的完整方法，我们已经说完了。那我们再来回顾一下利用 Canvas 绘制矩形的过程。我把这个过程总结为了 5 个步骤：</p>
<ol>
<li>获取 Canvas 对象，通过 getContext(‘2d’) 得到 2D 上下文；</li>
<li>设置绘图状态，比如填充颜色 fillStyle，平移变换 translate 等等；</li>
<li>调用 beginPath 指令开始绘制图形；</li>
<li>调用绘图指令，比如 rect，表示绘制矩形；</li>
<li>调用 fill 指令，将绘制内容真正输出到画布上。</li>
</ol>
<p>除此之外，Canvas 上下文还提供了更多丰富的 API，可以用来绘制直线、多边形、弧线、圆、椭圆、扇形和贝塞尔曲线等等，这里我们不一一介绍了。在之后的课程中，我们会详细讲解如何利用这些 API 来绘制复杂的几何图形。如果你还想了解更多关于 Canvas 的 API 相关的知识，还可以去阅读MDN 文档。</p>
<h2 id="如何用-canvas-绘制层次关系图">如何用 Canvas 绘制层次关系图？</h2>
<p>知道了 Canvas 的基本用法之后，接下来，我们就可以利用 Canvas 给一组城市数据绘制一个层次关系图了。也就是在一组给出的层次结构数据中，体现出同属于一个省的城市。</p>
<p>在操作之前呢，我们先引入一个概念层次结构数据（Hierarchy Data），它是可视化领域的专业术语，用来表示能够体现层次结构的信息，例如城市与省与国家。一般来说，层次结构数据用层次关系图表来呈现。</p>
<p>其中，城市数据是一组 JSON 格式的数据，如下所示。</p>
<p>{<br>
&ldquo;name&rdquo;:&ldquo;中国&rdquo;,<br>
&ldquo;children&rdquo;:<br>
[<br>
{<br>
&ldquo;name&rdquo;:&ldquo;浙江&rdquo; ,<br>
&ldquo;children&rdquo;:<br>
[<br>
{&ldquo;name&rdquo;:&ldquo;杭州&rdquo; },<br>
{&ldquo;name&rdquo;:&ldquo;宁波&rdquo; },<br>
{&ldquo;name&rdquo;:&ldquo;温州&rdquo; },<br>
{&ldquo;name&rdquo;:&ldquo;绍兴&rdquo; }<br>
]<br>
},<br>
{<br>
&ldquo;name&rdquo;:&ldquo;广西&rdquo; ,<br>
&ldquo;children&rdquo;:<br>
[<br>
{&ldquo;name&rdquo;:&ldquo;桂林&rdquo;},<br>
{&ldquo;name&rdquo;:&ldquo;南宁&rdquo;},<br>
&hellip;<br>
}<br>
]<br>
}</p>
<p>我们要绘制的层次关系图效果如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/8def9148fd1c8518c6b8ee263093d406.png" alt=""></p>
<p>知道了要求之后，我们应该怎么做呢？首先，我们要从数据源获取 JSON 数据。</p>
<p>const dataSource = &lsquo;<a href="https://s5.ssl.qhres.com/static/b0695e2dd30daa64.json';">https://s5.ssl.qhres.com/static/b0695e2dd30daa64.json';</a><br>
(async function () {<br>
const data = await (await fetch(dataSource)).json();</p>
<p>}();</p>
<p>这份 JSON 数据中只有“城市 &gt; 省份 &gt; 中国”这样的层级数据，我们要将它与绘图指令建立联系。建立联系指的是，我们要把数据的层级、位置和要绘制的圆的半径、位置一一对应起来。</p>
<p>换句话说，我们要把数据转换成图形信息，这个步骤需要数学计算。不过，我们可以直接使用 d3-hierarchyd3-hierarchy这个工具库转换数据。</p>
<p>(async function () {<br>
const data = await (await fetch(dataSource)).json();</p>
<p>const regions = d3.hierarchy(data)<br>
.sum(d =&gt; 1)<br>
.sort((a, b) =&gt; b.value - a.value);</p>
<p>const pack = d3.pack()<br>
.size([1600, 1600])<br>
.padding(3);</p>
<p>const root = pack(regions);<br>
}();</p>
<p>数学计算的内容，我会在数据篇中详细来讲。这里，我们就先不介绍 d3 的具体转换实现了，你只需要知道，我们可以用 d3.hierarchy(data).sum(…).sort(…) 将省份数据按照包含城市的数量，从多到少排序就可以了。</p>
<p>假设，我们要将它们展现在一个画布宽高为 1600 * 1600 的 Canvas 中，那我们可以通过 d3.pack() 将数据映射为一组 1600 宽高范围内的圆形。不过，为了展示得美观一些，在每个相邻的圆之间我们还保留 3 个像素的 padding（按照经验，我们一般是保留 3 个像素 padding 的，但这也要根据实际的设计需求来更改）。</p>
<p>这样，我们就获得了包含几何图形信息的数据对象。此时它的内部结构如下所示：</p>
<p>{<br>
data: {name: &lsquo;中国&rsquo;, children: [&hellip;]},<br>
children: [<br>
{<br>
data: {name: &lsquo;江苏&rsquo;, children: [&hellip;]},<br>
value: 7,<br>
r: 186.00172579386546,<br>
x: 586.5048250548921,<br>
y: 748.2441892254667,<br>
}<br>
&hellip;<br>
],<br>
value: 69,<br>
x: 800,<br>
y: 800,<br>
r: 800,<br>
}</p>
<p>我们需要的信息是数据中的 x、y、r，这些数值是前面调用 d3.hierarchy 帮我们算出来的。接下来我们只需要用 Canvas 将它们绘制出来就可以了。具体绘制过程比较简单，<strong>只需要遍历数据并且根据数据内容绘制圆弧</strong>，我也把它总结成了两步。</p>
<p>第一步：我们在当前数据节点绘制一个圆，圆可以使用 arc 指令来绘制。arc 方法的五个参数分别是圆心的 x、y 坐标、半径 r、起始角度和结束角度，前三个参数就是数据中的 x、y 和 r。因为我们要绘制的是整圆，所以后面的两个参数中起始角是 0，结束角是 2π。</p>
<p>第二步，绘制图成后，如果这个数据节点有下一级数据，我们遍历它的下一级数据，然后递归地对这些数据调用绘图过程。如果没有下一级数据，说明当前数据为城市数据，那么我们就直接给出城市的名字，这一步可以通过 fillText 指令来完成。具体的代码如下所示：</p>
<p>const TAU = 2 * Math.PI;</p>
<p>function draw(ctx, node, {fillStyle = &lsquo;rgba(0, 0, 0, 0.2)&rsquo;, textColor = &lsquo;white&rsquo;} = {}) {<br>
const children = node.children;<br>
const {x, y, r} = node;<br>
ctx.fillStyle = fillStyle;<br>
ctx.beginPath();<br>
ctx.arc(x, y, r, 0, TAU);<br>
ctx.fill();<br>
if(children) {<br>
for(let i = 0; i &lt; children.length; i++) {<br>
draw(context, children[i]);<br>
}<br>
} else {<br>
const name = node.data.name;<br>
ctx.fillStyle = textColor;<br>
ctx.font = &lsquo;1.5rem Arial&rsquo;;<br>
ctx.textAlign = &lsquo;center&rsquo;;<br>
ctx.fillText(name, x, y);<br>
}<br>
}</p>
<p>draw(context, root);</p>
<p>这样，我们就用 Canvas 绘图简单地实现了一个层次关系图，它的代码不多也不复杂，你可以很容易理解，所以我就不做过多的解释啦。</p>
<h2 id="canvas-有哪些优缺点">Canvas 有哪些优缺点？</h2>
<p>通过上面的例子，相信你已经熟悉了 Canvas 的基础用法。但是，浏览器是一个复杂的图形环境，要想灵活使用 Canvas，我们还需要从宏观层面来知道，它能做什么，不能做什么。</p>
<p>简单来说，就是要了解 Canvas 的优缺点。</p>
<p>首先，Canvas 是一个非常简单易用的图形系统。结合刚才的例子你也能感受到，Canvas 通过一组简单的绘图指令，就能够方便快捷地绘制出各种复杂的几何图形。</p>
<p>另外，Canvas 渲染起来相当高效。即使是绘制大量轮廓非常复杂的几何图形，Canvas 也只需要调用一组简单的绘图指令就能高性能地完成渲染。这个呀，其实和 Canvas 更偏向于渲染层，能够提供底层的图形渲染 API 有关。那在实际实现可视化业务的时候，Canvas 出色的渲染能力正是它的优势所在。</p>
<p>不过 Canvas 也有缺点，因为 Canvas 在 HTML 层面上是一个独立的画布元素，所以所有的绘制内容都是在内部通过绘图指令来完成的，绘制出的图形对于浏览器来说，只是 Canvas 中的一个个像素点，我们很难直接抽取其中的图形对象进行操作。</p>
<p>比如说，在 HTML 或 SVG 中绘制一系列图形的时候，我们可以一一获取这些图形的元素对象，然后给它们绑定用户事件。但同样的操作在 Canvas 中没有可以实现的简单方法（但是我们仍然可以和 Canvas 图形交互，在后续课程中我们会有专门讨论）。下一节课中，我们会详细讲解 SVG 图形系统，到时你就会更加明白它们的差异具体是什么了。</p>
<h2 id="要点总结">要点总结</h2>
<p>好了，Canvas 的使用讲完了，我们来总结一下你要掌握的重点内容。</p>
<p>首先，我们讲了利用 Canvas 绘制几何图形，这个过程很简单，不过依然有 3 点需要我们注意：</p>
<ol>
<li>在 HTML 中建立画布时，我们要分别设置画布宽高和样式宽高；</li>
<li>在建立坐标系时，我们要注意 canvas 的坐标系和笛卡尔坐标系在 y 轴上是相反的；</li>
<li>如果要把图形绘制在画布中心，我们不能直接让 x、y 的坐标等于画布中心坐标，而是要让图形中心和画布中心的位置重叠。这个操作，我们可以通过计算顶点坐标或者 平移变换来实现。</li>
</ol>
<p>接着，我们讲了利用 Canvas 展示数据的层级关系。在这个过程中，我们应当先处理数据，将数据内容与绘图指令建立映射关系，然后遍历数据，通过映射关系将代表数据内容的参数传给绘图指令，最后将图形绘制到 Canvas 上。</p>
<p>另外，我们还讲了 Canvas 的优缺点。在实际实现可视化业务的时候，Canvas 的简单易操作和高效的渲染能力是它的优势，但是它的缺点是不能方便地控制它内部的图形元素。</p>
<p>最后，我还有一点想要补充一下。我们今天绘制的图形都是静态的，如果要使用 Canvas 绘制动态的图形也很简单，我们可以通过 clearRect 指令，将之前的图形擦除，再把新的图形绘制上去即可。在后续课程中，我们有专门的章节来介绍动画。</p>
<h2 id="小试牛刀">小试牛刀</h2>
<p>最后呢，我为你准备了两道课后题，试着动手操作一下吧！</p>
<ol>
<li>这节课我们介绍了用 Canvas 绘制矩形和圆弧，实际上 Canvas 还有更多的绘图指令来绘制不同类型的几何图形。你可以试着修改一下前面显示正方形的例子，在画布的中心位置显示一个三角形、椭圆或五角星。</li>
<li>Canvas 的缺点是不能方便地控制它内部的图形元素，但这不代表它完全不能控制。你可以尝试给我们前面绘制的层次关系图增加鼠标的交互，让鼠标指针在移动到某个城市所属的圆的时候，这个圆显示不同的颜色（提示：你可以获取鼠标坐标，然后用这个坐标到圆心的距离来判断）。</li>
</ol>
<p>欢迎在留言区和我讨论，分享你的答案和思考，也欢迎你把这节课分享给你的朋友，我们下节课见！</p>
<h2 id="源码">源码</h2>
<p>用 Canvas 绘制层次关系图的完整代码</p>
<h2 id="推荐阅读">推荐阅读</h2>
<p>[1] MDN 文档</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/">跟月影学可视化</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AF%B4%E9%80%8F%E5%8C%BA%E5%9D%97%E9%93%BE/02__%E7%9D%80%E7%9C%BC%E4%BB%8A%E7%94%9F%E6%8F%AD%E7%A7%98%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95%E7%8E%B0%E7%8A%B6/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">02__着眼今生：揭秘区块链技术的发展现状</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E5%AE%98%E8%AF%86%E4%BA%BA%E6%89%8B%E5%86%8C/02__%E5%88%B6%E5%AE%9A%E8%AE%A1%E5%88%92%E5%A5%BD%E7%9A%84%E8%AE%A1%E5%88%92%E6%98%AF%E6%88%90%E5%8A%9F%E7%9A%84%E4%B8%80%E5%8D%8A/">
            <span class="next-text nav-default">02__制定计划：好的计划是成功的一半</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
