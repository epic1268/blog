<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>38__实战（二）：如何使用数据驱动框架绘制常用数据图表？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是月影。
上一节课，我们使用图表库实现了一些常用的可视化图表。使用图表库的好处是非常简单，基本上我们只需要准备好数据，然后根据图形需要的数据格式创建图形，再添加辅助插件，就可以将图表显示出来了。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/38__%E5%AE%9E%E6%88%98%E4%BA%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E7%BB%98%E5%88%B6%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/38__%E5%AE%9E%E6%88%98%E4%BA%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E7%BB%98%E5%88%B6%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="38__实战（二）：如何使用数据驱动框架绘制常用数据图表？">
  <meta property="og:description" content="你好，我是月影。
上一节课，我们使用图表库实现了一些常用的可视化图表。使用图表库的好处是非常简单，基本上我们只需要准备好数据，然后根据图形需要的数据格式创建图形，再添加辅助插件，就可以将图表显示出来了。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="跟月影学可视化">

  <meta itemprop="name" content="38__实战（二）：如何使用数据驱动框架绘制常用数据图表？">
  <meta itemprop="description" content="你好，我是月影。
上一节课，我们使用图表库实现了一些常用的可视化图表。使用图表库的好处是非常简单，基本上我们只需要准备好数据，然后根据图形需要的数据格式创建图形，再添加辅助插件，就可以将图表显示出来了。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4695">
  <meta itemprop="keywords" content="跟月影学可视化">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="38__实战（二）：如何使用数据驱动框架绘制常用数据图表？">
  <meta name="twitter:description" content="你好，我是月影。
上一节课，我们使用图表库实现了一些常用的可视化图表。使用图表库的好处是非常简单，基本上我们只需要准备好数据，然后根据图形需要的数据格式创建图形，再添加辅助插件，就可以将图表显示出来了。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">38__实战（二）：如何使用数据驱动框架绘制常用数据图表？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4695 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#课前准备">课前准备</a></li>
        <li><a href="#使用-d3js-绘制条形图">使用 D3.js 绘制条形图</a></li>
        <li><a href="#使用-d3js-绘制力导向图">使用 D3.js 绘制力导向图</a></li>
        <li><a href="#要点总结">要点总结</a></li>
        <li><a href="#小试牛刀">小试牛刀</a></li>
        <li><a href="#源码">源码</a></li>
        <li><a href="#推荐阅读">推荐阅读</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是月影。</p>
<p>上一节课，我们使用图表库实现了一些常用的可视化图表。使用图表库的好处是非常简单，基本上我们只需要准备好数据，然后根据图形需要的数据格式创建图形，再添加辅助插件，就可以将图表显示出来了。</p>
<p>图表库虽然使用上简单，但灵活性不高，对数据格式要求也很严格，我们必须按照各个图表的要求来准备数据。而且，图形和插件的可配置性，完全取决于图表库设计者开放的 API，给开发者的自由度很少。</p>
<p>今天，我们就来说说，使用数据驱动框架来实现图表的方式。这类框架以 D3.js 为代表，提供了数据处理能力，以及从数据转换成视图结构的通用 API，并且不限制用户处理视图的最终呈现。所以它的特点是更加灵活，不受图表类型对应 API 的制约。不过，因为图表库只要调用 API 就能展现内容，而数据驱动框架需要我们自己去完成内容的呈现，所以，它在使用上就没有图表库那么方便了。</p>
<p>使用图表库和使用数据驱动框架的具体过程和差别，我这里准备了一个对比图，你可以看一下。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/4e125c1a9efde4053543b6453402c6bd.png" alt=""></p>
<p>使用图表库（左）和使用数据驱动框架（右）渲染图表的流程对比</p>
<p>不过这么讲还是比较抽象，接下来，我们还是通过绘制条形图和力导向图，来体会用数据驱动框架和用图表库构建可视化图表究竟有什么区别。</p>
<h2 id="课前准备">课前准备</h2>
<p>与上一节课差不多，我们还是需要使用 SpriteJS，只不过今天我们将 QCharts 换成 D3.js。</p>
<script src="https://unpkg.com/spritejs/dist/spritejs.min.js"></script>  
<script src="https://d3js.org/d3.v6.js"></script>  
<p>使用上面的代码，我们就能加载 SpriteJS 和 D3.js，用它们来完成常用图表的绘制了。</p>
<h2 id="使用-d3js-绘制条形图">使用 D3.js 绘制条形图</h2>
<p>我们先来绘制条形图，条形图与柱状图差不多，都是用图形的长度来表示数据的多少。只不过，横向对比的条形图，更容易让我们看到各个数据之间的大小，而纵向的柱状图可以同时比较两个变量之间的数据差别。</p>
<p>用 D3.js 绘制图表，不同于使用 Qcharts，我们需要创建 SpriteJS 的容器。通过前面的课程我们已经知道，SpriteJS 创建场景（Scene）对象作为其他元素的根元素容器。接下来，我们一起看下具体的操作过程。</p>
<p>const container = document.getElementById(&lsquo;stage&rsquo;);<br>
const scene = new Scene({<br>
container,<br>
width: 1200,<br>
height: 1200,<br>
});</p>
<p>如上面代码所示，我们先创建一个 Scene 对象，与 QCharts 的 Chart 对象一样，它需要一个 HTML 容器，这里我们使用页面上一个 id 为 stage 的元素。我们设置了参数 width 和 height 为 1200，也就是把 Canvas 对象的画布宽高设为 1200 * 1200。</p>
<p>接着，我们准备数据。与使用 QCharts 必须要按照格式给出 JSON 数据不同，使用 D3.js 的时候数据格式比较自由。这里，我们直接用了一个数组：</p>
<p>const dataset = [125, 121, 127, 193, 309];</p>
<p>然后，我们使用 D3.js 的方法对数据进行映射：</p>
<p>const scale = d3.scaleLinear()<br>
.domain([100, d3.max(dataset)])<br>
.range([0, 500]);</p>
<p>D3.js 在设计上采用了一些函数式编程思想，这里的.scaleLinear、.domain 和.range 都是高阶函数，它们返回一个 scale 函数，这个函数把一组数值线性映射到某个范围，这里，我们就是将数值映射到 500 像素区间，数值是从 100 到 309。</p>
<p>那么这个 scale 函数要怎么使用呢？别着急，我们先往下看。</p>
<p>有了数据 dataset 和处理数据的 scale 方法之后，我们使用 d3-selection（这是 d3 中的一个子模块，我们是通过 CDN 来加载 d3 的，所以已经默认包含了 d3-selection）来创建并选择 layer 对象。</p>
<p>在 SpriteJS 中，场景 Scene 可以由多个 Layer 构成，针对每个 Layer 对象，SpriteJS 都会创建一个实际的 Canvas 画布。</p>
<p>const fglayer = scene.layer(&lsquo;fglayer&rsquo;);<br>
const s = d3.select(fglayer);</p>
<p>如上面的代码所示，我们先创建了一个 fglayer，它对应一个 Canvas 画布，然后通过 d3.select(fglayer)，将对应的 fglayer 元素经过 d3 包装后返回。</p>
<p>接着，我们在 fglayer 元素上进行迭代操作。你先认真看完代码，我再来解释。</p>
<p>const colors = [&rsquo;#fe645b&rsquo;, &lsquo;#feb050&rsquo;, &lsquo;#c2af87&rsquo;, &lsquo;#81b848&rsquo;, &lsquo;#55abf8&rsquo;];<br>
const chart = s.selectAll(&lsquo;sprite&rsquo;)<br>
.data(dataset)<br>
.enter()<br>
.append(&lsquo;sprite&rsquo;)<br>
.attr(&lsquo;x&rsquo;, 450)<br>
.attr(&lsquo;y&rsquo;, (d, i) =&gt; {<br>
return 200 + i * 95;<br>
})<br>
.attr(&lsquo;width&rsquo;, scale)<br>
.attr(&lsquo;height&rsquo;, 80)<br>
.attr(&lsquo;bgcolor&rsquo;, (d, i) =&gt; {<br>
return colors[i];<br>
});</p>
<p>我们从第 2 行代码开始看，其中，selectAll 用来返回 fglayer 下的 sprite 子元素，对于 SpriteJS 来说，sprite 元素是基本元素，用来表示一个图形。不过，现在 fglayer 下还没有任何子元素，所以 selectAll(‘sprite’) 本应该返回空的元素，但是，d3 通过 data 方法迭代数据集，也就是之前有 5 个元素的数组，然后通过执行 enter() 和 append(‘sprite’)，这样就在 fglayer 下添加了 5 个 sprite 子元素。enter() 方法是告诉 d3-selection，当数据集的数量大于 selectAll 选中的元素数量时，通过 append 添加元素补齐数量。</p>
<p>从第 6 行代码开始，我们给每个 sprite 元素迭代设置属性。注意，append 之后的 attr 是默认迭代设置每个 sprite 元素的属性，如果是常量就直接设置，如果是不同的值，就通过迭代算子来设置。迭代算子有两个参数，第一个是 dataset 中对应的数据，第二个是迭代次数，从 0 开始，因为有五项数据，所以会迭代 5 次。如果你对 jQuery 比较熟悉，你应该能比较容易理解上面这种批量迭代操作的形式。</p>
<p>最后，我们根据数据集的每个数据依次设置一个 sprite 元素，将 x 坐标值设置为 450，y 坐标值设置为从 200 开始，每个元素占据 95 个像素值，然后将 width 设置为用 scale 计算后的数据项的值，这里我们就用到前面 linearScale 高阶函数生成的 scale 函数，直接将它作为算子。我们将 height 值设为固定的 80，表示元素的高度。这样一来，元素之间就会有 95 - 80，即 15 像素的空隙。最后我们给元素设置一组不同的颜色值。</p>
<p>我们最终显示出来的效果如下图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/ec65c50298c52767d89ff41205775e57.png" alt=""></p>
<p>这里我们在画布上显示了五个不同颜色的矩形条，它们对应数组的 125、121、127、193、309。但它还不是一个完整的图表，我们需要给它增加辅助信息，比如坐标轴。添加坐标轴的代码如下所示。</p>
<p>const axis = d3.axisBottom(scale).tickValues([100, 200, 300]);<br>
const axisNode = new SpriteSvg({<br>
x: 420,<br>
y: 680,<br>
});<br>
d3.select(axisNode.svg)<br>
.attr(&lsquo;width&rsquo;, 600)<br>
.attr(&lsquo;height&rsquo;, 60)<br>
.append(&lsquo;g&rsquo;)<br>
.attr(&rsquo;transform&rsquo;, &rsquo;translate(30, 0)&rsquo;)<br>
.call(axis);</p>
<p>axisNode.svg.children[0].setAttribute(&lsquo;font-size&rsquo;, 20);<br>
fglayer.append(axisNode);</p>
<p>如上面代码所示，我们通过 d3.axisBottom 创建一个底部的坐标。我们可以通过 tickValues 给坐标轴传要显示的刻度值，这里我们显示 100、200、300 三个刻度。同样我们可以用 scale 函数将这些数值线性映射到 500 像素区间，值从 100 到 309。</p>
<p>axisBottom 本身是一个高阶函数，它返回 axis 函数用来绘制坐标轴，不过这个函数是使用 svg 来绘制坐标轴的。好在 SpriteJS 支持 SpriteSvg 对象，它可以绘制一个 SVG 图形，然后将这个图形以 WebGL 或者 Canvas2D 的方式绘制到画布上。</p>
<p>我们先创建 SpriteSvg 类的对象 axisNode，然后通过 d3.select 选中对象的 svg 属性，进行正常的 svg 属性设置和创建 svg 元素操作，最终将 axisNode 添加到 fglayer 上，这样就能将坐标轴显示出来了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/1e3d4fc7810492b545213db193f13547.png" alt=""></p>
<p>这样，我们就实现了一个简陋的条形图。简陋是因为和 QCharts 的柱状图相比，它现在只有图形主体部分和一个简单的 x 坐标轴，缺少 y 坐标轴、图例、提示信息、辅助网格等信息，不过这些用 D3.js 也都能创建，我觉得这部分内容，你可以自己试着实现，我就不多说了，如果遇到问题记得在留言区提问。</p>
<p>总的来说，在创建简单的图表的时候，使用 D3.js 比直接使用图表库还是要复杂很多的。但比较好的一点是，D3.js 对数据格式没有太多硬性要求，我们可以直接使用一个简单的数组，然后在后面绘图的时候再进行迭代。那麻烦一点的是，因为没有现成的图表对象，所以我们要自己处理数据、显示属性的映射，好在 D3.js 提供了 linearScale 这样的工具函数来创建数据映射。</p>
<p>处理好数据映射之后，我们需要自己通过 d3-selection 来遍历元素，完成属性的设置，从而把图形渲染出来。而且，对于坐标轴等其他附属信息，d3 也没有现成的对象，我们也需要通过遍历元素进行绘制。</p>
<p>这里顺便提一下，虽然我们使用 SpriteJS 作为图形库来讲解，但 d3 并没有强制限定图形库，所以我们无论是采用 SVG、原生 Canvas2D 还是 WebGL，又或者是采用 ThreeJS 等其他图形库，都可以进行渲染。只不过，d3-selection 依赖于 DOM 操作，所以 SVG 和 SpriteJS 这种与 DOM API 保持一致的图形系统，使用起来会更加方便一些。</p>
<h2 id="使用-d3js-绘制力导向图">使用 D3.js 绘制力导向图</h2>
<p>讲完了用 D3.js 绘制简单条形图的方法，接下来，我们看看怎么用 D3.js 绘制更加复杂的图形，比如力导向图。</p>
<p>力导向图也是一种比较常见的可视化图表，它非常适合用来描述关系型信息。比如下图就是一个经典的力导向图应用。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/a476e9ef7cbe6e8ce124d6532c2df3c9.png" alt=""></p>
<p>我们看到，力导向图不仅能够描绘节点和关系链，而且在移动一个节点的时候，图表各个节点的位置会跟随移动，避免节点相互重叠。</p>
<p>那么究竟如何用 D3.js 实现一个简单的力导向图呢？我们来看一个例子。</p>
<p>力导向图，顾名思义，我们通过模拟节点之间的斥力，来保证节点不会相互重叠。在 D3.js 中提供了模拟斥力的方法。</p>
<p>const simulation = d3.forceSimulation()<br>
.force(&rsquo;link&rsquo;, d3.forceLink().id(d =&gt; d.id)) //节点连线<br>
.force(&lsquo;charge&rsquo;, d3.forceManyBody()) // 多实体作用<br>
.force(&lsquo;center&rsquo;, d3.forceCenter(400, 300)); // 力中心</p>
<p>如上面代码所示，我们创建一个 d3 的力模型对象 simulation，通过它来模拟示例，然后我们设置节点连接、多实体相互作用、力中心点。</p>
<p>接着，我们读取数据。这里我准备了一份JSON 数据。我们可以用 d3.json 来读取数据，它返回一个 Promise 对象。</p>
<p>d3.json(&lsquo;<a href="https://s0.ssl.qhres.com/static/f74a79ccf53d8147.json').then(graph">https://s0.ssl.qhres.com/static/f74a79ccf53d8147.json').then(graph</a> =&gt; {<br>
&hellip;<br>
});</p>
<p>我们先用力模型来处理数据：</p>
<p>simulation<br>
.nodes(graph.nodes)<br>
.on(&rsquo;tick&rsquo;, ticked);</p>
<p>simulation.force(&rsquo;link&rsquo;)<br>
.links(graph.links);</p>
<p>接着，我们再绘制节点：</p>
<p>d3.select(layer).selectAll(&lsquo;sprite&rsquo;)<br>
.data(graph.nodes)<br>
.enter()<br>
.append(&lsquo;sprite&rsquo;)<br>
.attr(&lsquo;pos&rsquo;, (d) =&gt; {<br>
return [d.x, d.y];<br>
})<br>
.attr(&lsquo;size&rsquo;, [10, 10])<br>
.attr(&lsquo;border&rsquo;, [1, &lsquo;white&rsquo;])<br>
.attr(&lsquo;borderRadius&rsquo;, 5)<br>
.attr(&lsquo;anchor&rsquo;, 0.5);</p>
<p>然后，我们再绘制连线：</p>
<p>d3.select(layer).selectAll(&lsquo;path&rsquo;)<br>
.data(graph.links)<br>
.enter()<br>
.append(&lsquo;path&rsquo;)<br>
.attr(&rsquo;d&rsquo;, (d) =&gt; {<br>
const [sx, sy] = [d.source.x, d.source.y];<br>
const [tx, ty] = [d.target.x, d.target.y];<br>
return <code>M${sx} ${sy} L ${tx} ${ty}</code>;<br>
})<br>
.attr(&rsquo;name&rsquo;, (d, index) =&gt; {<br>
return <code>path${index}</code>;<br>
})<br>
.attr(&lsquo;strokeColor&rsquo;, &lsquo;white&rsquo;);</p>
<p>这里我们依然是用 d3-selection 的迭代，给 SpriteJS 的 sprite 和 path 元素设置了一些属性，这些属性有的与我们的数据建立关联，有的是单纯的样式。这里面没有特别难的地方，我就不一一解释了，最好的理解方法是实践，所以我建议你亲自研究一下示例代码，修改一些属性，看看结果有什么变化，这样能够加深理解。</p>
<p>将节点和连线绘制完成之后，力导向图的初步结果就呈现出来了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/3f6da9369e7d9bc50e888176db968b63.png" alt=""></p>
<p>因为力向导图有一个特点就是，在我们移动一个节点的时候，其他节点也会跟着移动。所以，我们还要实现拖动节点的功能。D3.js 支持处理拖拽事件，所以我们只要分别实现一下对应的事件回调函数，完成时间注册就可以了。首先是三个事件回调函数。</p>
<p>function dragstarted(event) {<br>
if(!event.active) simulation.alphaTarget(0.3).restart();</p>
<p>const [x, y] = [event.subject.x, event.subject.y];<br>
event.subject.fx0 = x;<br>
event.subject.fy0 = y;<br>
event.subject.fx = x;<br>
event.subject.fy = y;</p>
<p>const [x0, y0] = layer.toLocalPos(event.x, event.y);<br>
event.subject.x0 = x0;<br>
event.subject.y0 = y0;<br>
}</p>
<p>function dragged(event) {<br>
const [x, y] = layer.toLocalPos(event.x, event.y),<br>
{x0, y0, fx0, fy0} = event.subject;<br>
const [dx, dy] = [x - x0, y - y0];</p>
<p>event.subject.fx = fx0 + dx;<br>
event.subject.fy = fy0 + dy;<br>
}</p>
<p>function dragended(event) {<br>
if(!event.active) simulation.alphaTarget(0);<br>
event.subject.fx = null;<br>
event.subject.fy = nul</p>
<p>其中 dragstarted 处理开始拖拽的事件，这个时候，我们通过前面创建的 simulation 对象启动力模拟，记录一下当前各个节点的 x、y 坐标。因为默认的坐标是 DOM 事件坐标，我们通过 layer.toLocalPos 方法将它转换成相对于 layer 的坐标。接着 dragged 处理拖拽中的事件，同样也是转换 x、y 坐标，计算出坐标的差值，然后更新 fx、fy，也就是事件主体的当前坐标。最后，我们用 dragended 处理拖住结束事件，清空 fx 和 fy。</p>
<p>接着，我们将三个事件处理函数注册到 layer 的 canvas 上：</p>
<p>d3.select(layer.canvas)<br>
.call(d3.drag()<br>
.container(layer.canvas)<br>
.subject(dragsubject)<br>
.on(&lsquo;start&rsquo;, dragstarted)<br>
.on(&lsquo;drag&rsquo;, dragged)<br>
.on(&rsquo;end&rsquo;, dragended));</p>
<p>这样就实现了力导向图拖拽节点的交互，d3 会自动根据新的节点位置计算布局，避免节点的重叠。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/de4991f1734249ffccbd16b0b37507b2.png" alt=""></p>
<h2 id="要点总结">要点总结</h2>
<p>这节课，我们主要学习了使用数据驱动框架来绘制图表。</p>
<p>与直接使用图表库不同，使用数据驱动框架不要求固定格式的数据格式，而是通过对原始数据的处理和对容器迭代、创建新的子元素，并且根据数据设置属性，来完成从数据到元素结构和属性的映射，然后再用渲染引擎将它最终渲染出来。</p>
<p>那你可能有疑问了，我们应该在什么时候选择图表库，什么时候选择数据驱动框架呢？通常情况下，当需求比较明确可以用图表库，并且样式通过图表库 API 设置可以实现的时候，我们倾向于使用图表库，但是当需求比较复杂，或者样式要求灵活多变的时候，我们可以考虑使用数据驱动框架。</p>
<p>数据驱动框架可以灵活实现各种复杂的图表效果，我们前面举的两个图表例子虽然只是个例，但也会在实战项目中经常用到。除此之外，使用 D3.js 和 SpriteJS 还可以实现其他复杂的图表，比如说，地图或者一些 3D 图表，以及我们在前面的课程中实现的 3Dgithub 代码贡献图，就是使用 D3.js 和 SpriteJS 来实现的。</p>
<p>D3.js 和 SpriteJS 的使用都比较复杂，你是不可能用一节课系统掌握的，我们只有继续深入学习，并动手实践、积累经验，才能在可视化项目中得心应手地使用它们，来实现各种各样的可视化需求。</p>
<h2 id="小试牛刀">小试牛刀</h2>
<p>最后，我给你出了两个实践题。希望你能结合 D3.js 和 SpriteJS 的官方文档，花点时间仔细阅读和学习，再通过动手实践和反复练习，最终掌握它们。</p>
<ol>
<li>请你完善我们课程中讲到的条形图，给它实现 y 轴、图例和提示信息。</li>
<li>你可以将上一节课用 QCharts 图表库实现的图表改用 D3.js 实现吗？动手试一试，体会一下它们使用方式和思路上的不同。</li>
</ol>
<p>关于可视化图表的实战课程就讲到这里了，如果你对于图表绘制，还有什么疑问和困惑，欢迎你在留言区告诉我。我们下节课再见！</p>
<h2 id="源码">源码</h2>
<p>课程中完整示例代码详见GitHub 仓库</p>
<h2 id="推荐阅读">推荐阅读</h2>
<p>D3.js 的官方文档</p>
<p>SpriteJS 的官方文档</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/">跟月影学可视化</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/38__%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%8F%90%E9%AB%98%E4%BA%A4%E4%BB%98%E8%B4%A8%E9%87%8F/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">38__如何通过自动化测试提高交付质量？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/38__%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%8C%96%E5%A4%B1%E4%B9%8B%E6%AF%AB%E5%8E%98%E5%B7%AE%E4%B9%8B%E5%8D%83%E9%87%8C/">
            <span class="next-text nav-default">38__数据库参数设置优化，失之毫厘差之千里</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
