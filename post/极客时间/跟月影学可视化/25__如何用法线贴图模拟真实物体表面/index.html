<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>25__如何用法线贴图模拟真实物体表面 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是月影。
上节课，我们讲了光照的 Phong 反射模型，并使用它给几何体添加了光照效果。不过，我们使用的几何体表面都是平整的，没有凹凸感。而真实世界中，大部分物体的表面都是凹凸不平的，这肯定会影响光照的反射效果。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/25__%E5%A6%82%E4%BD%95%E7%94%A8%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%E6%A8%A1%E6%8B%9F%E7%9C%9F%E5%AE%9E%E7%89%A9%E4%BD%93%E8%A1%A8%E9%9D%A2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/25__%E5%A6%82%E4%BD%95%E7%94%A8%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%E6%A8%A1%E6%8B%9F%E7%9C%9F%E5%AE%9E%E7%89%A9%E4%BD%93%E8%A1%A8%E9%9D%A2/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="25__如何用法线贴图模拟真实物体表面">
  <meta property="og:description" content="你好，我是月影。
上节课，我们讲了光照的 Phong 反射模型，并使用它给几何体添加了光照效果。不过，我们使用的几何体表面都是平整的，没有凹凸感。而真实世界中，大部分物体的表面都是凹凸不平的，这肯定会影响光照的反射效果。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="跟月影学可视化">

  <meta itemprop="name" content="25__如何用法线贴图模拟真实物体表面">
  <meta itemprop="description" content="你好，我是月影。
上节课，我们讲了光照的 Phong 反射模型，并使用它给几何体添加了光照效果。不过，我们使用的几何体表面都是平整的，没有凹凸感。而真实世界中，大部分物体的表面都是凹凸不平的，这肯定会影响光照的反射效果。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3954">
  <meta itemprop="keywords" content="跟月影学可视化">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="25__如何用法线贴图模拟真实物体表面">
  <meta name="twitter:description" content="你好，我是月影。
上节课，我们讲了光照的 Phong 反射模型，并使用它给几何体添加了光照效果。不过，我们使用的几何体表面都是平整的，没有凹凸感。而真实世界中，大部分物体的表面都是凹凸不平的，这肯定会影响光照的反射效果。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">25__如何用法线贴图模拟真实物体表面</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3954 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#如何使用法线贴图给几何体表面增加凹凸效果">如何使用法线贴图给几何体表面增加凹凸效果？</a>
          <ul>
            <li><a href="#如何理解切线空间">如何理解切线空间？</a></li>
            <li><a href="#构建-tbn-矩阵来计算法向量">构建 TBN 矩阵来计算法向量</a></li>
            <li><a href="#使用偏导数来实现法线贴图">使用偏导数来实现法线贴图</a></li>
          </ul>
        </li>
        <li><a href="#法线贴图的应用">法线贴图的应用</a></li>
        <li><a href="#要点总结">要点总结</a></li>
        <li><a href="#小试牛刀">小试牛刀</a></li>
        <li><a href="#源码">源码</a></li>
        <li><a href="#推荐阅读">推荐阅读</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是月影。</p>
<p>上节课，我们讲了光照的 Phong 反射模型，并使用它给几何体添加了光照效果。不过，我们使用的几何体表面都是平整的，没有凹凸感。而真实世界中，大部分物体的表面都是凹凸不平的，这肯定会影响光照的反射效果。</p>
<p>因此，只有处理好物体凹凸表面的光照效果，我们才能更加真实地模拟物体表面。在图形学中就有一种对应的技术，叫做<strong>法线贴图</strong>。今天，我们就一起来学习一下。</p>
<h2 id="如何使用法线贴图给几何体表面增加凹凸效果">如何使用法线贴图给几何体表面增加凹凸效果？</h2>
<p>那什么是法线贴图？我们直接通过一个例子来理解。</p>
<p>首先，我们用 Phong 反射模型绘制一个灰色的立方体，并给它添加两道平行光。具体的代码和效果如下：</p>
<p>import {Phong, Material, vertex as v, fragment as f} from &lsquo;../common/lib/phong.js&rsquo;;</p>
<p>const scene = new Transform();</p>
<p>const phong = new Phong();<br>
phong.addLight({<br>
direction: [0, -3, -3],<br>
});<br>
phong.addLight({<br>
direction: [0, 3, 3],<br>
});<br>
const matrial = new Material(new Color(&rsquo;#808080&rsquo;));</p>
<p>const program = new Program(gl, {<br>
vertex: v,<br>
fragment: f,<br>
uniforms: {<br>
&hellip;phong.uniforms,<br>
&hellip;matrial.uniforms,<br>
},<br>
});</p>
<p>const geometry = new Box(gl);<br>
const cube = new Mesh(gl, {geometry, program});<br>
cube.setParent(scene);<br>
cube.rotation.x = -Math.PI / 2;</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/783c36b0bd6aeb080c349f98ab7fe521.png" alt=""></p>
<p>现在这个立方体的表面是光滑的，如果我们想在立方体的表面贴上凹凸的花纹。我们可以加载一张<strong>法线纹理</strong>，这是一张偏蓝色调的纹理图片。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/c214ac095dd80cd584938cfe275cf55f.png" alt=""></p>
<p>const normalMap = await loadTexture(&rsquo;../assets/normal_map.png&rsquo;);</p>
<p>为什么这张纹理图片是偏蓝色调的呢？实际上，这张纹理图片保存的是几何体表面的每个像素的法向量数据。我们知道，正常情况下，光滑立方体每个面的法向量是固定的，如下图所示：</p>
<p><a href="http://www.mbsoftworks.sk/tutorials/opengl4/014-normals-diffuse-lighting/"><img src="./94523180c54ac486138eef9a784d7777.png.md" alt=""></a></p>
<p>但如果表面有凹凸的花纹，那不同位置的法向量就会发生变化。在<strong>切线空间</strong>中，因为法线都偏向于 z 轴，也就是法向量偏向于 (0,0,1)，所以转换成的法线纹理就偏向于蓝色。如果我们根据花纹将每个点的法向量都保存下来，就会得到上面那张法线纹理的图片。</p>
<h3 id="如何理解切线空间">如何理解切线空间？</h3>
<p>我刚才提到了一个词，切线空间，那什么是切线空间呢？切线空间（Tangent Space）是一个特殊的坐标系，它是由几何体顶点所在平面的 uv 坐标和法线构成的。</p>
<p><a href="https://math.stackexchange.com/questions/342211/difference-between-tangent-space-and-tangent-plane"><img src="./deba12fe473bae358ad06bba9695957e.png.md" alt=""></a></p>
<p>切线空间</p>
<p>切线空间的三个轴，一般用 T (Tangent)、B (Bitangent)、N (Normal) 三个字母表示，所以切线空间也被称为 TBN 空间。其中 T 表示切线、B 表示副切线、N 表示法线。</p>
<p>对于大部分三维几何体来说，因为每个点的法线不同，所以它们各自的切线空间也不同。</p>
<p>接下来，我们来具体说说，切线空间中的 TBN 是怎么计算的。</p>
<p>首先，我们来回忆一下，怎么计算几何体三角形网格的法向量。假设一个三角形网格有三个点 v1、v2、v3，我们把边 v1v2 记为 e1，边 v1v3 记为 e2，那三角形的法向量就是 e1 和 e2 的叉积表示的归一化向量。用 JavaScript 代码实现就是下面这样：</p>
<p>function getNormal(v1, v2, v3) {<br>
const e1 = Vec3.sub(v2, v1);<br>
const e2 = Vec3.sub(v3, v1);<br>
const normal = Vec3.cross(e1, e1).normalize();<br>
return normal;<br>
}</p>
<p>而计算切线和副切线，要比计算法线复杂得多，不过，因为数学推导过程比较复杂，我们只要记住结论就可以了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/6b05780d989013c87260098f712a0ade.png" alt=""></p>
<p>如上图和公式，我们就可以通过 UV 坐标和点 P1、P2、P3 的坐标求出对应的 T 和 B 坐标了，对应的 JavaScript 函数如下：</p>
<p>function createTB(geometry) {<br>
const {position, index, uv} = geometry.attributes;<br>
if(!uv) throw new Error(&lsquo;NO uv.&rsquo;);<br>
function getTBNTriangle(p1, p2, p3, uv1, uv2, uv3) {<br>
const edge1 = new Vec3().sub(p2, p1);<br>
const edge2 = new Vec3().sub(p3, p1);<br>
const deltaUV1 = new Vec2().sub(uv2, uv1);<br>
const deltaUV2 = new Vec2().sub(uv3, uv1);</p>
<pre><code>const tang = new Vec3();  
const bitang = new Vec3();  

const f = 1.0 / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);  

tang.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);  
tang.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);  
tang.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);  

tang.normalize();  

bitang.x = f * (-deltaUV2.x * edge1.x + deltaUV1.x * edge2.x);  
bitang.y = f * (-deltaUV2.x * edge1.y + deltaUV1.x * edge2.y);  
bitang.z = f * (-deltaUV2.x * edge1.z + deltaUV1.x * edge2.z);  

bitang.normalize();  

return {tang, bitang};  
</code></pre>
<p>}</p>
<p>const size = position.size;<br>
if(size &lt; 3) throw new Error(&lsquo;Error dimension.&rsquo;);</p>
<p>const len = position.data.length / size;<br>
const tang = new Float32Array(len * 3);<br>
const bitang = new Float32Array(len * 3);</p>
<p>for(let i = 0; i &lt; index.data.length; i += 3) {<br>
const i1 = index.data[i];<br>
const i2 = index.data[i + 1];<br>
const i3 = index.data[i + 2];</p>
<pre><code>const p1 = [position.data[i1 * size], position.data[i1 * size + 1], position.data[i1 * size + 2]];  
const p2 = [position.data[i2 * size], position.data[i2 * size + 1], position.data[i2 * size + 2]];  
const p3 = [position.data[i3 * size], position.data[i3 * size + 1], position.data[i3 * size + 2]];  

const u1 = [uv.data[i1 * 2], uv.data[i1 * 2 + 1]];  
const u2 = [uv.data[i2 * 2], uv.data[i2 * 2 + 1]];  
const u3 = [uv.data[i3 * 2], uv.data[i3 * 2 + 1]];  

const {tang: t, bitang: b} = getTBNTriangle(p1, p2, p3, u1, u2, u3);  
tang.set(t, i1 * 3);  
tang.set(t, i2 * 3);  
tang.set(t, i3 * 3);  
bitang.set(b, i1 * 3);  
bitang.set(b, i2 * 3);  
bitang.set(b, i3 * 3);  
</code></pre>
<p>}<br>
geometry.addAttribute(&rsquo;tang&rsquo;, {data: tang, size: 3});<br>
geometry.addAttribute(&lsquo;bitang&rsquo;, {data: bitang, size: 3});<br>
return geometry;<br>
}</p>
<p>虽然上面这段代码比较长，但并不复杂。具体的思路就是按照我给出的公式，先进行向量计算，然后将 tang 和 bitang 的值添加到 geometry 对象中去。</p>
<h3 id="构建-tbn-矩阵来计算法向量">构建 TBN 矩阵来计算法向量</h3>
<p>有了 tang 和 bitang 之后，我们就可以构建 TBN 矩阵来计算法线了。这里的 TBN 矩阵的作用，就是将法线贴图里面读取的法向量数据，转换为对应的切线空间中实际的法向量。这里的切线空间，实际上对应着我们观察者（相机）位置的坐标系。</p>
<p>接下来，我们对应顶点着色器和片元着色器来说说，怎么构建 TBN 矩阵得出法线方向。</p>
<p>先看顶点着色器，我们增加了 tang 和 bitang 这两个属性。注意，这里我们用了 webgl2.0 的写法，因为 WebGL2.0 对应 OpenGL ES3.0，所以这段代码和我们之前看到的着色器代码略有不同。</p>
<p>首先它的第一行声明 #version 300 es 表示这段代码是 OpenGL ES3.0 的，然后我们用 in 和 out 对应变量的输入和输出，来取代 WebGL2.0 的 attribute 和 varying，其他的地方基本和 WebGL1.0 一样。因为 OGL 默认支持 WebGL2.0，所以在后续例子中你还会看到更多 OpenGL ES3.0 的着色器写法，不过因为两个版本差别不大，也不会妨碍我们理解代码。</p>
<p>#version 300 es<br>
precision highp float;</p>
<p>in vec3 position;<br>
in vec3 normal;<br>
in vec2 uv;<br>
in vec3 tang;<br>
in vec3 bitang;</p>
<p>uniform mat4 modelMatrix;<br>
uniform mat4 modelViewMatrix;<br>
uniform mat4 viewMatrix;<br>
uniform mat4 projectionMatrix;<br>
uniform mat3 normalMatrix;<br>
uniform vec3 cameraPosition;</p>
<p>out vec3 vNormal;<br>
out vec3 vPos;<br>
out vec2 vUv;<br>
out vec3 vCameraPos;<br>
out mat3 vTBN;</p>
<p>void main() {<br>
vec4 pos = modelViewMatrix * vec4(position, 1.0);<br>
vPos = pos.xyz;<br>
vUv = uv;<br>
vCameraPos = (viewMatrix * vec4(cameraPosition, 1.0)).xyz;<br>
vNormal = normalize(normalMatrix * normal);</p>
<p>vec3 N = vNormal;<br>
vec3 T = normalize(normalMatrix * tang);<br>
vec3 B = normalize(normalMatrix * bitang);</p>
<p>vTBN = mat3(T, B, N);</p>
<p>gl_Position = projectionMatrix * pos;<br>
}</p>
<p>接着来看代码，我们通过 normal、tang 和 bitang 建立 TBN 矩阵。注意，因为 normal、tang 和 bitang 都需要换到世界坐标中，所以我们要记得将它们左乘法向量矩阵 normalMatrix，然后我们构建 TBN 矩阵 (vTBN=mat(T,B,N))，将它传给片元着色器。</p>
<p>下面，我们接着来看片元着色器。</p>
<p>#version 300 es<br>
precision highp float;</p>
<p>#define MAX_LIGHT_COUNT 16<br>
uniform mat4 viewMatrix;</p>
<p>uniform vec3 ambientLight;<br>
uniform vec3 directionalLightDirection[MAX_LIGHT_COUNT];<br>
uniform vec3 directionalLightColor[MAX_LIGHT_COUNT];<br>
uniform vec3 pointLightColor[MAX_LIGHT_COUNT];<br>
uniform vec3 pointLightPosition[MAX_LIGHT_COUNT];<br>
uniform vec3 pointLightDecay[MAX_LIGHT_COUNT];<br>
uniform vec3 spotLightColor[MAX_LIGHT_COUNT];<br>
uniform vec3 spotLightDirection[MAX_LIGHT_COUNT];<br>
uniform vec3 spotLightPosition[MAX_LIGHT_COUNT];<br>
uniform vec3 spotLightDecay[MAX_LIGHT_COUNT];<br>
uniform float spotLightAngle[MAX_LIGHT_COUNT];</p>
<p>uniform vec3 materialReflection;<br>
uniform float shininess;<br>
uniform float specularFactor;</p>
<p>uniform sampler2D tNormal;</p>
<p>in vec3 vNormal;<br>
in vec3 vPos;<br>
in vec2 vUv;<br>
in vec3 vCameraPos;<br>
in mat3 vTBN;</p>
<p>out vec4 FragColor;</p>
<p>float getSpecular(vec3 dir, vec3 normal, vec3 eye) {<br>
vec3 reflectionLight = reflect(-dir, normal);<br>
float eyeCos = max(dot(eye, reflectionLight), 0.0);<br>
return specularFactor *  pow(eyeCos, shininess);<br>
}</p>
<p>vec4 phongReflection(vec3 pos, vec3 normal, vec3 eye) {<br>
float specular = 0.0;<br>
vec3 diffuse = vec3(0);</p>
<p>// 处理平行光<br>
for(int i = 0; i &lt; MAX_LIGHT_COUNT; i++) {<br>
vec3 dir = directionalLightDirection[i];<br>
if(dir.x == 0.0 &amp;&amp; dir.y == 0.0 &amp;&amp; dir.z == 0.0) continue;<br>
vec4 d = viewMatrix * vec4(dir, 0.0);<br>
dir = normalize(-d.xyz);<br>
float cos = max(dot(dir, normal), 0.0);<br>
diffuse += cos * directionalLightColor[i];<br>
specular += getSpecular(dir, normal, eye);<br>
}</p>
<p>// 处理点光源<br>
for(int i = 0; i &lt; MAX_LIGHT_COUNT; i++) {<br>
vec3 decay = pointLightDecay[i];<br>
if(decay.x == 0.0 &amp;&amp; decay.y == 0.0 &amp;&amp; decay.z == 0.0) continue;<br>
vec3 dir = (viewMatrix * vec4(pointLightPosition[i], 1.0)).xyz - pos;<br>
float dis = length(dir);<br>
dir = normalize(dir);<br>
float cos = max(dot(dir, normal), 0.0);<br>
float d = min(1.0, 1.0 / (decay.x * pow(dis, 2.0) + decay.y * dis + decay.z));<br>
diffuse += d * cos * pointLightColor[i];<br>
specular += getSpecular(dir, normal, eye);<br>
}</p>
<p>// 处理聚光灯<br>
for(int i = 0; i &lt; MAX_LIGHT_COUNT; i++) {<br>
vec3 decay = spotLightDecay[i];<br>
if(decay.x == 0.0 &amp;&amp; decay.y == 0.0 &amp;&amp; decay.z == 0.0) continue;</p>
<pre><code>vec3 dir = (viewMatrix * vec4(spotLightPosition[i], 1.0)).xyz - pos;  
float dis = length(dir);  
dir = normalize(dir);  

// 聚光灯的朝向  
vec3 spotDir = (viewMatrix * vec4(spotLightDirection[i], 0.0)).xyz;  
// 通过余弦值判断夹角范围  
float ang = cos(spotLightAngle[i]);  
float r = step(ang, dot(dir, normalize(-spotDir)));  

float cos = max(dot(dir, normal), 0.0);  
float d = min(1.0, 1.0 / (decay.x * pow(dis, 2.0) + decay.y * dis + decay.z));  
diffuse += r * d * cos * spotLightColor[i];  
specular += r * getSpecular(dir, normal, eye);  
</code></pre>
<p>}</p>
<p>return vec4(diffuse, specular);<br>
}</p>
<p>vec3 getNormal() {<br>
vec3 n = texture(tNormal, vUv).rgb * 2.0 - 1.0;<br>
return normalize(vTBN * n);<br>
}</p>
<p>void main() {<br>
vec3 eyeDirection = normalize(vCameraPos - vPos);<br>
vec3 normal = getNormal();<br>
vec4 phong = phongReflection(vPos, normal, eyeDirection);</p>
<p>// 合成颜色<br>
FragColor.rgb = phong.w + (phong.xyz + ambientLight) * materialReflection;<br>
FragColor.a = 1.0;<br>
}</p>
<p>片元着色器代码虽然也很长，但也并不复杂。因为其中的 Phong 反射模型，我们已经比较熟悉了。剩下的部分，我们重点理解，怎么从法线纹理中提取数据和 TBN 矩阵，来计算对应的法线就行了。具体的计算方法就是把法线纹理贴图中提取的数据转换到 [-1，1] 区间，然后左乘 TBN 矩阵并归一化。</p>
<p>然后，我们将经过处理之后的法向量传给 phongReflection 计算光照，就得到了法线贴图后的结果，效果如下图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/b86e32db03fa1e04c7b706a4b6e44c6b.png" alt=""></p>
<p>到这里我们就实现了完整的法线贴图。法线贴图就是根据法线纹理中保存的法向量数据以及 TBN 矩阵，将实际的法线计算出来，然后用实际的法线来计算光照的反射。具体点来说，要实现法线贴图，我们需要通过顶点数据计算几何体的切线和副切线，然后得到 TBN 矩阵，用 TBN 矩阵和法线纹理数据来计算法向量，从而完成法线贴图。</p>
<h3 id="使用偏导数来实现法线贴图">使用偏导数来实现法线贴图</h3>
<p>但是，构建 TBN 矩阵求法向量的方法还是有点麻烦。事实上，还有一种更巧妙的方法，不需要用顶点数据计算几何体的切线和副切线，而是直接用坐标插值和法线纹理来计算。</p>
<p>vec3 getNormal() {<br>
vec3 pos_dx = dFdx(vPos.xyz);<br>
vec3 pos_dy = dFdy(vPos.xyz);<br>
vec2 tex_dx = dFdx(vUv);<br>
vec2 tex_dy = dFdy(vUv);</p>
<p>vec3 t = normalize(pos_dx * tex_dy.t - pos_dy * tex_dx.t);<br>
vec3 b = normalize(-pos_dx * tex_dy.s + pos_dy * tex_dx.s);<br>
mat3 tbn = mat3(t, b, normalize(vNormal));</p>
<p>vec3 n = texture(tNormal, vUv).rgb * 2.0 - 1.0;<br>
return normalize(tbn * n);<br>
}</p>
<p>如上面代码所示，dFdx、dFdy 是 GLSL 内置函数，可以求插值的属性在 x、y 轴上的偏导数。那我们为什么要求偏导数呢？<strong>偏导数</strong>其实就代表插值的属性向量在 x、y 轴上的变化率，或者说曲面的切线。然后，我们再将顶点坐标曲面切线与 uv 坐标的切线求叉积，就能得到垂直于两条切线的法线。</p>
<p>那我们在 x、y 两个方向上求出的两条法线，就对应 TBN 空间的切线 tang 和副切线 bitang。然后，我们使用偏导数构建 TBN 矩阵，同样也是把 TBN 矩阵左乘从法线纹理中提取出的值，就可以计算出对应的法向量了。</p>
<p>这样做的好处是，我们不需要预先计算几何体的 tang 和 bitang 了。不过在片元着色器中计算偏导数也有一定的性能开销，所以各有利弊，我们可以根据不同情况选择不同的方案。</p>
<h2 id="法线贴图的应用">法线贴图的应用</h2>
<p>法线贴图的两种实现方式，我们都学会了。那法线贴图除了给几何体表面增加花纹以外，还可以用来增强物体细节，让物体看起来更加真实。比如说，在实现一个石块被变化的光源照亮效果的时候，我们就可以运用法线贴图技术，让石块的表面纹路细节显得非常的逼真。我把对应的片元着色器核心代码放在了下面，你可以利用今天学到的知识自己来实现一下。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/d0d5965f5cd91f6c0222b9fb8f782ab3.png" alt=""></p>
<p>uniform float uTime;</p>
<p>void main() {<br>
vec3 eyeDirection = normalize(vCameraPos - vPos);<br>
vec3 normal = getNormal();<br>
vec4 phong = phongReflection(vPos, normal, eyeDirection);<br>
// vec4 phong = phongReflection(vPos, vNormal, eyeDirection);</p>
<p>vec3 tex = texture(tMap, vUv).rgb;<br>
vec3 light = normalize(vec3(sin(uTime), 1.0, cos(uTime)));<br>
float shading = dot(normal, light) * 0.5;</p>
<p>FragColor.rgb = tex + shading;<br>
FragColor.a = 1.0;<br>
}</p>
<h2 id="要点总结">要点总结</h2>
<p>这节课，我们详细说了法线贴图这个技术。法线贴图是一种经典的图形学技术，可以用来给物体表面增加细节，让我们实现的效果更逼真。</p>
<p>具体来说，法线贴图是用一张图片来存储表面的法线数据。这张图片叫做法线纹理，它上面的每个像素对应一个坐标点的法线数据。</p>
<p>要想使用法线纹理的数据，我们还需要构建 TBN 矩阵。这个矩阵通过向量、矩阵乘法将法线数据转换到世界坐标中。</p>
<p>构建 TBN 矩阵我们有两个方法，一个是根据几何体顶点数据来计算切线（Tangent）、副切线（Bitangent），然后结合法向量一起构建 TBN 矩阵。另一个方法是使用偏导数来计算，这样我们就不用预先在顶点中计算 Tangent 和 Bitangent 了。两种方法各有利弊，我们可以根据实际情况来合理选择。</p>
<h2 id="小试牛刀">小试牛刀</h2>
<p>这里，我给出了两张图片，一张是纹理图片，一张是法线纹理，你能用它们分别来绘制一面墙，并且引入 Phong 反射模型，来实现光照效果吗？你还可以思考一下，应用法线贴图和不应用法线贴图绘制出来的墙，有什么差别？</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/da648b385bb5524a5e05aeb037a4e9d4.png" alt=""></p>
<p>欢迎在留言区和我讨论，分享你的答案和思考，也欢迎你把这节课分享给你的朋友，我们下节课再见！</p>
<h2 id="源码">源码</h2>
<p>课程中完整示例代码见GitHub 仓库</p>
<h2 id="推荐阅读">推荐阅读</h2>
<p>Normal mapping</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/">跟月影学可视化</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/25__%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E7%BB%84%E7%BB%87%E4%B8%8E%E4%B8%AA%E4%BA%BA%E7%9A%84%E7%A0%94%E5%8F%91%E6%95%88%E8%83%BD/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">25__如何提升组织与个人的研发效能？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/25__%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%9C%9F%E5%AE%9E%E7%9A%84%E5%AE%B9%E9%87%8F%E6%B5%8B%E8%AF%95/">
            <span class="next-text nav-default">25__如何在生产环境中进行真实的容量测试？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
