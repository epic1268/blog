<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>加餐二__SpriteJS：我是如何设计一个可视化图形渲染引擎的？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是月影。
今天，我们来聊一个相对轻松的话题，它不会有太多的代码，也不会有什么必须要掌握的理论知识。不过这个话题对你理解可视化，了解渲染引擎也是有帮助的。因为我今天要聊的话题是 SpriteJS，这个我亲自设计和实现的图形渲染引擎的版本迭代和演进。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%8A%A0%E9%A4%90%E4%BA%8C__spritejs%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%8A%A0%E9%A4%90%E4%BA%8C__spritejs%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E7%9A%84/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="加餐二__SpriteJS：我是如何设计一个可视化图形渲染引擎的？">
  <meta property="og:description" content="你好，我是月影。
今天，我们来聊一个相对轻松的话题，它不会有太多的代码，也不会有什么必须要掌握的理论知识。不过这个话题对你理解可视化，了解渲染引擎也是有帮助的。因为我今天要聊的话题是 SpriteJS，这个我亲自设计和实现的图形渲染引擎的版本迭代和演进。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="跟月影学可视化">

  <meta itemprop="name" content="加餐二__SpriteJS：我是如何设计一个可视化图形渲染引擎的？">
  <meta itemprop="description" content="你好，我是月影。
今天，我们来聊一个相对轻松的话题，它不会有太多的代码，也不会有什么必须要掌握的理论知识。不过这个话题对你理解可视化，了解渲染引擎也是有帮助的。因为我今天要聊的话题是 SpriteJS，这个我亲自设计和实现的图形渲染引擎的版本迭代和演进。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4260">
  <meta itemprop="keywords" content="跟月影学可视化">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="加餐二__SpriteJS：我是如何设计一个可视化图形渲染引擎的？">
  <meta name="twitter:description" content="你好，我是月影。
今天，我们来聊一个相对轻松的话题，它不会有太多的代码，也不会有什么必须要掌握的理论知识。不过这个话题对你理解可视化，了解渲染引擎也是有帮助的。因为我今天要聊的话题是 SpriteJS，这个我亲自设计和实现的图形渲染引擎的版本迭代和演进。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">加餐二__SpriteJS：我是如何设计一个可视化图形渲染引擎的？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4260 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#spritejs-v1x2017-年2018-年">SpriteJS v1.x（2017 年~2018 年）</a></li>
        <li><a href="#spritejs-v2x2018-年2019-年">SpriteJS v2.x（2018 年~2019 年）</a></li>
        <li><a href="#spritejs-v3x2019-年2020-年">SpriteJS v3.x（2019 年~2020 年）</a></li>
        <li><a href="#spritejs-的未来版本2020-年2021-年">SpriteJS 的未来版本（2020 年~2021 年）</a></li>
        <li><a href="#要点总结">要点总结</a></li>
        <li><a href="#课后思考">课后思考</a></li>
        <li><a href="#推荐阅读">推荐阅读</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是月影。</p>
<p>今天，我们来聊一个相对轻松的话题，它不会有太多的代码，也不会有什么必须要掌握的理论知识。不过这个话题对你理解可视化，了解渲染引擎也是有帮助的。因为我今天要聊的话题是 SpriteJS，这个我亲自设计和实现的图形渲染引擎的版本迭代和演进。</p>
<p>SpriteJS 是从 2017 年下半年开始设计的，到今天已经快三年了，它的大版本也从 1.0 升级到了 3.0。那么它为什么会被设计出来？它有什么特点？1.0、2.0、3.0 版本之间有什么区别，未来会不会有 4.0 甚至 5.0？别着急，听我一一道来。</p>
<h2 id="spritejs-v1x2017-年2018-年">SpriteJS v1.x（2017 年~2018 年）</h2>
<p>我们把时间调回到 2017 年下半年，当时我还在 360 奇舞团。奇舞团是 360 技术中台的前端团队，主要负责 Web 开发，包括 PC 端和移动端的产品的前端开发，比较少涉及可视化的内容。不过，虽然团队以支持传统 Web 开发为主，但是也支持过一部分可视化项目，比如一些 toB 系统的后台图表展现。那个时候，我们团队正要开始尝试探索可视化的方向。</p>
<p>如果你读过专栏的预习篇，你应该知道，要实现可视化图表，我们用图表库或者数据驱动框架都能够实现，前者使用起来简单，而后者更加灵活。当时，奇舞团的小伙伴更多是使用数据驱动框架D3.js来实现可视化图表的。</p>
<p>对 D3.js 来说，D3-selection是其核心子模块之一，它可以用来操作 DOM 树，返回选中的 DOM 元素集合。这个操作非常有用，因为它让我们可以像使用 jQuery 那样，快速遍历 DOM 元素，并且它通过 data 映射将数据与 DOM 元素对应起来。这样，我们用很简单的代码就能实现想要的可视化效果了。</p>
<p>比如，我们通过 <code>d3.select('body').selectAll('div').dataset(data).enter().append('div')</code>，把对应的 div 元素根据数据的数量添加到页面上的 body 元素下，然后，我们直接通过.style 来操作对应添加的 div 元素，修改它的样式，就能轻松绘制出一个简单的柱状图效果了。</p>
<pre><code>const dataset = [125, 121, 127, 193, 309];  
const colors = ['#fe645b', '#feb050', '#c2af87', '#81b848', '#55abf8'];  

const chart = d3.select('body')  
  .selectAll('div')  
  .data(dataset)  
  .enter()  
  .append('div')  
  .style('left', '450px')  
  .style('top', (d, i) =&gt; {  
    return `${200 + i * 45}px`;  
  })  
  .style('width', d =&gt; `${d}px`)  
  .style('height', '40px')  
  .style('background', (d, i) =&gt; colors[i]);
</code></pre>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/335224b578fb40c60e61ef3a6c1b5bb8.png" alt=""></p>
<p>这是一个非常快速且方便的绘图方式，但它也有局限性。D3-selection 只能操作具有 DOM 结构的图形系统，也就是 HTML 和 SVG。而对于 Canvas 和 WebGL，我们就没有办法像上面一样，直接遍历元素并且将数据和元素结构对应起来。</p>
<p>正因为 D3-selection 操作 DOM 使用起来特别方便，所以常见的 D3 例子都是用 HTML 或者 SVG 来写的，很少使用 Canvas 和 WebGL，即便后两者的性能要大大优于 HTML 和 SVG。因此，当时实现 SpriteJS 1.0 的初衷非常简单，那就是我希望让团队的同学既能使用熟悉的 D3.js 来支持可视化图表的展现，又可以使用 Canvas 来代替默认的 SVG 进行渲染，从而达到更好的性能。</p>
<p>所以，<strong>SpriteJS 1.0 实现了整个 DOM 底层的 API，我们可以像操作浏览器原生的 DOM 一样来操作 SpriteJS 元素，而我们最终渲染出的图形是调用底层 Canvas 的 API 绘制到画布上的</strong>。这样一来，SpriteJS 和 HTML 或者 SVG，就都可以用 D3-selection 来操作了，在使用上它们没有特别大的差别，但 SpriteJS 的最终渲染还是通过 Canvas 绘制的，性能相比其他两种有了较大的提升。</p>
<p>比如说，我用 D3.js 配合 SpriteJS 实现的柱状图代码，与使用 HTML 绘制的代码区别不大，但是由于是绘制在 Canvas 上，性能会提升很多。</p>
<pre><code>const {Scene, Sprite} = spritejs;  
const container = document.getElementById('container');  
const scene = new Scene({  
  container,  
  width: 800,  
  height: 800,  
});  

const dataset = [125, 121, 127, 193, 309];  
const colors = ['#fe645b', '#feb050', '#c2af87', '#81b848', '#55abf8'];  

const fglayer = scene.layer('fglayer');  
const chart = d3.select(fglayer)  
  .selectAll('sprite')  
  .data(dataset)  
  .enter()  
  .append('sprite')  
  .attr('x', 450)  
  .attr('y', (d, i) =&gt; {  
    return 200 + i * 45;  
  })  
  .attr('width', d =&gt; d)  
  .attr('height', 40)  
  .attr('bgcolor', (d, i) =&gt; colors[i]);
</code></pre>
<p>除了解决 API 的问题，以及让 D3-selection 可以使用之外，为了让使用方式尽可能接近于原生的 DOM，我还让 SpriteJS 1.0 实现了这 4 个特性，分别是标准的 DOM 元素盒模型、标准的 DOM 事件、Web Animation API（动画）以及缓存策略。</p>
<p>盒模型、DOM 事件和 Web Animation API，我想你作为前端工程师肯定都知道，所以我多说一下缓存策略。还记得在性能篇里我们说过，要提升 Canvas 的渲染性能，就要尽量减少绘图指令的数量和执行时间，比较有效的方式是，我们可以将绘制的图形用离屏 Canvas 缓存下来。这样，在下次绘制的时候，我们就可以将缓存未失效的元素从缓存中用 drawImage 的方式直接绘制出来，而不用重新执行绘制元素的绘图指令，也就大大提升了性能。</p>
<p>因此，<strong>在 SpriteJS 1.0 中，我实现了一套自动的缓存策略，它会根据代码运行判断是否对一个元素启用缓存，如果是，就尽可能地启用缓存，让渲染性能达到比较好的水平</strong>。</p>
<p>SpriteJS 1.0 实现的这些特性，基本上满足了我们当时的需要，让我们团队可以用 D3.js 配合 SpriteJS 来实现各种可视化图表项目需求，而且使用上非常接近于操作原生的 DOM，非常容易上手。</p>
<h2 id="spritejs-v2x2018-年2019-年">SpriteJS v2.x（2018 年~2019 年）</h2>
<p>到了 2018 年底，我开始思考 SpriteJS 的下一个版本。当时我们解决了在 PC 和移动 Web 上绘制可视化图表的诉求，不过外部的使用者和我们自己，在一些使用场景中，逐渐开始有一些跨平台的需求，比如在服务端渲染，或者在小程序中渲染。</p>
<p>因此，我开始重构代码，将绘图系统分层设计，实现了渲染的适配层。在适配层中，所有的绘图能力都由 Canvas 底层 API 提供，与浏览器 DOM 和其他的 API 无关。这样，SpriteJS 就能够运行在任何提供了 Canvas 运行时环境的系统中，而不一定是浏览器。</p>
<p>重构后的代码能够通过node-canvas运行在 Node.js 环境中，所以我们就能够使用服务端渲染来实现一些特殊的可视化项目。比如，我们曾经有一个项目要处理大量的历史数据，大概有几十万到上百万条记录，如果在前端分别绘制它们，性能一定会有问题。所以，我们将它们通过服务端绘制并缓存好之后，以图像的方式发送给前端，这样就大大提升了性能。此外，我们还通过在适配层上提供不同的封装，让 SpriteJS 2.0 支持了小程序环境，也能够运行在微信小程序中。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/913eff12547b7aba167e787846dd08c5.png" alt=""></p>
<p>上图是 SpriteJS 2.0 的主体架构，它的底层由一些通用模块组成，Sprite-core 是适配层，SpriteJS 是支持浏览器和 Node.js 的运行时，Sprite-wxapp 是小程序运行时，Sprite-extend-* 是一些外部扩展。我们通过外部扩展实现了粒子系统和物理引擎，以及对主流响应式框架的支持，让 SpriteJS 2.0 可以直接支持vue和react。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/6d7fa048a2496826f87a67bb27989b67.png" alt=""></p>
<p>SpriteJS 2.0 通过扩展实现物理引擎</p>
<p>除此以外，SpriteJS 2.0 还支持了文字排版和布局系统。其中，文字排版支持了多行文本自动换行，实现了几乎所有 CSS3 支持的文字排版属性，布局系统则支持了完整的弹性布局（Flex layout)。这两个特性被很多用户喜爱。</p>
<p>可以说，我们对 SpriteJS 2.0 做了加法，让它在 1.0 的基础上增加了许多强大且有用的特性。到了 2019 年底，我又开始思考实现 SpriteJS 3.0。这次我打算对特性做一些取舍，将许多特性从 SpriteJS 3.0 中去掉，甚至包括深受使用者喜爱的文字排版和布局系统。这又是为什么呢？</p>
<p>这是因为 SpriteJS 2.0 虽好，但是它也有一些明显的缺点：</p>
<ol>
<li>只支持 Canvas2D，尽管有缓存策略，性能仍然不足；</li>
<li>多平台适配采用不同的分支，维护起来比较麻烦；</li>
<li>支持了许多非核心功能，如文字排版、布局，使得 JavaScript 文件太大；</li>
<li>不支持 3D 绘图。</li>
</ol>
<h2 id="spritejs-v3x2019-年2020-年">SpriteJS v3.x（2019 年~2020 年）</h2>
<p>在 SpriteJS 3.0 中，我舍弃了非核心功能，将 SpriteJS 定位为纯粹的图形渲染引擎，核心目标是追求极致的性能。</p>
<p>在适配层上，SpriteJS 3.0 完全舍弃了 2.0 设计里面较重的 sprite-core，采用了更轻量级的图形库mesh.js作为 2D 适配层，mesh.js 以 gl-renderer 作为 webgl 渲染底层库，结合 Canvas2D 的 polyfill 做到了优雅降级。当运行环境支持 WebGL2.0 时，SpriteJS 3.0 默认采用 WebGL2.0 渲染，否则降级为 WebGL1.0，如果也不支持 WebGL1.0，再最终降级为 Canvas2D。</p>
<p>在 3D 适配层方面，SpriteJS 3.0 采用了OGL库。这样一来，SpriteJS 3.0 就完全支持 WebGL 渲染，能够绘制 2D 和 3D 图形了。</p>
<p>SpriteJS 3.0 继承了 SpriteJS 2.0 的跨平台性，但是不再需要使用分支来适配多平台，而是采用了更轻量级的 polyfill 设计，同时支持服务端渲染、Web 浏览器渲染和微信小程序渲染，理论上讲还可以移植到其他支持 WebGL 或 Canvas2D 的运行环境中去。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/6e2d7640813356a9e89f2afb1815077f.png" alt=""></p>
<p>SpriteJS 3.0 结构</p>
<p>与 SpriteJS 1.0 和 SpriteJS 2.0 采用缓存机制优化性能不同，SpriteJS 3.0 默认采用 WebGL 渲染，因此使用了批量渲染的优化策略，我们在性能篇中讲过这种策略，在绘制大量几何图形时，它能够显著提升 WebGL 渲染的性能。</p>
<p>由于发挥了 GPU 并行计算的能力，在大批量图形绘制的性能上，SpriteJS 3.0 的性能大约是 SpriteJS 2.0 的 100 倍。此外，SpriteJS 3.0 支持了多线程渲染，可避免 UI 阻塞，从而进一步提升性能。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/27093ff16d6e4903dd4c952b46ca7538.png" alt=""></p>
<p>SpriteJS 3.0 绘制 5 万个地理信息点，60fps 帧率</p>
<p>总之，SpriteJS 3.0 随着性能的优化，已经成为一个纯粹的可视化渲染引擎了，但在我看来它仍然有些问题：</p>
<ol>
<li>性能优化得不够极致，数据压缩和批量渲染没有做到最好；</li>
<li>JS 的矩阵运算还是不够快，计算性能有提升空间；</li>
<li>因为考虑到兼容性的问题，所以我采用了 Canvas2D 的降级，这让 JavaScript 包仍然有些大；</li>
<li>3D 能力不够强，与 ThreeJS 等主流 3D 引擎仍有差距。</li>
</ol>
<h2 id="spritejs-的未来版本2020-年2021-年">SpriteJS 的未来版本（2020 年~2021 年）</h2>
<p>今年下半年，我开始设计 SpriteJS 4.0。这一次，我打算把它打造成一个更纯粹的图形系统，让它可以做到真正跨平台，完全不依赖于 Web 浏览器。</p>
<p>下面是 SpriteJS 4.0 的结构图，它的底层将采用 OpenGL ES 和 Skia 来渲染 3D 和 2D 图形，中间层使用 JavaScript Core 和 JS Bindings 技术，将底层 Api 通过 JavaScript 导出，然后在上层适配层实现 WebGL、WebGPU 和 Canvas2D 的 API，最上层实现 SpriteJS 的 API。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/57f07f81cc8cc7a891006065e85b2498.png" alt=""></p>
<p>SpriteJS 4.0 体系结构</p>
<p>根据这个设计，SpriteJS 4.0 将对浏览器完全没有依赖，同时依然可以通过 Web Assembly 方式运行在浏览器上。这样 SpriteJS 4.0 会成为真正跨平台的图形系统，可以以非常小的包集成到其他系统和原生 App 中，并且达到原生应用的性能。</p>
<p>在这一版，我还会全面优化 SpriteJS 的内存管理、矩阵运算和多线程机制，力求渲染性能再上一个台阶，最终能够完全超越现在市面上的任何主流的图形系统。</p>
<h2 id="要点总结">要点总结</h2>
<p>在 SpriteJS 1.0 中，我们追求的是和 DOM 一致的 API，能够使用 D3.js 结合 SpriteJS 来绘制可视化图表到 Canvas，从而提升性能。到了 SpriteJS 2.0，我们追求跨平台能力和一些强大的功能扩展，比如文字排版和布局系统。而到了 SpriteJS 3.0，我们决定回归到渲染引擎本质，追求极致的性能发挥 GPU 的能力，并支持 3D 渲染。再到今年的 SpriteJS 4.0，我打算把它打造成更纯粹的图形系统，让它的渲染能力和性能最终能够超越目前市面上的主流图形系统。</p>
<p>总的来说，在 SpriteJS 1.0 到 4.0 的设计发展过程中，包含了我对整个图形系统架构的思考和取舍。我希望通过我今天的分享，能够帮助你理解图形系统和渲染引擎的设计，也期待在你设计其他系统和平台的时候，它们能给你启发。</p>
<h2 id="课后思考">课后思考</h2>
<p>最后，请你试着回想你曾经接触过的可视化项目，如果用 SpriteJS 来实现它们会不会有更好的效果呢？欢迎把你的思考和答案写在留言区，我们一起讨论。</p>
<p>看了我给 SpriteJS 未来版本定下的目标，你有没有心动呢？SpriteJS 是一个开源项目，如果你学完这门课，也想参与进 SpriteJS 的开发，那我非常欢迎你成为一名 SpriteJS 开发者，为我们提交 PR、贡献代码。</p>
<p>好了，今天的内容就到这里，我们下节课见！</p>
<h2 id="推荐阅读">推荐阅读</h2>
<ol>
<li>D3.js</li>
<li>SpriteJS</li>
<li>Mesh.js</li>
</ol>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/">跟月影学可视化</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E5%8A%A0%E9%A4%90%E5%85%AB__%E7%A8%8B%E5%BA%8F%E5%91%98%E6%80%8E%E4%B9%88%E6%89%8D%E8%83%BD%E8%AE%A9%E8%87%AA%E5%B7%B1%E8%B5%B0%E5%BE%97%E6%9B%B4%E9%AB%98%E6%9B%B4%E8%BF%9C/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">加餐八__程序员怎么才能让自己走得更高、更远？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E5%8A%A0%E9%A4%90%E4%BA%8C__%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%87%8D%E6%9E%84%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E7%AD%89%E7%9B%B8%E5%85%B3%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/">
            <span class="next-text nav-default">加餐二__设计模式、重构、编程规范等相关书籍推荐</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
