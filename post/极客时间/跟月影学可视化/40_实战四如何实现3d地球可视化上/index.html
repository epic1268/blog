<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>40_实战（四）：如何实现3D地球可视化（上）？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是月影。
前几节课我们一起进行了简单图表和二维地图的实战，这节课，我们来实现更炫酷的 3D 地球可视化。
3D 地球可视化主要是以 3D 的方式呈现整个地球的模型，视觉上看起来更炫酷。它是可视化应用里常见的一种形式，通常用来实现全球地理信息相关的可视化应用，例如全球黑客攻防示意图、全球航班信息示意图以及全球贸易活动示意图等等。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/40_%E5%AE%9E%E6%88%98%E5%9B%9B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B03d%E5%9C%B0%E7%90%83%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%8A/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/40_%E5%AE%9E%E6%88%98%E5%9B%9B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B03d%E5%9C%B0%E7%90%83%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%8A/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="40_实战（四）：如何实现3D地球可视化（上）？">
  <meta property="og:description" content="你好，我是月影。
前几节课我们一起进行了简单图表和二维地图的实战，这节课，我们来实现更炫酷的 3D 地球可视化。
3D 地球可视化主要是以 3D 的方式呈现整个地球的模型，视觉上看起来更炫酷。它是可视化应用里常见的一种形式，通常用来实现全球地理信息相关的可视化应用，例如全球黑客攻防示意图、全球航班信息示意图以及全球贸易活动示意图等等。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="跟月影学可视化">

  <meta itemprop="name" content="40_实战（四）：如何实现3D地球可视化（上）？">
  <meta itemprop="description" content="你好，我是月影。
前几节课我们一起进行了简单图表和二维地图的实战，这节课，我们来实现更炫酷的 3D 地球可视化。
3D 地球可视化主要是以 3D 的方式呈现整个地球的模型，视觉上看起来更炫酷。它是可视化应用里常见的一种形式，通常用来实现全球地理信息相关的可视化应用，例如全球黑客攻防示意图、全球航班信息示意图以及全球贸易活动示意图等等。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3555">
  <meta itemprop="keywords" content="跟月影学可视化">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="40_实战（四）：如何实现3D地球可视化（上）？">
  <meta name="twitter:description" content="你好，我是月影。
前几节课我们一起进行了简单图表和二维地图的实战，这节课，我们来实现更炫酷的 3D 地球可视化。
3D 地球可视化主要是以 3D 的方式呈现整个地球的模型，视觉上看起来更炫酷。它是可视化应用里常见的一种形式，通常用来实现全球地理信息相关的可视化应用，例如全球黑客攻防示意图、全球航班信息示意图以及全球贸易活动示意图等等。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">40_实战（四）：如何实现3D地球可视化（上）？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3555 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#如何实现一个-3d-地球">如何实现一个 3D 地球</a>
          <ul>
            <li><a href="#1-绘制一个-3d-球体">1. 绘制一个 3D 球体</a></li>
            <li><a href="#2-绘制地图">2. 绘制地图</a></li>
            <li><a href="#3-将地图作为纹理">3. 将地图作为纹理</a></li>
          </ul>
        </li>
        <li><a href="#如何实现星空背景">如何实现星空背景</a></li>
        <li><a href="#要点总结">要点总结</a></li>
        <li><a href="#小试牛刀">小试牛刀</a></li>
        <li><a href="#源码">源码</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是月影。</p>
<p>前几节课我们一起进行了简单图表和二维地图的实战，这节课，我们来实现更炫酷的 3D 地球可视化。</p>
<p>3D 地球可视化主要是以 3D 的方式呈现整个地球的模型，视觉上看起来更炫酷。它是可视化应用里常见的一种形式，通常用来实现全球地理信息相关的可视化应用，例如全球黑客攻防示意图、全球航班信息示意图以及全球贸易活动示意图等等。</p>
<p>因为内容比较多，所以我会用两节课来讲解 3D 地球的实现效果。而且，由于我们的关注点在效果，因此为了简化实现过程和把重点聚焦在效果上，我就不刻意准备数据了，我们用一些随机数据来实现。不过，即使我们要实现的是包含真实数据的 3D 可视化应用项目，前面学过的数据处理方法仍然是适用的。这里，我就不多说了。</p>
<p>在学习之前，你可以先看一下我们最终要实现的 3D 地球可视化效果，先有一个直观的印象。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/31a87ae556bb5114d25e41e75d1bf007.png" alt=""></p>
<p>如上面动画图像所示，我们要做的 3D 可视化效果是一个悬浮于宇宙空间中的地球，它的背后是一些星空背景和浅色的光晕，并且地球在不停旋转的同时，会有一些不同的地点出现飞线动画。</p>
<p>接下来，我们就来一步步实现这样的效果。</p>
<h2 id="如何实现一个-3d-地球">如何实现一个 3D 地球</h2>
<p>第一步，我们自然是要实现一个旋转的地球。通过前面课程的学习，我们知道直接用 SpriteJS 的 3D 扩展就可以方便地绘制 3D 图形。这里，我们再系统地说一下实现的方法。</p>
<h3 id="1-绘制一个-3d-球体">1. 绘制一个 3D 球体</h3>
<p>首先，我们加载 SpriteJS 和 3D 扩展，最简单的方式还是直接使用 CDN 上打包好的文件，代码如下：</p>
<script src="http://unpkg.com/spritejs/dist/spritejs.js"></script>  
<script src="http://unpkg.com/sprite-extend-3d/dist/sprite-extend-3d.js"></script>
<p>加载完成之后，我们创建场景对象，添加 Layer，代码如下：</p>
<p>const {Scene} = spritejs;<br>
const container = document.getElementById(&lsquo;container&rsquo;);<br>
const scene = new Scene({<br>
container,<br>
});<br>
const layer = scene.layer3d(&lsquo;fglayer&rsquo;, {<br>
alpha: false,<br>
camera: {<br>
fov: 35,<br>
pos: [0, 0, 5],<br>
},<br>
});</p>
<p>与 2D 的 Layer 不同，SpriteJS 的 3D 扩展创建的 Layer 需要设置相机。这里，我们设置了一个透视相机，视角为 35 度，位置为 0, 0, 5</p>
<p>接着是创建 WebGL 的 Program，我们通过 Layer 对象的 createProgram 来创建，代码如下：</p>
<p>const {Sphere, shaders} = spritejs.ext3d;</p>
<p>const program = layer.createProgram({<br>
&hellip;shaders.GEOMETRY,<br>
cullFace: null,<br>
});</p>
<p>SpriteJS 的 3D 扩展内置了一些常用的 Shader，比如 shaders.GEOMETRY 就是一个符合 Phong 反射模型的几何体 Shader，所以这次，我们直接使用它。</p>
<p>接着，我们创建一个球体，它在 SpriteJS 的 3D 扩展中对应 Sphere 对象。</p>
<p>const globe = new Sphere(program, {<br>
colors: &lsquo;#333&rsquo;,<br>
widthSegments: 64,<br>
heightSegments: 32,<br>
radius: 1,<br>
});</p>
<p>layer.append(globe);</p>
<p>我们给球体设置颜色、宽度、高度和半径这些默认的属性，然后将它添加到 layer 上，这样我们就能在画布上将这个球体显示出来了，效果如下所示。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/2b1a4656782b49cc7aa539b98dafc87d.png" alt=""></p>
<p>现在，我们只在画布上显示了一个灰色的球体，它和我们要实现的地球还相差甚远。别着急，我们一步一步来。</p>
<h3 id="2-绘制地图">2. 绘制地图</h3>
<p>上节课，我们已经讲了绘制平面地图的方法，就是把表示地图的 JSON 数据利用墨卡托投影到平面上。接下来，我们也要先绘制一张平面地图，然后把它以纹理的方式添加到我们创建的 3D 球体上。</p>
<p>不过，与平面地图采用墨卡托投影不同，作为纹理的球面地图需要采用<strong>等角方位投影</strong>(Equirectangular Projection)。d3-geo 模块中同样支持这种投影方式，我们可以直接加载 d3-geo 模块，然后使用对应的代码来创建投影。</p>
<p>从 CDN 加载 d3-geo 模块需要加载以下两个 JS 文件：</p>
<script src="https://d3js.org/d3-array.v2.min.js"></script>  
<script src="https://d3js.org/d3-geo.v2.min.js"></script>  
<p>然后，我们创建对应的投影：</p>
<p>const mapWidth = 960;<br>
const mapHeight = 480;<br>
const mapScale = 4;</p>
<p>const projection = d3.geoEquirectangular();<br>
projection.scale(projection.scale() * mapScale).translate([mapWidth * mapScale * 0.5, (mapHeight + 2) * mapScale * 0.5]);</p>
<p>这里，我们首先通过 d3.geoEquirectangular 方法来创建等角方位投影，再将它进行缩放。d3 的地图投影默认宽高为 960 * 480，我们将投影缩放为 4 倍，也就是将地图绘制为 3480 * 1920 大小。这样一来，它就能在大屏上显示得更清晰。</p>
<p>然后，我们通过 tanslate 将中心点调整到画布中心，因为 JSON 的地图数据的 0,0 点在画布正中心。仔细看我上面的代码，你会注意到我们在 Y 方向上多调整一个像素，这是因为原始数据坐标有一点偏差。</p>
<p>通过我刚才说的这些步骤，我们就创建好了投影，接下来就可以开始绘制地图了。我们从 topoJSON 数据加载地图。</p>
<p>async function loadMap(src = topojsonData, {strokeColor, fillColor} = {}) {<br>
const data = await (await fetch(src)).json();<br>
const countries = topojson.feature(data, data.objects.countries);<br>
const canvas = new OffscreenCanvas(mapScale * mapWidth, mapScale * mapHeight);<br>
const context = canvas.getContext(&lsquo;2d&rsquo;);<br>
context.imageSmoothingEnabled = false;<br>
return drawMap({context, countries, strokeColor, fillColor});<br>
}</p>
<p>这里我们创建一个离屏 Canvas，用加载的数据来绘制地图到离屏 Canvas 上，对应的绘制地图的逻辑如下：</p>
<p>function drawMap({<br>
context,<br>
countries,<br>
strokeColor = &lsquo;#666&rsquo;,<br>
fillColor = &lsquo;#000&rsquo;,<br>
strokeWidth = 1.5,<br>
} = {}) {<br>
const path = d3.geoPath(projection).context(context);</p>
<p>context.save();<br>
context.strokeStyle = strokeColor;<br>
context.lineWidth = strokeWidth;<br>
context.fillStyle = fillColor;<br>
context.beginPath();<br>
path(countries);<br>
context.fill();<br>
context.stroke();<br>
context.restore();</p>
<p>return context.canvas;</p>
<p>这样，我们就完成了地图加载和绘制的逻辑。当然，我们现在还看不到地图，因为我们只是将它绘制到了一个离屏的 Canvas 对象上，并没有将这个对象显示出来。</p>
<h3 id="3-将地图作为纹理">3. 将地图作为纹理</h3>
<p>要显示地图为 3D 地球，我们需要将刚刚绘制的地图作为纹理添加到之前绘制的球体上。之前我们绘制球体时，使用的是 SpriteJS 中默认的 shader，它是符合 Phong 光照模型的几何材质的。因为考虑到地球有特殊光照，我们现在自己实现一组自定义的 shader。</p>
<p>const vertex = `<br>
precision highp float;<br>
precision highp int;</p>
<p>attribute vec3 position;<br>
attribute vec3 normal;<br>
attribute vec4 color;<br>
attribute vec2 uv;</p>
<p>uniform mat4 modelViewMatrix;<br>
uniform mat4 projectionMatrix;<br>
uniform mat3 normalMatrix;</p>
<p>varying vec3 vNormal;<br>
varying vec2 vUv;<br>
varying vec4 vColor;</p>
<p>uniform vec3 pointLightPosition; //点光源位置</p>
<p>void main() {<br>
vNormal = normalize(normalMatrix * normal);</p>
<pre><code>vUv = uv;  
vColor = color;  


gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);  
</code></pre>
<p>}   <br>
`;</p>
<p>const fragment = `<br>
precision highp float;<br>
precision highp int;</p>
<p>varying vec3 vNormal;<br>
varying vec4 vColor;</p>
<p>uniform sampler2D tMap;<br>
varying vec2 vUv;</p>
<p>uniform vec2 uResolution;</p>
<p>void main() {<br>
vec4 color = vColor;<br>
vec4 texColor = texture2D(tMap, vUv);<br>
vec2 st = gl_FragCoord.xy / uResolution;</p>
<pre><code>float alpha = texColor.a;  
color.rgb = mix(color.rgb, texColor.rgb, alpha);  
color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));  
color.a = texColor.a + (1.0 - texColor.a) * color.a;  


float d = distance(st, vec2(0.5));  


gl_FragColor.rgb = color.rgb + 0.3 * pow((1.0 - d), 3.0);  
gl_FragColor.a = c
</code></pre>
<p>我们用上面的 Shader 来创建 Program。这组 Shader 并不复杂，原理我们在视觉篇都已经解释过了。如果你觉得理解起来依然有困难，可以复习一下视觉篇的内容。接着，我们创建一个 Texture 对象，将它赋给 Program 对象，代码如下。</p>
<p>const texture = layer.createTexture({});</p>
<p>const program = layer.createProgram({<br>
vertex,<br>
fragment,<br>
texture,<br>
cullFace: null,<br>
});</p>
<p>现在，画布上就显示出了一个中心有些亮光的球体。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/a2ea7ed1efd6b56498417330af0224c2.png" alt=""></p>
<p>从中，我们还是看不出地球的样子。这是因为我们给的 texture 对象是一个空的纹理对象。接下来，我们只要执行 loadMap 方法，将地图加载出来，再添加给这个空的纹理对象，然后刷新画布就可以了。对应代码如下：</p>
<p>loadMap().then((map) =&gt; {<br>
texture.image = map;<br>
texture.needsUpdate = true;<br>
layer.forceUpdate();<br>
});</p>
<p>最终，我们就显示出了地球的样子。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/0986d03140a9a1bcb63ef0c52c5f4e0b.png" alt=""></p>
<p>我们还可以给地球添加轨迹球控制，并让它自动旋转。在 SpriteJS 中非常简单，只需要一行代码即可完成。</p>
<p>layer.setOrbit({autoRotate: true}); // 开启旋转控制</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/0251e528509379745ccd23700db8240b.png" alt=""></p>
<p>这样我们就得到一个自动旋转的地球效果了。</p>
<h2 id="如何实现星空背景">如何实现星空背景</h2>
<p>不过，这个孤零零的地球悬浮在黑色背景的空间里，看起来不是很吸引人，所以我们可以给地球添加一些背景，比如星空，让它真正悬浮在群星闪耀的太空中。</p>
<p>要实现星空的效果，第一步是要创建一个天空包围盒。天空包围盒也是一个球体（Sphere）对象，只不过它要比地球大很多，以此让摄像机处于整个球体内部。为了显示群星，天空包围盒有自己特殊的 Shader。我们来看一下：</p>
<p>const skyVertex = `<br>
precision highp float;<br>
precision highp int;</p>
<p>attribute vec3 position;<br>
attribute vec3 normal;<br>
attribute vec2 uv;</p>
<p>uniform mat3 normalMatrix;<br>
uniform mat4 modelViewMatrix;<br>
uniform mat4 projectionMatrix;</p>
<p>varying vec2 vUv;</p>
<p>void main() {<br>
vUv = uv;<br>
gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);<br>
}<br>
`;</p>
<p>const skyFragment = `<br>
precision highp float;<br>
precision highp int;<br>
varying vec2 vUv;</p>
<p>highp float random(vec2 co)<br>
{<br>
highp float a = 12.9898;<br>
highp float b = 78.233;<br>
highp float c = 43758.5453;<br>
highp float dt= dot(co.xy ,vec2(a,b));<br>
highp float sn= mod(dt,3.14);<br>
return fract(sin(sn) * c);<br>
}</p>
<p>// Value Noise by Inigo Quilez - iq/2013<br>
// <a href="https://www.shadertoy.com/view/lsf3WH">https://www.shadertoy.com/view/lsf3WH</a><br>
highp float noise(vec2 st) {<br>
vec2 i = floor(st);<br>
vec2 f = fract(st);<br>
vec2 u = f * f * (3.0 - 2.0 * f);<br>
return mix( mix( random( i + vec2(0.0,0.0) ),<br>
random( i + vec2(1.0,0.0) ), u.x),<br>
mix( random( i + vec2(0.0,1.0) ),<br>
random( i + vec2(1.0,1.0) ), u.x), u.y);<br>
}</p>
<p>void main() {<br>
gl_FragColor.rgb = vec3(1.0);<br>
gl_FragColor.a = step(0.93, noise(vUv * 6000.0));</p>
<p>上面的代码是天空包围盒的 Shader，实际上它是我们使用二维噪声的技巧来实现的。在第 16 节课中也有过类似的做法，当时我们是用它来模拟水滴滚过的效果。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/9633927ea7633d3ad1d9ea8c737616d2.png" alt=""></p>
<p>但在这里，我们通过 step 函数和 vUv 的缩放，将它缩小之后，最终呈现出来星空效果。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/4caccd80e70d714bda26bd5df3f95fa4.png" alt=""></p>
<p>对应的创建天空盒子的 JavaScript 代码如下：</p>
<p>function createSky(layer, skyProgram) {<br>
skyProgram = skyProgram || layer.createProgram({<br>
vertex: skyVertex,<br>
fragment: skyFragment,<br>
transparent: true,<br>
cullFace: null,<br>
});<br>
const skyBox = new Sphere(skyProgram);<br>
skyBox.attributes.scale = 100;<br>
layer.append(skyBox);<br>
return skyBox;<br>
}</p>
<p>createSky(layer);</p>
<p>不过，光看这些代码，你可能还不能完全明白，为什么二维噪声技巧就能实现星空效果。那也不要紧，完整的示例代码在GitHub 仓库中，最好的理解方式还是你自己试着手动修改一下 skyFragment 中的绘制参数，看看实现出来效果，你就能明白了。</p>
<h2 id="要点总结">要点总结</h2>
<p>这节课，我们讲了实现 3D 地球可视化效果的方法，以及给 3D 地球添加天空背景的方法。</p>
<p>要实现 3D 地球效果，我们可以使用 SpriteJS 和它的 3D 扩展库。首先，我们绘制一个 3D 球体。然后，我们用 topoJSON 数据绘制地图，注意地图的投影方式必须选择等角方位投影。最后，我们把地图作为纹理添加到 3D 球体上，这样就绘制出了 3D 地球。</p>
<p>而要实现星空背景，我们需要创建一个天空盒子，它可以看成是一个放大很多倍的球体，包裹在地球的外面。具体的思路就是，我们创建一组特殊的 Shader，通过二维噪声来实现星空的效果。</p>
<p>说的这里，你可能会有一些疑问，我们为什么要用 topoJSON 数据来绘制地图，而不采用现成的等角方位投影的平面地图图片，直接用它来作为纹理，那样不是能够更快绘制出 3D 地球吗？的确，这样确实也能够更简单地绘制出 3D 地球，但这么做也有代价，就是我们没有地图数据就不能进一步实现交互效果了，比如说，点击某个地理区域实现当前国家地区的高亮效果了。</p>
<p>那在下节课，我们就会进一步讲解怎么在 3D 地球上添加交互效果，以及根据地理位置来放置各种记号。你的疑问也都会一一解开。</p>
<h2 id="小试牛刀">小试牛刀</h2>
<p>我们说，如果不考虑交互，可以直接使用更简单的等角方位投影地图作为纹理来直接绘制 3D 地球。你能试着在网上搜索类似的纹理图片来实现 3D 地球效果吗？</p>
<p>另外，你可以找类似的其他行星的图片，比如火星、木星图片来实现 3D 火星、木星的效果吗？</p>
<p>最后，你也可以想想，除了星空背景，如果我们还想在地球外部实现一层淡绿色的光晕，又该怎么做呢（提示：你可以使用距离场和颜色插值来实现）？</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/173fe2d05183458f2fe114ba9881cdb5.png" alt=""></p>
<p>今天的 3D 地球可视化实战就到这里了。欢迎把你实现的效果分享到留言区，我们一起交流。也欢迎把这节课转发出去，我们下节课见！</p>
<h2 id="源码">源码</h2>
<p>课程完整示例代码详</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/">跟月影学可视化</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/40_%E7%9E%A7%E4%B8%80%E7%9E%A7linux%E8%AF%A6%E8%A7%A3socket%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">40_瞧一瞧Linux：详解socket的接口实现</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/10x%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B3%95/40_%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E7%AB%9E%E4%BA%89%E5%8A%9B/">
            <span class="next-text nav-default">40_我们应该如何保持竞争力？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
