<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>05__如何用向量和坐标系描述点和线段？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是月影。
为什么你做了很多可视化项目，解决了一个、两个、三个甚至多个不同类型的图表展现之后，还是不能系统地提升自己的能力，在下次面对新的项目时依然会有各种难以克服的困难？这是因为你陷入了细节里。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/05__%E5%A6%82%E4%BD%95%E7%94%A8%E5%90%91%E9%87%8F%E5%92%8C%E5%9D%90%E6%A0%87%E7%B3%BB%E6%8F%8F%E8%BF%B0%E7%82%B9%E5%92%8C%E7%BA%BF%E6%AE%B5/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/05__%E5%A6%82%E4%BD%95%E7%94%A8%E5%90%91%E9%87%8F%E5%92%8C%E5%9D%90%E6%A0%87%E7%B3%BB%E6%8F%8F%E8%BF%B0%E7%82%B9%E5%92%8C%E7%BA%BF%E6%AE%B5/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="05__如何用向量和坐标系描述点和线段？">
  <meta property="og:description" content="你好，我是月影。
为什么你做了很多可视化项目，解决了一个、两个、三个甚至多个不同类型的图表展现之后，还是不能系统地提升自己的能力，在下次面对新的项目时依然会有各种难以克服的困难？这是因为你陷入了细节里。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="跟月影学可视化">

  <meta itemprop="name" content="05__如何用向量和坐标系描述点和线段？">
  <meta itemprop="description" content="你好，我是月影。
为什么你做了很多可视化项目，解决了一个、两个、三个甚至多个不同类型的图表展现之后，还是不能系统地提升自己的能力，在下次面对新的项目时依然会有各种难以克服的困难？这是因为你陷入了细节里。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5188">
  <meta itemprop="keywords" content="跟月影学可视化">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="05__如何用向量和坐标系描述点和线段？">
  <meta name="twitter:description" content="你好，我是月影。
为什么你做了很多可视化项目，解决了一个、两个、三个甚至多个不同类型的图表展现之后，还是不能系统地提升自己的能力，在下次面对新的项目时依然会有各种难以克服的困难？这是因为你陷入了细节里。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">05__如何用向量和坐标系描述点和线段？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5188 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#坐标系与坐标映射">坐标系与坐标映射</a></li>
        <li><a href="#如何用-canvas-实现坐标系转换">如何用 Canvas 实现坐标系转换？</a></li>
        <li><a href="#如何用向量来描述点和线段">如何用向量来描述点和线段？</a></li>
        <li><a href="#实战演练用向量绘制一棵树">实战演练：用向量绘制一棵树</a></li>
        <li><a href="#向量运算的意义">向量运算的意义</a></li>
        <li><a href="#要点总结">要点总结</a></li>
        <li><a href="#小试牛刀">小试牛刀</a></li>
        <li><a href="#源码">源码</a></li>
        <li><a href="#推荐阅读">推荐阅读</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是月影。</p>
<p>为什么你做了很多可视化项目，解决了一个、两个、三个甚至多个不同类型的图表展现之后，还是不能系统地提升自己的能力，在下次面对新的项目时依然会有各种难以克服的困难？这是因为你陷入了细节里。</p>
<p>什么是细节？简单来说，细节就是各种纯粹的图形学问题。在可视化项目里，我们需要描述很多的图形，而描述图形的顶点、边、线、面、体和其他各种信息有很多不同的方法。并且，如果我们使用不同的绘图系统，每个绘图系统又可能有独特的方式或者特定的 API，去解决某个或某类具体的问题。</p>
<p>正因为有了太多可以选择的工具，我们也就很难找到最恰当的那一个。而且<strong>如果我们手中只有解决具体问题的工具，没有统一的方法论，那我们也无法一劳永逸地解决问题的根本</strong>。</p>
<p>因此，我们要建立一套与各个图形系统无关联的、简单的基于向量和矩阵运算的数学体系，用它来描述所有的几何图形信息。这就是我在数学篇想要和你讨论的主要问题，也就是<strong>如何建立一套描述几何图形信息的数学体系，以及如何用这个体系来解决我们的可视化图形呈现的问题</strong>。</p>
<p>那这一节课，我们先学习用坐标系与向量来描述基本图形的方法，从如何定义和变换图形的直角坐标系，以及如何运用向量表示点和线段这两方面讲起。</p>
<h2 id="坐标系与坐标映射">坐标系与坐标映射</h2>
<p>首先，我们来看看浏览器的四个图形系统通用的坐标系分别是什么样的。</p>
<p>HTML 采用的是窗口坐标系，以参考对象（参考对象通常是最接近图形元素的 position 非 static 的元素）的元素盒子左上角为坐标原点，x 轴向右，y 轴向下，坐标值对应像素值。</p>
<p>SVG 采用的是视区盒子（viewBox）坐标系。这个坐标系在默认情况下，是以 svg 根元素左上角为坐标原点，x 轴向右，y 轴向下，svg 根元素右下角坐标为它的像素宽高值。如果我们设置了 viewBox 属性，那么 svg 根元素左上角为 viewBox 的前两个值，右下角为 viewBox 的后两个值。</p>
<p>Canvas 采用的坐标系我们比较熟悉了，它默认以画布左上角为坐标原点，右下角坐标值为 Canvas 的画布宽高值。</p>
<p>WebGL 的坐标系比较特殊，是一个三维坐标系。它默认以画布正中间为坐标原点，x 轴朝右，y 轴朝上，z 轴朝外，x 轴、y 轴在画布中范围是 -1 到 1。</p>
<p>尽管这四个坐标系在原点位置、坐标轴方向、坐标范围上有所区别，但都是<strong>直角坐标系</strong>，所以它们都满足直角坐标系的特性：不管原点和轴的方向怎么变，用同样的方法绘制几何图形，它们的形状和相对位置都不变。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/6689fd60812b9c9cfd6a9fad7187f5d1.png" alt=""></p>
<p>为了方便处理图形，我们经常需要对坐标系进行转换。转换坐标系可以说是一个非常基础且重要的操作了。正因为这四个坐标系都是直角坐标系，所以它们可以很方便地相互转化。其中，HTML、SVG 和 Canvas 都提供了 transform 的 API 能够帮助我们很方便地转换坐标系。而 WebGL 本身不提供 tranform 的 API，但我们可以在 shader 里做矩阵运算来实现坐标转换，WebGL 的问题我们在后续课程会有专门讨论，今天我们先来说说其他三种。那接下来我们就以 Canvas 为例，来看看用 transform API 怎样进行坐标转换。</p>
<h2 id="如何用-canvas-实现坐标系转换">如何用 Canvas 实现坐标系转换？</h2>
<p>假设，我们要在宽 512 * 高 256 的一个 Canvas 画布上实现如下的视觉效果。其中，山的高度是 100，底边 200，两座山的中心位置到中线的距离都是 80，太阳的圆心高度是 150。</p>
<p>当然，在不转换坐标系的情况下，我们也可以把图形绘制出来，但是要经过顶点换算，下面我们就来说一说这个过程。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/ff0450f9c859c40a4e9da9feb5d0184d.png" alt=""></p>
<p>首先，因为 Canvas 坐标系默认的原点是左上角，底边的 y 坐标是 256，而山的高度是 100，所以山顶点的 y 坐标是 256 - 100 = 156。而因为太阳的高度是 150，所以太阳圆心的 y 坐标是 256 - 150 = 106。</p>
<p>然后，因为 x 轴中点的坐标是 512 / 2 = 256，所以两座山顶点的 x 坐标分别是 256 - 80 和 256 + 80，也就是 176 和 336。又因为山是等腰三角形，它的底边是 200，所以两座山底边的 x 坐标计算出来，分别是 76、276、236、436（176 - 100 =76、176 + 100=276、336 - 100=236、336 + 100=436）。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/d0638f1dcd98b5137adf96d72b2b1bda.png" alt=""></p>
<p>计算出这些坐标之后，我们很容易就可以将这个图画出来了。不过，为了增加一些趣味性，我们用一个Rough.js的库，绘制一个手绘风格的图像（Rough.js 库的 API 和 Canvas 差不多，绘制出来的图形比较有趣）。绘制的代码如下所示：</p>
<p>const rc = rough.canvas(document.querySelector(&lsquo;canvas&rsquo;));<br>
const hillOpts = {roughness: 2.8, strokeWidth: 2, fill: &lsquo;blue&rsquo;};<br>
rc.path(&lsquo;M76 256L176 156L276 256&rsquo;, hillOpts);<br>
rc.path(&lsquo;M236 256L336 156L436 256&rsquo;, hillOpts);<br>
rc.circle(256, 106, 105, {<br>
stroke: &lsquo;red&rsquo;,<br>
strokeWidth: 4,<br>
fill: &lsquo;rgba(255, 255, 0, 0.4)&rsquo;,<br>
fillStyle: &lsquo;solid&rsquo;,<br>
});</p>
<p>最终，我们绘制出的图形效果如下所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/5c3a3d77e193b409bc2c5da4bfd5566f.png" alt=""></p>
<p>到这里，我们通过简单的计算就绘制出了这一组图形。但你也能够想到，如果每次绘制都要花费时间在坐标换算上，这会非常不方便。所以，为了解决这个问题，我们可以采用坐标系变换来代替坐标换算。</p>
<p>这里，我们给 Canvas 的 2D 上下文设置一下 transform 变换。我们经常会用到两个变换：translate 和 scale。</p>
<p>首先，我们通过 translate 变换将 Canvas 画布的坐标原点，从左上角 (0, 0) 点移动至 (256, 256) 位置，即画布的底边上的中点位置。接着，以移动了原点后新的坐标为参照，通过 scale(1, -1) 将 y 轴向下的部分，即 y&gt;0 的部分沿 x 轴翻转 180 度，这样坐标系就变成以画布底边中点为原点，x 轴向右，y 轴向上的坐标系了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/26d5a76315caaf1c74cccde24624c2b3.png" alt=""></p>
<p>坐标系</p>
<p>执行了这个坐标变换，也就是让坐标系原点在中间之后，我们就可以更方便、直观地计算出几个图形元素的坐标了。</p>
<p>两个山顶的坐标就是 (-80, 100) 和 (80, 100)，山脚的坐标就是 (-180, 0)、(20, 0)、(-20, 0)、(180, 0)，太阳的中心点的坐标就是 (0, 150)。那么更改后的代码如下所示。</p>
<p>const rc = rough.canvas(document.querySelector(&lsquo;canvas&rsquo;));<br>
const ctx = rc.ctx;<br>
ctx.translate(256, 256);<br>
ctx.scale(1, -1);</p>
<p>const hillOpts = {roughness: 2.8, strokeWidth: 2, fill: &lsquo;blue&rsquo;};</p>
<p>rc.path(&lsquo;M-180 0L-80 100L20 0&rsquo;, hillOpts);<br>
rc.path(&lsquo;M-20 0L80 100L180 0&rsquo;, hillOpts);</p>
<p>rc.circle(0, 150, 105, {<br>
stroke: &lsquo;red&rsquo;,<br>
strokeWidth: 4,<br>
fill: &lsquo;rgba(255,255, 0, 0.4)&rsquo;,<br>
fillStyle: &lsquo;solid&rsquo;,<br>
});</p>
<p>好了，现在我们就完成了坐标变换。但是因为这个例子要绘制的图形很少，所以还不太能体现使用坐标系变换的好处。不过，你可以想一下，在可视化的许多应用场景中，我们都要处理成百上千的图形。如果这个时候，我们在原始坐标下通过计算顶点来绘制图形，计算量会非常大，很麻烦。那采用坐标变换的方式就是一个很好的优化思路，<strong>它能够简化计算量，这不仅让代码更容易理解，也可以节省 CPU 运算的时间</strong>。</p>
<p>理解直角坐标系的坐标变换之后，我们再来说说直角坐标系里绘制图形的方法。<strong>那不管我们用什么绘图系统绘制图形，一般的几何图形都是由点、线段和面构成。其中，点和线段是基础的图元信息，因此，如何描述它们是绘图的关键</strong>。</p>
<h2 id="如何用向量来描述点和线段">如何用向量来描述点和线段？</h2>
<p>那在直角坐标系下，我们是怎么表示<strong>点和线段的呢</strong>？我们一般是用向量来表示一个点或者一个线段。</p>
<p>前面的例子因为包含 x、y 两个坐标轴，所以它们构成了一个绘图的平面。因此，我们可以用二维向量来表示这个平面上的点和线段。二维向量其实就是一个包含了两个数值的数组，一个是 x 坐标值，一个是 y 坐标值。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/38805c64d0ddebe2bf4b80e7f97027a0.png" alt=""></p>
<p>假设，现在这个平面直角坐标系上有一个向量 v。向量 v 有两个含义：一是可以表示该坐标系下位于 (x, y) 处的一个点；二是可以表示从原点 (0,0) 到坐标 (x,y) 的一根线段。</p>
<p>接下来，为了方便你理解，我们先来回顾一下关于向量的数学知识。</p>
<p>**首先，向量和标量一样可以进行数学运算。**举个例子，现在有两个向量，v1和 v2，如果让它们相加，其结果相当于将 v1向量的终点（x1, y1），沿着 v2向量的方向移动一段距离，这段距离等于 v2向量的长度。这样，我们就可以在平面上得到一个新的点（x1 + x2, y1 + y2），一条新的线段 [(0, 0), (x1 + x2, y1 + y2)]，以及一段折线：[(0, 0), (x1, y1) , (x1 + x2, y1 + y2)]。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/50bc242ab8b93406dfcfe15c34669949.png" alt=""></p>
<p><strong>其次，一个向量包含有长度和方向信息</strong>。它的长度可以用向量的 x、y 的平方和的平方根来表示，如果用 JavaScript 来计算，就是：</p>
<p>v.length = function(){return Math.hypot(this.x, this.y)};</p>
<p>它的方向可以用与 x 轴的夹角来表示，即：</p>
<p>v.dir = function() { return Math.atan2(this.y, this.x);}</p>
<p>在上面的代码里，Math.atan2 的取值范围是 -π到π，负数表示在 x 轴下方，正数表示在 x 轴上方。</p>
<p>最后，根据长度和方向的定义，我们还能推导出一组关系式：</p>
<p>v.x = v.length * Math.cos(v.dir);<br>
v.y = v.length * Math.sin(v.dir);</p>
<p>这个推论意味着一个重要的事实：我们可以很简单地构造出一个绘图向量。也就是说，如果我们希望以点 (x0, y0) 为起点，沿着某个方向画一段长度为 length 的线段，我们只需要构造出如下的一个向量就可以了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/6c8c7eef202b1cf4e42811e92e9e2449.png" alt=""></p>
<p>这里的α是与 x 轴的夹角，v 是一个单位向量，它的长度为 1。然后我们把向量 (x0, y0) 与这个向量 v1相加，得到的就是这条线段的终点。这么讲还是比较抽象，我们看一个例子。</p>
<h2 id="实战演练用向量绘制一棵树">实战演练：用向量绘制一棵树</h2>
<p>我们用前面学到的向量知识来绘制一棵随机生成的树，想要生成的效果如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/fc140c79e605bf97c8a0052399b3be69.png" alt=""></p>
<p>我们还是用 Canvas2D 来绘制。首先是坐标变换，原理前面讲过，我就不细说了。这里，我们要做的变换是将坐标原点从左上角移动到左下角，并且让 y 轴翻转为向上。</p>
<p>ctx.translate(0, canvas.height);<br>
ctx.scale(1, -1);<br>
ctx.lineCap = &lsquo;round&rsquo;;</p>
<p>然后，我们定义一个画树枝的函数 drawBranch。</p>
<p>function drawBranch(context, v0, length, thickness, dir, bias) {<br>
&hellip;<br>
}</p>
<p>这个函数有六个参数：</p>
<ol>
<li>context 是我们的 Canvas2D 上下文</li>
<li>v0是起始向量</li>
<li>length 是当前树枝的长度</li>
<li>thickness 是当前树枝的粗细</li>
<li>dir 是当前树枝的方向，用与 x 轴的夹角表示，单位是弧度。</li>
<li>bias 是一个随机偏向因子，用来让树枝的朝向有一定的随机性</li>
</ol>
<p>因为 v0是树枝的起点坐标，那根据前面向量计算的原理，我们创建一个单位向量 (1, 0)，它是一个朝向 x 轴，长度为 1 的向量。然后我们旋转 dir 弧度，再乘以树枝长度 length。这样，我们就能计算出树枝的终点坐标了。代码如下：</p>
<p>const v = new Vector2D(1, 0).rotate(dir).scale(length);<br>
const v1 = v0.copy().add(v);</p>
<p>向量的旋转是向量的一种常见操作，对于二维空间来说，向量的旋转可以定义成如下方法（这里我们省略了数学推导过程，有兴趣的同学可以去看一下数学原理）。这个方法我们后面还会经常用到，你先记一下，后续我们讲到仿射变换的时候，会有更详细的解释。</p>
<p>class Vector2D {<br>
&hellip; <br>
rotate(rad) {<br>
const c = Math.cos(rad),<br>
s = Math.sin(rad);<br>
const [x, y] = this;</p>
<pre><code>this.x = x * c + y * -s;  
this.y = x * s + y * c;  

return this;  
</code></pre>
<p>}<br>
}</p>
<p>我们可以从一个起始角度开始递归地旋转树枝，每次将树枝分叉成左右两个分枝：</p>
<p>if(thickness &gt; 2) {<br>
const left = dir + 0.2;<br>
drawBranch(context, v1, length * 0.9, thickness * 0.8, left, bias * 0.9);<br>
const right = dir - 0.2;<br>
drawBranch(context, v1, length * 0.9, thickness * 0.8, right, bias * 0.9);<br>
}</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/a7aaa9c1b2ffe2e09e5aa00e6d78fef2.png" alt=""></p>
<p>这样，我们得到的就是一棵形状规律的树。</p>
<p>接着我们修改代码，加入随机因子，让迭代生成的新树枝有一个随机的偏转角度。</p>
<p>if(thickness &gt; 2) {<br>
const left = Math.PI / 4 + 0.5 * (dir + 0.2) + bias * (Math.random() - 0.5);<br>
drawBranch(context, v1, length * 0.9, thickness * 0.8, left, bias * 0.9);<br>
const right = Math.PI / 4 + 0.5 * (dir - 0.2) + bias * (Math.random() - 0.5);<br>
drawBranch(context, v1, length * 0.9, thickness * 0.8, right, bias * 0.9);<br>
}</p>
<p>这样，我们就可以得到一棵随机的树。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/f461900a0a8bfe6659e30854b3d86c45.png" alt=""></p>
<p>最后，为了美观，我们再随机绘制一些花瓣上去，你也可以尝试绘制其他的图案到这棵树上。</p>
<p>if(thickness &lt; 5 &amp;&amp; Math.random() &lt; 0.3) {<br>
context.save();<br>
context.strokeStyle = &lsquo;#c72c35&rsquo;;<br>
const th = Math.random() * 6 + 3;<br>
context.lineWidth = th;<br>
context.beginPath();<br>
context.moveTo(&hellip;v1);<br>
context.lineTo(v1.x, v1.y - 2);<br>
context.stroke();<br>
context.restore();<br>
}</p>
<p>这样，我们就实现了绘制一棵随机树的方法。</p>
<p>它的完整代码在GitHub 仓库，你可以研究一下。这里面最关键的一步就是前面的向量操作，为了实现向量的 rotate、scale、add 等方法，我封装了一个简单的库 Vector2d.js，你也可以在代码仓库中找到它。</p>
<h2 id="向量运算的意义">向量运算的意义</h2>
<p>实际上，在我们的可视化项目里，直接使用向量的加法、旋转和乘法来构造线段绘制图形的情形并不多。这是因为，在一般情况下，数据在传给前端的时候就已经计算好了，我们只需要拿到数据点的信息，根据坐标变换进行映射，然后直接用映射后的点来绘制图形即可。</p>
<p>既然这样，为什么我们在这里又要强调向量操作的重要性呢？虽然我们很少直接使用向量构造线段来完成绘图，但是向量运算的意义并不仅仅只是用来算点的位置和构造线段，这只是最初级的用法。我们要记住，<strong>可视化呈现依赖于计算机图形学，而向量运算是整个计算机图形学的数学基础。</strong></p>
<p>而且，在向量运算中，除了加法表示移动点和绘制线段外，向量的点乘、叉乘运算也有特殊的意义。课后我会给你出一道有挑战性的思考题，让你能更深入地理解向量运算的现实意义，在下一节课里我会给你答案。</p>
<h2 id="要点总结">要点总结</h2>
<p>这一节课，我们以 Canvas 为例学习了坐标变换，以及用向量描述点和线段的原理和方法。</p>
<p>一般来说，采用平面直角坐标系绘图的时候，对坐标进行平移等线性变换，并不会改变坐标系中图形的基本形状和相对位置，因此我们可以利用坐标变换让我们的绘图变得更加容易。Canvas 坐标变换经常会用到 translate 和 scale 这两个变换，它们的操作和原理都很简单，我们根据实际需求来设置就好了。</p>
<p>在平面直角坐标系中，我们可以定义向量来绘图。向量可以表示绘图空间中的一个点，或者连接原点的一条线段。两个向量相加，结果相当于将被加向量的终点沿着加数向量的方向移动一段距离，移动的距离等于加数向量的长度。利用向量的这个特性，我们就能以某个点为起点，朝任意方向绘制线段，从而绘制各种较复杂的几何图形了。</p>
<h2 id="小试牛刀">小试牛刀</h2>
<ol>
<li>我们已经知道如何用向量来定义一个线段，你知道如何判断两个线段的位置关系吗？假设有两个线段 l1和 l2，已知它们的起点和终点分别是 [(x10, y10),(x11, y11)]、[(x20, y20),(x21, y21)]，你能判断它们的关系吗（小提示：两个线段之间的关系有<strong>平行、垂直</strong>或既不平行又不垂直）？</li>
<li>已知线段 [(x0, y0)、(x1, y1)]，以及一个点 (x2, y2)，怎么求点到线段的距离？</li>
<li>一个平面上放置了一个扫描器，方向延 y 轴方向（该坐标系 y 轴向上），扫描器的视角是 60 度。假设它可以扫描到无限远的地方，那对于平面上给定的任意一个点 (x,y)，我们该如何判断这个点是否处于扫描范围内呢？</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/5a00ce18e822941658cc65e9b25b0a36.png" alt=""></p>
<p>欢迎在留言区和我讨论，分享你的答案和思考，也欢迎你把这节课分享给你的朋友，我们下节课见！</p>
<h2 id="源码">源码</h2>
<p>[1]绘制随机树的源代码</p>
<p>[2]坐标变换的源代码</p>
<h2 id="推荐阅读">推荐阅读</h2>
<p>[1] 二维旋转矩阵与向量旋转推荐文档</p>
<p>[2] 一个有趣的绘图库：Rough.js</p>
<p>[3] Vector2d.js 模块文档</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/">跟月影学可视化</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E5%AE%9E%E6%88%98%E8%AF%BE/05__%E5%A6%82%E4%BD%95%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E7%BA%B7%E7%B9%81%E6%9D%82%E4%B9%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%87%E6%A0%87/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">05__如何统一管理纷繁杂乱的数据指标？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E7%9D%80%E9%AB%98%E6%89%8B%E5%AD%A6%E5%A4%8D%E7%9B%98/05__%E4%B8%89%E8%A7%92%E6%B3%95%E6%80%8E%E4%B9%88%E7%BB%84%E5%BB%BA%E5%A4%8D%E7%9B%98%E5%9B%A2%E9%98%9F/">
            <span class="next-text nav-default">05__三角法：怎么组建复盘团队？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
