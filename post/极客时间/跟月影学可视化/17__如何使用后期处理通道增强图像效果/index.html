<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>17__如何使用后期处理通道增强图像效果？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是月影。
前面几节课，我们学习了利用向量和矩阵公式，来处理像素和生成纹理的技巧，但是这些技巧都有一定的局限性：每个像素是彼此独立的，不能共享信息。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/17__%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E9%80%9A%E9%81%93%E5%A2%9E%E5%BC%BA%E5%9B%BE%E5%83%8F%E6%95%88%E6%9E%9C/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/17__%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E9%80%9A%E9%81%93%E5%A2%9E%E5%BC%BA%E5%9B%BE%E5%83%8F%E6%95%88%E6%9E%9C/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="17__如何使用后期处理通道增强图像效果？">
  <meta property="og:description" content="你好，我是月影。
前面几节课，我们学习了利用向量和矩阵公式，来处理像素和生成纹理的技巧，但是这些技巧都有一定的局限性：每个像素是彼此独立的，不能共享信息。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="跟月影学可视化">

  <meta itemprop="name" content="17__如何使用后期处理通道增强图像效果？">
  <meta itemprop="description" content="你好，我是月影。
前面几节课，我们学习了利用向量和矩阵公式，来处理像素和生成纹理的技巧，但是这些技巧都有一定的局限性：每个像素是彼此独立的，不能共享信息。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5944">
  <meta itemprop="keywords" content="跟月影学可视化">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="17__如何使用后期处理通道增强图像效果？">
  <meta name="twitter:description" content="你好，我是月影。
前面几节课，我们学习了利用向量和矩阵公式，来处理像素和生成纹理的技巧，但是这些技巧都有一定的局限性：每个像素是彼此独立的，不能共享信息。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">17__如何使用后期处理通道增强图像效果？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5944 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#如何用后期处理通道实现-blur-滤镜">如何用后期处理通道实现 Blur 滤镜？</a></li>
        <li><a href="#如何用后期处理通道实现辉光效果">如何用后期处理通道实现辉光效果？</a></li>
        <li><a href="#如何用后期处理通道实现烟雾效果">如何用后期处理通道实现烟雾效果？</a></li>
        <li><a href="#要点总结">要点总结</a></li>
        <li><a href="#小试牛刀">小试牛刀</a></li>
        <li><a href="#源码">源码</a></li>
        <li><a href="#推荐阅读">推荐阅读</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是月影。</p>
<p>前面几节课，我们学习了利用向量和矩阵公式，来处理像素和生成纹理的技巧，但是这些技巧都有一定的局限性：每个像素是彼此独立的，不能共享信息。</p>
<p>为什么这么说呢？因为 GPU 是并行渲染的，所以在着色器的执行中，每个像素的着色都是同时进行的。这样一来，我们就不能获得某一个像素坐标周围坐标点的颜色信息，也不能获得要渲染图像的全局信息。</p>
<p>这会导致什么问题呢？如果我们要实现与周围像素点联动的效果，比如给生成的纹理添加平滑效果滤镜，就不能直接通过着色器的运算来实现了。</p>
<p>因此，在 WebGL 中，像这样不能直接通过着色器运算来实现的效果，我们需要使用其他的办法来实现，其中一种办法就是使用<strong>后期处理通道</strong>。所谓后期处理通道，是指将渲染出来的图像作为纹理输入给新着色器处理，是一种二次加工的手段。这么一来，虽然我们不能从当前渲染中获取周围的像素信息，却可以从纹理中获取任意 uv 坐标下的像素信息，也就相当于可以获取任意位置的像素信息了。</p>
<p>使用后期处理通道的一般过程是，我们先正常地将数据送入缓冲区，然后执行 WebGLProgram。只不过，在执行了 WebGLProgram 之后，我们要将输出的结果再作为纹理，送入另一个 WebGLProgram 进行处理，这个过程可以进行一次，也可以循环多次。最后，经过两次 WebGLProgram 处理之后，我们再输出结果。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/3aa668919fd4156d931c1b9254b878ce.png" alt=""></p>
<p>后期通道处理的一般过程示意图</p>
<p>你可以先仔细看看这张流程总结图，加深一下印象。接下来，我会结合这个过程，说说怎么用后期处理通道，来实现 Blur 滤镜、辉光效果和烟雾效果，这样你就能理解得更深刻了。</p>
<p>首先，我们来实现 Blur 滤镜。</p>
<h2 id="如何用后期处理通道实现-blur-滤镜">如何用后期处理通道实现 Blur 滤镜？</h2>
<p>其实在第 11 节课中，我们已经在 Canvas2D 中实现了 Bblur 滤镜（高斯模糊的平滑效果滤镜），但 Canvas2D 实现滤镜的性能不佳，尤其是在图片较大，需要大量计算的时候。</p>
<p>而在 WebGL 中，我们可以通过后期处理来实现高性能的 Blur 滤镜。下面，我就以给随机三角形图案加 Blur 滤镜为例，来说说具体的操作。</p>
<p>首先，我们实现一个绘制随机三角形图案的着色器。代码如下：</p>
<p>#ifdef GL_ES<br>
precision highp float;<br>
#endif</p>
<p>float line_distance(in vec2 st, in vec2 a, in vec2 b) {<br>
vec3 ab = vec3(b - a, 0);<br>
vec3 p = vec3(st - a, 0);<br>
float l = length(ab);<br>
return cross(p, normalize(ab)).z;<br>
}</p>
<p>float seg_distance(in vec2 st, in vec2 a, in vec2 b) {<br>
vec3 ab = vec3(b - a, 0);<br>
vec3 p = vec3(st - a, 0);<br>
float l = length(ab);<br>
float d = abs(cross(p, normalize(ab)).z);<br>
float proj = dot(p, ab) / l;<br>
if(proj &gt;= 0.0 &amp;&amp; proj &lt;= l) return d;<br>
return min(distance(st, a), distance(st, b));<br>
}</p>
<p>float triangle_distance(in vec2 st, in vec2 a, in vec2 b, in vec2 c) {<br>
float d1 = line_distance(st, a, b);<br>
float d2 = line_distance(st, b, c);<br>
float d3 = line_distance(st, c, a);</p>
<p>if(d1 &gt;= 0.0 &amp;&amp; d2 &gt;= 0.0 &amp;&amp; d3 &gt;= 0.0 || d1 &lt;= 0.0 &amp;&amp; d2 &lt;= 0.0 &amp;&amp; d3 &lt;= 0.0) {<br>
return -min(abs(d1), min(abs(d2), abs(d3))); // 内部距离为负<br>
}</p>
<p>return min(seg_distance(st, a, b), min(seg_distance(st, b, c), seg_distance(st, c, a))); // 外部为正<br>
}</p>
<p>float random (vec2 st) {<br>
return fract(sin(dot(st.xy,<br>
vec2(12.9898,78.233)))*<br>
43758.5453123);<br>
}</p>
<p>vec3 hsb2rgb(vec3 c){<br>
vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0);<br>
rgb = rgb * rgb * (3.0 - 2.0 * rgb);<br>
return c.z * mix(vec3(1.0), rgb, c.y);<br>
}</p>
<p>varying vec2 vUv;</p>
<p>void main() {<br>
vec2 st = vUv;<br>
st *= 10.0;<br>
vec2 i_st = floor(st);<br>
vec2 f_st = 2.0 * fract(st) - vec2(1);<br>
float r = random(i_st);<br>
float sign = 2.0 * step(0.5, r) - 1.0;</p>
<p>float d = triangle_distance(f_st, vec2(-1), vec2(1), sign * vec2(1, -1));<br>
gl_FragColor.rgb = (smoothstep(-0.85, -0.8, d) - smoothstep(0.0, 0.05, d)) * hsb2rgb(vec3(r + 1.2, 0.5, r));<br>
gl_FragColor.a = 1.0;<br>
}</p>
<p>这个着色器绘制出的效果如下图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/4cc1deb05838db02988f400199c54e33.png" alt=""></p>
<p>接着就是重点了，我们要使用后期处理通道对它进行高斯模糊。</p>
<p>首先，我们需要准备另一个着色器：blurFragment。通过它，我们能将第一次渲染后生成的纹理 tMap 内容给显示出来。</p>
<p>#ifdef GL_ES<br>
precision highp float;<br>
#endif</p>
<p>varying vec2 vUv;<br>
uniform sampler2D tMap;</p>
<p>void main() {<br>
vec4 color = texture2D(tMap, vUv);<br>
gl_FragColor.rgb = color.rgb;<br>
gl_FragColor.a = color.a;<br>
}</p>
<p>然后，我们要修改 JavaScript 代码，把渲染分为两次。第一次渲染时，我们启用 program 程序，但不直接把图形输出到画布上，而是输出到一个帧缓冲对象（Frame Buffer Object）上。第二次渲染时，我们再启用 blurProgram 程序，将第一次渲染完成的纹理（fbo.texture）作为 blurFragment 的 tMap 变量，这次的输出绘制到画布上。代码如下：</p>
<p>&hellip;</p>
<p>renderer.useProgram(program);</p>
<p>renderer.setMeshData([{<br>
positions: [<br>
[-1, -1],<br>
[-1, 1],<br>
[1, 1],<br>
[1, -1],<br>
],<br>
attributes: {<br>
uv: [<br>
[0, 0],<br>
[0, 1],<br>
[1, 1],<br>
[1, 0],<br>
],<br>
},<br>
cells: [[0, 1, 2], [2, 0, 3]],<br>
}]);</p>
<p>const fbo = renderer.createFBO();<br>
renderer.bindFBO(fbo);<br>
renderer.render();<br>
renderer.bindFBO(null);</p>
<p>const blurProgram = renderer.compileSync(blurFragment, vertex);<br>
renderer.useProgram(blurProgram);<br>
renderer.setMeshData(program.meshData);<br>
renderer.uniforms.tMap = fbo.texture;<br>
renderer.render();</p>
<p>其中，renderer.createFBO 是创建帧缓冲对象，bindFBO 是绑定帧缓冲对象。为了方便调用，我在这里通过 gl-renderer 做了一层简单的封装。</p>
<p>那经过两次渲染之后，我们运行程序输出的结果和之前输出的并不会有什么区别。因为第二次渲染只不过是将第一次渲染到帧缓冲的结果原封不动地输出到画布上了。</p>
<p>接下来，我们修改 blurFragment 的代码，在其中添加高斯模糊的代码。代码如下：</p>
<p>#ifdef GL_ES<br>
precision highp float;<br>
#endif</p>
<p>varying vec2 vUv;<br>
uniform sampler2D tMap;<br>
uniform int axis;</p>
<p>void main() {<br>
vec4 color = texture2D(tMap, vUv);</p>
<p>// 高斯矩阵的权重值<br>
float weight[5];<br>
weight[0] = 0.227027;<br>
weight[1] = 0.1945946;<br>
weight[2] = 0.1216216;<br>
weight[3] = 0.054054;<br>
weight[4] = 0.016216;</p>
<p>// 每一个相邻像素的坐标间隔，这里的 512 可以用实际的 Canvas 像素宽代替<br>
float tex_offset = 1.0 / 512.0;</p>
<p>vec3 result = color.rgb;<br>
result *= weight[0];<br>
for(int i = 1; i &lt; 5; ++i) {<br>
float f = float(i);<br>
if(axis == 0) { // x 轴的高斯模糊<br>
result += texture2D(tMap, vUv + vec2(tex_offset * f, 0.0)).rgb * weight[i];<br>
result += texture2D(tMap, vUv - vec2(tex_offset * f, 0.0)).rgb * weight[i];<br>
} else { // y 轴的高斯模糊<br>
result += texture2D(tMap, vUv + vec2(0.0, tex_offset * f)).rgb * weight[i];<br>
result += texture2D(tMap, vUv - vec2(0.0, tex_offset * f)).rgb * weight[i];<br>
}<br>
}</p>
<p>gl_FragColor.rgb = result.rgb;<br>
gl_FragColor.a = color.a;<br>
}</p>
<p>因为高斯模糊有两个方向，x 和 y 方向，所以我们至少要执行两次渲染，一次对 x 轴，另一次对 y 轴。如果想要达到更好的效果，我们还可以执行多次渲染。</p>
<p>那我们就以分别对 x 轴和 y 轴执行 2 次渲染为例，修改后的 JavaScript 代码如下：</p>
<p>// 创建两个 FBO 对象交替使用<br>
const fbo1 = renderer.createFBO();<br>
const fbo2 = renderer.createFBO();</p>
<p>// 第一次，渲染原始图形<br>
renderer.bindFBO(fbo1);<br>
renderer.render();</p>
<p>// 第二次，对 x 轴高斯模糊<br>
renderer.useProgram(blurProgram);<br>
renderer.setMeshData(program.meshData);<br>
renderer.bindFBO(fbo2);<br>
renderer.uniforms.tMap = fbo1.texture;<br>
renderer.uniforms.axis = 0;<br>
renderer.render();</p>
<p>// 第三次，对 y 轴高斯模糊<br>
renderer.useProgram(blurProgram);<br>
renderer.bindFBO(fbo1);<br>
renderer.uniforms.tMap = fbo2.texture;<br>
renderer.uniforms.axis = 1;<br>
renderer.render();</p>
<p>// 第四次，对 x 轴高斯模糊<br>
renderer.useProgram(blurProgram);<br>
renderer.bindFBO(fbo2);<br>
renderer.uniforms.tMap = fbo1.texture;<br>
renderer.uniforms.axis = 0;<br>
renderer.render();</p>
<p>// 第五次，对 y 轴高斯模糊<br>
renderer.useProgram(blurProgram);<br>
renderer.bindFBO(null);<br>
renderer.uniforms.tMap = fbo2.texture;<br>
renderer.uniforms.axis = 1;<br>
renderer.render();</p>
<p>在上面的代码中，我们创建了两个 FBO 对象，然后将它们交替使用。我们一共进行 5 次绘制，先对原始图片执行 1 次渲染，再进行 4 次后期处理。</p>
<p>这里啊，我还要告诉你一个小技巧。本来啊，在执行的这 5 次绘制中，前四次都是输出到帧缓冲对象，所以我们至少需要 4 个 FBO 对象。但是，由于我们可以交替使用 FBO 对象，也就是可以把用过的对象重复使用。因此，无论需要绘制多少次，我们都只要创建两个对象就可以，也就节约了内存。</p>
<p>最终，我们就能通过后期处理通道实现 Blur 滤镜，给三角形图案加上模糊的效果了。渲染结果如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/04dd27b89144f66906f06492a463768e.png" alt=""></p>
<h2 id="如何用后期处理通道实现辉光效果">如何用后期处理通道实现辉光效果？</h2>
<p>在上面这个例子中，我们是对所有元素进行高斯模糊的。那除此之外，我们还可以对特定元素进行高斯模糊。在可视化和游戏开发中，就常用这种技巧来实现元素的“辉光”效果。比如，下面这张图就是用辉光效果实现的浩瀚宇宙背景。</p>
<p><a href="https://zhuanlan.zhihu.com/p/44131797"><img src="./f1572b5475021bfb7c36b199143cc3e8.png.md" alt=""></a></p>
<p>全局辉光效果（图片来源于知乎：H 光大小姐）</p>
<p>那类似这样的辉光效果该怎么实现呢？我们可以在前面添加高斯模糊例子的基础上进行修改。首先，我们给 blurFragment 加了一个关于亮度的滤镜，将颜色亮度大于 filter 值的三角形过滤出来添加高斯模糊。修改后的代码如下。</p>
<p>uniform float filter;</p>
<p>void main() {<br>
vec4 color = texture2D(tMap, vUv);<br>
float brightness = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));<br>
brightness = step(filter, brightness);</p>
<p>// 高斯矩阵的权重值<br>
float weight[5];<br>
weight[0] = 0.227027;<br>
weight[1] = 0.1945946;<br>
weight[2] = 0.1216216;<br>
weight[3] = 0.054054;<br>
weight[4] = 0.016216;</p>
<p>// 每一个相邻像素的坐标间隔，这里的 512 可以用实际的 Canvas 像素宽代替<br>
float tex_offset = 1.0 / 512.0;</p>
<p>vec3 result = color.rgb;<br>
result *= weight[0];<br>
for(int i = 1; i &lt; 5; ++i) {<br>
float f = float(i);<br>
if(axis == 0) { // x 轴的高斯模糊<br>
result += texture2D(tMap, vUv + vec2(tex_offset * f, 0.0)).rgb * weight[i];<br>
result += texture2D(tMap, vUv - vec2(tex_offset * f, 0.0)).rgb * weight[i];<br>
} else { // y 轴的高斯模糊<br>
result += texture2D(tMap, vUv + vec2(0.0, tex_offset * f)).rgb * weight[i];<br>
result += texture2D(tMap, vUv - vec2(0.0, tex_offset * f)).rgb * weight[i];<br>
}<br>
}</p>
<p>gl_FragColor.rgb = brightness * result.rgb;<br>
gl_FragColor.a = color.a;<br>
}</p>
<p>然后，我们再增加一个 bloomFragment 着色器，用来做最后的效果混合。这里，我们会用到一个叫做<strong>Tone Mapping</strong>（色调映射）的方法。这个方法就比较复杂了，在这里，你只要知道它可以将对比度过大的图像色调映射到合理的范围内就可以了，其他的内容你可以在课后看一下我给出的参考链接。</p>
<p>这个着色器的代码如下：</p>
<p>#ifdef GL_ES<br>
precision highp float;<br>
#endif</p>
<p>uniform sampler2D tMap;<br>
uniform sampler2D tSource;</p>
<p>varying vec2 vUv;</p>
<p>void main() {<br>
vec3 color = texture2D(tSource, vUv).rgb;<br>
vec3 bloomColor = texture2D(tMap, vUv).rgb;<br>
color += bloomColor;<br>
// tone mapping<br>
float exposure = 2.0;<br>
float gamma = 1.3;<br>
vec3 result = vec3(1.0) - exp(-color * exposure);<br>
// also gamma correct while we&rsquo;re at it<br>
if(length(bloomColor) &gt; 0.0) {<br>
result = pow(result, vec3(1.0 / gamma));<br>
}<br>
gl_FragColor.rgb = result;<br>
gl_FragColor.a = 1.0;<br>
}</p>
<p>最后，我们修改 JavaScript 渲染的逻辑，添加新的后期处理规则。这里，我们要使用三个 FBO 对象，因为第一个 FBO 对象在渲染原始图形之后，还要在混合效果时使用，后两个对象是用来交替使用完成高斯模糊的。最后，我们再将原始图形和高斯模糊的结果进行效果混合就可以了。修改后的代码如下：</p>
<p>// 创建三个 FBO 对象，fbo1 和 fbo2 交替使用<br>
const fbo0 = renderer.createFBO();<br>
const fbo1 = renderer.createFBO();<br>
const fbo2 = renderer.createFBO();</p>
<p>// 第一次，渲染原始图形<br>
renderer.bindFBO(fbo0);<br>
renderer.render();</p>
<p>// 第二次，对 x 轴高斯模糊<br>
renderer.useProgram(blurProgram);<br>
renderer.setMeshData(program.meshData);<br>
renderer.bindFBO(fbo2);<br>
renderer.uniforms.tMap = fbo0.texture;<br>
renderer.uniforms.axis = 0;<br>
renderer.uniforms.filter = 0.7;<br>
renderer.render();</p>
<p>// 第三次，对 y 轴高斯模糊<br>
renderer.useProgram(blurProgram);<br>
renderer.bindFBO(fbo1);<br>
renderer.uniforms.tMap = fbo2.texture;<br>
renderer.uniforms.axis = 1;<br>
renderer.uniforms.filter = 0;<br>
renderer.render();</p>
<p>// 第四次，对 x 轴高斯模糊<br>
renderer.useProgram(blurProgram);<br>
renderer.bindFBO(fbo2);<br>
renderer.uniforms.tMap = .texture;<br>
renderer.uniforms.axis = 0;<br>
renderer.uniforms.filter = 0;<br>
renderer.render();</p>
<p>// 第五次，对 y 轴高斯模糊<br>
renderer.useProgram(blurProgram);<br>
renderer.bindFBO(fbo1);<br>
renderer.uniforms.tMap = fbo2.texture;<br>
renderer.uniforms.axis = 1;<br>
renderer.uniforms.filter = 0;<br>
renderer.render();</p>
<p>// 第六次，叠加辉光<br>
renderer.useProgram(bloomProgram);<br>
renderer.setMeshData(program.meshData);<br>
renderer.bindFBO(null);<br>
renderer.uniforms.tSource = fbo0.texture;<br>
renderer.uniforms.tMap = fbo1.texture;<br>
renderer.uniforms.axis = 1;<br>
renderer.uniforms.filter = 0;<br>
renderer.render();</p>
<p>这样渲染之后，我就能让三角形图案中几个比较亮的三角形，产生一种微微发光的效果。渲染效果如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/0dff5a1b1d82ec7a9afabba28f0ecafb.png" alt=""></p>
<p>局部辉光效果示意图</p>
<p>这样，我们就实现了最终的局部辉光效果。实现它的关键，就是在高斯模糊原理的基础上，将局部高斯模糊的图像与原始图像叠加。</p>
<h2 id="如何用后期处理通道实现烟雾效果">如何用后期处理通道实现烟雾效果？</h2>
<p>除了模糊和辉光效果之外，后期处理通道还经常用来实现烟雾效果。接下来，我们就实现一个小圆的烟雾效果。具体的实现过程主要分为两步：第一步和前面两个例子一样，我们通过创建一个 shader，画出一个简单的圆。第二步，我们对这个圆进行后期处理，不过这次的处理方法就和实现辉光不同了。</p>
<p>下面，我们就一起来看。</p>
<p>首先，我们创建一个简单的 shader，也就是使用距离场在画布上画一个圆。这个 shader 我们非常熟悉，具体的代码如下：</p>
<p>#ifdef GL_ES<br>
precision highp float;<br>
#endif</p>
<p>varying vec2 vUv;</p>
<p>void main() {<br>
vec2 st = vUv - vec2(0.5);<br>
float d = length(st);<br>
gl_FragColor.rgb = vec3(1.0 - smoothstep(0.05, 0.055, d));<br>
gl_FragColor.a = 1.0;<br>
}</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/14677868686c5e3d035fdf749a6f9466.png" alt=""></p>
<p>接着，我们修改一下 shader 代码，增加 uTime、tMap 这两个变量，代码如下所示。其中，uTime 用来控制图像随时间变化，而 tMap 是我们用来做后期处理的变量。</p>
<p>#ifdef GL_ES<br>
precision highp float;<br>
#endif</p>
<p>varying vec2 vUv;<br>
uniform sampler2D tMap;<br>
uniform float uTime;</p>
<p>void main() {<br>
vec3 smoke = vec3(0);<br>
if(uTime &lt;= 0.0) {<br>
vec2 st = vUv - vec2(0.5);<br>
float d = length(st);<br>
smoke = vec3(1.0 - smoothstep(0.05, 0.055, d));<br>
}<br>
vec3 diffuse = texture2D(tMap, vUv).rgb;<br>
gl_FragColor.rgb = diffuse + smoke;<br>
gl_FragColor.a = 1.0;<br>
}</p>
<p>然后，我们依然创建两个 FBO，用它们交替进行绘制。最后，我们把绘制的内容输出到画布上。这里，我使用了一个 if 语句，根据绘制过程判断初始绘制还是后续的叠加过程，就能把着色器合并成一个。这样一来，不管是输出到画布还是 FBO，我们使用同一个 program 就可以了。</p>
<p>const fbo = {<br>
readFBO: renderer.createFBO(),<br>
writeFBO: renderer.createFBO(),<br>
get texture() {<br>
return this.readFBO.texture;<br>
},<br>
swap() {<br>
const tmp = this.writeFBO;<br>
this.writeFBO = this.readFBO;<br>
this.readFBO = tmp;<br>
},<br>
};</p>
<p>function update(t) {<br>
// 输出到画布<br>
renderer.bindFBO(null);<br>
renderer.uniforms.uTime = t / 1000;<br>
renderer.uniforms.tMap = fbo.texture;<br>
renderer.render();<br>
// 同时输出到 FBO<br>
renderer.bindFBO(fbo.writeFBO);<br>
renderer.uniforms.tMap = fbo.texture;<br>
// 交换读写缓冲以便下一次写入<br>
fbo.swap();<br>
renderer.render();<br>
requestAnimationFrame(update);<br>
}<br>
update(0);</p>
<p>你会发现，上面的代码执行以后输出的画面并没有什么变化。这是为什么呢？因为我们第一次渲染时，也就是当 uTime 为 0 的时候，我们直接画了一个圆。而当我们从上一次绘制的纹理中获取信息，重新渲染时，因为每次获取的纹理图案都是不变的，所以现在的画面依然是静止的圆。</p>
<p>如果我们想让这个图动起来，比如说让它向上升，那么我们只要在每次绘制的时候，改变一下采样的 y 坐标，就是每次从 tMap 取样时取当前纹理坐标稍微下方一点的像素点就可以了。具体的操作代码如下：</p>
<p>void main() {<br>
vec3 smoke = vec3(0);<br>
if(uTime &lt;= 0.0) {<br>
vec2 st = vUv - vec2(0.5);<br>
float d = length(st);<br>
smoke = vec3(1.0 - smoothstep(0.05, 0.055, d));<br>
}<br>
vec2 st = vUv;<br>
st.y -= 0.001;<br>
vec3 diffuse = texture2D(tMap, st).rgb;<br>
gl_FragColor.rgb = diffuse + smoke;<br>
gl_FragColor.a = 1.0;<br>
}</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/0eb94e7f34366abc7fcd9bc883982355.png" alt=""></p>
<p>不过，由于纹理采样精度的问题，我们得到的上升圆还会有一个扩散的效果。不过这没有关系，它不影响我们接下来要实现的烟雾效果。</p>
<p>接下来，我们需要构建一个烟雾的扩散模型，也就是以某个像素位置以及周边像素的纹理颜色来计算新的颜色值。为了方便你理解，我就以一个 5*5 的画布为例来详细说说。假设，这个画布只有中心五个位置的颜色是纯白（1.0），周围都是黑色，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/c0d4d545d3addefb73f7660f9f9114e6.png" alt=""></p>
<p>在这个扩散模型中，每个格子到下一时刻的颜色变化量，等于它周围四个格子的颜色值之和减去它自身颜色值的 4 倍，乘以扩散系数。</p>
<p>假设扩散系数是常量 0.1，那么第一轮每一格的颜色值我在表格上标出来了，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/215ef881adac7f8008195073a841fe1e.png" alt=""></p>
<p>可以看到，上图中有三种颜色的格子，分别是红色、蓝色和绿色。下面，我们直接来看颜色值的计算过程。</p>
<p>首先是中间红色的那个格子。因为它四周的格子颜色都是 1.0，所以它的颜色变化量是：0.1 * ((1.0 + 1.0 + 1.0 + 1.0) - 4 * 1.0) = 0，那么下一帧的颜色值还是 1.0 不变。</p>
<p>其次，红格子周围的四个蓝色格子。它们下一帧的颜色变化量为：0.1 * ((1.0 + 0 + 0 + 0)- 4 * 1.0) = -0.3，那么它们下一帧的颜色值都要减去 0.3 就是 0.7。</p>
<p>最后，在计算绿色格子下一帧的颜色值时，要分为两种情况。</p>
<p>第一种，当要计算的绿色格子和两个蓝色格子相邻的时候，颜色变化量为：0.1 * ((1.0 + 1.0 + 0 + 0) - 4 * 0) = 0.2，所以绿格子下一帧的颜色值变为 0.2。</p>
<p>第二种，当这个绿色格子只和一个蓝色格子相邻的时候，颜色变化量为 0.1，那么绿格子下一帧的颜色值就变为 0.1。</p>
<p>就这样，我们把每一帧颜色按照这个规则不断迭代下去，就能得到一个烟雾扩散效果了。那我们下一步就是把它实现到 Shader 中，不过，在 Fragment Shader 中添加扩散模型的时候，为了让这个烟雾效果，能上升得更明显，我稍稍修改了一下扩散公式的权重，让它向上的幅度比较大。</p>
<p>#ifdef GL_ES<br>
precision highp float;<br>
#endif</p>
<p>varying vec2 vUv;<br>
uniform sampler2D tMap;<br>
uniform float uTime;</p>
<p>void main() {<br>
vec3 smoke = vec3(0);<br>
if(uTime &lt;= 0.0) {<br>
vec2 st = vUv - vec2(0.5);<br>
float d = length(st);<br>
smoke = vec3(step(d, 0.05));<br>
// smoke = vec3(1.0 - smoothstep(0.05, 0.055, d));<br>
}</p>
<p>vec2 st = vUv;</p>
<p>float offset = 1.0 / 256.0;<br>
vec3 diffuse = texture2D(tMap, st).rgb;</p>
<p>vec4 left = texture2D(tMap, st + vec2(-offset, 0.0));<br>
vec4 right = texture2D(tMap, st + vec2(offset, 0.0));<br>
vec4 up = texture2D(tMap, st + vec2(0.0, -offset));<br>
vec4 down = texture2D(tMap, st + vec2(0.0, offset));</p>
<p>float diff = 8.0 * 0.016 * (<br>
left.r +<br>
right.r +<br>
down.r +<br>
2.0 * up.r -<br>
5.0 * diffuse.r<br>
);</p>
<p>gl_FragColor.rgb = (diffuse + diff) + smoke;<br>
gl_FragColor.a = 1.0;<br>
}</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/658fa29432ea0fb56623d9d69c63a906.png" alt=""></p>
<p>你会发现，这个效果还不是特别真实。那为了达到更真实的烟雾效果，我们还可以在扩散函数上增加一些噪声，代码如下：</p>
<p>void main() {<br>
vec3 smoke = vec3(0);<br>
if(uTime &lt;= 0.0) {<br>
vec2 st = vUv - vec2(0.5);<br>
float d = length(st);<br>
smoke = vec3(step(d, 0.05));<br>
// smoke = vec3(1.0 - smoothstep(0.05, 0.055, d));<br>
}</p>
<p>vec2 st = vUv;</p>
<p>float offset = 1.0 / 256.0;<br>
vec3 diffuse = texture2D(tMap, st).rgb;</p>
<p>vec4 left = texture2D(tMap, st + vec2(-offset, 0.0));<br>
vec4 right = texture2D(tMap, st + vec2(offset, 0.0));<br>
vec4 up = texture2D(tMap, st + vec2(0.0, -offset));<br>
vec4 down = texture2D(tMap, st + vec2(0.0, offset));</p>
<p>float rand = noise(st + 5.0 * uTime);<br>
float diff = 8.0 * 0.016 * (<br>
(1.0 + rand) * left.r +<br>
(1.0 - rand) * right.r +<br>
down.r +<br>
2.0 * up.r -<br>
5.0 * diffuse.r<br>
);</p>
<p>gl_FragColor.rgb = (diffuse + diff) + smoke;<br>
gl_FragColor.a = 1.0;<br>
}</p>
<p>这样，我们最终实现的效果看起来就会更真实一些：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/860d4889ee498e72353a61c003b91a5f.png" alt=""></p>
<h2 id="要点总结">要点总结</h2>
<p>今天，我们学习了怎么在 WebGL 中，使用后期处理通道来增强图像的视觉效果。我们讲了两个比较常用的效果，一个是 Blur 滤镜以及基于它实现辉光效果，另一个是烟雾效果。</p>
<p>那后期处理通道实现这些效果的核心原理其实都是一样的，都是把第一次渲染后的内容输出到帧缓冲对象 FBO 中，然后把这个对象的内容作为纹理图片，再进行下一次渲染，这个渲染的过程可以重复若干次。最后，我们再把结果输出到屏幕上，就可以了。</p>
<p>到这里，视觉基础篇的内容，我们就全部讲完了。在这个模块里，我们围绕处理图像的细节，系统地学习了怎么表示颜色，怎么生成重复图案，怎么构造和使用滤镜处理图像，怎么进行纹理造型，还有怎么使用不同的坐标系绘图，怎么使用噪声和网格噪声生成复杂纹理、以及今天学习的怎么使用后期处理通道增强图像。我把核心的内容总结成了一张脑图，你可以借助它，来复习巩固这一模块的内容，查缺补漏。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/699b5f9e66f729c922b3d90f854b85f5.png" alt=""></p>
<h2 id="小试牛刀">小试牛刀</h2>
<p>第一题，今天，我们实现的烟雾扩散效果还不够完善，也不够有趣，你能试着改进它，让它变得更有趣吗？你可以参考我给出的两个建议，也可以试试其他的效果。</p>
<p>1. 给定一个向量，表示风向和风速，让烟雾随着这个风扩散，这个风可以随着时间慢慢变化（你可以使用前面学过的噪声来实现风的变化），看看能够做出什么效果。</p>
<p>2. 尝试让烟雾跟随着鼠标移动轨迹扩散，达到类似下面的效果。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/2e721e0d437deac4b731e12283f9af27.png" alt=""></p>
<p>如果你觉得难以实现，这里有一篇文章详细讲了烟雾生成的方法，你可以仔细研究一下。</p>
<p>第二题，实际上，后期处理通道可不止是实现 Blur 滤镜、辉光或者烟雾效果那么简单，它还可以实现很多不同的功能。比如，SpriteJS 官网上那种类似于探照灯的效果，就是用后期处理通道实现的。你可以用 gl-renderer 来实现这类效果吗？</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/a0245b142efe8fd44ea34a7bc0a8b0b5.png" alt=""></p>
<p>欢迎在留言区和我讨论，分享你的答案和思考，也欢迎你把这节课分享给你的朋友，我们下节课再见！</p>
<h2 id="源码">源码</h2>
<p>完整的示例代码见GitHub 仓库</p>
<h2 id="推荐阅读">推荐阅读</h2>
<p>[1] 原始 FBO 对象的创建和使用方法</p>
<p>[2] How to Write a Smoke Shader</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/">跟月影学可视化</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/webassembly%E5%85%A5%E9%97%A8%E8%AF%BE/17__%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_webassembly_%E5%9C%A8%E7%BA%BF%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E5%BA%94%E7%94%A8%E4%B8%89/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">17__如何实现一个_WebAssembly_在线多媒体处理应用（三）？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E5%AE%9E%E6%88%98%E8%AF%BE/17__%E5%A6%82%E4%BD%95%E6%8F%90%E7%82%BC%E5%B9%B6%E5%85%91%E7%8E%B0%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%94%9F%E6%B4%BB%E4%B8%BB%E5%BC%A0/">
            <span class="next-text nav-default">17__如何提炼并兑现服务设计的生活主张？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
