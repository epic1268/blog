<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>21__如何添加相机，用透视原理对物体进行投影？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是月影。
上节课，我们在绘制 3D 几何体的时候，实际上有一个假设，那就是观察者始终从三维空间坐标系的正面，也就是 z 轴正方向，看向坐标原点。但在真实世界的模型里，观察者可以处在任何一个位置上。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/21__%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E7%9B%B8%E6%9C%BA%E7%94%A8%E9%80%8F%E8%A7%86%E5%8E%9F%E7%90%86%E5%AF%B9%E7%89%A9%E4%BD%93%E8%BF%9B%E8%A1%8C%E6%8A%95%E5%BD%B1/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/21__%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E7%9B%B8%E6%9C%BA%E7%94%A8%E9%80%8F%E8%A7%86%E5%8E%9F%E7%90%86%E5%AF%B9%E7%89%A9%E4%BD%93%E8%BF%9B%E8%A1%8C%E6%8A%95%E5%BD%B1/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="21__如何添加相机，用透视原理对物体进行投影？">
  <meta property="og:description" content="你好，我是月影。
上节课，我们在绘制 3D 几何体的时候，实际上有一个假设，那就是观察者始终从三维空间坐标系的正面，也就是 z 轴正方向，看向坐标原点。但在真实世界的模型里，观察者可以处在任何一个位置上。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="跟月影学可视化">

  <meta itemprop="name" content="21__如何添加相机，用透视原理对物体进行投影？">
  <meta itemprop="description" content="你好，我是月影。
上节课，我们在绘制 3D 几何体的时候，实际上有一个假设，那就是观察者始终从三维空间坐标系的正面，也就是 z 轴正方向，看向坐标原点。但在真实世界的模型里，观察者可以处在任何一个位置上。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4205">
  <meta itemprop="keywords" content="跟月影学可视化">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="21__如何添加相机，用透视原理对物体进行投影？">
  <meta name="twitter:description" content="你好，我是月影。
上节课，我们在绘制 3D 几何体的时候，实际上有一个假设，那就是观察者始终从三维空间坐标系的正面，也就是 z 轴正方向，看向坐标原点。但在真实世界的模型里，观察者可以处在任何一个位置上。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">21__如何添加相机，用透视原理对物体进行投影？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4205 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#如何理解相机和视图矩阵">如何理解相机和视图矩阵？</a></li>
        <li><a href="#剪裁空间和投影对-3d-图像的影响">剪裁空间和投影对 3D 图像的影响</a></li>
        <li><a href="#3d-绘图标准模型">3D 绘图标准模型</a></li>
        <li><a href="#如何使用-ogl-绘制基本的几何体">如何使用 OGL 绘制基本的几何体</a></li>
        <li><a href="#要点总结">要点总结</a></li>
        <li><a href="#小试牛刀">小试牛刀</a></li>
        <li><a href="#源码">源码</a></li>
        <li><a href="#推荐阅读">推荐阅读</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是月影。</p>
<p>上节课，我们在绘制 3D 几何体的时候，实际上有一个假设，那就是观察者始终从三维空间坐标系的正面，也就是 z 轴正方向，看向坐标原点。但在真实世界的模型里，观察者可以处在任何一个位置上。</p>
<p>那今天，我们就在上节课的基础上，引入一个空间观察者的角色，或者说是相机（Camera），来总结一个更通用的绘图模型。这样，我们就能绘制出，从三维空间中任意一个位置观察物体的效果了。</p>
<p>首先，我们来说说什么是相机。</p>
<h2 id="如何理解相机和视图矩阵">如何理解相机和视图矩阵？</h2>
<p>我们现在假设，在 WebGL 的三维世界任意位置上有一个相机，它可以用一个三维坐标（Position）和一个三维向量方向（LookAt Target）来表示。</p>
<p>在初始情况下，相机的参考坐标和世界坐标是重合的。但是，当我们移动或者旋转相机的时候，相机的参考坐标和世界坐标就不重合了。</p>
<p>而我们最终要在 Canvas 画布上绘制出的是，以相机为观察者的图形，所以我们就需要用一个变换，将世界坐标转换为相机坐标。这个变换的矩阵就是<strong>视图矩阵</strong>（ViewMatrix）。</p>
<p>计算视图矩阵比较简单的一种方法是，我们先计算相机的模型矩阵，然后对矩阵使用 lookAt 函数，这样我们得到的矩阵就是视图矩阵的逆矩阵。然后，我们再对这个逆矩阵求一次逆，就可以得到视图矩阵了。</p>
<p>这么说还是有点比较抽象，我们通过代码来理解。</p>
<p>function updateCamera(eye, target = [0, 0, 0]) {<br>
const [x, y, z] = eye;<br>
const m = new Mat4(<br>
1, 0, 0, 0,<br>
0, 1, 0, 0,<br>
0, 0, 1, 0,<br>
x, y, z, 1,<br>
);<br>
const up = [0, 1, 0];<br>
m.lookAt(eye, target, up).inverse();<br>
renderer.uniforms.viewMatrix = m;<br>
}</p>
<p>如上面代码所示，我们设置相机初始位置矩阵 m，然后执行 m.lookAt(eye, target, up)，这里的 up 是一个向量，表示朝上的方向，我们把它定义为 y 轴正向。然后我们调用 inverse，将这个结果求逆，得到的就是视图矩阵。</p>
<p>为了让你看到相机的效果，我们改写上节课圆柱体的顶点着色器代码，加入视图矩阵。</p>
<p>attribute vec3 a_vertexPosition;<br>
attribute vec4 color;<br>
attribute vec3 normal;</p>
<p>varying vec4 vColor;<br>
varying float vCos;<br>
uniform mat4 projectionMatrix;<br>
uniform mat4 modelMatrix;<br>
uniform mat4 viewMatrix;<br>
uniform mat3 normalMatrix;</p>
<p>const vec3 lightPosition = vec3(1, 0, 0);</p>
<p>void main() {<br>
gl_PointSize = 1.0;<br>
vColor = color;<br>
vec4 pos = viewMatrix * modelMatrix * vec4(a_vertexPosition, 1.0);<br>
vec4 lp = viewMatrix * vec4(lightPosition, 1.0);<br>
vec3 invLight = lp.xyz - pos.xyz;<br>
vec3 norm = normalize(normalMatrix * normal);<br>
vCos = max(dot(normalize(invLight), norm), 0.0);<br>
gl_Position = projectionMatrix * pos;<br>
}</p>
<p>这样，如果我们就把相机位置改变了。我们以 updateCamera([0.5, 0, 0.5]); 为例，这样朝向 (0, 0, 0) 拍摄图像的最终效果就如下所示。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/9486479489c2e832006c5539c91e9e34.png" alt=""></p>
<h2 id="剪裁空间和投影对-3d-图像的影响">剪裁空间和投影对 3D 图像的影响</h2>
<p>在前面的课程中我们说过，WebGL 的默认坐标范围是从 -1 到 1 的。也就是说，只有当图像的 x、y、z 的值在 -1 到 1 区间内才会被显示在画布上，而在其他位置上的图像都会被剪裁掉。</p>
<p>举个例子，如果我们修改模型矩阵，让圆柱体沿 x、y 轴平移，向右上方各平移 0.5，那么圆柱中 x、y 值大于 1 的部分都会被剪裁掉，因为这些部分已经超过了 Canvas 边缘。操作代码和最终效果如下：</p>
<p>function update() {<br>
const modelMatrix = fromRotation(rotationX, rotationY, rotationZ);<br>
modelMatrix[12] = 0.5; // 给 x 轴增加 0.5 的平移<br>
modelMatrix[13] = 0.5; // 给 y 轴也增加 0.5 的平移<br>
renderer.uniforms.modelMatrix = modelMatrix;<br>
renderer.uniforms.normalMatrix = normalFromMat4([], modelMatrix);<br>
&hellip;<br>
}</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/305891e55365782ae42d516259d7e166.png" alt=""></p>
<p>给 x、y 增加 0.5 平移后的效果</p>
<p>对于只有 x、y 的二维坐标系来说，这一点很好理解。但是，对于三维坐标系来说，不仅 x、y 轴会被剪裁，z 轴同样也会被剪裁。我们还是直接修改代码，给 z 轴增加 0.5 的平移。你会看到，最终绘制出来的图形非常奇怪。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/fe1a96fde27eca70dce060ecb7f50e53.png" alt=""></p>
<p>给 z 轴增加 0.5 平移后的效果</p>
<p>会显示这么奇怪的结果，就是因为 z 轴超过范围的部分也被剪裁掉了，导致投影出现了问题。</p>
<p>既然是投影出现了问题，我们先回想一下，我们都对 z 轴做过哪些投影操作。在绘制圆柱体的时候，我们只是用投影矩阵非常简单地反转了一下 z 轴，除此之外，没做过其他任何操作了。所以，为了让图形在剪裁空间中正确显示，我们不能只反转 z 轴，还需要将图像从三维空间中<strong>投影</strong>到剪裁坐标内。那么问题来了，图像是怎么被投影到剪裁坐标内的呢？</p>
<p>一般来说，投影有两种方式，分别是<strong>正投影</strong>与<strong>透视投影</strong>。你可以结合我给出的示意图，来理解它们各自的特点。</p>
<p><strong>首先是正投影</strong>，它又叫做平行投影。正投影是将物体投影到一个长方体的空间（又称为视景体），并且无论相机与物体距离多远，投影的大小都不变。</p>
<p><a href="https://glumes.com/post/opengl/opengl-tutorial-projection-matrix/"><img src="./20bd8b3b76d362dc997cdb3cef9aad57.png.md" alt=""></a></p>
<p>正投影示意图</p>
<p>而<strong>透视投影</strong>则更接近我们的视觉感知。它投影的规律是，离相机近的物体大，离相机远的物体小。与正投影不同，正投影的视景体是一个长方体，而透视投影的视景体是一个棱台。</p>
<p><a href="https://glumes.com/post/opengl/opengl-tutorial-projection-matrix/"><img src="./610bb7c013dd0a0cdfc30c9ec396edd8.png.md" alt=""></a></p>
<p>透视投影示意图</p>
<p>知道了不同投影方式的特点，我们就可以根据投影方式和给定的参数来计算投影矩阵了。因为数学推导过程比较复杂，我在这里就不详细推导了，直接给出对应的 JavaScript 函数，你只要记住 ortho 和 perspective 这两个投影函数就可以了，函数如下所示。</p>
<p>其中，ortho 是计算正投影的函数，它的参数是视景体 x、y、z 三个方向的坐标范围，它的返回值就是投影矩阵。而 perspective 是计算透视投影的函数，它的参数是近景平面 near、远景平面 far、视角 fov 和宽高比率 aspect，返回值也是投影矩阵。</p>
<p>// 计算正投影矩阵<br>
function ortho(out, left, right, bottom, top, near, far) {<br>
let lr = 1 / (left - right);<br>
let bt = 1 / (bottom - top);<br>
let nf = 1 / (near - far);<br>
out[0] = -2 * lr;<br>
out[1] = 0;<br>
out[2] = 0;<br>
out[3] = 0;<br>
out[4] = 0;<br>
out[5] = -2 * bt;<br>
out[6] = 0;<br>
out[7] = 0;<br>
out[8] = 0;<br>
out[9] = 0;<br>
out[10] = 2 * nf;<br>
out[11] = 0;<br>
out[12] = (left + right) * lr;<br>
out[13] = (top + bottom) * bt;<br>
out[14] = (far + near) * nf;<br>
out[15] = 1;<br>
return out;<br>
}</p>
<p>// 计算透视投影矩阵<br>
function perspective(out, fovy, aspect, near, far) {<br>
let f = 1.0 / Math.tan(fovy / 2);<br>
let nf = 1 / (near - far);<br>
out[0] = f / aspect;<br>
out[1] = 0;<br>
out[2] = 0;<br>
out[3] = 0;<br>
out[4] = 0;<br>
out[5] = f;<br>
out[6] = 0;<br>
out[7] = 0;<br>
out[8] = 0;<br>
out[9] = 0;<br>
out[10] = (far + near) * nf;<br>
out[11] = -1;<br>
out[12] = 0;<br>
out[13] = 0;<br>
out[14] = 2 * far * near * nf;<br>
out[15] = 0;<br>
return out;<br>
}</p>
<p>接下来，我们先试试对圆柱体进行正投影。假设，在正投影的时候，我们让视景体三个方向的范围都是 (-2,2)。以刚才的相机位置为参照（任何一个位置观察都一样，不管物体在哪里，都是只有之前大小的一半。因为视景体范围增加了），我们绘制出来的圆柱体的大小只有之前的一半。这是因为我们通过投影变换将空间坐标范围增大了一倍。</p>
<p>import {ortho} from &lsquo;../common/lib/math/functions/Mat4Func.js&rsquo;;<br>
function projection(left, right, bottom, top, near, far) {<br>
return ortho([], left, right, bottom, top, near, far);<br>
}</p>
<p>const projectionMatrix = projection(-2, 2, -2, 2, -2, 2);<br>
renderer.uniforms.projectionMatrix = projectionMatrix; // 投影矩阵</p>
<p>updateCamera([0.5, 0, 0.5]); // 设置相机位置</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/8f9524ee6f2a08ede5514bda66cd20d8.png" alt=""></p>
<p>接下来，我们再试一下对圆柱体进行透视投影。在进行透视投影的时候，我们将相机的位置放在 (2, 2, 3) 的地方。</p>
<p>import {perspective} from &lsquo;../common/lib/math/functions/Mat4Func.js&rsquo;;</p>
<p>function projection(near = 0.1, far = 100, fov = 45, aspect = 1) {<br>
return perspective([], fov * Math.PI / 180, aspect, near, far);<br>
}</p>
<p>const projectionMatrix = projection();<br>
renderer.uniforms.projectionMatrix = projectionMatrix;</p>
<p>updateCamera([2, 2, 3]); // 设置相机位置</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/b0a7c5c06538d3b4b2ab136f4f102fe8.png" alt=""></p>
<p>我们发现，在透视投影下，距离观察者（相机）近的部分大，距离它远的部分小。这更符合真实世界中我们看到的效果，所以一般来说，在绘制 3D 图形时，我们更偏向使用透视投影。</p>
<h2 id="3d-绘图标准模型">3D 绘图标准模型</h2>
<p>实际上，通过上节课和刚才的内容，我们已经能总结出 3D 绘制几何体的基本数学模型，也就是 3D 绘图的<strong>标准模型</strong>。这个标准模型一共有四个矩阵，它们分别是：<strong>投影矩阵、视图矩阵（ViewMatrix）、模型矩阵（ModelMatrix）、法向量矩阵（NormalMatrix）</strong>。</p>
<p>其中，前三个矩阵用来计算最终显示的几何体的顶点位置，第四个矩阵用来实现光照等效果。比较成熟的图形库，如ThreeJS、BabylonJS，基本上都是采用这个标准模型来进行 3D 绘图的。所以理解这个模型，也有助于增强我们对图形库的认识，帮助我们更好地去使用这些流行的图形库。</p>
<p>在前面的课程中，因为 WebGL 原生的 API 在使用上比较复杂，所以我们使用了简易的 gl-renderer 库来简化 2D 绘图过程。而 3D 绘图是一个比 2D 绘图更加复杂的过程，即使是 gl-renderer 库也有点力不从心，我们需要更加强大的绘图库，来简化我们的绘制，以便于我们能够把精力专注于理解图形学本身的核心内容。</p>
<p>当然，使用 ThreeJS 或 BabeylonJS 都是不错的选择。但是在这节课中，我会使用一个更加轻量级的图形库，叫做OGL。它拥有我们可视化绘图需要的所有基本功能，而且，相比于 ThreeJS 等流行图形库，它的 AP 相对更底层、更简单一些。因此不会有太多高级的特性对我们的学习造成干扰。</p>
<p>接下来，我就用这个库来绘制一些简单的圆柱体、立方体等等，让你对这个库的使用有一个全面的了解。</p>
<h2 id="如何使用-ogl-绘制基本的几何体">如何使用 OGL 绘制基本的几何体</h2>
<p>OGL 库使用的也是我们刚才说的标准模型，因此，使用它所以绘制几何体非常简单，分成以下 7 个步骤，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/945ae8cefa335ba29c84bf1f6b12be7e.png" alt=""></p>
<p>接下来，我们详细来看看每一步的操作。</p>
<p>首先，是创建 Renderer 对象。我们可以创建一个画布宽高为 512 的 Renderer 对象。代码如下：</p>
<p>const canvas = document.querySelector(&lsquo;canvas&rsquo;);<br>
const renderer = new Renderer({<br>
canvas,<br>
width: 512,<br>
height: 512,<br>
});</p>
<p>然后，我们在 OGL 中，通过 new Camera 来创建相机，默认创建出的是透视投影相机。这里我们把视角设置为 35 度，位置设置为 (0,1,7)，朝向为 (0,0,0)。代码如下：</p>
<p>const gl = renderer.gl;<br>
gl.clearColor(1, 1, 1, 1);<br>
const camera = new Camera(gl, {fov: 35});<br>
camera.position.set(0, 1, 7);<br>
camera.lookAt([0, 0, 0]);</p>
<p>接着，我们创建场景。OGL 使用树形渲染的方式，所以在用 OGL 创建场景时，我们要使用 Transform 元素。Transform 类型是基本元素，它可以添加子元素和设置几何变换，如果父元素设置了变换，这些变换也会被应用到子元素。</p>
<p>const scene = new Transform();</p>
<p>然后，我们创建几何体对象。OGL 内置了许多常用的几何体对象，包括球体 Sphere、立方体 Box、柱 / 锥体 Cylinder 以及环面 Torus 等等。使用这些对象，我们可以快速创建这些几何体的顶点信息。那在这里，我创建了 4 个几何体对象，分别是球体、立方体、椎体和环面。</p>
<p>const sphereGeometry = new Sphere(gl);<br>
const cubeGeometry = new Box(gl);<br>
const cylinderGeometry = new Cylinder(gl);<br>
const torusGeometry = new Torus(gl);</p>
<p>再然后，我们创建 WebGL 程序。并且，我们在着色器中给这些几何体设置了浅蓝色和简单的光照效果。</p>
<p>const vertex = /* glsl */ `<br>
precision highp float;</p>
<p>attribute vec3 position;<br>
attribute vec3 normal;<br>
uniform mat4 modelViewMatrix;<br>
uniform mat4 projectionMatrix;<br>
uniform mat3 normalMatrix;<br>
varying vec3 vNormal;<br>
void main() {<br>
vNormal = normalize(normalMatrix * normal);<br>
gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);<br>
}<br>
`;</p>
<p>const fragment = /* glsl */ `<br>
precision highp float;</p>
<p>varying vec3 vNormal;<br>
void main() {<br>
vec3 normal = normalize(vNormal);<br>
float lighting = dot(normal, normalize(vec3(-0.3, 0.8, 0.6)));<br>
gl_FragColor.rgb = vec3(0.2, 0.8, 1.0) + lighting * 0.1;<br>
gl_FragColor.a = 1.0;<br>
}<br>
`;</p>
<p>const program = new Program(gl, {<br>
vertex,<br>
fragment,<br>
});</p>
<p>有了 WebGL 程序之后，我们使用它和几何体对象来构建真正的网格（Mesh）元素，最终再把这些元素渲染到画布上。我们创建了 4 个网格对象，它们的形状分别是环面、球体、立方体和圆柱，我们给它们设置了不同的位置，然后将它们添加到场景 scene 中去。</p>
<p>const torus = new Mesh(gl, {geometry: torusGeometry, program});<br>
torus.position.set(0, 1.3, 0);<br>
torus.setParent(scene);</p>
<p>const sphere = new Mesh(gl, {geometry: sphereGeometry, program});<br>
sphere.position.set(1.3, 0, 0);<br>
sphere.setParent(scene);</p>
<p>const cube = new Mesh(gl, {geometry: cubeGeometry, program});<br>
cube.position.set(0, -1.3, 0);<br>
cube.setParent(scene);</p>
<p>const cylinder = new Mesh(gl, {geometry: cylinderGeometry, program});<br>
cylinder.position.set(-1.3, 0, 0);<br>
cylinder.setParent(scene);</p>
<p>最后，我们将它们用相机 camera 对象的设定渲染出来，并分别设置绕 y 轴旋转的动画，你就能看到这 4 个图像旋转的画面了。代码如下：</p>
<p>requestAnimationFrame(update);<br>
function update() {<br>
requestAnimationFrame(update);</p>
<p>torus.rotation.y -= 0.02;<br>
sphere.rotation.y -= 0.03;<br>
cube.rotation.y -= 0.04;<br>
cylinder.rotation.y -= 0.02;</p>
<p>renderer.render({scene, camera});<br>
}</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/cbaeb495d243e8188c0a11e79e78918b.png" alt=""></p>
<h2 id="要点总结">要点总结</h2>
<p>在这一节课，我们在三维空间里，引入了相机和视图矩阵的概念，相机分为透视相机和正交相机，它们有不同的投影方式，并且设置它们还可以改变剪裁空间。视图矩阵和前一节课介绍的投影矩阵、模型矩阵、法向量矩阵一起，构成了 3D 绘图标准模型，这是一般的图形库遵循的标准绘图方式。</p>
<p>为了巩固学习到的知识，我们使用 OGL 库来尝试绘制不同的 3D 几何体，我们依次用 OGL 绘制了球体、立方体、圆柱体和环面。OGL 绘制图形的基本步骤可以总结为 7 步，如下图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/4c96270a397481791510c8cca90b7cde.png" alt=""></p>
<h2 id="小试牛刀">小试牛刀</h2>
<ol>
<li>在上面的例子里，使用 OGL 绘制的球体看起来不是很圆，你可以研究一下OGL 的代码，修改一下创建球体的参数，让它看起来更圆。</li>
<li>你能试着修改一下片元着色器，让上面绘制的 4 个几何体呈现不同的颜色吗？将它们分别改成红色、黄色、蓝色和绿色。</li>
</ol>
<p>欢迎在留言区和我讨论，分享你的答案和思考，也欢迎你把这节课分享给你的朋友，我们下节课见！</p>
<h2 id="源码">源码</h2>
<p>课程中完整示例代码详见GitHub 仓库</p>
<h2 id="推荐阅读">推荐阅读</h2>
<p>OGL</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/">跟月影学可视化</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E6%A1%88%E4%BE%8B%E8%AF%BE/21__%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9A%84%E6%88%90%E9%95%BF%E5%A4%A9%E8%8A%B1%E6%9D%BF/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">21__如何打破设计师的成长天花板？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%9836%E8%AE%B2/21__%E5%A6%82%E4%BD%95%E7%89%A9%E8%89%B2%E5%92%8C%E5%9F%B9%E5%85%BB%E6%A0%B8%E5%BF%83%E4%BA%BA%E6%89%8D/">
            <span class="next-text nav-default">21__如何物色和培养核心人才？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
