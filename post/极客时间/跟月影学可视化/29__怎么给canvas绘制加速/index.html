<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>29__怎么给Canvas绘制加速？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是月影。
上节课，我们从宏观上了解了各个图形系统在性能方面的优劣，以及影响性能的要素。实际上，想要解决性能问题，我们就必须要知道真正消耗性能的点，从而结合项目需求进行有针对的处理，否则性能优化就是纸上谈兵、空中楼阁。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/29__%E6%80%8E%E4%B9%88%E7%BB%99canvas%E7%BB%98%E5%88%B6%E5%8A%A0%E9%80%9F/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/29__%E6%80%8E%E4%B9%88%E7%BB%99canvas%E7%BB%98%E5%88%B6%E5%8A%A0%E9%80%9F/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="29__怎么给Canvas绘制加速？">
  <meta property="og:description" content="你好，我是月影。
上节课，我们从宏观上了解了各个图形系统在性能方面的优劣，以及影响性能的要素。实际上，想要解决性能问题，我们就必须要知道真正消耗性能的点，从而结合项目需求进行有针对的处理，否则性能优化就是纸上谈兵、空中楼阁。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="跟月影学可视化">

  <meta itemprop="name" content="29__怎么给Canvas绘制加速？">
  <meta itemprop="description" content="你好，我是月影。
上节课，我们从宏观上了解了各个图形系统在性能方面的优劣，以及影响性能的要素。实际上，想要解决性能问题，我们就必须要知道真正消耗性能的点，从而结合项目需求进行有针对的处理，否则性能优化就是纸上谈兵、空中楼阁。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6258">
  <meta itemprop="keywords" content="跟月影学可视化">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="29__怎么给Canvas绘制加速？">
  <meta name="twitter:description" content="你好，我是月影。
上节课，我们从宏观上了解了各个图形系统在性能方面的优劣，以及影响性能的要素。实际上，想要解决性能问题，我们就必须要知道真正消耗性能的点，从而结合项目需求进行有针对的处理，否则性能优化就是纸上谈兵、空中楼阁。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">29__怎么给Canvas绘制加速？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6258 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#手段一优化-canvas-指令">手段一：优化 Canvas 指令</a></li>
        <li><a href="#手段二使用缓存">手段二：使用缓存</a>
          <ul>
            <li><a href="#缓存的局限性">缓存的局限性</a></li>
          </ul>
        </li>
        <li><a href="#手段三分层渲染">手段三：分层渲染</a></li>
        <li><a href="#手段四局部重绘">手段四：局部重绘</a></li>
        <li><a href="#手段五优化滤镜">手段五：优化滤镜</a></li>
        <li><a href="#手段六多线程渲染">手段六：多线程渲染</a></li>
        <li><a href="#要点总结">要点总结</a></li>
        <li><a href="#小试牛刀">小试牛刀</a></li>
        <li><a href="#源码">源码</a></li>
        <li><a href="#推荐阅读">推荐阅读</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是月影。</p>
<p>上节课，我们从宏观上了解了各个图形系统在性能方面的优劣，以及影响性能的要素。实际上，想要解决性能问题，我们就必须要知道真正消耗性能的点，从而结合项目需求进行有针对的处理，否则性能优化就是纸上谈兵、空中楼阁。</p>
<p>所以这节课，我们就深入讨论一下影响 Canvas 绘图性能的因素，一起来分析几个不同类型的 Canvas 项目，找到的性能瓶颈以及对应的解决办法，从而学会对大部分 Canvas 项目进行性能优化。</p>
<p>我们知道，Canvas 是指令式绘图系统，它有状态设置指令、绘图指令以及真正的绘图方法（fill 和 stroke）等各类 API。通常情况下利用 Canvas 绘图，我们要先调用状态设置指令设置绘图状态，然后用绘图指令决定要绘制的图形，最后调用真正的 fill() 或 stroke() 方法将内容输出到画布上。</p>
<p>那结合上节课的实验我们知道，影响 Canvas 性能的两大因素分别是图形的数量和图形的大小。它们都会直接影响绘图指令，一个决定了绘图指令的多少，另一个决定了绘图指令的执行时间。通常来说，绘图指令越多、执行时间越长，渲染效率就越低，性能也就越差。</p>
<p>因此，我们想要对 Canvas 性能进行优化，最重要的就是优化渲染效率。常用的手段有 5 种，分别是优化 Canvas 指令、使用缓存、分层渲染、局部重绘和优化滤镜。此外，还有一种手段叫做<strong>多线程渲染</strong>，是用来优化非渲染的计算和交互方面导致的性能问题。</p>
<p>首先，我们来说说优化 Canvas 指令。</p>
<h2 id="手段一优化-canvas-指令">手段一：优化 Canvas 指令</h2>
<p>刚刚我们说了，Canvas 执行的绘图指令越多，性能的消耗就越大。那如果希望 Canvas 绘图达到更好的性能，我们要尽可能减少绘图指令的数量。这就是“优化 Canvas 指令”要做的事情。</p>
<p>那具体怎么做呢？我们看一个例子。</p>
<p>假设，我们要在一个 600 X 600 的画布上，实现一些位置随机的多边形，并且不断刷新这些图形的形状和位置，效果如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/da8470c79a9a959db636c99600813c37.png" alt=""></p>
<p>结合我们之前学过的知识，这个效果其实并不难实现，可以分为 4 步，分别是创建多边形的顶点，根据顶点绘制图形，生成随机多边形，执行绘制。</p>
<p>具体的实现代码如下：</p>
<p>const canvas = document.querySelector(&lsquo;canvas&rsquo;);<br>
const ctx = canvas.getContext(&lsquo;2d&rsquo;);</p>
<p>// 创建正多边形，返回顶点<br>
function regularShape(x, y, r, edges = 3) {<br>
const points = [];<br>
const delta = 2 * Math.PI / edges;<br>
for(let i = 0; i &lt; edges; i++) {<br>
const theta = i * delta;<br>
points.push([x + r * Math.sin(theta), y + r * Math.cos(theta)]);<br>
}<br>
return points;<br>
}</p>
<p>// 根据顶点绘制图形<br>
function drawShape(context, points) {<br>
context.fillStyle = &lsquo;red&rsquo;;<br>
context.strokeStyle = &lsquo;black&rsquo;;<br>
context.lineWidth = 2;<br>
context.beginPath();<br>
context.moveTo(&hellip;points[0]);<br>
for(let i = 1; i &lt; points.length; i++) {<br>
context.lineTo(&hellip;points[i]);<br>
}<br>
context.closePath();<br>
context.stroke();<br>
context.fill();<br>
}</p>
<p>// 多边形类型，包括正三角形、正四边形、正五边形、正六边形和正 100 边形<br>
const shapeTypes = [3, 4, 5, 6, 100];<br>
const COUNT = 1000;</p>
<p>// 执行绘制<br>
function draw() {<br>
ctx.clearRect(0, 0, canvas.width, canvas.height);<br>
for(let i = 0; i &lt; COUNT; i++) {<br>
const type = shapeTypes[Math.floor(Math.random() * shapeTypes.length)];<br>
const points = regularShape(Math.random() * canvas.width,<br>
Math.random() * canvas.height, 10, type);<br>
drawShape(ctx, points);<br>
}<br>
requestAnimationFrame(draw);<br>
}</p>
<p>draw();</p>
<p>这个效果实现起来虽然不难，但性能却不是很好，因为它在我的 Macbook Pro 电脑上只有不到 30fps 的帧率。那问题出在哪呢？我们还是要回到代码中。</p>
<p>我们注意到 drawShape 函数里的 for 循环，它是根据顶点来绘制图形的，一个点对应一条绘图指令。而在我们绘制的随机图形里，有 3、4、5、6 边形和 100 边形。对于一个 100 边形来说，它的顶点数量非常多，所以 Canvas 需要执行的绘图指令也会非常多，那绘制很多个 100 边形自然会造成性能问题了。因此，如何减少绘制 100 边形的绘图指令的数量，才是我们要优化的重点。具体该怎么做呢？</p>
<p>我们知道，对于半径为 10 的小图形来说，正 100 边形已经完全是正圆形了，所以我们可以用 arc 指令来替代 for 循环。</p>
<p>我们修改 shapeTypes 和 draw 函数，用 -1 代替正 100 边形，然后判断 type 是否大于 0，如果是就用之前的方式绘制正多边形，否则用 arc 指令来画圆。这么做了之后，整个效果的帧率就会从 30fps 提升到 40fps，效果还是比较明显的。</p>
<p>const shapeTypes = [3, 4, 5, 6, -1];<br>
const COUNT = 1000;<br>
const TAU = Math.PI * 2;</p>
<p>function draw() {<br>
ctx.clearRect(0, 0, canvas.width, canvas.height);<br>
for(let i = 0; i &lt; COUNT; i++) {<br>
const type = shapeTypes[Math.floor(Math.random() * shapeTypes.length)];<br>
const x = Math.random() * canvas.width;<br>
const y = Math.random() * canvas.height;<br>
if(type &gt; 0) {<br>
// 画正多边形<br>
const points = regularShape(x, y, 10, type);<br>
drawShape(ctx, points);<br>
} else {<br>
// 画圆<br>
ctx.beginPath();<br>
ctx.arc(x, y, 10, 0, TAU);<br>
ctx.stroke();<br>
ctx.fill();<br>
}<br>
}<br>
requestAnimationFrame(draw);<br>
}</p>
<p>到这里，你会发现，我们讲的其实是个特例，那在实际工作中，我们是需要针对特例来优化的。我希望我讲完今天的内容你能够做到举一反三。</p>
<h2 id="手段二使用缓存">手段二：使用缓存</h2>
<p>在上面的方法中，我们优化了绘图指令，让渲染性能有了比较明显的提升。不过，因为这个绘图任务的图形数量和状态都是有限的，我们还有更好的优化方法，那就是<strong>使用缓存</strong>。</p>
<p>因为 Canvas 的性能瓶颈主要在绘图指令方面，如果我们能将图形缓存下来，保存到离屏的 Canvas（offscreen Canvas）中，然后在绘制的时候作为图像来渲染，那我们就可以将绘制顶点的绘图指令变成直接通过 drawImage 指令来绘制图像，而且也不需要 fill() 方法来填充图形，这样性能就会有大幅度的提升。</p>
<p>具体的做法，是我们先实现一个创建缓存的函数。代码如下：</p>
<p>function createCache() {<br>
const ret = [];<br>
for(let i = 0; i &lt; shapeTypes.length; i++) {<br>
// 创建离屏 Canvas 缓存图形<br>
const cacheCanvas = new OffscreenCanvas(20, 20);<br>
// 将图形绘制到离屏 Canvas 对象上<br>
const type = shapeTypes[i];<br>
const context = cacheCanvas.getContext(&lsquo;2d&rsquo;);<br>
context.fillStyle = &lsquo;red&rsquo;;<br>
context.strokeStyle = &lsquo;black&rsquo;;<br>
if(type &gt; 0) {<br>
const points = regularShape(10, 10, 10, type);<br>
drawShape(context, points);<br>
} else {<br>
context.beginPath();<br>
context.arc(10, 10, 10, 0, TAU);<br>
context.stroke();<br>
context.fill();<br>
}<br>
ret.push(cacheCanvas);<br>
}<br>
// 将离屏 Canvas 数组（缓存对象）返回<br>
return ret;<br>
}</p>
<p>然后，我们一次性创建缓存，直接通过缓存来绘图。</p>
<p>const shapes = createCache();<br>
const COUNT = 1000;</p>
<p>function draw() {<br>
ctx.clearRect(0, 0, canvas.width, canvas.height);<br>
for(let i = 0; i &lt; COUNT; i++) {<br>
const shape = shapes[Math.floor(Math.random() * shapeTypes.length)];<br>
const x = Math.random() * canvas.width;<br>
const y = Math.random() * canvas.height;<br>
ctx.drawImage(shape, x, y);<br>
}<br>
requestAnimationFrame(draw);<br>
}</p>
<p>这样，我们就通过缓存渲染，把原本数量非常多的绘图指令优化成了只有 drawImage 的一条指令，让渲染帧率达到了 60fps，从而大大提升了性能。</p>
<h3 id="缓存的局限性">缓存的局限性</h3>
<p>不过，虽然使用缓存能够显著降低 Canvas 的性能消耗，但是缓存的使用也有局限性。</p>
<p>首先，因为缓存是通过创建离屏 Canvas 对象实现的，如果我们要绘制的图形状态（指不同形状、颜色等）非常多的话，那将它们都缓存起来，就需要创建大量的离屏 Canvas 对象。这本身对内存消耗就非常大，有可能反而降低了性能。</p>
<p>其次，缓存适用于图形状态本身不变的图形元素，如固定的几何图形，它们每次刷新只需要更新它的 transform，这样的图形比较适合用缓存。如果是经常发生状态改变的图形元素，那么缓存就必须一直更新，缓存更新本身也是绘图过程。因此，这种情况下，采用缓存根本起不到减少绘图指令的作用，反而因为增加了一条 drawImage 指令产生了更大的开销。</p>
<p>第三，严格上来说，从缓存绘制和直接用绘图指令绘制还是有区别的，尤其是在 fillText 渲染文字或者我们绘制一个图形有较大缩放（scale）的时候。因为不使用缓存直接绘制的是矢量图，而通过缓存 drawImage 绘制出的则是位图，所以缓存绘制的图形，在清晰度上可能不是很好。</p>
<p>但是总体来说，缓存的应用还是非常多的，我们应该要掌握它的用法，学会在合适的时候运用缓存来提升 Canvas 的渲染性能。</p>
<h2 id="手段三分层渲染">手段三：分层渲染</h2>
<p>前面两种手段是操作 Canvas 上所有元素来优化性能的，但有的时候，我们要绘制的元素很多，其中大部分元素状态是不变的，只有一小部分有变化。这个时候，我们又该如何进行优化呢？</p>
<p>我们知道，Canvas 是将上一次绘制的内容擦除，然后绘制新的内容来实现状态变化的。利用这一特点，我们就可以将变化的元素和不变的元素进行分层处理。也就是说，我们可以用两个 Canvas 叠在一起，将不变的元素绘制在一个 Canvas 中，变化的元素绘制在另一个 Canvas 中。</p>
<p>我们还是来看一个例子。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/2d13ff4b97ba695aff40099d308714b7.png" alt=""></p>
<p>假设，我们要实现一个如上图的效果。这个效果的特点是，画面上有一个飞机在运动，运动的物体比较少，而其他静止不动的图形很多（如背景中的上千个三角形）。</p>
<p>在绘制的时候，我们如果将运动的物体和其他物体都绘制在同一个 Canvas 画布中，要改变飞机的运动状态，我们就要重新绘制所有的物体，这会非常浪费性能。因此，更好的做法是我们使用两层画布，一层 Canvas 作为背景，来绘制静态的图形，就是这个例子里的上千个小三角形，而另一层 Canvas 作为前景，用来绘制运动的物体就是运动的飞机。</p>
<p>这样的话，我们只需要一次绘制就能得到背景层 Canvas，并且不管飞机的状态怎么改变，我们都不需要重绘，而前景的飞机可以每一帧重绘，也就大大减少了图形绘制的数量，并且提升了性能。</p>
<p>下面我列出具体的代码，虽然很长但逻辑并不复杂，核心就是用两个 Canvas 元素来分别绘制，你可以看一下。</p>
<p>function drawRandomTriangle(path, context) {<br>
const {width, height} = context.canvas;<br>
context.save();<br>
context.translate(Math.random() * width, Math.random() * height);<br>
context.fill(path);<br>
context.restore();<br>
}</p>
<p>function drawBackground(context, count = 2000) {<br>
context.fillStyle = &lsquo;#ed7&rsquo;;<br>
const d = &lsquo;M0,0L0,10L8.66, 5z&rsquo;;<br>
const p = new Path2D(d);<br>
for(let i = 0; i &lt; count; i++) {<br>
drawRandomTriangle(p, context);<br>
}<br>
}</p>
<p>function loadImage(src) {<br>
const img = new Image();<br>
img.crossOrigin = &lsquo;anonymous&rsquo;;<br>
return new Promise((resolve) =&gt; {<br>
img.onload = resolve(img);<br>
img.src = src;<br>
});<br>
}</p>
<p>async function drawForeground(context) {<br>
const img = await loadImage(&lsquo;<a href="http://p3.qhimg.com/t015b85b72445154fe0.png');">http://p3.qhimg.com/t015b85b72445154fe0.png');</a><br>
const {width, height} = context.canvas;<br>
function update(t) {<br>
context.clearRect(0, 0, width, height);<br>
context.save();<br>
context.translate(0, 0.5 * height);<br>
const p = (t % 3000) / 3000;<br>
const x = width * p;<br>
const y = 0.1 * height * Math.sin(3 * Math.PI * p);<br>
context.drawImage(img, x, y);<br>
context.restore();<br>
requestAnimationFrame(update);<br>
}<br>
update(0);<br>
}</p>
<p>const bgcanvas = document.querySelector(&rsquo;#bg&rsquo;);<br>
const fgcanvas = document.querySelector(&rsquo;#fg&rsquo;);<br>
drawBackground(bgcanvas.getContext(&lsquo;2d&rsquo;));<br>
drawForeground(fgcanvas.getContext(&lsquo;2d&rsquo;));</p>
<h2 id="手段四局部重绘">手段四：局部重绘</h2>
<p>但是，我们用分层渲染解决性能问题的时候，所绘制的图形必须满足两个条件：一是有大量静态的图形元素不需要重新绘制，二是动态和静态图形元素绘制顺序是固定的，先绘制完静态元素再绘制动态元素。如果元素都有可能运动，或者动态元素和静态元素的绘制顺序是交错的，比如先绘制几个静态元素，再绘制几个动态元素，然后再绘制静态元素，这样交替进行，那么分层渲染就不好实现了。这时候，我们还有另外一种优化手段，它叫做局部重绘。</p>
<p>**局部重绘顾名思义，就是不需要清空 Canvas 的全局区域，而是根据运动的元素的范围来清空部分区域。**在很大一部分可视化大屏项目中，我们不会让整个屏幕的所有元素都不断改变，而是只有一些固定的区域改变，所以我们直接刷新那部分区域，重绘区域中的元素就可以了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/58403ad265b4940d4a441b5b47354e91.png" alt=""></p>
<p>大屏的动态区与静态区</p>
<p>如上图所示，一个可视化大屏只有 2 块动态区域需要不断重绘，那我们用 Canvas 上下文的 <strong>clearRect 方法控制要刷新的动态区域</strong>，只对这些区域进行擦除然后重绘。</p>
<p>要注意的是，动态区重绘的时候，区域内的静态元素也需要跟着重绘。如果有静态元素跨越了动态和静态区域范围，那在重绘时，我们自然不希望破坏了静态区的图形。这时候，我们可以使用 Canvas 上下文的 clip 方法，它是一种特殊的绘图指令，可以设定一个绘图区，让图形的绘制限制在这个绘图区内部。这样的话，图形中超过 clip 范围的部分，浏览器就不会把它渲染到 Canvas 上。</p>
<p>这种固定区域的局部重绘使用起来不难，但有时候我们不知道具体的动态区域究竟多大。这个时候，我们可以使用动态计算要重绘区域的技术，它也被称为<strong>脏区检测</strong>。它的基本原理是根据动态元素的<strong>包围盒</strong>，动态算出需要重绘的范围。</p>
<p>那什么是包围盒呢？</p>
<p>我们知道，多边形由顶点构成，包围盒就是指能包含多边形所有顶点，并且与坐标轴平行的最小矩形。</p>
<p><a href="https://www.pngsucai.com/png/950314.html"><img src="./99819f134500264d4fe5fa46ea72dddc.png.md" alt=""></a></p>
<p>多边形包围盒</p>
<p>在 Canvas 平面直角坐标系下，求包围盒并不复杂，只要分别找到所有顶点坐标中 x 的最大、最小值 xmin 和 xmax，以及 y 的最大、最小值 ymin 和 ymax，那么包围盒就是矩形 [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]。</p>
<p>对所有的动态元素计算出包围盒，我们就能知道局部刷新的范围了。不过在实际操作的时候，我们经常会遇到各种复杂的细节问题需要解决。因为涉及的细节比较多，我没法全都讲到，所以，如果你遇到了问题，可以看看蚂蚁金服 AntV 团队的Canvas 局部渲染优化总结这篇文章。</p>
<h2 id="手段五优化滤镜">手段五：优化滤镜</h2>
<p>实际上，分层渲染和局部重绘解决的都是图形重绘的问题。那除了重绘，影响渲染效率的还有 Canvas 滤镜。</p>
<p>我们知道，滤镜是一种对图形像素进行处理的方法，Canvas 支持许多常用的滤镜。不过 Canvas 渲染滤镜的性能开销比较大。到底有多大呢？我们还是用前面绘制随机图形的例子来体验一下。</p>
<p>这次我们用缓存优化版本的代码，这一版代码的性能最高。在绘制前，我们给 Canvas 设置一个 blur 滤镜。代码如下：</p>
<p>ctx.filter = &lsquo;blur(5px)&rsquo;;</p>
<p>这样呢，我们让 Canvas 绘制出来的图形有了模糊的效果。但是这么设置了之后，你会发现原本 60fps 的帧率直接掉到 2fps，画面看上去一顿一顿的，卡得惨不忍睹。这就是因为滤镜对渲染性能的开销实在太大了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/ba5cf7d42b65244dbc5c762e8bd42779.png" alt=""></p>
<p>那这种情况下，其实我们也有优化手段。针对这个场，我们实际上是对 Canvas 应用一个全局的 blur 滤镜，把绘制的所有元素都变得模糊，所以，我们完全没必要对每个元素应用滤镜，而是可以采用类似后期处理通道的做法，先将图形以不使用滤镜的方式绘制到一个离屏的 Canvas 上，然后直接将这个离屏 Canvas 以图片方式绘制到要显示的画布上，在这次绘制的时候采用滤镜。这样，我们就把大量滤镜绘制的过程缩减为对一张图片使用一次滤镜了。大大减少了处理滤镜的次数之后，效果立竿见影，帧率立即回到了 60fps。</p>
<p>那么具体实现的代码和效果我也列出来，你可以看一下。</p>
<p>ctx.filter = &lsquo;blur(5px)&rsquo;;</p>
<p>// 创建离屏的 Canvas<br>
const ofc = new OffscreenCanvas(canvas.width, canvas.height);<br>
const octx = ofc.getContext(&lsquo;2d&rsquo;);<br>
function draw() {<br>
ctx.clearRect(0, 0, canvas.width, canvas.height);<br>
octx.clearRect(0, 0, canvas.width, canvas.height);<br>
// 将图形不应用滤镜，绘制到离屏 Canvas 上<br>
for(let i = 0; i &lt; COUNT; i++) {<br>
const shape = shapes[Math.floor(Math.random() * shapeTypes.length)];<br>
const x = Math.random() * canvas.width;<br>
const y = Math.random() * canvas.height;<br>
octx.drawImage(shape, x, y);<br>
}<br>
// 再将离屏 Canvas 图像绘制到画布上，这一次绘制采用了滤镜<br>
ctx.drawImage(ofc, 0, 0);<br>
requestAnimationFrame(draw);<br>
}</p>
<p>draw();</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/9ed4f4a7aa886bf8ce8c472f7be7107f.png" alt=""></p>
<p>当然这种优化滤镜的方式，只有当我们要对画布上绘制的所有图形，都采用同一种滤镜的时候才有效。不过，如果有部分图形采用相同的滤镜，而且它们是连续绘制的，我们也可以采用类似的办法，把这部分图形绘制到离屏 Canvas 上，之后再将图像应用滤镜并绘制回画布。这样也能够减少滤镜的处理次数，明显提升性能。总之，想要达到比较好的性能，我们要记住一个原则，尽量合并图形应用相同滤镜的过程。</p>
<h2 id="手段六多线程渲染">手段六：多线程渲染</h2>
<p>到这里，我们说完了几种提升渲染性能的常见手段。不过，影响用户体验的不仅仅是渲染性能，有时候，我们还要对绘制的内容进行交互，而如果渲染过程消耗了大量的时间，它也可能会阻塞其他的操作，比如对事件的响应。</p>
<p>遇到这种问题的时候，以前我们会比较头疼，甚至不得不降低渲染性能，以减少 CPU 资源占用，从而让交互行为不被阻塞。不过现在，浏览器支持的 Canvas 可以在 WebWorker 中以单独的线程来渲染，这样就可以避免对主线程的阻塞，也不会影响用户交互行为了。</p>
<p>那么具体怎么才能在 Worker 中绘制呢？其实也很简单。我们在浏览器主线程中创建 Worker，然后将 Canvas 对象通过 transferControlToOffscreen 转成离屏 Canvas 对象发送给 Worker 线程去处理。</p>
<p>const canvas = document.querySelector(&lsquo;canvas&rsquo;);</p>
<p>const worker = new Worker(&rsquo;./random_shapes_worker.js&rsquo;);<br>
const ofc = canvas.transferControlToOffscreen();<br>
worker.postMessage({<br>
canvas: ofc,<br>
type: &lsquo;init&rsquo;,<br>
}, [ofc]);</p>
<p>这样，从使用上来说，无论在 Worker 线程中还是在主线程中操作都没有太大的区别，还能不阻塞浏览器主线程的任何操作。</p>
<p>我这里列出一部分核心代码，完整的代码我放在 GitHub 仓库里，你可以试着运行一下，看看效果。</p>
<p>function draw(ctx, shapes) {<br>
const canvas = ctx.canvas;<br>
ctx.clearRect(0, 0, canvas.width, canvas.height);<br>
for(let i = 0; i &lt; COUNT; i++) {<br>
const shape = shapes[Math.floor(Math.random() * shapeTypes.length)];<br>
const x = Math.random() * canvas.width;<br>
const y = Math.random() * canvas.height;<br>
ctx.drawImage(shape, x, y);<br>
}<br>
requestAnimationFrame(draw.bind(null, ctx, shapes));<br>
}</p>
<p>self.addEventListener(&lsquo;message&rsquo;, (evt) =&gt; {<br>
if(evt.data.type === &lsquo;init&rsquo;) {<br>
const canvas = evt.data.canvas;<br>
if(canvas) {<br>
const ctx = canvas.getContext(&lsquo;2d&rsquo;);<br>
const shapes = createCache();<br>
draw(ctx, shapes);<br>
}<br>
}<br>
});</p>
<h2 id="要点总结">要点总结</h2>
<p>这节课我们讲了 Canvas 性能优化的 6 种手段，其中前 5 种是针对渲染效率进行优化，分别是优化 Canvas 指令、使用缓存、分层渲染、局部重绘，以及针对滤镜的优化。最后一种是通过多线程来优化计算的性能，让计算过程能够并行执行不会阻塞浏览器的 UI。下面，我再带你一起梳理一下性能优化的原则。</p>
<p>首先，我们在绘制图形时，用越简单的绘图指令来绘制，渲染的效率就越高。所以，我们要想办法减少 Canvas 绘图指令的数量，比如，用 arc 指令画圆来代替绘制边数很多的正多边形。</p>
<p>然后，当我们大批量绘制有限的几种形状的图形时，可以采用缓存将图形一次绘制后保存在离屏的 Canvas 中，下一次绘制的时候，我们直接绘制缓存的图片来取代原始的绘图指令，也能大大提升性能。</p>
<p>可如果我们绘制的元素中只有一部分元素发生改变，我们就可以采用分层渲染，将变化的元素绘制在一个图层，剩下的元素绘制在另一个图层。这样每次只需要重新绘制变化元素所在的图层，大大减少绘制的图形数，从而显著提升了性能。</p>
<p>还有一种情况是，如果 Canvas 只有部分区域发生变化，那我们只需要刷新局部区域，不需要刷新整个 Canvas，这样能显著降低消耗、提升性能。</p>
<p>还要注意的是，一些 Canvas 滤镜渲染起来非常耗费性能，所以我们可以对滤镜进行合并，让多个元素只应用一次滤镜，从而减少滤镜对性能的消耗。</p>
<p>最后，除了优化渲染性能外，我们还可以通过 WebWork 以多线程的手段优化计算性能，以达到渲染不阻塞 UI 操作的目的。</p>
<h2 id="小试牛刀">小试牛刀</h2>
<p>学会了使用多种优化手段之后，我们来尝试实现一个粒子效果吧！</p>
<p>具体效果是，我们要让小三角形以不同的角度和速度，由画布中心点向四周运动，同时小三角形自身也以随机的角速度旋转。</p>
<p>你可以尝试用两种方式来实现这个效果，分别是使用性能优化和不使用性能优化。在这两种情况下，你的电脑最多能支持同时绘制多少个小三角形？</p>
<p>我们今天学的这 6 种性能优化手段，对你的工作是不是很有帮助？那不妨就把这节课分享出去吧！我们下节课再见！</p>
<h2 id="源码">源码</h2>
<p>课程中详细示例代码 GitHub 仓库</p>
<h2 id="推荐阅读">推荐阅读</h2>
<p>[1] AntV Canvas 局部渲染总结</p>
<p>[2] Speed up Your Canvas Operations with a Web Worker，WebWorker 和 OffscreenCanvas 使用参考文档</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%B7%9F%E6%9C%88%E5%BD%B1%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96/">跟月影学可视化</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2/29__%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8A/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">29__原子操作（上）</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%BE%8E/29__%E6%88%98%E6%9C%AF%E8%AE%BE%E8%AE%A1%E5%A6%82%E4%BD%95%E5%83%8F%E5%86%99%E6%95%85%E4%BA%8B%E4%B8%80%E6%A0%B7%E6%89%BE%E5%87%BA%E6%A8%A1%E5%9E%8B/">
            <span class="next-text nav-default">29__战术设计：如何像写故事一样找出模型？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
