<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>16__为什么不建议你使用存储过程？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是王磊，你也可以叫我 Ivan。
今天，我们一起来到了这门课的第 16 讲。如果你学习并理解了前面的所有课程，那么我要恭喜你，这不仅是因为你学完了一半的课程，还意味着你已经征服了“数据库事务”这座高峰。当然，如果你有困惑的地方，也不必沮丧，因为接下来会是一小段平缓地带，我们会探讨一些相对独立的问题。比如我们今天的话题，为什么不建议你使用存储过程？
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%9330%E8%AE%B2/16__%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%A0%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%9330%E8%AE%B2/16__%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%A0%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="16__为什么不建议你使用存储过程？">
  <meta property="og:description" content="你好，我是王磊，你也可以叫我 Ivan。
今天，我们一起来到了这门课的第 16 讲。如果你学习并理解了前面的所有课程，那么我要恭喜你，这不仅是因为你学完了一半的课程，还意味着你已经征服了“数据库事务”这座高峰。当然，如果你有困惑的地方，也不必沮丧，因为接下来会是一小段平缓地带，我们会探讨一些相对独立的问题。比如我们今天的话题，为什么不建议你使用存储过程？">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="分布式数据库30讲">

  <meta itemprop="name" content="16__为什么不建议你使用存储过程？">
  <meta itemprop="description" content="你好，我是王磊，你也可以叫我 Ivan。
今天，我们一起来到了这门课的第 16 讲。如果你学习并理解了前面的所有课程，那么我要恭喜你，这不仅是因为你学完了一半的课程，还意味着你已经征服了“数据库事务”这座高峰。当然，如果你有困惑的地方，也不必沮丧，因为接下来会是一小段平缓地带，我们会探讨一些相对独立的问题。比如我们今天的话题，为什么不建议你使用存储过程？">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4375">
  <meta itemprop="keywords" content="分布式数据库30讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="16__为什么不建议你使用存储过程？">
  <meta name="twitter:description" content="你好，我是王磊，你也可以叫我 Ivan。
今天，我们一起来到了这门课的第 16 讲。如果你学习并理解了前面的所有课程，那么我要恭喜你，这不仅是因为你学完了一半的课程，还意味着你已经征服了“数据库事务”这座高峰。当然，如果你有困惑的地方，也不必沮丧，因为接下来会是一小段平缓地带，我们会探讨一些相对独立的问题。比如我们今天的话题，为什么不建议你使用存储过程？">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">16__为什么不建议你使用存储过程？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4375 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#我从-cs-时代走来">我从 C/S 时代走来</a></li>
        <li><a href="#触发器被抛弃">触发器被抛弃</a></li>
        <li><a href="#存储过程的优点">存储过程的优点</a></li>
        <li><a href="#存储过程的问题">存储过程的问题</a></li>
        <li><a href="#分布式数据库的支持情况">分布式数据库的支持情况</a></li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#思考题">思考题</a></li>
        <li><a href="#学习资料">学习资料</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是王磊，你也可以叫我 Ivan。</p>
<p>今天，我们一起来到了这门课的第 16 讲。如果你学习并理解了前面的所有课程，那么我要恭喜你，这不仅是因为你学完了一半的课程，还意味着你已经征服了“数据库事务”这座高峰。当然，如果你有困惑的地方，也不必沮丧，因为接下来会是一小段平缓地带，我们会探讨一些相对独立的问题。比如我们今天的话题，为什么不建议你使用存储过程？</p>
<p>有些资深的数据库开发同学可能不同意这个观点，我猜他们大概会说：“存储过程很好呀，那些用不好的人就是自己水平烂，不接受反驳！”其实，我就有过这样的念头，但是现在的我面对分布式数据库，会更倾向于少用或者不用存储过程。下面，我就来和你分享下这个心路历程吧。</p>
<h2 id="我从-cs-时代走来">我从 C/S 时代走来</h2>
<p>当我刚成为一个名程序员时，正好是 C/S 架构时代的末期。那时最流行的开发套件是 PowerBuilder 和 Sybase 数据库。PowerBuilder 是一款可视化开发工具，有点像 VB，开发好的程序运行在用户的 PC 终端上，通过驱动程序连接远端的数据库。而 Sybase 当时正与 Oracle 争夺数据库的头把交椅，它和 SQL Server 有很深的渊源，两者在架构和语言上都很像。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%9330%E8%AE%B2/4a7e3c84964b2f4d27242fd070723192.png" alt=""></p>
<p>C/S 架构</p>
<p>在这个 C/S 架构中，数据库不仅承担了数据存储、计算功能，还要运行很重的业务逻辑，相当于数据库同时承担了应用服务器（Application Server）的大多数功能。而这些业务逻辑的技术载体就是存储过程。所以，不管是 Sybase 还是 Oracle，它们存储过程的功能都非常强大。</p>
<h2 id="触发器被抛弃">触发器被抛弃</h2>
<p>进入 B/S 时代，大家对数据库的理解发生了变化，应用服务器承载了服务器端的主要业务逻辑，那还要不要使用存储过程呢？你看，这和我们今天的问题是一样的。当时的主流观点认为存储过程还有存在价值的，但是它的同胞兄弟触发器则被彻底抛弃了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%9330%E8%AE%B2/e20021e732f00fd9012a40457ffb8c3a.png" alt=""></p>
<p>B/S 架构</p>
<p>为什么呢？其实，触发器和存储过程一样也是一种自定义函数。但它并不是显式调用，而是在操作数据表的时候被动触发，也就是执行 insert、update 和 delete 时；而且你还可以选择触发时机是在操作前还是操作后，也就 before 和 after 的语义。</p>
<p>听上去这个功能很强大吧，有点面向事件编程的意思。但是，如果你维护过触发器的逻辑就会发现，这是一个大坑。随着业务的发展和变更，触发器的逻辑会越来越复杂，就有人会在触发器的逻辑里操纵另一张表，而那张表上又有其他触发器牵连到其他表，这样慢慢就变成一个交错网络。</p>
<p>这简直就是一个地雷阵，你只要踏错一小步，经过一串连锁反应就会演变成一场大灾难。所以，触发器毫无悬念地退出了历史舞台。</p>
<h2 id="存储过程的优点">存储过程的优点</h2>
<p>存储过程的调用清晰，不存在触发器的问题。它的优点很明显，逻辑运行在数据库，没有网络传输数据的开销，所以在进行数据密集型操作时，性能优势很突出。</p>
<p>关于存储过程的使用，我有一段亲身经历，虽然过去了很多年但依然记忆深刻。当时要开发一个功能，追溯业务实体间的影响关系，比如 A 影响 B，B 又影响到 C。这个功能就是要以 A 为输入，把 B 和 C 都找出来，当然这个影响关系不只是三层了，一直要追溯到所有被影响的实体。</p>
<p>今天，我们都知道这是一个典型的关联关系查询，适合用图数据库来处理。但那个时候还没有可用的图数据库，我们需要在 Oracle 上解决这个问题。有一个比我更年轻的同事写了一段 Java 代码来实现这个功能，我猜他没有经历过 C/S 时代。程序运行起来，应用服务器不断地访问这张表，处理每一条记录的关联关系。性能可想而知，在一个数据量较少的测试环境上，程序足足跑了三十分钟。这大大超出了用户的容忍范围，必须要优化。</p>
<p>关于解决方案，我想你也猜到了，我换成了存储过程来实现同样的逻辑，因为不需要网络传输，性能大幅度提升。最后，存储过程花了大概二十几秒就得到了同样的结果。“干得漂亮！“我当时这么告诉自己。</p>
<h2 id="存储过程的问题">存储过程的问题</h2>
<p>但是后来，我发现了这个方案的问题，那就是移植性差。我们开发的产品要部署到客户环境里，会受到相关基础软件的制约。</p>
<p>有一次，刚好碰到这个客户没有使用 Oracle，所以其他同事将我写的逻辑翻写到了客户使用的数据库上。我们给这个数据库取个化名，就叫它 TDB 吧。可是，移植到 TDB 之后的存储过程并没有跑出结果，直接失败退出。我觉得很奇怪，就跟踪了这段代码，最后发现问题不在逻辑本身，而在数据库上。答案是这样的，这段逻辑中我使用了递归算法，因为 Oracle 支持很深的递归层次，所以运行完全没有问题；而 TDB 只支持非常有限的递归层次，而当时数据关联关系又比较多，所以程序没跑多久，就报错退出了。</p>
<p>这段经历让我对存储过程的信心有一点动摇。存储过程对于环境有很重的依赖，而这个环境并不是操作系统和 Java 虚拟机这样遵循统一标准、有大量技术资料的开放环境，而是数据库这个不那么标准的黑盒子。</p>
<p>然而，存储过程的问题还不止于此。当我在 C/S 架构下开发时，就遇到了存储过程难以调试的问题，只不过当时大家都认为这是必须付出的代价。但是随着 B/S 架构的到来，Java 代码的开发测试技术不断发展，相比之下存储过程难调试的问题就显得更突出了。而到了今天，敏捷开发日渐普及，DevOps 工具链迅速发展，而存储过程呢，还是“遗世独立”的样子。</p>
<p>说了这么多，我希望你明白的是，今天的存储过程和当年的触发器，本质上面临的是同样的问题：<strong>一种技术必须要匹配同时代的工程化水平，与整个技术生态相融合，否则它就要退出绝大多数应用场景</strong>。</p>
<p>你看，《阿里巴巴 Java 开发手册》中也赫然写着“禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。”我想，他们大概是有和我类似的心路历程吧。</p>
<h2 id="分布式数据库的支持情况">分布式数据库的支持情况</h2>
<p>刚才说的都是我从工程化角度发表的一些观点，现在让我们回到分布式数据库，再来看看这个新技术对存储过程的支持情况是怎样的。</p>
<p>目前，多数 NewSQL 分布式数据库仍然是不支持存储过程的。OceanBase 是一个例外，它在 2.2 版本中增加了对 Oracle 存储过程的支持。我认为这是它全面兼容 Oracle 策略的产物。但是，OceanBase 的官方说明也说得很清楚，目前存储过程的功能还不能满足生产级的要求。</p>
<p>其实，对遗留系统的兼容，可能就是今天存储过程最大的意义。而对于那些从 MySQL 向分布式数据库迁移的系统，这个诉求可能就没那么强烈，因为这些系统没有那么倚重存储过程。其中的原因就是，MySQL 在较晚的版本才提供存储过程，而且功能上也没有 Oracle 那么强大，用户对它的依赖自然也就小了。</p>
<p>当然，存储过程没有得到 NewSQL 的广泛支持，还因为架构上存在的难题。我们不妨看看业界的一些尝试。</p>
<p>Google 在 2018 年 VLDB 上发布了 F1 的新论文” F1 Query: Declarative Querying at Scale”。论文中提出，通过独立的 UDF Server 支持自定义函数，也就是存储过程。这个架构中，因为 F1 是完全独立于数据存储的，所以 UDF Server 自然也就被抽了出来。从论文提供的测试数据看，这个设计保持了比较高的性能，但我觉得这和 Google 强大的网络设施有很大关系，在普通企业网络条件下能否适用，这还很难说。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%9330%E8%AE%B2/1efb17efec2d7a85bb5668093e78e413.png" alt=""></p>
<p>关于 UDF Server 的设计，还有两点也是非常重要的。</p>
<ol>
<li>首先，UDF 实现了对通用语言的支持，除了 SQL，还支持 C++、Java、Go 等多种语言实现方式。这样不依赖于数据库的 SQL 方言，逻辑表述的通用性更好。</li>
<li>其次，UDF 并没有耦合在存储层。这意味着它的上下文环境可以更加开放。</li>
</ol>
<p>这两点变化意味着存储过程的调试问题可能会得到明显的改善，使其与 DevOps 体系的对接成为可能。</p>
<p>不仅是 F1，其实更早的 VoltDB 也已经对存储过程进行了改革。VoltDB 是一款基于内存的分布式数据库，由数据库领域的传奇人物，迈克尔 · 斯通布雷克（Micheal Stonebraker）主导开发。VoltDB 将存储过程作为主要操作方式，并支持使用 Java 语言编写。开发者可以继承系统提供的父类（VoltProcedure）来开发自己的存储过程。下面是一个简单的示例。</p>
<p>import org.voltdb.*;<br>
public class LeastPopulated extends VoltProcedure {<br>
//待执行的 SQL 语句<br>
public final SQLStmt getLeast = new SQLStmt(<br>
&quot; SELECT TOP 1 county, abbreviation, population &quot;<br>
+ &quot; FROM people, states WHERE people.state_num=?&quot;<br>
+ &quot; AND people.state_num=states.state_num&quot;<br>
+ &quot; ORDER BY population ASC;&quot; );</p>
<p>//执行入口<br>
public VoltTable[] run(int state_num)<br>
throws VoltAbortException {<br>
//赋输入参数<br>
voltQueueSQL( getLeast, state_num );<br>
//SQL 执行函数<br>
return voltExecuteSQL();<br>
}<br>
}</p>
<p>这段代码的逻辑非常简单，首先定义 SQL，其中“state_num=？”是预留参数位置，而后在入口函数 run() 中赋参并执行。</p>
<p>VoltDB 在设计理念上非常与众不同，很重视 CPU 的使用效率。他们对传统数据库进行了分析，认为普通数据库只有 12% 的 CPU 时间在做真正有意义的数据操作，所以它的很多设计都是围绕着充分利用 CPU 资源这个理念展开的。</p>
<p>具体来说，存储过程实质上是预定义的事务，没有人工交互过程，也就避免了相应的 CPU 等待。同时，因为存储过程的内容是预先可知的，所以能够尽早的将数据加载到内存中，这又进一步减少了网络和磁盘 I/O 带来的 CPU 等待。</p>
<p>正是由于存储过程和内存的使用，VoltDB 即使在单线程模型下也获得了很好的性能。反过来，单线程本身也让事务控制更加简单，避免了传统的锁管理的开销和 CPU 等待，提升了 VoltDB 的性能。</p>
<p>可以说，与其他数据库相比，存储过程对于 VoltDB 意义已经是截然不同了。</p>
<h2 id="小结">小结</h2>
<p>好了，有关存储过程的话题就到这里了，让我们一起梳理下今天的重点内容。</p>
<ol>
<li>我用自己的一段亲身经历，说明了存储过程的移植差。究其原因，在于存储过程高度依赖于数据库环境，而数据库环境不像操作系统或虚拟机那样遵循统一的标准。因为同样的原因，存储过程调试也很复杂，也没有跟上敏捷开发的步伐，与今天工程化的要求不匹配。正是因为这两个工程化方面的原因，我建议你不用或者少用存储过程。</li>
<li>从分布式数据库看，多数 NewSQL 还不支持存储过程，OceanBase 作为唯一的例外，已经支持 Oracle 存储过程，但仍然没有达到生产级。</li>
<li>F1 的论文提出了独立 UDF Server 的思路，是分布式架构下存储过程的一种实现方案，但能不能适合普通的企业网络环境，尚待观察。但这个方案中，存储过程的实现语言不局限于 SQL 方言，而是放宽到多种主流语言，向标准兼容，具备更好的开放性。这提升了存储过程技术与 DevOps 融合的可能性。</li>
<li>VoltDB 作为一款内存型分布式数据库，以存储过程作为主要的操作定义方式，支持使用 Java 语言开发。甚至可以说，VoltDB 的基础就是存储过程这种预定义事务方式。存储过程、内存存储、单线程三者互相影响，使得 VoltDB 具备出色的性能表现。</li>
</ol>
<p>对于任何一个程序员来说，放弃一种已经熟练掌握而且执行高效的技术，必然是一个艰难的决定。但是今天，对于大型软件系统而言，工程化要求远比某项技术本身更加重要。不能与整个技术生态协作的技术，最终将无法避免被边缘化的命运。当你学习一门新技术前，无论是分布式数据库还是微服务，我都建议你要关注它与周边生态是否能够适配，因为符合潮流的技术有机会变得更好，而太过小众的技术则蕴藏了更大的不确定性。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%9330%E8%AE%B2/05d5b929c57fdb454646ea545c96cb6e.png" alt=""></p>
<h2 id="思考题">思考题</h2>
<p>课程的最后，我们来看看今天的思考题。我们说 VoltDB 的设计思路很特别，除了单线程、大量使用内存、存储过程支持 Java 语言外，它在数据的复制上的设计也是别出心裁，既不是 NewSQL 的 Paxos 协议也不是 PGXC 的主从复制，你能想到是如何设计的吗？提示一下，复制机制和存储过程是有一定关系的。</p>
<p>欢迎你在评论区留言和我一起讨论，我会在答疑篇和你继续讨论这个问题。如果你身边的朋友也对存储过程这个话题感兴趣，你也可以把今天这一讲分享给他，我们一起讨论。</p>
<h2 id="学习资料">学习资料</h2>
<p>Bart Samwel: F1 Query: Declarative Querying at Scale</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%9330%E8%AE%B2/">分布式数据库30讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/16__%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B8%AD%E5%A4%8D%E6%9D%82%E5%A4%9A%E5%8F%98%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">16__网络优化（中）：复杂多变的移动网络该如何优化？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%BE%8E/16__%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E4%B8%8D%E7%88%B1%E5%86%99%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/">
            <span class="next-text nav-default">16__为什么你不爱写项目文档？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
