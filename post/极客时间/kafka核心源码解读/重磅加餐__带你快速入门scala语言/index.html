<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>重磅加餐__带你快速入门Scala语言 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是胡夕。最近，我在留言区看到一些同学反馈说“Scala 语言不太容易理解”，于是，我决定临时加一节课，给你讲一讲 Scala 语言的基础语法，包括变量和函数的定义、元组的写法、函数式编程风格的循环语句的写法、它独有的 case 类和强大的 match 模式匹配功能，以及 Option 对象的用法。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E9%87%8D%E7%A3%85%E5%8A%A0%E9%A4%90__%E5%B8%A6%E4%BD%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8scala%E8%AF%AD%E8%A8%80/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E9%87%8D%E7%A3%85%E5%8A%A0%E9%A4%90__%E5%B8%A6%E4%BD%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8scala%E8%AF%AD%E8%A8%80/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="重磅加餐__带你快速入门Scala语言">
  <meta property="og:description" content="你好，我是胡夕。最近，我在留言区看到一些同学反馈说“Scala 语言不太容易理解”，于是，我决定临时加一节课，给你讲一讲 Scala 语言的基础语法，包括变量和函数的定义、元组的写法、函数式编程风格的循环语句的写法、它独有的 case 类和强大的 match 模式匹配功能，以及 Option 对象的用法。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Kafka核心源码解读">

  <meta itemprop="name" content="重磅加餐__带你快速入门Scala语言">
  <meta itemprop="description" content="你好，我是胡夕。最近，我在留言区看到一些同学反馈说“Scala 语言不太容易理解”，于是，我决定临时加一节课，给你讲一讲 Scala 语言的基础语法，包括变量和函数的定义、元组的写法、函数式编程风格的循环语句的写法、它独有的 case 类和强大的 match 模式匹配功能，以及 Option 对象的用法。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5012">
  <meta itemprop="keywords" content="Kafka核心源码解读">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="重磅加餐__带你快速入门Scala语言">
  <meta name="twitter:description" content="你好，我是胡夕。最近，我在留言区看到一些同学反馈说“Scala 语言不太容易理解”，于是，我决定临时加一节课，给你讲一讲 Scala 语言的基础语法，包括变量和函数的定义、元组的写法、函数式编程风格的循环语句的写法、它独有的 case 类和强大的 match 模式匹配功能，以及 Option 对象的用法。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">重磅加餐__带你快速入门Scala语言</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5012 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#java-函数式编程">Java 函数式编程</a></li>
        <li><a href="#定义变量和函数">定义变量和函数</a></li>
        <li><a href="#定义元组tuple">定义元组（Tuple）</a></li>
        <li><a href="#循环写法">循环写法</a></li>
        <li><a href="#case-类">case 类</a></li>
        <li><a href="#模式匹配">模式匹配</a></li>
        <li><a href="#option-对象">Option 对象</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是胡夕。最近，我在留言区看到一些同学反馈说“Scala 语言不太容易理解”，于是，我决定临时加一节课，给你讲一讲 Scala 语言的基础语法，包括变量和函数的定义、元组的写法、函数式编程风格的循环语句的写法、它独有的 case 类和强大的 match 模式匹配功能，以及 Option 对象的用法。</p>
<p>学完这节课以后，相信你能够在较短的时间里掌握这些实用的 Scala 语法，特别是 Kafka 源码中用到的 Scala 语法特性，彻底扫清源码阅读路上的编程语言障碍。</p>
<h2 id="java-函数式编程">Java 函数式编程</h2>
<p>就像我在开篇词里面说的，你不熟悉 Scala 语言其实并没有关系，但你至少要对 Java 8 的函数式编程有一定的了解，特别是要熟悉 Java 8 Stream 的用法。</p>
<p>倘若你之前没有怎么接触过 Lambda 表达式和 Java 8 Stream，我给你推荐一本好书：<strong>《Java 8 实战》</strong>。这本书通过大量的实例深入浅出地讲解了 Lambda 表达式、Stream 以及函数式编程方面的内容，你可以去读一读。</p>
<p>现在，我就给你分享一个实际的例子，借着它开始我们今天的所有讨论。</p>
<p>TopicPartition 是 Kafka 定义的主题分区类，它建模的是 Kafka 主题的分区对象，其关键代码如下：</p>
<p>public final class TopicPartition implements Serializable {<br>
private final int partition;<br>
private final String topic;<br>
// 其他字段和方法&hellip;&hellip;<br>
}</p>
<p>对于任何一个分区而言，一个 TopicPartition 实例最重要的就是 <strong>topic 和 partition 字段</strong>，即 <strong>Kafka 的主题和分区号</strong>。假设给定了一组分区对象 List &lt; TopicPartition &gt; ，我想要找出分区数大于 3 且以“test”开头的所有主题列表，我应该怎么写这段 Java 代码呢？你可以先思考一下，然后再看下面的答案。</p>
<p>我先给出 Java 8 Stream 风格的答案：</p>
<p>// 假设分区对象列表变量名是 list<br>
Set<String> topics = list.stream()<br>
.filter(tp -&gt; tp.topic().startsWith(&ldquo;test-&rdquo;))<br>
.collect(Collectors.groupingBy(TopicPartition::topic, Collectors.counting()))<br>
.entrySet().stream()<br>
.filter(entry -&gt; entry.getValue() &gt; 3)<br>
.map(entry -&gt; entry.getKey()).collect(Collectors.toSet());</p>
<p>这是典型的 Java 8 Stream 代码，里面大量使用了诸如 filter、map 等操作算子，以及 Lambda 表达式，这让代码看上去一气呵成，而且具有很好的可读性。</p>
<p>我从第 3 行开始解释下每一行的作用：第 3 行的 filter 方法调用实现了筛选以“test”开头主题的功能；第 4 行是运行 collect 方法，同时指定使用 groupingBy 统计分区数并按照主题进行分组，进而生成一个 Map 对象；第 5~7 行是提取出这个 Map 对象的所有 &lt;K, V&gt; 对，然后再次调用 filter 方法，将分区数大于 3 的主题提取出来；最后是将这些主题做成一个集合返回。</p>
<p>其实，给出这个例子，我只是想说明，<strong>Scala 语言的编写风格和 Java 8 Stream 有很多相似之处</strong>：一方面，代码中有大量的 filter、map，甚至是 flatMap 等操作算子；另一方面，代码的风格也和 Java 中的 Lambda 表达式写法类似。</p>
<p>如果你不信的话，我们来看下 Kafka 中计算消费者 Lag 的 getLag 方法代码：</p>
<p>private def getLag(offset: Option[Long], logEndOffset: Option[Long]): Option[Long] =<br>
offset.filter(_ != -1).flatMap(offset =&gt; logEndOffset.map(_ - offset))</p>
<p>你看，这里面也有 filter 和 map。是不是和上面的 Java 代码有异曲同工之妙？</p>
<p>如果你现在还看不懂这个方法的代码是什么意思，也不用着急，接下来我会带着你一步一步来学习。我相信，学完了这节课以后，你一定能自主搞懂 getLag 方法的源码含义。getLag 代码是非常典型的 Kafka 源码，一旦你熟悉了这种编码风格，后面一定可以举一反三，一举攻克其他的源码阅读难题。</p>
<p>我们先从 Scala 语言中的变量（Variable）开始说起。毕竟，不管是学习任何编程语言，最基础的就是先搞明白变量是如何定义的。</p>
<h2 id="定义变量和函数">定义变量和函数</h2>
<p>Scala 有两类变量：<strong>val 和 var</strong>。<strong>val 等同于 Java 中的 final 变量，一旦被初始化，就不能再被重新赋值了</strong>。相反地，<strong>var 是非 final 变量，可以重复被赋值</strong>。我们看下这段代码：</p>
<p>scala&gt; val msg = &ldquo;hello, world&rdquo;<br>
msg: String = hello, world</p>
<p>scala&gt; msg = &ldquo;another string&rdquo;<br>
<console>:12: error: reassignment to val<br>
msg = &ldquo;another string&rdquo;</p>
<p>scala&gt; var a:Long = 1L<br>
a: Long = 1</p>
<p>scala&gt; a = 2<br>
a: Long = 2</p>
<p>很直观，对吧？msg 是一个 val，a 是一个 var，所以 msg 不允许被重复赋值，而 a 可以。我想提醒你的是，<strong>变量后面可以跟“冒号 + 类型”，以显式标注变量的类型</strong>。比如，这段代码第 6 行的“：Long”，就是告诉我们变量 a 是一个 Long 型。当然，如果你不写“：Long”，也是可以的，因为 Scala 可以通过后面的值“1L”自动判断出 a 的类型。</p>
<p>不过，很多时候，显式标注上变量类型，可以让代码有更好的可读性和可维护性。</p>
<p>下面，我们来看下 Scala 中的函数如何定义。我以获取两个整数最大值的 Max 函数为例，进行说明，代码如下：</p>
<p>def max(x: Int, y: Int): Int = {<br>
if (x &gt; y) x<br>
else y<br>
}</p>
<p>首先，def 关键字表示这是一个函数。max 是函数名，括号中的 x 和 y 是函数输入参数，它们都是 Int 类型的值。结尾的“Int =”组合表示 max 函数返回一个整数。</p>
<p>其次，max 代码使用 if 语句比较 x 和 y 的大小，并返回两者中较大的值，但是它没有使用所谓的 return 关键字，而是直接写了 x 或 y。<strong>在 Scala 中，函数体具体代码块最后一行的值将被作为函数结果返回</strong>。在这个例子中，if 分支代码块的最后一行是 x，因此，此路分支返回 x。同理，else 分支返回 y。</p>
<p>讲完了 max 函数，我再用 Kafka 源码中的一个真实函数，来帮你进一步地理解 Scala 函数：</p>
<p>def deleteIndicesIfExist(<br>
// 这里参数 suffix 的默认值是&quot;&quot;，即空字符串<br>
// 函数结尾处的 Unit 类似于 Java 中的 void 关键字，表示该函数不返回任何结果<br>
baseFile: File, suffix: String = &ldquo;&rdquo;): Unit = {<br>
info(s&quot;Deleting index files with suffix $suffix for baseFile $baseFile&quot;)<br>
val offset = offsetFromFile(baseFile)<br>
Files.deleteIfExists(Log.offsetIndexFile(dir, offset, suffix).toPath)<br>
Files.deleteIfExists(Log.timeIndexFile(dir, offset, suffix).toPath)<br>
Files.deleteIfExists(Log.transactionIndexFile(dir, offset, suffix).toPath)<br>
}</p>
<p>和上面的 max 函数相比，这个函数有两个额外的语法特性需要你了解。</p>
<p>第一个特性是<strong>参数默认值</strong>，这是 Java 不支持的。这个函数的参数 suffix 默认值是空字符串，因此，以下两种调用方式都是合法的：</p>
<p>deleteIndicesIfExist(baseFile) // OK<br>
deleteIndicesIfExist(baseFile, &ldquo;.swap&rdquo;) // OK</p>
<p>第二个特性是<strong>该函数的返回值 Unit</strong>。Scala 的 Unit 类似于 Java 的 void，因此，deleteIndicesIfExist 函数的返回值是 Unit 类型，表明它仅仅是执行一段逻辑代码，不需要返回任何结果。</p>
<h2 id="定义元组tuple">定义元组（Tuple）</h2>
<p>接下来，我们来看下 Scala 中的元组概念。<strong>元组是承载数据的容器，一旦被创建，就不能再被更改了</strong>。元组中的数据可以是不同数据类型的。定义和访问元组的方法很简单，请看下面的代码：</p>
<p>scala&gt; val a = (1, 2.3, &ldquo;hello&rdquo;, List(1,2,3)) // 定义一个由 4 个元素构成的元组，每个元素允许是不同的类型<br>
a: (Int, Double, String, List[Int]) = (1,2.3,hello,List(1, 2, 3))</p>
<p>scala&gt; a._1 // 访问元组的第一个元素<br>
res0: Int = 1</p>
<p>scala&gt; a._2 // 访问元组的第二个元素<br>
res1: Double = 2.3</p>
<p>scala&gt; a._3 // 访问元组的第三个元素<br>
res2: String = hello</p>
<p>scala&gt; a._4 // 访问元组的第四个元素<br>
res3: List[Int] = List(1, 2, 3)</p>
<p>总体上而言，元组的用法简单而优雅。Kafka 源码中也有很多使用元组的例子，比如：</p>
<p>def checkEnoughReplicasReachOffset(requiredOffset: Long): (Boolean, Errors) = { // 返回 (Boolean，Errors) 类型的元组<br>
&hellip;&hellip;<br>
if (minIsr &lt;= curInSyncReplicaIds.size) {<br>
&hellip;&hellip;<br>
(true, Errors.NONE)<br>
} else<br>
(false, Errors.NOT_ENOUGH_REPLICAS_AFTER_APPEND)<br>
}</p>
<p>checkEnoughReplicasReachOffset 方法返回一个 (Boolean, Errors) 类型的元组，即元组的第一个元素或字段是 Boolean 类型，第二个元素是 Kafka 自定义的 Errors 类型。</p>
<p>该方法会判断某分区 ISR 中副本的数量，是否大于等于所需的最小 ISR 副本数，如果是，就返回（true, Errors.NONE）元组，否则返回（false，Errors.NOT_ENOUGH_REPLICAS_AFTER_APPEND）。目前，你不必理会代码中 minIsr 或 curInSyncReplicaIds 的含义，仅仅掌握 Kafka 源码中的元组用法就够了。</p>
<h2 id="循环写法">循环写法</h2>
<p>下面我们来看下 Scala 中循环的写法。我们常见的循环有两种写法：<strong>命令式编程方式</strong>和<strong>函数式编程方式</strong>。我们熟悉的是第一种，比如下面的 for 循环代码：</p>
<p>scala&gt; val list = List(1, 2, 3, 4, 5)<br>
list: List[Int] = List(1, 2, 3, 4, 5)</p>
<p>scala&gt; for (element &lt;- list) println(element)<br>
1<br>
2<br>
3<br>
4<br>
5</p>
<p>Scala 支持的函数式编程风格的循环，类似于下面的这种代码：</p>
<p>scala&gt; list.foreach(e =&gt; println(e))<br>
// 省略输出&hellip;&hellip;<br>
scala&gt; list.foreach(println)<br>
// 省略输出&hellip;&hellip;</p>
<p>特别是代码中的第二种写法，会让代码写得异常简洁。我用一段真实的 Kafka 源码再帮你加强下记忆。它取自 SocketServer 组件中 stopProcessingRequests 方法，主要目的是让 Broker 停止请求和新入站 TCP 连接的处理。SocketServer 组件是实现 Kafka 网络通信的重要组件，后面我会花 3 节课的时间专门讨论它。这里，咱们先来学习下这段明显具有函数式风格的代码：</p>
<p>// dataPlaneAcceptors:ConcurrentHashMap&lt;Endpoint, Acceptor&gt;对象<br>
dataPlaneAcceptors.asScala.values.foreach(_.initiateShutdown())</p>
<p>这一行代码首先调用 asScala 方法，将 Java 的 ConcurrentHashMap 转换成 Scala 语言中的 concurrent.Map 对象；然后获取它保存的所有 Acceptor 线程，通过 foreach 循环，调用每个 Acceptor 对象的 initiateShutdown 方法。如果这个逻辑用命令式编程来实现，至少要几行甚至是十几行才能完成。</p>
<h2 id="case-类">case 类</h2>
<p>在 Scala 中，case 类与普通类是类似的，只是它具有一些非常重要的不同点。Case 类非常适合用来表示不可变数据。同时，它最有用的一个特点是，case 类自动地为所有类字段定义 Getter 方法，这样能省去很多样本代码。我举个例子说明一下。</p>
<p>如果我们要编写一个类表示平面上的一个点，Java 代码大概长这个样子：</p>
<p>public final class Point {<br>
private int x;<br>
private int y;<br>
public Point(int x, int y) {<br>
this.x = x;<br>
this.y = y;<br>
}<br>
// setter methods&hellip;&hellip;<br>
// getter methods&hellip;&hellip;<br>
}</p>
<p>我就不列出完整的 Getter 和 Setter 方法了，写过 Java 的你一定知道这些样本代码。但如果用 Scala 的 case 类，只需要写一行代码就可以了：</p>
<p>case class Point(x:Int, y: Int) // 默认写法。不能修改 x 和 y<br>
case class Point(var x: Int, var y: Int) // 支持修改 x 和 y</p>
<p>Scala 会自动地帮你创建出 x 和 y 的 Getter 方法。默认情况下，x 和 y 不能被修改，如果要支持修改，你要采用上面代码中第二行的写法。</p>
<h2 id="模式匹配">模式匹配</h2>
<p>有了 case 类的基础，接下来我们就可以学习下 Scala 中强大的模式匹配功能了。</p>
<p>和 Java 中 switch 仅仅只能比较数值和字符串相比，Scala 中的 match 要强大得多。我先来举个例子：</p>
<p>def describe(x: Any) = x match {<br>
case 1 =&gt; &ldquo;one&rdquo;<br>
case false =&gt; &ldquo;False&rdquo;<br>
case &ldquo;hi&rdquo; =&gt; &ldquo;hello, world!&rdquo;<br>
case Nil =&gt; &ldquo;the empty list&rdquo;<br>
case e: IOException =&gt; &ldquo;this is an IOException&rdquo;<br>
case s: String if s.length &gt; 10 =&gt; &ldquo;a long string&rdquo;<br>
case _ =&gt; &ldquo;something else&rdquo;<br>
}</p>
<p>这个函数的 x 是 Any 类型，这相当于 Java 中的 Object 类型，即所有类的父类。注意倒数第二行的“case _”的写法，它是用来兜底的。如果上面的所有 case 分支都不匹配，那就进入到这个分支。另外，它还支持一些复杂的表达式，比如倒数第三行的 case 分支，表示 x 是字符串类型，而且 x 的长度超过 10 的话，就进入到这个分支。</p>
<p>要知道，Java 在 JDK 14 才刚刚引入这个相同的功能，足见 Scala 语法的强大和便捷。</p>
<h2 id="option-对象">Option 对象</h2>
<p>最后，我再介绍一个小的语法特性或语言特点：<strong>Option 对象</strong>。</p>
<p>实际上，Java 也引入了类似的类：Optional。根据我的理解，不论是 Scala 中的 Option，还是 Java 中的 Optional，都是用来帮助我们更好地规避 NullPointerException 异常的。</p>
<p>Option 表示一个容器对象，里面可能装了值，也可能没有装任何值。由于是容器，因此一般都是这样的写法：Option[Any]。中括号里面的 Any 就是上面说到的 Any 类型，它能是任何类型。如果值存在的话，就可以使用 Some(x) 来获取值或给值赋值，否则就使用 None 来表示。我用一段代码帮助你理解：</p>
<p>scala&gt; val keywords = Map(&ldquo;scala&rdquo; -&gt; &ldquo;option&rdquo;, &ldquo;java&rdquo; -&gt; &ldquo;optional&rdquo;) // 创建一个 Map 对象<br>
keywords: scala.collection.immutable.Map[String,String] = Map(scala -&gt; option, java -&gt; optional)</p>
<p>scala&gt; keywords.get(&ldquo;java&rdquo;) // 获取 key 值为 java 的 value 值。由于值存在故返回 Some(optional)<br>
res24: Option[String] = Some(optional)</p>
<p>scala&gt; keywords.get(&ldquo;C&rdquo;) // 获取 key 值为 C 的 value 值。由于不存在故返回 None<br>
res23: Option[String] = None</p>
<p>Option 对象还经常与模式匹配语法一起使用，以实现不同情况下的处理逻辑。比如，Option 对象有值和没有值时分别执行什么代码。具体写法你可以参考下面这段代码：</p>
<p>def display(game: Option[String]) = game match {<br>
case Some(s) =&gt; s<br>
case None =&gt; &ldquo;unknown&rdquo;<br>
}</p>
<p>scala&gt; display(Some(&ldquo;Heroes 3&rdquo;))<br>
res26: String = Heroes 3</p>
<p>scala&gt; display(Some(&ldquo;StarCraft&rdquo;))<br>
res27: String = StarCraft</p>
<p>scala&gt; display(None)<br>
res28: String = unknown</p>
<h2 id="总结">总结</h2>
<p>今天，我们专门花了些时间快速地学习了一下 Scala 语言的语法，这些语法能够帮助你更快速地上手 Kafka 源码的学习。现在，让我们再来看下这节课刚开始时我提到的 getLag 方法源码，你看看现在是否能够说出它的含义。我再次把它贴出来：</p>
<p>private def getLag(offset: Option[Long], logEndOffset: Option[Long]): Option[Long] =<br>
offset.filter(_ != -1).flatMap(offset =&gt; logEndOffset.map(_ - offset))</p>
<p>现在，你应该知道了，它是一个函数，接收两个类型为 Option[Long] 的参数，同时返回一个 Option[Long] 的结果。代码逻辑很简单，首先判断 offset 是否有值且不能是 -1。这些都是在 filter 函数中完成的，之后调用 flatMap 方法计算 logEndOffset 值与 offset 的差值，最后返回这个差值作为 Lag。</p>
<p>这节课结束以后，语言问题应该不再是你学习源码的障碍了，接下来，我们就可以继续专心地学习源码了。借着这个机会，我还想跟你多说几句。</p>
<p>很多时候，我们都以为，要有足够强大的毅力才能把源码学习坚持下去，但实际上，毅力是在你读源码的过程中培养起来的。</p>
<p>考虑到源码并不像具体技术本身那样容易掌握，我力争用最清晰易懂的方式来讲这门课。所以，我希望你每天都能花一点点时间跟着我一起学习，我相信，到结课的时候，你不仅可以搞懂 Kafka Broker 端源码，还能提升自己的毅力。而毅力和执行力的提升，可能比技术本身的提升还要弥足珍贵。</p>
<p>另外，我还想给你分享一个小技巧：想要养成每天阅读源码的习惯，你最好把目标拆解得足够小。人的大脑都是有惰性的，比起“我每天要读 1000 行源码”，它更愿意接受“每天只读 20 行”。你可能会说，每天读 20 行，这也太少了吧？其实不是的。只要你读了 20 行源码，你就一定能再多读一些，“20 行”这个小目标只是为了促使你愿意开始去做这件事情。而且，即使你真的只读了 20 行，那又怎样？读 20 行总好过 1 行都没有读，对吧？</p>
<p>当然了，阅读源码经常会遇到一种情况，那就是读不懂某部分的代码。没关系，读不懂的代码，你可以选择先跳过。</p>
<p>如果你是个追求完美的人，那么对于读不懂的代码，我给出几点建议：</p>
<ol>
<li><strong>多读几遍</strong>。不要小看这个朴素的建议。有的时候，我们的大脑是很任性的，只让它看一遍代码，它可能“傲娇地表示不理解”，但你多给它看几遍，也许就恍然大悟了。</li>
<li><strong>结合各种资料来学习</strong>。比如，社区或网上关于这部分代码的设计文档、源码注释或源码测试用例等。尤其是搞懂测试用例，往往是让我们领悟代码精神最快捷的办法了。</li>
</ol>
<p>总之，阅读源码是一项长期的工程，不要幻想有捷径或一蹴而就，微小积累会引发巨大改变，我们一起加油。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Kafka核心源码解读</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/%E8%87%B4%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84%E4%B8%93%E6%A0%8F%E8%AE%A2%E9%98%85%E7%94%A8%E6%88%B7/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">致「从0开始学架构」专栏订阅用户</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/%E5%91%A8%E6%9C%AB%E7%A6%8F%E5%88%A9__%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9java%E5%AD%A6%E4%B9%A0%E5%92%8C%E9%9D%A2%E8%AF%95%E7%9A%84%E7%9C%8B%E6%B3%95/">
            <span class="next-text nav-default">周末福利__谈谈我对Java学习和面试的看法</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
