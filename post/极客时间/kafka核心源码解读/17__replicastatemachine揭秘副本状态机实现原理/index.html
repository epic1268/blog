<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>17__ReplicaStateMachine：揭秘副本状态机实现原理 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是胡夕。今天我们讲副本状态机。
前几节课，在讲 Controller、TopicDeletionManager 时，我反复提到副本状态机和分区状态机这两个组件。现在，你应该知道了，它们分别管理着 Kafka 集群中所有副本和分区的状态转换，但是，你知道副本和分区到底都有哪些状态吗？
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/17__replicastatemachine%E6%8F%AD%E7%A7%98%E5%89%AF%E6%9C%AC%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/17__replicastatemachine%E6%8F%AD%E7%A7%98%E5%89%AF%E6%9C%AC%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="17__ReplicaStateMachine：揭秘副本状态机实现原理">
  <meta property="og:description" content="你好，我是胡夕。今天我们讲副本状态机。
前几节课，在讲 Controller、TopicDeletionManager 时，我反复提到副本状态机和分区状态机这两个组件。现在，你应该知道了，它们分别管理着 Kafka 集群中所有副本和分区的状态转换，但是，你知道副本和分区到底都有哪些状态吗？">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Kafka核心源码解读">

  <meta itemprop="name" content="17__ReplicaStateMachine：揭秘副本状态机实现原理">
  <meta itemprop="description" content="你好，我是胡夕。今天我们讲副本状态机。
前几节课，在讲 Controller、TopicDeletionManager 时，我反复提到副本状态机和分区状态机这两个组件。现在，你应该知道了，它们分别管理着 Kafka 集群中所有副本和分区的状态转换，但是，你知道副本和分区到底都有哪些状态吗？">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7272">
  <meta itemprop="keywords" content="Kafka核心源码解读">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="17__ReplicaStateMachine：揭秘副本状态机实现原理">
  <meta name="twitter:description" content="你好，我是胡夕。今天我们讲副本状态机。
前几节课，在讲 Controller、TopicDeletionManager 时，我反复提到副本状态机和分区状态机这两个组件。现在，你应该知道了，它们分别管理着 Kafka 集群中所有副本和分区的状态转换，但是，你知道副本和分区到底都有哪些状态吗？">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">17__ReplicaStateMachine：揭秘副本状态机实现原理</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7272 字 </span>
          <span class="more-meta"> 预计阅读 15 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#课前导读">课前导读</a></li>
        <li><a href="#定义与初始化">定义与初始化</a></li>
        <li><a href="#副本状态及状态管理流程">副本状态及状态管理流程</a></li>
        <li><a href="#具体实现类zkreplicastatemachine">具体实现类：ZkReplicaStateMachine</a>
          <ul>
            <li><a href="#状态转换方法定义">状态转换方法定义</a></li>
            <li><a href="#handlestatechanges-方法">handleStateChanges 方法</a></li>
            <li><a href="#dohandlestatechanges-方法">doHandleStateChanges 方法</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#课后讨论">课后讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是胡夕。今天我们讲副本状态机。</p>
<p>前几节课，在讲 Controller、TopicDeletionManager 时，我反复提到副本状态机和分区状态机这两个组件。现在，你应该知道了，它们分别管理着 Kafka 集群中所有副本和分区的状态转换，但是，你知道副本和分区到底都有哪些状态吗？</p>
<p>带着这个问题，我们用两节课的时间，重点学习下这两个组件的源码。我们先从副本状态机（ReplicaStateMachine）开始。</p>
<h2 id="课前导读">课前导读</h2>
<p>坦率地说，ReplicaStateMachine 不如前面的组件有名气，Kafka 官网文档中甚至没有任何关于它的描述，可见，它是一个内部组件，一般用户感觉不到它的存在。因此，很多人都会有这样的错觉：既然它是外部不可见的组件，那就没有必要学习它的实现代码了。</p>
<p>其实不然。弄明白副本状态机的原理，对于我们从根本上定位很多数据不一致问题是有帮助的。下面，我跟你分享一个我的真实经历。</p>
<p>曾经，我们部署过一个 3-Broker 的 Kafka 集群，版本是 2.0.0。假设这 3 个 Broker 是 A、B 和 C，我们在这 3 个 Broker 上创建了一个单分区、双副本的主题。</p>
<p>当时，我们发现了一个奇怪的现象：如果两个副本分别位于 A 和 B，而 Controller 在 C 上，那么，当关闭 A、B 之后，ZooKeeper 中会显示该主题的 Leader 是 -1，ISR 为空；但是，如果两个副本依然位于 A 和 B 上，而 Controller 在 B 上，当我们依次关闭 A 和 B 后，该主题在 ZooKeeper 中的 Leader 和 ISR 就变成了 B。这显然和刚刚的情况不符。</p>
<p>虽然这并不是特别严重的问题，可毕竟出现了数据的不一致性，所以还是需要谨慎对待。在仔细查看源码之后，我们找到了造成不一致的原因：原来，在第一种情况下，Controller 会调用 ReplicaStateMachine，调整该主题副本的状态，进而变更了 Leader 和 ISR；而在第二种情况下，Controller 执行了 Failover，但是并未在新 Controller 组件初始化时进行状态转换，因而出现了不一致。</p>
<p>你看，要是不阅读这部分源码，我们肯定是无法定位这个问题的原因的。总之，副本状态机代码定义了 Kafka 副本的状态集合，同时控制了这些状态之间的流转规则。对于想要深入了解内部原理的你来说，短小精悍的 ReplicaStateMachine 源码是绝对不能错过的。</p>
<h2 id="定义与初始化">定义与初始化</h2>
<p>今天，我们要关注的源码文件是 controller 包下的 ReplicaStateMachine.scala 文件。它的代码结构非常简单，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/37770a1f732f61342f4a8268a98a9143.png" alt=""></p>
<p>在不到 500 行的源文件中，代码定义了 3 个部分。</p>
<ol>
<li>ReplicaStateMachine：副本状态机抽象类，定义了一些常用方法（如 startup、shutdown 等），以及状态机最重要的处理逻辑方法 handleStateChanges。</li>
<li>ZkReplicaStateMachine：副本状态机具体实现类，重写了 handleStateChanges 方法，实现了副本状态之间的状态转换。目前，ZkReplicaStateMachine 是唯一的 ReplicaStateMachine 子类。</li>
<li>ReplicaState：副本状态集合，Kafka 目前共定义了 7 种副本状态。</li>
</ol>
<p>下面，我们看下 ReplicaStateMachine 及其子类 ZKReplicaStateMachine 在代码中是如何定义的，请看这两个代码片段：</p>
<p>// ReplicaStateMachine 抽象类定义<br>
abstract class ReplicaStateMachine(controllerContext: ControllerContext) extends Logging {<br>
&hellip;&hellip;<br>
}</p>
<p>// ZkReplicaStateMachine 具体实现类定义<br>
class ZkReplicaStateMachine(config: KafkaConfig,<br>
stateChangeLogger: StateChangeLogger,<br>
controllerContext: ControllerContext,<br>
zkClient: KafkaZkClient,<br>
controllerBrokerRequestBatch: ControllerBrokerRequestBatch)<br>
extends ReplicaStateMachine(controllerContext) with Logging {<br>
&hellip;&hellip;<br>
}</p>
<p>ReplicaStateMachine 只需要接收一个 ControllerContext 对象实例。在前几节课，我反复说过，ControllerContext 封装了 Controller 端保存的所有集群元数据信息。</p>
<p>ZKReplicaStateMachine 的属性则多一些。如果要构造一个 ZKReplicaStateMachine 实例，除了 ControllerContext 实例，比较重要的属性还有 <strong>KafkaZkClient 对象实例</strong>和 <strong>ControllerBrokerRequestBatch 实例</strong>。前者负责与 ZooKeeper 进行交互；后者用于给集群 Broker 发送控制类请求（也就是咱们在第 12 节课重点讲过的 LeaderAndIsrRequest、StopReplicaRequest 和 UpdateMetadataRequest）。</p>
<p>ControllerBrokerRequestBatch 对象的源码位于 ControllerChannelManager.scala 中，这是一个只有 10 行代码的类，主要的功能是将给定的 Request 发送给指定的 Broker，你可以自行探索下它是如何发送请求的。（给你个提示：结合我们在第 12 节课讲到的 ControllerBrokerStateInfo 代码进行思考。）</p>
<p>在副本状态转换操作的逻辑中，一个很重要的步骤，就是为 Broker 上的副本更新信息，而这是通过 Controller 给 Broker 发送请求实现的，因此，你最好了解下这里的请求发送逻辑。</p>
<p>好了，学习了副本状态机类的定义，下面我们看下副本状态机是在何时进行初始化的。</p>
<p>一句话总结就是，<strong>KafkaController 对象在构建的时候，就会初始化一个 ZkReplicaStateMachine 实例</strong>，如下列代码所示：</p>
<p>val replicaStateMachine: ReplicaStateMachine = new  <br>
ZkReplicaStateMachine(config, stateChangeLogger,<br>
controllerContext, zkClient,<br>
new ControllerBrokerRequestBatch(config, controllerChannelManager, eventManager, controllerContext, stateChangeLogger))</p>
<p>你可能会问：“如果一个 Broker 没有被选举为 Controller，它也会构建 KafkaController 对象实例吗？”没错！所有 Broker 在启动时，都会创建 KafkaController 实例，因而也会创建 ZKReplicaStateMachine 实例。</p>
<p>每个 Broker 都会创建这些实例，并不代表每个 Broker 都会启动副本状态机。事实上，只有在 Controller 所在的 Broker 上，副本状态机才会被启动。具体的启动代码位于 KafkaController 的 onControllerFailover 方法，如下所示：</p>
<p>private def onControllerFailover(): Unit = {<br>
&hellip;&hellip;<br>
replicaStateMachine.startup() // 启动副本状态机<br>
partitionStateMachine.startup() // 启动分区状态机<br>
&hellip;&hellip;<br>
}</p>
<p>当 Broker 被成功推举为 Controller 后，onControllerFailover 方法会被调用，进而启动该 Broker 早已创建好的副本状态机和分区状态机。</p>
<h2 id="副本状态及状态管理流程">副本状态及状态管理流程</h2>
<p>副本状态机一旦被启动，就意味着它要行使它最重要的职责了：<strong>管理副本状态的转换</strong>。</p>
<p>不过，在学习如何管理状态之前，我们必须要弄明白，当前都有哪些状态，以及它们的含义分别是什么。源码中的 ReplicaState 定义了 7 种副本状态。</p>
<ol>
<li>NewReplica：副本被创建之后所处的状态。</li>
<li>OnlineReplica：副本正常提供服务时所处的状态。</li>
<li>OfflineReplica：副本服务下线时所处的状态。</li>
<li>ReplicaDeletionStarted：副本被删除时所处的状态。</li>
<li>ReplicaDeletionSuccessful：副本被成功删除后所处的状态。</li>
<li>ReplicaDeletionIneligible：开启副本删除，但副本暂时无法被删除时所处的状态。</li>
<li>NonExistentReplica：副本从副本状态机被移除前所处的状态。</li>
</ol>
<p>具体到代码而言，<strong>ReplicaState 接口及其实现对象定义了每种状态的序号，以及合法的前置状态</strong>。我以 OnlineReplica 代码为例进行说明：</p>
<p>// ReplicaState 接口<br>
sealed trait ReplicaState {<br>
def state: Byte<br>
def validPreviousStates: Set[ReplicaState] // 定义合法的前置状态<br>
}</p>
<p>// OnlineReplica 状态<br>
case object OnlineReplica extends ReplicaState {<br>
val state: Byte = 2<br>
val validPreviousStates: Set[ReplicaState] = Set(NewReplica, OnlineReplica, OfflineReplica, ReplicaDeletionIneligible)<br>
}</p>
<p>OnlineReplica 的 validPreviousStates 属性是一个集合类型，里面包含 NewReplica、OnlineReplica、OfflineReplica 和 ReplicaDeletionIneligible。这说明，Kafka 只允许副本从刚刚这 4 种状态变更到 OnlineReplica 状态。如果从 ReplicaDeletionStarted 状态跳转到 OnlineReplica 状态，就是非法的状态转换。</p>
<p>这里，我只列出了 OnlineReplica。实际上，其他 6 种副本状态的代码逻辑也是类似的，因为比较简单，我就不一一介绍了，课下你可以对照着源码自己探索下，重点关注这些状态的 validPreviousStates 字段，看看每个状态合法的前置状态都有哪些。</p>
<p>为了方便你记忆，我直接帮你提炼了出来了。这张图绘制出了完整的状态转换规则：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/f5f8e86908fd523e1a0f26a7eed6891b.png" alt=""></p>
<p>图中的单向箭头表示只允许单向状态转换，双向箭头则表示转换方向可以是双向的。比如，OnlineReplica 和 OfflineReplica 之间有一根双向箭头，这就说明，副本可以在 OnlineReplica 和 OfflineReplica 状态之间随意切换。</p>
<p>结合这张图，我再详细解释下各个状态的含义，以及它们的流转过程。</p>
<p>当副本对象首次被创建出来后，它会被置于 NewReplica 状态。经过一番初始化之后，当副本对象能够对外提供服务之后，状态机会将其调整为 OnlineReplica，并一直以该状态持续工作。</p>
<p>如果副本所在的 Broker 关闭或者是因为其他原因不能正常工作了，副本需要从 OnlineReplica 变更为 OfflineReplica，表明副本已处于离线状态。</p>
<p>一旦开启了如删除主题这样的操作，状态机会将副本状态跳转到 ReplicaDeletionStarted，以表明副本删除已然开启。倘若删除成功，则置为 ReplicaDeletionSuccessful，倘若不满足删除条件（如所在 Broker 处于下线状态），那就设置成 ReplicaDeletionIneligible，以便后面重试。</p>
<p>当副本对象被删除后，其状态会变更为 NonExistentReplica，副本状态机将移除该副本数据。</p>
<p>这就是一个基本的状态管理流程。</p>
<h2 id="具体实现类zkreplicastatemachine">具体实现类：ZkReplicaStateMachine</h2>
<p>了解了这些状态之后，我们来看下 ZkReplicaStateMachine 类的原理，毕竟，它是副本状态机的具体实现类。</p>
<p>该类定义了 1 个 public 方法和 7 个 private 方法。这个 public 方法是副本状态机最重要的逻辑处理代码，它就是 handleStateChanges 方法。而那 7 个方法全部都是用来辅助 public 方法的。</p>
<h3 id="状态转换方法定义">状态转换方法定义</h3>
<p>在详细介绍 handleStateChanges 方法前，我稍微花点时间，给你简单介绍下其他 7 个方法都是做什么用的。就像前面说过的，这些方法主要是起辅助的作用。只有清楚了这些方法的用途，你才能更好地理解 handleStateChanges 的实现逻辑。</p>
<ol>
<li>logFailedStateChange：仅仅是记录一条错误日志，表明执行了一次无效的状态变更。</li>
<li>logInvalidTransition：同样也是记录错误之用，记录一次非法的状态转换。</li>
<li>logSuccessfulTransition：记录一次成功的状态转换操作。</li>
<li>getTopicPartitionStatesFromZk：从 ZooKeeper 中获取指定分区的状态信息，包括每个分区的 Leader 副本、ISR 集合等数据。</li>
<li>doRemoveReplicasFromIsr：把给定的副本对象从给定分区 ISR 中移除。</li>
<li>removeReplicasFromIsr：调用 doRemoveReplicasFromIsr 方法，实现将给定的副本对象从给定分区 ISR 中移除的功能。</li>
<li>doHandleStateChanges：执行状态变更和转换操作的主力方法。接下来，我们会详细学习它的源码部分。</li>
</ol>
<h3 id="handlestatechanges-方法">handleStateChanges 方法</h3>
<p>handleStateChange 方法的作用是处理状态的变更，是对外提供状态转换操作的入口方法。其方法签名如下：</p>
<p>def handleStateChanges(replicas: Seq[PartitionAndReplica], targetState: ReplicaState): Unit</p>
<p>该方法接收两个参数：<strong>replicas</strong> 是一组副本对象，每个副本对象都封装了它们各自所属的主题、分区以及副本所在的 Broker ID 数据；<strong>targetState</strong> 是这组副本对象要转换成的目标状态。</p>
<p>这个方法的完整代码如下：</p>
<p>override def handleStateChanges(<br>
replicas: Seq[PartitionAndReplica],<br>
targetState: ReplicaState): Unit = {<br>
if (replicas.nonEmpty) {<br>
try {<br>
// 清空 Controller 待发送请求集合<br>
controllerBrokerRequestBatch.newBatch()<br>
// 将所有副本对象按照 Broker 进行分组，依次执行状态转换操作<br>
replicas.groupBy(_.replica).foreach {<br>
case (replicaId, replicas) =&gt;<br>
doHandleStateChanges(replicaId, replicas, targetState)<br>
}<br>
// 发送对应的 Controller 请求给 Broker<br>
controllerBrokerRequestBatch.sendRequestsToBrokers(<br>
controllerContext.epoch)<br>
} catch {<br>
// 如果 Controller 易主，则记录错误日志然后抛出异常<br>
case e: ControllerMovedException =&gt;<br>
error(s&quot;Controller moved to another broker when moving some replicas to $targetState state&quot;, e)<br>
throw e<br>
case e: Throwable =&gt; error(s&quot;Error while moving some replicas to $targetState state&quot;, e)<br>
}<br>
}<br>
}</p>
<p>代码逻辑总体上分为两步：第 1 步是调用 doHandleStateChanges 方法执行真正的副本状态转换；第 2 步是给集群中的相应 Broker 批量发送请求。</p>
<p>在执行第 1 步的时候，它会将 replicas 按照 Broker ID 进行分组。</p>
<p>举个例子，如果我们使用 &lt; 主题名，分区号，副本 Broker ID&gt; 表示副本对象，假设 replicas 为集合（&lt;test, 0, 0&gt;, &lt;test, 0, 1&gt;, &lt;test, 1, 0&gt;, &lt;test, 1, 1&gt;），那么，在调用 doHandleStateChanges 方法前，代码会将 replicas 按照 Broker ID 进行分组，即变成：Map(0 -&gt; Set(&lt;test, 0, 0&gt;, &lt;test, 1, 0&gt;)，1 -&gt; Set(&lt;test, 0, 1&gt;, &lt;test, 1, 1&gt;))。</p>
<p>待这些都做完之后，代码开始调用 doHandleStateChanges 方法，执行状态转换操作。这个方法看着很长，其实都是不同的代码分支。</p>
<h3 id="dohandlestatechanges-方法">doHandleStateChanges 方法</h3>
<p>我先用一张图，帮你梳理下它的流程，然后再具体分析下它的代码：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/f6fe372c6c69c71f4ed80567ca45b7de.png" alt=""></p>
<p>从图中，我们可以发现，代码的第 1 步，会尝试获取给定副本对象在 Controller 端元数据缓存中的当前状态，如果没有保存某个副本对象的状态，代码会将其初始化为 NonExistentReplica 状态。</p>
<p>第 2 步，代码根据不同 ReplicaState 中定义的合法前置状态集合以及传入的目标状态（targetState），将给定的副本对象集合划分成两部分：能够合法转换的副本对象集合，以及执行非法状态转换的副本对象集合。doHandleStateChanges 方法会为后者中的每个副本对象记录一条错误日志。</p>
<p>第 3 步，代码携带能够执行合法转换的副本对象集合，进入到不同的代码分支。由于当前 Kafka 为副本定义了 7 类状态，因此，这里的代码分支总共有 7 路。</p>
<p>我挑选几路最常见的状态转换路径详细说明下，包括副本被创建时被转换到 NewReplica 状态，副本正常工作时被转换到 OnlineReplica 状态，副本停止服务后被转换到 OfflineReplica 状态。至于剩下的记录代码，你可以在课后自行学习下，它们的转换操作原理大致是相同的。</p>
<h4 id="第-1-路转换到-newreplica-状态">第 1 路：转换到 NewReplica 状态</h4>
<p>首先，我们先来看第 1 路，即目标状态是 NewReplica 的代码。代码如下：</p>
<p>case NewReplica =&gt;<br>
// 遍历所有能够执行转换的副本对象<br>
validReplicas.foreach { replica =&gt;<br>
// 获取该副本对象的分区对象，即&lt;主题名，分区号&gt;数据<br>
val partition = replica.topicPartition<br>
// 获取副本对象的当前状态<br>
val currentState = controllerContext.replicaState(replica)<br>
// 尝试从元数据缓存中获取该分区当前信息<br>
// 包括 Leader 是谁、ISR 都有哪些副本等数据<br>
controllerContext.partitionLeadershipInfo.get(partition) match {<br>
// 如果成功拿到分区数据信息<br>
case Some(leaderIsrAndControllerEpoch) =&gt;<br>
// 如果该副本是 Leader 副本<br>
if (leaderIsrAndControllerEpoch.leaderAndIsr.leader == replicaId) {<br>
val exception = new StateChangeFailedException(s&quot;Replica $replicaId for partition $partition cannot be moved to NewReplica state as it is being requested to become leader&quot;)<br>
// 记录错误日志。Leader 副本不能被设置成 NewReplica 状态<br>
logFailedStateChange(replica, currentState, OfflineReplica, exception)<br>
// 否则，给该副本所在的 Broker 发送 LeaderAndIsrRequest<br>
// 向它同步该分区的数据，之后给集群当前所有 Broker 发送<br>
// UpdateMetadataRequest 通知它们该分区数据发生变更<br>
} else {<br>
controllerBrokerRequestBatch<br>
.addLeaderAndIsrRequestForBrokers(<br>
Seq(replicaId),<br>
replica.topicPartition,<br>
leaderIsrAndControllerEpoch,<br>
controllerContext.partitionFullReplicaAssignment(<br>
replica.topicPartition),<br>
isNew = true)<br>
if (traceEnabled)<br>
logSuccessfulTransition(<br>
stateLogger, replicaId,<br>
partition, currentState, NewReplica)<br>
// 更新元数据缓存中该副本对象的当前状态为 NewReplica<br>
controllerContext.putReplicaState(replica, NewReplica)<br>
}<br>
// 如果没有相应数据<br>
case None =&gt;<br>
if (traceEnabled)<br>
logSuccessfulTransition(<br>
stateLogger, replicaId,<br>
partition, currentState, NewReplica)<br>
// 仅仅更新元数据缓存中该副本对象的当前状态为 NewReplica 即可<br>
controllerContext.putReplicaState(replica, NewReplica)<br>
}<br>
}</p>
<p>看完了代码，你可以再看下这张流程图：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/90fc0cb2589e15d85203a4b36af52b92.png" alt=""></p>
<p>这一路主要做的事情是，尝试从元数据缓存中，获取这些副本对象的分区信息数据，包括分区的 Leader 副本在哪个 Broker 上、ISR 中都有哪些副本，等等。</p>
<p>如果找不到对应的分区数据，就直接把副本状态更新为 NewReplica。否则，代码就需要给该副本所在的 Broker 发送请求，让它知道该分区的信息。同时，代码还要给集群所有运行中的 Broker 发送请求，让它们感知到新副本的加入。</p>
<h4 id="第-2-路转换到-onlinereplica-状态">第 2 路：转换到 OnlineReplica 状态</h4>
<p>下面我们来看第 2 路，即转换副本对象到 OnlineReplica。</p>
<p>刚刚我说过，这是副本对象正常工作时所处的状态。我们来看下要转换到这个状态，源码都做了哪些事情：</p>
<p>case OnlineReplica =&gt;<br>
validReplicas.foreach { replica =&gt;<br>
// 获取副本所在分区<br>
val partition = replica.topicPartition<br>
// 获取副本当前状态<br>
val currentState = controllerContext.replicaState(replica)<br>
currentState match {<br>
// 如果当前状态是 NewReplica<br>
case NewReplica =&gt;<br>
// 从元数据缓存中拿到分区副本列表<br>
val assignment = controllerContext<br>
.partitionFullReplicaAssignment(partition)<br>
// 如果副本列表不包含当前副本，视为异常情况<br>
if (!assignment.replicas.contains(replicaId)) {<br>
error(s&quot;Adding replica ($replicaId) that is not part of the assignment $assignment&quot;)<br>
// 将该副本加入到副本列表中，并更新元数据缓存中该分区的副本列表<br>
val newAssignment = assignment.copy(<br>
replicas = assignment.replicas :+ replicaId)<br>
controllerContext.updatePartitionFullReplicaAssignment(<br>
partition, newAssignment)<br>
}<br>
// 如果当前状态是其他状态<br>
case _ =&gt;<br>
// 尝试获取该分区当前信息数据<br>
controllerContext.partitionLeadershipInfo<br>
.get(partition) match {<br>
// 如果存在分区信息<br>
// 向该副本对象所在 Broker 发送请求，令其同步该分区数据<br>
case Some(leaderIsrAndControllerEpoch) =&gt;<br>
controllerBrokerRequestBatch<br>
.addLeaderAndIsrRequestForBrokers(Seq(replicaId),<br>
replica.topicPartition,<br>
leaderIsrAndControllerEpoch,<br>
controllerContext<br>
.partitionFullReplicaAssignment(partition),<br>
isNew = false)<br>
case None =&gt;<br>
}<br>
}<br>
if (traceEnabled)<br>
logSuccessfulTransition(<br>
stateLogger, replicaId,<br>
partition, currentState, OnlineReplica)<br>
// 将该副本对象设置成 OnlineReplica 状态<br>
controllerContext.putReplicaState(replica, OnlineReplica)<br>
}</p>
<p>我同样使用一张图来说明：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/32e20b2684f8adda65abf382a7922fbb.png" alt=""></p>
<p>代码依然会对副本对象进行遍历，并依次执行下面的几个步骤。</p>
<ol>
<li>第 1 步，获取元数据中该副本所属的分区对象，以及该副本的当前状态。</li>
<li>第 2 步，查看当前状态是否是 NewReplica。如果是，则获取分区的副本列表，并判断该副本是否在当前的副本列表中，假如不在，就记录错误日志，并更新元数据中的副本列表；如果状态不是 NewReplica，就说明，这是一个已存在的副本对象，那么，源码会获取对应分区的详细数据，然后向该副本对象所在的 Broker 发送 LeaderAndIsrRequest 请求，令其同步获知，并保存该分区数据。</li>
<li>第 3 步，将该副本对象状态变更为 OnlineReplica。至此，该副本处于正常工作状态。</li>
</ol>
<h4 id="第-3-路转换到-offlinereplica-状态">第 3 路：转换到 OfflineReplica 状态</h4>
<p>最后，再来看下第 3 路分支。这路分支要将副本对象的状态转换成 OfflineReplica。我依然以代码注释的方式给出主要的代码逻辑：</p>
<p>case OfflineReplica =&gt;<br>
validReplicas.foreach { replica =&gt;<br>
// 向副本所在 Broker 发送 StopReplicaRequest 请求，停止对应副本<br>
controllerBrokerRequestBatch<br>
.addStopReplicaRequestForBrokers(Seq(replicaId),<br>
replica.topicPartition, deletePartition = false)<br>
}<br>
// 将副本对象集合划分成有 Leader 信息的副本集合和无 Leader 信息的副本集合<br>
val (replicasWithLeadershipInfo, replicasWithoutLeadershipInfo) =<br>
validReplicas.partition { replica =&gt;<br>
controllerContext.partitionLeadershipInfo<br>
.contains(replica.topicPartition)<br>
}<br>
// 对于有 Leader 信息的副本集合而言从，<br>
// 它们对应的所有分区中移除该副本对象并更新 ZooKeeper 节点<br>
val updatedLeaderIsrAndControllerEpochs =<br>
removeReplicasFromIsr(replicaId, <br>
replicasWithLeadershipInfo.map(<em>.topicPartition))<br>
// 遍历每个更新过的分区信息<br>
updatedLeaderIsrAndControllerEpochs.foreach {<br>
case (partition, leaderIsrAndControllerEpoch) =&gt;<br>
stateLogger.info(s&quot;Partition $partition state changed to $leaderIsrAndControllerEpoch after removing replica $replicaId from the ISR as part of transition to $OfflineReplica&quot;)<br>
// 如果分区对应主题并未被删除<br>
if (!controllerContext.isTopicQueuedUpForDeletion(<br>
partition.topic)) {<br>
// 获取该分区除给定副本以外的其他副本所在的 Broker <br>
val recipients = controllerContext<br>
.partitionReplicaAssignment(partition)<br>
.filterNot(</em> == replicaId)<br>
// 向这些 Broker 发送请求更新该分区更新过的分区 LeaderAndIsr 数据<br>
controllerBrokerRequestBatch.addLeaderAndIsrRequestForBrokers(<br>
recipients,<br>
partition,<br>
leaderIsrAndControllerEpoch,<br>
controllerContext.partitionFullReplicaAssignment(partition),<br>
isNew = false)<br>
}<br>
val replica = PartitionAndReplica(partition, replicaId)<br>
val currentState = controllerContext.replicaState(replica)<br>
if (traceEnabled)<br>
logSuccessfulTransition(stateLogger, replicaId,<br>
partition, currentState, OfflineReplica)<br>
// 设置该分区给定副本的状态为 OfflineReplica<br>
controllerContext.putReplicaState(replica, OfflineReplica)<br>
}<br>
// 遍历无 Leader 信息的所有副本对象<br>
replicasWithoutLeadershipInfo.foreach { replica =&gt;<br>
val currentState = controllerContext.replicaState(replica)<br>
if (traceEnabled)<br>
logSuccessfulTransition(stateLogger, replicaId,<br>
replica.topicPartition, currentState, OfflineReplica)<br>
// 向集群所有 Broker 发送请求，更新对应分区的元数据<br>
controllerBrokerRequestBatch.addUpdateMetadataRequestForBrokers(<br>
controllerContext.liveOrShuttingDownBrokerIds.toSeq,<br>
Set(replica.topicPartition))<br>
// 设置该分区给定副本的状态为 OfflineReplica<br>
controllerContext.putReplicaState(replica, OfflineReplica)<br>
}</p>
<p>我依然用一张图来说明它的执行流程：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/90ee1b2098d967303d3cfa273fd4bf94.png" alt=""></p>
<p>首先，代码会给所有符合状态转换的副本所在的 Broker，发送 StopReplicaRequest 请求，显式地告诉这些 Broker 停掉其上的对应副本。Kafka 的副本管理器组件（ReplicaManager）负责处理这个逻辑。后面我们会用两节课的时间专门讨论 ReplicaManager 的实现，这里你只需要了解，StopReplica 请求被发送出去之后，这些 Broker 上对应的副本就停止工作了。</p>
<p>其次，代码根据分区是否保存了 Leader 信息，将副本集合划分成两个子集：有 Leader 副本集合和无 Leader 副本集合。有无 Leader 信息并不仅仅包含 Leader，还有 ISR 和 controllerEpoch 等数据。不过，你大致可以认为，副本集合是根据有无 Leader 进行划分的。</p>
<p>接下来，源码会遍历有 Leader 的子集合，向这些副本所在的 Broker 发送 LeaderAndIsrRequest 请求，去更新停止副本操作之后的分区信息，再把这些分区状态设置为 OfflineReplica。</p>
<p>最后，源码遍历无 Leader 的子集合，执行与上一步非常类似的操作。只不过，对于无 Leader 而言，因为我们没有执行任何 Leader 选举操作，所以给这些副本所在的 Broker 发送的就不是 LeaderAndIsrRequest 请求了，而是 UpdateMetadataRequest 请求，显式去告知它们更新对应分区的元数据即可，然后再把副本状态设置为 OfflineReplica。</p>
<p>从这段描述中，我们可以知道，把副本状态变更为 OfflineReplica 的主要逻辑，其实就是停止对应副本 + 更新远端 Broker 元数据的操作。</p>
<h2 id="总结">总结</h2>
<p>今天，我们重点学习了 Kafka 的副本状态机实现原理，还仔细研读了这部分的源码。我们简单回顾一下这节课的重点。</p>
<ol>
<li>副本状态机：ReplicaStateMachine 是 Kafka Broker 端源码中控制副本状态流转的实现类。每个 Broker 启动时都会创建 ReplicaStateMachine 实例，但只有 Controller 组件所在的 Broker 才会启动它。</li>
<li>副本状态：当前，Kafka 定义了 7 类副本状态。同时，它还规定了每类状态合法的前置状态。</li>
<li>handleStateChanges：用于执行状态转换的核心方法。底层调用 doHandleStateChanges 方法，以 7 路 case 分支的形式穷举每类状态的转换逻辑。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/687a4a1354d0d435a0212a24d24ff9b8.png" alt=""></p>
<p>下节课，我将带你学习 Kafka 中另一类著名的状态机：分区状态机。掌握了这两个状态机，你就能清楚地知道 Kafka Broker 端管理分区和副本对象的完整流程和手段了。事实上，弄明白了这两个组件之后，Controller 负责主题方面的所有工作内容基本上都不会难倒你了。</p>
<h2 id="课后讨论">课后讨论</h2>
<p>请尝试分析 doHandleStateChanges 方法中最后一路分支的代码。</p>
<p>欢迎你在留言区写下你的思考和答案，跟我交流讨论，也欢迎你把今天的内容分享给你的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Kafka核心源码解读</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/17__readwritelock%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%A4%87%E7%9A%84%E7%BC%93%E5%AD%98/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">17__ReadWriteLock：如何快速实现一个完备的缓存？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/17__singleflight_%E5%92%8C_cyclicbarrier%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6%E5%92%8C%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F%E8%AF%A5%E6%80%8E%E4%B9%88%E7%94%A8/">
            <span class="next-text nav-default">17__SingleFlight_和_CyclicBarrier：请求合并和循环栅栏该怎么用？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
