<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>31__GroupMetadataManager：查询位移时，不用读取位移主题？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是胡夕。
上节课，我们学习了位移主题中的两类消息：消费者组注册消息和消费者组已提交位移消息。今天，我们接着学习位移主题，重点是掌握写入位移主题和读取位移主题。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/31__groupmetadatamanager%E6%9F%A5%E8%AF%A2%E4%BD%8D%E7%A7%BB%E6%97%B6%E4%B8%8D%E7%94%A8%E8%AF%BB%E5%8F%96%E4%BD%8D%E7%A7%BB%E4%B8%BB%E9%A2%98/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/31__groupmetadatamanager%E6%9F%A5%E8%AF%A2%E4%BD%8D%E7%A7%BB%E6%97%B6%E4%B8%8D%E7%94%A8%E8%AF%BB%E5%8F%96%E4%BD%8D%E7%A7%BB%E4%B8%BB%E9%A2%98/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="31__GroupMetadataManager：查询位移时，不用读取位移主题？">
  <meta property="og:description" content="你好，我是胡夕。
上节课，我们学习了位移主题中的两类消息：消费者组注册消息和消费者组已提交位移消息。今天，我们接着学习位移主题，重点是掌握写入位移主题和读取位移主题。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Kafka核心源码解读">

  <meta itemprop="name" content="31__GroupMetadataManager：查询位移时，不用读取位移主题？">
  <meta itemprop="description" content="你好，我是胡夕。
上节课，我们学习了位移主题中的两类消息：消费者组注册消息和消费者组已提交位移消息。今天，我们接着学习位移主题，重点是掌握写入位移主题和读取位移主题。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5851">
  <meta itemprop="keywords" content="Kafka核心源码解读">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="31__GroupMetadataManager：查询位移时，不用读取位移主题？">
  <meta name="twitter:description" content="你好，我是胡夕。
上节课，我们学习了位移主题中的两类消息：消费者组注册消息和消费者组已提交位移消息。今天，我们接着学习位移主题，重点是掌握写入位移主题和读取位移主题。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">31__GroupMetadataManager：查询位移时，不用读取位移主题？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5851 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#写入位移主题">写入位移主题</a></li>
        <li><a href="#读取位移主题">读取位移主题</a>
          <ul>
            <li><a href="#第-1-部分">第 1 部分</a></li>
            <li><a href="#第-2-部分">第 2 部分</a></li>
            <li><a href="#第-3-部分">第 3 部分</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#课后讨论">课后讨论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是胡夕。</p>
<p>上节课，我们学习了位移主题中的两类消息：<strong>消费者组注册消息</strong>和<strong>消费者组已提交位移消息</strong>。今天，我们接着学习位移主题，重点是掌握写入位移主题和读取位移主题。</p>
<p>我们总说，位移主题是个神秘的主题，除了它并非我们亲自创建之外，它的神秘之处还体现在，它的读写也不由我们控制。默认情况下，我们没法向这个主题写入消息，而且直接读取该主题的消息时，看到的更是一堆乱码。因此，今天我们学习一下读写位移主题，这正是去除它神秘感的重要一步。</p>
<h2 id="写入位移主题">写入位移主题</h2>
<p>我们先来学习一下位移主题的写入。在第 29 讲学习 storeOffsets 方法时，我们已经学过了 appendForGroup 方法。Kafka 定义的两类消息类型都是由它写入的。在源码中，storeGroup 方法调用它写入消费者组注册消息，storeOffsets 方法调用它写入已提交位移消息。</p>
<p>首先，我们需要知道 storeGroup 方法，它的作用是<strong>向 Coordinator 注册消费者组</strong>。我们看下它的代码实现：</p>
<p>def storeGroup(group: GroupMetadata,<br>
groupAssignment: Map[String, Array[Byte]],<br>
responseCallback: Errors =&gt; Unit): Unit = {<br>
// 判断当前 Broker 是否是该消费者组的 Coordinator<br>
getMagic(partitionFor(group.groupId)) match {<br>
// 如果当前 Broker 不是 Coordinator<br>
case Some(magicValue) =&gt;<br>
val timestampType = TimestampType.CREATE_TIME<br>
val timestamp = time.milliseconds()<br>
// 构建注册消息的 Key<br>
val key = GroupMetadataManager.groupMetadataKey(group.groupId)<br>
// 构建注册消息的 Value<br>
val value = GroupMetadataManager.groupMetadataValue(group, groupAssignment, interBrokerProtocolVersion)<br>
// 使用 Key 和 Value 构建待写入消息集合<br>
val records = {<br>
val buffer = ByteBuffer.allocate(AbstractRecords.estimateSizeInBytes(magicValue, compressionType,<br>
Seq(new SimpleRecord(timestamp, key, value)).asJava))<br>
val builder = MemoryRecords.builder(buffer, magicValue, compressionType, timestampType, 0L)<br>
builder.append(timestamp, key, value)<br>
builder.build()<br>
}<br>
// 计算要写入的目标分区<br>
val groupMetadataPartition = new TopicPartition(Topic.GROUP_METADATA_TOPIC_NAME, partitionFor(group.groupId))<br>
val groupMetadataRecords = Map(groupMetadataPartition -&gt; records)<br>
val generationId = group.generationId<br>
// putCacheCallback 方法，填充 Cache<br>
&hellip;&hellip;<br>
// 向位移主题写入消息<br>
appendForGroup(group, groupMetadataRecords, putCacheCallback)<br>
// 如果当前 Broker 不是 Coordinator<br>
case None =&gt;<br>
// 返回 NOT_COORDINATOR 异常<br>
responseCallback(Errors.NOT_COORDINATOR)<br>
None<br>
}<br>
}</p>
<p>为了方便你理解，我画一张图来展示一下 storeGroup 方法的逻辑。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/8bbcb57ce3eb0719cbba2b1e7aa13d6b.png" alt=""></p>
<p>storeGroup 方法的第 1 步是调用 getMagic 方法，来判断当前 Broker 是否是该消费者组的 Coordinator 组件。判断的依据，是尝试去获取位移主题目标分区的底层日志对象。如果能够获取到，就说明当前 Broker 是 Coordinator，程序进入到下一步；反之，则表明当前 Broker 不是 Coordinator，就构造一个 NOT_COORDINATOR 异常返回。</p>
<p>第 2 步，调用我们上节课学习的 groupMetadataKey 和 groupMetadataValue 方法，去构造注册消息的 Key 和 Value 字段。</p>
<p>第 3 步，使用 Key 和 Value 构建待写入消息集合。这里的消息集合类是 MemoryRecords。</p>
<p>当前，建模 Kafka 消息集合的类有两个。</p>
<ol>
<li>MemoryRecords：表示内存中的消息集合；</li>
<li>FileRecords：表示磁盘文件中的消息集合。</li>
</ol>
<p>这两个类的源码不是我们学习的重点，你只需要知道它们的含义就行了。不过，我推荐你课下阅读一下它们的源码，它们在 clients 工程中，这可以进一步帮助你理解 Kafka 如何在内存和磁盘上保存消息。</p>
<p>第 4 步，调用 partitionFor 方法，计算要写入的位移主题目标分区。</p>
<p>第 5 步，调用 appendForGroup 方法，将待写入消息插入到位移主题的目标分区下。至此，方法返回。</p>
<p>需要提一下的是，在上面的代码中，我省略了 putCacheCallback 方法的源码，我们在第 29 讲已经详细地学习过它了。它的作用就是当消息被写入到位移主题后，填充 Cache。</p>
<p>可以看到，写入位移主题和写入其它的普通主题并无差别。Coordinator 会构造符合规定格式的消息数据，并把它们传给 storeOffsets 和 storeGroup 方法，由它们执行写入操作。因此，我们可以认为，Coordinator 相当于位移主题的消息生产者。</p>
<h2 id="读取位移主题">读取位移主题</h2>
<p>其实，除了生产者这个角色以外，Coordinator 还扮演了消费者的角色，也就是读取位移主题。跟写入相比，读取操作的逻辑更加复杂一些，不光体现在代码长度上，更体现在消息读取之后的处理上。</p>
<p>首先，我们要知道，什么时候需要读取位移主题。</p>
<p>你可能会觉得，当消费者组查询位移时，会读取该主题下的数据。其实不然。查询位移时，Coordinator 只会从 GroupMetadata 元数据缓存中查找对应的位移值，而不会读取位移主题。真正需要读取位移主题的时机，<strong>是在当前 Broker 当选 Coordinator</strong>，也就是 Broker 成为了位移主题某分区的 Leader 副本时。</p>
<p>一旦当前 Broker 当选为位移主题某分区的 Leader 副本，它就需要将它内存中的元数据缓存填充起来，因此需要读取位移主题。在代码中，这是由 <strong>scheduleLoadGroupAndOffsets</strong> 方法完成的。该方法会创建一个异步任务，来读取位移主题消息，并填充缓存。这个异步任务要执行的逻辑，就是 loadGroupsAndOffsets 方法。</p>
<p>如果你翻开 loadGroupsAndOffsets 方法的源码，就可以看到，它本质上是调用 doLoadGroupsAndOffsets 方法实现的位移主题读取。下面，我们就重点学习下这个方法。</p>
<p>这个方法的代码很长，为了让你能够更加清晰地理解它，我先带你了解下它的方法签名，然后再给你介绍具体的实现逻辑。</p>
<p>首先，我们来看它的方法签名以及内置的一个子方法 logEndOffset。</p>
<p>private def doLoadGroupsAndOffsets(topicPartition: TopicPartition, onGroupLoaded: GroupMetadata =&gt; Unit): Unit = {<br>
// 获取位移主题指定分区的 LEO 值<br>
// 如果当前 Broker 不是该分区的 Leader 副本，则返回 -1<br>
def logEndOffset: Long = replicaManager.getLogEndOffset(topicPartition).getOrElse(-1L)<br>
&hellip;&hellip;<br>
}</p>
<p>doLoadGroupsAndOffsets 方法，顾名思义，它要做两件事请：加载消费者组；加载消费者组的位移。再强调一遍，所谓的加载，就是指读取位移主题下的消息，并将这些信息填充到缓存中。</p>
<p>该方法接收两个参数，第一个参数 topicPartition 是位移主题目标分区；第二个参数 onGroupLoaded 是加载完成后要执行的逻辑，这个逻辑是在上层组件中指定的，我们不需要掌握它的实现，这不会影响我们学习位移主题的读取。</p>
<p>doLoadGroupsAndOffsets 还定义了一个内置子方法 logEndOffset。它的目的很简单，就是<strong>获取位移主题指定分区的 LEO 值，如果当前 Broker 不是该分区的 Leader 副本，就返回 -1</strong>。</p>
<p>这是一个特别重要的事实，因为 Kafka 依靠它来判断分区的 Leader 副本是否发生变更。一旦发生变更，那么，在当前 Broker 执行 logEndOffset 方法的返回值，就是 -1，此时，Broker 就不再是 Leader 副本了。</p>
<p>doLoadGroupsAndOffsets 方法会<strong>读取位移主题目标分区的日志对象</strong>，并执行核心的逻辑动作，代码如下：</p>
<p>&hellip;&hellip;<br>
replicaManager.getLog(topicPartition) match {<br>
// 如果无法获取到日志对象<br>
case None =&gt;<br>
warn(s&quot;Attempted to load offsets and group metadata from $topicPartition, but found no log&quot;)<br>
case Some(log) =&gt;<br>
// 核心逻辑&hellip;&hellip;</p>
<p>我把核心的逻辑分成 3 个部分来介绍。</p>
<ol>
<li>第 1 部分：初始化 4 个列表 + 读取位移主题；</li>
<li>第 2 部分：处理读到的数据，并填充 4 个列表；</li>
<li>第 3 部分：分别处理这 4 个列表。</li>
</ol>
<p>在具体讲解这个方法所做的事情之前，我先画一张流程图，从宏观层面展示一下这个流程。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/cd54ef7e5f025ab5316cb60845b48c54.png" alt=""></p>
<h3 id="第-1-部分">第 1 部分</h3>
<p>首先，我们来学习一下第一部分的代码，完成了对位移主题的读取操作。</p>
<p>// 已完成位移值加载的分区列表<br>
val loadedOffsets = mutable.Map<a href="">GroupTopicPartition, CommitRecordMetadataAndOffset</a><br>
// 处于位移加载中的分区列表，只用于 Kafka 事务<br>
val pendingOffsets = mutable.Map<a href="">Long, mutable.Map[GroupTopicPartition, CommitRecordMetadataAndOffset]</a><br>
// 已完成组信息加载的消费者组列表<br>
val loadedGroups = mutable.Map<a href="">String, GroupMetadata</a><br>
// 待移除的消费者组列表<br>
val removedGroups = mutable.Set<a href="">String</a><br>
// 保存消息集合的 ByteBuffer 缓冲区<br>
var buffer = ByteBuffer.allocate(0)<br>
// 位移主题目标分区日志起始位移值<br>
var currOffset = log.logStartOffset<br>
// 至少要求读取一条消息<br>
var readAtLeastOneRecord = true<br>
// 当前读取位移&lt;LEO，且至少要求读取一条消息，且 GroupMetadataManager 未关闭<br>
while (currOffset &lt; logEndOffset &amp;&amp; readAtLeastOneRecord &amp;&amp; !shuttingDown.get()) {<br>
// 读取位移主题指定分区<br>
val fetchDataInfo = log.read(currOffset,<br>
maxLength = config.loadBufferSize,<br>
isolation = FetchLogEnd,<br>
minOneMessage = true)<br>
// 如果无消息可读，则不再要求至少读取一条消息<br>
readAtLeastOneRecord = fetchDataInfo.records.sizeInBytes &gt; 0<br>
// 创建消息集合<br>
val memRecords = fetchDataInfo.records match {<br>
case records: MemoryRecords =&gt; records<br>
case fileRecords: FileRecords =&gt;<br>
val sizeInBytes = fileRecords.sizeInBytes<br>
val bytesNeeded = Math.max(config.loadBufferSize, sizeInBytes)<br>
if (buffer.capacity &lt; bytesNeeded) {<br>
if (config.loadBufferSize &lt; bytesNeeded)<br>
warn(s&quot;Loaded offsets and group metadata from $topicPartition with buffer larger ($bytesNeeded bytes) than &quot; +<br>
s&quot;configured offsets.load.buffer.size (${config.loadBufferSize} bytes)&quot;)<br>
buffer = ByteBuffer.allocate(bytesNeeded)<br>
} else {<br>
buffer.clear()<br>
}<br>
fileRecords.readInto(buffer, 0)<br>
MemoryRecords.readableRecords(buffer)<br>
}<br>
&hellip;&hellip;<br>
}</p>
<p><strong>首先</strong>，这部分代码创建了 4 个列表。</p>
<ol>
<li>loadedOffsets：已完成位移值加载的分区列表；</li>
<li>pendingOffsets：位移值加载中的分区列表；</li>
<li>loadedGroups：已完成组信息加载的消费者组列表；</li>
<li>removedGroups：待移除的消费者组列表。</li>
</ol>
<p><strong>之后</strong>，代码又创建了一个 ByteBuffer 缓冲区，用于保存消息集合。<strong>接下来</strong>，计算位移主题目标分区的日志起始位移值，这是要读取的起始位置。<strong>再之后</strong>，代码定义了一个布尔类型的变量，该变量表示本次至少要读取一条消息。</p>
<p>这些初始化工作都做完之后，代码进入到 while 循环中。循环的条件有 3 个，而且需要同时满足：</p>
<ol>
<li>读取位移值小于日志 LEO 值；</li>
<li>布尔变量值是 True；</li>
<li>GroupMetadataManager 未关闭。</li>
</ol>
<p>只要满足这 3 个条件，代码就会一直执行 while 循环下的语句逻辑。整个 while 下的逻辑被分成了 3 个步骤，我们现在学习的第 1 部分代码，包含了前两步。最后一步在第 3 部分中实现，即处理上面的这 4 个列表。我们先看前两步。</p>
<p>第 1 步是<strong>读取位移主题目标分区的日志对象</strong>，从日志中取出真实的消息数据。读取日志这个操作，是使用我们在第 3 讲中学过的 Log.read 方法完成的。当读取到完整的日志之后，doLoadGroupsAndOffsets 方法会查看返回的消息集合，如果一条消息都没有返回，则取消“至少要求读取一条消息”的限制，即把刚才的布尔变量值设置为 False。</p>
<p>第 2 步是根据上一步获取到的消息数据，创建保存在内存中的消息集合对象，也就是 MemoryRecords 对象。</p>
<p>由于 doLoadGroupsAndOffsets 方法要将读取的消息填充到缓存中，因此，这里必须做出 MemoryRecords 类型的消息集合。这就是第二路 case 分支要将 FileRecords 转换成 MemoryRecords 类型的原因。</p>
<p>至此，第 1 部分逻辑完成。这一部分的产物就是成功地从位移主题目标分区读取到消息，然后转换成 MemoryRecords 对象，等待后续处理。</p>
<h3 id="第-2-部分">第 2 部分</h3>
<p>现在，代码进入到第 2 部分：<strong>处理消息集合</strong>。</p>
<p>值得注意的是，这部分代码依然在 while 循环下，我们看下它是如何实现的：</p>
<p>// 遍历消息集合的每个消息批次 (RecordBatch)<br>
memRecords.batches.forEach { batch =&gt;<br>
val isTxnOffsetCommit = batch.isTransactional<br>
// 如果是控制类消息批次<br>
// 控制类消息批次属于 Kafka 事务范畴，这里不展开讲<br>
if (batch.isControlBatch) {<br>
&hellip;&hellip;<br>
} else {<br>
// 保存消息批次第一条消息的位移值<br>
var batchBaseOffset: Option[Long] = None<br>
// 遍历消息批次下的所有消息<br>
for (record &lt;- batch.asScala) {<br>
// 确保消息必须有 Key，否则抛出异常<br>
require(record.hasKey, &ldquo;Group metadata/offset entry key should not be null&rdquo;)<br>
// 记录消息批次第一条消息的位移值<br>
if (batchBaseOffset.isEmpty)<br>
batchBaseOffset = Some(record.offset)<br>
// 读取消息 Key<br>
GroupMetadataManager.readMessageKey(record.key) match {<br>
// 如果是 OffsetKey，说明是提交位移消息<br>
case offsetKey: OffsetKey =&gt;<br>
&hellip;&hellip;<br>
val groupTopicPartition = offsetKey.key<br>
// 如果该消息没有 Value<br>
if (!record.hasValue) {<br>
if (isTxnOffsetCommit)               <br>
pendingOffsets(batch.producerId)<br>
.remove(groupTopicPartition)<br>
else<br>
// 将目标分区从已完成位移值加载的分区列表中移除<br>
loadedOffsets.remove(groupTopicPartition)<br>
} else {<br>
val offsetAndMetadata = GroupMetadataManager.readOffsetMessageValue(record.value)<br>
if (isTxnOffsetCommit)<br>
pendingOffsets(batch.producerId).put(groupTopicPartition, CommitRecordMetadataAndOffset(batchBaseOffset, offsetAndMetadata))<br>
else<br>
// 将目标分区加入到已完成位移值加载的分区列表<br>
loadedOffsets.put(groupTopicPartition, CommitRecordMetadataAndOffset(batchBaseOffset, offsetAndMetadata))<br>
}<br>
// 如果是 GroupMetadataKey，说明是注册消息<br>
case groupMetadataKey: GroupMetadataKey =&gt;<br>
val groupId = groupMetadataKey.key<br>
val groupMetadata = GroupMetadataManager.readGroupMessageValue(groupId, record.value, time)<br>
// 如果消息 Value 不为空<br>
if (groupMetadata != null) {<br>
// 把该消费者组从待移除消费者组列表中移除<br>
removedGroups.remove(groupId)<br>
// 将消费者组加入到已完成加载的消费组列表<br>
loadedGroups.put(groupId, groupMetadata)<br>
// 如果消息 Value 为空，说明是 Tombstone 消息<br>
} else {<br>
// 把该消费者组从已完成加载的组列表中移除<br>
loadedGroups.remove(groupId)<br>
// 将消费者组加入到待移除消费组列表<br>
removedGroups.add(groupId)<br>
}<br>
// 如果是未知类型的 Key，抛出异常<br>
case unknownKey =&gt;<br>
throw new IllegalStateException(s&quot;Unexpected message key $unknownKey while loading offsets and group metadata&quot;)<br>
}<br>
}<br>
}<br>
// 更新读取位置到消息批次最后一条消息的位移值 +1，等待下次 while 循环<br>
currOffset = batch.nextOffset<br>
}</p>
<p>这一部分的主要目的，是处理上一步获取到的消息集合，然后把相应数据添加到刚刚说到的 4 个列表中，具体逻辑是代码遍历消息集合的每个消息批次（Record Batch）。我来解释一下这个流程。</p>
<p><strong>首先</strong>，判断该批次是否是控制类消息批次，如果是，就执行 Kafka 事务专属的一些逻辑。由于我们不讨论 Kafka 事务，因此，这里我就不详细展开了。如果不是，就进入到下一步。</p>
<p><strong>其次</strong>，遍历该消息批次下的所有消息，并依次执行下面的步骤。</p>
<p>第 1 步，记录消息批次中第一条消息的位移值。</p>
<p>第 2 步，读取消息 Key，并判断 Key 的类型，判断的依据如下：</p>
<ol>
<li>如果是提交位移消息，就判断消息有无 Value。如果没有，那么，方法将目标分区从已完成位移值加载的分区列表中移除；如果有，则将目标分区加入到已完成位移值加载的分区列表中。</li>
<li>如果是注册消息，依然是判断消息有无 Value。如果存在 Value，就把该消费者组从待移除消费者组列表中移除，并加入到已完成加载的消费组列表；如果不存在 Value，就说明，这是一条 Tombstone 消息，那么，代码把该消费者组从已完成加载的组列表中移除，并加入到待移除消费组列表。</li>
<li>如果是未知类型的 Key，就直接抛出异常。</li>
</ol>
<p>最后，更新读取位置，等待下次 while 循环，这个位置就是整个消息批次中最后一条消息的位移值 +1。</p>
<p>至此，这部分代码宣告结束，它的主要产物就是被填充了的 4 个列表。那么，第 3 部分，就要开始处理这 4 个列表了。</p>
<h3 id="第-3-部分">第 3 部分</h3>
<p>最后一部分的完整代码如下：</p>
<p>// 处理 loadedOffsets<br>
val (groupOffsets, emptyGroupOffsets) = loadedOffsets<br>
.groupBy(_._1.group)<br>
.map { case (k, v) =&gt;<br>
// 提取出&lt;组名，主题名，分区号&gt;与位移值对<br>
k -&gt; v.map { case (groupTopicPartition, offset) =&gt; (groupTopicPartition.topicPartition, offset) }<br>
}.partition { case (group, _) =&gt; loadedGroups.contains(group) }<br>
&hellip;&hellip;<br>
// 处理 loadedGroups<br>
loadedGroups.values.foreach { group =&gt;<br>
// 提取消费者组的已提交位移<br>
val offsets = groupOffsets.getOrElse(group.groupId, Map.empty[TopicPartition, CommitRecordMetadataAndOffset])<br>
val pendingOffsets = pendingGroupOffsets.getOrElse(group.groupId, Map.empty[Long, mutable.Map[TopicPartition, CommitRecordMetadataAndOffset]])<br>
debug(s&quot;Loaded group metadata $group with offsets $offsets and pending offsets $pendingOffsets&quot;)<br>
// 为已完成加载的组执行加载组操作<br>
loadGroup(group, offsets, pendingOffsets)<br>
// 为已完成加载的组执行加载组操作之后的逻辑<br>
onGroupLoaded(group)<br>
}<br>
(emptyGroupOffsets.keySet ++ pendingEmptyGroupOffsets.keySet).foreach { groupId =&gt;<br>
val group = new GroupMetadata(groupId, Empty, time)<br>
val offsets = emptyGroupOffsets.getOrElse(groupId, Map.empty[TopicPartition, CommitRecordMetadataAndOffset])<br>
val pendingOffsets = pendingEmptyGroupOffsets.getOrElse(groupId, Map.empty[Long, mutable.Map[TopicPartition, CommitRecordMetadataAndOffset]])<br>
debug(s&quot;Loaded group metadata $group with offsets $offsets and pending offsets $pendingOffsets&quot;)<br>
// 为空的消费者组执行加载组操作<br>
loadGroup(group, offsets, pendingOffsets)<br>
// 为空的消费者执行加载组操作之后的逻辑<br>
onGroupLoaded(group)<br>
}<br>
// 处理 removedGroups<br>
removedGroups.foreach { groupId =&gt;<br>
if (groupMetadataCache.contains(groupId) &amp;&amp; !emptyGroupOffsets.contains(groupId))<br>
throw new IllegalStateException(s&quot;Unexpected unload of active group $groupId while &quot; +<br>
s&quot;loading partition $topicPartition&quot;)<br>
}</p>
<p><strong>首先</strong>，代码对 loadedOffsets 进行分组，将那些已经完成组加载的消费者组位移值分到一组，保存在字段 groupOffsets 中；将那些有位移值，但没有对应组信息的分成另外一组，也就是字段 emptyGroupOffsets 保存的数据。</p>
<p><strong>其次</strong>，代码为 loadedGroups 中的所有消费者组执行加载组操作，以及加载之后的操作 onGroupLoaded。还记得吧，loadedGroups 中保存的都是已完成组加载的消费者组。这里的 onGroupLoaded 是上层调用组件 Coordinator 传入的。它主要的作用是处理消费者组下所有成员的心跳超时设置，并指定下一次心跳的超时时间。</p>
<p><strong>再次</strong>，代码为 emptyGroupOffsets 的所有消费者组，创建空的消费者组元数据，然后执行和上一步相同的组加载逻辑以及加载后的逻辑。</p>
<p><strong>最后</strong>，代码检查 removedGroups 中的所有消费者组，确保它们不能出现在消费者组元数据缓存中，否则将抛出异常。</p>
<p>至此，doLoadGroupsAndOffsets 方法的逻辑全部完成。经过调用该方法后，Coordinator 成功地读取了位移主题目标分区下的数据，并把它们填充到了消费者组元数据缓存中。</p>
<h2 id="总结">总结</h2>
<p>今天，我们重点学习了 GroupMetadataManager 类中读写位移主题的方法代码。Coordinator 会使用这些方法对位移主题进行操作，实现对消费者组的管理。写入操作比较简单，它和一般的消息写入并无太大区别，而读取操作相对复杂一些。更重要的是，和我们的直观理解可能相悖的是，Kafka 在查询消费者组已提交位移时，是不会读取位移主题的，而是直接从内存中的消费者组元数据缓存中查询。这一点你一定要重点关注。</p>
<p>我们来简单回顾一下这节课的重点。</p>
<ol>
<li>读写方法：appendForGroup 方法负责写入位移主题，doLoadGroupsAndOffsets 负责读取位移主题，并加载组信息和位移值。</li>
<li>查询消费者组位移：查询位移时不读取位移主题，而是读取消费者组元数据缓存。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/94ad579cbfc6a59d7d8879dbc966a880.png" alt=""></p>
<p>至此，GroupMetadataManager 类的重要源码，我们就学完了。作为一个有着将近 1000 行代码，而且集这么多功能于一身的大文件，这个类的代码绝对值得你多读几遍。</p>
<p>除了我们集中介绍的这些功能之外，GroupMetadataManager 类其实还是连接 GroupMetadata 和 Coordinator 的重要纽带，Coordinator 利用 GroupMetadataManager 类实现操作 GroupMetadata 的目的。</p>
<p>我刚开始学习这部分源码的时候，居然不清楚 GroupMetadata 和 GroupMetadataManager 的区别是什么。现在，经过这 3 节课的内容，相信你已经知道，GroupMetadata 建模的是元数据信息，而 GroupMetadataManager 类建模的是管理元数据的方法，也是管理内部位移主题的唯一组件。以后碰到任何有关位移主题的问题，你都可以直接到这个类中去寻找答案。</p>
<h2 id="课后讨论">课后讨论</h2>
<p>其实，除了读写位移主题之外，GroupMetadataManager 还提供了清除位移主题数据的方法。代码中的 cleanGroupMetadata 就是做这个事儿的。请你结合源码，分析一下 cleanGroupMetadata 方法的流程。</p>
<p>欢迎在留言区写下你的思考和答案，跟我交流讨论，也欢迎你把今天的内容分享给你的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Kafka核心源码解读</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/31__gpu%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8gpu/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">31__GPU（下）：为什么深度学习需要使用GPU？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/31__guarded_suspension%E6%A8%A1%E5%BC%8F%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0/">
            <span class="next-text nav-default">31__Guarded_Suspension模式：等待唤醒机制的规范实现</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
