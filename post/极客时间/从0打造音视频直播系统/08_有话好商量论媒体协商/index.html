<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>08_有话好商量，论媒体协商 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="在《07 | 你竟然不知道 SDP？它可是 WebRTC 的驱动核心！》一文中，我向你详细介绍了标准 SDP 规范，以及 WebRTC 与标准 SDP 规范的一些不同，而本文我们将重点学习一下 WebRTC 究竟是如何使用 SDP 规范进行媒体协商的。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/08_%E6%9C%89%E8%AF%9D%E5%A5%BD%E5%95%86%E9%87%8F%E8%AE%BA%E5%AA%92%E4%BD%93%E5%8D%8F%E5%95%86/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/08_%E6%9C%89%E8%AF%9D%E5%A5%BD%E5%95%86%E9%87%8F%E8%AE%BA%E5%AA%92%E4%BD%93%E5%8D%8F%E5%95%86/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="08_有话好商量，论媒体协商">
  <meta property="og:description" content="在《07 | 你竟然不知道 SDP？它可是 WebRTC 的驱动核心！》一文中，我向你详细介绍了标准 SDP 规范，以及 WebRTC 与标准 SDP 规范的一些不同，而本文我们将重点学习一下 WebRTC 究竟是如何使用 SDP 规范进行媒体协商的。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="从0打造音视频直播系统">

  <meta itemprop="name" content="08_有话好商量，论媒体协商">
  <meta itemprop="description" content="在《07 | 你竟然不知道 SDP？它可是 WebRTC 的驱动核心！》一文中，我向你详细介绍了标准 SDP 规范，以及 WebRTC 与标准 SDP 规范的一些不同，而本文我们将重点学习一下 WebRTC 究竟是如何使用 SDP 规范进行媒体协商的。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3275">
  <meta itemprop="keywords" content="从0打造音视频直播系统">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="08_有话好商量，论媒体协商">
  <meta name="twitter:description" content="在《07 | 你竟然不知道 SDP？它可是 WebRTC 的驱动核心！》一文中，我向你详细介绍了标准 SDP 规范，以及 WebRTC 与标准 SDP 规范的一些不同，而本文我们将重点学习一下 WebRTC 究竟是如何使用 SDP 规范进行媒体协商的。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">08_有话好商量，论媒体协商</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3275 字 </span>
          <span class="more-meta"> 预计阅读 7 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#在-webrtc-处理过程中的位置">在 WebRTC 处理过程中的位置</a></li>
        <li><a href="#webrtc-中媒体协商的作用">WebRTC 中媒体协商的作用</a></li>
        <li><a href="#rtcpeerconnection">RTCPeerConnection</a></li>
        <li><a href="#媒体协商的过程">媒体协商的过程</a></li>
        <li><a href="#媒体协商的代码实现">媒体协商的代码实现</a>
          <ul>
            <li><a href="#1-呼叫方创建-offer">1. 呼叫方创建 Offer</a></li>
            <li><a href="#2-被呼叫方收到-offer">2. 被呼叫方收到 Offer</a></li>
            <li><a href="#3-被呼叫方创建-answer">3. 被呼叫方创建 Answer</a></li>
            <li><a href="#4-呼叫方收到-answer">4. 呼叫方收到 Answer</a></li>
          </ul>
        </li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#思考时间">思考时间</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>在<a href="./111337.md">《07 | 你竟然不知道 SDP？它可是 WebRTC 的驱动核心！》</a>一文中，我向你详细介绍了标准 SDP 规范，以及 WebRTC 与标准 SDP 规范的一些不同，而本文我们将重点学习一下 WebRTC 究竟是如何使用 SDP 规范进行<strong>媒体协商</strong>的。</p>
<p>我们平时所说的<strong>协商</strong>你应该清楚是什么意思，说白了就是讨价还价。以买白菜为例，商家说 5 元一颗，买家说身上只有 4.5 元卖不卖？商家同意卖，这样一次协商就完成了。</p>
<p>而<strong>媒体协商</strong>也是这个意思，只不过它们讨价还价的不是一般商品，而是与媒体相关的能力。那<strong>媒体能力</strong>是什么呢？实际就是你的设备所支持的音视频编解码器、使用的传输协议、传输的速率是多少等信息。</p>
<p>所以简单地说，<strong>媒体协商</strong>就是看看你的设备都支持那些编解码器，我的设备是否也支持？如果我的设备也支持，那么咱们双方就算协商成功了。</p>
<h2 id="在-webrtc-处理过程中的位置">在 WebRTC 处理过程中的位置</h2>
<p>在正式进入主题之前，我们还是来看看本文在整个 WebRTC 处理过程中的位置，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/8712987829fbaab8bc7659764ffff410.png" alt=""></p>
<p>WebRTC 处理过程图</p>
<p>通过这张图你可以了解到，本文所涉及的内容包括<strong>创建连接</strong>和<strong>信令</strong>两部分。</p>
<ul>
<li>创建连接，指的是创建 RTCPeerConnection，它负责端与端之间彼此建立 P2P 连接。在后面 RTCPeerConnection 一节中，我们还会对其做进一步的介绍。</li>
<li>信令，指的是客户端通过信令服务器交换 SDP 信息。</li>
</ul>
<p>所以从本文开始，我们就开始讲解 WebRTC 最核心的一部分知识了，下面就让我们开始吧。</p>
<h2 id="webrtc-中媒体协商的作用">WebRTC 中媒体协商的作用</h2>
<p>在 WebRTC 1.0 规范中，在双方通信时，双方必须清楚彼此使用的编解码器是什么，也必须知道传输过来的音视频流的 SSRC（SSRC 的概念参见<a href="./109999.md">《06 | WebRTC 中的 RTP 及 RTCP 详解》</a>一文）信息，如果连这些最基本的信息彼此都不清楚的话，那么双方是无法正常通信的。</p>
<p>举个例子，如果 WebRTC 不清楚对方使用的是哪种编码器编码的数据，比如到底是 H264，还是 VP8？那 WebRTC 就无法将这些数据包正常解码，还原成原来的音视频帧，这将导致音视频无法正常显示或播放。</p>
<p>同样的道理，如果 WebRTC 不知道对方发过来的音视频流的 SSRC 是多少，那么 WebRTC 就无法对该音视频流的合法性做验证，这也将导致你无法观看正常的音视频。因为对于无法验证的音视频流，WebRTC 在接收音视频包后会直接将其抛弃。</p>
<p>通过上面的描述，我想你已经非常清楚媒体协商的作用是什么了。没错，<strong>媒体协商的作用就是让双方找到共同支持的媒体能力</strong>，如双方都支持的编解码器，从而<strong>最终实现彼此之间的音视频通信</strong>。</p>
<p>那 WebRTC 是怎样进行媒体协商的呢？这就要用到<a href="./111337.md">《07 | 你竟然不知道 SDP？它可是 WebRTC 的驱动核心！》</a>文章中讲解的 SDP 了。</p>
<ul>
<li>首先，通信双方将它们各自的媒体信息，如编解码器、媒体流的 SSRC、传输协议、IP 地址和端口等，按 SDP 格式整理好。</li>
<li>然后，通信双方通过信令服务器交换 SDP 信息，并待彼此拿到对方的 SDP 信息后，找出它们共同支持的媒体能力。</li>
<li>最后，双方按照协商好的媒体能力开始音视频通信。</li>
</ul>
<p>WebRTC 进行媒体协商的步骤基本如上所述。接下来，我们来看看 WebRTC 具体是如何操作的。</p>
<h2 id="rtcpeerconnection">RTCPeerConnection</h2>
<p>讲到媒体协商，我们就不得不介绍一下 RTCPeerConnection 类，顾名思义，它表示的就是端与端之间建立的<strong>连接</strong>。</p>
<p>该类是整个 WebRTC 库中<strong>最关键</strong>的一个类，通过它创建出来的对象可以做很多事情，如 NAT 穿越、音视频数据的接收与发送，甚至它还可以用于非音视频数据的传输等等。</p>
<p>而在这里我们之所以要介绍 RTCPeerConnection，最主要的原因是<strong>我们今天要讲的端到端之间的媒体协商，就是基于 RTCPeerConnection 对象实现的</strong>。</p>
<p>首先，我们来看一下如何创建一个 RTCPeerConnection 对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">pcConfig</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">new</span> <span class="n">RTCPeerConnection</span><span class="p">(</span><span class="n">pcConfig</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 JavaScript 下创建 RTCPeerConnection 对象非常简单，如上所述，只要通过 new 关键字创建即可。</p>
<p>在创建 RTCPeerConnection 对象时，还可以给它传一个参数<strong>pcConfig</strong>，该参数的结构非常复杂，这里我们先将其设置为 null，后面在《12 | RTCPeerConnection：音视频实时通讯的核心》一文中我再对其做更详尽的描述。</p>
<p>有了 RTCPeerConnection 对象，接下来，让我们再来看看端与端之间是如何进行媒体协商的吧！</p>
<h2 id="媒体协商的过程">媒体协商的过程</h2>
<p><strong>在通讯双方都创建好 RTCPeerConnection 对象后</strong>，它们就可以开始进行媒体协商了。不过在进行媒体协商之前，有两个重要的概念，即 <strong>Offer</strong> 与 <strong>Answer</strong> ，你必须要弄清楚。</p>
<p>Offer 与 Answer 是什么呢？对于 1 对 1 通信的双方来说，我们称首先发送媒体协商消息的一方为<strong>呼叫方</strong>，而另一方则为<strong>被呼叫方</strong>。</p>
<ul>
<li>Offer，在双方通讯时，呼叫方发送的 SDP 消息称为 Offer。</li>
<li>Answer，在双方通讯时，被呼叫方发送的 SDP 消息称为 Answer。</li>
</ul>
<p>在 WebRTC 中，双方协商的整个过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/e2125ccea15fe76fb3824f13c7a274c9.png" alt=""></p>
<p>媒体协商过程图</p>
<p>首先，呼叫方创建 Offer 类型的 SDP 消息。创建完成后，调用 setLocalDescriptoin 方法将该 Offer 保存到本地 Local 域，然后通过信令将 Offer 发送给被呼叫方。</p>
<p>被呼叫方收到 Offer 类型的 SDP 消息后，调用 setRemoteDescription 方法将 Offer 保存到它的 Remote 域。作为应答，被呼叫方要创建 Answer 类型的 SDP 消息，Answer 消息创建成功后，再调用 setLocalDescription 方法将 Answer 类型的 SDP 消息保存到本地的 Local 域。最后，被呼叫方将 Answer 消息通过信令发送给呼叫方。至此，被呼叫方的工作就完部完成了。</p>
<p>接下来是呼叫方的收尾工作，呼叫方收到 Answer 类型的消息后，调用 RTCPeerConnecton 对象的 setRemoteDescription 方法，将 Answer 保存到它的 Remote 域。</p>
<p>至此，<strong>整个媒体协商过程处理完毕</strong>。</p>
<p>当通讯双方拿到彼此的 SDP 信息后，就可以进行媒体协商了。媒体协商的具体过程是在 WebRTC 内部实现的，我们就不去细讲了。你只需要记住本地的 SDP 和远端的 SDP 都设置好后，协商就算成功了。</p>
<h2 id="媒体协商的代码实现">媒体协商的代码实现</h2>
<p>了解了 WebRTC 的媒体协商过程之后，我们再看一下如何使用 JavaScript 代码来实现这一功能。浏览器提供了几个非常方便的 API，这些 API 是对底层 WebRTC API 的封装。如下所示：</p>
<ul>
<li>createOffer，创建 Offer；</li>
<li>createAnswer，创建 Answer；</li>
<li>setLocalDescription，设置本地 SDP 信息；</li>
<li>setRemoteDescription，设置远端的 SDP 信息。</li>
</ul>
<p>接下来，我们就结合上述的协商过程对这几个重要的 API 做下详细的讲解。</p>
<h3 id="1-呼叫方创建-offer">1. 呼叫方创建 Offer</h3>
<p>当呼叫方发起呼叫之前，首先要创建 Offer 类型的 SDP 信息，即调用 <strong>RTCPeerConnection</strong> 的 createOffer() 方法。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   function doCall() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       console.log(&#39;Sending offer to peer&#39;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       pc.createOffer(setLocalAndSendMessage, handleCreateOfferError);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	}	
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果 createOffer 函数调用成功的话，浏览器会回调我们设置的 setLocalAndSendMessage 方法，你可以在 setLocalAndSendMessage 方法里获取到 <strong>RTCSessionDescription 类型的 SDP 信息</strong>；如果出错则会回调 handleCreateOfferError 方法。</p>
<p>最终，在 setLocalAndSendMessage 回调方法中，通过 <strong>setLocalDescription()</strong> 方法将本地 SDP 描述信息设置到 WebRTC 的 Local 域。然后通过信令通道将此会话描述发送给被呼叫方。代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  function setLocalAndSendMessage(sessionDescription) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      pc.setLocalDescription(sessionDescription);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      sendMessage(sessionDescription);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="2-被呼叫方收到-offer">2. 被呼叫方收到 Offer</h3>
<p>被呼叫方收到 Offer 后，调用 <strong>setRemoteDescription</strong> 方法设置呼叫方发送给它的 Offer 作为远端描述。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  socket.on(&#39;message&#39;, function(message) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      } else if (message.type === &#39;offer&#39;) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              pc.setRemoteDescription(new RTCSessionDescription(message));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          doAnswer();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      } else if (...) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ....
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  });
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="3-被呼叫方创建-answer">3. 被呼叫方创建 Answer</h3>
<p>然后，被呼叫方调用 RTCPeerConnection 对象的 createAnswer 方法，它会生成一个与远程会话兼容的本地会话，并最终将该会话描述发送给呼叫方。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> function doAnswer() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     pc.createAnswer().then(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         setLocalAndSendMessage,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         onCreateSessionDescriptionError
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     );
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> }
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="4-呼叫方收到-answer">4. 呼叫方收到 Answer</h3>
<p>当呼叫方得到被呼叫方的会话描述，即 SDP 时，调用 setRemoteDescription 方法，将收到的会话描述设置为一个远程会话。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  socket.on(&#39;message&#39;, function(message) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      } else if (message.type === &#39;answer&#39;) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              pc.setRemoteDescription(new RTCSessionDescription(message));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      } else if (...) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ....
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  });
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时，媒体协商过程完成。紧接着在 WebRTC 底层会收集 Candidate，并进行连通性检测，最终在通话双方之间建立起一条链路来。</p>
<p>以上就是通信双方交换媒体能力信息的过程。对于你来说，如果媒体协商这个逻辑没搞清楚的话，那么，你在编写音视频相关程序时很容易出现各种问题，最常见的就是音视之间不能互通。</p>
<p>另外，<strong>需要特别注意的是，通信双方链路的建立是在设置本地媒体能力，即调用 setLocalDescription 函数之后才进行的</strong>。</p>
<h2 id="小结">小结</h2>
<p>在本文中，我向你详细介绍了 WebRTC 进行媒体协商的过程，这个过程是你必须牢记在脑子里的。如果对这块不熟悉的话，后面你在真正使用 WebRTC 开发音视频应用程序时就会遇到各种困难，如音视频不通、单通等情况。</p>
<p>另外，本文还向你简要介绍了 RTCPeerConnection 对象，它是 WebRTC 的核心 API，媒体协商的具体操作都是通过该对象来完成的。对于该对象，我会在后面的文章中做更详尽的解答。</p>
<p>RTCPeerConnection 除了会在端与端之间建立连接、传输音视频数据外，还要进行两次绑定：一次是与媒体源进行绑定，以解决数据从哪里来的问题；另外一次是与输出进行绑定，以解决接收到的音视频数据显示 / 播放的问题。</p>
<h2 id="思考时间">思考时间</h2>
<p>在 WebRTC 中，SDP 消息的交换是使用 RTCPeerConnection 对象完成的吗？</p>
<p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/b76671e85154bd22630b3e9c53a64d98.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/">从0打造音视频直播系统</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/10x%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E6%B3%95/08_%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%81%9A%E4%BA%8B%E4%B9%8B%E5%89%8D%E8%A6%81%E5%85%88%E8%BF%9B%E8%A1%8C%E6%8E%A8%E6%BC%94/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">08_为什么说做事之前要先进行推演？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E8%AF%BE/08_%E7%BB%84%E5%90%88%E5%A6%82%E4%BD%95%E8%AE%A9%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E6%8E%92%E4%B8%96%E7%95%8C%E6%9D%AF%E7%9A%84%E8%B5%9B%E7%A8%8B/">
            <span class="next-text nav-default">08_组合：如何让计算机安排世界杯的赛程？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
