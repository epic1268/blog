<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>32_HLS：实现一对多直播系统的必备协议 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="在上一篇文章中，我们对 RTMP 协议和 HLS 协议的优势与劣势进行了比较。从比较的结果我们可以看出，RTMP 作为传统的直播传输技术在实时性方面要比 HLS 好很多，所以它还是有一定优势的。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/32_hls%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BF%85%E5%A4%87%E5%8D%8F%E8%AE%AE/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/32_hls%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BF%85%E5%A4%87%E5%8D%8F%E8%AE%AE/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="32_HLS：实现一对多直播系统的必备协议">
  <meta property="og:description" content="在上一篇文章中，我们对 RTMP 协议和 HLS 协议的优势与劣势进行了比较。从比较的结果我们可以看出，RTMP 作为传统的直播传输技术在实时性方面要比 HLS 好很多，所以它还是有一定优势的。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="从0打造音视频直播系统">

  <meta itemprop="name" content="32_HLS：实现一对多直播系统的必备协议">
  <meta itemprop="description" content="在上一篇文章中，我们对 RTMP 协议和 HLS 协议的优势与劣势进行了比较。从比较的结果我们可以看出，RTMP 作为传统的直播传输技术在实时性方面要比 HLS 好很多，所以它还是有一定优势的。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3265">
  <meta itemprop="keywords" content="从0打造音视频直播系统">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="32_HLS：实现一对多直播系统的必备协议">
  <meta name="twitter:description" content="在上一篇文章中，我们对 RTMP 协议和 HLS 协议的优势与劣势进行了比较。从比较的结果我们可以看出，RTMP 作为传统的直播传输技术在实时性方面要比 HLS 好很多，所以它还是有一定优势的。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">32_HLS：实现一对多直播系统的必备协议</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3265 字 </span>
          <span class="more-meta"> 预计阅读 7 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#hls-直播架构">HLS 直播架构</a></li>
        <li><a href="#ffmpeg-生成-hls-切片">FFmpeg 生成 HLS 切片</a></li>
        <li><a href="#m3u8-格式分析">m3u8 格式分析</a></li>
        <li><a href="#ts-格式分析">TS 格式分析</a></li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#思考时间">思考时间</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>在<a href="./140181.md">上一篇文章</a>中，我们对 RTMP 协议和 HLS 协议的优势与劣势进行了比较。从比较的结果我们可以看出，RTMP 作为传统的直播传输技术在实时性方面要比 HLS 好很多，所以它还是有一定优势的。</p>
<p>不过，随着 Chrome 浏览器宣布不再对 Flash 插件提供支持、Adobe 公司停止对 RTMP 协议更新以及苹果公司声称 iOS 上不允许使用 RTMP 协议等一系列事件的发生，我们可以断定 RTMP 协议已失去了未来。</p>
<p>而 HLS 协议则恰恰相反，它在未来会有更广阔的应用前景。我们可以通过以下几点来得到这个结论：</p>
<ul>
<li>HLS 是苹果开发的协议，苹果产品原生支持此协议；</li>
<li>HLS 是基于 HTTP 的，可以不受防火墙限制，所以它的连通性会更好；</li>
<li>HLS 还能根据客户的网络带宽情况进行自适应码率的调整，这对于很多用户来说是非常有吸引力的。</li>
</ul>
<p>基于以上原因，我们有必要从 HLS 直播架构、FFmpeg 生成 HLS 切片、HLS m3u8 格式和 HLS TS 格式这四个方面对 HLS 协议的细节做一下介绍。</p>
<h2 id="hls-直播架构">HLS 直播架构</h2>
<p>下面我们来看一下 HLS 直播系统的架构图，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/0f9eb93490d7efd52f8962cc79bfb8b9.png" alt=""></p>
<p>HLS 直播架构图</p>
<p>我们在<a href="./140181.md">上一篇文章</a>中讲过，传统直播系统大致分为三部分：直播客户端、信令服务和 CDN 网络，使用 HLS 协议也是如此。只不过在我们这里为了简化流程，去掉了信令服务系统。</p>
<p>如上图所示，客户端采集媒体数据后，通过 RTMP 协议将音视频流推送给 CDN 网络的源节点（接入节点）。源节点收到音视频流后，再通过 Convert 服务器将 RTMP 流切割为 HLS 切片文件，即 .ts 文件。同时生成与之对应的 m3u8 文件，即 HLS 播放列表文件。</p>
<p>切割后的 HLS 分片文件（.ts 文件）和 HLS 列表文件（.m3u8 文件）经 CDN 网络转发后，客户端就可以从离自己最近的 CDN 边缘节点拉取 HLS 媒体流了。</p>
<p>在拉取 HLS 媒体流时，客户端首先通过 HLS 协议将 m3u8 索引文件下载下来，然后按索引文件中的顺序，将 .ts 文件一片一片下载下来，然后一边播放一边缓冲。此时，你就可以在 PC、手机、平板等设备上观看直播节目了。</p>
<p>对于使用 HLS 协议的直播系统来说，最重要的一步就是<strong>切片</strong>。源节点服务器收到音视频流后，先要数据缓冲起来，保证到达帧的所有分片都已收到之后，才会将它们切片成 TS 流。</p>
<p>为了便于分析，本文是通过 FFmpeg 工具将 MP4 文件切割成 HLS 格式的文件切片。但不管选择使用哪一种切割文件的方法或工具，生成的切片和索引文件的格式都是一致的。</p>
<p>勿在浮沙筑高台，为了让你在工作中做到得心应手、心中有数，接下来就让我们一起探索 HLS 协议的一些具体细节吧。</p>
<h2 id="ffmpeg-生成-hls-切片">FFmpeg 生成 HLS 切片</h2>
<p>这里我们是通过 FFmpeg 工具将一个 MP4 文件转换为 HLS 切片和索引文件的。所以，你需要预先准备一个 MP4 文件，并且下载好 FFmpeg 工具。你可以从<a href="./download.md">FFmpeg 官网</a>下载二进制包，也可以通过下载源码自行编译出 FFmpeg 工具。FFmpeg 用于将 MP4 切片成 HLS 的命令如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ffmpeg -i test.mp4 -c copy -start_number 0 -hls_time 10 -hls_list_size 0 -hls_segment_filename test%03d.ts index.m3u8
</span></span></code></pre></td></tr></table>
</div>
</div><p>该命令参数说明如下：</p>
<ul>
<li>-i，输入文件选项，可以是磁盘文件，也可以是媒体设备。</li>
<li>-c copy，表示只是进行封装格式的转换。不需要将多媒体文件中的音视频数据重新进行编码。</li>
<li>-start_number，表示 .ts 文件的起始编号，这里设置从 0 开始。当然，你也可以设置其他数字。</li>
<li>-hls_time，表示每个 .ts 文件的最大时长，单位是秒。这里设置的是 10s，表示每个切片文件的时长，为 10 秒。当然，由于没有进行重新编码，所以这个时长并不准确。</li>
<li>-hls_list_size，表示播放列表文件的长度，0 表示不对播放列表文件的大小进行限制。</li>
<li>-hls_segment_filename，表示指定 TS 文件的名称。</li>
<li>index.m3u8，表示索引文件名称。</li>
</ul>
<p>执行完这条命令后，在当前路径下会生成一系列 .ts 文件和 index.m3u8 文件。下面，我们再分别分析一下 .m3u8 文件格式和 .ts 文件格式。</p>
<h2 id="m3u8-格式分析">m3u8 格式分析</h2>
<p>正如前面讲到，HLS 必须要有一个 .m3u8 的索引文件。它是一个播放列表文件，文件的编码必须是 UTF-8 格式。这里我们将前面生成的 .m3u8 文件内容展示一下，以便让你有个感观的认识。内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#EXTM3U
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#EXT-X-VERSION:3         // 版本信息
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#EXT-X-TARGETDURATION:11 // 每个分片的目标时长
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#EXT-X-MEDIA-SEQUENCE:0  // 分片起始编号
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#EXTINF:10.922578,       // 分片实际时长
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">test000.ts               // 分片文件
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#EXTINF:9.929578,        // 第二个分片实际时长
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">test001.ts               // 第二个分片文件
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">... 
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里截取了分片列表文件开头部分的内容，可以看出文件内容要么是以<code>#</code>字母开头，要么就是没有<code>#</code>字母。关于文件格式规范，<a href="./draft-pantos-hls-rfc8216bis-04.md#section-4">RFC8216 草案</a>第四节有详细的说明，你可以到那里查看详细的内容。</p>
<p>RFC8216 规定，.m3u8 文件内容以<code>#</code>字母开头的行是注释和 TAG，其中 TAG 必须是<code>#EXT</code> 开头，如上面示例中的内容所示。</p>
<p>接下来，我们对这几个 TAG 做一下说明：</p>
<ul>
<li><code>EXTM3U</code> 表示文件是第一个扩展的 M3U8 文件，此 TAG 必须放在索引文件的第一行。</li>
<li><code>EXT-X-VERSION: n</code> 表示索引文件支持的版本号，后面的数字 n 是版本号数字。需要注意的是，一个索引文件只能有一行版本号 TAG，否则播放器会解析报错。</li>
<li><code>EXT-X-TARGETDURATION: s</code> 表示 .ts 切片的最大时长，单位是秒（s）。</li>
<li><code>EXT-X-MEDIA-SEQUENCE: number</code> 表示第一个 .ts 切片文件的编号。若不设置此项，就是默认从 0 开始的。</li>
<li><code>EXTINF: duration, title</code> 表示 .ts 文件的时长和文件名称。文件时长不能超过<code>#EXT-X-TARGETDURATION</code>中设置的最大时长，并且时长的单位应该采用浮点数来提高精度。</li>
</ul>
<h2 id="ts-格式分析">TS 格式分析</h2>
<p>TS 流最早应用于数字电视领域，其格式非常复杂，包含的配置信息表多达十几个。TS 流中的视频格式是 MPEG2 TS，格式标准是在 ISO-IEC 13818-1 中定义的。</p>
<p>苹果推出的 HLS 协议对 MPEG2 规范中的 TS 流做了精减，只保留了两个最基本的配置表 PAT 和 PMT，再加上音视频数据流就形成了现在的 HLS 协议。也就是说，HLS 协议是由 PAT + PMT + TS 数据流组成的。其中，TS 数据中的视频数据采用 H264 编码，而音频数据采用 AAC/MP3 编码。TS 数据流示意图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/5f0e15dbba29d8165cf5addc6c89e3b9.png" alt=""></p>
<p>TS 数据流示意图</p>
<p>我们再进一步细化，TS 数据流由 TS Header 和 TS Payload 组成。其中，TS Header 占 4 字节，TS Payload 占 184 字节，即 TS 数据流总长度是 188 字节。</p>
<p>TS Payload 又由 PES Header 和 PES Payload 组成。其中，PES Payload 是真正的音视频流，也称为 ES 流。</p>
<ul>
<li>PES（Packet Elementary Stream）是将 ES 流增加 PES Header 后形成的数据包。</li>
<li>ES（Elementary Stream），中文可以翻译成<strong>基流</strong>，是编码后的音视频数据。</li>
</ul>
<p>下面我们就来分析一下 TS 数据流的格式，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/b379ceb9f174b2e13fdecb6678e8b904.png" alt=""></p>
<p>TS 文件格式图</p>
<p>这是 TS Header 各个字段的详细说明，图中数字表示长度，如果数字后面带有 bytes，单位就是 bytes；否则，单位都是 bit。</p>
<p>TS Header 分为 8 个字段，下面我们分别解释一下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/bc7ce6787fe493fb5faeb4cf65a6466d.png" alt=""></p>
<p>PES Packet 作为 TS 数据流的 Payload，也有自己的 Header，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/f4cc670a24e5cdd859146ea14f455e13.png" alt=""></p>
<p>PES 结构图</p>
<p>下面我们就对这些常用的字段一一做下解释，当然也还有很多不常用的字段，我们这里就不列出来了，如有需求，可参考 ISO-IEC 13818-1 2.4.3.7 节。</p>
<p>PES Header 长度是 6 字节，字段说明如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/7bb06b32e0ca8c6749eacdc6be0e8247.png" alt=""></p>
<p>另外，PTS（Presentation Tmestamp）字段总共包含了 40 bit，高 4 个 bit 固定取值是 0010；剩下的 36 个 bit 分三部分，分别是：3 bit+1 bit 标记位；15 bit+1 bit 标记位；15 bit+1 bit 标记位。</p>
<p>通过以上的描述我们就将 HLS 协议中最重要的 TS 数据流向你介绍清楚了。</p>
<h2 id="小结">小结</h2>
<p>本文我们首先讲述了采用 HLS 协议的直播架构。实际上该直播架构与我们上文中介绍的直播架构是一致的，只不过我们这里为了强调 HLS 协议对之前的直播架构做了简化。同时，我们还通过该直播架构模型向你介绍了传统直播系统中，从用户推流到服务端切片、再到用户拉流的基本过程。</p>
<p>随后，我们借助 FFmpeg 工具向你讲解了如何将 MP4 文件转换成 HLS 文件，并向你展示了 .m3u8 文件的基本结构。最后还重点介绍了 TS 数据流的格式。</p>
<p>通过本文的学习，我相信你应该已经对 HLS 协议有了非常清楚的认知了。实际上，作为应用级的开发人员来说，你并不需要了解到文中所介绍的那么细，只需要对 HLS 协议有个基本的理解就可以了。因为目前有很多不错的开源库已经完成了大部分的工作，你只需要将这些开源库使用好即可。</p>
<p>比如在播放 HLS 流时，就有很多开源库可用。在移动端可以使用 Ijkplayer，在浏览器上可以使用 video.js，在 PC 端可以使用 VLC。而服务端的 HLS 切片则是由 CDN 网络完成的，你只需要向 CDN 网络推流就可以了，CDN 网络会直接将上传的流进行 HLS 切片。而在 CDN 网络内部，它就是使用我们上面所介绍的 FFmpeg 开源库编译好的工具来完成切片工作的。</p>
<h2 id="思考时间">思考时间</h2>
<p>每个 TS 格式数据包是 188 字节长，不够 188 字节就需要用 Padding 填充，那为什么要限制成 188 字节呢？</p>
<p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/b76671e85154bd22630b3e9c53a64d98.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/">从0打造音视频直播系统</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/32_beam_window%E6%89%93%E9%80%9A%E6%B5%81%E5%A4%84%E7%90%86%E7%9A%84%E4%BB%BB%E7%9D%A3%E4%BA%8C%E8%84%89/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">32_Beam_Window：打通流处理的任督二脉</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/32_%E4%BB%93%E5%BA%93%E7%BB%93%E6%9E%84%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E6%96%87%E4%BB%B6_/">
            <span class="next-text nav-default">32_仓库结构：如何组织文件_</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
