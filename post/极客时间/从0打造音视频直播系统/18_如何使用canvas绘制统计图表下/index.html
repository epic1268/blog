<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>18_如何使用Canvas绘制统计图表（下）？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="Google 的 Chrome 浏览器已经默认支持 WebRTC 库了，因此 Chrome 浏览器之间已经可以进行音视频实时通信了。更让人欣喜的是 Google 还开源了 WebRTC 源码，此举不仅惊艳，而且非常伟大。WebRTC 源码的开放，为音视频实时通信领域从业者、爱好者提供了非常好的研究和学习的机会。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/18_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8canvas%E7%BB%98%E5%88%B6%E7%BB%9F%E8%AE%A1%E5%9B%BE%E8%A1%A8%E4%B8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/18_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8canvas%E7%BB%98%E5%88%B6%E7%BB%9F%E8%AE%A1%E5%9B%BE%E8%A1%A8%E4%B8%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="18_如何使用Canvas绘制统计图表（下）？">
  <meta property="og:description" content="Google 的 Chrome 浏览器已经默认支持 WebRTC 库了，因此 Chrome 浏览器之间已经可以进行音视频实时通信了。更让人欣喜的是 Google 还开源了 WebRTC 源码，此举不仅惊艳，而且非常伟大。WebRTC 源码的开放，为音视频实时通信领域从业者、爱好者提供了非常好的研究和学习的机会。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="从0打造音视频直播系统">

  <meta itemprop="name" content="18_如何使用Canvas绘制统计图表（下）？">
  <meta itemprop="description" content="Google 的 Chrome 浏览器已经默认支持 WebRTC 库了，因此 Chrome 浏览器之间已经可以进行音视频实时通信了。更让人欣喜的是 Google 还开源了 WebRTC 源码，此举不仅惊艳，而且非常伟大。WebRTC 源码的开放，为音视频实时通信领域从业者、爱好者提供了非常好的研究和学习的机会。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3996">
  <meta itemprop="keywords" content="从0打造音视频直播系统">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="18_如何使用Canvas绘制统计图表（下）？">
  <meta name="twitter:description" content="Google 的 Chrome 浏览器已经默认支持 WebRTC 库了，因此 Chrome 浏览器之间已经可以进行音视频实时通信了。更让人欣喜的是 Google 还开源了 WebRTC 源码，此举不仅惊艳，而且非常伟大。WebRTC 源码的开放，为音视频实时通信领域从业者、爱好者提供了非常好的研究和学习的机会。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">18_如何使用Canvas绘制统计图表（下）？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3996 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#浏览器中的-webrtc-统计图表">浏览器中的 WebRTC 统计图表</a></li>
        <li><a href="#使用-canvas-绘制图形">使用 Canvas 绘制图形</a>
          <ul>
            <li><a href="#1-坐标系">1. 坐标系</a></li>
            <li><a href="#2-绘制-webrtc-图表">2. 绘制 WebRTC 图表</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#思考时间">思考时间</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Google 的 Chrome 浏览器已经默认支持 WebRTC 库了，因此 Chrome 浏览器之间已经可以进行音视频实时通信了。更让人欣喜的是 Google 还开源了 WebRTC 源码，此举不仅惊艳，而且非常伟大。WebRTC 源码的开放，为音视频实时通信领域从业者、爱好者提供了非常好的研究和学习的机会。</p>
<p>虽然“浏览器 + WebRTC”为广大用户提供了诸多便利，但当你开发产品时会发现，在浏览器上调试<strong>媒体流</strong>还是非常困难的。因为媒体通信涉及到了多个层面的知识，而浏览器更擅长的是处理 HTML 页面和 JavaScript 脚本，所以如果用它来分析媒体流的收发情况或者网络情况，就显得很困难了。</p>
<p>为了解决这个问题，Google 在它的 Chrome 浏览器中支持了 WebRTC 的统计分析功能，只要<strong>在 Chrome 浏览器的地址栏输入“chrome://webrtc-internals/ ”</strong>，你就可以看到浏览器中正在使用的 WebRTC 的各种统计分析数据了，而且这些数据都是以可视化统计图表的方式展现在你面前的，从而大大方便了你分析媒体流的效率。</p>
<p>实际上，关于 WebRTC 统计方面的内容我在前面《WebRTC 中的数据统计原来这么强大》的两篇文章中已经做了详细的介绍。而今天我们要讲的主要内容是<strong>如何使用 Canvas 进行图表的绘制</strong>。</p>
<h2 id="浏览器中的-webrtc-统计图表">浏览器中的 WebRTC 统计图表</h2>
<p>下面我们先通过一个实际的例子，感受一下在 Chome 浏览器中是如何通过统计图表来展现 WebRTC 的统计信息的。要想看到这个图表，你需按以下步骤操作：</p>
<ul>
<li>在 Chrome 浏览器中同时打开两个 tab 页面；</li>
<li>在两个 tab 页面中输入 <a href="https://learningrtc.cn/getstats/index.html">https://learningrtc.cn/getstats/index.html</a> 地址，这是一个用于测试 WebRTC 的 URL 地址；</li>
<li>在每一个打开的页面中，点击“Connect Sig Server”按钮，此时每个页面都会出现两个视频窗口，这说明 WebRTC 视频通信已经建立成功了；</li>
<li>在 Chrome 浏览器中再打开一个 tab 页面（也就是第三个页面），输入 chrome://webrtc-internals/ 地址，此时，在这个页面中就会展示正在运行的 WebRTC 的各种统计信息，如媒体流统计信息、网络统计信息等；</li>
<li>你可以继续点开任意一个带有“<strong>Stats graphs</strong>”字样的选项，这样相关的统计图表就会展示出来了。</li>
</ul>
<p>在这些统计图表中，你可以看到每一路音视频流的收发包、传输码率、带宽等信息。下面两张图展示的就是视频相关的统计信息。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/7d81e7ec7ef29b466cf11507904e3095.png" alt=""></p>
<p>WebRTC 统计信息图（一）</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/568b24fcd1c44f0748e7e537351176bb.png" alt=""></p>
<p>WebRTC 统计信息图（二）</p>
<p>在统计信息页面中，你可以点击鼠标右键，在弹出的菜单中选择“<strong>检查</strong>”，就会显示出该页面的 HTML 源码，也就是上面两张图中右半部分的内容。下面我们就对这个源码做一下简单的分析。</p>
<p>在 chrome://webrtc-internals/ 地址源码的 <code>&lt;head&gt;</code> 标签中，引用了 webrtc_internals.js 和 util.js 两个 JavaScript 脚本，代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;head&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    &lt;script src=&#34;chrome://resources/js/util.js&#34;&gt;&lt;/script&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    &lt;script src=&#34;webrtc_internals.js&#34;&gt;&lt;/script&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;/head&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这两个脚本中，最关键的是 webrtc_internals.js 脚本，因为<strong>所有统计信息的绘制都在 webrtc_internals.js 中完成的</strong>。</p>
<p>那这些图表是怎么绘制出来的呢？为了解开这个迷团，我们来观察一下“WebRTC 统计信息图（一）”这张图。在这张图中，左侧红框框中的信息表示的是 id 为“<strong>12756-1-bweforvideo-bweCompound-div</strong>”的 DIV，在这个 DIV 中绘制了一张<strong>发送视频带宽</strong>的图表。然后，我们再来看一下这张图表所对应的代码，也就是图中右侧红框框中的 HTML5 代码，从中我们可以知道，<strong>左侧的图表是由右侧的 HTML5 代码中的 <code>&lt;canvas&gt;</code> 标签绘制而成的</strong>。</p>
<p>在“WebRTC 统计信息图（二）”中，我在图的右侧用红框选中了 webrtc_internals.js，在该脚本的源码中，我们能够看到在 webrtc_internals.js 脚本中调用了 <code>getContext('2d')</code>API，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">context</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">canvas_</span><span class="o">.</span><span class="n">getContext</span><span class="p">(</span><span class="s1">&#39;2d&#39;</span><span class="p">);</span>  <span class="o">//</span> <span class="err">获得</span> <span class="n">canvas</span> <span class="err">上下文</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="n">fillstyle</span> <span class="o">=</span> <span class="n">BACKGROUND_COLOR</span><span class="p">;</span> <span class="o">//</span> <span class="err">设置填充颜色</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="n">fillRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">heigth</span><span class="p">);</span> <span class="o">//</span> <span class="err">设置填充区域</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的这段代码，首先通过 Canvas 获得它的上下文，然后通过 Canvas 上下文来设置 Canvas 的背景颜色和区域大小。通过这段代码，我们还可以得出一个结论：<strong>WebRTC 中的各种统计图表都是通过 Canvas 来绘制的</strong>。</p>
<p>了解了上面的这些信息后，下面我们就来分析一下 WebRTC 是如何通过 Canvas 来绘制图表的。</p>
<h2 id="使用-canvas-绘制图形">使用 Canvas 绘制图形</h2>
<p>Canvas 可以绘制矩形、路径、圆弧等基本几何图形，通过这些基本图形的组合，可以绘制出其他更加复杂的图形。</p>
<p><strong>除了绘制各种图形外，Canvas 还可以对图形进行颜色填充和边框涂色。而对图形的操作，如旋转、伸缩、位置变换等也是 Canvas 必备的功能。</strong></p>
<p>下面我们就来学习一下如何通过 Canvas 来绘制统计图表。</p>
<h3 id="1-坐标系">1. 坐标系</h3>
<p>通过上面的描述，我想你应该已经知道了 Canvas 的功能还是非常强大的，通过它可以绘制各种复杂的图形。不过在使用 Canvas 绘制各种复杂的图形之前，你必须要先了解 Canvas 的坐标系。只有对 Canvas 的坐标系了解清楚了，你才能做后面的事儿。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/ef40a5aaa37640965f0c2156584bb26d.png" alt=""></p>
<p>Canvas 坐标系图</p>
<p>Canvas 坐标系的原点在画布的左上角，X 坐标从左向右增长，Y 坐标是从上到下增长。因为 Canvas 绘制的是像素图，所以你可以把上图坐标系中的小方格理解为一个个像素。</p>
<p>另外，Canvas 坐标系是可以改变的。你既可以从坐标 (0,0) 点来绘图，也可以改成相对 (x,y) 点来绘图，这是通过接口 translate(x,y) 来实现的。也就是说，当你想改变坐标系的原点时，可以通过调用 translate(x,y) 这个 API 将原点设置为 (x,y) 点，这样你后面所有图形的绘制都是基于 (x,y) 这个坐标点的相对坐标了。坐标原点变换，主要是为了处理上的方便，它往往需要配合 save()/restore() 等 API 来完成。</p>
<h3 id="2-绘制-webrtc-图表">2. 绘制 WebRTC 图表</h3>
<p>关于绘制 WebRTC 统计图表的实现，可以参考在 GitHub 上的<a href="./chromium.md">Chrome 源码</a>的镜像，在这个源码中，与绘图相关的代码主要是以下三个文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">content/browser/resources/media/timeline_graph_view.js
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">content/browser/resources/media/data_series.js
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">content/browser/resources/media/stats_graph_helper.js
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，我们就对这个实现做一下简单的分析，由于功能不是很复杂，所以涉及的类也不多，通过下面这张类图就可以表示得很清楚：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/499d3b2e00c53eef509a3cdbb880b2ee.png" alt=""></p>
<p>绘制 WebRTC 统计图表的类图</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/7fce49e274fb7e1b8dba009aed8d5e17.png" alt=""></p>
<p>下面我们就对上面这几个类之间的逻辑关系做一下梳理：</p>
<ul>
<li>当我们在浏览器的 tab 页中输入 chrome://webrtc-internals/ 打开 WebRTC 的统计页面后，该页面首先会通过 WebRTC 的 RTCPeerConnection 对象的 getStats API 获取 WebRTC 的各种统计数据，然后按照不同的分类，将数据转成一个的 <strong>DataPoint</strong>。</li>
<li>chrome://webrtc-internals/ 会启动一个定时器，每秒触发一次，这样就可以每秒调用一次 getStats 方法获取统计数据，然后生成各种 <strong>DataPoint</strong> 对象。随着时间的推移，这些 DataPoint 就可以连成一条线了。</li>
<li>每种 DataPoint 都被保存到 <strong>TimelineDataSeries</strong> 对象中。该对象是按时间排序的数据集。当然，在该数据集中所有的 DataPoint 都属于一类，举个例子，每秒钟发送端带宽属于一类，每秒钟发送的数据包个数属于另一类。</li>
<li><strong>TimelineGraphView</strong>对象表示的是一个以时间为主线的图表，在这个图表中可以绘制多条曲线。实际上我们可以将每秒钟发送端的带宽与每秒钟发送的数据包数放在同一个 TimelineGraphView 中显示。但在我们的例子中，每个图表只绘制了一种曲线。</li>
<li>数据准备好后，最终图形的绘制是通过 <strong>Graph</strong> 对象完成的，它才是在 Canvas 中绘制图形真正的“<strong>负责人</strong>”。</li>
</ul>
<p>下面咱们再从代码的角度来看一下它们具体是如何实现的吧！</p>
<p><strong>首先是 DataPoint 类</strong>，它非常简单，定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">function DataPoint(time, value) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        this.time = time;  // 数据产生的时间，以毫秒为单位
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        this.value = value; // 数值
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个类没有什么需要特别讲的，就是记录了一个<strong>数据产生的时间和数值</strong>。</p>
<p><strong>其次是 TimelineDataSeries 类</strong>，你可以结合下面的示例代码来看看它都包括哪些内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 按时间顺序的列表
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">this.dataPoints_ = [];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 画点的默认颜色
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">this.color_ = &#39;red&#39;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 是否真正的绘制图形
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">this.isVisible_ = true;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>在该类中主要包括上面三个属性：</p>
<ul>
<li>dataPoints_：用于存放 DataPoint 类型数据的数组，在实际场景中就是每秒生成的 DataPoint 的数组。</li>
<li>color_：表示在绘制时以什么颜色画点。</li>
<li>isVisible_：指示数据是否真的要在图表中展示出来。</li>
</ul>
<p>通过以上三个属性，你就可以非常清楚地知道这个类的作用是存放 DataPoint 类型数据的集合，并指明了画点时的颜色。</p>
<p><strong>再次是 TimelineGraphView 类</strong>，它的重要属性如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 获得 canvas
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">this.canvas_ = document.getElementById(canvasId);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 开始时间
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">this.startTime_ = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 终止时间
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">this.endTime_ = 1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//graph 用于绘图
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">this.graph_ = null;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 横向刻度，每毫秒一个像素，默认刻度是一秒
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">this.scale_ = 1000;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // 初始化开启滚动条
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">this.updateScrollbarRange_(true);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>从上面的代码中，你可以看到 TimelineGraphView 类可以获得 Canvas 元素，并保存了要绘制图形的开始时间和结束时间等信息。</p>
<p>其中还有一个特别关键的属性，即 graph_ 属性，TimelineGraphView 对象最终会使用 Graph 对象绘制图形。</p>
<p><strong>最后一个是 Graph 类</strong>，它的重要属性定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//TimelineDataSeries 对象数组
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">this.dataSeries_ = [];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> // Cached properties of the graph, set in layout.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">this.width_ = 0; // 图表的宽度
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">this.height_ = 0; // 图表的高度
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过上面的属性你可以知道，Graph 对象里存放了 TimelineDataSeries 对象数组，也就是说可以在一张图表中绘制多条不同的曲线。除此之外，Graph 中还定义了图表的宽度和高度。</p>
<p><strong>那 Graph 是如何通过 Canvas 绘制图形的呢</strong>？我们来看一下它的具体实现，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">repaint: function () {
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  let width = this.canvas_.width;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  let height = this.canvas_.height;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  let context = this.canvas_.getContext(&#39;2d&#39;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   // 清空 Canvas 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  context.fillStyle = BACKGROUND_COLOR;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  context.fillRect(0, 0, width, height);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   if (this.graph_) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       // 画线
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      this.graph_.drawLines(context);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> drawLines: function (context) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 编译每个 TimelineDataSeries 对象，实际只有一个
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (let i = this.dataSeries_.length - 1; i &gt;= 0; --i) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 从 TimelineDataSeries 对象中取出值
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        let values = this.getValues(this.dataSeries_[i]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (!values) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            continue;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 取出画线的颜色
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        context.strokeStyle = this.dataSeries_[i].getColor();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        context.beginPath(); 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        for (let x = 0; x &lt; values.length; ++x) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            // 连线
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            context.lineTo(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                x, bottom - Math.round((values[x] - this.min_) * scale));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        context.stroke();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 Graph 中首先调用 repaint 函数进行绘图，在该函数中通过 Canvas 元素获取到了 Canvas 的上下文，然后通过该上下文将 Canvas 清空，最后调用 drawLines 函数进行连线。</p>
<p>在 drawLines 函数中，它从 dataSeries 数组中取 DataPoint 数据，之后调用 context.lineTo 方法将所有的点进行连接，这样就可以将 WebRTC 的统计信息通过图表的方式展示出来了。</p>
<p>通过上面的分析，你应该可以看出使用 HTML5 中的 Canvas 标签来绘制图表还是蛮简单的！</p>
<h2 id="总结">总结</h2>
<p>本文通过一个例子，向你讲述了 WebRTC 的统计信息图表是如何通过 Canvas 来实现的。还分析了在 Chrome 浏览器中的 chrome://webrtc-internals 统计页面中各种统计信息图表实现的基本逻辑。</p>
<p>另外，你还需要知道，Chrome 浏览器中提供的统计信息的功能非常强大，除了本文介绍的可视化图表外，更重要的是你需要理解统计数据的含义，这样才更有利于分析产品中遇到的问题。对于这些数据的含义我在之前的文章中已经向你做了介绍，不清楚的同学可以再回顾一下之前的内容。</p>
<p>所以，你如果有时间也有兴趣的话，可以对 WebRTC 做进一步了解，你也可参考本文提供的 Chrome 源码部分以及相关资料，做进一步学习。</p>
<h2 id="思考时间">思考时间</h2>
<p>我们通过 Canvas 绘制曲线的时候，经常会出现锯齿形，这种锯齿非常难看，有什么办法可以让曲线更平滑一些吗？</p>
<p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/b76671e85154bd22630b3e9c53a64d98.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/">从0打造音视频直播系统</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80%E8%AF%BE/18_%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C__%E5%B7%A6%E6%89%8B%E4%BF%A1%E5%8F%B7%E5%8F%B3%E6%89%8B%E8%AF%AF%E5%B7%AE%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">18_人工神经网络__左手信号，右手误差：多层感知器</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1/18_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/">
            <span class="next-text nav-default">18_如何使用负载均衡算法？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
