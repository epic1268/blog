<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>19_WebRTC能不能进行文本聊天呢？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="WebRTC 不但可以让你进行音视频通话，而且还可以用它传输普通的二进制数据，比如说可以利用它实现文本聊天、文件的传输等等。
WebRTC 的**数据通道（RTCDataChannel）**是专门用来传输除了音视频数据之外的任何数据，所以它的应用非常广泛，如实时文字聊天、文件传输、远程桌面、游戏控制、P2P 加速等都是它的应用场景。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/19_webrtc%E8%83%BD%E4%B8%8D%E8%83%BD%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%81%8A%E5%A4%A9%E5%91%A2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/19_webrtc%E8%83%BD%E4%B8%8D%E8%83%BD%E8%BF%9B%E8%A1%8C%E6%96%87%E6%9C%AC%E8%81%8A%E5%A4%A9%E5%91%A2/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="19_WebRTC能不能进行文本聊天呢？">
  <meta property="og:description" content="WebRTC 不但可以让你进行音视频通话，而且还可以用它传输普通的二进制数据，比如说可以利用它实现文本聊天、文件的传输等等。
WebRTC 的**数据通道（RTCDataChannel）**是专门用来传输除了音视频数据之外的任何数据，所以它的应用非常广泛，如实时文字聊天、文件传输、远程桌面、游戏控制、P2P 加速等都是它的应用场景。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="从0打造音视频直播系统">

  <meta itemprop="name" content="19_WebRTC能不能进行文本聊天呢？">
  <meta itemprop="description" content="WebRTC 不但可以让你进行音视频通话，而且还可以用它传输普通的二进制数据，比如说可以利用它实现文本聊天、文件的传输等等。
WebRTC 的**数据通道（RTCDataChannel）**是专门用来传输除了音视频数据之外的任何数据，所以它的应用非常广泛，如实时文字聊天、文件传输、远程桌面、游戏控制、P2P 加速等都是它的应用场景。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4283">
  <meta itemprop="keywords" content="从0打造音视频直播系统">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="19_WebRTC能不能进行文本聊天呢？">
  <meta name="twitter:description" content="WebRTC 不但可以让你进行音视频通话，而且还可以用它传输普通的二进制数据，比如说可以利用它实现文本聊天、文件的传输等等。
WebRTC 的**数据通道（RTCDataChannel）**是专门用来传输除了音视频数据之外的任何数据，所以它的应用非常广泛，如实时文字聊天、文件传输、远程桌面、游戏控制、P2P 加速等都是它的应用场景。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">19_WebRTC能不能进行文本聊天呢？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4283 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#rtcdatachannel-介绍">RTCDataChannel 介绍</a></li>
        <li><a href="#配置-rtcdatachannel">配置 RTCDataChannel</a></li>
        <li><a href="#rtcdatachannel-的事件">RTCDataChannel 的事件</a></li>
        <li><a href="#实时文字聊天">实时文字聊天</a>
          <ul>
            <li><a href="#1-in-band-协商方式">1. In-band 协商方式</a></li>
            <li><a href="#2-out-of-band-协商方式">2. Out-of-band 协商方式</a></li>
          </ul>
        </li>
        <li><a href="#具体例子">具体例子</a>
          <ul>
            <li><a href="#1-添加事件">1. 添加事件</a></li>
            <li><a href="#2-创建连接">2. 创建连接</a></li>
            <li><a href="#3-创建-rtcdatachannel">3. 创建 RTCDataChannel</a></li>
            <li><a href="#4-数据的发送与接收">4. 数据的发送与接收</a></li>
          </ul>
        </li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#思考时间">思考时间</a></li>
        <li><a href="#参考">参考</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>WebRTC 不但可以让你进行音视频通话，而且还可以用它传输普通的二进制数据，比如说可以利用它实现文本聊天、文件的传输等等。</p>
<p>WebRTC 的**数据通道（RTCDataChannel）**是专门用来传输除了音视频数据之外的任何数据，所以它的应用非常广泛，如实时文字聊天、文件传输、远程桌面、游戏控制、P2P 加速等都是它的应用场景。</p>
<p>像文本聊天、文件传输这类应用，大多数人能想到的通常是通过服务器中转数据的方案，但 WebRTC 则优先使用的是<strong>P2P 方案，即两端之间直接传输数据</strong>，这样就大大减轻了服务器的压力。当然 WebRTC 也可以采用中继的方案，这就需要你根据自己的业务需要进行选择，非常灵活。</p>
<h2 id="rtcdatachannel-介绍">RTCDataChannel 介绍</h2>
<p>RTCDataChannel 就是 WebRTC 中专门用来传输非音视频数据的类，它的设计模仿了 WebSocket 的实现，使用起来非常方便，关于这一点我将在下面的“RTCDataChannel 的事件”部分向你做更详细的介绍。</p>
<p>另外，RTCDataChannel 支持的数据类型也非常多，包括：字符串、Blob、ArrayBuffer 以及 ArrayBufferView。</p>
<p>实际上，关于这几种类型的联系与区别我在前面<a href="./109105.md">《04 | 可以把采集到的音视频数据录制下来吗？》</a>一文中已经向你做过详细的介绍，如果你现在记不清了，可以再去回顾一下。</p>
<p>WebRTC 的 RTCDataChannel 使用的传输协议为 SCTP，即 Stream Control Transport Protocol。下面图表表示的就是在 TCP、UDP 及 SCTP 等不同传输模式下，数据传输的可靠性、传递方式、流控等信息的对比：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/449eb9e60d271d868c7d5ecfb354a582.png" alt=""></p>
<p>RTCDataChannel 既可以在可靠的、有序的模式下工作，也可在不可靠的、无序的模式下工作，具体使用哪种模式可以根据用户的配置来决定。下面我们来看看它们之间的区别。</p>
<ul>
<li><strong>可靠有序模式（TCP 模式）</strong>：在这种模式下，消息可以有序到达，但同时也带来了额外的开销，所以在这种模式下<strong>消息传输会比较慢</strong>。</li>
<li><strong>不可靠无序模式（UDP 模式）</strong>：在此种模式下，不保证消息可达，也不保证消息有序，但在这种模式下没有什么额外开销，所以它<strong>非常快</strong>。</li>
<li><strong>部分可靠模式（SCTP 模式）</strong>：在这种模式下，消息的可达性和有序性可以根据业务需求进行配置。</li>
</ul>
<p>那接下来我们就来看一下到底该如何配置 RTCDataChannle 对象吧。</p>
<h2 id="配置-rtcdatachannel">配置 RTCDataChannel</h2>
<p>在创建 RTCDataChannel 对象之前，首先要创建 RTCPeerConnection 对象，因为 <strong>RTCDataChannel 对象是由 RTCPeerConnection 对象生成的</strong>。有了 RTCPeerConnection 对象后，调用它的 createDataChannel 方法，就可以将 RTCDataChannel 创建出来了。具体操作如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">new</span> <span class="n">RTCPeerConnection</span><span class="p">();</span> <span class="o">//</span> <span class="err">创建</span> <span class="n">RTCPeerConnection</span> <span class="err">对象</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">createDataChannel</span><span class="p">(</span><span class="s2">&#34;dc&#34;</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span> <span class="o">//</span> <span class="err">创建</span> <span class="n">RTCDataChannel</span> <span class="err">对象</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从上面的代码中可以看到 RTCDataChannel 对象是由 RTCPeerConnection 对象创建的，在创建 RTCDataChannel 对象时有两个参数。</p>
<ul>
<li>第一个参数是一个标签（字符串），相当于给 RTCDataChannel 起了一个名字；</li>
<li>第二个参数是 options，其形式如下：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">var</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">ordered</span><span class="p">:</span> <span class="bp">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">maxPacketLifeTime</span><span class="p">:</span> <span class="mi">3000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其实<strong>options</strong>可以指定很多选项，比如像上面所设置的，指定了创建的 RTCDataChannel 是否是有序的，以及最大的存活时间。</p>
<p>下面我就向你详细介绍一下 options 所支持的选项。</p>
<ul>
<li><strong>ordered</strong>：消息的传递是否有序。</li>
<li><strong>maxPacketLifeTime</strong>：重传消息失败的最长时间。也就是说超过这个时间后，即使消息重传失败了也不再进行重传了。</li>
<li><strong>maxRetransmits</strong>：重传消息失败的最大次数。</li>
<li><strong>protocol</strong>：用户自定义的子协议，也就是说可以根据用户自己的业务需求而定义的私有协议，默认为空。</li>
<li><strong>negotiated</strong>：如果为 true，则会删除另一方数据通道的自动设置。这也意味着你可以通过自己的方式在另一侧创建具有相同 ID 的数据通道。</li>
<li><strong>id</strong>：当 negotiated 为 true 时，允许你提供自己的 ID 与 channel 进行绑定。</li>
</ul>
<p>在上面的选项中，前三项是经常使用的，也是你要重点搞清楚的。不过需要特别说明的是， <strong>maxRetransmits 与 maxPacketLifeTime 是互斥的</strong>，也就是说这两者不能同时存在，只能二选一。</p>
<h2 id="rtcdatachannel-的事件">RTCDataChannel 的事件</h2>
<p>RTCDataChannel 的事件处理与 WebSocket 的事件处理非常相似，RTCDataChannel 在打开、关闭、接收到消息以及出错时都会有接收到事件。</p>
<p>而当你在使用 RTCDataChannel 时，对上面所描述的这些事件都要进行处理，所以就形成了下面这样的代码模板：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">dc.onerror = (error)=&gt; { // 出错
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> dc.onopen = ()=&gt; {// 打开
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> dc.onclose = () =&gt; {// 关闭
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> dc.onmessage = (event)=&gt;{// 收到消息
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以在使用 RTCDataChannel 对象时，你只要按上面的模板逐一实现其逻辑就好了，是不是很简单？</p>
<h2 id="实时文字聊天">实时文字聊天</h2>
<p>有了上面的知识，下面我们就来<strong>看一个具体的例子，看看如何通过 RTCDataChannel 对象实现一个实时文字聊天应用</strong>。</p>
<p>你可以想像这样一个场景，在两台不同的 PC 上（一个称为 A，另一个称为 B），用户打开浏览器，在页面上显示两个 textarea，一个作为文本输入框，另一个作为聊天记录的显示框。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/2984bef58875f130c46eb2cb5c725e37.png" alt=""></p>
<p>文本聊天图</p>
<p>当 A 向 B 发消息时，JavaScript 会从输入框中提取文本，然后通过 RTCDataChannel 发送出去。实际上，文本通过 RTCDataChannel 发送出去后，最终是经过 RTCPeerConnection 传送出去的。同理，B 向 A 发送文本数据时也是同样的流程。另一方面，当 B 收到 A 发送过来的文本数据后，也要通过 RTCDataChannel 对象来接收文本数据。</p>
<p>对于 RTCDataChannel 对象的创建主要有<strong>In-band 协商和 Out-of-band 协商</strong>两种方式。</p>
<h3 id="1-in-band-协商方式">1. In-band 协商方式</h3>
<p>此方式是默认方式。那什么是 In-band 协商方式呢？假设通信双方中的一方调用 <strong>createDataChannel</strong> 创建 RTCDataChannel 对象时，将 options 参数中的 <strong>negotiated</strong> 字段设置为 false，则通信的另一方就可以通过它的 RTCPeerConnection 对象的 <strong>ondatachannel</strong> 事件来得到与对方通信的 RTCDataChannel 对象了，这种方式就是 In-band 协商方式。</p>
<p>那 In-band 协商方式到底是如何工作的呢？下面我们就来详细描述一下。</p>
<ul>
<li>A 端调用 createDataChannel 创建 RTCDataChannel 对象。</li>
<li>A 端与 B 端交换 SDP，即进行媒体协商（offer/answer）。</li>
<li>媒体协商完成之后，双方连接就建立成功了。此时，A 端就可以向 B 端发送消息了。</li>
<li>当 B 端收到 A 端发的消息后，B 端的 ondatachannel 事件被触发，B 端的处理程序就可以从该事件的参数中获得与 A 端通信的 RTCDataChannel 对象。需要注意的是，该对象与 A 端创建的 RTCDataChannel 具有相同的属性。</li>
<li>此时双方的 RTCDataChannel 对象就可以进行双向通信了。</li>
</ul>
<p>该方法的<strong>优势是 RTCDataChannel 对象可以在需要时自动创建，不需要应用程序做额外的逻辑处理</strong>。</p>
<h3 id="2-out-of-band-协商方式">2. Out-of-band 协商方式</h3>
<p>RTCDataChannel 对象还能使用 Out-of-band 协商方式创建，这种方式不再是一端调用 createDataChannel，另一端监听 ondatachannel 事件，从而实现双方的数据通信；而是两端都调用 createDataChannel 方法创建 RTCDataChannel 对象，再通过 ID 绑定来实现双方的数据通信。具体步骤如下：</p>
<ul>
<li>A 端调用 createDataChannel({negotiated: true, id: 0}) 方法；</li>
<li>B 也调用 createDataChannel({negotiated: true, id: 0}) 方法；</li>
<li>双方交换 SDP，即进行媒体协商（offer/answer）；</li>
<li>一旦双方连接建立起来，数据通道可以被立即使用，它们是通过 ID 进行匹配的（这里的 ID 就是上面 options 中指定的 ID，ID 号必须一致）。</li>
</ul>
<p>这种方法的优势是，B 端不需等待有消息发送来再创建 RTCDataChannel 对象，所以双方发送数据时不用考虑顺序问题，即谁都可以先发数据，这是与 In-band 方式的最大不同，这也<strong>使得应用代码变得简单</strong>，因为你不需要处理 ondatachannel 事件了。</p>
<p>另外，需要注意的是，你选的 ID 不能是任意值。ID 值是从 0 开始计数的，也就是说你第一次创建的 RTCDataChannel 对象的 ID 是 0，第二个是 1，依次类推。所以这些 ID 只能与 WebRTC 实现协商的 SCTP 流数量一样，如果你使用的 ID 太大了，而又没有那么多的 SCTP 流的话，那么你的数据通道就不能正常工作了。</p>
<h2 id="具体例子">具体例子</h2>
<p>了解完相关理论后，接下来我们就实践起来，结合具体例子将这些理论应用起来。</p>
<p>在本文的例子中，我们使用的是 In-band 协商方式来创建 RTCDataChannel 对象。下面我们就来一步一步操作，看看一个文本聊天应用是如何实现的。</p>
<h3 id="1-添加事件">1. 添加事件</h3>
<p>为页面上的每个按钮添加 <strong>onclick 事件</strong>，具体如下面的示例代码所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">startButton</span> <span class="o">=</span> <span class="n">document</span><span class="o">.</span><span class="n">querySelector</span><span class="p">(</span><span class="s1">&#39;button#startButton&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">callButton</span> <span class="o">=</span> <span class="n">document</span><span class="o">.</span><span class="n">querySelector</span><span class="p">(</span><span class="s1">&#39;button#callButton&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">sendButton</span> <span class="o">=</span> <span class="n">document</span><span class="o">.</span><span class="n">querySelector</span><span class="p">(</span><span class="s1">&#39;button#sendButton&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">closeButton</span> <span class="o">=</span> <span class="n">document</span><span class="o">.</span><span class="n">querySelector</span><span class="p">(</span><span class="s1">&#39;button#closeButton&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">startButton</span><span class="o">.</span><span class="n">onclick</span> <span class="o">=</span> <span class="n">connectServer</span><span class="p">;</span> <span class="o">//</span><span class="n">createConnection</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">callButton</span><span class="o">.</span><span class="n">onclick</span> <span class="o">=</span> <span class="n">call</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">sendButton</span><span class="o">.</span><span class="n">onclick</span> <span class="o">=</span> <span class="n">sendData</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">closeButton</span><span class="o">.</span><span class="n">onclick</span> <span class="o">=</span> <span class="n">closeDataChannels</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个段代码中定义了 4 个 button，其中 Start 按钮用于与信令服务器建立连接；Call 用于创建 RTCDataChannel 对象；Send 用于发送文本数据；Close 用于关闭连接释放资源。</p>
<h3 id="2-创建连接">2. 创建连接</h3>
<p>用户在页面上点击 <strong>Start</strong> 按钮时，会调用 <strong>connectServer</strong> 方法。具体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  function connectServer(){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      socket = io.connect();  // 与服务器建立连接
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	 	 ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	 socket.on(&#39;created&#39;, function(room) { // 第一个用户加入后收到的消息
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	   createConnection();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	 });
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    	 socket.on(&#39;joined&#39;, function(room) { // 第二个用户加入后收到的消息
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	   createConnection();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	 });
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 	 ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span></code></pre></td></tr></table>
</div>
</div><p>从代码中可以看到，connectServer 函数首先调用 <code>io.connect()</code> 连接信令服务器，然后再根据信令服务器下发的消息做不同的处理。</p>
<blockquote>
<p>需要注意的是，在本例中我们使用了 socket.io 库与信令服务器建立连接。</p>
</blockquote>
<p>如果消息是 <strong>created</strong> 或 <strong>joined</strong>，则调用 createConnection 创建 RTCPeerConnection。其代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">servers</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;iceServers&#39;</span><span class="p">:</span> <span class="p">[{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	      <span class="s1">&#39;urls&#39;</span><span class="p">:</span> <span class="s1">&#39;turn:youdomain:3478&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	      <span class="s1">&#39;credential&#39;</span><span class="p">:</span> <span class="s2">&#34;passwd&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	      <span class="s1">&#39;username&#39;</span><span class="p">:</span> <span class="s2">&#34;username&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	    <span class="p">}]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">pc</span> <span class="o">=</span> <span class="n">new</span> <span class="n">RTCPeerConnection</span><span class="p">(</span><span class="n">servers</span><span class="p">,</span> <span class="n">pcConstraint</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">pc</span><span class="o">.</span><span class="n">onicecandidate</span> <span class="o">=</span> <span class="n">handleIceCandidate</span><span class="p">;</span> <span class="o">//</span> <span class="err">收集候选者</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">pc</span><span class="o">.</span><span class="n">ondatachannel</span> <span class="o">=</span> <span class="n">onDataChannelAdded</span><span class="p">;</span>  <span class="o">//</span> <span class="err">当对接创建数据通道时会回调该方法。</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过上面的代码就将 RTCPeerConnection 对象创建好了。</p>
<h3 id="3-创建-rtcdatachannel">3. 创建 RTCDataChannel</h3>
<p>当用户点击 Call 按钮时，会创建 RTCDataChannel，并发送 offer。具体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  dc = pc.createDataChannel(&#39;sendDataChannel&#39;,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	    dataConstraint); // 一端主动创建 RTCDataChannel
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  dc.onmessage = receivedMessage; // 当有文本数据来时，回调该函数。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	   pc.createOffer(setLocalAndSendMessage,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        onCreateSessionDescriptionError); // 创建 offer，如果成功，则在 setLocalAndSendMessage 函数中将 SDP 发送给远端
</span></span></code></pre></td></tr></table>
</div>
</div><p>当其中一方创建了 RTCDataChannel 且通信双方完成了媒体协商、交换了 SDP 之后，另一端收到发送端的消息，ondatachannel 事件就会被触发。此时就会调用它的回调函数 onDataChannelAdded，通过 onDataChannelAdded 函数的参数 event 你就可以获取到另一端的 RTCDataChannel 对象了。具体如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  function onDataChannelAdded(event) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      dc = event.channel;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      dc.onmessage = receivedMessage;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  }
</span></span></code></pre></td></tr></table>
</div>
</div><p>至此，双方就可以通过 RTCDataChannel 对象进行双向通信了。</p>
<h3 id="4-数据的发送与接收">4. 数据的发送与接收</h3>
<p>数据的发送非常简单，当用户点击 Send 按钮后，文本数据就会通过 RTCDataChannel 传输到远端。其代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">function</span> <span class="n">sendData</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">var</span> <span class="n">data</span> <span class="o">=</span> <span class="n">dataChannelSend</span><span class="o">.</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">dc</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而对于接收数据，则是通过 RTCDataChannel 的 onmessage 事件实现的。当该事件触发后，会调用 receivedMessage 方法。通过其参数就可以获取到对端发送的文本数据了。具体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">function</span> <span class="n">receivedMessage</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">var</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="n">dataChannelReceive</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="s2">&#34;&lt;- &#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s2">&#34;</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>以上就是文本聊天的大体逻辑。具体的代码你可以到（文末的）<a href="./19%5Fchat.md">GitHub 链接</a>上获取。</p>
<h2 id="小结">小结</h2>
<p>本文我们结合具体的例子——实时文字聊天，向你详细介绍了如何使用 RTCDataChannel 进行非音视频数据的传输。</p>
<p>RTCDataChannel 的创建有两种方式，一种是默认的 In-band 协商方式，另一种是 Out-of-band 协商方式。在本文例子的实践部分，我们主要应用的是第一种方式。但一般情况下我更推荐使用第二种方式，因为它更高效、更简洁。</p>
<p>另外，在使用 RTCDataChannel 时，还有两点你需要注意：</p>
<ol>
<li>RTCDataChannel 对象的创建要在媒体协商（offer/answer）之前创建，否则 WebRTC 就会一直处于 connecting 状态，从而导致数据无法进行传输。</li>
<li>RTCDataChannel 对象是可以双向传输数据的，所以接收与发送使用一个 RTCDataChannel 对象即可，而不需要为发送和接收单独创建 RTCDataChannel 对象。</li>
</ol>
<p>当然本文只是介绍了 RTCDataChannel 的“一种”具体应用，若你有兴趣还可以自行实践其他更有趣的实现。</p>
<h2 id="思考时间">思考时间</h2>
<p>今天留给你的思考题是：SCTP 协议是运行在 TCP 协议之上还是 UDP 协议之上呢？</p>
<p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>
<h2 id="参考">参考</h2>
<p>具体代码地址：<a href="https://github.com/avdance/webrtc%5Fweb/tree/master/19%5Fchat/">https://github.com/avdance/webrtc%5Fweb/tree/master/19%5Fchat/</a></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/b76671e85154bd22630b3e9c53a64d98.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/">从0打造音视频直播系统</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE/19_spark%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8A/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">19_Spark的性能优化案例分析（上）</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/linux%E5%86%85%E6%A0%B8%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98%E8%AF%BE/19_%E6%A1%88%E4%BE%8B%E7%AF%87__%E7%BD%91%E7%BB%9C%E5%90%9E%E5%90%90%E9%AB%98%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%BC%80%E5%90%AF%E7%BD%91%E5%8D%A1%E7%89%B9%E6%80%A7%E5%91%A2/">
            <span class="next-text nav-default">19_案例篇__网络吞吐高的业务是否需要开启网卡特性呢？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
