<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>19_综合案例实战：处理加州房屋信息，构建线性回归模型 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是蔡元楠。
今天我要与你分享的主题是“综合案例实战：处理加州房屋信息，构建线性回归模型”。
通过之前的学习，我们对 Spark 各种 API 的基本用法有了一定的了解，还通过统计词频的实例掌握了如何从零开始写一个 Spark 程序。那么现在，让我们从一个真实的数据集出发，看看如何用 Spark 解决实际问题。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/19_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98%E5%A4%84%E7%90%86%E5%8A%A0%E5%B7%9E%E6%88%BF%E5%B1%8B%E4%BF%A1%E6%81%AF%E6%9E%84%E5%BB%BA%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/19_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98%E5%A4%84%E7%90%86%E5%8A%A0%E5%B7%9E%E6%88%BF%E5%B1%8B%E4%BF%A1%E6%81%AF%E6%9E%84%E5%BB%BA%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="19_综合案例实战：处理加州房屋信息，构建线性回归模型">
  <meta property="og:description" content="你好，我是蔡元楠。
今天我要与你分享的主题是“综合案例实战：处理加州房屋信息，构建线性回归模型”。
通过之前的学习，我们对 Spark 各种 API 的基本用法有了一定的了解，还通过统计词频的实例掌握了如何从零开始写一个 Spark 程序。那么现在，让我们从一个真实的数据集出发，看看如何用 Spark 解决实际问题。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="大规模数据处理实战">

  <meta itemprop="name" content="19_综合案例实战：处理加州房屋信息，构建线性回归模型">
  <meta itemprop="description" content="你好，我是蔡元楠。
今天我要与你分享的主题是“综合案例实战：处理加州房屋信息，构建线性回归模型”。
通过之前的学习，我们对 Spark 各种 API 的基本用法有了一定的了解，还通过统计词频的实例掌握了如何从零开始写一个 Spark 程序。那么现在，让我们从一个真实的数据集出发，看看如何用 Spark 解决实际问题。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3862">
  <meta itemprop="keywords" content="大规模数据处理实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="19_综合案例实战：处理加州房屋信息，构建线性回归模型">
  <meta name="twitter:description" content="你好，我是蔡元楠。
今天我要与你分享的主题是“综合案例实战：处理加州房屋信息，构建线性回归模型”。
通过之前的学习，我们对 Spark 各种 API 的基本用法有了一定的了解，还通过统计词频的实例掌握了如何从零开始写一个 Spark 程序。那么现在，让我们从一个真实的数据集出发，看看如何用 Spark 解决实际问题。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">19_综合案例实战：处理加州房屋信息，构建线性回归模型</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3862 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#数据集介绍">数据集介绍</a></li>
        <li><a href="#进一步了解数据集">进一步了解数据集</a></li>
        <li><a href="#预处理">预处理</a></li>
        <li><a href="#创建模型">创建模型</a></li>
        <li><a href="#模型评估">模型评估</a></li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#实践与思考题">实践与思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是蔡元楠。</p>
<p>今天我要与你分享的主题是“综合案例实战：处理加州房屋信息，构建线性回归模型”。</p>
<p>通过之前的学习，我们对 Spark 各种 API 的基本用法有了一定的了解，还通过统计词频的实例掌握了如何从零开始写一个 Spark 程序。那么现在，让我们从一个真实的数据集出发，看看如何用 Spark 解决实际问题。</p>
<h2 id="数据集介绍">数据集介绍</h2>
<p>为了完成今天的综合案例实战，我使用的是美国加州 1990 年房屋普查的数据集。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/eadd2d3d0f7a2db84f9520cfb5f6029e.png" alt=""></p>
<p>数据集中的每一个数据都代表着一块区域内房屋和人口的基本信息，总共包括 9 项：</p>
<ol>
<li>该地区中心的纬度（latitude）</li>
<li>该地区中心的经度（longitude）</li>
<li>区域内所有房屋屋龄的中位数（housingMedianAge）</li>
<li>区域内总房间数（totalRooms）</li>
<li>区域内总卧室数（totalBedrooms）</li>
<li>区域内总人口数（population）</li>
<li>区域内总家庭数（households）</li>
<li>区域内人均收入中位数（medianIncome）</li>
<li>该区域房价的中位数（medianHouseValue）</li>
</ol>
<p>也就是说，我们可以把每一个数据看作一个地区，它含有 9 项我们关心的信息，也就是上面提到的 9 个指标。比如下面这个数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-122.230000,37.880000,41.000000,880.000000,129.000000,322.000000,126.000000,8.325200,452600.000000&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个数据代表该地区的经纬度是（-122.230000,37.880000），这个地区房屋历史的中位数是 41 年，所有房屋总共有 880 个房间，其中有 129 个卧室。这个地区内共有 126 个家庭和 322 位居民，人均收入中位数是 8.3252 万，房价中位数是 45.26 万。</p>
<p>这里的地域单位是美国做人口普查的最小地域单位，平均一个地域单位中有 1400 多人。在这个数据集中共有两万多个这样的数据。显然，这样小的数据量我们并“不需要”用 Spark 来处理，但是，它可以起到一个很好的示例作用。这个数据集可以从<a href="./cal%5Fhousing.md">网上</a>下载到。这个数据集是在 1997 年的一篇学术论文中创建的，感兴趣的同学可以去亲自下载，并加以实践。</p>
<p>那么我们今天的目标是什么呢？就是用已有的数据，构建一个<strong>线性回归模型</strong>，来预测房价。</p>
<p>我们可以看到，前 8 个属性都可能对房价有影响。这里，我们假设这种影响是线性的，我们就可以找到一个类似<strong>A=b_B+c_C+d_D+…+i_I</strong>的公式，A 代表房价，B 到 I 分别代表另外八个属性。这样，对于不在数据集中的房子，我们可以套用这个公式来计算出一个近似的房价。由于专栏的定位是大规模数据处理专栏，所以我们不会细讲统计学的知识。如果你对统计学知识感兴趣，或者还不理解什么是线性回归的话，可以去自行学习一下。</p>
<h2 id="进一步了解数据集">进一步了解数据集</h2>
<p>每当我们需要对某个数据集进行处理时，不要急着写代码。你一定要先观察数据集，了解它的特性，并尝试对它做一些简单的预处理，让数据的可读性更好。这些工作我们最好在 Spark 的交互式 Shell 上完成，而不是创建 python 的源文件并执行。因为，在 Shell 上我们可以非常直观而简便地看到每一步的输出。</p>
<p>首先，让我们把数据集读入 Spark。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">from</span> <span class="n">pyspark</span><span class="o">.</span><span class="n">sql</span> <span class="n">import</span> <span class="n">SparkSession</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1"># 初始化 SparkSession 和 SparkContext</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">spark</span> <span class="o">=</span> <span class="n">SparkSession</span><span class="o">.</span><span class="n">builder</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="n">master</span><span class="p">(</span><span class="s2">&#34;local&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="n">appName</span><span class="p">(</span><span class="s2">&#34;California Housing &#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="s2">&#34;spark.executor.memory&#34;</span><span class="p">,</span> <span class="s2">&#34;1gb&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="n">getOrCreate</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">sc</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sparkContext</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1"># 读取数据并创建 RDD</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="p">(</span><span class="s1">&#39;/Users/yourName/Downloads/CaliforniaHousing/cal_housing.data&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="c1"># 读取数据每个属性的定义并创建 RDD</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">header</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="p">(</span><span class="s1">&#39;/Users/yourName/Downloads/CaliforniaHousing/cal_housing.domain&#39;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样，我们就把房屋信息数据和每个属性的定义读入了 Spark，并创建了两个相应的 RDD。你还记得吧？RDD 是有一个惰性求值的特性的，所以，我们可以用 collect() 函数来把数据输出在 Shell 上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">header.collect()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> [u&#39;longitude: continuous.&#39;, u&#39;latitude: continuous.&#39;, u&#39;housingMedianAge: continuous. &#39;, u&#39;totalRooms: continuous. &#39;, u&#39;totalBedrooms: continuous. &#39;, u&#39;population: continuous. &#39;, u&#39;households: continuous. &#39;, u&#39;medianIncome: continuous. &#39;, u&#39;medianHouseValue: continuous. &#39;]
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样，我们就得到了每个数据所包含的信息，这和我们前面提到的 9 个属性的顺序是一致的，而且它们都是连续的值，而不是离散的。你需要注意的是，collect() 函数会把所有数据都加载到内存中，如果数据很大的话，有可能会造成内存泄漏，所以要小心使用。平时比较常见的方法是用 take() 函数去只读取 RDD 中的某几个元素。</p>
<p>由于 RDD 中的数据可能会比较大，所以接下来让我们读取它的前两个数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">rdd.take(2)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> [u&#39;-122.230000,37.880000,41.000000,880.000000,129.000000,322.000000,126.000000,8.325200,452600.000000&#39;, u&#39;-122.220000,37.860000,21.000000,7099.000000,1106.000000,2401.000000,1138.000000,8.301400,358500.000000&#39;]
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于我们是用 SparkContext 的 textFile 函数去创建 RDD，所以每个数据其实是一个大的字符串，各个属性之间用逗号分隔开来。这不利于我们之后的处理，因为我们可能会需要分别读取每个对象的各个属性。所以，让我们用 map 函数把大字符串分隔成数组，这会方便我们的后续操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">rdd = rdd.map(lambda line: line.split(&#34;,&#34;))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">rdd.take(2)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> [[u&#39;-122.230000&#39;, u&#39;37.880000&#39;, u&#39;41.000000&#39;, u&#39;880.000000&#39;, u&#39;129.000000&#39;, u&#39;322.000000&#39;, u&#39;126.000000&#39;, u&#39;8.325200&#39;, u&#39;452600.000000&#39;], [u&#39;-122.220000&#39;, u&#39;37.860000&#39;, u&#39;21.000000&#39;, u&#39;7099.000000&#39;, u&#39;1106.000000&#39;, u&#39;2401.000000&#39;, u&#39;1138.000000&#39;, u&#39;8.301400&#39;, u&#39;358500.000000&#39;]]
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们在前面学过，Spark SQL 的 DataFrame API 在查询结构化数据时更方便使用，而且性能更好。在这个例子中你可以看到，数据的 schema 是定义好的，我们需要去查询各个列，所以 DataFrame API 显然更加适用。所以，我们需要先把 RDD 转换为 DataFrame。</p>
<p>具体来说，就是需要把之前用数组代表的对象，转换成为 Row 对象，再用 toDF() 函数转换成 DataFrame。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">from pyspark.sql import Row
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> df = rdd.map(lambda line: Row(longitude=line[0],
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                             latitude=line[1],
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                             housingMedianAge=line[2],
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                             totalRooms=line[3],
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                             totalBedRooms=line[4],
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                             population=line[5],
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                             households=line[6],
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                             medianIncome=line[7],
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                             medianHouseValue=line[8])).toDF()
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在我们可以用 show() 函数打印出这个 DataFrame 所含的数据表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">df.show()
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/8945d9e1e4bf7e91797ae42be1009714.png" alt=""></p>
<p>这里每一列的数据格式都是 string，但是，它们其实都是数字，所以我们可以通过 cast() 函数把每一列的类型转换成 float。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def convertColumn(df, names, newType)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> for name in names:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    df = df.withColumn(name, df[name].cast(newType))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> return df
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> columns = [&#39;households&#39;, &#39;housingMedianAge&#39;, &#39;latitude&#39;, &#39;longitude&#39;, &#39;medianHouseValue&#39;, &#39;medianIncome&#39;, &#39;population&#39;, &#39;totalBedRooms&#39;, &#39;totalRooms&#39;]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> df = convertColumn(df, columns, FloatType())
</span></span></code></pre></td></tr></table>
</div>
</div><p>转换成数字有很多优势。比如，我们可以按某一列，对所有对象进行排序，也可以计算平均值等。比如，下面这段代码就可以统计出所有建造年限各有多少个房子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">df.groupBy(&#34;housingMedianAge&#34;).count().sort(&#34;housingMedianAge&#34;,ascending=False).show()
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="预处理">预处理</h2>
<p>通过上面的数据分析，你可能会发现这些数据还是不够直观。具体的问题有：</p>
<ol>
<li>房价的值普遍都很大，我们可以把它调整成相对较小的数字；</li>
<li>有的属性没什么意义，比如所有房子的总房间数和总卧室数，我们更加关心的是平均房间数；</li>
<li>在我们想要构建的线性模型中，房价是结果，其他属性是输入参数。所以我们需要把它们分离处理；</li>
<li>有的属性最小值和最大值范围很大，我们可以把它们标准化处理。</li>
</ol>
<p>对于第一点，我们观察到大多数房价都是十万起的，所以可以用 withColumn() 函数把所有房价都除以 100000。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">df = df.withColumn(&#34;medianHouseValue&#34;, col(&#34;medianHouseValue&#34;)/100000)
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于第二点，我们可以添加如下三个新的列：</p>
<ul>
<li>每个家庭的平均房间数：roomsPerHousehold</li>
<li>每个家庭的平均人数：populationPerHousehold</li>
<li>卧室在总房间的占比：bedroomsPerRoom</li>
</ul>
<p>当然，你们可以自由添加你们觉得有意义的列，这里的三个是我觉得比较典型的。同样，用 withColumn() 函数可以容易地新建列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">df = df.withColumn(&#34;roomsPerHousehold&#34;, col(&#34;totalRooms&#34;)/col(&#34;households&#34;))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  .withColumn(&#34;populationPerHousehold&#34;, col(&#34;population&#34;)/col(&#34;households&#34;))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  .withColumn(&#34;bedroomsPerRoom&#34;, col(&#34;totalBedRooms&#34;)/col(&#34;totalRooms&#34;))
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样，有的列是我们并不关心的，比如经纬度，这个数值很难有线性的意义。所以我们可以只留下重要的信息列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">df = df.select(&#34;medianHouseValue&#34;,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">             &#34;totalBedRooms&#34;,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">             &#34;population&#34;,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">             &#34;households&#34;,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">             &#34;medianIncome&#34;,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">             &#34;roomsPerHousehold&#34;,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">             &#34;populationPerHousehold&#34;,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">             &#34;bedroomsPerRoom&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于第三点，最简单的办法就是把 DataFrame 转换成 RDD，然后用 map() 函数把每个对象分成两部分：房价和一个包含其余属性的列表，然后在转换回 DataFrame。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">from pyspark.ml.linalg import DenseVector
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> input_data = df.rdd.map(lambda x: (x[0], DenseVector(x[1:])))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">df = spark.createDataFrame(input_data, [&#34;label&#34;, &#34;features&#34;])
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们重新把两部分重新标记为“label”和“features”，label 代表的是房价，features 代表包括其余参数的列表。</p>
<p>对于第四点，数据的标准化我们可以借助 Spark 的机器学习库 Spark ML 来完成。Spark ML 也是基于 DataFrame，它提供了大量机器学习的算法实现、数据流水线（pipeline）相关工具和很多常用功能。由于本专栏的重点是大数据处理，所以我们并没有介绍 Spark ML，但是我强烈推荐同学们有空去了解一下它。</p>
<p>在这个 AI 和机器学习的时代，我们不能落伍。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">from pyspark.ml.feature import StandardScaler
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> standardScaler = StandardScaler(inputCol=&#34;features&#34;, outputCol=&#34;features_scaled&#34;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">scaler = standardScaler.fit(df)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">scaled_df = scaler.transform(df)
</span></span></code></pre></td></tr></table>
</div>
</div><p>在第二行，我们创建了一个 StandardScaler，它的输入是 features 列，输出被我们命名为 features_scaled。第三、第四行，我们把这个 scaler 对已有的 DataFrame 进行处理，让我们看下代码块里显示的输出结果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">scaled_df.take(1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> [Row(label=4.526, features=DenseVector([129.0, 322.0, 126.0, 8.3252, 6.9841, 2.5556, 0.1466]), features_scaled=DenseVector([0.3062, 0.2843, 0.3296, 4.3821, 2.8228, 0.2461, 2.5264]))]
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以清楚地看到，这一行新增了一个 features_scaled 的列，它里面每个数据都是标准化过的，我们应该用它，而非 features 来训练模型。</p>
<h2 id="创建模型">创建模型</h2>
<p>上面的预处理都做完后，我们终于可以开始构建线性回归模型了。</p>
<p>首先，我们需要把数据集分为训练集和测试集，训练集用来训练模型，测试集用来评估模型的正确性。DataFrame 的 randomSplit() 函数可以很容易的随机分割数据，这里我们将 80% 的数据用于训练，剩下 20% 作为测试集。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">train_data, test_data = scaled_df.randomSplit([.8,.2],seed=123)
</span></span></code></pre></td></tr></table>
</div>
</div><p>用 Spark ML 提供的 LinearRegression 功能，我们可以很容易得构建一个线性回归模型，如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">from pyspark.ml.regression import LinearRegression
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> lr = LinearRegression(featuresCol=&#39;features_scaled&#39;, labelCol=&#34;label&#34;, maxIter=10, regParam=0.3, elasticNetParam=0.8)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">linearModel = lr.fit(train_data)
</span></span></code></pre></td></tr></table>
</div>
</div><p>LinearRegression 可以调节的参数还有很多，你可以去<a href="./pyspark.ml.md#pyspark.ml.regression.LinearRegression">官方 API 文档</a>查阅，这里我们只是示范一下。</p>
<h2 id="模型评估">模型评估</h2>
<p>现在有了模型，我们终于可以用 linearModel 的 transform() 函数来预测测试集中的房价，并与真实情况进行对比。代码如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">predicted = linearModel.transform(test_data)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">predictions = predicted.select(&#34;prediction&#34;).rdd.map(lambda x: x[0])
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">labels = predicted.select(&#34;label&#34;).rdd.map(lambda x: x[0])
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">predictionAndLabel = predictions.zip(labels).collect()
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们用 RDD 的 zip() 函数把预测值和真实值放在一起，这样可以方便地进行比较。比如让我们看一下前两个对比结果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">predictionAndLabel.take(2)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> [(1.4491508524918457, 1.14999), (1.5831547768979277, 0.964)]
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里可以看出，我们的模型预测的结果有些偏小，这可能有多个因素造成。最直接的原因就是房价与我们挑选的列并没有强线性关系，而且我们使用的参数也可能不够准确。</p>
<p>这一讲我只是想带着你一起体验下处理真实数据集和解决实际问题的感觉，想要告诉你的是这种通用的思想，并帮助你继续熟悉 Spark 各种库的用法，并不是说房价一定就是由这些参数线性决定了。感兴趣的同学可以去继续优化，或者尝试别的模型比如逻辑回归。</p>
<h2 id="小结">小结</h2>
<p>这一讲我们通过一个真实的数据集，通过以下步骤解决了一个实际的数据处理问题：</p>
<ol>
<li>观察并了解数据集</li>
<li>数据清洗</li>
<li>数据的预处理</li>
<li>训练模型</li>
<li>评估模型</li>
</ol>
<p>其实这里还可以有与“优化与改进”相关的内容，这里没有去阐述是因为我们的首要目的依然是熟悉与使用 Spark 各类 API。相信通过今天的学习，你初步了解了数据处理问题的一般思路，并强化了对 RDD、DataFrame 和机器学习 API 的使用。</p>
<h2 id="实践与思考题">实践与思考题</h2>
<p>今天请你下载这个数据集，按文章的介绍去动手实践一次。如果有时间的话，还可以对这个过程的优化和改进提出问题并加以解决。</p>
<p>欢迎你在留言板贴出自己的 idea。如果你觉得有所收获，也欢迎你把文章分享给朋友。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/a0f5b0b51dbfc98740637837dc0ae117.png" alt="unpreview"></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/">大规模数据处理实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/19_%E9%9A%9C%E7%A2%8D%E4%BB%8E%E8%AE%A1%E5%88%92%E5%88%B0%E5%9D%9A%E6%8C%81%E5%86%8D%E5%88%B0%E5%9D%9A%E6%8C%81%E4%B8%8D%E4%B8%8B%E5%8E%BB%E7%9A%84%E6%97%B6%E5%80%99/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">19_障碍：从计划到坚持，再到坚持不下去的时候</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/reacthooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/19%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E5%BA%93%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E5%BA%93%E6%9C%89%E5%93%AA%E4%BA%9B/">
            <span class="next-text nav-default">19｜第三方工具库：最常用的第三方工具库有哪些？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
