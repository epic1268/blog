<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>08__该怎么选择初始化向量？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是范学雷。
上一讲，我们讨论了对称密钥的常见算法，还讲到了序列算法和分组算法。还记得吗？当时，我建议你优先使用序列算法，因为它有着良好的性能和皮实的用法。另外，我还向你推荐了 AES-256 和 AES-128。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%9E%E7%94%A8%E5%AF%86%E7%A0%81%E5%AD%A6/08__%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%91%E9%87%8F/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%9E%E7%94%A8%E5%AF%86%E7%A0%81%E5%AD%A6/08__%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%91%E9%87%8F/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="08__该怎么选择初始化向量？">
  <meta property="og:description" content="你好，我是范学雷。
上一讲，我们讨论了对称密钥的常见算法，还讲到了序列算法和分组算法。还记得吗？当时，我建议你优先使用序列算法，因为它有着良好的性能和皮实的用法。另外，我还向你推荐了 AES-256 和 AES-128。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="实用密码学">

  <meta itemprop="name" content="08__该怎么选择初始化向量？">
  <meta itemprop="description" content="你好，我是范学雷。
上一讲，我们讨论了对称密钥的常见算法，还讲到了序列算法和分组算法。还记得吗？当时，我建议你优先使用序列算法，因为它有着良好的性能和皮实的用法。另外，我还向你推荐了 AES-256 和 AES-128。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3425">
  <meta itemprop="keywords" content="实用密码学">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="08__该怎么选择初始化向量？">
  <meta name="twitter:description" content="你好，我是范学雷。
上一讲，我们讨论了对称密钥的常见算法，还讲到了序列算法和分组算法。还记得吗？当时，我建议你优先使用序列算法，因为它有着良好的性能和皮实的用法。另外，我还向你推荐了 AES-256 和 AES-128。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">08__该怎么选择初始化向量？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3425 字 </span>
          <span class="more-meta"> 预计阅读 7 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#分组算法怎么计算">分组算法怎么计算？</a></li>
        <li><a href="#什么影响算法的安全性">什么影响算法的安全性？</a></li>
        <li><a href="#初始化向量怎么选">初始化向量怎么选？</a></li>
        <li><a href="#一个密钥能用多少次">一个密钥能用多少次？</a></li>
        <li><a href="#take-away今日收获">Take Away（今日收获）</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是范学雷。</p>
<p>上一讲，我们讨论了对称密钥的常见算法，还讲到了序列算法和分组算法。还记得吗？当时，我建议你优先使用序列算法，因为它有着良好的性能和皮实的用法。另外，我还向你推荐了 AES-256 和 AES-128。</p>
<p>但是，由于我们还没有考虑数据分组等因素的影响，所以这个建议的实用性还有待商榷。那么，这一讲，我们就来看看对于分组算法，到底有哪些麻烦？我们又该怎么避免这些麻烦？</p>
<p>其实，这是一个解决起来很复杂的问题。不过，今天我们可以先对问题建立一个初步的认知。</p>
<p>要知道分组算法有哪些麻烦，就要先知道该怎么计算分组算法。</p>
<h2 id="分组算法怎么计算">分组算法怎么计算？</h2>
<p>我们在上一讲说过，分组算法要对输入数据进行分组，然后按数据分组来进行运算。一个典型的分组算法，一般要由三个部分组成，数据分组、分组运算和链接模式。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%9E%E7%94%A8%E5%AF%86%E7%A0%81%E5%AD%A6/34bdaa7de62f181582cdcbe755373881.png" alt=""></p>
<p>我们先来看看数据分组是怎么一回事。</p>
<p>数据分组在加密时，会把明文的输入数据分割成加密函数能够处理的数据块。比如，AES 算法能够处理的数据块大小是 128 位，那么，输入数据就要被分割成一个或者多个 128 位的小数据块。</p>
<p>如果不能整分，就要把最后一个分组补齐成 128 位。这些分组数据的运算结果，组合起来就是<strong>密文数据</strong>。解密时，执行相反的操作，把补齐数据去掉，再把数据分组组合成完整的明文数据。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%9E%E7%94%A8%E5%AF%86%E7%A0%81%E5%AD%A6/29c402b33b726d1a29f5fe4a1efe8c6b.png" alt=""></p>
<p>理解了数据分组，我们再来看分组运算和链接模式。</p>
<p><strong>分组运算</strong>，意思就是把每一个明文数据分组通过加密函数，转换成密文数据分组。而<strong>链接模式</strong>，指的是如何把上一个分组运算和下一个分组运算联系起来。</p>
<p>有一点需要说，第一个分组运算并没有上一个分组运算可以使用，这时候，我们就需要引入一个初始化的数据，来承担“上一个分组运算”向下链接的功能。这个初始化的数据，我们一般称为<strong>初始化向量</strong>。</p>
<p>那你有没有想过，我们为什么要把上一个分组运算和下一个分组运算联系起来呢？其实，我们在前面讨论过单向散列函数的链接模式，我们说它是为了确保雪崩效应能够延续。</p>
<p>在分组运算里，链接模式也承担类似的功能：</p>
<ol>
<li>不同的明文数据，它的密文数据应该是完全不同的，即使明文数据里包含相同的数据分组；</li>
<li>相同的明文数据，每一次的加密运算，它的密文数据也应该是完全不同的。</li>
</ol>
<h2 id="什么影响算法的安全性">什么影响算法的安全性？</h2>
<p>现在，我们已经梳理了一遍分组算法的运算过程了。这样，我们就能够在其中找到影响分组算法的关键因素。这些因素，也就是影响分组算法安全性的因素。</p>
<p>在数据分组里，把输入数据分割成固定大小的数据块这一部分，除了数据补齐之外，没有什么变数。所以，我们可以发现，数据补齐方案才是影响分组算法的关键部分。</p>
<p>这样，我们就不难找出下面的五个因素：</p>
<ol>
<li>加密函数和解密函数；</li>
<li>密钥；</li>
<li>初始化向量；</li>
<li>链接模式；</li>
<li>数据补齐方案。</li>
</ol>
<p>通过上一讲的讨论，我想我们都了解加密函数、解密函数和密钥在分组算法中的重要地位了。如果加密函数不安全，整个分组算法的安全性也就坍塌了；如果密钥没有做好保密或者密钥质量不好，数据的保密性也就无从谈起。</p>
<p>比如说，我们经常看到宣传，说什么采用了 AES-256 算法，安全强度有保障；说什么只有造一台时光机，穿越回历史现场，才能破解一个应用。这些说法，有它的道理，但是仅仅依据这些信息，还不能确认一个算法的使用和运算是不是安全的。</p>
<p>另外三个因素，就是经常被我们忽视的因素。那么，它们是怎么影响算法安全性的呢？</p>
<h2 id="初始化向量怎么选">初始化向量怎么选？</h2>
<p>我们今天先讨论第一个影响的因素：初始化向量。</p>
<p>我们要想了解初始化向量对算法安全性的影响，就要先看看第一个数据块是怎么计算的，第一个数据块和初始化向量关系紧密。第一个数据块的计算，它的输入信息包括：</p>
<ol>
<li>密钥；</li>
<li>初始化向量；</li>
<li>第一个明文数据分组。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%AE%9E%E7%94%A8%E5%AF%86%E7%A0%81%E5%AD%A6/9f2f170937458986ed41527da9a37c4f.png" alt=""></p>
<p>如果我们能够确定这些输入信息，那么输出的第一个密文数据分组也就确定了。</p>
<p>一般来说，一个对称密钥要使用多次，对多个明文数据进行加密运算。如果存在第一个明文数据分组相同的两段数据，并且使用了相同的初始化向量，那么第一个密文数据分组就是相同的。</p>
<p>也就是说，相同的输入，就会有相同的输出。</p>
<p>对于大部分算法而言，分组数据块都比较小，比如，AES 算法的分组数据块大小是 16 个字节。这样，在实际应用中，就比较容易构造相同的数据块，或者存在相同的数据块。</p>
<p>在现实的应用里，也存在大量的、重复的、已知的数据，比如 HTTP 协议的头部数据。如果我们需要保密的数据恰好重复了一段已知的明文，攻击者就可以根据密文数据是不是相同，来猜测、寻找明文数据。这样的话，就破坏了数据的保密性。</p>
<p>但是，我们在使用加密运算时，大部分时候都没有办法确定明文数据会不会有重复数据，以及重复数据会不会是一次加密运算的第一个数据块。所以，如果不想暴露重复数据的机密性，我们只能在初始化向量这一个因素上想办法。因为，密钥是相同的，如果第一个明文数据分组也是相同的，只剩下初始化向量这一个输入信息可以控制了。</p>
<p><strong>在一个对称密钥的生命周期里，初始化向量不能重复，这是使用对称密钥算法的第一个要求。</strong></p>
<p>这个要求看似简单，其实做起来并不容易。一个单纯的加密算法的实现，一般没有办法记住一个初始化向量有没有用过。这就需要应用程序的开发者自己想办法，常见的办法有两种：</p>
<ol>
<li>使用安全强度足够的随机数作为初始化向量；</li>
<li>使用序列数，下一次的初始化向量的数值，比上一次的数字自动加一或者自动减一。</li>
</ol>
<p>不过，这两种初始化向量的选择，还是各有各的问题，我们需要注意。</p>
<p>第一种，随机数的获取，有时候不是一个有效率的运算。如果随机数发生器选择不当，还会造成加密运算的阻塞，进一步降低加密运算的效率。另外，由于解密需要相同的初始向量，如何在加密端和解密端同步初始化向量，也是一个需要考虑的问题。</p>
<p>一个常见的解决办法，就是把初始化向量和加密数据一起发送给对方。</p>
<p>第二种的话，使用序列数，需要保持序列数的状态，还需要加密运算的同步。不过，序列数状态的保持和同步，除了效率之外，还会衍生出其他的待解决的问题，比如分布式计算环境下的序列数同步问题，比如攻击者会知道每一个初始化向量的问题。</p>
<p>如果你能够看到的问题无法解决，可以考虑使用随机数作为初始化向量。</p>
<p>你看，初始化向量选择充满了复杂性，一般的密钥算法库都不会提供缺省的、自动的初始化向量。<strong>应用程序需要根据使用场景来制定适当的初始化向量选择方案，这是一个容易忽略的要求</strong>。</p>
<h2 id="一个密钥能用多少次">一个密钥能用多少次？</h2>
<p>在这一讲的最后，我们来讨论一个话题，一个密钥有没有使用次数的限制呢？为什么要在这一讲讨论这个话题呢？因为，我想，这是一个恰当的时机。</p>
<p>前面，我们讨论了，在一个对称密钥的生命周期里，初始化向量不能重复。也就是说，对于一个算法来说，初始化向量的长度是固定的。长度固定，也就意味着初始化向量的个数是有限制的。</p>
<p>比如，一个 128 位的初始化向量，最多有 2^ 128 个不重复的数值。进一步的说，对于这个算法，一个密钥最多只能使用 2^ 128 次。的确看起来，2^128 是一个巨大的数字，一般的应用程序也没有什么机会使用这么多次加密运算。</p>
<p>当然，还有其他因素限制密钥的使用次数。很多限制因素的叠加，就会使得密钥使用的限制数远远低于初始化向量的许可数目。所以，<strong>我们心里一定要知道，密钥是有使用次数限制的，并且要有检查密钥使用次数限制的习惯</strong>。</p>
<p>这是一个不太引人注意的安全陷阱，也是近几年才受到广泛关注的算法安全问题。我们后面还会讨论其他的限制条件，并且我会罗列出来不同算法的使用限制。</p>
<p>之后的两讲，我们就接着今天的话题，看看除了初始化向量之外，链接模式和数据补齐方案是怎么影响对称密钥算法的安全性的？这两个问题的讨论，需要较大篇幅，不过我会带你一起分析。</p>
<h2 id="take-away今日收获">Take Away（今日收获）</h2>
<p>今天，通过解构分组算法的运算，我们讨论了影响分组算法安全性的五个关键因素。然后讨论了选择初始化向量应该注意的陷阱，也就是说，在使用对称密钥加密时，初始化向量不能重复。</p>
<p>最后，我们还讨论了一个不太容易受关注的问题，就是密钥是有使用次数限制的。一般的应用程序，密钥使用次数限制不是问题，但是如果你要设计一个广泛使用的协议，还是要考虑密钥这个限制的。密钥使用次数用完之前，一定要更新密钥。</p>
<p>今天，我们应该理解、记住：</p>
<ol>
<li>分组算法的处理过程；</li>
<li>影响对称密钥算法安全性的五个关键因素；</li>
<li>在一个对称密钥的生命周期里，初始化向量不能重复。</li>
</ol>
<h2 id="思考题">思考题</h2>
<p>今天的思考题，也是一个动手题。</p>
<p>在你正在开发的项目中，或者你关注的开放源代码项目中，试着搜索一下初始化向量的使用。看一看对于同一个对称密钥，初始化向量会不会重复，有没有可能重复。如果一个对称密钥使用了重复的初始化向量，有没有潜在的安全风险？你有没有什么建议？</p>
<p>欢迎在留言区留言，记录、讨论你的发现和建议。</p>
<p>好的，今天就这样，我们下次再聊。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%AE%9E%E7%94%A8%E5%AF%86%E7%A0%81%E5%AD%A6/">实用密码学</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/rpc%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/08__%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%88%B0%E5%BA%95%E6%98%AF%E8%A6%81cp%E8%BF%98%E6%98%AFap/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">08__服务发现：到底是要CP还是AP？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/08__%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%90%84%E7%A7%8D%E5%B7%A5%E5%85%B7/">
            <span class="next-text nav-default">08__工欲善其事必先利其器：学会使用各种工具</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
