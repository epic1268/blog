<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>08__Once：一个简约而不简单的并发原语 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是鸟窝。
这一讲我来讲一个简单的并发原语：Once。为什么要学习 Once 呢？我先给你答案：Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/08__once%E4%B8%80%E4%B8%AA%E7%AE%80%E7%BA%A6%E8%80%8C%E4%B8%8D%E7%AE%80%E5%8D%95%E7%9A%84%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/08__once%E4%B8%80%E4%B8%AA%E7%AE%80%E7%BA%A6%E8%80%8C%E4%B8%8D%E7%AE%80%E5%8D%95%E7%9A%84%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="08__Once：一个简约而不简单的并发原语">
  <meta property="og:description" content="你好，我是鸟窝。
这一讲我来讲一个简单的并发原语：Once。为什么要学习 Once 呢？我先给你答案：Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Go并发编程实战课">

  <meta itemprop="name" content="08__Once：一个简约而不简单的并发原语">
  <meta itemprop="description" content="你好，我是鸟窝。
这一讲我来讲一个简单的并发原语：Once。为什么要学习 Once 呢？我先给你答案：Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5307">
  <meta itemprop="keywords" content="Go并发编程实战课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="08__Once：一个简约而不简单的并发原语">
  <meta name="twitter:description" content="你好，我是鸟窝。
这一讲我来讲一个简单的并发原语：Once。为什么要学习 Once 呢？我先给你答案：Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">08__Once：一个简约而不简单的并发原语</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5307 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#once-的使用场景">Once 的使用场景</a></li>
    <li><a href="#如何实现一个-once">如何实现一个 Once？</a></li>
    <li><a href="#使用-once-可能出现的-2-种错误">使用 Once 可能出现的 2 种错误</a>
      <ul>
        <li><a href="#第一种错误死锁">第一种错误：死锁</a></li>
        <li><a href="#第二种错误未初始化">第二种错误：未初始化</a></li>
      </ul>
    </li>
    <li><a href="#once-的踩坑案例">Once 的踩坑案例</a></li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#思考题">思考题</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是鸟窝。</p>
<p>这一讲我来讲一个简单的并发原语：Once。为什么要学习 Once 呢？我先给你答案：<strong>Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。</strong></p>
<p>那这节课，我们就从对单例对象进行初始化这件事儿说起。</p>
<p>初始化单例资源有很多方法，比如定义 package 级别的变量，这样程序在启动的时候就可以初始化：</p>
<p>package abc</p>
<p>import time</p>
<p>var startTime = time.Now()</p>
<p>或者在 init 函数中进行初始化：</p>
<p>package abc</p>
<p>var startTime time.Time</p>
<p>func init() {<br>
startTime = time.Now()<br>
}</p>
<p>又或者在 main 函数开始执行的时候，执行一个初始化的函数：</p>
<p>package abc</p>
<p>var startTime time.Tim</p>
<p>func initApp() {<br>
startTime = time.Now()<br>
}<br>
func main() {<br>
initApp()<br>
}</p>
<p>这三种方法都是线程安全的，并且后两种方法还可以根据传入的参数实现定制化的初始化操作。</p>
<p>但是很多时候我们是要延迟进行初始化的，所以有时候单例资源的初始化，我们会使用下面的方法：</p>
<p>package main</p>
<p>import (<br>
&ldquo;net&rdquo;<br>
&ldquo;sync&rdquo;<br>
&ldquo;time&rdquo;<br>
)</p>
<p>// 使用互斥锁保证线程 (goroutine) 安全<br>
var connMu sync.Mutex<br>
var conn net.Conn</p>
<p>func getConn() net.Conn {<br>
connMu.Lock()<br>
defer connMu.Unlock()</p>
<pre><code>// 返回已创建好的连接  
if conn != nil {  
    return conn  
}  

// 创建连接  
conn, _ = net.DialTimeout(&quot;tcp&quot;, &quot;baidu.com:80&quot;, 10*time.Second)  
return conn  
</code></pre>
<p>}</p>
<p>// 使用连接<br>
func main() {<br>
conn := getConn()<br>
if conn == nil {<br>
panic(&ldquo;conn is nil&rdquo;)<br>
}<br>
}</p>
<p>这种方式虽然实现起来简单，但是有性能问题。一旦连接创建好，每次请求的时候还是得竞争锁才能读取到这个连接，这是比较浪费资源的，因为连接如果创建好之后，其实就不需要锁的保护了。怎么办呢？</p>
<p>这个时候就可以使用这一讲要介绍的 Once 并发原语了。接下来我会详细介绍 Once 的使用、实现和易错场景。</p>
<h1 id="once-的使用场景">Once 的使用场景</h1>
<p><strong>sync.Once 只暴露了一个方法 Do，你可以多次调用 Do 方法，但是只有第一次调用 Do 方法时 f 参数才会执行，这里的 f 是一个无参数无返回值的函数。</strong></p>
<p>func (o *Once) Do(f func())</p>
<p>因为当且仅当第一次调用 Do 方法的时候参数 f 才会执行，即使第二次、第三次、第 n 次调用时 f 参数的值不一样，也不会被执行，比如下面的例子，虽然 f1 和 f2 是不同的函数，但是第二个函数 f2 就不会执行。</p>
<p>package main</p>
<p>import (<br>
&ldquo;fmt&rdquo;<br>
&ldquo;sync&rdquo;<br>
)</p>
<p>func main() {<br>
var once sync.Once</p>
<pre><code>// 第一个初始化函数  
f1 := func() {  
    fmt.Println(&quot;in f1&quot;)  
}  
once.Do(f1) // 打印出 in f1  

// 第二个初始化函数  
f2 := func() {  
    fmt.Println(&quot;in f2&quot;)  
}  
once.Do(f2) // 无输出  
</code></pre>
<p>}</p>
<p>因为这里的 f 参数是一个无参数无返回的函数，所以你可能会通过闭包的方式引用外面的参数，比如：</p>
<pre><code>var addr = &quot;baidu.com&quot;  

var conn net.Conn  
var err error  

once.Do(func() {  
    conn, err = net.Dial(&quot;tcp&quot;, addr)  
})
</code></pre>
<p>而且在实际的使用中，绝大多数情况下，你会使用闭包的方式去初始化外部的一个资源。</p>
<p>你看，Once 的使用场景很明确，所以，在标准库内部实现中也常常能看到 Once 的身影。</p>
<p>比如标准库内部cache的实现上，就使用了 Once 初始化 Cache 资源，包括 defaultDir 值的获取：</p>
<pre><code>func Default() *Cache { // 获取默认的 Cache  
defaultOnce.Do(initDefaultCache) // 初始化 cache  
return defaultCache  
</code></pre>
<p>}</p>
<pre><code>// 定义一个全局的 cache 变量，使用 Once 初始化，所以也定义了一个 Once 变量  
</code></pre>
<p>var (<br>
defaultOnce  sync.Once<br>
defaultCache *Cache<br>
)</p>
<pre><code>func initDefaultCache() { //初始化 cache，也就是 Once.Do 使用的 f 函数  
......  
defaultCache = c  
</code></pre>
<p>}</p>
<pre><code>// 其它一些 Once 初始化的变量，比如 defaultDir  
var (  
defaultDirOnce sync.Once  
defaultDir     string  
defaultDirErr  error  
</code></pre>
<p>)</p>
<p>还有一些测试的时候初始化测试的资源（export_windows_test）：</p>
<pre><code>// 测试 window 系统调用时区相关函数  
func ForceAusFromTZIForTesting() {  
ResetLocalOnceForTest()  
    // 使用 Once 执行一次初始化  
localOnce.Do(func() { initLocalFromTZI(&amp;aus) })  
</code></pre>
<p>}</p>
<p>除此之外，还有保证只调用一次 copyenv 的 envOnce，strings 包下的 Replacer，time 包中的测试，Go 拉取库时的proxy，net.pipe，crc64，Regexp，…，数不胜数。我给你重点介绍一下很值得我们学习的 math/big/sqrt.go 中实现的一个数据结构，它通过 Once 封装了一个只初始化一次的值：</p>
<p>// 值是 3.0 或者 0.0 的一个数据结构<br>
var threeOnce struct {<br>
sync.Once<br>
v *Float<br>
}</p>
<pre><code>// 返回此数据结构的值，如果还没有初始化为 3.0，则初始化  
</code></pre>
<p>func three() *Float {<br>
threeOnce.Do(func() { // 使用 Once 初始化<br>
threeOnce.v = NewFloat(3.0)<br>
})<br>
return threeOnce.v<br>
}</p>
<p>它将 sync.Once 和 *Float 封装成一个对象，提供了只初始化一次的值 v。你看它的 three 方法的实现，虽然每次都调用 threeOnce.Do 方法，但是参数只会被调用一次。</p>
<p>当你使用 Once 的时候，你也可以尝试采用这种结构，将值和 Once 封装成一个新的数据结构，提供只初始化一次的值。</p>
<p>总结一下 Once 并发原语解决的问题和使用场景：<strong>Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测试资源</strong>。</p>
<p>了解了 Once 的使用场景，那应该怎样实现一个 Once 呢？</p>
<h1 id="如何实现一个-once">如何实现一个 Once？</h1>
<p>很多人认为实现一个 Once 一样的并发原语很简单，只需使用一个 flag 标记是否初始化过即可，最多是用 atomic 原子操作这个 flag，比如下面的实现：</p>
<p>type Once struct {<br>
done uint32<br>
}</p>
<p>func (o *Once) Do(f func()) {<br>
if !atomic.CompareAndSwapUint32(&amp;o.done, 0, 1) {<br>
return<br>
}<br>
f()<br>
}</p>
<p>这确实是一种实现方式，但是，这个实现有一个很大的问题，就是如果参数 f 执行很慢的话，后续调用 Do 方法的 goroutine 虽然看到 done 已经设置为执行过了，但是获取某些初始化资源的时候可能会得到空的资源，因为 f 还没有执行完。</p>
<p>所以，<strong>一个正确的 Once 实现要使用一个互斥锁，</strong> <strong>这样初始化的时候如果有并发的 goroutine，就会进入</strong> <strong>doSlow 方法</strong>。互斥锁的机制保证只有一个 goroutine 进行初始化，同时利用<strong>双检查的机制</strong>（double-checking），再次判断 o.done 是否为 0，如果为 0，则是第一次执行，执行完毕后，就将 o.done 设置为 1，然后释放锁。</p>
<p>即使此时有多个 goroutine 同时进入了 doSlow 方法，因为双检查的机制，后续的 goroutine 会看到 o.done 的值为 1，也不会再次执行 f。</p>
<p>这样既保证了并发的 goroutine 会等待 f 完成，而且还不会多次执行 f。</p>
<p>type Once struct {<br>
done uint32<br>
m    Mutex<br>
}</p>
<p>func (o *Once) Do(f func()) {<br>
if atomic.LoadUint32(&amp;o.done) == 0 {<br>
o.doSlow(f)<br>
}<br>
}</p>
<p>func (o *Once) doSlow(f func()) {<br>
o.m.Lock()<br>
defer o.m.Unlock()<br>
// 双检查<br>
if o.done == 0 {<br>
defer atomic.StoreUint32(&amp;o.done, 1)<br>
f()<br>
}<br>
}</p>
<p>好了，到这里我们就了解了 Once 的使用场景，很明确，同时呢，也感受到 Once 的实现也是相对简单的。在实践中，其实很少会出现错误使用 Once 的情况，但是就像墨菲定律说的，凡是可能出错的事就一定会出错。使用 Once 也有可能出现两种错误场景，尽管非常罕见。我这里提前讲给你，咱打个预防针。</p>
<h1 id="使用-once-可能出现的-2-种错误">使用 Once 可能出现的 2 种错误</h1>
<h2 id="第一种错误死锁">第一种错误：死锁</h2>
<p>你已经知道了 Do 方法会执行一次 f，但是如果 f 中再次调用这个 Once 的 Do 方法的话，就会导致死锁的情况出现。这还不是无限递归的情况，而是的的确确的 Lock 的递归调用导致的死锁。</p>
<p>func main() {<br>
var once sync.Once<br>
once.Do(func() {<br>
once.Do(func() {<br>
fmt.Println(&ldquo;初始化&rdquo;)<br>
})<br>
})<br>
}</p>
<p>当然，想要避免这种情况的出现，就不要在 f 参数中调用当前的这个 Once，不管是直接的还是间接的。</p>
<h2 id="第二种错误未初始化">第二种错误：未初始化</h2>
<p>如果 f 方法执行的时候 panic，或者 f 执行初始化资源的时候失败了，这个时候，Once 还是会认为初次执行已经成功了，即使再次调用 Do 方法，也不会再次执行 f。</p>
<p>比如下面的例子，由于一些防火墙的原因，googleConn 并没有被正确的初始化，后面如果想当然认为既然执行了 Do 方法 googleConn 就已经初始化的话，会抛出空指针的错误：</p>
<p>func main() {<br>
var once sync.Once<br>
var googleConn net.Conn // 到 Google 网站的一个连接</p>
<pre><code>once.Do(func() {  
    // 建立到 google.com 的连接，有可能因为网络的原因，googleConn 并没有建立成功，此时它的值为 nil  
    googleConn, _ = net.Dial(&quot;tcp&quot;, &quot;google.com:80&quot;)  
})  
// 发送 http 请求  
googleConn.Write([]byte(&quot;GET / HTTP/1.1\r\nHost: google.com\r\n Accept: */*\r\n\r\n&quot;))  
io.Copy(os.Stdout, googleConn)  
</code></pre>
<p>}</p>
<p>既然执行过 Once.Do 方法也可能因为函数执行失败的原因未初始化资源，并且以后也没机会再次初始化资源，那么这种初始化未完成的问题该怎么解决呢？</p>
<p>这里我来告诉你一招独家秘笈，我们可以<strong>自己实现一个类似 Once 的并发原语</strong>，既可以返回当前调用 Do 方法是否正确完成，还可以在初始化失败后调用 Do 方法再次尝试初始化，直到初始化成功才不再初始化了。</p>
<p>// 一个功能更加强大的 Once<br>
type Once struct {<br>
m    sync.Mutex<br>
done uint32<br>
}<br>
// 传入的函数 f 有返回值 error，如果初始化失败，需要返回失败的 error<br>
// Do 方法会把这个 error 返回给调用者<br>
func (o *Once) Do(f func() error) error {<br>
if atomic.LoadUint32(&amp;o.done) == 1 { //fast path<br>
return nil<br>
}<br>
return o.slowDo(f)<br>
}<br>
// 如果还没有初始化<br>
func (o *Once) slowDo(f func() error) error {<br>
o.m.Lock()<br>
defer o.m.Unlock()<br>
var err error<br>
if o.done == 0 { // 双检查，还没有初始化<br>
err = f()<br>
if err == nil { // 初始化成功才将标记置为已初始化<br>
atomic.StoreUint32(&amp;o.done, 1)<br>
}<br>
}<br>
return err<br>
}</p>
<p>我们所做的改变就是 Do 方法和参数 f 函数都会返回 error，如果 f 执行失败，会把这个错误信息返回。</p>
<p>对 slowDo 方法也做了调整，如果 f 调用失败，我们不会更改 done 字段的值，这样后续 degoroutine 还会继续调用 f。如果 f 执行成功，才会修改 done 的值为 1。</p>
<p>可以说，真是一顿操作猛如虎，我们使用 Once 有点得心应手的感觉了。等等，还有个问题，我们怎么查询是否初始化过呢？</p>
<p>目前的 Once 实现可以保证你调用任意次数的 once.Do 方法，它只会执行这个方法一次。但是，有时候我们需要打一个标记。如果初始化后我们就去执行其它的操作，标准库的 Once 并不会告诉你是否初始化完成了，只是让你放心大胆地去执行 Do 方法，所以，<strong>你还需要一个辅助变量，自己去检查是否初始化过了</strong>，比如通过下面的代码中的 inited 字段：</p>
<p>type AnimalStore struct {once   sync.Once;inited uint32}<br>
func (a *AnimalStore) Init() // 可以被并发调用<br>
a.once.Do(func() {<br>
longOperationSetupDbOpenFilesQueuesEtc()<br>
atomic.StoreUint32(&amp;a.inited, 1)<br>
})<br>
}<br>
func (a *AnimalStore) CountOfCats() (int, error) { // 另外一个 goroutine<br>
if atomic.LoadUint32(&amp;a.inited) == 0 { // 初始化后才会执行真正的业务逻辑<br>
return 0, NotYetInitedError<br>
}<br>
//Real operation<br>
}</p>
<p>当然，通过这段代码，我们可以解决这类问题，但是，如果官方的 Once 类型有 Done 这样一个方法的话，我们就可以直接使用了。这是有人在 Go 代码库中提出的一个 issue(#41690)。对于这类问题，一般都会被建议采用其它类型，或者自己去扩展。我们可以尝试扩展这个并发原语：</p>
<p>// Once 是一个扩展的 sync.Once 类型，提供了一个 Done 方法<br>
type Once struct {<br>
sync.Once<br>
}</p>
<p>// Done 返回此 Once 是否执行过<br>
// 如果执行过则返回 true<br>
// 如果没有执行过或者正在执行，返回 false<br>
func (o *Once) Done() bool {<br>
return atomic.LoadUint32((*uint32)(unsafe.Pointer(&amp;o.Once))) == 1<br>
}</p>
<p>func main() {<br>
var flag Once<br>
fmt.Println(flag.Done()) //false</p>
<pre><code>flag.Do(func() {  
    time.Sleep(time.Second)  
})  

fmt.Println(flag.Done()) //true  
</code></pre>
<p>}</p>
<p>好了，到这里关于并发原语 Once 的内容我讲得就差不多了。最后呢，和你分享一个 Once 的踩坑案例。</p>
<p>其实啊，使用 Once 真的不容易犯错，想犯错都很困难，因为很少有人会傻傻地在初始化函数 f 中递归调用 f，这种死锁的现象几乎不会发生。另外如果函数初始化不成功，我们一般会 panic，或者在使用的时候做检查，会及早发现这个问题，在初始化函数中加强代码。</p>
<p>所以查看大部分的 Go 项目，几乎找不到 Once 的错误使用场景，不过我还是发现了一个。这个 issue 先从另外一个需求 (go#25955) 谈起。</p>
<h1 id="once-的踩坑案例">Once 的踩坑案例</h1>
<p>go#25955 有网友提出一个需求，希望 Once 提供一个 Reset 方法，能够将 Once 重置为初始化的状态。比如下面的例子，St 通过两个 Once 控制它的 Open/Close 状态。但是在 Close 之后再调用 Open 的话，不会再执行 init 函数，因为 Once 只会执行一次初始化函数。</p>
<p>type St struct {<br>
openOnce *sync.Once<br>
closeOnce *sync.Once<br>
}</p>
<p>func(st *St) Open(){<br>
st.openOnce.Do(func() { &hellip; }) // init<br>
&hellip;<br>
}</p>
<p>func(st *St) Close(){<br>
st.closeOnce.Do(func() { &hellip; }) // deinit<br>
&hellip;<br>
}</p>
<p>所以提交这个 Issue 的开发者希望 Once 增加一个 Reset 方法，Reset 之后再调用 once.Do 就又可以初始化了。</p>
<p>Go 的核心开发者 Ian Lance Taylor 给他了一个简单的解决方案。在这个例子中，只使用一个 ponce *sync.Once 做初始化，Reset 的时候给 ponce 这个变量赋值一个新的 Once 实例即可 (ponce = new(sync.Once))。Once 的本意就是执行一次，所以 Reset 破坏了这个并发原语的本意。</p>
<p>这个解决方案一点都没问题，可以很好地解决这位开发者的需求。Docker 较早的版本（1.11.2）中使用了它们的一个网络库 libnetwork，这个网络库在使用 Once 的时候就使用 Ian Lance Taylor 介绍的方法，但是不幸的是，它的 Reset 方法中又改变了 Once 指针的值，导致程序 panic 了。原始逻辑比较复杂，一个简化版可重现的代码如下：</p>
<p>package main</p>
<p>import (<br>
&ldquo;fmt&rdquo;<br>
&ldquo;sync&rdquo;<br>
&ldquo;time&rdquo;<br>
)</p>
<p>// 一个组合的并发原语<br>
type MuOnce struct {<br>
sync.RWMutex<br>
sync.Once<br>
mtime time.Time<br>
vals  []string<br>
}</p>
<p>// 相当于 reset 方法，会将 m.Once 重新复制一个 Once<br>
func (m *MuOnce) refresh() {<br>
m.Lock()<br>
defer m.Unlock()<br>
m.Once = sync.Once{}<br>
m.mtime = time.Now()<br>
m.vals = []string{m.mtime.String()}<br>
}</p>
<p>// 获取某个初始化的值，如果超过某个时间，会 reset Once<br>
func (m *MuOnce) strings() []string {<br>
now := time.Now()<br>
m.RLock()<br>
if now.After(m.mtime) {<br>
defer m.Do(m.refresh) // 使用 refresh 函数重新初始化<br>
}<br>
vals := m.vals<br>
m.RUnlock()<br>
return vals<br>
}</p>
<p>func main() {<br>
fmt.Println(&ldquo;Hello, playground&rdquo;)<br>
m := new(MuOnce)<br>
fmt.Println(m.strings())<br>
fmt.Println(m.strings())<br>
}</p>
<p>如果你执行这段代码就会 panic:</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/299410d2e97b8e267b67f676e7ca1b37.png" alt=""></p>
<p>原因在于第 31 行执行 m.Once.Do 方法的时候，使用的是 m.Once 的指针，然后调用 m.refresh，在执行 m.refresh 的时候 Once 内部的 Mutex 首先会加锁（可以再翻看一下这一讲的 Once 的实现原理），但是，在 refresh 中更改了 Once 指针的值之后，结果在执行完 refresh 释放锁的时候，释放的是一个刚初始化未加锁的 Mutex，所以就 panic 了。</p>
<p>如果你还不太明白，我再给你简化成一个更简单的例子：</p>
<p>package main</p>
<p>import (<br>
&ldquo;sync&rdquo;<br>
)</p>
<p>type Once struct {<br>
m sync.Mutex<br>
}</p>
<p>func (o *Once) doSlow() {<br>
o.m.Lock()<br>
defer o.m.Unlock()</p>
<pre><code>// 这里更新的 o 指针的值!!!!!!!, 会导致上一行 Unlock 出错  
*o = Once{}  
</code></pre>
<p>}</p>
<p>func main() {<br>
var once Once<br>
once.doSlow()<br>
}</p>
<p>doSlow 方法就演示了这个错误。Ian Lance Taylor 介绍的 Reset 方法没有错误，但是你在使用的时候千万别再初始化函数中 Reset 这个 Once，否则势必会导致 Unlock 一个未加锁的 Mutex 的错误。</p>
<p>总的来说，这还是对 Once 的实现机制不熟悉，又进行复杂使用导致的错误。不过最新版的 libnetwork 相关的地方已经去掉了 Once 的使用了。所以，我带你一起来看这个案例，主要目的还是想巩固一下我们对 Once 的理解。</p>
<h1 id="总结">总结</h1>
<p>今天我们一起学习了 Once，我们常常使用它来实现单例模式。</p>
<p>单例是 23 种设计模式之一，也是常常引起争议的设计模式之一，甚至有人把它归为反模式。为什么说它是反模式呢，我拿标准库中的单例模式给你介绍下。</p>
<p>因为 Go 没有 immutable 类型，导致我们声明的全局变量都是可变的，别的地方或者第三方库可以随意更改这些变量。比如 package io 中定义了几个全局变量，比如 io.EOF：</p>
<p>var EOF = errors.New(&ldquo;EOF&rdquo;)</p>
<p>因为它是一个 package 级别的变量，我们可以在程序中偷偷把它改了，这会导致一些依赖 io.EOF 这个变量做判断的代码出错。</p>
<p>io.EOF = errors.New(&ldquo;我们自己定义的 EOF&rdquo;)</p>
<p>从我个人的角度来说，一些单例（全局变量）的确很方便，比如 Buffer 池或者连接池，所以有时候我们也不要谈虎色变。虽然有人把单例模式称之为反模式，但毕竟只能代表一部分开发者的观点，否则也不会把它列在 23 种设计模式中了。</p>
<p>如果你真的担心这个 package 级别的变量被人修改，你可以不把它们暴露出来，而是提供一个只读的 GetXXX 的方法，这样别人就不会进行修改了。</p>
<p>而且，Once 不只应用于单例模式，一些变量在也需要在使用的时候做延迟初始化，所以也是可以使用 Once 处理这些场景的。</p>
<p>总而言之，Once 的应用场景还是很广泛的。<strong>一旦你遇到只需要初始化一次的场景，首先想到的就应该是 Once 并发原语。</strong></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/6cf9e542e71680a64358690a0f17a09a.png" alt=""></p>
<h1 id="思考题">思考题</h1>
<ol>
<li>我已经分析了几个并发原语的实现，你可能注意到总是有些 slowXXXX 的方法，从 XXXX 方法中单独抽取出来，你明白为什么要这么做吗，有什么好处？</li>
<li>Once 在第一次使用之后，还能复制给其它变量使用吗？</li>
</ol>
<p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/">Go并发编程实战课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/08__mvc%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%9E%8Bmodel%E7%AF%87/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">08__MVC架构解析：模型（Model）篇</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/08__raft%E7%AE%97%E6%B3%95%E4%BA%8C%E5%A6%82%E4%BD%95%E5%A4%8D%E5%88%B6%E6%97%A5%E5%BF%97/">
            <span class="next-text nav-default">08__Raft算法（二）：如何复制日志？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
