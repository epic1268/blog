<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>18__分组操作：处理一组子任务，该用什么并发原语？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是鸟窝。
共享资源保护、任务编排和消息传递是 Go 并发编程中常见的场景，而分组执行一批相同的或类似的任务则是任务编排中一类情形，所以，这节课，我专门来介绍一下分组编排的一些常用场景和并发原语，包括 ErrGroup、gollback、Hunch 和 schedgroup。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/18__%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C%E5%A4%84%E7%90%86%E4%B8%80%E7%BB%84%E5%AD%90%E4%BB%BB%E5%8A%A1%E8%AF%A5%E7%94%A8%E4%BB%80%E4%B9%88%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/18__%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C%E5%A4%84%E7%90%86%E4%B8%80%E7%BB%84%E5%AD%90%E4%BB%BB%E5%8A%A1%E8%AF%A5%E7%94%A8%E4%BB%80%E4%B9%88%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="18__分组操作：处理一组子任务，该用什么并发原语？">
  <meta property="og:description" content="你好，我是鸟窝。
共享资源保护、任务编排和消息传递是 Go 并发编程中常见的场景，而分组执行一批相同的或类似的任务则是任务编排中一类情形，所以，这节课，我专门来介绍一下分组编排的一些常用场景和并发原语，包括 ErrGroup、gollback、Hunch 和 schedgroup。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Go并发编程实战课">

  <meta itemprop="name" content="18__分组操作：处理一组子任务，该用什么并发原语？">
  <meta itemprop="description" content="你好，我是鸟窝。
共享资源保护、任务编排和消息传递是 Go 并发编程中常见的场景，而分组执行一批相同的或类似的任务则是任务编排中一类情形，所以，这节课，我专门来介绍一下分组编排的一些常用场景和并发原语，包括 ErrGroup、gollback、Hunch 和 schedgroup。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7788">
  <meta itemprop="keywords" content="Go并发编程实战课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="18__分组操作：处理一组子任务，该用什么并发原语？">
  <meta name="twitter:description" content="你好，我是鸟窝。
共享资源保护、任务编排和消息传递是 Go 并发编程中常见的场景，而分组执行一批相同的或类似的任务则是任务编排中一类情形，所以，这节课，我专门来介绍一下分组编排的一些常用场景和并发原语，包括 ErrGroup、gollback、Hunch 和 schedgroup。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">18__分组操作：处理一组子任务，该用什么并发原语？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7788 字 </span>
          <span class="more-meta"> 预计阅读 16 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#errgroup">ErrGroup</a>
      <ul>
        <li><a href="#基本用法">基本用法</a></li>
        <li><a href="#errgroup-使用例子">ErrGroup 使用例子</a>
          <ul>
            <li><a href="#简单例子返回第一个错误">简单例子：返回第一个错误</a></li>
            <li><a href="#更进一步返回所有子任务的错误">更进一步，返回所有子任务的错误</a></li>
            <li><a href="#任务执行流水线-pipeline">任务执行流水线 Pipeline</a></li>
          </ul>
        </li>
        <li><a href="#扩展库">扩展库</a>
          <ul>
            <li><a href="#bilibilierrgroup">bilibili/errgroup</a></li>
            <li><a href="#neilotooleerrgroup">neilotoole/errgroup</a></li>
            <li><a href="#facebookgoerrgroup">facebookgo/errgroup</a></li>
          </ul>
        </li>
        <li><a href="#其它实用的-group-并发原语">其它实用的 Group 并发原语</a>
          <ul>
            <li><a href="#sizedgrouperrsizedgroup">SizedGroup/ErrSizedGroup</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#gollback">gollback</a></li>
    <li><a href="#hunch">Hunch</a></li>
    <li><a href="#schedgroup">schedgroup</a></li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#思考题">思考题</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是鸟窝。</p>
<p>共享资源保护、任务编排和消息传递是 Go 并发编程中常见的场景，而<strong>分组执行一批相同的或类似的任务则是任务编排中一类情形</strong>，所以，这节课，我专门来介绍一下分组编排的一些常用场景和并发原语，包括 ErrGroup、gollback、Hunch 和 schedgroup。</p>
<p>我们先来学习一类非常常用的并发原语，那就是 ErrGroup。</p>
<h1 id="errgroup">ErrGroup</h1>
<p>ErrGroup是 Go 官方提供的一个同步扩展库。我们经常会碰到需要将一个通用的父任务拆成几个小任务并发执行的场景，其实，将一个大的任务拆成几个小任务并发执行，可以有效地提高程序的并发度。就像你在厨房做饭一样，你可以在蒸米饭的同时炒几个小菜，米饭蒸好了，菜同时也做好了，很快就能吃到可口的饭菜。</p>
<p>ErrGroup 就是用来应对这种场景的。它和 WaitGroup 有些类似，但是它提供功能更加丰富：</p>
<ol>
<li>和 Context 集成；</li>
<li>error 向上传播，可以把子任务的错误传递给 Wait 的调用者。</li>
</ol>
<p>接下来，我来给你介绍一下 ErrGroup 的基本用法和几种应用场景。</p>
<h2 id="基本用法">基本用法</h2>
<p>golang.org/x/sync/errgroup 包下定义了一个 Group struct，它就是我们要介绍的 ErrGroup 并发原语，底层也是基于 WaitGroup 实现的。</p>
<p>在使用 ErrGroup 时，我们要用到三个方法，分别是 WithContext、Go 和 Wait。</p>
<p><strong>1.WithContext</strong></p>
<p>在创建一个 Group 对象时，需要使用 WithContext 方法：</p>
<p>func WithContext(ctx context.Context) (*Group, context.Context)</p>
<p>这个方法返回一个 Group 实例，同时还会返回一个使用 context.WithCancel(ctx) 生成的新 Context。一旦有一个子任务返回错误，或者是 Wait 调用返回，这个新 Context 就会被 cancel。</p>
<p>Group 的零值也是合法的，只不过，你就没有一个可以监控是否 cancel 的 Context 了。</p>
<p>注意，如果传递给 WithContext 的 ctx 参数，是一个可以 cancel 的 Context 的话，那么，它被 cancel 的时候，并不会终止正在执行的子任务。</p>
<p><strong>2.Go</strong></p>
<p>我们再来学习下执行子任务的 Go 方法：</p>
<p>func (g *Group) Go(f func() error)</p>
<p>传入的子任务函数 f 是类型为 func() error 的函数，如果任务执行成功，就返回 nil，否则就返回 error，并且会 cancel 那个新的 Context。</p>
<p>一个任务可以分成好多个子任务，而且，可能有多个子任务执行失败返回 error，不过，Wait 方法只会返回第一个错误，所以，如果想返回所有的错误，需要特别的处理，我先留个小悬念，一会儿再讲。</p>
<p><strong>3.Wait</strong></p>
<p>类似 WaitGroup，Group 也有 Wait 方法，等所有的子任务都完成后，它才会返回，否则只会阻塞等待。如果有多个子任务返回错误，它只会返回第一个出现的错误，如果所有的子任务都执行成功，就返回 nil：</p>
<p>func (g *Group) Wait() error</p>
<h2 id="errgroup-使用例子">ErrGroup 使用例子</h2>
<p>好了，知道了基本用法，下面我来给你介绍几个例子，帮助你全面地掌握 ErrGroup 的使用方法和应用场景。</p>
<h3 id="简单例子返回第一个错误">简单例子：返回第一个错误</h3>
<p>先来看一个简单的例子。在这个例子中，启动了三个子任务，其中，子任务 2 会返回执行失败，其它两个执行成功。在三个子任务都执行后，group.Wait 才会返回第 2 个子任务的错误。</p>
<p>package main</p>
<p>import (<br>
&ldquo;errors&rdquo;<br>
&ldquo;fmt&rdquo;<br>
&ldquo;time&rdquo;</p>
<pre><code>&quot;golang.org/x/sync/errgroup&quot;  
</code></pre>
<p>)</p>
<p>func main() {<br>
var g errgroup.Group</p>
<pre><code>// 启动第一个子任务，它执行成功  
g.Go(func() error {  
    time.Sleep(5 * time.Second)  
    fmt.Println(&quot;exec #1&quot;)  
    return nil  
})  
// 启动第二个子任务，它执行失败  
g.Go(func() error {  
    time.Sleep(10 * time.Second)  
    fmt.Println(&quot;exec #2&quot;)  
    return errors.New(&quot;failed to exec #2&quot;)  
})  

// 启动第三个子任务，它执行成功  
g.Go(func() error {  
    time.Sleep(15 * time.Second)  
    fmt.Println(&quot;exec #3&quot;)  
    return nil  
})  
// 等待三个任务都完成  
if err := g.Wait(); err == nil {  
    fmt.Println(&quot;Successfully exec all&quot;)  
} else {  
    fmt.Println(&quot;failed:&quot;, err)  
}  
</code></pre>
<p>}</p>
<p>如果执行下面的这个程序，会显示三个任务都执行了，而 Wait 返回了子任务 2 的错误：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/76afd46e2dabf73334489ad8930ac14a.png" alt=""></p>
<h3 id="更进一步返回所有子任务的错误">更进一步，返回所有子任务的错误</h3>
<p>Group 只能返回子任务的第一个错误，后续的错误都会被丢弃。但是，有时候我们需要知道每个任务的执行情况。怎么办呢？这个时候，我们就可以用稍微有点曲折的方式去实现。我们使用一个 result slice 保存子任务的执行结果，这样，通过查询 result，就可以知道每一个子任务的结果了。</p>
<p>下面的这个例子，就是使用 result 记录每个子任务成功或失败的结果。其实，你不仅可以使用 result 记录 error 信息，还可以用它记录计算结果。</p>
<p>package main</p>
<p>import (<br>
&ldquo;errors&rdquo;<br>
&ldquo;fmt&rdquo;<br>
&ldquo;time&rdquo;</p>
<pre><code>&quot;golang.org/x/sync/errgroup&quot;  
</code></pre>
<p>)</p>
<p>func main() {<br>
var g errgroup.Group<br>
var result = make([]error, 3)</p>
<pre><code>// 启动第一个子任务，它执行成功  
g.Go(func() error {  
    time.Sleep(5 * time.Second)  
    fmt.Println(&quot;exec #1&quot;)  
    result[0] = nil // 保存成功或者失败的结果  
    return nil  
})  


// 启动第二个子任务，它执行失败  
g.Go(func() error {  
    time.Sleep(10 * time.Second)  
    fmt.Println(&quot;exec #2&quot;)  

    result[1] = errors.New(&quot;failed to exec #2&quot;) // 保存成功或者失败的结果  
    return result[1]  
})  

// 启动第三个子任务，它执行成功  
g.Go(func() error {  
    time.Sleep(15 * time.Second)  
    fmt.Println(&quot;exec #3&quot;)  
    result[2] = nil // 保存成功或者失败的结果  
    return nil  
})  

if err := g.Wait(); err == nil {  
    fmt.Printf(&quot;Successfully exec all. result: %v\n&quot;, result)  
} else {  
    fmt.Printf(&quot;failed: %v\n&quot;, result)  
}  
</code></pre>
<p>}</p>
<h3 id="任务执行流水线-pipeline">任务执行流水线 Pipeline</h3>
<p>Go 官方文档中还提供了一个 pipeline 的例子。这个例子是说，由一个子任务遍历文件夹下的文件，然后把遍历出的文件交给 20 个 goroutine，让这些 goroutine 并行计算文件的 md5。</p>
<p>这个例子中的计算逻辑你不需要重点掌握，我来把这个例子简化一下（如果你想看原始的代码，可以看这里）：</p>
<p>package main</p>
<p>import (<br>
&hellip;&hellip;<br>
&ldquo;golang.org/x/sync/errgroup&rdquo;<br>
)</p>
<p>// 一个多阶段的 pipeline.使用有限的 goroutine 计算每个文件的 md5 值.<br>
func main() {<br>
m, err := MD5All(context.Background(), &ldquo;.&rdquo;)<br>
if err != nil {<br>
log.Fatal(err)<br>
}</p>
<pre><code>for k, sum := range m {  
    fmt.Printf(&quot;%s:\t%x\n&quot;, k, sum)  
}  
</code></pre>
<p>}</p>
<p>type result struct {<br>
path string<br>
sum  [md5.Size]byte<br>
}</p>
<p>// 遍历根目录下所有的文件和子文件夹，计算它们的 md5 的值.<br>
func MD5All(ctx context.Context, root string) (map[string][md5.Size]byte, error) {<br>
g, ctx := errgroup.WithContext(ctx)<br>
paths := make(chan string) // 文件路径 channel</p>
<pre><code>g.Go(func() error {  
    defer close(paths) // 遍历完关闭 paths chan  
    return filepath.Walk(root, func(path string, info os.FileInfo, err error) error {  
        ...... //将文件路径放入到 paths  
        return nil  
    })  
})  

// 启动 20 个 goroutine 执行计算 md5 的任务，计算的文件由上一阶段的文件遍历子任务生成.  
c := make(chan result)  
const numDigesters = 20  
for i := 0; i &lt; numDigesters; i++ {  
    g.Go(func() error {  
        for path := range paths { // 遍历直到 paths chan 被关闭  
            ...... // 计算 path 的 md5 值，放入到 c 中  
        }  
        return nil  
    })  
}  
go func() {  
    g.Wait() // 20 个 goroutine 以及遍历文件的 goroutine 都执行完  
    close(c) // 关闭收集结果的 chan  
}()  


m := make(map[string][md5.Size]byte)  
for r := range c { // 将 md5 结果从 chan 中读取到 map 中，直到 c 被关闭才退出  
    m[r.path] = r.sum  
}  

// 再次调用 Wait，依然可以得到 group 的 error 信息  
if err := g.Wait(); err != nil {  
    return nil, err  
}  
return m, nil  
</code></pre>
<p>}</p>
<p>通过这个例子，你可以学习到多阶段 pipeline 的实现（这个例子是遍历文件夹和计算 md5 两个阶段），还可以学习到如何控制执行子任务的 goroutine 数量。</p>
<p>很多公司都在使用 ErrGroup 处理并发子任务，比如 Facebook、bilibili 等公司的一些项目，但是，这些公司在使用的时候，发现了一些不方便的地方，或者说，官方的 ErrGroup 的功能还不够丰富。所以，他们都对 ErrGroup 进行了扩展。接下来呢，我就带你看看几个扩展库。</p>
<h2 id="扩展库">扩展库</h2>
<h3 id="bilibilierrgroup">bilibili/errgroup</h3>
<p>如果我们无限制地直接调用 ErrGroup 的 Go 方法，就可能会创建出非常多的 goroutine，太多的 goroutine 会带来调度和 GC 的压力，而且也会占用更多的内存资源。就像go#34457指出的那样，当前 Go 运行时创建的 g 对象只会增长和重用，不会回收，所以在高并发的情况下，也要尽可能减少 goroutine 的使用。</p>
<p>常用的一个手段就是使用 worker pool(goroutine pool)，或者是类似containerd/stargz-snapshotter的方案，使用前面我们讲的信号量，信号量的资源的数量就是可以并行的 goroutine 的数量。但是在这一讲，我来介绍一些其它的手段，比如下面介绍的 bilibili 实现的 errgroup。</p>
<p>bilibili 实现了一个扩展的 ErrGroup，可以使用一个固定数量的 goroutine 处理子任务。如果不设置 goroutine 的数量，那么每个子任务都会比较“放肆地”创建一个 goroutine 并发执行。</p>
<p>这个链接里的文档已经很详细地介绍了它的几个扩展功能，所以我就不通过示例的方式来进行讲解了。</p>
<p>除了可以控制并发 goroutine 的数量，它还提供了 2 个功能：</p>
<ol>
<li>cancel，失败的子任务可以 cancel 所有正在执行任务；</li>
<li>recover，而且会把 panic 的堆栈信息放到 error 中，避免子任务 panic 导致的程序崩溃。</li>
</ol>
<p>但是，有一点不太好的地方就是，一旦你设置了并发数，超过并发数的子任务需要等到调用者调用 Wait 之后才会执行，而不是只要 goroutine 空闲下来，就去执行。如果不注意这一点的话，可能会出现子任务不能及时处理的情况，这是这个库可以优化的一点。</p>
<p>另外，这个库其实是有一个并发问题的。在高并发的情况下，如果任务数大于设定的 goroutine 的数量，并且这些任务被集中加入到 Group 中，这个库的处理方式是把子任务加入到一个数组中，但是，这个数组不是线程安全的，有并发问题，问题就在于，下面图片中的标记为 96 行的那一行，这一行对 slice 的 append 操作不是线程安全的：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/3fb3c2c985e10a55ebc114bc9cbe27a2.png" alt=""></p>
<p>我们可以写一个简单的程序来测试这个问题：</p>
<p>package main</p>
<p>import (<br>
&ldquo;context&rdquo;<br>
&ldquo;fmt&rdquo;<br>
&ldquo;sync/atomic&rdquo;<br>
&ldquo;time&rdquo;</p>
<pre><code>&quot;github.com/bilibili/kratos/pkg/sync/errgroup&quot;  
</code></pre>
<p>)</p>
<p>func main() {<br>
var g errgroup.Group<br>
g.GOMAXPROCS(1) // 只使用一个 goroutine 处理子任务</p>
<pre><code>var count int64  
g.Go(func(ctx context.Context) error {  
    time.Sleep(time.Second) //睡眠 5 秒，把这个 goroutine 占住  
    return nil  
})  

total := 10000  

for i := 0; i &lt; total; i++ { // 并发一万个 goroutine 执行子任务，理论上这些子任务都会加入到 Group 的待处理列表中  
    go func() {  
        g.Go(func(ctx context.Context) error {  
            atomic.AddInt64(&amp;count, 1)  
            return nil  
        })  
    }()  
}  

// 等待所有的子任务完成。理论上 10001 个子任务都会被完成  
if err := g.Wait(); err != nil {  
    panic(err)  
}  

got := atomic.LoadInt64(&amp;count)  
if got != int64(total) {  
    panic(fmt.Sprintf(&quot;expect %d but got %d&quot;, total, got))  
}  
</code></pre>
<p>}</p>
<p>运行这个程序的话，你就会发现死锁问题，因为我们的测试程序是一个简单的命令行工具，程序退出的时候，Go runtime 能检测到死锁问题。如果是一直运行的服务器程序，死锁问题有可能是检测不出来的，程序一直会 hang 在 Wait 的调用上。</p>
<h3 id="neilotooleerrgroup">neilotoole/errgroup</h3>
<p>neilotoole/errgroup 是今年年中新出现的一个 ErrGroup 扩展库，它可以直接替换官方的 ErrGroup，方法都一样，原有功能也一样，只不过<strong>增加了可以控制并发 goroutine 的功能</strong>。它的方法集如下：</p>
<p>type Group<br>
func WithContext(ctx context.Context) (*Group, context.Context)<br>
func WithContextN(ctx context.Context, numG, qSize int) (*Group, context.Context)<br>
func (g *Group) Go(f func() error)<br>
func (g *Group) Wait() error</p>
<p>新增加的方法 WithContextN，可以设置并发的 goroutine 数，以及等待处理的子任务队列的大小。当队列满的时候，如果调用 Go 方法，就会被阻塞，直到子任务可以放入到队列中才返回。如果你传给这两个参数的值不是正整数，它就会使用 runtime.NumCPU 代替你传入的参数。</p>
<p>当然，你也可以把 bilibili 的 recover 功能扩展到这个库中，以避免子任务的 panic 导致程序崩溃。</p>
<h3 id="facebookgoerrgroup">facebookgo/errgroup</h3>
<p>Facebook 提供的这个 ErrGroup，其实并不是对 Go 扩展库 ErrGroup 的扩展，而是对标准库 WaitGroup 的扩展。不过，因为它们的名字一样，处理的场景也类似，所以我把它也列在了这里。</p>
<p>标准库的 WaitGroup 只提供了 Add、Done、Wait 方法，而且 Wait 方法也没有返回子 goroutine 的 error。而 Facebook 提供的 ErrGroup 提供的 Wait 方法可以返回 error，而且可以包含多个 error。子任务在调用 Done 之前，可以把自己的 error 信息设置给 ErrGroup。接着，Wait 在返回的时候，就会把这些 error 信息返回给调用者。</p>
<p>我们来看下 Group 的方法：</p>
<p>type Group<br>
func (g *Group) Add(delta int)<br>
func (g *Group) Done()<br>
func (g *Group) Error(e error)<br>
func (g *Group) Wait() error</p>
<p>关于 Wait 方法，我刚刚已经介绍了它和标准库 WaitGroup 的不同，我就不多说了。这里还有一个不同的方法，就是 Error 方法，</p>
<p>我举个例子演示一下 Error 的使用方法。</p>
<p>在下面的这个例子中，第 26 行的子 goroutine 设置了 error 信息，第 39 行会把这个 error 信息输出出来。</p>
<p>package main</p>
<p>import (<br>
&ldquo;errors&rdquo;<br>
&ldquo;fmt&rdquo;<br>
&ldquo;time&rdquo;</p>
<pre><code>&quot;github.com/facebookgo/errgroup&quot;  
</code></pre>
<p>)</p>
<p>func main() {<br>
var g errgroup.Group<br>
g.Add(3)</p>
<pre><code>// 启动第一个子任务，它执行成功  
go func() {  
    time.Sleep(5 * time.Second)  
    fmt.Println(&quot;exec #1&quot;)  
    g.Done()  
}()  

// 启动第二个子任务，它执行失败  
go func() {  
    time.Sleep(10 * time.Second)  
    fmt.Println(&quot;exec #2&quot;)  
    g.Error(errors.New(&quot;failed to exec #2&quot;))  
    g.Done()  
}()  

// 启动第三个子任务，它执行成功  
go func() {  
    time.Sleep(15 * time.Second)  
    fmt.Println(&quot;exec #3&quot;)  
    g.Done()  
}()  

// 等待所有的 goroutine 完成，并检查 error  
if err := g.Wait(); err == nil {  
    fmt.Println(&quot;Successfully exec all&quot;)  
} else {  
    fmt.Println(&quot;failed:&quot;, err)  
}  
</code></pre>
<p>}</p>
<p>关于 ErrGroup，你掌握这些就足够了，接下来，我再介绍几种有趣而实用的 Group 并发原语。这些并发原语都是控制一组子 goroutine 执行的面向特定场景的并发原语，当你遇见这些特定场景时，就可以参考这些库。</p>
<h2 id="其它实用的-group-并发原语">其它实用的 Group 并发原语</h2>
<h3 id="sizedgrouperrsizedgroup">SizedGroup/ErrSizedGroup</h3>
<p>go-pkgz/syncs提供了两个 Group 并发原语，分别是 SizedGroup 和 ErrSizedGroup。</p>
<p>SizedGroup 内部是使用信号量和 WaitGroup 实现的，它通过信号量控制并发的 goroutine 数量，或者是不控制 goroutine 数量，只控制子任务并发执行时候的数量（通过）。</p>
<p>它的代码实现非常简洁，你可以到它的代码库中了解它的具体实现，你一看就明白了，我就不多说了。下面我重点说说它的功能。</p>
<p><strong>默认情况下，SizedGroup 控制的是子任务的并发数量，而不是 goroutine 的数量</strong>。在这种方式下，每次调用 Go 方法都不会被阻塞，而是新建一个 goroutine 去执行。</p>
<p>如果想控制 goroutine 的数量，你可以使用 syncs.Preemptive 设置这个并发原语的可选项。如果设置了这个可选项，但在调用 Go 方法的时候没有可用的 goroutine，那么调用者就会等待，直到有 goroutine 可以处理这个子任务才返回，这个控制在内部是使用信号量实现的。</p>
<p>我们来看一个使用 SizedGroup 的例子：</p>
<p>package main</p>
<p>import (<br>
&ldquo;context&rdquo;<br>
&ldquo;fmt&rdquo;<br>
&ldquo;sync/atomic&rdquo;<br>
&ldquo;time&rdquo;</p>
<pre><code>&quot;github.com/go-pkgz/syncs&quot;  
</code></pre>
<p>)</p>
<p>func main() {<br>
// 设置 goroutine 数是 10<br>
swg := syncs.NewSizedGroup(10)<br>
// swg := syncs.NewSizedGroup(10, syncs.Preemptive)<br>
var c uint32</p>
<pre><code>// 执行 1000 个子任务，只会有 10 个 goroutine 去执行  
for i := 0; i &lt; 1000; i++ {  
    swg.Go(func(ctx context.Context) {  
        time.Sleep(5 * time.Millisecond)  
        atomic.AddUint32(&amp;c, 1)  
    })  
}  

// 等待任务完成  
swg.Wait()  
// 输出结果  
fmt.Println(c)  
</code></pre>
<p>}</p>
<p>ErrSizedGroup 为 SizedGroup 提供了 error 处理的功能，它的功能和 Go 官方扩展库的功能一样，就是等待子任务完成并返回第一个出现的 error。不过，它还提供了额外的功能，我来介绍一下。</p>
<p>第一个额外的功能，就是可以控制并发的 goroutine 数量，这和 SizedGroup 的功能一样。</p>
<p>第二个功能是，如果设置了 termOnError，子任务出现第一个错误的时候会 cancel Context，而且后续的 Go 调用会直接返回，Wait 调用者会得到这个错误，这相当于是遇到错误快速返回。如果没有设置 termOnError，Wait 会返回所有的子任务的错误。</p>
<p>不过，ErrSizedGroup 和 SizedGroup 设计得不太一致的地方是，<strong>SizedGroup 可以把 Context 传递给子任务，这样可以通过 cancel 让子任务中断执行，但是 ErrSizedGroup 却没有实现。我认为，这是一个值得加强的地方</strong>。</p>
<p>总体来说，syncs 包提供的并发原语的质量和功能还是非常赞的。不过，目前的 star 只有十几个，这和它的功能严重不匹配，我建议你 star 这个项目，支持一下作者。</p>
<p>好了，关于 ErrGroup，你掌握这些就足够了，下面我再来给你介绍一些非 ErrGroup 的并发原语，它们用来编排子任务。</p>
<h1 id="gollback">gollback</h1>
<p>gollback也是用来处理一组子任务的执行的，不过它解决了 ErrGroup 收集子任务返回结果的痛点。使用 ErrGroup 时，如果你要收到子任务的结果和错误，你需要定义额外的变量收集执行结果和错误，但是这个库可以提供更便利的方式。</p>
<p>我刚刚在说官方扩展库 ErrGroup 的时候，举了一些例子（返回第一个错误的例子和返回所有子任务错误的例子），在例子中，如果想得到每一个子任务的结果或者 error，我们需要额外提供一个 result slice 进行收集。使用 gollback 的话，就不需要这些额外的处理了，因为它的方法会把结果和 error 信息都返回。</p>
<p>接下来，我们看一下它提供的三个方法，分别是 <strong>All、Race 和 Retry</strong>。</p>
<p><strong>All 方法</strong></p>
<p>All 方法的签名如下：</p>
<p>func All(ctx context.Context, fns &hellip;AsyncFunc) ([]interface{}, []error)</p>
<p>它会等待所有的异步函数（AsyncFunc）都执行完才返回，而且返回结果的顺序和传入的函数的顺序保持一致。第一个返回参数是子任务的执行结果，第二个参数是子任务执行时的错误信息。</p>
<p>其中，异步函数的定义如下：</p>
<p>type AsyncFunc func(ctx context.Context) (interface{}, error)</p>
<p>可以看到，ctx 会被传递给子任务。如果你 cancel 这个 ctx，可以取消子任务。</p>
<p>我们来看一个使用 All 方法的例子：</p>
<p>package main</p>
<p>import (<br>
&ldquo;context&rdquo;<br>
&ldquo;errors&rdquo;<br>
&ldquo;fmt&rdquo;<br>
&ldquo;github.com/vardius/gollback&rdquo;<br>
&ldquo;time&rdquo;<br>
)</p>
<p>func main() {<br>
rs, errs := gollback.All( // 调用 All 方法<br>
context.Background(),<br>
func(ctx context.Context) (interface{}, error) {<br>
time.Sleep(3 * time.Second)<br>
return 1, nil // 第一个任务没有错误，返回 1<br>
},<br>
func(ctx context.Context) (interface{}, error) {<br>
return nil, errors.New(&ldquo;failed&rdquo;) // 第二个任务返回一个错误<br>
},<br>
func(ctx context.Context) (interface{}, error) {<br>
return 3, nil // 第三个任务没有错误，返回 3<br>
},<br>
)</p>
<p>fmt.Println(rs) // 输出子任务的结果<br>
fmt.Println(errs) // 输出子任务的错误信息<br>
}</p>
<p><strong>Race 方法</strong></p>
<p>Race 方法跟 All 方法类似，只不过，在使用 Race 方法的时候，只要一个异步函数执行没有错误，就立马返回，而不会返回所有的子任务信息。如果所有的子任务都没有成功，就会返回最后一个 error 信息。</p>
<p>Race 方法签名如下：</p>
<p>func Race(ctx context.Context, fns &hellip;AsyncFunc) (interface{}, error)</p>
<p>如果有一个正常的子任务的结果返回，Race 会把传入到其它子任务的 Context cancel 掉，这样子任务就可以中断自己的执行。</p>
<p>Race 的使用方法也跟 All 方法类似，我就不再举例子了，你可以把 All 方法的例子中的 All 替换成 Race 方式测试下。</p>
<p><strong>Retry 方法</strong></p>
<p><strong>Retry 不是执行一组子任务，而是执行一个子任务</strong>。如果子任务执行失败，它会尝试一定的次数，如果一直不成功，就会返回失败错误，如果执行成功，它会立即返回。如果 retires 等于 0，它会永远尝试，直到成功。</p>
<p>func Retry(ctx context.Context, retires int, fn AsyncFunc) (interface{}, error)</p>
<p>再来看一个使用 Retry 的例子：</p>
<p>package main</p>
<p>import (<br>
&ldquo;context&rdquo;<br>
&ldquo;errors&rdquo;<br>
&ldquo;fmt&rdquo;<br>
&ldquo;github.com/vardius/gollback&rdquo;<br>
&ldquo;time&rdquo;<br>
)</p>
<p>func main() {<br>
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)<br>
defer cancel()</p>
<p>// 尝试 5 次，或者超时返回<br>
res, err := gollback.Retry(ctx, 5, func(ctx context.Context) (interface{}, error) {<br>
return nil, errors.New(&ldquo;failed&rdquo;)<br>
})</p>
<p>fmt.Println(res) // 输出结果<br>
fmt.Println(err) // 输出错误信息<br>
}</p>
<h1 id="hunch">Hunch</h1>
<p>Hunch提供的功能和 gollback 类似，不过它提供的方法更多，而且它提供的和 gollback 相应的方法，也有一些不同。我来一一介绍下。</p>
<p>它定义了执行子任务的函数，这和 gollback 的 AyncFunc 是一样的，它的定义如下：</p>
<p>type Executable func(context.Context) (interface{}, error)</p>
<p><strong>All 方法</strong></p>
<p>All 方法的签名如下：</p>
<p>func All(parentCtx context.Context, execs &hellip;Executable) ([]interface{}, error)</p>
<p>它会传入一组可执行的函数（子任务），返回子任务的执行结果。和 gollback 的 All 方法不一样的是，一旦一个子任务出现错误，它就会返回错误信息，执行结果（第一个返回参数）为 nil。</p>
<p><strong>Take 方法</strong></p>
<p>Take 方法的签名如下：</p>
<p>func Take(parentCtx context.Context, num int, execs &hellip;Executable) ([]interface{}, error)</p>
<p>你可以指定 num 参数，只要有 num 个子任务正常执行完没有错误，这个方法就会返回这几个子任务的结果。一旦一个子任务出现错误，它就会返回错误信息，执行结果（第一个返回参数）为 nil。</p>
<p><strong>Last 方法</strong></p>
<p>Last 方法的签名如下：</p>
<p>func Last(parentCtx context.Context, num int, execs &hellip;Executable) ([]interface{}, error)</p>
<p>它只返回最后 num 个正常执行的、没有错误的子任务的结果。一旦一个子任务出现错误，它就会返回错误信息，执行结果（第一个返回参数）为 nil。</p>
<p>比如 num 等于 1，那么，它只会返回最后一个无错的子任务的结果。</p>
<p><strong>Retry 方法</strong></p>
<p>Retry 方法的签名如下：</p>
<p>func Retry(parentCtx context.Context, retries int, fn Executable) (interface{}, error)</p>
<p>它的功能和 gollback 的 Retry 方法的功能一样，如果子任务执行出错，就会不断尝试，直到成功或者是达到重试上限。如果达到重试上限，就会返回错误。如果 retries 等于 0，它会不断尝试。</p>
<p><strong>Waterfall 方法</strong></p>
<p>Waterfall 方法签名如下：</p>
<p>func Waterfall(parentCtx context.Context, execs &hellip;ExecutableInSequence) (interface{}, error)</p>
<p>它其实是一个 pipeline 的处理方式，所有的子任务都是串行执行的，前一个子任务的执行结果会被当作参数传给下一个子任务，直到所有的任务都完成，返回最后的执行结果。一旦一个子任务出现错误，它就会返回错误信息，执行结果（第一个返回参数）为 nil。</p>
<p>gollback 和 Hunch 是属于同一类的并发原语，对一组子任务的执行结果，可以选择一个结果或者多个结果，这也是现在热门的微服务常用的服务治理的方法。</p>
<h1 id="schedgroup">schedgroup</h1>
<p>接下来，我再介绍一个<strong>和时间相关的处理一组 goroutine 的并发原语 schedgroup</strong>。</p>
<p>schedgroup是 Matt Layher 开发的 worker pool，可以指定任务在某个时间或者某个时间之后执行。Matt Layher 也是一个知名的 Gopher，经常在一些会议上分享一些他的 Go 开发经验，他在 GopherCon Europe 2020 大会上专门介绍了这个并发原语：schedgroup: a timer-based goroutine concurrency primitive ，课下你可以点开这个链接看一下，下面我来给你介绍一些重点。</p>
<p>这个并发原语包含的方法如下：</p>
<p>type Group<br>
func New(ctx context.Context) *Group<br>
func (g *Group) Delay(delay time.Duration, fn func())<br>
func (g *Group) Schedule(when time.Time, fn func())<br>
func (g *Group) Wait() error</p>
<p>我来介绍下这些方法。</p>
<p>先说 Delay 和 Schedule。</p>
<p>它们的功能其实是一样的，都是用来指定在某个时间或者之后执行一个函数。只不过，Delay 传入的是一个 time.Duration 参数，它会在 time.Now()+delay 之后执行函数，而 Schedule 可以指定明确的某个时间执行。</p>
<p>再来说说 Wait 方法。</p>
<p>这个方法调用会阻塞调用者，直到之前安排的所有子任务都执行完才返回。如果 Context 被取消，那么，Wait 方法会返回这个 cancel error。</p>
<p>在使用 Wait 方法的时候，有 2 点需要注意一下。</p>
<p><strong>第一点是，如果调用了 Wait 方法，你就不能再调用它的 Delay 和 Schedule 方法，否则会 panic。</strong></p>
<p><strong>第二点是，Wait 方法只能调用一次，如果多次调用的话，就会 panic。</strong></p>
<p>你可能认为，简单地使用 timer 就可以实现这个功能。其实，如果只有几个子任务，使用 timer 不是问题，但一旦有大量的子任务，而且还要能够 cancel，那么，使用 timer 的话，CPU 资源消耗就比较大了。所以，schedgroup 在实现的时候，就使用 container/heap，按照子任务的执行时间进行排序，这样可以避免使用大量的 timer，从而提高性能。</p>
<p>我们来看一个使用 schedgroup 的例子，下面代码会依次输出 1、2、3：</p>
<p>sg := schedgroup.New(context.Background())</p>
<p>// 设置子任务分别在 100、200、300 之后执行<br>
for i := 0; i &lt; 3; i++ {<br>
n := i + 1<br>
sg.Delay(time.Duration(n)<em>100</em>time.Millisecond, func() {<br>
log.Println(n) //输出任务编号<br>
})<br>
}</p>
<p>// 等待所有的子任务都完成<br>
if err := sg.Wait(); err != nil {<br>
log.Fatalf(&ldquo;failed to wait: %v&rdquo;, err)<br>
}</p>
<h1 id="总结">总结</h1>
<p>这节课，我给你介绍了几种常见的处理一组子任务的并发原语，包括 ErrGroup、gollback、Hunch、schedgroup，等等。这些常见的业务场景共性处理方式的总结，你可以把它们加入到你的知识库中，等以后遇到相同的业务场景时，你就可以考虑使用这些并发原语。</p>
<p>当然，类似的并发原语还有别的，比如go-waitgroup等，而且，我相信还会有新的并发原语不断出现。所以，你不仅仅要掌握这些并发原语，而且还要通过学习这些并发原语，学会构造新的并发原语来处理应对你的特有场景，实现代码重用和业务逻辑简化。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/2baf2aa051f42b56eb5b1d8eb4395739.png" alt=""></p>
<h1 id="思考题">思考题</h1>
<p>这节课，我讲的官方扩展库 ErrGroup 没有实现可以取消子任务的功能，请你课下可以自己去实现一个子任务可取消的 ErrGroup。</p>
<p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/">Go并发编程实战课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/18__%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BD%A0%E6%96%B9%E5%94%B1%E7%BD%A2%E6%88%91%E7%99%BB%E5%9C%BA/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">18__分布式计算模式之流水线：你方唱罢我登场</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E6%A5%BC%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/18__%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%BF%A1%E6%81%AF%E7%A1%AE%E5%AE%9A%E8%AE%A2%E5%8D%95%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%E5%8C%96%E9%80%BB%E8%BE%91%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81/">
            <span class="next-text nav-default">18__购物车信息确定订单：为什么动态参数化逻辑非常重要？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
