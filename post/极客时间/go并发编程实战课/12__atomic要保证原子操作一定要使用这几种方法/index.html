<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>12__atomic：要保证原子操作，一定要使用这几种方法 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是鸟窝。
前面我们在学习 Mutex、RWMutex 等并发原语的实现时，你可以看到，最底层是通过 atomic 包中的一些原子操作来实现的。当时，为了让你的注意力集中在这些原语的功能实现上，我并没有展开介绍这些原子操作是干什么用的。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/12__atomic%E8%A6%81%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%80%E5%AE%9A%E8%A6%81%E4%BD%BF%E7%94%A8%E8%BF%99%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/12__atomic%E8%A6%81%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%80%E5%AE%9A%E8%A6%81%E4%BD%BF%E7%94%A8%E8%BF%99%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="12__atomic：要保证原子操作，一定要使用这几种方法">
  <meta property="og:description" content="你好，我是鸟窝。
前面我们在学习 Mutex、RWMutex 等并发原语的实现时，你可以看到，最底层是通过 atomic 包中的一些原子操作来实现的。当时，为了让你的注意力集中在这些原语的功能实现上，我并没有展开介绍这些原子操作是干什么用的。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Go并发编程实战课">

  <meta itemprop="name" content="12__atomic：要保证原子操作，一定要使用这几种方法">
  <meta itemprop="description" content="你好，我是鸟窝。
前面我们在学习 Mutex、RWMutex 等并发原语的实现时，你可以看到，最底层是通过 atomic 包中的一些原子操作来实现的。当时，为了让你的注意力集中在这些原语的功能实现上，我并没有展开介绍这些原子操作是干什么用的。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6304">
  <meta itemprop="keywords" content="Go并发编程实战课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="12__atomic：要保证原子操作，一定要使用这几种方法">
  <meta name="twitter:description" content="你好，我是鸟窝。
前面我们在学习 Mutex、RWMutex 等并发原语的实现时，你可以看到，最底层是通过 atomic 包中的一些原子操作来实现的。当时，为了让你的注意力集中在这些原语的功能实现上，我并没有展开介绍这些原子操作是干什么用的。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">12__atomic：要保证原子操作，一定要使用这几种方法</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6304 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#原子操作的基础知识">原子操作的基础知识</a></li>
    <li><a href="#atomic-原子操作的应用场景">atomic 原子操作的应用场景</a></li>
    <li><a href="#atomic-提供的方法">atomic 提供的方法</a>
      <ul>
        <li><a href="#add">Add</a></li>
        <li><a href="#cascompareandswap">CAS（CompareAndSwap）</a></li>
        <li><a href="#swap">Swap</a></li>
        <li><a href="#load">Load</a></li>
        <li><a href="#store">Store</a></li>
        <li><a href="#value-类型">Value 类型</a></li>
      </ul>
    </li>
    <li><a href="#第三方库的扩展">第三方库的扩展</a></li>
    <li><a href="#使用-atomic-实现-lock-free-queue">使用 atomic 实现 Lock-Free queue</a></li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#思考题">思考题</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是鸟窝。</p>
<p>前面我们在学习 Mutex、RWMutex 等并发原语的实现时，你可以看到，最底层是通过 atomic 包中的一些原子操作来实现的。当时，为了让你的注意力集中在这些原语的功能实现上，我并没有展开介绍这些原子操作是干什么用的。</p>
<p>你可能会说，这些并发原语已经可以应对大多数的并发场景了，为啥还要学习原子操作呢？其实，这是因为，在很多场景中，使用并发原语实现起来比较复杂，而原子操作可以帮助我们更轻松地实现底层的优化。</p>
<p>所以，现在，我会专门用一节课，带你仔细地了解一下什么是原子操作，atomic 包都提供了哪些实现原子操作的方法。另外，我还会带你实现一个基于原子操作的数据结构。好了，接下来我们先来学习下什么是原子操作。</p>
<h1 id="原子操作的基础知识">原子操作的基础知识</h1>
<p>Package sync/atomic 实现了同步算法底层的原子的内存操作原语，我们把它叫做原子操作原语，它提供了一些实现原子操作的方法。</p>
<p>之所以叫原子操作，是因为一个原子在执行的时候，其它线程不会看到执行一半的操作结果。在其它线程看来，原子操作要么执行完了，要么还没有执行，就像一个最小的粒子 - 原子一样，不可分割。</p>
<p>CPU 提供了基础的原子操作，不过，不同架构的系统的原子操作是不一样的。</p>
<p>对于单处理器单核系统来说，如果一个操作是由一个 CPU 指令来实现的，那么它就是原子操作，比如它的 XCHG 和 INC 等指令。如果操作是基于多条指令来实现的，那么，执行的过程中可能会被中断，并执行上下文切换，这样的话，原子性的保证就被打破了，因为这个时候，操作可能只执行了一半。</p>
<p>在多处理器多核系统中，原子操作的实现就比较复杂了。</p>
<p>由于 cache 的存在，单个核上的单个指令进行原子操作的时候，你要确保其它处理器或者核不访问此原子操作的地址，或者是确保其它处理器或者核总是访问原子操作之后的最新的值。x86 架构中提供了指令前缀 LOCK，LOCK 保证了指令（比如 LOCK CMPXCHG op1、op2）不会受其它处理器或 CPU 核的影响，有些指令（比如 XCHG）本身就提供 Lock 的机制。不同的 CPU 架构提供的原子操作指令的方式也是不同的，比如对于多核的 MIPS 和 ARM，提供了 LL/SC（Load Link/Store Conditional）指令，可以帮助实现原子操作（ARMLL/SC 指令 LDREX 和 STREX）。</p>
<p><strong>因为不同的 CPU 架构甚至不同的版本提供的原子操作的指令是不同的，所以，要用一种编程语言实现支持不同架构的原子操作是相当有难度的</strong>。不过，还好这些都不需要你操心，因为 Go 提供了一个通用的原子操作的 API，将更底层的不同的架构下的实现封装成 atomic 包，提供了修改类型的原子操作（atomic read-modify-write，RMW）和加载存储类型的原子操作（Load 和 Store）的 API，稍后我会一一介绍。</p>
<p>有的代码也会因为架构的不同而不同。有时看起来貌似一个操作是原子操作，但实际上，对于不同的架构来说，情况是不一样的。比如下面的代码的第 4 行，是将一个 64 位的值赋值给变量 i：</p>
<p>const x int64 = 1 + 1&laquo;33</p>
<p>func main() {<br>
var i = x<br>
_ = i<br>
}</p>
<p>如果你使用 GOARCH=386 的架构去编译这段代码，那么，第 5 行其实是被拆成了两个指令，分别操作低 32 位和高 32 位（使用 GOARCH=386 go tool compile -N -l test.go；GOARCH=386 go tool objdump -gnu test.o 反编译试试）：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/5b193054158f2a645beeeb82220b95b3.png" alt=""></p>
<p>如果 GOARCH=amd64 的架构去编译这段代码，那么，第 5 行其中的赋值操作其实是一条指令：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/13a91d5dc292d1d733761fc654ca7efd.png" alt=""></p>
<p>所以，如果要想保证原子操作，切记一定要使用 atomic 提供的方法。</p>
<p>好了，了解了什么是原子操作以及不同系统的不同原子操作，接下来，我来介绍下 atomic 原子操作的应用场景。</p>
<h1 id="atomic-原子操作的应用场景">atomic 原子操作的应用场景</h1>
<p>开篇我说过，使用 atomic 的一些方法，我们可以实现更底层的一些优化。如果使用 Mutex 等并发原语进行这些优化，虽然可以解决问题，但是这些并发原语的实现逻辑比较复杂，对性能还是有一定的影响的。</p>
<p>举个例子：假设你想在程序中使用一个标志（flag，比如一个 bool 类型的变量），来标识一个定时任务是否已经启动执行了，你会怎么做呢？</p>
<p>我们先来看看加锁的方法。如果使用 Mutex 和 RWMutex，在读取和设置这个标志的时候加锁，是可以做到互斥的、保证同一时刻只有一个定时任务在执行的，所以使用 Mutex 或者 RWMutex 是一种解决方案。</p>
<p>其实，这个场景中的问题不涉及到对资源复杂的竞争逻辑，只是会并发地读写这个标志，这类场景就适合使用 atomic 的原子操作。具体怎么做呢？你可以使用一个 uint32 类型的变量，如果这个变量的值是 0，就标识没有任务在执行，如果它的值是 1，就标识已经有任务在完成了。你看，是不是很简单呢？</p>
<p>再来看一个例子。假设你在开发应用程序的时候，需要从配置服务器中读取一个节点的配置信息。而且，在这个节点的配置发生变更的时候，你需要重新从配置服务器中拉取一份新的配置并更新。你的程序中可能有多个 goroutine 都依赖这份配置，涉及到对这个配置对象的并发读写，你可以使用读写锁实现对配置对象的保护。在大部分情况下，你也可以利用 atomic 实现配置对象的更新和加载。</p>
<p>分析到这里，可以看到，这两个例子都可以使用基本并发原语来实现的，只不过，我们不需要这些基本并发原语里面的复杂逻辑，而是只需要其中的简单原子操作，所以，这些场景可以直接使用 atomic 包中的方法去实现。</p>
<p><strong>有时候，你也可以使用 atomic 实现自己定义的基本并发原语</strong>，比如 Go issue 有人提议的 CondMutex、Mutex.LockContext、WaitGroup.Go 等，我们可以使用 atomic 或者基于它的更高一级的并发原语去实现。我先前讲的几种基本并发原语的底层（比如 Mutex），就是基于通过 atomic 的方法实现的。</p>
<p>除此之外，atomic 原子操作还是实现 lock-free 数据结构的基石。</p>
<p>在实现 lock-free 的数据结构时，我们可以不使用互斥锁，这样就不会让线程因为等待互斥锁而阻塞休眠，而是让线程保持继续处理的状态。另外，不使用互斥锁的话，lock-free 的数据结构还可以提供并发的性能。</p>
<p>不过，lock-free 的数据结构实现起来比较复杂，需要考虑的东西很多，有兴趣的同学可以看一位微软专家写的一篇经验分享：Lockless Programming Considerations for Xbox 360 and Microsoft Windows，这里我们不细谈了。不过，这节课的最后我会带你开发一个 lock-free 的 queue，来学习下使用 atomic 操作实现 lock-free 数据结构的方法，你可以拿它和使用互斥锁实现的 queue 做性能对比，看看在性能上是否有所提升。</p>
<p>看到这里，你是不是觉得 atomic 非常重要呢？不过，要想能够灵活地应用 atomic，我们首先得知道 atomic 提供的所有方法。</p>
<h1 id="atomic-提供的方法">atomic 提供的方法</h1>
<p>目前的 Go 的泛型的特性还没有发布，Go 的标准库中的很多实现会显得非常啰嗦，多个类型会实现很多类似的方法，尤其是 atomic 包，最为明显。相信泛型支持之后，atomic 的 API 会清爽很多。</p>
<p>atomic 为了支持 int32、int64、uint32、uint64、uintptr、Pointer（Add 方法不支持）类型，分别提供了 AddXXX、CompareAndSwapXXX、SwapXXX、LoadXXX、StoreXXX 等方法。不过，你也不要担心，你只要记住了一种数据类型的方法的意义，其它数据类型的方法也是一样的。</p>
<p>关于 atomic，还有一个地方你一定要记住，<strong>atomic 操作的对象是一个地址，你需要把可寻址的变量的地址作为参数传递给方法，而不是把变量的值传递给方法</strong>。</p>
<p>好了，下面我就来给你介绍一下 atomic 提供的方法。掌握了这些，你就可以说完全掌握了 atomic 包。</p>
<h2 id="add">Add</h2>
<p>首先，我们来看 Add 方法的签名：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/4170b71547faa59d29d21cd53bdaa6bf.png" alt=""></p>
<p>其实，Add 方法就是给第一个参数地址中的值增加一个 delta 值。</p>
<p>对于有符号的整数来说，delta 可以是一个负数，相当于减去一个值。对于无符号的整数和 uinptr 类型来说，怎么实现减去一个值呢？毕竟，atomic 并没有提供单独的减法操作。</p>
<p>我来跟你说一种方法。你可以利用计算机补码的规则，把减法变成加法。以 uint32 类型为例：</p>
<p>AddUint32(&amp;x, ^uint32(c-1)).</p>
<p>如果是对 uint64 的值进行操作，那么，就把上面的代码中的 uint32 替换成 uint64。</p>
<p>尤其是减 1 这种特殊的操作，我们可以简化为：</p>
<p>AddUint32(&amp;x, ^uint32(0))</p>
<p>好了，我们再来看看 CAS 方法。</p>
<h2 id="cascompareandswap">CAS（CompareAndSwap）</h2>
<p>以 int32 为例，我们学习一下 CAS 提供的功能。在 CAS 的方法签名中，需要提供要操作的地址、原数据值、新值，如下所示：</p>
<p>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</p>
<p>我们来看下这个方法的功能。</p>
<p>这个方法会比较当前 addr 地址里的值是不是 old，如果不等于 old，就返回 false；如果等于 old，就把此地址的值替换成 new 值，返回 true。这就相当于“判断相等才替换”。</p>
<p>如果使用伪代码来表示这个原子操作，代码如下：</p>
<p>if *addr == old {<br>
*addr = new<br>
return true<br>
}<br>
return false</p>
<p>它支持的类型和方法如图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/de6d354f350b6eb983dcc3f17b87bbb4.png" alt=""></p>
<h2 id="swap">Swap</h2>
<p>如果不需要比较旧值，只是比较粗暴地替换的话，就可以使用 Swap 方法，它替换后还可以返回旧值，伪代码如下：</p>
<p>old = *addr<br>
*addr = new<br>
return old</p>
<p>它支持的数据类型和方法如图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/5b9745467457b6af711d236317ecf226.png" alt=""></p>
<h2 id="load">Load</h2>
<p>Load 方法会取出 addr 地址中的值，即使在多处理器、多核、有 CPU cache 的情况下，这个操作也能保证 Load 是一个原子操作。</p>
<p>它支持的数据类型和方法如图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/1417b6be3516542b8d4d475b905e1283.png" alt=""></p>
<h2 id="store">Store</h2>
<p>Store 方法会把一个值存入到指定的 addr 地址中，即使在多处理器、多核、有 CPU cache 的情况下，这个操作也能保证 Store 是一个原子操作。别的 goroutine 通过 Load 读取出来，不会看到存取了一半的值。</p>
<p>它支持的数据类型和方法如图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/c1738c351948a98a88ef7457126156ce.png" alt=""></p>
<h2 id="value-类型">Value 类型</h2>
<p>刚刚说的都是一些比较常见的类型，其实，atomic 还提供了一个特殊的类型：Value。它可以原子地存取对象类型，但也只能存取，不能 CAS 和 Swap，常常用在配置变更等场景中。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/50e77b6214b543a4048549b7d0481312.png" alt=""></p>
<p>接下来，我以一个配置变更的例子，来演示 Value 类型的使用。这里定义了一个 Value 类型的变量 config，用来存储配置信息。</p>
<p>首先，我们启动一个 goroutine，然后让它随机 sleep 一段时间，之后就变更一下配置，并通过我们前面学到的 Cond 并发原语，通知其它的 reader 去加载新的配置。</p>
<p>接下来，我们启动一个 goroutine 等待配置变更的信号，一旦有变更，它就会加载最新的配置。</p>
<p>通过这个例子，你可以了解到 Value 的 Store/Load 方法的使用，因为它只有这两个方法，只要掌握了它们的使用，你就完全掌握了 Value 类型。</p>
<p>type Config struct {<br>
NodeName string<br>
Addr     string<br>
Count    int32<br>
}</p>
<p>func loadNewConfig() Config {<br>
return Config{<br>
NodeName: &ldquo;北京&rdquo;,<br>
Addr:     &ldquo;10.77.95.27&rdquo;,<br>
Count:    rand.Int31(),<br>
}<br>
}<br>
func main() {<br>
var config atomic.Value<br>
config.Store(loadNewConfig())<br>
var cond = sync.NewCond(&amp;sync.Mutex{})</p>
<pre><code>// 设置新的 config  
go func() {  
    for {  
        time.Sleep(time.Duration(5+rand.Int63n(5)) * time.Second)  
        config.Store(loadNewConfig())  
        cond.Broadcast() // 通知等待着配置已变更  
    }  
}()  

go func() {  
    for {  
        cond.L.Lock()  
        cond.Wait()                 // 等待变更信号  
        c := config.Load().(Config) // 读取新的配置  
        fmt.Printf(&quot;new config: %+v\n&quot;, c)  
        cond.L.Unlock()  
    }  
}()  

select {}  
</code></pre>
<p>}</p>
<p>好了，关于标准库的 atomic 提供的方法，到这里我们就学完了。事实上，atomic 包提供了非常好的支持各种平台的一致性的 API，绝大部分项目都是直接使用它。接下来，我再给你介绍一下第三方库，帮助你稍微开拓一下思维。</p>
<h1 id="第三方库的扩展">第三方库的扩展</h1>
<p>其实，atomic 的 API 已经算是很简单的了，它提供了包一级的函数，可以对几种类型的数据执行原子操作。</p>
<p>不过有一点让人觉得不爽的是，或者是让熟悉面向对象编程的程序员不爽的是，函数调用有一点点麻烦。所以，有些人就对这些函数做了进一步的包装，跟 atomic 中的 Value 类型类似，这些类型也提供了面向对象的使用方式，比如关注度比较高的uber-go/atomic，它定义和封装了几种与常见类型相对应的原子操作类型，这些类型提供了原子操作的方法。这些类型包括 Bool、Duration、Error、Float64、Int32、Int64、String、Uint32、Uint64 等。</p>
<p>比如 Bool 类型，提供了 CAS、Store、Swap、Toggle 等原子方法，还提供 String、MarshalJSON、UnmarshalJSON 等辅助方法，确实是一个精心设计的 atomic 扩展库。关于这些方法，你一看名字就能猜出来它们的功能，我就不多说了。</p>
<p>其它的数据类型也和 Bool 类型相似，使用起来就像面向对象的编程一样，你可以看下下面的这段代码。</p>
<pre><code>var running atomic.Bool  
running.Store(true)  
running.Toggle()  
fmt.Println(running.Load()) // false
</code></pre>
<h1 id="使用-atomic-实现-lock-free-queue">使用 atomic 实现 Lock-Free queue</h1>
<p>atomic 常常用来实现 Lock-Free 的数据结构，这次我会给你展示一个 Lock-Free queue 的实现。</p>
<p>Lock-Free queue 最出名的就是 Maged M. Michael 和 Michael L. Scott 1996 年发表的论文中的算法，算法比较简单，容易实现，伪代码的每一行都提供了注释，我就不在这里贴出伪代码了，因为我们使用 Go 实现这个数据结构的代码几乎和伪代码一样：</p>
<p>package queue<br>
import (<br>
&ldquo;sync/atomic&rdquo;<br>
&ldquo;unsafe&rdquo;<br>
)<br>
// lock-free 的 queue<br>
type LKQueue struct {<br>
head unsafe.Pointer<br>
tail unsafe.Pointer<br>
}<br>
// 通过链表实现，这个数据结构代表链表中的节点<br>
type node struct {<br>
value interface{}<br>
next  unsafe.Pointer<br>
}<br>
func NewLKQueue() *LKQueue {<br>
n := unsafe.Pointer(&amp;node{})<br>
return &amp;LKQueue{head: n, tail: n}<br>
}<br>
// 入队<br>
func (q *LKQueue) Enqueue(v interface{}) {<br>
n := &amp;node{value: v}<br>
for {<br>
tail := load(&amp;q.tail)<br>
next := load(&amp;tail.next)<br>
if tail == load(&amp;q.tail) { // 尾还是尾<br>
if next == nil { // 还没有新数据入队<br>
if cas(&amp;tail.next, next, n) { //增加到队尾<br>
cas(&amp;q.tail, tail, n) //入队成功，移动尾巴指针<br>
return<br>
}<br>
} else { // 已有新数据加到队列后面，需要移动尾指针<br>
cas(&amp;q.tail, tail, next)<br>
}<br>
}<br>
}<br>
}<br>
// 出队，没有元素则返回 nil<br>
func (q *LKQueue) Dequeue() interface{} {<br>
for {<br>
head := load(&amp;q.head)<br>
tail := load(&amp;q.tail)<br>
next := load(&amp;head.next)<br>
if head == load(&amp;q.head) { // head 还是那个 head<br>
if head == tail { // head 和 tail 一样<br>
if next == nil { // 说明是空队列<br>
return nil<br>
}<br>
// 只是尾指针还没有调整，尝试调整它指向下一个<br>
cas(&amp;q.tail, tail, next)<br>
} else {<br>
// 读取出队的数据<br>
v := next.value<br>
// 既然要出队了，头指针移动到下一个<br>
if cas(&amp;q.head, head, next) {<br>
return v // Dequeue is done.  return<br>
}<br>
}<br>
}<br>
}<br>
}</p>
<p>// 将 unsafe.Pointer 原子加载转换成 node<br>
func load(p *unsafe.Pointer) (n *node) {<br>
return (*node)(atomic.LoadPointer(p))<br>
}</p>
<p>// 封装 CAS，避免直接将*node 转换成 unsafe.Pointer<br>
func cas(p *unsafe.Pointer, old, new *node) (ok bool) {<br>
return atomic.CompareAndSwapPointer(<br>
p, unsafe.Pointer(old), unsafe.Pointer(new))<br>
}</p>
<p>我来给你介绍下这里的主要逻辑。</p>
<p>这个 lock-free 的实现使用了一个辅助头指针（head），头指针不包含有意义的数据，只是一个辅助的节点，这样的话，出队入队中的节点会更简单。</p>
<p>入队的时候，通过 CAS 操作将一个元素添加到队尾，并且移动尾指针。</p>
<p>出队的时候移除一个节点，并通过 CAS 操作移动 head 指针，同时在必要的时候移动尾指针。</p>
<h1 id="总结">总结</h1>
<p>好了，我们来小结一下。这节课，我们学习了 atomic 的基本使用方法，以及它提供的几种方法，包括 Add、CAS、Swap、Load、Store、Value 类型。除此之外，我还介绍了一些第三方库，并且带你实现了 Lock-free queue。到这里，相信你已经掌握了 atomic 提供的各种方法，并且能够应用到实践中了。</p>
<p>最后，我还想和你讨论一个额外的问题：对一个地址的赋值是原子操作吗？</p>
<p>这是一个很有趣的问题，如果是原子操作，还要 atomic 包干什么？官方的文档中并没有特意的介绍，不过，在一些 issue 或者论坛中，每当有人谈到这个问题时，总是会被建议用 atomic 包。</p>
<p>Dave Cheney就谈到过这个问题，讲得非常好。我来给你总结一下他讲的知识点，这样你就比较容易理解使用 atomic 和直接内存操作的区别了。</p>
<p>在现在的系统中，write 的地址基本上都是对齐的（aligned）。比如，32 位的操作系统、CPU 以及编译器，write 的地址总是 4 的倍数，64 位的系统总是 8 的倍数（还记得 WaitGroup 针对 64 位系统和 32 位系统对 state1 的字段不同的处理吗）。对齐地址的写，不会导致其他人看到只写了一半的数据，因为它通过一个指令就可以实现对地址的操作。如果地址不是对齐的话，那么，处理器就需要分成两个指令去处理，如果执行了一个指令，其它人就会看到更新了一半的错误的数据，这被称做撕裂写（torn write） 。所以，你可以认为赋值操作是一个原子操作，这个“原子操作”可以认为是保证数据的完整性。</p>
<p>但是，对于现代的多处理多核的系统来说，由于 cache、指令重排，可见性等问题，我们对原子操作的意义有了更多的追求。在多核系统中，一个核对地址的值的更改，在更新到主内存中之前，是在多级缓存中存放的。这时，多个核看到的数据可能是不一样的，其它的核可能还没有看到更新的数据，还在使用旧的数据。</p>
<p>多处理器多核心系统为了处理这类问题，使用了一种叫做内存屏障（memory fence 或 memory barrier）的方式。一个写内存屏障会告诉处理器，必须要等到它管道中的未完成的操作（特别是写操作）都被刷新到内存中，再进行操作。此操作还会让相关的处理器的 CPU 缓存失效，以便让它们从主存中拉取最新的值。</p>
<p>atomic 包提供的方法会提供内存屏障的功能，所以，atomic 不仅仅可以保证赋值的数据完整性，还能保证数据的可见性，一旦一个核更新了该地址的值，其它处理器总是能读取到它的最新值。但是，需要注意的是，因为需要处理器之间保证数据的一致性，atomic 的操作也是会降低性能的。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/7e6f43bc405a39f1b651cee6dbf2eaac.png" alt=""></p>
<h1 id="思考题">思考题</h1>
<p>atomic.Value 只有 Load/Store 方法，你是不是感觉意犹未尽？你可以尝试为 Value 类型增加 Swap 和 CompareAndSwap 方法（可以参考一下这份资料）。</p>
<p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/">Go并发编程实战课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/12__1_in_1..constructor%E8%BF%99%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%93%E6%9E%9C%E5%80%BC%E6%97%A2%E5%8F%AF%E8%83%BD%E6%98%AFtrue%E4%B9%9F%E5%8F%AF%E8%83%BD%E6%98%AFfalse/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">12__1_in_1..constructor：这行代码的结果值，既可能是true，也可能是false</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/12__controllerchannelmanagercontroller%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%AF%B7%E6%B1%82%E5%8F%91%E9%80%81/">
            <span class="next-text nav-default">12__ControllerChannelManager：Controller如何管理请求发送？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
