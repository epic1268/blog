<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>14__Channel：透过代码看典型的应用模式 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是鸟窝。
前一讲，我介绍了 Channel 的基础知识，并且总结了几种应用场景。这一讲，我将通过实例的方式，带你逐个学习 Channel 解决这些问题的方法，帮你巩固和完全掌握它的用法。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/14__channel%E9%80%8F%E8%BF%87%E4%BB%A3%E7%A0%81%E7%9C%8B%E5%85%B8%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/14__channel%E9%80%8F%E8%BF%87%E4%BB%A3%E7%A0%81%E7%9C%8B%E5%85%B8%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="14__Channel：透过代码看典型的应用模式">
  <meta property="og:description" content="你好，我是鸟窝。
前一讲，我介绍了 Channel 的基础知识，并且总结了几种应用场景。这一讲，我将通过实例的方式，带你逐个学习 Channel 解决这些问题的方法，帮你巩固和完全掌握它的用法。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Go并发编程实战课">

  <meta itemprop="name" content="14__Channel：透过代码看典型的应用模式">
  <meta itemprop="description" content="你好，我是鸟窝。
前一讲，我介绍了 Channel 的基础知识，并且总结了几种应用场景。这一讲，我将通过实例的方式，带你逐个学习 Channel 解决这些问题的方法，帮你巩固和完全掌握它的用法。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7177">
  <meta itemprop="keywords" content="Go并发编程实战课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="14__Channel：透过代码看典型的应用模式">
  <meta name="twitter:description" content="你好，我是鸟窝。
前一讲，我介绍了 Channel 的基础知识，并且总结了几种应用场景。这一讲，我将通过实例的方式，带你逐个学习 Channel 解决这些问题的方法，帮你巩固和完全掌握它的用法。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">14__Channel：透过代码看典型的应用模式</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7177 字 </span>
          <span class="more-meta"> 预计阅读 15 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#使用反射操作-channel">使用反射操作 Channel</a></li>
    <li><a href="#典型的应用场景">典型的应用场景</a>
      <ul>
        <li><a href="#消息交流">消息交流</a></li>
        <li><a href="#数据传递">数据传递</a></li>
        <li><a href="#信号通知">信号通知</a></li>
        <li><a href="#锁">锁</a></li>
        <li><a href="#任务编排">任务编排</a>
          <ul>
            <li><a href="#or-done-模式">Or-Done 模式</a></li>
            <li><a href="#扇入模式">扇入模式</a></li>
            <li><a href="#扇出模式">扇出模式</a></li>
            <li><a href="#stream">Stream</a></li>
            <li><a href="#map-reduce">Map-Reduce</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#思考题">思考题</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是鸟窝。</p>
<p>前一讲，我介绍了 Channel 的基础知识，并且总结了几种应用场景。这一讲，我将通过实例的方式，带你逐个学习 Channel 解决这些问题的方法，帮你巩固和完全掌握它的用法。</p>
<p>在开始上课之前，我先补充一个知识点：通过反射的方式执行 select 语句，在处理很多的 case clause，尤其是不定长的 case clause 的时候，非常有用。而且，在后面介绍任务编排的实现时，我也会采用这种方法，所以，我先带你具体学习下 Channel 的反射用法。</p>
<h1 id="使用反射操作-channel">使用反射操作 Channel</h1>
<p>select 语句可以处理 chan 的 send 和 recv，send 和 recv 都可以作为 case clause。如果我们同时处理两个 chan，就可以写成下面的样子：</p>
<pre><code>select {  
case v := &lt;-ch1:  
    fmt.Println(v)  
case v := &lt;-ch2:  
    fmt.Println(v)  
}
</code></pre>
<p>如果需要处理三个 chan，你就可以再添加一个 case clause，用它来处理第三个 chan。可是，如果要处理 100 个 chan 呢？一万个 chan 呢？</p>
<p>或者是，chan 的数量在编译的时候是不定的，在运行的时候需要处理一个 slice of chan，这个时候，也没有办法在编译前写成字面意义的 select。那该怎么办？</p>
<p>这个时候，就要“祭”出我们的反射大法了。</p>
<p>通过 reflect.Select 函数，你可以将一组运行时的 case clause 传入，当作参数执行。Go 的 select 是伪随机的，它可以在执行的 case 中随机选择一个 case，并把选择的这个 case 的索引（chosen）返回，如果没有可用的 case 返回，会返回一个 bool 类型的返回值，这个返回值用来表示是否有 case 成功被选择。如果是 recv case，还会返回接收的元素。Select 的方法签名如下：</p>
<p>func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</p>
<p>下面，我来借助一个例子，来演示一下，动态处理两个 chan 的情形。因为这样的方式可以动态处理 case 数据，所以，你可以传入几百几千几万的 chan，这就解决了不能动态处理 n 个 chan 的问题。</p>
<p>首先，createCases 函数分别为每个 chan 生成了 recv case 和 send case，并返回一个 reflect.SelectCase 数组。</p>
<p>然后，通过一个循环 10 次的 for 循环执行 reflect.Select，这个方法会从 cases 中选择一个 case 执行。第一次肯定是 send case，因为此时 chan 还没有元素，recv 还不可用。等 chan 中有了数据以后，recv case 就可以被选择了。这样，你就可以处理不定数量的 chan 了。</p>
<p>func main() {<br>
var ch1 = make(chan int, 10)<br>
var ch2 = make(chan int, 10)</p>
<pre><code>// 创建 SelectCase  
var cases = createCases(ch1, ch2)  

// 执行 10 次 select  
for i := 0; i &lt; 10; i++ {  
    chosen, recv, ok := reflect.Select(cases)  
    if recv.IsValid() { // recv case  
        fmt.Println(&quot;recv:&quot;, cases[chosen].Dir, recv, ok)  
    } else { // send case  
        fmt.Println(&quot;send:&quot;, cases[chosen].Dir, ok)  
    }  
}  
</code></pre>
<p>}</p>
<p>func createCases(chs &hellip;chan int) []reflect.SelectCase {<br>
var cases []reflect.SelectCase</p>
<pre><code>// 创建 recv case  
for _, ch := range chs {  
    cases = append(cases, reflect.SelectCase{  
        Dir:  reflect.SelectRecv,  
        Chan: reflect.ValueOf(ch),  
    })  
}  

// 创建 send case  
for i, ch := range chs {  
    v := reflect.ValueOf(i)  
    cases = append(cases, reflect.SelectCase{  
        Dir:  reflect.SelectSend,  
        Chan: reflect.ValueOf(ch),  
        Send: v,  
    })  
}  

return cases  
</code></pre>
<p>}</p>
<h1 id="典型的应用场景">典型的应用场景</h1>
<p>了解刚刚的反射用法，我们就解决了今天的基础知识问题，接下来，我就带你具体学习下 Channel 的应用场景。</p>
<p>首先来看消息交流。</p>
<h2 id="消息交流">消息交流</h2>
<p>从 chan 的内部实现看，它是以一个循环队列的方式存放数据，所以，它有时候也会被当成线程安全的队列和 buffer 使用。一个 goroutine 可以安全地往 Channel 中塞数据，另外一个 goroutine 可以安全地从 Channel 中读取数据，goroutine 就可以安全地实现信息交流了。</p>
<p>我们来看几个例子。</p>
<p>第一个例子是 worker 池的例子。Marcio Castilho 在 使用 Go 每分钟处理百万请求 这篇文章中，就介绍了他们应对大并发请求的设计。他们将用户的请求放在一个 chan Job 中，这个 chan Job 就相当于一个待处理任务队列。除此之外，还有一个 chan chan Job 队列，用来存放可以处理任务的 worker 的缓存队列。</p>
<p>dispatcher 会把待处理任务队列中的任务放到一个可用的缓存队列中，worker 会一直处理它的缓存队列。通过使用 Channel，实现了一个 worker 池的任务处理中心，并且解耦了前端 HTTP 请求处理和后端任务处理的逻辑。</p>
<p>我在讲 Pool 的时候，提到了一些第三方实现的 worker 池，它们全部都是通过 Channel 实现的，这是 Channel 的一个常见的应用场景。worker 池的生产者和消费者的消息交流都是通过 Channel 实现的。</p>
<p>第二个例子是 etcd 中的 node 节点的实现，包含大量的 chan 字段，比如 recvc 是消息处理的 chan，待处理的 protobuf 消息都扔到这个 chan 中，node 有一个专门的 run goroutine 处理这些消息。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/06932e15be51be922c00e09e10d7fc44.png" alt=""></p>
<h2 id="数据传递">数据传递</h2>
<p>“击鼓传花”的游戏很多人都玩过，花从一个人手中传给另外一个人，就有点类似流水线的操作。这个花就是数据，花在游戏者之间流转，这就类似编程中的数据传递。</p>
<p>还记得上节课我给你留了一道任务编排的题吗？其实它就可以用数据传递的方式实现。</p>
<blockquote>
<p>有 4 个 goroutine，编号为 1、2、3、4。每秒钟会有一个 goroutine 打印出它自己的编号，要求你编写程序，让输出的编号总是按照 1、2、3、4、1、2、3、4……这个顺序打印出来。</p>
</blockquote>
<p>为了实现顺序的数据传递，我们可以定义一个令牌的变量，谁得到令牌，谁就可以打印一次自己的编号，同时将令牌<strong>传递</strong>给下一个 goroutine，我们尝试使用 chan 来实现，可以看下下面的代码。</p>
<p>type Token struct{}</p>
<p>func newWorker(id int, ch chan Token, nextCh chan Token) {<br>
for {<br>
token := &lt;-ch         // 取得令牌<br>
fmt.Println((id + 1)) // id 从 1 开始<br>
time.Sleep(time.Second)<br>
nextCh &lt;- token<br>
}<br>
}<br>
func main() {<br>
chs := []chan Token{make(chan Token), make(chan Token), make(chan Token), make(chan Token)}</p>
<pre><code>// 创建 4 个 worker  
for i := 0; i &lt; 4; i++ {  
    go newWorker(i, chs[i], chs[(i+1)%4])  
}  

//首先把令牌交给第一个 worker  
chs[0] &lt;- struct{}{}  

select {}  
</code></pre>
<p>}</p>
<p>我来给你具体解释下这个实现方式。</p>
<p>首先，我们定义一个令牌类型（Token），接着定义一个创建 worker 的方法，这个方法会从它自己的 chan 中读取令牌。哪个 goroutine 取得了令牌，就可以打印出自己编号，因为需要每秒打印一次数据，所以，我们让它休眠 1 秒后，再把令牌交给它的下家。</p>
<p>接着，在第 16 行启动每个 worker 的 goroutine，并在第 20 行将令牌先交给第一个 worker。</p>
<p>如果你运行这个程序，就会在命令行中看到每一秒就会输出一个编号，而且编号是以 1、2、3、4 这样的顺序输出的。</p>
<p>这类场景有一个特点，就是当前持有数据的 goroutine 都有一个信箱，信箱使用 chan 实现，goroutine 只需要关注自己的信箱中的数据，处理完毕后，就把结果发送到下一家的信箱中。</p>
<h2 id="信号通知">信号通知</h2>
<p>chan 类型有这样一个特点：chan 如果为空，那么，receiver 接收数据的时候就会阻塞等待，直到 chan 被关闭或者有新的数据到来。利用这个机制，我们可以实现 wait/notify 的设计模式。</p>
<p>传统的并发原语 Cond 也能实现这个功能，但是，Cond 使用起来比较复杂，容易出错，而使用 chan 实现 wait/notify 模式就方便很多了。</p>
<p>除了正常的业务处理时的 wait/notify，我们经常碰到的一个场景，就是程序关闭的时候，我们需要在退出之前做一些清理（doCleanup 方法）的动作。这个时候，我们经常要使用 chan。</p>
<p>比如，使用 chan 实现程序的 graceful shutdown，在退出之前执行一些连接关闭、文件 close、缓存落盘等一些动作。</p>
<p>func main() {<br>
go func() {<br>
&hellip;&hellip; // 执行业务处理<br>
}()</p>
<p>// 处理 CTRL+C 等中断信号<br>
termChan := make(chan os.Signal)<br>
signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)<br>
&lt;-termChan</p>
<p>// 执行退出之前的清理动作<br>
doCleanup()</p>
<p>fmt.Println(&ldquo;优雅退出&rdquo;)<br>
}</p>
<p>有时候，doCleanup 可能是一个很耗时的操作，比如十几分钟才能完成，如果程序退出需要等待这么长时间，用户是不能接受的，所以，在实践中，我们需要设置一个最长的等待时间。只要超过了这个时间，程序就不再等待，可以直接退出。所以，退出的时候分为两个阶段：</p>
<ol>
<li>closing，代表程序退出，但是清理工作还没做；</li>
<li>closed，代表清理工作已经做完。</li>
</ol>
<p>所以，上面的例子可以改写如下：</p>
<p>func main() {<br>
var closing = make(chan struct{})<br>
var closed = make(chan struct{})</p>
<pre><code>go func() {  
    // 模拟业务处理  
    for {  
        select {  
        case &lt;-closing:  
            return  
        default:  
            // ....... 业务计算  
            time.Sleep(100 * time.Millisecond)  
        }  
    }  
}()  

// 处理 CTRL+C 等中断信号  
termChan := make(chan os.Signal)  
signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)  
&lt;-termChan  

close(closing)  
// 执行退出之前的清理动作  
go doCleanup(closed)  

select {  
case &lt;-closed:  
case &lt;-time.After(time.Second):  
    fmt.Println(&quot;清理超时，不等了&quot;)  
}  
fmt.Println(&quot;优雅退出&quot;)  
</code></pre>
<p>}</p>
<p>func doCleanup(closed chan struct{}) {<br>
time.Sleep((time.Minute))<br>
close(closed)<br>
}</p>
<h2 id="锁">锁</h2>
<p>使用 chan 也可以实现互斥锁。</p>
<p>在 chan 的内部实现中，就有一把互斥锁保护着它的所有字段。从外在表现上，chan 的发送和接收之间也存在着 happens-before 的关系，保证元素放进去之后，receiver 才能读取到（关于 happends-before 的关系，是指事件发生的先后顺序关系，我会在下一讲详细介绍，这里你只需要知道它是一种描述事件先后顺序的方法）。</p>
<p>要想使用 chan 实现互斥锁，至少有两种方式。一种方式是先初始化一个 capacity 等于 1 的 Channel，然后再放入一个元素。这个元素就代表锁，谁取得了这个元素，就相当于获取了这把锁。另一种方式是，先初始化一个 capacity 等于 1 的 Channel，它的“空槽”代表锁，谁能成功地把元素发送到这个 Channel，谁就获取了这把锁。</p>
<p>这是使用 Channel 实现锁的两种不同实现方式，我重点介绍下第一种。理解了这种实现方式，第二种方式也就很容易掌握了，我就不多说了。</p>
<p>// 使用 chan 实现互斥锁<br>
type Mutex struct {<br>
ch chan struct{}<br>
}</p>
<p>// 使用锁需要初始化<br>
func NewMutex() *Mutex {<br>
mu := &amp;Mutex{make(chan struct{}, 1)}<br>
mu.ch &lt;- struct{}{}<br>
return mu<br>
}</p>
<p>// 请求锁，直到获取到<br>
func (m *Mutex) Lock() {<br>
&lt;-m.ch<br>
}</p>
<p>// 解锁<br>
func (m *Mutex) Unlock() {<br>
select {<br>
case m.ch &lt;- struct{}{}:<br>
default:<br>
panic(&ldquo;unlock of unlocked mutex&rdquo;)<br>
}<br>
}</p>
<p>// 尝试获取锁<br>
func (m *Mutex) TryLock() bool {<br>
select {<br>
case &lt;-m.ch:<br>
return true<br>
default:<br>
}<br>
return false<br>
}</p>
<p>// 加入一个超时的设置<br>
func (m *Mutex) LockTimeout(timeout time.Duration) bool {<br>
timer := time.NewTimer(timeout)<br>
select {<br>
case &lt;-m.ch:<br>
timer.Stop()<br>
return true<br>
case &lt;-timer.C:<br>
}<br>
return false<br>
}</p>
<p>// 锁是否已被持有<br>
func (m *Mutex) IsLocked() bool {<br>
return len(m.ch) == 0<br>
}</p>
<p>func main() {<br>
m := NewMutex()<br>
ok := m.TryLock()<br>
fmt.Printf(&ldquo;locked v %v\n&rdquo;, ok)<br>
ok = m.TryLock()<br>
fmt.Printf(&ldquo;locked %v\n&rdquo;, ok)<br>
}</p>
<p>你可以用 buffer 等于 1 的 chan 实现互斥锁，在初始化这个锁的时候往 Channel 中先塞入一个元素，谁把这个元素取走，谁就获取了这把锁，把元素放回去，就是释放了锁。元素在放回到 chan 之前，不会有 goroutine 能从 chan 中取出元素的，这就保证了互斥性。</p>
<p>在这段代码中，还有一点需要我们注意下：利用 select+chan 的方式，很容易实现 TryLock、Timeout 的功能。具体来说就是，在 select 语句中，我们可以使用 default 实现 TryLock，使用一个 Timer 来实现 Timeout 的功能。</p>
<h2 id="任务编排">任务编排</h2>
<p>前面所说的消息交流的场景是一个特殊的任务编排的场景，这个“击鼓传花”的模式也被称为流水线模式。</p>
<p>在第 6 讲，我们学习了 WaitGroup，我们可以利用它实现等待模式：启动一组 goroutine 执行任务，然后等待这些任务都完成。其实，我们也可以使用 chan 实现 WaitGroup 的功能。这个比较简单，我就不举例子了，接下来我介绍几种更复杂的编排模式。</p>
<p>这里的编排既指安排 goroutine 按照指定的顺序执行，也指多个 chan 按照指定的方式组合处理的方式。goroutine 的编排类似“击鼓传花”的例子，我们通过编排数据在 chan 之间的流转，就可以控制 goroutine 的执行。接下来，我来重点介绍下多个 chan 的编排方式，总共 5 种，分别是 Or-Done 模式、扇入模式、扇出模式、Stream 和 Map-Reduce。</p>
<h3 id="or-done-模式">Or-Done 模式</h3>
<p>首先来看 Or-Done 模式。Or-Done 模式是信号通知模式中更宽泛的一种模式。这里提到了“信号通知模式”，我先来解释一下。</p>
<p>我们会使用“信号通知”实现某个任务执行完成后的通知机制，在实现时，我们为这个任务定义一个类型为 chan struct{}类型的 done 变量，等任务结束后，我们就可以 close 这个变量，然后，其它 receiver 就会收到这个通知。</p>
<p>这是有一个任务的情况，如果有多个任务，只要有任意一个任务执行完，我们就想获得这个信号，这就是 Or-Done 模式。</p>
<p>比如，你发送同一个请求到多个微服务节点，只要任意一个微服务节点返回结果，就算成功，这个时候，就可以参考下面的实现：</p>
<p>func or(channels &hellip;&lt;-chan interface{}) &lt;-chan interface{} {<br>
// 特殊情况，只有零个或者 1 个 chan<br>
switch len(channels) {<br>
case 0:<br>
return nil<br>
case 1:<br>
return channels[0]<br>
}</p>
<pre><code>orDone := make(chan interface{})  
go func() {  
    defer close(orDone)  

    switch len(channels) {  
    case 2: // 2 个也是一种特殊情况  
        select {  
        case &lt;-channels[0]:  
        case &lt;-channels[1]:  
        }  
    default: //超过两个，二分法递归处理  
        m := len(channels) / 2  
        select {  
        case &lt;-or(channels[:m]...):  
        case &lt;-or(channels[m:]...):  
        }  
    }  
}()  

return orDone  
</code></pre>
<p>}</p>
<p>我们可以写一个测试程序测试它：</p>
<p>func sig(after time.Duration) &lt;-chan interface{} {<br>
c := make(chan interface{})<br>
go func() {<br>
defer close(c)<br>
time.Sleep(after)<br>
}()<br>
return c<br>
}</p>
<p>func main() {<br>
start := time.Now()</p>
<pre><code>&lt;-or(  
    sig(10*time.Second),  
    sig(20*time.Second),  
    sig(30*time.Second),  
    sig(40*time.Second),  
    sig(50*time.Second),  
    sig(01*time.Minute),  
)  

fmt.Printf(&quot;done after %v&quot;, time.Since(start))  
</code></pre>
<p>}</p>
<p>这里的实现使用了一个巧妙的方式，<strong>当 chan 的数量大于 2 时，使用递归的方式等待信号</strong>。</p>
<p>在 chan 数量比较多的情况下，递归并不是一个很好的解决方式，根据这一讲最开始介绍的反射的方法，我们也可以实现 Or-Done 模式：</p>
<p>func or(channels &hellip;&lt;-chan interface{}) &lt;-chan interface{} {<br>
//特殊情况，只有 0 个或者 1 个<br>
switch len(channels) {<br>
case 0:<br>
return nil<br>
case 1:<br>
return channels[0]<br>
}</p>
<pre><code>orDone := make(chan interface{})  
go func() {  
    defer close(orDone)  
    // 利用反射构建 SelectCase  
    var cases []reflect.SelectCase  
    for _, c := range channels {  
        cases = append(cases, reflect.SelectCase{  
            Dir:  reflect.SelectRecv,  
            Chan: reflect.ValueOf(c),  
        })  
    }  

    // 随机选择一个可用的 case  
    reflect.Select(cases)  
}()  


return orDone  
</code></pre>
<p>}</p>
<p>这是递归和反射两种方法实现 Or-Done 模式的代码。反射方式避免了深层递归的情况，可以处理有大量 chan 的情况。其实最笨的一种方法就是为每一个 Channel 启动一个 goroutine，不过这会启动非常多的 goroutine，太多的 goroutine 会影响性能，所以不太常用。你只要知道这种用法就行了，不用重点掌握。</p>
<h3 id="扇入模式">扇入模式</h3>
<p>扇入借鉴了数字电路的概念，它定义了单个逻辑门能够接受的数字信号输入最大量的术语。一个逻辑门可以有多个输入，一个输出。</p>
<p>在软件工程中，模块的扇入是指有多少个上级模块调用它。而对于我们这里的 Channel 扇入模式来说，就是指有多个源 Channel 输入、一个目的 Channel 输出的情况。扇入比就是源 Channel 数量比 1。</p>
<p>每个源 Channel 的元素都会发送给目标 Channel，相当于目标 Channel 的 receiver 只需要监听目标 Channel，就可以接收所有发送给源 Channel 的数据。</p>
<p>扇入模式也可以使用反射、递归，或者是用最笨的每个 goroutine 处理一个 Channel 的方式来实现。</p>
<p>这里我列举下递归和反射的方式，帮你加深一下对这个技巧的理解。</p>
<p>反射的代码比较简短，易于理解，主要就是构造出 SelectCase slice，然后传递给 reflect.Select 语句。</p>
<p>func fanInReflect(chans &hellip;&lt;-chan interface{}) &lt;-chan interface{} {<br>
out := make(chan interface{})<br>
go func() {<br>
defer close(out)<br>
// 构造 SelectCase slice<br>
var cases []reflect.SelectCase<br>
for _, c := range chans {<br>
cases = append(cases, reflect.SelectCase{<br>
Dir:  reflect.SelectRecv,<br>
Chan: reflect.ValueOf(c),<br>
})<br>
}</p>
<pre><code>    // 循环，从 cases 中选择一个可用的  
    for len(cases) &gt; 0 {  
        i, v, ok := reflect.Select(cases)  
        if !ok { // 此 channel 已经 close  
            cases = append(cases[:i], cases[i+1:]...)  
            continue  
        }  
        out &lt;- v.Interface()  
    }  
}()  
return out  
</code></pre>
<p>}</p>
<p>递归模式也是在 Channel 大于 2 时，采用二分法递归 merge。</p>
<p>func fanInRec(chans &hellip;&lt;-chan interface{}) &lt;-chan interface{} {<br>
switch len(chans) {<br>
case 0:<br>
c := make(chan interface{})<br>
close(c)<br>
return c<br>
case 1:<br>
return chans[0]<br>
case 2:<br>
return mergeTwo(chans[0], chans[1])<br>
default:<br>
m := len(chans) / 2<br>
return mergeTwo(<br>
fanInRec(chans[:m]&hellip;),<br>
fanInRec(chans[m:]&hellip;))<br>
}<br>
}</p>
<p>这里有一个 mergeTwo 的方法，是将两个 Channel 合并成一个 Channel，是扇入形式的一种特例（只处理两个 Channel）。下面我来借助一段代码帮你理解下这个方法。</p>
<p>func mergeTwo(a, b &lt;-chan interface{}) &lt;-chan interface{} {<br>
c := make(chan interface{})<br>
go func() {<br>
defer close(c)<br>
for a != nil || b != nil { //只要还有可读的 chan<br>
select {<br>
case v, ok := &lt;-a:<br>
if !ok { // a 已关闭，设置为 nil<br>
a = nil<br>
continue<br>
}<br>
c &lt;- v<br>
case v, ok := &lt;-b:<br>
if !ok { // b 已关闭，设置为 nil<br>
b = nil<br>
continue<br>
}<br>
c &lt;- v<br>
}<br>
}<br>
}()<br>
return c<br>
}</p>
<h3 id="扇出模式">扇出模式</h3>
<p>有扇入模式，就有扇出模式，扇出模式是和扇入模式相反的。</p>
<p>扇出模式只有一个输入源 Channel，有多个目标 Channel，扇出比就是 1 比目标 Channel 数的值，经常用在设计模式中的观察者模式中（观察者设计模式定义了对象间的一种一对多的组合关系。这样一来，一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动刷新）。在观察者模式中，数据变动后，多个观察者都会收到这个变更信号。</p>
<p>下面是一个扇出模式的实现。从源 Channel 取出一个数据后，依次发送给目标 Channel。在发送给目标 Channel 的时候，可以同步发送，也可以异步发送：</p>
<p>func fanOut(ch &lt;-chan interface{}, out []chan interface{}, async bool) {<br>
go func() {<br>
defer func() { //退出时关闭所有的输出 chan<br>
for i := 0; i &lt; len(out); i++ {<br>
close(out[i])<br>
}<br>
}()</p>
<pre><code>    for v := range ch { // 从输入 chan 中读取数据  
        v := v  
        for i := 0; i &lt; len(out); i++ {  
            i := i  
            if async { //异步  
                go func() {  
                    out[i] &lt;- v // 放入到输出 chan 中，异步方式  
                }()  
            } else {  
                out[i] &lt;- v // 放入到输出 chan 中，同步方式  
            }  
        }  
    }  
}()  
</code></pre>
<p>}</p>
<p>你也可以尝试使用反射的方式来实现，我就不列相关代码了，希望你课后可以自己思考下。</p>
<h3 id="stream">Stream</h3>
<p>这里我来介绍一种把 Channel 当作流式管道使用的方式，也就是把 Channel 看作流（Stream），提供跳过几个元素，或者是只取其中的几个元素等方法。</p>
<p>首先，我们提供创建流的方法。这个方法把一个数据 slice 转换成流：</p>
<p>func asStream(done &lt;-chan struct{}, values &hellip;interface{}) &lt;-chan interface{} {<br>
s := make(chan interface{}) //创建一个 unbuffered 的 channel<br>
go func() { // 启动一个 goroutine，往 s 中塞数据<br>
defer close(s) // 退出时关闭 chan<br>
for _, v := range values { // 遍历数组<br>
select {<br>
case &lt;-done:<br>
return<br>
case s &lt;- v: // 将数组元素塞入到 chan 中<br>
}<br>
}<br>
}()<br>
return s<br>
}</p>
<p>流创建好以后，该咋处理呢？下面我再给你介绍下实现流的方法。</p>
<ol>
<li>takeN：只取流中的前 n 个数据；</li>
<li>takeFn：筛选流中的数据，只保留满足条件的数据；</li>
<li>takeWhile：只取前面满足条件的数据，一旦不满足条件，就不再取；</li>
<li>skipN：跳过流中前几个数据；</li>
<li>skipFn：跳过满足条件的数据；</li>
<li>skipWhile：跳过前面满足条件的数据，一旦不满足条件，当前这个元素和以后的元素都会输出给 Channel 的 receiver。</li>
</ol>
<p>这些方法的实现很类似，我们以 takeN 为例来具体解释一下。</p>
<p>func takeN(done &lt;-chan struct{}, valueStream &lt;-chan interface{}, num int) &lt;-chan interface{} {<br>
takeStream := make(chan interface{}) // 创建输出流<br>
go func() {<br>
defer close(takeStream)<br>
for i := 0; i &lt; num; i++ { // 只读取前 num 个元素<br>
select {<br>
case &lt;-done:<br>
return<br>
case takeStream &lt;- &lt;-valueStream: //从输入流中读取元素<br>
}<br>
}<br>
}()<br>
return takeStream<br>
}</p>
<h3 id="map-reduce">Map-Reduce</h3>
<p>map-reduce 是一种处理数据的方式，最早是由 Google 公司研究提出的一种面向大规模数据处理的并行计算模型和方法，开源的版本是 hadoop，前几年比较火。</p>
<p>不过，我要讲的并不是分布式的 map-reduce，而是单机单进程的 map-reduce 方法。</p>
<p>map-reduce 分为两个步骤，第一步是映射（map），处理队列中的数据，第二步是规约（reduce），把列表中的每一个元素按照一定的处理方式处理成结果，放入到结果队列中。</p>
<p>就像做汉堡一样，map 就是单独处理每一种食材，reduce 就是从每一份食材中取一部分，做成一个汉堡。</p>
<p>我们先来看下 map 函数的处理逻辑:</p>
<p>func mapChan(in &lt;-chan interface{}, fn func(interface{}) interface{}) &lt;-chan interface{} {<br>
out := make(chan interface{}) //创建一个输出 chan<br>
if in == nil { // 异常检查<br>
close(out)<br>
return out<br>
}</p>
<pre><code>go func() { // 启动一个 goroutine，实现 map 的主要逻辑  
    defer close(out)  
    for v := range in { // 从输入 chan 读取数据，执行业务操作，也就是 map 操作  
        out &lt;- fn(v)  
    }  
}()  

return out  
</code></pre>
<p>}</p>
<p>reduce 函数的处理逻辑如下：</p>
<p>func reduce(in &lt;-chan interface{}, fn func(r, v interface{}) interface{}) interface{} {<br>
if in == nil { // 异常检查<br>
return nil<br>
}</p>
<pre><code>out := &lt;-in // 先读取第一个元素  
for v := range in { // 实现 reduce 的主要逻辑  
    out = fn(out, v)  
}  

return out  
</code></pre>
<p>}</p>
<p>我们可以写一个程序，这个程序使用 map-reduce 模式处理一组整数，map 函数就是为每个整数乘以 10，reduce 函数就是把 map 处理的结果累加起来：</p>
<p>// 生成一个数据流<br>
func asStream(done &lt;-chan struct{}) &lt;-chan interface{} {<br>
s := make(chan interface{})<br>
values := []int{1, 2, 3, 4, 5}<br>
go func() {<br>
defer close(s)<br>
for _, v := range values { // 从数组生成<br>
select {<br>
case &lt;-done:<br>
return<br>
case s &lt;- v:<br>
}<br>
}<br>
}()<br>
return s<br>
}</p>
<p>func main() {<br>
in := asStream(nil)</p>
<pre><code>// map 操作：乘以 10  
mapFn := func(v interface{}) interface{} {  
    return v.(int) * 10  
}  

// reduce 操作：对 map 的结果进行累加  
reduceFn := func(r, v interface{}) interface{} {  
    return r.(int) + v.(int)  
}  

sum := reduce(mapChan(in, mapFn), reduceFn) //返回累加结果  
fmt.Println(sum)  
</code></pre>
<p>}</p>
<h1 id="总结">总结</h1>
<p>这节课，我借助代码示例，带你学习了 Channel 的应用场景和应用模式。这几种模式不是我们学习的终点，而是学习的起点。掌握了这几种模式之后，我们可以延伸出更多的模式。</p>
<p>虽然 Channel 最初是基于 CSP 设计的用于 goroutine 之间的消息传递的一种数据类型，但是，除了消息传递这个功能之外，大家居然还演化出了各式各样的应用模式。我不确定 Go 的创始人在设计这个类型的时候，有没有想到这一点，但是，我确实被各位大牛利用 Channel 的各种点子折服了，比如有人实现了一个基于 TCP 网络的分布式的 Channel。</p>
<p>在使用 Go 开发程序的时候，你也不妨多考虑考虑是否能够使用 chan 类型，看看你是不是也能创造出别具一格的应用模式。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/f1bf2e33add2f016d0ba6ae84c31e859.png" alt=""></p>
<h1 id="思考题">思考题</h1>
<p>想一想，我们在利用 chan 实现互斥锁的时候，如果 buffer 设置的不是 1，而是一个更大的值，会出现什么状况吗？能解决什么问题吗？</p>
<p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/">Go并发编程实战课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0%E4%B8%9A%E5%8A%A1%E5%BB%BA%E6%A8%A1/14__8x_flow%E4%B8%8A%E4%BD%95%E4%B8%BA%E4%B8%9A%E5%8A%A1%E4%BD%95%E4%B8%BA%E9%A2%86%E5%9F%9F/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">14__8X_Flow（上）：何为业务？何为领域？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kafka%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/14__controller%E9%80%89%E4%B8%BE%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/">
            <span class="next-text nav-default">14__Controller选举是怎么实现的？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
