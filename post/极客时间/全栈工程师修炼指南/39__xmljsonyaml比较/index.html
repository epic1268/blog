<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>39__XML、JSON、YAML比较 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是四火。
XML 和 JSON，是程序员几乎每天都会打交道的数据、特别是配置数据的承载格式。我想你心里应该有一个大致的印象，它们二者各有什么优劣，但是也许没有系统地比较过。那今天我们就把它们放到一起，丁是丁卯是卯地分析分析，对比一下它们各自的特点。另外，这些年来，对于配置，特别是复杂 DSL 的配置，YAML 也逐渐流行开来，因此我们也把它拿过来剖析一番。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/39__xmljsonyaml%E6%AF%94%E8%BE%83/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/39__xmljsonyaml%E6%AF%94%E8%BE%83/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="39__XML、JSON、YAML比较">
  <meta property="og:description" content="你好，我是四火。
XML 和 JSON，是程序员几乎每天都会打交道的数据、特别是配置数据的承载格式。我想你心里应该有一个大致的印象，它们二者各有什么优劣，但是也许没有系统地比较过。那今天我们就把它们放到一起，丁是丁卯是卯地分析分析，对比一下它们各自的特点。另外，这些年来，对于配置，特别是复杂 DSL 的配置，YAML 也逐渐流行开来，因此我们也把它拿过来剖析一番。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="全栈工程师修炼指南">

  <meta itemprop="name" content="39__XML、JSON、YAML比较">
  <meta itemprop="description" content="你好，我是四火。
XML 和 JSON，是程序员几乎每天都会打交道的数据、特别是配置数据的承载格式。我想你心里应该有一个大致的印象，它们二者各有什么优劣，但是也许没有系统地比较过。那今天我们就把它们放到一起，丁是丁卯是卯地分析分析，对比一下它们各自的特点。另外，这些年来，对于配置，特别是复杂 DSL 的配置，YAML 也逐渐流行开来，因此我们也把它拿过来剖析一番。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4231">
  <meta itemprop="keywords" content="全栈工程师修炼指南">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="39__XML、JSON、YAML比较">
  <meta name="twitter:description" content="你好，我是四火。
XML 和 JSON，是程序员几乎每天都会打交道的数据、特别是配置数据的承载格式。我想你心里应该有一个大致的印象，它们二者各有什么优劣，但是也许没有系统地比较过。那今天我们就把它们放到一起，丁是丁卯是卯地分析分析，对比一下它们各自的特点。另外，这些年来，对于配置，特别是复杂 DSL 的配置，YAML 也逐渐流行开来，因此我们也把它拿过来剖析一番。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">39__XML、JSON、YAML比较</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4231 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#xml-和-json-的比较">XML 和 JSON 的比较</a>
          <ul>
            <li><a href="#1-简洁还是严谨">1. 简洁还是严谨</a></li>
            <li><a href="#2-javascript-一家亲">2. JavaScript 一家亲</a></li>
            <li><a href="#3-路径表达式">3. 路径表达式</a></li>
            <li><a href="#4-特殊字符">4. 特殊字符</a></li>
          </ul>
        </li>
        <li><a href="#审视一番-yaml">审视一番 YAML</a></li>
        <li><a href="#city">cities:<br>
city:</a></li>
        <li><a href="#id-1">name: Beijing<br>
id: 1</a></li>
        <li><a href="#总结思考">总结思考</a></li>
        <li><a href="#扩展阅读">扩展阅读</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是四火。</p>
<p>XML 和 JSON，是程序员几乎每天都会打交道的数据、特别是配置数据的承载格式。我想你心里应该有一个大致的印象，它们二者各有什么优劣，但是也许没有系统地比较过。那今天我们就把它们放到一起，丁是丁卯是卯地分析分析，对比一下它们各自的特点。另外，这些年来，对于配置，特别是复杂 DSL 的配置，YAML 也逐渐流行开来，因此我们也把它拿过来剖析一番。</p>
<h2 id="xml-和-json-的比较">XML 和 JSON 的比较</h2>
<p>XML 全称叫做 Extensible Markup Language，就像 HTML、CSS 一样，是一种标记语言（标记语言不属于传统意义上的编程语言），且是一种具备结构化特征的数据交换语言；类似地，JSON，也就是 JavaScript Object Notation，被称作 JavaScript 对象表示法，非结构化，更轻量，但归根结底也是一种数据交换语言。因此，二者具备相当程度的相似性，在实际应用中，往往也可以比较和替代。</p>
<h3 id="1-简洁还是严谨">1. 简洁还是严谨</h3>
<p>在 [第 04 讲] 的时候，我介绍了 REST 和 SOAP 这样一个简洁、一个严谨的俩兄弟。而在本讲中，JSON 和 XML 也在一定程度上同样满足这样的比较关系，JSON 往往是更为简洁、快速的那一个，而 XML 则更为严谨、周全。</p>
<p>我们来看一个简单的例子，id 为 1 的城市北京：</p>
<city>  
  <name>Beijing</name>  
  <id>1<id>  
</city>
<p>如果用 JSON 表示：</p>
<p>{<br>
&ldquo;city&rdquo;: {<br>
&ldquo;name&rdquo;: &ldquo;Beijing&rdquo;,<br>
&ldquo;id&rdquo;: 1<br>
}<br>
}</p>
<p>你可能会说，除了 XML tag 的名字，在 JSON 中只需要写一遍以外，看起来复杂复杂、严谨的程度似乎也差不太多啊。</p>
<p>别急，往下看。XML 的结构，强制要求每一个内容数据，都必须具备能够说明它的结构，而 JSON 则没有这样的要求。比方说，如果我们把城市组成数组，用 XML 来表示，请你把这个文件存成 cities.xml，因为我们会多次用到这个文件：</p>
<cities>  
  <city>  
    <name>Beijing</name>  
    <id>1</id>  
  </city>  
  <city>  
    <name>Shanghai</name>  
    <id>2</id>  
  </city>  
</cities>
<p>如果使用 JSON 的话，由于对于数组可以使用中括号直接支持，而不需要显式写出上例中的 city 这个 tag 的名称，请你同样建立 cities.json：</p>
<p>{<br>
&ldquo;cities&rdquo;: [<br>
{&ldquo;name&rdquo;: &ldquo;Beijing&rdquo;, &ldquo;id&rdquo;: 1},<br>
{&ldquo;name&rdquo;: &ldquo;Shanghai&rdquo;, &ldquo;id&rdquo;: 2}<br>
]<br>
}</p>
<p>从这就可以看出，在这种情况下，JSON 似乎确实要更为简洁一些。上例中 JSON 能够使用中括号直接表示数组，能够直接支持数值、字符串和布尔型的表示。</p>
<p>等等，这样说的话，JSON 因为能够直接支持数值的表示，这个 id 没有双引号修饰，就是数值类型，可是从 XML 中并不能看出这一点啊。因此，从这个角度说，应该是 JSON 更严谨啊！那为什么说 XML 更严谨，严谨在哪呢？</p>
<p>有些程序员朋友可能会马上想到，XML 是可以定义 tag 属性的，预定义一个 type 不就好了？</p>
<city>  
  <name type="String">Beijing</name>  
  <id type="number">1<id>  
</city>
<p>看起来也能达到“严谨”的目的，可这很可能就是一个不好的实践了，因为 XML 对于这些常见的数据类型，内置了直接的支持。我们可以通过定义 XML Schema Definition（XSD）来对 XML 的结构做出明确的要求，也就是说，我们不必自己去造轮子，来定义并实现这个 type 属性。针对上面的 cities.xml，我们可以定义这样的 XSD：</p>
<p>&lt;xs:schema xmlns:xs=&ldquo;<a href="http://www.w3.org/2001/XMLSchema%22%3E">http://www.w3.org/2001/XMLSchema&quot;&gt;</a><br>
&lt;xs:element name=&ldquo;cities&rdquo;&gt;<br>
<a href="xs:complexType">xs:complexType</a><br>
<a href="xs:sequence">xs:sequence</a><br>
&lt;xs:element name=&ldquo;city&rdquo; maxOccurs=&ldquo;unbounded&rdquo; minOccurs=&ldquo;0&rdquo;&gt;<br>
<a href="xs:complexType">xs:complexType</a><br>
<a href="xs:sequence">xs:sequence</a><br>
&lt;xs:element type=&ldquo;xs:string&rdquo; name=&ldquo;name&rdquo;/&gt;<br>
&lt;xs:element type=&ldquo;xs:byte&rdquo; name=&ldquo;id&rdquo;/&gt;<br>
&lt;/xs:sequence&gt;<br>
&lt;/xs:complexType&gt;<br>
&lt;/xs:element&gt;<br>
&lt;/xs:sequence&gt;<br>
&lt;/xs:complexType&gt;<br>
&lt;/xs:element&gt;<br>
&lt;/xs:schema&gt;</p>
<p>这样一来，我们就对 cities 和 city 这两个 tag 做了严格的内容限定，包括包含的子节点有哪些，顺序如何，取值类型是什么等等。在实际的 XML 定义中，我们可以引用这个 XSD，这样 XML 的处理程序就会加载这个 XSD 并根据 schema 的规则对 XML 进行校验，从而发现 XML 不合要求的问题。</p>
<p>进一步地，你可以自己动动手，看一下这个工具，它可以帮助你通过 XML 快速生成样例 XSD；而这个工具则可以帮你快速验证 XML 是不是满足某 XSD 的要求，它们都很有用。</p>
<p>补充一下，你可能也听说过，或使用过类似的叫做 DTD，也就是 Document Type Definition 的方式，能想到这个很好，但是 XSD 相对来说有着更大的优势，并成为了 W3C 的标准。因此我在这里不提 DTD，但是我在扩展阅读中放了关于 XSD 和 DTD 的比较材料，供感兴趣的朋友拓展。</p>
<p>我想，从 XSD 你应该可以体会到 XML 的严谨性了。那喜爱使用 JSON 的程序员，就不能创造一个类似的东西，来填补这个坑——即定义和保证 JSON 的严谨性吗？</p>
<p>有，它就是 JSON Schema，也许你已经在项目中使用了，但是还没有统一成标准，也没有被足够广泛地接纳，因此我就不展开来说了。你可以自己实践一下，把上面提到的 JSON 填写到这个 JSON Schema 推断工具上面，去看看生成的 JSON Schema 样例。</p>
<h3 id="2-javascript-一家亲">2. JavaScript 一家亲</h3>
<p>对于全栈工程师来说，和 XML 比较起来，JSON 对于前端开发来说，可以说有着不可比拟的亲和力。本来，JSON 就是 JavaScript 对象表示法，就是从 JavaScript 这个源头发展而来的，当然，JSON 如今是不依赖于任何编程语言的。这个“一家亲”，首先表现在，JSON 和 JavaScript 对象之间的互相转化，可以说是轻而易举的。</p>
<p>我们来动动手实践一下，打开 Chrome 的开发者工具，切换到 Console 页，打开前面建立的 cities.json，拷贝其中的内容到一对反引号（backtick，就是键盘上 esc 下面的那个按键）中，并赋给变量 text：</p>
<p>var text = <code>JSON 字符串</code>;</p>
<p>我们很轻松地就可以把它转化为 JavaScript 对象（反序列化），不需要任何第三方的 parser：</p>
<p>var obj = JSON.parse(text);</p>
<p>在早些时候的 ES 版本中，这个方法不支持，那么还可以使用 eval 大法，效果是一样的：</p>
<p>var obj = eval(&rsquo;(&rsquo; + text + &lsquo;)&rsquo;);</p>
<p>不过，在现代浏览器中，如果 text 不是绝对安全的，就不要使用这样的方法，因为 eval 可以执行任何恶意代码。</p>
<p>当然，我们也可以把 JavaScript 对象转换回（序列化）JSON 文本：</p>
<p>var serializedText = JSON.stringify(obj);</p>
<p>完成以后，先不要关闭控制台，下面还会用到。</p>
<h3 id="3-路径表达式">3. 路径表达式</h3>
<p>对于一段巨大的 XML 或 JSON 文本，我们经常需要找出其中特定的一个或多个节点（tag）、内容（content）或者属性，二者都有相似的方法。</p>
<p>对于 XML 来说，它就是 XPath，也是 W3C 的标准。现在我们来动手操作一下吧：</p>
<p>我们可以利用 Xpath Generator 来直观地生成相应的 XPath。让我们打开这个工具，找到我们刚才保存下来的 cities.xml 文件，拷贝里面的内容，粘贴到页面上。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/25377f91d49de83afa38b700986d4edd.png" alt=""></p>
<p>接着，点击第一个 id 标签，你将看到这样的 XPath：</p>
<p>/cities/city[1]/id</p>
<p>这就唯一确定了 XML 中，cities 这个节点下，city 节点中的第一个，它下面的 id 节点。</p>
<p>我们再来试一试，点击 Shanghai 这个 content，你将看到：</p>
<p>/cities/city[2]/name/text()</p>
<p>对于 JSON 来说，也有 JSONPath 这样的东西，但是，我们却很少提及它，因为正如上文我提到的，它和 JavaScript 极强的亲和力。我们在前端代码中已经不自觉地通过对象的点操作符，或是数组的下标操作符使用了，于是，JSONPath 在多数场景中就显得不那么重要了。</p>
<p>举例来说，上面我给出的两个 XPath 例子，我们在将 cities.json 反序列化成 JavaScript 对象以后，我们可以直接访问（你可以在前面实践的控制台上，继续键入）：</p>
<p>obj.cities[0].id</p>
<p>以及：</p>
<p>obj[&lsquo;cities&rsquo;][1].name</p>
<p>但是，还有很多场景，特别是对于 JSON 支持不像 JavaScript 那么足够的场景，JSONPath 就有其用武之地了。和前面介绍的 XPath 查找的例子一样，你可以打开 JSON Path Finder 页面，把之前 cities.json 的文本粘贴到左侧的输入框中，在右侧选择对应的节点或值，上方就会显示出 JSONPath 了：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/4b935e15bba0e1e6e7ec91ac9e834578.png" alt=""></p>
<p>所以，Beijing 的 id 和 Shanghai 的 name 分别显示为：</p>
<p>x.cities[0].id<br>
x.cities[1].name</p>
<p>这和 JavaScript 对象访问的表达式是一致的。</p>
<h3 id="4-特殊字符">4. 特殊字符</h3>
<p>任何格式都要使用特定的字符来表示结构和关系，那么 XML 和 JSON 也不例外，这些特定字符，如果被用来表示实际内容，就会出现“冲突”，于是我们就需要转义。</p>
<p>对于 XML 来说，且看下面的表格，第三列是“预定义实体”，也就是字符转义后相应的形式：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/7bb9dc2ba3e8f6735f850cb425b15be2.png" alt=""></p>
<p>值得一提的是，在 XML 中，我们还能够以 CDATA 来表示内容，这种方式可以尽可能地避免对于转义的使用，并可以直接使用换行等控制字符，增加 XML 的可读性。比方说下面这个例子，实际的 function 使用 CDATA 的方式给嵌在了 function 这个 tag 内：</p>
<p><function><![CDATA[  
function compare(a, b) {  
...  
}  
]]></function></p>
<p>对于 JSON 来说，没有这样的预定义实体，但是我们也经常需要转义，比如说，如果双引号出现在了一对双引号内的字符串中，这时候我们可以用常规的反斜杠转义序列来表示，比如引号“转义为 \”等。</p>
<h2 id="审视一番-yaml">审视一番 YAML</h2>
<p>最后来讲一讲 YAML，这是一种可读性非常优秀的数据交换语言。如果你使用过 Python，那么对于其“有意义”的缩进应该印象深刻，而 YAML，也具备这样的特点。你可以打开 XML to YAML Converter 这个网站，然后将前面我们创建的 cities.xml 的内容拷贝出来，贴到左侧的输入框中：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/5db8aa47b4bee7a5314c98fa6cdea3e3.png" alt=""></p>
<p>然后点击 XML TO YAML 按钮，你就能看到前面的例子，如果使用 YAML 来表示，它会是这么个样子：</p>
<h2 id="city">cities:<br>
city:</h2>
<h2 id="id-1">name: Beijing<br>
id: 1</h2>
<p>name: Shanghai<br>
id: 2</p>
<p>你看，这种方式对于层次结构的表达，可以说比 XML 或 JSON 更为清晰。对于 XML 和 JSON 的表达，对于每一层节点，你都要去找结尾标记，并和节点开头标记对应起来看；但是 YAML 则完全不用，它利用了人阅读的时候，一行一行往下顺序进行的特性，利用直观的缩进块来表达一个特定深度的节点。对于某些强调层次结构的特定信息表达的场景，比如说电子邮件消息，或者是商品信息、候选人的简历等等，使用 YAML 比其它的数据交换格式都要直接和清晰。</p>
<p>值得注意的是，对于缩进，YAML 要求不可以使用 TAB，只能使用空格，这和 Python 是不同的；而对于每层缩进多少个空格，这不重要，只要保证不同层次的缩进空格数量不同即可，这一点和 Python 是相同的。</p>
<p>**YAML 由于极强的可读性，它在数据类型的明确性上做了一定程度的牺牲。**从上面的例子你可以发现，本来我们希望 name 是字符串，id 是数值，可是 YAML 它根本不关心这一点，如你所见，字符串也没有双引号修饰，它只是诚实地把具体的文本数值罗列展示出来罢了。这一点，在我们权衡不同的数据交换格式的时候（比如设计哪一种格式作为我们的模块配置项文件），需要注意。</p>
<h2 id="总结思考">总结思考</h2>
<p>今天我们一边动手比较、一边学习了 XML 和 JSON 的前前后后，包括它们的风格、schema 和路径表达式等等，并在之后了解了可读性至上的另一种数据交换语言 YAML。希望这些内容能够帮助你对于这些数据交换语言有更为全面的认识，并能够在工作中选择合适的技术来解决实际问题。</p>
<p>今天的提问环节，我想换个形式。这一讲我们已经比较了许多 XML 和 JSON 的特性了，其中一些涉及到了它们之间的优劣。那么，你能不能归纳出 XML 和 JSON 各自的一些优劣来呢？比如有这样几个方面供你参考，当然，你完全可以谈其它方面：</p>
<ol>
<li>报文大小；</li>
<li>数据类型的表达能力；</li>
<li>Schema 的支持；</li>
<li>可读性；</li>
<li>数据校验的支持性；</li>
<li>序列化和反序列化（编程访问）的难易程度；</li>
<li>程序处理的性能；</li>
<li>Web 中的普适性；</li>
<li>可扩展性（自定义 DSL 的能力）；</li>
<li>……</li>
</ol>
<h2 id="扩展阅读">扩展阅读</h2>
<ol>
<li>关于 DTD，你可以在这里找到许多例子；而 XSD，它的例子则在这里。而且，在 XML Schema 与 XML DTD 的技术比较与分析这篇文章里，你可以得知为什么 W3C 最后选择了 XSD，而不是 DTD。另外，对于 XSD 的批评，你可以参看这里。</li>
<li>对于 XPath，如果想全面地了解它的语法，请参阅 XPath 词条；如果你想检验所学，校验自己书写的 XPath 的正确性，那么你可以使用这个工具，这个工具和文中介绍的 Xpath Generator 配合起来使用，可以非常有效地帮助你理解 XPath。</li>
<li>相应的，对于 JSONPath，你可以阅读这篇文章来进一步了解它的语法，你也可以使用这个工具来校验其正确性。</li>
<li>对于 YAML，你可以阅读这个词条来获得较为全面的了解；另外，你可能听说过 YAML 和 JSON 之间的超集与子集这样的关系，那我推荐你阅读 YAML 官方文档的这一小段关于它与 JSON 的区别和联系。</li>
<li>文中介绍了数据交换语言这个大家族中的三个，其实还有其它成员，你可以阅读一下这个列表。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/416e86252686994524facb7ae49b76eb.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/">全栈工程师修炼指南</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/39__redis_6.0%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E4%B8%8E%E5%AE%89%E5%85%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">39__Redis_6.0的新特性：多线程、客户端缓存与安全</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/39__%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%BA%8C%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6netty/">
            <span class="next-text nav-default">39__案例分析（二）：高性能网络应用框架Netty</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
