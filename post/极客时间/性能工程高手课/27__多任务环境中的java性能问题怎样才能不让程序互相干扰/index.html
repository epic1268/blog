<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>27__多任务环境中的Java性能问题，怎样才能不让程序互相干扰？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是庄振运。
我们来继续学习生产实践中的案例。在生产实践中，为了降低公司运营成本，更好地利用系统容量，并提高资源使用率，我们经常会让多个应用程序，同时运行在同一台服务器上。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/27__%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E4%B8%8D%E8%AE%A9%E7%A8%8B%E5%BA%8F%E4%BA%92%E7%9B%B8%E5%B9%B2%E6%89%B0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/27__%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E4%B8%8D%E8%AE%A9%E7%A8%8B%E5%BA%8F%E4%BA%92%E7%9B%B8%E5%B9%B2%E6%89%B0/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="27__多任务环境中的Java性能问题，怎样才能不让程序互相干扰？">
  <meta property="og:description" content="你好，我是庄振运。
我们来继续学习生产实践中的案例。在生产实践中，为了降低公司运营成本，更好地利用系统容量，并提高资源使用率，我们经常会让多个应用程序，同时运行在同一台服务器上。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="性能工程高手课">

  <meta itemprop="name" content="27__多任务环境中的Java性能问题，怎样才能不让程序互相干扰？">
  <meta itemprop="description" content="你好，我是庄振运。
我们来继续学习生产实践中的案例。在生产实践中，为了降低公司运营成本，更好地利用系统容量，并提高资源使用率，我们经常会让多个应用程序，同时运行在同一台服务器上。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5637">
  <meta itemprop="keywords" content="性能工程高手课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="27__多任务环境中的Java性能问题，怎样才能不让程序互相干扰？">
  <meta name="twitter:description" content="你好，我是庄振运。
我们来继续学习生产实践中的案例。在生产实践中，为了降低公司运营成本，更好地利用系统容量，并提高资源使用率，我们经常会让多个应用程序，同时运行在同一台服务器上。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">27__多任务环境中的Java性能问题，怎样才能不让程序互相干扰？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5637 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#怎样理解多程序互相干扰">怎样理解多程序互相干扰？</a></li>
        <li><a href="#应用程序启动时为什么会被其他程序干扰">应用程序启动时为什么会被其他程序干扰？</a></li>
        <li><a href="#运行中的应用程序为什么会被别的程序干扰">运行中的应用程序为什么会被别的程序干扰？</a></li>
        <li><a href="#如何解决多程序互相干扰">如何解决多程序互相干扰？</a></li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是庄振运。</p>
<p>我们来继续学习生产实践中的案例。在生产实践中，为了降低公司运营成本，更好地利用系统容量，并提高资源使用率，我们经常会让多个应用程序，同时运行在同一台服务器上。</p>
<p>但是，万事有利就有弊。这几个共存的应用程序，有可能会互相影响；有时还会导致严重的性能问题。我就遇到过，几个程序同时运行，最后导致吞吐量急剧下降的情况。</p>
<p>所以，今天我们就来探讨，当多个 Java 应用程序共存在一个 Linux 系统上的时候，会产生哪些性能问题？我们又该怎么解决这些问题？</p>
<h2 id="怎样理解多程序互相干扰">怎样理解多程序互相干扰？</h2>
<p>为了更好地理解后面的性能问题，你需要先了解一下应用程序内存管理机制的背景知识。我们运行的是 Java 程序，所以先快速复习一下 <strong>Java 的 JVM 内存管理机制</strong>。</p>
<p>Java 程序在 Java 虚拟机 JVM 中运行，JVM 使用的内存区域称为<strong>堆</strong>。JVM 堆用于支持动态 Java 对象的分配，并且分为几个区域，称为“代”（例如新生代和老年代）。Java 对象首先在新生代中分配；当这些对象不再被需要时，它们会被称为 GC（Garbage Collection）的垃圾回收机制收集。发生 GC 时，JVM 会从根对象开始，一个个地检查所有对象的引用计数。如果对象的引用计数降为零，那就删除这个对象，并回收使用这个对象相应的存储空间。</p>
<p>GC 运行的某些阶段，会导致应用程序停止响应其他请求，这种行为，通常称为 STW（Stop The Word 暂停）。JVM 调优的重要目标之一，就是最大程度地减少 GC 暂停的持续时间。</p>
<p>复习完 JVM 内存管理机制，我们还要看一下与它相关的 <strong>Linux 的内存管理机制</strong>。</p>
<p>在 Linux 操作系统上，虚拟内存空间基本上是固定大小（例如 4KB）的页面。Linux 近年来有很多内存管理的优化，来提高内存使用效率和运行进程的性能。</p>
<p>Linux 内存管理有一个<strong>页面回收</strong>的机制。它在内部维护一个空闲页面（Free Page）列表，来满足未来应用程序的内存请求。当空闲页面的数量下降到一定水平时，操作系统就开始回收页面，并将新回收的页面添加到空闲列表中。</p>
<p>执行页面回收时，操作系统需要进行页面扫描（Page Scanning），以检查已经分配页面的活动性。Linux 有两个策略来进行页面扫描：<strong>后台扫描</strong>（由 kswapd 守护程序执行）和<strong>前台扫描</strong>（由进程自己执行）。</p>
<p>通常情况下，后台扫描就够了，应用程序的性能一般不会受到影响。但是当操作系统的内存使用非常大，空闲页面严重不足时，Linux 就会启动前台页面回收，也被称为<strong>直接回收或同步回收</strong>。在前台页面回收过程中，应用程序会停止运行，因此对应用程序影响很大。</p>
<p>Linux 还有一个<strong>页面交换</strong>（Page Swapping）的机制。是当可用内存不足时，Linux 会将某些内存页面换出到外部存储，以回收内存空间来运行新进程。当对应于换出页面的内存空间，再次处于活动状态时，系统会把这些页面重新从外部存储换入内存。</p>
<p>内存管理方面，THP（Transparent Huge Pages，透明大页面）是另外一个机制，也是为了提高进程的性能。我们在第 22 讲讨论过，如果系统用较大的页面，比如 2MB，而不是传统的 4KB，那么会带来一些好处，尤其是所需的地址转换条目数会减少。</p>
<p>尽管使用大页面的好处很早就为人所理解，但在 THP 引入之前，程序想使用大型页面并不容易。例如，操作系统启动时，需要保留大页面，并且进程必须显式调用才能分配大页面。而 THP 就是为了避免这两个问题而设计的，因此操作系统默认情况下就启用 THP。</p>
<p>了解了背景知识，你再看多个应用程序共存时的两个场景就不会有障碍了。第一个场景是应用程序启动时，第二个场景是应用程序稳定运行时。</p>
<h2 id="应用程序启动时为什么会被其他程序干扰">应用程序启动时为什么会被其他程序干扰？</h2>
<p>我们先看应用程序启动时的场景。当几个共存的应用程序共享有限的计算资源（包括内存和 cpu）时，它们之间会相互影响。如果各自独立地运行，导致对系统计算资源的消耗无法协调一致，那么某些应用程序会出现问题。</p>
<p>我们要做个实验来暴露这些性能问题，看看这个问题的表象是什么，然后一起分析产生问题的原因。</p>
<p>这个实验采用了两个相同的 Java 程序。我们首先启动第一个程序，来占用一些内存，系统剩下约 20GB 的未使用内存。然后我们开始启动另外一个 Java 程序，这个程序需要 20GB 的堆。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/0172f2c0de9e2d743358f80ebacb57f4.png" alt=""></p>
<p>在图中你可以看到，启动第二个程序之后，它的吞吐量是 12K/ 秒，持续时间约 30 秒。然后，吞吐量开始急剧下降。最坏的情况，在大约 20 秒的时间内，吞吐量几乎为零。有趣的是，过了一会儿，吞吐量又再次回到了稳定状态：12KB/ 秒。</p>
<p>下图显示了同一时间段的 GC 暂停信息。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/dad84caf36e535d3aa891c814ac33620.png" alt=""></p>
<p>最初的 GC 暂停很低，都低于 50 毫秒；然后暂停就跳到数百毫秒之大。你甚至可以看到两次大于 1 秒的超大的暂停！大约 1 分钟后，GC 暂停再次下降至低于 50 毫秒，并变得稳定。</p>
<p>我们看到在启动期间，Java 程序的性能很差。因为问题是在启动 JVM 时发生的，我们有理由怀疑这与 JVM 的启动方式有关。我们检查了程序的的内存驻留大小（RES，Resident Size），也就是进程使用的未交换的物理内存，图示如下。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/59d833a0cd855ebb07c9021978062521.png" alt=""></p>
<p>从图中你可以看到，尽管我们在启动 JVM 时，用参数将 JVM 的堆大小指定为 20GB（-Xmx20g 和 -Xms20g），但是 JVM 并不会从内存中一次全部拿到 20GB 的堆空间。相反，操作系统会在 JVM 的运行过程中不断地分配。也就是说，随着 JVM 实例化越来越多的对象，JVM 会从操作系统逐渐拿到更多的内存页面来容纳它们。</p>
<p>在分配过程中，操作系统将不断地检查空闲页面列表。如果发现可用内存量低于一定水平，操作系统就会开始回收页面，这个过程会花费 CPU 的时间。根据可用内存短缺的严重程度，回收过程可能会严重阻塞应用程序。在下图中，我们看到，可用内存明显地下降到了非常低的水平。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/96468bcd206c0818b97c97149db3acb7.png" alt=""></p>
<p>下面这张图显示了 CPU 的空闲百分比（CPU 空闲百分比和繁忙百分比的和是 100%）。对比时间线，我们可以清楚地看到，页面回收过程会导致 CPU 开销，也就是空闲百分比下降了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/d4142610159b3f8f1bdeec6d54cb4a59.png" alt=""></p>
<p>那么怎么进行内存回收呢？</p>
<p>在 Linux 上，当可用内存不足时，操作系统会唤醒 <strong>kswapd 守护程序</strong>，开始在后台回收空闲页面。如果内存压力很大，操作系统就会被迫采取另外一种措施，就是<strong>直接地同步释放内存的前台</strong>。具体来讲，当可用空闲页面降到一个阈值之下，就会触发这种直接前台回收。</p>
<p>当发生直接前台回收时，Linux 会冻结正在申请内存的执行代码的应用程序，从而间接地导致大量的 GC 暂停。</p>
<p>此外，直接回收通常会扫描大量内存页面，以释放未使用的页面。那么我们就来看看 Linux 直接回收内存页面的繁忙程度。下图就画出了 Linux 通过直接回收路径扫描的页面数。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/517f58302f0265b9f585c6f427ba96c4.png" alt=""></p>
<p>我们看到，在峰值时，通过直接回收，每秒扫描约 48K 个页面（即 200 MB）；这个回收工作量是很大的，CPU 会不堪重负。</p>
<h2 id="运行中的应用程序为什么会被别的程序干扰">运行中的应用程序为什么会被别的程序干扰？</h2>
<p>了解过程序启动时互相干扰的场景，我们再来考虑第二个场景：应用程序在持续运行中。</p>
<p>我们的实验是这样进行的。第一个 Java 程序以 20GB 的堆启动，并进入稳定状态。然后另外一个程序启动，并开始分配 50GB 的内存。</p>
<p>下图中体现了第一个程序的吞吐量。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/85b251553bb65cbfda67ad530ab3e86b.png" alt=""></p>
<p>从图中我们看到，第一个程序从一开始就实现了稳定的 12K/ 秒的吞吐量。然后，吞吐量急剧下降到零，这个零吞吐量的过程持续了约 2 分钟。从那时起，吞吐量一直在发生相当大的变化：有时吞吐量是 12K/ 秒，其他时候又降为零。</p>
<p>我们也观察了 JVM 的暂停，用下图所示。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/de80aadc3cbe69469a085f6c5465f4c0.png" alt=""></p>
<p>从图中我们看到，在稳定状态下，GC 暂停几乎为零，然后居然有一个超级大的暂停；多大呢？55 秒！从那时起，GC 暂停持续变化，但很少恢复为零。大多数暂停时间为几秒钟。</p>
<p>我们观察到，其他应用程序的运行会严重影响本程序的性能。各种观察的结论是，系统处于内存压力之下，操作系统内存会有很多和外部存储的页面交换活动。在下图中，我们看到操作系统交换出了很多内存页面到外部存储空间。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/304e134f55c686c3b1001ea93820ae5e.png" alt=""></p>
<p>这些换出的内存页面很多属于 Java 程序（也就是堆空间）。如果 JVM 需要进行堆上的垃圾回收，也就是 GC，那么 GC 需要扫描 JVM 对象，以收集失效的对象。如果扫描的对象恰好是分配在换出的页面上，那么 JVM 需要先将它们从外部存储交换空间重新载入到内存中。从外部存储载入内存需要一些时间，因为交换空间通常位于磁盘驱动器上。</p>
<p>所有这些时间，都会算在 GC 暂停之中。因此，程序会看到较大的 GC 暂停。下图就显示了大量的从外部存储载入页面的活动。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/2b82273c9c336dd28e8a69663b2c9c6d.png" alt=""></p>
<p>尽管页面交换活动会增加 GC 暂停时间，似乎可以解释刚刚看到的 JVM 暂停。但是，我怀疑，仅是这个原因根本无法解释生产中看到的很大暂停，比如超过 55 秒的暂停。你可能会问，我为什么有这样的怀疑？因为我在许多 GC 暂停的过程中，观察到了较高的系统 CPU 使用。</p>
<p>比如在下图中，我们观察到，系统也处于严重的 CPU 压力下。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/b71ae2c2900507af8e19677e45998294.png" alt=""></p>
<p>CPU 的高使用率不能完全归因于页面交换活动，因为页面交换通常不会占用大量 CPU。所以，其中“必有隐情”：一定是有其他活动在大量使用 CPU。我们通过检查了各种系统性能指标，最终确定了根因：是由于 THP 的机制，该机制严重加剧了程序性能和系统性能的下降。</p>
<p>具体来说，Linux 启用 THP 后，当应用程序分配内存时，会优先选择 2MB 大小的透明大页面，而不是 4KB 的常规页面。这一点我们可以轻易验证，比如下图中显示了透明大页面的瞬时数量。在峰值时，我们看到约 34,000 个 THP，即约 68GB 的内存量。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/a49d97c38eb6de6a0d372af3bc19b6e2.png" alt=""></p>
<p>我们还观察到，THP 的数量一开始很高，一段时间后开始下降。这是因为某些 THP 被拆分成小的常规页面，以补充可用内存的不足。</p>
<p>为什么需要拆分大页面呢？是因为当 Linux 在有内存压力时，它会将 THP 分为常规的、要准备交换的页面。为什么必需拆分大页面？这是因为当前的 Linux，仅支持常规大小页面的交换。</p>
<p>拆分活动的数量我们也用下图画出来了。你可以看到，在五分钟内大约有 5K 个 THP 页面被拆分，对应于 10GB 的内存。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/a7da9091c16db820e07b0c1880b115e3.png" alt=""></p>
<p>除了大页面拆分，同时，Linux 也会尝试将常规页面重新聚合为 THP 大页面，这就需要额外的页面扫描，并消耗 CPU。如果你在实践中注意观察的话，可以发现这种活动会占用大量 CPU。</p>
<p>使用 THP 可能遇到的更糟糕的情况是，<strong>聚合</strong>和<strong>拆分</strong>这两个相互矛盾的活动，是来回执行的。也就是说，当系统承受内存压力时，THP 被拆分成常规页面，而不久之后，常规页面则又被聚合成 THP，依此类推。我们已经观察到，这种行为会严重损害我们生产系统中的应用程序性能。</p>
<h2 id="如何解决多程序互相干扰">如何解决多程序互相干扰？</h2>
<p>那么程序在启动和运行时互相干扰的性能问题，到底该怎么解决呢？我们现在就来看解决方案。</p>
<p>我们的解决方案由三个设计元素组成，每个设计元素都针对问题的特定方面。部署任何单独的元素都将在一定程度上对问题有所帮助。但是，所有设计元素协同工作，才能获得最好的效果。</p>
<p>第一个设计元素是<strong>预分配 JVM 的堆空间</strong>。</p>
<p>我们知道，对 JVM 而言，只有在实际使用堆空间之时，就是当需要增大堆空间来容纳新对象分配请求时，Linux 才会为之分配新的内存页面，这时就可能会触发大量页面回收，并损害程序和系统性能。</p>
<p>这个设计元素就是预分配所有堆空间，从而避免了 Linux 实时分配页面的不利场景。要预先执行堆预分配，需要使用一个特殊的 JVM 参数：“ -XX：+ AlwaysPreTouch”，来启动 Java 应用程序。</p>
<p>但这个设计元素也有副作用，就是增加了 JVM 启动所需的时间，在部署时你需要考虑这一点。我们也做过一些实际测量，这个额外启动时间并不大，一般在几秒钟内，通常是可以接受的。</p>
<p>第二个设计元素，是关于如何<strong>保护 JVM 的堆空间不被唤出到外部存储</strong>。</p>
<p>我们知道，当发生 GC 时，JVM 需要扫描相应的内存页。如果这些页面被操作系统换出到外部存储，则需要先换入它们到内存，这就会导致延迟，会增加 JVM 的暂停时间。</p>
<p>这个设计元素就可以防止 JVM 的堆页面被换出。我们知道，Linux 操作系统上是可以关闭内存页面交换的，但是这个设置如果是在系统级别进行，就会影响所有应用程序和所有内存空间。我推荐你一个更好的实现，就是采用<strong>微调</strong>，你来选择哪个应用程序和哪个存储区域可以页面交换。例如，你可以使用 cgroup 来精确控制要交换的应用程序。</p>
<p>公司中的大多数平台，一般都用来运行同类 Java 应用程序；这些程序往往配置差不多。在这些情况下，在系统级别关闭应用程序交换，倒也是非常合理的。</p>
<p>第三个设计元素是<strong>动态调整 THP</strong>。</p>
<p>我们已经看到，启用 THP 功能可能会在某些场景下，导致严重的性能损失；但是 THP 在其他场景的确提高了性能，所以到底是否要启用 THP 呢？我们需要仔细考虑。</p>
<p>当 THP 影响性能时，系统的可用内存往往也恰好严重不足。发生这种情况时，现有的 THP 需要拆分成常规页面以进行页面换出。所以，我建议你用一个可用内存大小的阈值来决定 THP 的开关。</p>
<p>具体来说，就是建议你使用<strong>应用程序的堆大小</strong>作为内存阈值，来决定是否打开或关闭 THP。当可用内存远远大于应用程序的内存可能占用量大小时，就启用 THP，因为系统不太可能在启动特定应用程序后出现内存压力。否则的话，就关闭 THP。</p>
<p>由于许多后端服务器都是运行同类应用程序，通常情况下，你都很容易知道，部署的应用程序预期会占用多少内存空间。</p>
<p>此外，常规页面需要聚合成 THP，才能将大页面分配给应用程序。因此，这个元素的另外一部分机制是进行微调，是决定何时允许 THP 聚合。我建议你根据<strong>操作系统的直接页面扫描率</strong>和<strong>聚合进程的 CPU 使用率</strong>来决定。</p>
<h2 id="总结">总结</h2>
<p>今天我们讲述了，将多个应用程序放置在同一台服务器上时，由于应用程序和操作系统机制的互相作用，引发的一系列性能问题。这些问题的根本原因，就是程序之间的互相影响。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/62cd9e1108786f8fb95160b2c9775c8b.png" alt=""></p>
<p>应用程序之间的关系和人际关系一样，有时和谐，有时不和谐。唐代诗人刘禹锡有几句诗说：“常恨言语浅，不如人意深。今朝两相视，脉脉万重心。”说的是，语言的表达能力通常很有限，所以两人只能用眼神传达更复杂的情感。应用程序之间的关系，甚至程序和操作系统及硬件之间的关系，也会很复杂，也需要做足够的性能分析，才能理清它们之间的关系。</p>
<p>今天的讲述，主要集中在多任务共存环境中的两个问题，重点在分析问题产生的复杂根因。如果你对这方面的具体算法和生产验证有兴趣，可以参考我的一篇论文。这篇论文发表在International Journal of Cloud Computing上面。</p>
<h2 id="思考题">思考题</h2>
<p>Linux 操作系统的 THP 机制的设计初衷，本是为了提升系统性能。可是在有些情况下反而导致了系统性能下降。想一想操作系统的其他机制，有没有类似的情况发生？</p>
<blockquote>
<p>Tips：文件系统的预先读取等。</p>
</blockquote>
<p>欢迎你在留言区分享自己的思考，与我和其他同学一起讨论，也欢迎你把文章分享给自己的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE/">性能工程高手课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/27__%E6%B4%9E%E6%82%89paas%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">27__洞悉PaaS平台的本质</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/27__%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E4%B9%8B%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E8%BA%AB%E6%89%8B%E9%92%A5%E9%92%B1%E9%9A%8F%E8%BA%AB%E5%B8%A6/">
            <span class="next-text nav-default">27__分布式数据之缓存技术：“身手钥钱”随身带</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
