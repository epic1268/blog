<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>29__流式计算：如何通过集群实现实时计算？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是陶辉。
上节课我们介绍了在有边界的存量数据上进行的 MapReduce 离线计算，这节课我们来看看对于无边界数据，怎样实时地完成流式计算。
对于不再变化的存量数据，可以通过分而治之的 MapReduce 技术将数据划分到多台主机上并行计算，由于待处理的数据量很大，我们只能获得分钟级以上的时延。当面对持续实时产生动态数据的场景时，业务上通常需要在秒级时延中及时地拿到运算结果。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/29__%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E9%9B%86%E7%BE%A4%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/29__%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E9%9B%86%E7%BE%A4%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="29__流式计算：如何通过集群实现实时计算？">
  <meta property="og:description" content="你好，我是陶辉。
上节课我们介绍了在有边界的存量数据上进行的 MapReduce 离线计算，这节课我们来看看对于无边界数据，怎样实时地完成流式计算。
对于不再变化的存量数据，可以通过分而治之的 MapReduce 技术将数据划分到多台主机上并行计算，由于待处理的数据量很大，我们只能获得分钟级以上的时延。当面对持续实时产生动态数据的场景时，业务上通常需要在秒级时延中及时地拿到运算结果。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="系统性能调优必知必会">

  <meta itemprop="name" content="29__流式计算：如何通过集群实现实时计算？">
  <meta itemprop="description" content="你好，我是陶辉。
上节课我们介绍了在有边界的存量数据上进行的 MapReduce 离线计算，这节课我们来看看对于无边界数据，怎样实时地完成流式计算。
对于不再变化的存量数据，可以通过分而治之的 MapReduce 技术将数据划分到多台主机上并行计算，由于待处理的数据量很大，我们只能获得分钟级以上的时延。当面对持续实时产生动态数据的场景时，业务上通常需要在秒级时延中及时地拿到运算结果。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3351">
  <meta itemprop="keywords" content="系统性能调优必知必会">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="29__流式计算：如何通过集群实现实时计算？">
  <meta name="twitter:description" content="你好，我是陶辉。
上节课我们介绍了在有边界的存量数据上进行的 MapReduce 离线计算，这节课我们来看看对于无边界数据，怎样实时地完成流式计算。
对于不再变化的存量数据，可以通过分而治之的 MapReduce 技术将数据划分到多台主机上并行计算，由于待处理的数据量很大，我们只能获得分钟级以上的时延。当面对持续实时产生动态数据的场景时，业务上通常需要在秒级时延中及时地拿到运算结果。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">29__流式计算：如何通过集群实现实时计算？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3351 字 </span>
          <span class="more-meta"> 预计阅读 7 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#流式计算是如何实现的">流式计算是如何实现的？</a></li>
        <li><a href="#如何通过窗口确定待计算的数据">如何通过窗口确定待计算的数据？</a></li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是陶辉。</p>
<p>上节课我们介绍了在有边界的存量数据上进行的 MapReduce 离线计算，这节课我们来看看对于无边界数据，怎样实时地完成流式计算。</p>
<p>对于不再变化的存量数据，可以通过分而治之的 MapReduce 技术将数据划分到多台主机上并行计算，由于待处理的数据量很大，我们只能获得分钟级以上的时延。当面对持续实时产生动态数据的场景时，业务上通常需要在秒级时延中及时地拿到运算结果。</p>
<p>比如，商家为了拉新促活，会为特定的用户群体（比如新用户或者不活跃用户）推出优惠活动，为了防止“羊毛党”通过大量主机并行地**“薅羊毛”**，系统要能实时地聚合分析所有优惠券的使用者特点，再基于业务规则及时地封掉“羊毛党”帐号或者 IP 地址，才可以控制住风险范围，提高营销活动的收益。那对于整个系统持续生成的大量订单数据，怎样才能提供秒级的聚合分析结果呢？</p>
<p>最初的流式计算方案，是在时间维度上定期地将数据分片，再基于 MapReduce 思想在空间维度的多台主机上实现并行计算，这样也能获得实时计算结果。然而，对每片数据执行批量计算，想要在秒级甚至毫秒级拿到计算结果并不容易。当网络不稳定时，数据会因为报文延误而乱序，简单的基于时序分片会导致计算结果失真。当数据之间具有明显的业务关系时，固定的时间窗口更是难以得到预期的分析结果。</p>
<p>接下来我们就深入学习一下流式计算的工作原理，以及流式计算常用的数据分片窗口。</p>
<h2 id="流式计算是如何实现的">流式计算是如何实现的？</h2>
<p>在数据库、HDFS 等分布式系统中存放的静态数据，由于拥有清晰的边界，所以被称为 InBound Data 有边界数据。然而，线上运行中的互联网产品生命周期并不确定，它产生的数据有明确的开始，却没有截止时间点。对于这样有始无终的实时数据流，我们把它称为 OutBound Data 无边界数据，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/e965124dd76b6769a5b9b53ad53ab639.png" alt=""></p>
<p>从业务需求上看，有边界数据与无边界数据的计算目的是完全不同的。比如对于分布式监控系统，我们需要基于 IP 地址、用户帐号、请求类型等许多特征进行定时的聚合统计，例如获取每分钟内所有请求处理时延的平均值、中位数、最大值等，监控系统性能。此时，可以根据请求执行结果的产生时间对数据进行分片计算。比如，下表中有 7 条监控数据，需要求出每分钟请求时延的平均值。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/d3fdb80afc4cbf46c5954349ddc67ebd.png" alt=""></p>
<p>如果我们按照分钟整点对数据进行分片，就可以在 02:00 时对蓝色的消息 1、2 求出窗口内的平均时延 192 毫秒，并立刻返回结果。之后当接收完红色的消息 3、4、5 后，在第 2 分钟结束时再对 3 个数字求出平均值。以此类推。</p>
<p>**这种设计思想就是基于固定时间窗口的批处理解决方案。**当然，并不是一定要等到时间窗口结束时，才对这一批次的所有数据统一计算。我们完全可以在每个消息到来时，就计算出中间状态，当所在的时间窗口结束时，再将中间状态转换为最终结果。仍然以上表为例，我们可以在每个监控事件到达时，计算出请求时延和以及当前窗口内的事件个数，这样，在窗口结束时我们只需要将时延和除以事件个数，就能得到平均值。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/e51ddd917c5a25cc198a6c48489e6231.png" alt=""></p>
<p>因此，中间状态可以更均衡地使用计算资源，提高流式计算的整体性能。我们既可以把中间状态放在内存中，也可以把它持久化到本地磁盘中获取更高的可用性，为了方便计算节点的调度，我们通常还会将备份状态存放至远端的数据库。</p>
<p><a href="https://flink.apache.org/"><img src="./07bb839d3369015edfbfb0b5e2cb2746.png.md" alt=""></a></p>
<p>图片来源：https://flink.apache.org/</p>
<p>当然，流式计算最主要的性能提升思路，还是基于 MapReduce 思想，将同一窗口的数据从空间维度中分发到不同的计算节点进行并行的 Map 计算，再将 Map 映射出的结果 Reduce 为最终结果。由于流式计算天然是基于消息事件驱动的，因此它往往直接从 Kafka 等消息队列中获取输入数据，如同[第 27 讲] 的介绍，消息队列很容易协助流式计算实现数据拆分。</p>
<p>到这里，我们已经看到了实现流式计算的基本思路，其中基于固定时间窗口的数据划分方式还有很大的改进空间，目前它还无法解决较为复杂的有状态计算。所谓有状态计算，是指在时间窗口内，不同的消息之间会互相作用并影响最终的计算结果，比如求平均值就是这样一个例子，每个新到达的数据都会影响中间状态值。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/1e2ef4e99337e97fe5703c1c8672d6da.png" alt=""></p>
<p>相反，无状态计算处理到达的数据时，并不涉及窗口内的其他数据，处理流程要简单的多。例如，当监控到请求时延超过 3 秒时，就产生一条告警。此时，只需要单独地判断每个消息中的时延数据，就能够得到计算结果。</p>
<p>在真实的业务场景中，有状态计算还要更复杂。比如，对两个不同的数据源（可以理解为数据库中的表）做 join 连接时，采用内连接、外连接这两种不同的连接方式，就会影响到我们的时间窗口长度。再比如，当不同的事件具有逻辑关系时，窗口长度则应该由业务规则确定，不同的请求可能拥有不等的窗口大小。接下来，我们再来看看流式计算中的几种常见窗口。</p>
<h2 id="如何通过窗口确定待计算的数据">如何通过窗口确定待计算的数据？</h2>
<p>首先来看滑动窗口，它是从固定窗口衍生出的一种窗口。我们继续延续求每分钟平均值的例子，当业务上需要更平滑的曲线时，可以通过每 20 秒求最近 1 分钟请求时延的平均值实现，这就是滑动窗口，其中窗口长度则是 1 分钟，但每次计算完并不会淘汰窗口中的全部数据，而只是将步长向后移动 20 秒，即只淘汰最早 20 秒中的数据。当窗口长度与步长一致时，滑动窗口就退化成了固定窗口。</p>
<p>当然，我们还可以把窗口的计量单位从时间改为事件个数，此时可以称为计数窗口。仍然延续上面的例子，固定计数窗口可以改为求每 100 个访问记录的平均时延，滑动计数窗口可以改为每 10 条记录中求最近 100 个记录的平均时延。由于消息本身是有时序的，所以这些都可以称为时间驱动的窗口。事实上，还有另外一种事件驱动的窗口与此完全不同，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/e3e596920ec4029b66052d0ec53d2af7.png" alt=""></p>
<p>固定窗口、滑动窗口并不会解析业务字段，区别对待图中不同的 Key 关键字，这就很难解决以下这类场景：当需要统计用户在一个店铺内浏览的商品数量时，就需要针对用户的店铺停留时长来设计动态的窗口大小。毕竟不同的用户在不同的店铺内停留时长不可能相同，此时，动态的窗口大小可以通过事件来驱动，我们称为会话窗口。</p>
<p>事实上，我们还面临着信息统计准确性上的问题。在基于时间驱动的窗口中，这里的时间其实是事件到达流式系统时产生的系统处理时间，而不是事件发生的时间。仍然以访问日志为例，每条日志都有明确的请求访问时间，但在分布式系统传输时，由于网络波动的传输时延，以及各主机节点应用层的处理时延，这些事件到达流式计算框架的顺序已经发生了变化。如果仍然以固定的时间窗口来处理，就会得到错误的统计结果。</p>
<p>为了避免乱序事件扰乱统计结果，我们可以使用水位线 Watermark 减少乱序概率。比如下图中，消息队列中的数字表示事件时间，其中事件 7 先于事件 3、5 到达了流式计算系统：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/1f3a85ac4e8be9d3b8f4703b4b2614d8.png" alt=""></p>
<p>如果设置了水位 4，窗口就不再以事件顺序严格划分，而是通过水位上的时间来划分窗口，这样事件 7 就会放在第 2 个窗口中处理：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/74eddba0fcc61b54adb9dc93533bbd54.png" alt=""></p>
<p>当然，并不是有了水位线，第 1 个窗口就会无限制的等下去。在经历一个时间段后，第 1 个窗口会认定窗口关闭（这未必准确），它会处理 3、1、3、2 这 4 个事件。基于业务规则，下一个水位被设置为 9：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/e26e6bdcec84577a6e842b61a1507739.png" alt=""></p>
<p>这样第 2 个窗口会处理 6、5、7 事件，而事件 9 就放在了第 3 个窗口中处理：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/b8cad1de29a6b3d8cb5560af35742f70.png" alt=""></p>
<p>以此类推。根据业务特性和经验值，找到最大乱序时间差，再基于此设置合适的水位线，就能减轻乱序事件的影响。</p>
<h2 id="小结">小结</h2>
<p>这一讲我们介绍了流式计算的实现原理，以及常用的几种分片窗口。</p>
<p>对于无边界的实时数据流，我们可以在时间维度上将其切分到不同的窗口中，再将每个窗口内的数据从空间维度上分发到不同的节点并行计算，在窗口结束时汇总结果，这就实现了流式计算。Apache Flink、Spark、Storm 等开源产品都是这样的流式计算框架。</p>
<p>通过不同的窗口划分规则，可以实现不同的计算目的，包括以时间驱动的固定窗口、滑动窗口和计数窗口，以及以事件驱动的会话窗口。为了避免乱序事件的影响，还可以通过携带超时时间的 Watermark 水位，基于事件发生时间更精准地划分窗口。</p>
<h2 id="思考题">思考题</h2>
<p>最后，留给你一道讨论题。你知道 Lambda 架构吗？它通过分开部署的 MapReduce、流式计算系统，分别完成离线计算与实时流计算，如下图所示：</p>
<p><a href="https://www.oreilly.com/radar/questioning-the-lambda-architecture/"><img src="./f3b1891de26d4c63dba544846f4cd839.png.md" alt=""></a></p>
<p>图片来源：https://www.oreilly.com/radar/questioning-the-lambda-architecture/</p>
<p>这套系统的 IT 成本很高，因此大家致力于使用一套系统同时解决这两个问题。你认为这种解决方案是如何实现的？你又是如何看待流式计算发展方向的？欢迎你在留言区与大家一起探讨。</p>
<p>感谢阅读，如果你觉得这节课让你有所收获，也欢迎你把今天的内容分享给你的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">系统性能调优必知必会</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%AB%98%E6%89%8B%E8%AF%BE/29__%E6%B5%81%E8%AE%A1%E7%AE%97%E4%B8%8E%E6%B6%88%E6%81%AF%E4%B8%80%E9%80%9A%E8%BF%87flink%E7%90%86%E8%A7%A3%E6%B5%81%E8%AE%A1%E7%AE%97%E7%9A%84%E5%8E%9F%E7%90%86/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">29__流计算与消息（一）：通过Flink理解流计算的原理</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%82%B1%E5%B2%B3%E7%9A%84%E4%BA%A7%E5%93%81%E5%AE%9E%E6%88%98/29__%E6%AF%8F%E4%B8%AA%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E9%83%BD%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%95%86%E4%B8%9A%E6%A6%82%E5%BF%B5%E6%98%AF%E4%BB%80%E4%B9%88/">
            <span class="next-text nav-default">29__每个产品经理都要掌握的基本商业概念是什么？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
