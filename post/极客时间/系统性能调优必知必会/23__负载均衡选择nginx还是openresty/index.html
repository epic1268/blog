<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>23__负载均衡：选择Nginx还是OpenResty？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是陶辉。
在[第 21 讲] 介绍 AKF 立方体时，我们讲过只有在下游添加负载均衡后，才能沿着 X、Y、Z 三个轴提升性能。这一讲，我们将介绍最流行的负载均衡 Nginx、OpenResty，看看它们是如何支持 AKF 扩展体系的。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/23__%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%80%89%E6%8B%A9nginx%E8%BF%98%E6%98%AFopenresty/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/23__%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%80%89%E6%8B%A9nginx%E8%BF%98%E6%98%AFopenresty/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="23__负载均衡：选择Nginx还是OpenResty？">
  <meta property="og:description" content="你好，我是陶辉。
在[第 21 讲] 介绍 AKF 立方体时，我们讲过只有在下游添加负载均衡后，才能沿着 X、Y、Z 三个轴提升性能。这一讲，我们将介绍最流行的负载均衡 Nginx、OpenResty，看看它们是如何支持 AKF 扩展体系的。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="系统性能调优必知必会">

  <meta itemprop="name" content="23__负载均衡：选择Nginx还是OpenResty？">
  <meta itemprop="description" content="你好，我是陶辉。
在[第 21 讲] 介绍 AKF 立方体时，我们讲过只有在下游添加负载均衡后，才能沿着 X、Y、Z 三个轴提升性能。这一讲，我们将介绍最流行的负载均衡 Nginx、OpenResty，看看它们是如何支持 AKF 扩展体系的。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4660">
  <meta itemprop="keywords" content="系统性能调优必知必会">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="23__负载均衡：选择Nginx还是OpenResty？">
  <meta name="twitter:description" content="你好，我是陶辉。
在[第 21 讲] 介绍 AKF 立方体时，我们讲过只有在下游添加负载均衡后，才能沿着 X、Y、Z 三个轴提升性能。这一讲，我们将介绍最流行的负载均衡 Nginx、OpenResty，看看它们是如何支持 AKF 扩展体系的。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">23__负载均衡：选择Nginx还是OpenResty？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4660 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#负载均衡是如何扩展系统提升性能的">负载均衡是如何扩展系统提升性能的？</a></li>
        <li><a href="#nginx-上为什么可以执行-lua-代码">Nginx 上为什么可以执行 Lua 代码？</a></li>
        <li><a href="#nginx-与-openresty-的差别在哪里">Nginx 与 OpenResty 的差别在哪里？</a></li>
      </ul>
    </li>
    <li><a href="#usrlocalnginxsbinnginx--v">/usr/local/nginx/sbin/nginx -v</a></li>
    <li><a href="#usrlocalopenrestynginxsbinnginx--v">/usr/local/openresty/nginx/sbin/nginx -v</a></li>
    <li><a href="#ls--s---block-size1-usrlocalopenrestynginxsbinnginx">ls -s &ndash;block-size=1 /usr/local/openresty/nginx/sbin/nginx</a></li>
    <li><a href="#ls--s---block-size1-usrlocalnginxsbinnginx">ls -s &ndash;block-size=1 /usr/local/nginx/sbin/nginx</a></li>
    <li><a href="#ls--s---block-size1-usrlocalopenrestynginxsbinnginx-1">ls -s &ndash;block-size=1 /usr/local/openresty/nginx/sbin/nginx</a>
      <ul>
        <li><a href="#小结">小结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是陶辉。</p>
<p>在[第 21 讲] 介绍 AKF 立方体时，我们讲过只有在下游添加负载均衡后，才能沿着 X、Y、Z 三个轴提升性能。这一讲，我们将介绍最流行的负载均衡 Nginx、OpenResty，看看它们是如何支持 AKF 扩展体系的。</p>
<p>负载均衡通过将流量分发给新增的服务器，提升了系统的性能。因此，我们对负载均衡最基本的要求，就是它的吞吐量要远大于上游的应用服务器，否则扩展能力会极为有限。因此，目前性能最好的 Nginx，以及在 Nginx 之上构建的 OpenResty，通常是第一选择。</p>
<p>系统接入层的负载均衡，常通过 Waf 防火墙承担着网络安全职责，系统内部的负载均衡则通过权限、流量控制等功能承担着 API 网关的职责，CDN 等边缘节点上的负载均衡还会承担边缘计算的任务。如果负载均衡不具备高度开放的设计，或者推出时间短、社区不活跃，<strong>我们就无法像搭积木一样，从整个生态中低成本地构建出符合需求的负载均衡。</strong></p>
<p>很幸运的是，Nginx 完全符合上述要求，它性能一流而且非常稳定。从 2004 年诞生之初，Nginx 的模块化设计就未改变过，这样 16 年来累积下的各种 Nginx 模块都可以复用。它的2-clause BSD-like license 源码许可协议极其开放，即使修改源码后仍然可作商业用途，因此 Nginx 之上延伸出了 TEngine、OpenResty、Kong 等生态，这大大扩展了 Nginx 的能力边界。</p>
<p>接下来，我们就以 Nginx 以及建立了 Lua 语言生态的 OpenResty 为例，看看负载均衡是怎样扩展系统的，以及 Nginx 和同源的 OpenResty 有何不同。</p>
<h2 id="负载均衡是如何扩展系统提升性能的">负载均衡是如何扩展系统提升性能的？</h2>
<p>通过 AKF 立方体 X 轴扩展系统时，负载均衡只需要能够透传协议，并选择负载最低的上游应用作为流量分发对象即可。这样，三层（网络层）、四层（传输层）负载均衡都可用于扩展系统，甚至在单个局域网内你还可以使用二层（数据链路层）负载均衡。其中，分发流量的路由算法既可以使用 RoundRobin 轮转算法，也可以基于 TCP 连接或者 UDP Session 使用最少连接数算法，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/f85819ccc2c4d0dabeb7428f0f44b312.png" alt=""></p>
<p>然而，基于 AKF Y 轴扩展系统时，负载均衡必须根据功能来分发请求，也就是说它必须解析完应用层协议，才能明白这是什么请求。因此，如 LVS 这样工作在三层和四层的负载均衡就无法满足需求了，我们需要 Nginx 这样的七层（应用层）负载均衡，它能够从请求中获取到描述功能的关键信息，并以此为依据路由请求。比如当 HTTP 请求中的 URL 描述功能时，Nginx 就可以用 location 匹配 URL，再基于 location 来路由请求，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/f198fbd640791f43d2ab268f629df356.png" alt=""></p>
<p>基于 AKF Z 轴扩展时，如果只是使用了网络报文中的源 IP 地址，那么三层、四层负载均衡都能胜任。然而如果需要帐号、访问对象等用户信息扩展系统，仍然只能使用七层负载均衡从请求中获得。比如，Nginx 可以通过 $ 变量获取到 URL 参数或者 HEADER 头部的值，再以此作为路由算法的输入参数。</p>
<p>因此，**七层负载均衡是分布式系统提升性能的必备工具。**除了基于各种路由策略分发流量，提高性能及可用性（如宕机迁移）外，负载均衡还需要完成上、下游协议间的适配、转换。例如考虑到信息安全，跑在公网上的外部协议常基于 TLS/SSL 协议，而在效率优先的企业内网中，一般不会使用大幅降低性能的 TLS 协议，因此负载均衡需要拥有卸载或者装载 TLS 层的能力。</p>
<p>再比如，下游客户端多样且难以保持一致（比如 IE6 这个古董浏览器仍然存在于当下的互联网中），因此常使用 HTTP 协议与服务器通讯，而上游组件则依据开发团队或者系统架构的特点，会选择 CGI、uWSGI、gRPC 等协议，这样负载均衡还得拥有转换各种协议的功能。Nginx 可以通过反向代理模块，轻松适配各类协议，如下所示（通过 stream 模块，Nginx 也支持四层负载均衡）：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/924e4a5ed4b41d0f5265e20be4fd5f59.png" alt=""></p>
<p>从性能角度，Nginx 支持 C10M 级别的并发连接，其原因你可以参考本专栏第 1、2 部分的内容。从功能角度，良好的模块化设计，使得 Nginx 可以完成各类协议的适配，不只包括第 3 部分课程介绍过的通用协议，甚至支持 Redis、MySQL 等专有协议。因此，Nginx 是目前最好用的负载均衡。</p>
<h2 id="nginx-上为什么可以执行-lua-代码">Nginx 上为什么可以执行 Lua 代码？</h2>
<p>OpenResty 也非常流行，其实它就是 Nginx，只是通过扩展的 C 模块支持在 Nginx 中嵌入 Lua 语言，这样 Lua 模块构建出的生态就可以与 C 模块协作使用，大幅度提升了开发效率。我们先来看下 OpenResty 与 Nginx 之间的关系。</p>
<p>OpenResty 源代码由<strong>官方 Nginx、第三方 C 模块、Lua 语言模块以及一些工具脚本</strong>构成。编译 Nginx 时，OpenResty 将自己的第三方 C 模块按照 Nginx 的规则添加到可执行文件中，包括 ngx_http_lua_module 和 ngx_stream_lua_module 这两个 C 模块，它们允许 Lua 语言运行在 Nginx 进程中，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/b0504e7928a274b4a4eff46ad3d9d2c5.png" alt=""></p>
<p><strong>Lua 模块既能够享受 Nginx 的高性能，又通过“协程”</strong>（参见[第 5 讲]）<strong>、Lua 脚本语言提高了开发效率</strong>，这也是 OpenResty 最大的优点。我们先来看看 Lua 语言是怎么嵌入到 Nginx 中的。</p>
<p>**Nginx 在进程启动、处理请求时提供了许多钩子函数，允许第三方 C 模块将其代码放在这些钩子函数中执行。同时，Nginx 还允许 C 模块自行解析 nginx.conf 中出现的配置项。**这种架构允许 OpenResty 将 Lua 代码写进 nginx.conf 文件，再基于LuaJIT 即时编译到 Nginx 中执行。</p>
<p>ngx_http_lua_module 模块也正是通过 OpenResty 提供的以下 11 个指令嵌入 Lua 代码的：</p>
<ol>
<li>在 Nginx 启动时嵌入 Lua 代码，包括 master 进程启动时执行的 <strong>init_by_lua</strong> 指令，以及每个 worker 进程启动时执行的 <strong>init_worker_by_lua</strong> 指令。</li>
<li>在重写 URL、访问权限控制等预处理阶段嵌入 Lua 代码，包括解析 TLS 协议后的 <strong>ssl_certificate_by_lua</strong> 指令（基于 openssl 的回调函数实现），设置动态变量的 <strong>set_by_lua</strong> 指令，重写 URL 阶段的 <strong>rewrite_by_lua</strong> 指令，以及控制访问权限的 <strong>access_by_lua</strong> 指令。</li>
<li>生成 HTTP 响应时嵌入 Lua 代码，包括直接生成响应的 <strong>content_by_lua</strong> 指令，连接上游服务前的 <strong>balancer_by_lua</strong> 指令，处理响应头部的 <strong>header_filter_by_lua</strong> 指令，以及处理响应包体的 <strong>body_filter_by_lua</strong> 指令。</li>
<li>记录 access.log 日志时嵌入 Lua 代码，通过 <strong>log_by_lua</strong> 指令实现。</li>
</ol>
<p>如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/a370d8265295e0ab87ba2493766ae8fa.png" alt=""></p>
<p>ngx_stream_lua_module 模块与之类似，这里不再赘述。</p>
<p>当然，如果 Lua 代码只是可以在 Nginx 进程中执行，它是无法处理用户请求的。我们还需要让 Lua 代码与 Nginx 中的 C 代码互相调用，去获取、改变 HTTP 请求、响应的内容。因此，ngx_http_lua_module 和 ngx_stream_lua_module 这两个模块通过FFI 技术，将 C 函数通过 Ngx 库中的 Lua API，暴露给纯 Lua 代码，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/7ef8518d8c54801e7ad164d97c3fb33c.png" alt=""></p>
<p>这样，通过 nginx.conf 文件中的 11 个指令，以及 FFI 技术提供的 SDK，Lua 代码才真正可以处理请求，Lua 生态从这里开始延伸，因此，OpenResty 上还提供了进一步提高开发效率的 Lua 模块库（参见 /usr/local/openresty/lualib/ 目录）。关于 FFI 技术及 OpenResty 提供的 HTTP SDK，你可以参考 《Nginx 核心知识 100 讲》中的第 147-154 课。</p>
<h2 id="nginx-与-openresty-的差别在哪里">Nginx 与 OpenResty 的差别在哪里？</h2>
<p>清楚了 OpenResty 与 Nginx 间的相同之处，我们再来看，二者默认编译出的 Nginx 可执行程序有何不同之处。</p>
<p>首先看版本差异。当你在官网下载 Nginx 时，会发现有 3 类版本：Mainline、Stable 和 Legacy。其中，Mainline 是单号版本，<strong>它是含有最新功能的主线版本，迭代速度最快。Stable 是 mainline 版本稳定运行一段时间后，将单号大版本转换为双号的稳定版本</strong>，比如 1.18.0 就是由 1.17.10 转换而来。Legacy 则是曾经的稳定版本，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/19af6875ccaffcf53d6ebfb916afa2f7.png" alt=""></p>
<p>你可以通过源代码中的 CHANGES 文件，通过 4 种不同类型的变更查看版本间的差异，包括：</p>
<ol>
<li>表示新功能的 <strong>Feature</strong>，比如下图中 HTTP 服务新增的 auth_delay 指令。</li>
<li>表示已修复问题的 <strong>Bugfix</strong>。</li>
<li>表示已知特性变更的 <strong>Change</strong>，比如 Nginx 曾经允许 HTTP 请求头部中出现多个 Host 头部，但在 1.17.9 这个 Change 之后，这类 HTTP 请求将作为非法请求处理。</li>
<li>表示安全升级的 <strong>Security</strong>，比如 1.15.6 版本就修复了 CVE-2018-16843 等 3 个安全问题。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/c17dc497d8e5c487d61e5be3b08097eb.png" alt=""></p>
<p>当你安装好了 OpenResty 或者 Nginx 后，你可以通过 nginx -v 命令查看它们的版本。你会发现，<strong>2014 年以后发布的 OpenResty 都是运行在单号 Mainline 版本上的：</strong></p>
<h1 id="usrlocalnginxsbinnginx--v">/usr/local/nginx/sbin/nginx -v</h1>
<p>nginx version: nginx/1.18.0</p>
<h1 id="usrlocalopenrestynginxsbinnginx--v">/usr/local/openresty/nginx/sbin/nginx -v</h1>
<p>nginx version: openresty/1.15.8.3</p>
<p>通常我们会选择稳定的 Stable 版本，OpenResty 为什么会选择单号的 Mainline 版本呢？这是因为，<strong>Nginx 与 OpenResty 的版本发布频率完全不同</strong>，2012 年后 Nginx 每年大约发布 10 多个版本，如下图所示（versions 统计了每年发布的版本数，图中其他 3 条拆线统计了每年 feature、bugfix、change 的变更次数）：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/1ec42336f5e2a7f59a8e4f0d73bc32ca.png" alt=""></p>
<p>OpenResty 每年的版本更新频率是个位数，特别是从 2018 年到现在，OpenResty 只发布了 4 个版本。所以<strong>为了使用尽量运行在最新版本上，OpenResty 选择了 Mainline 单号版本。</strong></p>
<p>你可能会想，OpenResty 并没有修改 Nginx 的源代码，为什么不能由用户在官方 Nginx 上自行添加 C 模块，实现 OpenResty 的安装呢？这源于部分 OpenResty C 模块，没有按照 Nginx 架构指定的顺序添加到模块列表中，而且它们的编译环境也过于复杂。因此，OpenResty 放弃了 Nginx 官方的 configure 文件，用户需要使用 OpenResty 改造过的 configure 脚本编译 Nginx。</p>
<p>再来看模块间的差异。如果你留意 OpenResty 与 Nginx 间二进制文件的体积，会发现使用默认配置时，**OpenResty 的可执行文件大了 5 倍，**如下所示：</p>
<h1 id="ls--s---block-size1-usrlocalopenrestynginxsbinnginx">ls -s &ndash;block-size=1 /usr/local/openresty/nginx/sbin/nginx</h1>
<p>16437248 /usr/local/openresty/nginx/sbin/nginx</p>
<h1 id="ls--s---block-size1-usrlocalnginxsbinnginx">ls -s &ndash;block-size=1 /usr/local/nginx/sbin/nginx</h1>
<p>3851568 /usr/local/openresty/nginx/sbin/nginx</p>
<p>这由 2 个原因所致。</p>
<p>首先，官方 Nginx 提供的四层负载均衡功能（由 18 个 STREAM 模块实现）、TLS 协议处理功能，默认都是不添加到 Nginx 中的，而 OpenResty 的 configure 脚本将其改为了默认模块。当然，如果你在编译官方 Nginx 时，加入以下选项：</p>
<p>./configure &ndash;with-stream &ndash;with-stream_ssl_module &ndash;with-stream_ssl_preread_module &ndash;with-http_ssl_module</p>
<p>那么从官方模块上，Nginx 就与 OpenResty 完全一致了，此时再观察二进制文件的体积，会发现它翻了一倍：</p>
<h1 id="ls--s---block-size1-usrlocalopenrestynginxsbinnginx-1">ls -s &ndash;block-size=1 /usr/local/openresty/nginx/sbin/nginx</h1>
<p>6999144 /usr/local/openresty/nginx/sbin/nginx</p>
<p>其次，OpenResty 添加了近 20 个第三方 C 模块，除了前文介绍过支持 Lua 语言的 2 个模块外，还有支持 Redis、Memcached、MySQL 等服务的模块。这些模块编译时，还需要链接依赖的软件库，因此它们又将 Nginx 可执行文件的体积增加了 1 倍多。</p>
<p>除版本、模块外，OpenResty 与 Nginx 间还有一些小的差异，比如 Nginx 使用了 GCC 编译器的 -O1 优化参数，而 OpenResty 则使用了 -O2 优化参数。再比如，官方 Nginx 最新版本的 Makefile 支持 upgrade 参数，简化了热升级操作。当然，这些小改动并不重要，只要修改 configure 脚本就能做到。</p>
<p>我们到底该如何在二者中选择呢？我认为，如果不使用 Lua 语言，那么我建议使用 Nginx。官方 Nginx 的 Stable 版本更稳定，可执行文件的体积也更小。<strong>如果你需要使用 OpenResty、TEngine 中的部分 C 模块，可以通过–add-module 选项将其加入到官方 Nginx 中。</strong></p>
<p>如果所有 C 模块都无法满足业务需求，你就应该选择 OpenResty。注意，Lua 语言给你带来极大灵活性的同时，也会引入许多不确定性。比如，如果你调用了会导致进程休眠的 Lua 阻塞函数（比如封装了系统调用的原生 Lua 库，或者第三方服务提供的同步 SDK），将会导致 Nginx 正在处理数万并发请求的 C 模块同时进入休眠，从而让服务的性能大幅度下降。</p>
<h2 id="小结">小结</h2>
<p>这一讲，我们介绍了负载均衡的工作方式，以及 Nginx、OpenResty 这两个最流行的负载均衡之间的异同。</p>
<p>任何负载均衡都能从 AKF X 轴水平扩展系统，但只有能够解析应用层协议，获取到请求的功能、用户身份、访问对象等信息，才能够沿 AKF Y 轴、Z 轴全方位扩展系统。因此，七层负载均衡是分布式系统提升性能的利器。</p>
<p>Nginx 的开放式架构允许第三方模块通过 10 多个钩子函数，在不同的生命周期中处理请求。同时，还允许 C 模块自行解析 nginx.conf 配置文件。这样，OpenResty 就通过 2 个 C 模块，将 Lua 代码用 LuaJIT 编译到 Nginx 中执行，并通过 FFI 技术将 C 函数暴露给 Lua 代码。这就是 OpenResty 允许 Lua 语言与 C 模块协同处理请求的原因。</p>
<p>OpenResty 虽然就是 Nginx，但由于版本发布频率低于官方 Nginx，因此使用了单号的 Mainline 版本以获得 Nginx 的最新特性。由于 OpenResty 默认加入了四层负载均衡和 TLS 协议处理功能，还新增了近 20 个第三方 C 模块，这造成它编译出的 Nginx 体积大了 5 倍。如果无须使用 Lua 语言就能够满足业务需求，我推荐你使用 Nginx。</p>
<h2 id="思考题">思考题</h2>
<p>最后，留给你一道思考题。Nginx、OpenResty 都有着丰富、活跃的生态，这也是我们选择开源软件的一个前提。这节课我们提到开放的设计是形成生态的一个必要因素，然而这二者都有许多没有形成生态的竞争对手，你认为开源软件构建出庞大的生态，还需要哪些充分条件呢？欢迎你在留言区与大家一起探讨。</p>
<p>感谢阅读，如果你觉得这节课让你对负载均衡有了更深的了解，搞清楚了 OpenResty 与 Nginx 间的差别，也欢迎把它分享给你的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">系统性能调优必知必会</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/23__%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%88/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">23__分布式系统的技术栈</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/23__%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E7%BC%93%E5%AD%98%E5%8F%AF%E4%BB%A5%E9%94%A6%E4%B8%8A%E6%B7%BB%E8%8A%B1%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%90%BD%E4%BA%95%E4%B8%8B%E7%9F%B3/">
            <span class="next-text nav-default">23__缓存设计：缓存可以锦上添花也可以落井下石</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
