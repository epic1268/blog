<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>24彩蛋聊聊我的大厂面试经历，谈谈我对算法学习的看法 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="今天我想和你聊聊我的大厂面试经历，谈谈我对算法学习的看法。
我会分成三个阶段向你介绍。
面试前：如何准备面试。
面试中：面试/笔试中的注意事项。
面试后：如何回答问题与提问题。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/24%E5%BD%A9%E8%9B%8B%E8%81%8A%E8%81%8A%E6%88%91%E7%9A%84%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%9C%8B%E6%B3%95/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/24%E5%BD%A9%E8%9B%8B%E8%81%8A%E8%81%8A%E6%88%91%E7%9A%84%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%9C%8B%E6%B3%95/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="24彩蛋聊聊我的大厂面试经历，谈谈我对算法学习的看法">
  <meta property="og:description" content="今天我想和你聊聊我的大厂面试经历，谈谈我对算法学习的看法。
我会分成三个阶段向你介绍。
面试前：如何准备面试。
面试中：面试/笔试中的注意事项。
面试后：如何回答问题与提问题。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="数据结构与算法面试宝典">

  <meta itemprop="name" content="24彩蛋聊聊我的大厂面试经历，谈谈我对算法学习的看法">
  <meta itemprop="description" content="今天我想和你聊聊我的大厂面试经历，谈谈我对算法学习的看法。
我会分成三个阶段向你介绍。
面试前：如何准备面试。
面试中：面试/笔试中的注意事项。
面试后：如何回答问题与提问题。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="10130">
  <meta itemprop="keywords" content="数据结构与算法面试宝典">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="24彩蛋聊聊我的大厂面试经历，谈谈我对算法学习的看法">
  <meta name="twitter:description" content="今天我想和你聊聊我的大厂面试经历，谈谈我对算法学习的看法。
我会分成三个阶段向你介绍。
面试前：如何准备面试。
面试中：面试/笔试中的注意事项。
面试后：如何回答问题与提问题。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">24彩蛋聊聊我的大厂面试经历，谈谈我对算法学习的看法</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 10130 字 </span>
          <span class="more-meta"> 预计阅读 21 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>今天我想和你聊聊我的大厂面试经历，谈谈我对算法学习的看法。</p>
<p>我会分成三个阶段向你介绍。</p>
<p>面试前：如何准备面试。</p>
<p>面试中：面试/笔试中的注意事项。</p>
<p>面试后：如何回答问题与提问题。</p>
<p>就职现公司之前，我用一个月的时间通关了 10+ 家公司，顺利地拿下了腾讯、头条、蚂蚁、美团、eBay、微软等大厂的 Offer。</p>
<p>借着这个机会，我也把自己总结的“面经”分享给你。希望能够助力你早日拿下梦想中的职位。</p>
<p>面试前的准备</p>
<p>如果把面试比作打仗，那么在出发前我们需要确定的两件事。</p>
<p>“粮草”：需要储备什么样的“知识”才能去面试？以及如何准备？</p>
<p>“对手”：职位要求是什么？公司是做什么的？他们的业务有哪些特点？</p>
<p>知识的储备</p>
<p>一般而言，我们会把需要准备的知识分为 3 块：</p>
<p>项目经历</p>
<p>基础知识</p>
<p>算法与数据结构</p>
<p>这里，我首先需要重点提出来的是“项目”上的准备。根据我多年的面试经验，很多候选人并没有认真地准备这一块。所以，我认为有必要说一下具体应该如何准备。</p>
<p>面试的时候，一般开头都会问你的项目经历，有些公司甚至在面试中的某一轮只涉及项目相关的知识，完全不涉及写题。所以，你的“项目经历”准备得是否充分有时候也会直接影响面试结果。</p>
<p>1. 项目经历 5 步法</p>
<p>一般而言，只要介绍两段项目经历就够了。然后，针对这两个项目，你需要回答以下 5 个问题：</p>
<p>为什么会有这个项目？</p>
<p>为什么这样设计？</p>
<p>你在项目里面的角色是什么？你做了什么？</p>
<p>项目中有什么特别困难（出彩/你做得最好）的地方？你是如何克服的？</p>
<p>你在项目中的收获是什么？</p>
<p>针对这 5 个问题，你的答案需要满足以下三个特点。</p>
<p>清晰流畅：平时有空闲时间，一定要像批改作文一样，批改自己准备的答案。</p>
<p>突出重点：不要介绍无关紧要的内容，面试的每一分钟都是展示你的机会，不要浪费。</p>
<p>自我提问：在一些关键的细节上要做到非常清楚，想象一下面试官可能会提出哪些问题。2. 基础知识</p>
<p>基础知识的准备，需要根据以下 3 方面展开。</p>
<p>项目经历：有的基础知识会直接从项目经历展开，比如数据库开发，那么大概率会问到 B+ 树。</p>
<p>职位性质：比如，如果你面试的是微服务，那么关于服务治理的基础知识就需要多记忆一下。</p>
<p>公司特点：有的公司对于过往的经历和项目并不是特别看重，那么他们对基础知识的考察就会相对多一些，比如操作系统、计算机网络等。</p>
<p>我个人的准备顺序是：项目经历、职位性质、公司特点，优先级由高到低。</p>
<p>3. 算法与数据结构</p>
<p>算法与数据结构的准备，时间上我一般分为三个阶段。</p>
<p>重点准备的知识点</p>
<p>刷题与整理模板</p>
<p>模板复习与重点题目突击</p>
<p>重点知识点：算法与数据结构的面试，并不需要准备到算法竞赛的程度。下图是我整理的面试常考知识点：</p>
<p>刷题与模板：刷题的时候，需要注意：</p>
<p>按照 tag 刷；</p>
<p>刷题的难度应该集中在中等难度；</p>
<p>按照“一解多题”的方式整理好知识点与模板。</p>
<p>这一阶段刷题结束之后，你的产出就是像《22 | 数据结构模板：如何让解题变成搭积木？》《23 | 算法模板：如何让高频算法考点秒变默写题？》给出的思维导图和代码模板。</p>
<p>复习与突击：主要分为模板与题目。你需要对模板代码中的思路，涉及的代码和细节都非常熟悉。</p>
<p>重点题目：我们应该按照“一题多解”的方式来过一遍重点题目，比如那些具有代表性的题目，并且在求解的时候，尽量使用我们整理过的模板。</p>
<p>面试现场</p>
<p>接下来，介绍一下我在各个大厂的面试经历，以及前面部分没有介绍过的题目。</p>
<p>注：涉及的公司名称我均用随机的大写字母来表示。</p>
<p>X 公司：第一轮</p>
<p>第一轮，在聊过各种项目细节之后。便打开了某客的平台开始算法笔试。余下的时间大概只有 20 分钟。</p>
<p>面试官：“现在我们开始写一个算法题吧。题目是这样，我给你一个树的前序和中序遍历，你能把这棵树给恢复出来吗？”</p>
<p>我：“请问一下，这个树是二叉树吗？二叉树里面会有重复元素吗？”</p>
<p>点评：给出题目之后，不要马上开始写代码，一定要与面试官沟通题意，可以当成在与客户进行沟通！因为这里的题意实际上非常含糊，没有说清楚是什么树，也没有说清楚是否有重复元素。一定不要马上往你刷过的题上去套路面试官。</p>
<p>面试官：“是二叉树，并且保证二叉树里面没有重复的元素！”</p>
<p>我：“那给定的前序遍历和中序遍历是数组吗？给定的输入是合法的吧，我不需要去处理非法的情况吧。”</p>
<p>面试官：“是的。我们假定给你的输入肯定都是可以恢复出一棵二叉树的。”</p>
<p>我：“好的，那我写一个接口给你看一下。”</p>
<p>于是根据面试官的要求，我写出了二叉树结点的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class TreeNode {
</span></span><span class="line"><span class="cl">  int val = 0;
</span></span><span class="line"><span class="cl">  TreeNode *left = null;
</span></span><span class="line"><span class="cl">  TreeNode *right = null;
</span></span><span class="line"><span class="cl">  TreeNode() {}
</span></span><span class="line"><span class="cl">  TreeNode(int x) { val = x; }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>以及接口的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">TreeNode buildTree(int[] preorder, int[] inorder);
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，我并没有立马开始写代码，而是马上与面试官过了一个简单的 Case，确保我对题意的理解是准确的。</p>
<p>我：“如果输入 preorder = [1, 2, 3], inorder = [2, 1, 3]。那么返回的树的结构是根结点为 1，左子结点是 2，右子结点为 3。对吗？所以这棵二叉树可以不是二叉搜索树吧？”</p>
<p>面试官：“是的，开始写吧。”</p>
<p>下面和你分享一下我的解题的思路。</p>
<p>前序遍历：根结点，左子树的所有结点，右子树的所有结点。</p>
<p>中序遍历：左子树的所有结点，根结点，右子树的所有结点。</p>
<p>那么，首先我可以通过前序遍历拿到根结点，然后在中序遍历中找到根结点，就可以将两个数组成功切分成三部分，如下图所示：</p>
<p>切分成三部分之后，我们可以再分别用相应的子数组构建子树。因此，整个问题遍历是类似于个递归 + 二叉树的前序遍历。</p>
<p>于是我开始写出第一份代码（我在真实面试中并没有写代码注释，写在这里是为了方便你查看)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">TreeNode createTree(int[] preorder, int b, int e,
</span></span><span class="line"><span class="cl">                    int[] inorder, int f, int t) {
</span></span><span class="line"><span class="cl">  if (b &gt;= e) {
</span></span><span class="line"><span class="cl">    return null;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 如果只有一个结点
</span></span><span class="line"><span class="cl">  if (b + 1 == e) {
</span></span><span class="line"><span class="cl">    return new TreeNode(preorder[b]);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 利用根结点来切分中序
</span></span><span class="line"><span class="cl">  final int rootValue = preorder[b];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 找到根结点在中序遍历中的位置
</span></span><span class="line"><span class="cl">  final int rootPos = findPos(inorder, f, t, rootValue);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 创建根结点
</span></span><span class="line"><span class="cl">  TreeNode root = new TreeNode(rootValue);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 利用在中序遍历中找到的根结点，将数组分为三部分
</span></span><span class="line"><span class="cl">  // 分别计算出左子树与右子树的长度
</span></span><span class="line"><span class="cl">  final int leftLen = rootPos - f;
</span></span><span class="line"><span class="cl">  final int rightLen = t - rootPos - 1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 左子树
</span></span><span class="line"><span class="cl">  // preorder里面左子树的范围 =&gt; [b + 1, b + 1 + leftLlen)
</span></span><span class="line"><span class="cl">  // inorder里面左子树的范围  =&gt; [f, rootPos)
</span></span><span class="line"><span class="cl">  root.left = createTree(preorder, b + 1, b + 1 + leftLen,
</span></span><span class="line"><span class="cl">                         inorder, f, rootPos);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 右子树
</span></span><span class="line"><span class="cl">  // preorder右子树的范围 =&gt; [b + 1 + leftLen , e)
</span></span><span class="line"><span class="cl">  // inorder里面右子树的范围 =&gt; [rootPos + 1, t]
</span></span><span class="line"><span class="cl">  root.right =
</span></span><span class="line"><span class="cl">    createTree(preorder, b + 1 + leftLen, e,
</span></span><span class="line"><span class="cl">               inorder, rootPos + 1, t);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  return root;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">int findPos(int[] inorder, int f, int t, int val) {
</span></span><span class="line"><span class="cl">  for (int i = f; i &lt; t; i++) {
</span></span><span class="line"><span class="cl">    if (inorder[i] == val) {
</span></span><span class="line"><span class="cl">      return i;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return -1;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">TreeNode buildTree(int[] preorder, int[] inorder) {
</span></span><span class="line"><span class="cl">  final int N = preorder == null ? 0 : preorder.length;
</span></span><span class="line"><span class="cl">  if (N == 0) {
</span></span><span class="line"><span class="cl">    return null;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return createTree(preorder, 0, N, inorder, 0, N);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>当代码写完之后，我还写了一些测试用例，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void TEST_null() {
</span></span><span class="line"><span class="cl">  assert null == buildTree(null, null);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">void TEST_length0() {
</span></span><span class="line"><span class="cl">  int[] preorder = new int[0];
</span></span><span class="line"><span class="cl">  int[] inorder = new int[0];
</span></span><span class="line"><span class="cl">  assert null == buildTree(preorder, inorder);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">void TEST_single() {
</span></span><span class="line"><span class="cl">  int[] preorder = new int[] { 1 };
</span></span><span class="line"><span class="cl">  int[] inorder = new int[] { 1 };
</span></span><span class="line"><span class="cl">  TreeNode ret = buildTree(preorder, inorder);
</span></span><span class="line"><span class="cl">  assert null != ret;
</span></span><span class="line"><span class="cl">  assert ret.val == 1;
</span></span><span class="line"><span class="cl">  assert ret.left == null;
</span></span><span class="line"><span class="cl">  assert ret.right == null;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">void TEST_two() {
</span></span><span class="line"><span class="cl">  int[] preorder = new int[] { 1, 2 };
</span></span><span class="line"><span class="cl">  int[] inorder = new int[] { 1, 2 };
</span></span><span class="line"><span class="cl">  TreeNode ret = buildTree(preorder, inorder);
</span></span><span class="line"><span class="cl">  assert null != ret;
</span></span><span class="line"><span class="cl">  assert 1 == ret.val;
</span></span><span class="line"><span class="cl">  assert 2 == ret.right.val;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">//.. 由于篇幅，我省略了一些暴力+大数据量的测试用例
</span></span></code></pre></td></tr></table>
</div>
</div><p>点评：写完代码之后，不要立马交卷，好好写一些测试还是非常有必要的！</p>
<p>面试官看了一下代码，说：“那你这个时间复杂度是多少呢？”</p>
<p>我开始仔细地盘算，首先这段代码实际上是需要把数组切分为三部分，这段代码和我们学过的“三路切分”快排是非常类似的，那么时间复杂度应该是 O(NlgN)，其中 N 表示数组的长度。</p>
<p>然后我再想最差的情况。比如，如果二叉树是如下图所示的一种结构：</p>
<p>那么，preorder = [1, 2, 3, 4]; inorder = [4,3,2,1]。由于每次查找的时候都是顺序查找，那么整个时间复杂度就会达到 O(N2)。</p>
<p>这段代码与快排非常类似，因此，快排的时间复杂度分析就在这里用上了。</p>
<p>我回答面试官：“时间复杂度正常情况下是 O(NlgN)，最差会达到 O(N2)。”</p>
<p>面试官：“有什么优化的方法吗？”</p>
<p>我开始思考，首先建树的框架肯定是对的，那么时间的消耗应该就是在查找根结点的位置。我想到每个元素都不一样，是不是可以用哈希把每个元素的位置记录下来，这样就不用查找了。</p>
<p>我问：“可以使用哈希把每个元素在中序遍历的位置记下来，这样就可以省略掉查找的时间，那么时间复杂度就会下降到 O(N)。”</p>
<p>于是我又立马写了第二版代码（复制了一份，然后再修改）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">TreeNode createTree(int[] preorder,
</span></span><span class="line"><span class="cl">           int b,
</span></span><span class="line"><span class="cl">           int e,
</span></span><span class="line"><span class="cl">           int[] inorder,
</span></span><span class="line"><span class="cl">           int f,
</span></span><span class="line"><span class="cl">           int t,
</span></span><span class="line"><span class="cl">           Map&lt;Integer, Integer&gt; indexHash) {
</span></span><span class="line"><span class="cl">  if (b &gt;= e) {
</span></span><span class="line"><span class="cl">    return null;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 如果只有一个结点
</span></span><span class="line"><span class="cl">  if (b + 1 == e) {
</span></span><span class="line"><span class="cl">    return new TreeNode(preorder[b]);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 利用根结点来切分中序
</span></span><span class="line"><span class="cl">  final int rootValue = preorder[b];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 找到根结点在中序遍历中的位置
</span></span><span class="line"><span class="cl">  final int rootPos = indexHash.get(rootValue);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 创建根结点
</span></span><span class="line"><span class="cl">  TreeNode root = new TreeNode(rootValue);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 利用在中序遍历中找到的根结点，将数组分为三部分
</span></span><span class="line"><span class="cl">  // 分别计算出左子树与右子树的长度
</span></span><span class="line"><span class="cl">  final int leftLen = rootPos - f;
</span></span><span class="line"><span class="cl">  final int rightLen = t - rootPos - 1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 左子树
</span></span><span class="line"><span class="cl">  // preorder里面左子树的范围 =&gt; [b + 1, b + 1 + leftLlen)
</span></span><span class="line"><span class="cl">  // inorder里面左子树的范围  =&gt; [f, rootPos)
</span></span><span class="line"><span class="cl">  root.left = createTree(
</span></span><span class="line"><span class="cl">    preorder, b + 1, b + 1 + leftLen,
</span></span><span class="line"><span class="cl">    inorder, f, rootPos, indexHash);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 右子树
</span></span><span class="line"><span class="cl">  // preorder右子树的范围 =&gt; [b + 1 + leftLen , e)
</span></span><span class="line"><span class="cl">  // inorder里面右子树的范围 =&gt; [rootPos + 1, t]
</span></span><span class="line"><span class="cl">  root.right = createTree(
</span></span><span class="line"><span class="cl">    preorder, b + 1 + leftLen, e,
</span></span><span class="line"><span class="cl">    inorder, rootPos + 1, t, indexHash);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  return root;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">TreeNode buildTree(int[] preorder, int[] inorder) {
</span></span><span class="line"><span class="cl">  final int N = preorder == null ? 0 : preorder.length;
</span></span><span class="line"><span class="cl">  if (N == 0) {
</span></span><span class="line"><span class="cl">    return null;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // 记录值与index的映射关系
</span></span><span class="line"><span class="cl">  Map&lt;Integer, Integer&gt; indexHash = new HashMap&lt;&gt;();
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">    indexHash.put(inorder[i], i);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  return createTree(preorder, 0, N, inorder, 0, N, indexHash);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>面试官看了代码，觉得没有问题，然后又问了一个问题：“你这样写，空间复杂度是多少？”</p>
<p>我：“最差情况下都是 O(N)。”</p>
<p>面试官：“好的，代码没什么问题。你有什么问题要问我吗？”</p>
<p>于是我拿出我早就准备好的针对这个公司、小组以及职位的问题与面试官进行了一个简短的交流，然后通过了第一轮面试。</p>
<p>X 公司：第二轮</p>
<p>第二轮开始的时候，面试官并没有多说，确认通信正常后（因为是视频面试），不废话，立马开了一道算法题。</p>
<p>面试官：“我们先写一个题吧。在一个数组里面，只有一个数出现了 1 次，其他的数都出现了 2 次，请你把这个数找出来。”</p>
<p>1. 三路切分</p>
<p>我：“这个题可以使用一种三路切分的方法，另外也可以使用位运算的方法。”</p>
<p>面试官：“嗯，我还是第一次听说三路切分的方法，你能详细给我说一下吗？”</p>
<p>我：“原理大概是这样……代码可以这样写……”（这部分内容我们在《08 | 排序：如何利用合并与快排的小技巧，解决算法难题？》“例 4”已经介绍过，这里不再赘述。）</p>
<p>2. bit 计数</p>
<p>面试官：“好的，那你能再说一下位运算的方法吗？”</p>
<p>我：“为了讲解这个原理，我首先采用这样一种方法进行操作。”</p>
<p>思路：一个整数一共有 32 个 bit，那么，我可以统计每个 bit 在数组中出现的次数。由于只有一个数出现了 1 次，其他的数都出现了 2 次。那么在最后的统计结果中，相应 bit 位为奇数的时候，只出现一次的数其 bit 位也必然为 1。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public int singleNumber(int[] nums) {
</span></span><span class="line"><span class="cl">        int[] bitCount = new int[32];
</span></span><span class="line"><span class="cl">        for (long x: nums) {
</span></span><span class="line"><span class="cl">            for (int i = 0; i &lt; 32; i++) {
</span></span><span class="line"><span class="cl">                final long mask = (long)1 &lt;&lt; i;
</span></span><span class="line"><span class="cl">                if ((x &amp; mask) &gt; 0) {
</span></span><span class="line"><span class="cl">                    bitCount[i]++;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        long ans = 0;
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 32; i++) {
</span></span><span class="line"><span class="cl">            // 如果这个位置的bit计数为奇数
</span></span><span class="line"><span class="cl">            // 那么这个bit肯定有只出现一次的那个数的贡献
</span></span><span class="line"><span class="cl">            if ((bitCount[i] &amp; 0x01) == 1) {
</span></span><span class="line"><span class="cl">                ans |= (long)1 &lt;&lt; i;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return (int)ans;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：应该用 long 的地方一定要用 long，否则在位移的时候容易出错。</p>
<p>面试官：“你这个算法的时间复杂度是多少？”</p>
<p>我：“如果是长度为 N 的数组，那么时间复杂度为 O(32N)，空间复杂度为 O(1)。所以可以认为是一个常量空间，线性时间复杂度的算法。”</p>
<p>面试官：“看起来常量的部分有点大，你有什么办法可以优化吗？”</p>
<p>我：“首先，可以优化 bit 位的计数，由于我们最终只是关心统计结果的奇偶性，因此，在某 bit 位的统计结果 &gt;= 2 的时候，我们可以直接减去 2。”</p>
<p>代码可以优化成这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public int singleNumber(int[] nums) {
</span></span><span class="line"><span class="cl">        int[] bitCount = new int[32];
</span></span><span class="line"><span class="cl">        for (long x: nums) {
</span></span><span class="line"><span class="cl">            for (int i = 0; i &lt; 32; i++) {
</span></span><span class="line"><span class="cl">                final long mask = (long)1 &lt;&lt; i;
</span></span><span class="line"><span class="cl">                if ((x &amp; mask) &gt; 0) {
</span></span><span class="line"><span class="cl">                    bitCount[i]++;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // 减去2，因为我们只关心统计结果的奇偶性
</span></span><span class="line"><span class="cl">            for (int i = 0; i &lt; 32; i++) {
</span></span><span class="line"><span class="cl">                if (bitCount[i] &gt;= 2) {
</span></span><span class="line"><span class="cl">                    bitCount[i] -= 2;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        long ans = 0;
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 32; i++) {
</span></span><span class="line"><span class="cl">            // 如果这个位置的bit计数为奇数
</span></span><span class="line"><span class="cl">            if (bitCount[i] == 1) {
</span></span><span class="line"><span class="cl">                ans |= (long)1 &lt;&lt; i;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return (int)ans;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>3. 二进制计数</p>
<p>我：“当然，这还不是最终的版本。我们可以继续优化。因为每个 bit 计数之后，一旦 &gt;= 2 就会减去 2。那么每一位的计数实际上只会有 0，1 两种状态。既然只有 0， 1 两种状态，那么可以考虑使用二进制来表示这个计数结果。”</p>
<p>面试官：“可是这样，你怎么继续进行计数呢？”</p>
<p>我：“可以使用一个整数来表示 bitCount 数组。”</p>
<p>操作原理：我们用两个整数one, two来计数，含义如下：</p>
<p>如果我们将图片稍微旋转一下就得到了下图：</p>
<p>这里可以发现：</p>
<p>one 表示的是每个 bitCount[] 数字的最低 bit 位；</p>
<p>two 表示的是每个 bitCount[] 数字的第 2 个 bit 位。</p>
<p>那么，在累加的时候，我们可以采用这种办法：当 one = 0111, two = 0 的时候，bitCount[] ={0, 1, 1, 1}。假设新来一个数 x = 0b1010，那么可以得到下图：</p>
<p>当然，真正累加的时候，我们也不会一位一位地去加。加法采用如下方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 当one和x相应 bit位都是1的时候，就会产生2个1
</span></span><span class="line"><span class="cl">// 可以认为是产生了进位。
</span></span><span class="line"><span class="cl">int carry = one &amp; x;
</span></span><span class="line"><span class="cl">// 当one与x对应bit一共只有一个1:相应位置需要设置为1.
</span></span><span class="line"><span class="cl">// 当one与x对应bit都为1: 这里的计数结果2已经存放在了
</span></span><span class="line"><span class="cl">//               carry中（相应bit设置为1）。
</span></span><span class="line"><span class="cl">//               one的相应bit需要设置为 0
</span></span><span class="line"><span class="cl">// 当one与x对应bit都为0: one的相应bit需要设置为0。
</span></span><span class="line"><span class="cl">one ^= x;
</span></span><span class="line"><span class="cl">// TODO：这里还需要将two 与进位carry进行相加。
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么，我们可以写出代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public int singleNumber(int[] nums) {
</span></span><span class="line"><span class="cl">        int one = 0;
</span></span><span class="line"><span class="cl">        int two = 0;
</span></span><span class="line"><span class="cl">        for (int x: nums) {
</span></span><span class="line"><span class="cl">            int carry = one &amp; x;
</span></span><span class="line"><span class="cl">            one ^= x;
</span></span><span class="line"><span class="cl">            // TODO: two 需要与carry相加
</span></span><span class="line"><span class="cl">            // TODO: 如果bit位 &gt;= 2，那么我们需要减去2
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 我们只关心奇数位的情况。所以直接返回one即可。
</span></span><span class="line"><span class="cl">        return one;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>不难发现，two 与 carry 相加的结果总是表示偶数个 bit 位。因此 two 和 carry 都可以被设置为 0。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public int singleNumber(int[] nums) {
</span></span><span class="line"><span class="cl">        int one = 0;
</span></span><span class="line"><span class="cl">        int two = 0;
</span></span><span class="line"><span class="cl">        for (int x: nums) {
</span></span><span class="line"><span class="cl">            int carry = one &amp; x;
</span></span><span class="line"><span class="cl">            one ^= x;
</span></span><span class="line"><span class="cl">            two = 0;
</span></span><span class="line"><span class="cl">            carry = 0;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 我们只关心奇数位的情况。所以直接返回one即可。
</span></span><span class="line"><span class="cl">        return one;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们又发现，two 和 carry 变量其实没什么用，还可以再次优化。最终版代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public int singleNumber(int[] nums) {
</span></span><span class="line"><span class="cl">        int one = 0;
</span></span><span class="line"><span class="cl">        for (int x: nums) {
</span></span><span class="line"><span class="cl">            one ^= x;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return one;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>4. 异或运算</p>
<p>写到这里，我又和面试官聊了另外一种思路：那就是利用异或运算的性质。</p>
<p>如果采用这种方法去思考，也可以得到一样的最终版的代码。</p>
<p>面试官：“那我们稍微把这个题目变更一下，假设除一个数字外，其他的数字都出现了 3 次。这个时候，应该怎么办？”</p>
<p>我：“首先，这个题目仍然可以采用”三路切分“的方法。”（具体可参考《08 | 排序：如何利用合并与快排的小技巧，解决算法难题？》“例 4”）。</p>
<p>我：“然后，这个题目还可以继续采用二进制计数的方法，当然，采用 bitCount[] 数组的方法也是可以的，但是采用异或性质的思路就不可以了。因此，三路切分和二进制计数的方法较为通用。”</p>
<p>面试官：“那你能写一下利用二进制的计数方法吗？我想三路切分的方法代码应该没什么变动。”</p>
<p>我：“好的。首先，由于除一个数字外，其他所有的数字都出现了 3 次。因此，bit 位计数的时候，&gt;= 3 的计数都没有意义，只需要记录 0, 1, 2 三种状态。所以，我们仍然只需要两个整数 one 和 two。”</p>
<p>于是，延续之前的思路，可以写出如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public int singleNumber(int[] nums) {
</span></span><span class="line"><span class="cl">        int one = 0;
</span></span><span class="line"><span class="cl">        int two = 0;
</span></span><span class="line"><span class="cl">        for (int x: nums) {
</span></span><span class="line"><span class="cl">            // 产生进位
</span></span><span class="line"><span class="cl">            int carry = one &amp; x;
</span></span><span class="line"><span class="cl">            one ^= x;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            // 计数为2的情况与进位相加
</span></span><span class="line"><span class="cl">            // 如果我们只看某个bit位：
</span></span><span class="line"><span class="cl">            // - 由于我们bit计数的状态只有
</span></span><span class="line"><span class="cl">            //   0, 1, 2
</span></span><span class="line"><span class="cl">            // - 当新来一个bit的时候，
</span></span><span class="line"><span class="cl">            //   最大的计算结果是3
</span></span><span class="line"><span class="cl">            // =&gt; 因此，不可能同时two与carry在某bit
</span></span><span class="line"><span class="cl">            //    都是1的情况
</span></span><span class="line"><span class="cl">            two ^= carry;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            // 当one与two的某个bit位都是1
</span></span><span class="line"><span class="cl">            // 表示计数出现了3
</span></span><span class="line"><span class="cl">            // 我们需要把这个3减掉。
</span></span><span class="line"><span class="cl">            int cnt = one &amp; two;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            // 减掉就是把one和 two对应bit位置00
</span></span><span class="line"><span class="cl">            one &amp;= ~cnt;
</span></span><span class="line"><span class="cl">            two &amp;= ~cnt;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return one;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>这里我还加了一些测试代码。</p>
<p>5. 状态机</p>
<p>我：“当然，这个题还可以进一步优化。”</p>
<p>面试官：“我们还有一点时间，你可以简单地说一下怎么优化吗？”</p>
<p>优化思路：由于所有的 bit 计数都是一样的，所以我们可以把注意力放在某一个 bit 的计数上来操作（尽管一个整数有 32 个 bit，但此时我们只看一个 bit）。</p>
<p>由于状态是有限的（只需要记录 0, 1, 2 三种状态），那么可以采用状态机的思路来直接优化。圆圈表示某个 bit 上的计数结果，由于只有三种状态，所以我们分别用 (00, 01, 10) 来表示。那么当遇到新来的 x（带箭头的线）或为 1，或为 0 的时候，我们可以画出状态跃迁图。</p>
<p>在使用二进制表示的时候，我们用 ones 表示蓝色的 bit 位。twos 表示棕色的 bit 位。那么当遇到新来的 x，我们可以整理出一个表：</p>
<p>然后可以根据这个表得到化简之后的 bool 运算结果，如下图所示：</p>
<p>此时可以写出代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public int singleNumber(int[] nums) {
</span></span><span class="line"><span class="cl">        int ones = 0, twos = 0;
</span></span><span class="line"><span class="cl">        for(int num : nums){
</span></span><span class="line"><span class="cl">            ones = ones ^ num &amp; ~twos;
</span></span><span class="line"><span class="cl">            twos = twos ^ num &amp; ~ones;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">       return ones;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python这里我还加了一些测试代码，由于篇幅原因就不进行展示了。注意：面试遇到简单题，既是机遇，也是挑战。机遇是解题很容易，挑战则是面试官很有可能也会用同样的题目去面别人，想要出彩就需要平时多深度思考。</p>
<p>面试到这里，时间已经过去了一个多小时，面试官又准备问一下项目经历。这一轮时间差不多持续了两个小时以上。</p>
<p>Y 公司：第一轮</p>
<p>这次的面试是在一个茶室里面进行的，一边喝茶一边聊。从生活、工作到兴趣都聊开了。</p>
<p>注意：放松的面试环境非常容易让候选人放下戒备。在这种情况下，一定不要忘记深入地思考面试官提出的每个问题。</p>
<p>面试官看了一下表：“这样吧，我们简单写个题吧？”</p>
<p>我：“好啊。不过这里没有白板，我就在纸上写吧。”</p>
<p>注意：如果是去公司面试，最好带上电脑、纸、笔以及打印好的简历。</p>
<p>于是我拿出了白纸和笔，做好了准备。</p>
<p>面试官：“来个 24 点吧。”</p>
<p>我：“可以啊，就是那种我们平时玩的 24 点吧。为了简单起见，我可以直接用有效整数表示扑克的点数吗？”</p>
<p>面试官：“可以，我们需要把精力重点放在我们需要关注的地方。”</p>
<p>我：“好的，先让我整理一下思路。正常的 24 点会给 4 张卡牌，每个卡牌会用整数来进行表示。”</p>
<p>面试官点了点头。</p>
<p>我问：“那返回值返回什么呢？返回所有的解，还是返回是否有解？”</p>
<p>面试官：“我们先写是否有解吧。”</p>
<p>我：“那你看看这个接口可以吗？”</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">boolean judgePoint24(int[] cards)
</span></span></code></pre></td></tr></table>
</div>
</div><p>面试官：“好的，你能说一下你的思路吗？”</p>
<p>我：“首先，当给定 4 个数的时候，我可以进行如下操作！”</p>
<p>从数组中挑选两个不同的数出来，此时数组中余下 2 个数。</p>
<p>尝试对这两个数进行加减乘除操作。</p>
<p>把操作的结果与余下的 12 个数放一起，构成一个新的数组，这个数组只有 3 个元素。</p>
<p>然后，接着处理给定输入有 3 个数的时候：</p>
<p>从数组中挑选两个不同的数出来，此时数组中余下 1 个数；</p>
<p>尝试对这两个数进行加减乘除操作；</p>
<p>把操作的结果与余下的 1 个数放一起，构成一个新的数组，这个数组只有 2 个元素。</p>
<p>然后，接着处理给定的输入只有 2 个数的时候：</p>
<p>从数组中挑选两个不同的数出来，此时数组中余下 0 个数；</p>
<p>尝试对这两个数进行加减乘除操作；</p>
<p>把操作的结果与余下的 0 个数放一起，构成一个新的数组，这个数组只有 1 个元素。</p>
<p>最后，只需要处理输入的数，如果只有一个数，那么判断这个数是否是 24 即可。</p>
<p>面试官：“你打算就这样写代码吗？”</p>
<p>我：“当然不是。由于这个过程问题规模是在不断变小的，所以我们可以使用 DFS 来求解。”</p>
<p>于是我先在纸上写了伪代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">boolean judgePoint24(int[] cards) {
</span></span><span class="line"><span class="cl">  if cards只有一个数 and cards[0] == 24:
</span></span><span class="line"><span class="cl">      return true;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  for x in cards:
</span></span><span class="line"><span class="cl">      for y in cards:
</span></span><span class="line"><span class="cl">          if x != y:
</span></span><span class="line"><span class="cl">             ans = 利用x, y进行加/减/乘/除)
</span></span><span class="line"><span class="cl">             newCards = [ans, cards.remove(x,y)]
</span></span><span class="line"><span class="cl">             if judgePoint24(newCards):
</span></span><span class="line"><span class="cl">                 return true;
</span></span><span class="line"><span class="cl">  return false;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：如果你打算写伪代码，一定要给面试官明确地说明这不是最终版本的代码，而是伪代码！</p>
<p>面试官：“伪代码看起来没什么问题，你可以开始写了。”</p>
<p>我：“好。”</p>
<p>在纸上写代码的时候，由于涂改，容易把卷面弄得很难看。写完之后我看还有时间，就又把代码重新抄了一遍，再在另外一张纸上加了测试代码。</p>
<p>如果你也是在纸上写代码，那么强烈建议你重新抄一遍。因为大部分纸上手写代码都非常难看，再加上涂改，简直不能直视。</p>
<p>最终我交上了这么一份代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 将cards中的cards[i], cards[j] 经过某种运算之后 生成了value
</span></span><span class="line"><span class="cl">// 然后生成一个新的数组
</span></span><span class="line"><span class="cl">double[] getNextCards(double[] cards, int i, int j, double v) {
</span></span><span class="line"><span class="cl">  final int N = cards.length;
</span></span><span class="line"><span class="cl">  double[] ans = new double[N - 1];
</span></span><span class="line"><span class="cl">  int to = 0;
</span></span><span class="line"><span class="cl">  for (int k = 0; k &lt; N; k++) {
</span></span><span class="line"><span class="cl">    if (k != i &amp;&amp; k != j) {
</span></span><span class="line"><span class="cl">      ans[to++] = cards[k];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  ans[to++] = v;
</span></span><span class="line"><span class="cl">  return ans;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// 判断是否达到了答案，注意浮点数的判断
</span></span><span class="line"><span class="cl">boolean isResult(double value) {
</span></span><span class="line"><span class="cl">  if (Math.abs(value - 24.0) &lt; 1e-6) {
</span></span><span class="line"><span class="cl">    return true;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return false;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">boolean notZero(double value) {
</span></span><span class="line"><span class="cl">  return Math.abs(value) &gt; 1e-6;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">boolean judge(double[] cards) {
</span></span><span class="line"><span class="cl">  if (cards == null) {
</span></span><span class="line"><span class="cl">    return false;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  final int N = cards.length;
</span></span><span class="line"><span class="cl">  // 如果已经只有一个数了，那么检查一下看看是否
</span></span><span class="line"><span class="cl">  // 是24
</span></span><span class="line"><span class="cl">  if (N == 1) {
</span></span><span class="line"><span class="cl">    return isResult(cards[0]);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  // 否则我们挑两个数，进行加减乘除
</span></span><span class="line"><span class="cl">  // 其中加法和乘法没有交换的必要
</span></span><span class="line"><span class="cl">  // 所以我们只需要check两个就可以了
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">    for (int j = i + 1; j &lt; N; j++) {
</span></span><span class="line"><span class="cl">      if (judge(getNextCards(cards, i, j,
</span></span><span class="line"><span class="cl">                cards[i] + cards[j])) || /* 加法 */
</span></span><span class="line"><span class="cl">          judge(getNextCards(cards, i, j,
</span></span><span class="line"><span class="cl">                cards[i] * cards[j])) || /* 乘法 */
</span></span><span class="line"><span class="cl">          notZero(cards[j]) &amp;&amp;
</span></span><span class="line"><span class="cl">            judge(getNextCards(cards, i, j,
</span></span><span class="line"><span class="cl">                  cards[i] / cards[j])) || /* 除法 */
</span></span><span class="line"><span class="cl">          notZero(cards[i]) &amp;&amp;
</span></span><span class="line"><span class="cl">            judge(getNextCards(cards, i, j,
</span></span><span class="line"><span class="cl">                  cards[j] / cards[i])) || /* 除法 */
</span></span><span class="line"><span class="cl">          judge(getNextCards(cards, i, j,
</span></span><span class="line"><span class="cl">                cards[i] - cards[j])) || /* 减法 */
</span></span><span class="line"><span class="cl">          judge(getNextCards(cards, i, j,
</span></span><span class="line"><span class="cl">                cards[j] - cards[i]))    /* 减法 */
</span></span><span class="line"><span class="cl">      ) {
</span></span><span class="line"><span class="cl">        return true;
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return false;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">boolean judgePoint24(int[] cards) {
</span></span><span class="line"><span class="cl">  if (cards == null) {
</span></span><span class="line"><span class="cl">    return false;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  double[] dCards = new double[cards.length];
</span></span><span class="line"><span class="cl">  int to = 0;
</span></span><span class="line"><span class="cl">  for (int x : cards) {
</span></span><span class="line"><span class="cl">    dCards[to++] = x;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return judge(dCards);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>后面我还加了一系列测试代码。你在面试的时候，一定要记得主动写测试代码。</p>
<p>面试官：“你为什么用 isResult 和 notZero 这两个函数？”</p>
<p>我：“因为 double 在表示浮点数的时候，存在精度损失的情况，为了处理这两种情况，我用了 1e-6 作为边界判断两个数是否相等。”</p>
<p>面试官又仔细看了看代码，觉得没什么问题，然后就开始进行下一个话题的交流了。</p>
<p>面试的收尾</p>
<p>一般而言，大部分公司的算法面试结束之后，都会留一个提问环节。这里我们主要介绍这个环节需要注意地方。</p>
<p>提问的建议</p>
<p>我们的目的是求职，因此可以通过提问尽可能多地拿到关于这个职位、部门以及公司的信息。</p>
<p>由于大部分公司的面试都是将经理、部门负责人安排在后面。因此，这里我分享一下自己的策略（与战争进行一个类比）。</p>
<p>前两轮会侧重于当前面试的职位信息。尽量得出你在战场中的位置，你是前锋攻坚？后勤保障？还是辅助打野？</p>
<p>中间的轮次侧重于当前职位在整个部门里面的位置，能够发挥的作用，以及将要展开的项目等。得到整个部门在一场大会战中的位置，是第一梯队的部门吗？这是一个处在人员优化的部门吗？</p>
<p>后面的轮次侧重于部门在公司的位置、作用以及发展计划。公司每场“战斗”这个部门的参与率如何？这个部门以后还会发展吗？会独当一面成为封疆大吏吗？</p>
<p>工作节奏：如果关心工作节奏，那么也可以在技术面试中直接大方地提出来。简单直接有效地拿到一手信息。比如正常情况下的工作时间是什么样的？是否严格打卡？</p>
<p>绩效：每个公司都会有不同的方法来评定绩效。因此，我们应该认真地去拿到绩效评定的信息，这样才知道将来要努力工作的方向。</p>
<p>因此，提问的时候，主要是将这些信息进行整合和总结，然后得出职位的整体情况。</p>
<p>不建议提的问题</p>
<p>算法面试结束之后，我们总结一下不建议提的问题。</p>
<p>薪水：大部分时候，薪水都是由 HR 部门来决策的。无论是经理，还是技术人员，他们的作用就是根据你的面试情况进行打分。HR 会根据这个分数评定你的薪资水平。</p>
<p>结果：面试结束之后，不应该去问“我这一轮面试过了吗？”原因在于，大多数情况是很多人面试一个职位。公司在人员选择时，会将所有通过面试的人进行一轮排序，然后再取出 Top1, Top2 来发放 Offer。如果 Top1 拒绝，那么会给 Top2 发放 Offer。正确的心态是：好好总结，认真准备即将到来的下一场面试！</p>
<p>算法题的答案：写完题的最后环节，不应该再纠缠于前面的算法题了。你应该更多地围绕职位、部门以及公司进行提问。否则，万一通过面试入职之后，发现做的事情与心里预期不一样，岂不是很亏？</p>
<p>换组/换部门：一般而言，公司内部都是允许换组、换部门的。但是，应该没有一个部门会花时间帮其他部门招人，因为最好不要问这类问题。</p>
<p>关于面试时如何提问，如果你还有其他建议或者补充，也可以放在留言区，我们相互学习，一起讨论。</p>
<p>总结</p>
<p>在这一讲里，我们一起回顾了一段面试过程，我把这部分的内容整理在一个思维导图里方便你复习，也希望能够助力你求职成功，拿到心仪的 Offer。</p>
<p>此外，我还给你留了一个要特别注意的点：实事求是。如果用大白话来说就是：懂的就懂，不懂的就直接说不懂。</p>
<p>不要套路面试官，然后尝试一点一点往正确的答案上靠！</p>
<p>接下来，假设我是一个面试官，我抛出了一个问题：“给你一棵树，和两个结点，请输出这两个点的距离。”</p>
<p>所以这一讲留给你的作业就是：</p>
<p>你应该怎么进行沟通？</p>
<p>你应该如何写代码？</p>
<p>你应该如何写测试？</p>
<p>这一讲就到这里，也欢迎在留言区分享你面试经历，遇到过哪些难以解决的问题？我们一起讨论。下一讲我将和你聊一聊算法的精进之路。</p>
<p>-&ndash; ### 精选评论 ##### *中： &gt; 老师你好,算法题当时精通了,隔两周就忘了 咋办 ######     讲师回复： &gt;     允许我调皮一下。你这个叫看懂，不叫精通。（其实我以前也有这个毛病）我是通过两个方法来解决的。1. 深度思考。如果我真的看懂了一个题。接下来需要去想，a. 题目的特点是什么？为什么会用这个方法可以解决？为什么用别的方法不行？b. 有类似的题目吗？与别的题目的联系是什么？c.这个题的通用解是什么？是一个模板吗？2.尽量与自己整理的模板产生关系。如果没有和你整理的模板关生联系的题目，实际上是一个知识的孤岛，的确是很容易遗忘的。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">数据结构与算法面试宝典</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/24%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%87%8F%E8%BD%BB%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%B4%9F%E6%8B%85/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">24怎么减少内存使用减轻内存管理负担</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kubernetes%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/24%E8%B0%83%E5%BA%A6%E5%BC%95%E6%93%8Ekubernete%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%B0%83%E5%BA%A6pod/">
            <span class="next-text nav-default">24调度引擎：Kubernete如何高效调度Pod？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
