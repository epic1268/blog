<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>15 字符串查找：为什么我最终选择了BM算法？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="这一模块我会带你挖掘题目的特点，再对标不同的数据结构与算法，从而得出不同的解法。虽然我们只介绍一道题，但是解题的方法却有很多种，我会带你尝试从不同的角度去击破一道题。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/15-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E6%9C%80%E7%BB%88%E9%80%89%E6%8B%A9%E4%BA%86bm%E7%AE%97%E6%B3%95/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/15-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E6%9C%80%E7%BB%88%E9%80%89%E6%8B%A9%E4%BA%86bm%E7%AE%97%E6%B3%95/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="15 字符串查找：为什么我最终选择了BM算法？">
  <meta property="og:description" content="这一模块我会带你挖掘题目的特点，再对标不同的数据结构与算法，从而得出不同的解法。虽然我们只介绍一道题，但是解题的方法却有很多种，我会带你尝试从不同的角度去击破一道题。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="数据结构与算法面试宝典">

  <meta itemprop="name" content="15 字符串查找：为什么我最终选择了BM算法？">
  <meta itemprop="description" content="这一模块我会带你挖掘题目的特点，再对标不同的数据结构与算法，从而得出不同的解法。虽然我们只介绍一道题，但是解题的方法却有很多种，我会带你尝试从不同的角度去击破一道题。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="12526">
  <meta itemprop="keywords" content="数据结构与算法面试宝典">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="15 字符串查找：为什么我最终选择了BM算法？">
  <meta name="twitter:description" content="这一模块我会带你挖掘题目的特点，再对标不同的数据结构与算法，从而得出不同的解法。虽然我们只介绍一道题，但是解题的方法却有很多种，我会带你尝试从不同的角度去击破一道题。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">15 字符串查找：为什么我最终选择了BM算法？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 12526 字 </span>
          <span class="more-meta"> 预计阅读 26 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>这一模块我会带你挖掘题目的特点，再对标不同的数据结构与算法，从而得出不同的解法。虽然我们只介绍一道题，但是解题的方法却有很多种，我会带你尝试从不同的角度去击破一道题。</p>
<p>关于字符串查找，可以说是一类非常经典的面试题，它可以考察候选人多方面的技能，比如代码基本功、深度思考能力，以及知识广度等。</p>
<p>代码基本功：需要注意各种空字符串，数组访问越界等边界的处理。</p>
<p>深度思考能力：各种字符串查找的算法代码本身不会太长，但是需要你深入理解其原理才能正确地写代码，并且清晰地讲述思路。</p>
<p>知识广度：字符串查找涉及很多种算法，可以借此了解候选人的知识积累。</p>
<p>在本讲，将以一道字符串查找的面试题为引，带你深入探索“一题多解”的思考方式，有利于你掌握快速审题和解题的能力。具体来说，学完本讲你将收获：</p>
<p>暴力搜索算法与本质</p>
<p>KMP 算法的改进与扩展</p>
<p>BM 算法</p>
<p>Sunday 算法</p>
<p>字符串查找</p>
<p>【题目】实现 strStr() 函数。给定一个 main 字符串和一个 sub 字符串，在 main 字符串中找出 sub 字符串出现的第一个位置 （从 0 开始）。如果不存在，则返回 -1。</p>
<p>示例 1</p>
<p>输入: main = &ldquo;hello&rdquo;, sub = &ldquo;ll&rdquo;</p>
<p>输出: 2</p>
<p>注意：有的文章也把 sub 字符串称为 pattern字符串（模式串）。</p>
<p>暴力查找算法</p>
<p>如果你在面试的时候，拿到这道题没有任何思路，可以先选择一个暴力求解的方法。具体思路就是把每一个 main 字符串都当成一个潜在的起始位置，然后依次向后匹配。</p>
<p>这里我们用一个例子说明一下暴力查找算法的思路。注意，图中较长的字符串为主串 main，较短的字符串为子串 sub。</p>
<p>基于这样的思路，我们可以写出代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public int strStr(String main, String sub) {
</span></span><span class="line"><span class="cl">        if (sub == null || sub.length() == 0) {
</span></span><span class="line"><span class="cl">            return 0;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if (main == null || main.length() == 0) {
</span></span><span class="line"><span class="cl">            return -1;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 采用暴力匹配的方式
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; main.length(); i++) {
</span></span><span class="line"><span class="cl">            boolean hasFind = true;
</span></span><span class="line"><span class="cl">            // 那么从头开始匹配sub
</span></span><span class="line"><span class="cl">            for  (int j = 0; j &lt; sub.length(); j++) {
</span></span><span class="line"><span class="cl">                if (i + j &gt;= main.length() ||
</span></span><span class="line"><span class="cl">                    main.charAt(i+j) != sub.charAt(j)) {
</span></span><span class="line"><span class="cl">                    // 如果无法匹配或者说匹配失败
</span></span><span class="line"><span class="cl">                    hasFind = false;
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            if (hasFind) {
</span></span><span class="line"><span class="cl">                return i;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：最坏情况下时间复杂度为O(N×M)，其中 N 为 main 字符串的长度，M 为 sub 字符串的长度。空间复杂度为 O(1)。</p>
<p>【分析】首先我们分析一下这种方法的缺点：时间复杂度高，如果字符较长，不能快速定位。</p>
<p>那么这种算法有没有优点呢？实际上还是有的：</p>
<p>实现简单；</p>
<p>不需要额外空间，在字符串较短的情况下，算法的运行速度很快；</p>
<p>大部分时候，我们处理的都是较短的字符串。</p>
<p>虽然其他一些算法是线性时间复杂度，但是由于需要开辟额外的内存空间，在一定情况下：</p>
<p>涉及内存申请与释放，内存的申请与释放都会带来较大的时间开销；</p>
<p>可能触发带内存 GC 语言的内存垃圾回收，导致程序运行速度变得更慢。</p>
<p>为了避免申请内存，Java 语言内置的 IndexOf 方法的实现就是采用的这种思路。我们在面试的时候，除了要把代码写对，还需要亮出更多手中的“法宝”，向面试官展示出自己的优势。比如：</p>
<p>指出这种算法实现的优点和缺点；</p>
<p>什么情况下用这种算法？什么情况下不应该用？</p>
<p>在面试中，如果你仅是把暴力的方法写对，很有可能还是不能通过面试。因为：</p>
<p>字符串查找题目，用暴力方法写对的人~~实在太多了= =。</p>
<p>KMP 算法</p>
<p>接下来我们讨论 KMP 算法。如果你以前在学习 KMP 算法的过程中，觉得很难，或者说压根看不懂。相信我，这不是你的错。因为学习 KMP 算法需要一些前置知识，在这里，我们就将这些前置知识讲透。</p>
<p>只要你跟着我的思路，一步一步思考，学完本讲肯定能看懂 KMP 。</p>
<p>前缀与前缀集</p>
<p>首先我们要学习的第一个概念是前缀，一个长度为 N 的字符串 S 的前缀需要满足如下条件：</p>
<p>非空</p>
<p>不是 S 自身</p>
<p>是包含 S[0] 的连续子串</p>
<p>比如，给定一个字符串 S = &ldquo;ABC&rdquo;，那么所有的前缀有：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;A&#34;,
</span></span><span class="line"><span class="cl">  &#34;AB&#34;,
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们把所有前缀放到一个集合中，就构成了字符串的前缀集。</p>
<p>后缀与后缀集</p>
<p>第二个概念是后缀，一个长度为 N 的字符串 S 的后缀需要满足如下条件：</p>
<p>非空</p>
<p>不是 S 自身</p>
<p>是包含最后一个字符 S[N-1] 的连续子串</p>
<p>比如，给定一个字符串 S = &ldquo;ABC&rdquo;，那么所有的后缀有：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;C&#34;,
</span></span><span class="line"><span class="cl">  &#34;BC&#34;,
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们把所有后缀放到一个集合中，就构成了字符串的后缀集。</p>
<p>前后缀的最长匹配</p>
<p>给定一个字符串，我们想知道它的前缀集和后缀集里面最长且相同的字符串是什么，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">S = &#34;ababa&#34;;
</span></span><span class="line"><span class="cl">前缀集 = {
</span></span><span class="line"><span class="cl">  &#34;a&#34;,
</span></span><span class="line"><span class="cl">  &#34;ab&#34;,
</span></span><span class="line"><span class="cl">  &#34;aba&#34;,
</span></span><span class="line"><span class="cl">  &#34;abab&#34;,
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">后缀集 = {
</span></span><span class="line"><span class="cl">  &#34;a&#34;,
</span></span><span class="line"><span class="cl">  &#34;ba&#34;,
</span></span><span class="line"><span class="cl">  &#34;aba&#34;,
</span></span><span class="line"><span class="cl">  &#34;baba&#34;,
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么两个集合的交集就是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">前后缀的交集 = {
</span></span><span class="line"><span class="cl">  &#34;a&#34;,
</span></span><span class="line"><span class="cl">  &#34;aba&#34;,
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们还需要在这个交集里面找到最长的字符串，就是 &ldquo;aba&rdquo;，这里我们称为前后缀的最长匹配。</p>
<p>PMT 表（Partial Match Table）</p>
<p>PMT 表（本质上就是一个数组）中的每一项 PMT[i]，表示的是一个字符串 S[0..i] 的前后缀的最长匹配的长度。这里我可以用如下操作表示 PMT 表的含义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">S = &#34;abababca&#34;; // ab重复3次再加上一个ca
</span></span><span class="line"><span class="cl">PMT[0] = 前后缀的最长匹配(S[0]= &#34;a&#34;) = &#34;&#34; = 0
</span></span><span class="line"><span class="cl">PMT[1] = 前后缀的最长匹配(S[0..1]= &#34;ab&#34;) = &#34;&#34; = 0
</span></span><span class="line"><span class="cl">PMT[2] = 前后缀的最长匹配(S[0..2]= &#34;aba&#34;) = &#34;a&#34; = 1
</span></span><span class="line"><span class="cl">PMT[3] = 前后缀的最长匹配(S[0..3]= &#34;abab&#34;) = &#34;ab&#34; = 2
</span></span><span class="line"><span class="cl">PMT[4] = 前后缀的最长匹配(S[0..4] = &#34;ababa&#34;) = &#34;aba&#34; = 3
</span></span><span class="line"><span class="cl">PMT[5] = 前后缀的最长匹配(S[0..5] = &#34;ababab&#34;) = &#34;abab&#34; = 4
</span></span><span class="line"><span class="cl">PMT[6] = 前后缀的最长匹配(S[0..6] = &#34;abababc&#34;) = &#34;&#34; = 0
</span></span><span class="line"><span class="cl">PMT[6] = 前后缀的最长匹配(S[0..6] = &#34;abababca&#34;) = &#34;a&#34; = 1
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：PMT[i] 求的就是字符串 S[0..i]的前后缀的最长匹配。所以，字符串 S = &ldquo;abababca&rdquo; 的 PMT 表如下：</p>
<p>PMT 的用途</p>
<p>现在你已经知道了 PMT 表的定义，以及如何计算 PMT 表。但直接根据定义来计算，复杂度有点高。不过没关系，我们后面马上就会介绍如何高效地计算 PMT 表。</p>
<p>在这之前，我先介绍一下 PMT 表的用途。重要的话说三遍：</p>
<p>PMT 表的用途是解开 KMP 算法的关键！</p>
<p>PMT 表的用途是解开 KMP 算法的关键！</p>
<p>PMT 表的用途是解开 KMP 算法的关键！</p>
<p>那么，PMT 表到底能用来做什么呢？我们再来看一下暴力算法中可以优化的地方。比如，要在字符串 main = &ldquo;ababdababc&rdquo; 中找到 sub=&ldquo;ababc&rdquo;。</p>
<p>第 1 轮比较时，会在 main[4] 处比较 (&rsquo;d&rsquo; != &lsquo;c&rsquo;) 失败。如下图所示：</p>
<p>进行第 2 轮比较时，会在 main[1] 处比较 (&lsquo;b&rsquo; != &lsquo;a&rsquo;) 失败。如下图所示：</p>
<p>进行第 3 轮比较时，会在 main[4] 处比较 (&rsquo;d&rsquo; != &lsquo;a&rsquo;) 失败。如下图所示：</p>
<p>接下来，进行第 4 轮比较时，会在 main[3] 处比较 (&lsquo;b&rsquo; != &lsquo;a&rsquo;)失败。如下图所示：</p>
<p>进行第 5 轮比较时，会在 main[4] 处比较 (&rsquo;d&rsquo; != &lsquo;a&rsquo;) 失败。凡是比较失败下标小于 4 的情况，都是无效比较（比如第 2 轮，第 4 轮）。因为这种比较还没有跑到 main[4] 就挂了（第 2 轮挂在 main[1]，第 4 轮挂在 main[3]）。</p>
<p>如果我们只看有效比较（第 1 轮、第 3 轮、第 5 轮），然后分别观察字符串已经匹配的部分，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">第1轮匹配成功的部分是: &#34;abab&#34;
</span></span><span class="line"><span class="cl">第3轮匹配成功的部分是：&#34;ab&#34;
</span></span><span class="line"><span class="cl">第5轮匹配成功的部分是: &#34;&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>联系前面讲到的前后缀的最长匹配知识，可以发现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34;abab&#34;的前后缀最长匹配为&#34;ab&#34;
</span></span><span class="line"><span class="cl">&#34;ab&#34;的前后缀最长匹配为&#34;&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>因此，我们可以总结出一个规律：当某个匹配位置失败，进行下一次比较时，取已经匹配成功部分的“前后缀的最长匹配”即可。这样，比较时就能够从第 1 轮，直接跳到第 3 轮，然后再从第 3 轮直接跳到第 5 轮。如下图所示：</p>
<p>到这里，就可以发现 PMT 表的作用了。我们先给出 sub=&ldquo;ababc&rdquo; 字符串的 PMT 表，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34;abab&#34;的前后缀最长匹配 = &#34;ab&#34; = PMT[3] = 2
</span></span><span class="line"><span class="cl">&#34;ab&#34;的前后缀最长匹配 = &#34;&#34; = PMT[1] = 0
</span></span></code></pre></td></tr></table>
</div>
</div><p>结合 PMT 表，还可以发现，当在 sub[j] 位置比较失败，下一个可能成功的比较位置就是 PMT[j-1]。</p>
<p>因此，经过前面的分析，我们总算弄明白了 PMT 表的作用。就是：</p>
<p>比较失败的时候，可以利用 PMT 表迅速地转到下一个有可能成功的比较上。直接跳过一些无效比较。</p>
<p>当我们有 PMT 表的时候，就可以跳过无效比较的代码写出如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">i = 0
</span></span><span class="line"><span class="cl">j = 0
</span></span><span class="line"><span class="cl">while i &lt; main.length() and j &lt; sub.length():
</span></span><span class="line"><span class="cl">  if main[i] == sub[j]:
</span></span><span class="line"><span class="cl">    i++
</span></span><span class="line"><span class="cl">    j++
</span></span><span class="line"><span class="cl">  else:
</span></span><span class="line"><span class="cl">    j = pmt[j-1] // &lt;-- 出错了!
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是这样写，会在 j = pmt[j-1] 这里出错，原因在于 j 是可以取 0 的。并且，当 j = 0 的时候，如果比较失败，应该移动 i。</p>
<p>所以正确的代码应该写成如下（是的，还不用关心 pmt 数组怎么算的）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int strStr(String main, String sub) {
</span></span><span class="line"><span class="cl">    int i = 0;
</span></span><span class="line"><span class="cl">    int j = 0;
</span></span><span class="line"><span class="cl">    final int alen = main.length();
</span></span><span class="line"><span class="cl">    final int blen = sub.length();
</span></span><span class="line"><span class="cl">    int[] PMT = buildPMT(sub);
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    while (i &lt; alen &amp;&amp; j &lt; blen) {
</span></span><span class="line"><span class="cl">      if (main.charAt(i) == sub.charAt(j)) {
</span></span><span class="line"><span class="cl">        // 如果匹配成功，那么向前走
</span></span><span class="line"><span class="cl">        // 这里和暴力的方法没有区别
</span></span><span class="line"><span class="cl">        i++;
</span></span><span class="line"><span class="cl">        j++;
</span></span><span class="line"><span class="cl">      } else {
</span></span><span class="line"><span class="cl">        // 如果匹配失败，我们这里要跳过一些无效的比较
</span></span><span class="line"><span class="cl">        if (j == 0) {
</span></span><span class="line"><span class="cl">          // 这里需要移动i
</span></span><span class="line"><span class="cl">          i++;
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">          // 跳过无效的比较!
</span></span><span class="line"><span class="cl">          j = PMT[j-1];
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    // 看一下是不是匹配完了
</span></span><span class="line"><span class="cl">    return j == blen ? i - blen : -1;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度为 O(N + M)，其中 N 表示 main 字符串的长度，而 M 表示 sub 字符串的长度。空间复杂度为 O(M)。</p>
<p>next 数组怎么来的？</p>
<p>你可能会问：我们学的 KMP 算法里面都是有 next 数组，为什么你这里只有 PMT 数组？</p>
<p>其实关键在于这里面有一个优化。因为每次访问 pmt[] 数组的时候，都是用 pmt[j-1]。每次访问的时候，都还需要 j-1，因此多了一个减法。那么有没有办法把这个减法给节省掉？</p>
<p>为了节省运算量，我们在 pmt[] 数组的前面插一个数 -1。</p>
<p>那么就形成了 next 数组。既然有了这样一个数组，比较的代码就可以更改 2 个匹配失败的地方，如下图所示：</p>
<p>更改之后的代码就变成如下的样子（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int strStr(String main, String sub) {
</span></span><span class="line"><span class="cl">    int i = 0;
</span></span><span class="line"><span class="cl">    int j = 0;
</span></span><span class="line"><span class="cl">    final int alen = main.length();
</span></span><span class="line"><span class="cl">    final int blen = sub.length();
</span></span><span class="line"><span class="cl">    int[] next = buildNext(sub); // &lt;-- pmt[]的前面加一个-1形成next
</span></span><span class="line"><span class="cl">    while (i &lt; alen &amp;&amp; j &lt; blen) {
</span></span><span class="line"><span class="cl">        if (-1 == j || main.charAt(i) == sub.charAt(j)) {
</span></span><span class="line"><span class="cl">            // 如果匹配成功，那么向前走
</span></span><span class="line"><span class="cl">            // 这里和暴力的方法没有区别
</span></span><span class="line"><span class="cl">            i++;
</span></span><span class="line"><span class="cl">            j++;
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            j = next[j];
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 看一下是不是匹配完了
</span></span><span class="line"><span class="cl">    return j == blen ? i - blen : -1;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>next 数组的计算</p>
<p>讲完主程序之后，接下来我们应该看一下如何计算 sub 字符串的 next 数组。首先应该考虑整个字符串的最后一步，也就是找整个字符串的前后缀的最长匹配。</p>
<p>我们分 4 个阶段进行讲解：</p>
<p>暴力方法</p>
<p>跳过无效比较方法 1</p>
<p>跳过无效比较方法2</p>
<p>写代码</p>
<p>第一个阶段：暴力方法</p>
<p>暴力方法的思路是：不停地移动字符串的前缀，从最长的可能开始暴力比较。那么当字符串为 sub = &ldquo;ababc&rdquo; 的时候，匹配过程如下：</p>
<p>我们很快可以发现，暴力的比较过程，和我们最开始的字符串暴力算法非常类似。</p>
<p>优化暴力算法的思路就是跳过一些无效比较。</p>
<p>第二阶段：跳过无效比较方法 1</p>
<p>那么这里是否可以跳过一些无效比较呢？（提示，借助 PMT 的思路）</p>
<p>很快，我们应该可以发现，在第 2 轮比较的时候，当得到已经匹配的字符串为 &ldquo;ab&rdquo; 时，PMT[&ldquo;ab&rdquo;] = 0。此时，下一轮比较的时候，应该直接从 j = 0 开始。也就是如下图所示的地方：</p>
<p>我们可以直接把第 3 轮给跳过。所以当我们计算 PMT[&ldquo;ababc&rdquo;] 的时候，需要依赖P MT[&ldquo;ab&rdquo;]。这就形成了一个子问题。</p>
<p>第三阶段：跳过无效比较方法 2</p>
<p>首先我们看一种运气好的情况：</p>
<p>已知：在左边，我们找到了字符串 &ldquo;abab&rdquo; 的前后缀的最长匹配“ab&quot;（长度为 2）。那么当我们再去求字符串 &ldquo;ababa&rdquo; 的前后缀的最长匹配的时候，直接往后延伸一位就可以了。</p>
<p>我们利用反证法进行证明。</p>
<p>条件：字符串 &ldquo;abab&rdquo; 的前后缀的最长匹配&quot;ab&quot;（长度为 2）成立。</p>
<p>并且假设 &ldquo;ababa&rdquo;，相比在 &ldquo;abab&rdquo; 的基础上直接延伸，还有更长的“前后缀的最长匹配”。</p>
<p>观察下图展示的结果，假设框中的区域为相等的部分（不管问号存在的这种情况，并且它们是相等的）。</p>
<p>但是，如果存在这种更长的情况。导致的结果就是：绿色线框中的内容肯定是相等的。</p>
<p>如果绿色线框中的内容相等，那么 &ldquo;abab&rdquo; 的前后缀的最长匹配长度就是 3。这样与我们给定的条件矛盾。</p>
<p>实际上，就算是运气差的时候，我们也只需要：直接延伸一位就可以了。这种情况也是可以用完全一样的反证法来证明。那么如下图所示，我们可以把第 1 轮直接跳过。</p>
<p>第四阶段：写代码</p>
<p>我们发现，实际上最后一步的情况只有两种：</p>
<p>直接延伸一位，并且延伸之后相等，那么 last_len = 之前匹配的长度 + 1；</p>
<p>直接延伸一位，并且延伸之后不相等，那么下一个比较位置就是转到 pmt[j-1]。</p>
<p>但是，我们又发现：每次匹配成功的时候，有如下图所示的这个规律：</p>
<p>左边，需要记录 PMT[&ldquo;abab&rdquo;] = 前后缀最长匹配长度 = 2 = j + 1，此时 j = 1；</p>
<p>右边，需要记录 PMT[&ldquo;ababa&rdquo;] = 前后缀最长匹配长度 = 3 = j + 1，此时 j=2。</p>
<p>匹配失败的时候:</p>
<p>1）当 j=0 的时候，j 已经不能再退了，所以需要移动 i；</p>
<p>2）当 j &gt; 0 的时候，我们还可以再往回退，于是设置 j = PMT[j-1]。</p>
<p>并且，PMT[x] 里面的所有字符串 x，都是字符串截取了 sub 字符串位置 [0, &hellip;, len(x)-1]。由于这个范围的左端点总是 0，所以我们只需要记录这个范围的右端点就可以了，即用PMT[len(x)-1] 表示 PMT[x]。</p>
<p>那么，我们就可以得到如下代码（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int[] buildPMT(String sub) {
</span></span><span class="line"><span class="cl">  final int N = sub == null ? 0 : sub.length();
</span></span><span class="line"><span class="cl">  int[] PMT = new int[N];
</span></span><span class="line"><span class="cl">  int i = 1;
</span></span><span class="line"><span class="cl">  int j = 0;
</span></span><span class="line"><span class="cl">  PMT[0] = 0;
</span></span><span class="line"><span class="cl">  while (i &lt; N) {
</span></span><span class="line"><span class="cl">    if (sub.charAt(i) == sub.charAt(j)) {
</span></span><span class="line"><span class="cl">      // 当相等的时候，
</span></span><span class="line"><span class="cl">      i++;
</span></span><span class="line"><span class="cl">      j++;
</span></span><span class="line"><span class="cl">      PMT[i - 1] = j;
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">      if (0 == j) {
</span></span><span class="line"><span class="cl">        // 如果匹配失败，并且j已经为0
</span></span><span class="line"><span class="cl">        // 那么
</span></span><span class="line"><span class="cl">        i++;
</span></span><span class="line"><span class="cl">        PMT[i - 1] = 0;
</span></span><span class="line"><span class="cl">      } else {
</span></span><span class="line"><span class="cl">        j = PMT[j - 1];
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return PMT;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>实际上，这部分代码与我们最开始用 PMT 表来求字符串匹配的代码非常像。访问所有 pmt[] 数组里面的元素的时候，都是用 pmt[i-1] 和 pmt[j-1]。每次访问都需要做 1 次减法，当时我们采用的优化方法是：引入 next 数组。那么同样的，这里也可以引入 next 数组。</p>
<p>最终求解 next 数组的代码就可以表示如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int[] buildNext(String sub) {
</span></span><span class="line"><span class="cl">    final int N = sub == null ? 0 : sub.length();
</span></span><span class="line"><span class="cl">    int[] next = new int[N + 1];
</span></span><span class="line"><span class="cl">    int i = 0;
</span></span><span class="line"><span class="cl">    int j = -1;
</span></span><span class="line"><span class="cl">    next[0] = -1;
</span></span><span class="line"><span class="cl">    while (i &lt; N) {
</span></span><span class="line"><span class="cl">        if (j == -1 || sub.charAt(i) == sub.charAt(j)) {
</span></span><span class="line"><span class="cl">            i++;
</span></span><span class="line"><span class="cl">            j++;
</span></span><span class="line"><span class="cl">            next[i] = j;
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            j = next[j];
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return next;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：由于 next 数组是在 pmt 数组的前面插入了一个 -1。所以，申请数组长度的时候，是字符串的长度 +1。注意写代码的时候不要写错！</p>
<p>练习题 1：求解一个字符串的 pmt[] 数组，本质上是一个动态规划，你能用我们《14 | DP：我是怎么治好“DP 头痛症”的？》介绍的动态规划 6 步分析法进行求解吗？</p>
<p>代码：Java/C++/Python</p>
<p>练习题 2：当我们求解了 pmt[] 数组，由于访问 pmt 数组的时候，都是 pmt[i-1] 或 pmt[j-1]，为了优化掉这个减法，你可以把求解 pmt[] 数组的代码，转成输出 next 数组的代码吗？</p>
<p>代码：Java/C++/Python</p>
<p>练习题 3：给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过 10000。</p>
<p>输入：&ldquo;abab&rdquo;</p>
<p>输出：True</p>
<p>解释：可由子字符串 &ldquo;ab&rdquo; 重复两次构成。</p>
<p>方法 1 PMT：Java/C++/Python方法 2 Next：Java/C++/Python方法 3 同余：Java/C++/Python</p>
<p>完整的 KMP 代码</p>
<p>到此为止，我们已经可以给出完整的 KMP 代码了，如下所示（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    // 在学习PMT的
</span></span><span class="line"><span class="cl">    private int[] buildNext(String sub) {
</span></span><span class="line"><span class="cl">        final int N = sub == null ? 0 : sub.length();
</span></span><span class="line"><span class="cl">        int[] next = new int[N + 1];
</span></span><span class="line"><span class="cl">        int i = 0;
</span></span><span class="line"><span class="cl">        int j = -1;
</span></span><span class="line"><span class="cl">        next[0] = -1;
</span></span><span class="line"><span class="cl">        while (i &lt; N) {
</span></span><span class="line"><span class="cl">            if (j == -1 || sub.charAt(i) == sub.charAt(j)) {
</span></span><span class="line"><span class="cl">                i++;
</span></span><span class="line"><span class="cl">                j++;
</span></span><span class="line"><span class="cl">                next[i] = j;
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                j = next[j];
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return next;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public int strStr(String main, String sub) {
</span></span><span class="line"><span class="cl">        int i = 0;
</span></span><span class="line"><span class="cl">        int j = 0;
</span></span><span class="line"><span class="cl">        final int alen = main.length();
</span></span><span class="line"><span class="cl">        final int blen = sub.length();
</span></span><span class="line"><span class="cl">        int[] next = buildNext(sub);
</span></span><span class="line"><span class="cl">        while (i &lt; alen &amp;&amp; j &lt; blen) {
</span></span><span class="line"><span class="cl">            if (-1 == j || main.charAt(i) == sub.charAt(j)) {
</span></span><span class="line"><span class="cl">                // 如果匹配成功，那么向前走
</span></span><span class="line"><span class="cl">                // 这里和暴力的方法没有区别
</span></span><span class="line"><span class="cl">                i++;
</span></span><span class="line"><span class="cl">                j++;
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                j = next[j];
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 看一下是不是匹配完了
</span></span><span class="line"><span class="cl">        return j == blen ? i - blen : -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析</p>
<p>这里稍微唠叨一下 KMP 的时间复杂度。在比较成功的情况下，i 和 j 都会前进。在比较失败的时候，j 会往回跑（j back），如下图所示：</p>
<p>这里我们需要给出两个定义：</p>
<p>匹配失败时，当 i 停住不动的时候，称为一个失配点；</p>
<p>当遇到一个失配点时，j 会往回跑，那么会有不同的往回跑的步数。</p>
<p>那么时间复杂度可以写成如下：O(N + sum(每个失配点 x 每个失配点j往回跑的次数))。那么最差情况如下图所示：</p>
<p>此时失配点只有 N / M 个，每次失配之后，j 要往回跑 M 次。所以最差情况下时间复杂度为 O(N + M)，而空间复杂度为 O(M)。</p>
<p>KMP 的优化</p>
<p>相信你已经理解了前面介绍的 PMT 对暴力算法进行优化的原理，其核心就是跳过无效地比较。那么，我们再看一下，是不是可以在 KMP 的基础上跳过更多的无效比较呢？</p>
<p>假设有如下比较失败的情况：</p>
<p>我们已经跳过了比较失败的情况，不过可以发现，每次回退，其实都是反复地用 &lsquo;b&rsquo; 和&rsquo; c&rsquo; 字符进行比较。实际这里上可以进行如下优化：</p>
<p>总结一下，当发现回退之后的字符仍然是相等的时候，我们就再回退一次。由于这部分代码只涉及求解 next 数组，所以我把这部分代码也给你写出来：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    private int[] buildNext(String sub) {
</span></span><span class="line"><span class="cl">        final int N = sub == null ? 0 : sub.length();
</span></span><span class="line"><span class="cl">        int[] next = new int[N + 1];
</span></span><span class="line"><span class="cl">        int i = 0;
</span></span><span class="line"><span class="cl">        int j = -1;
</span></span><span class="line"><span class="cl">        next[0] = -1;
</span></span><span class="line"><span class="cl">        while (i &lt; N) {
</span></span><span class="line"><span class="cl">            if (j == -1 || sub.charAt(i) == sub.charAt(j)) {
</span></span><span class="line"><span class="cl">                i++;
</span></span><span class="line"><span class="cl">                j++;
</span></span><span class="line"><span class="cl">                if (i &lt; sub.length() &amp;&amp; 
</span></span><span class="line"><span class="cl">                    j &lt; sub.length() &amp;&amp;
</span></span><span class="line"><span class="cl">                    sub.charAt(i) == sub.charAt(j)) {
</span></span><span class="line"><span class="cl">                    next[i] = next[j];    
</span></span><span class="line"><span class="cl">                } else {
</span></span><span class="line"><span class="cl">                    next[i] = j;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                j = next[j];
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return next;
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>BM 算法</p>
<p>虽然 KMP 算法能够取得线性时间复杂度。不过，当你打开任何一个文档编辑器的时候，大部分编辑器的搜索算法并不是基于 KMP 算法来实现的。这里主要有两个原因：</p>
<p>KMP 算法需要在 main 字符串从头搜索到结尾；</p>
<p>KMP 算法在跳过一些坏字符的时候，会出现不停回退的情况。</p>
<p>比如，当你利用 KMP 算法进行搜索的时候，会有如下情况：</p>
<p>实际上，我们肉眼可见的是，字符 &lsquo;c&rsquo; 并不出现在 sub 字符串，所以我们没有必要一直回退。一种更好的办法是：将 sub 字符串推到 &lsquo;c&rsquo; 字符的后面。</p>
<p>如果你能想到这个思路，不妨再更进一步思考一下。既然字符串比较的时候，右边失效就直接前移了，那么我们直接从右往左边比较，不是来得更直接吗？</p>
<p>于是，基于下面这两个思路你就可以得到答案。</p>
<p>坏字符：在 main 字符串与 sub比较失败的字符；</p>
<p>从右向左比较。</p>
<p>有人发明了 BM（Boyer-Moore）算法，还在字符串查找上留下了大名。你先别后悔晚生了那么多年，我们一起再把这个算法讲透。</p>
<p>概念</p>
<p>我会采用 Moore 举的例子一步一步展开介绍。两个字符串为：main = &ldquo;HERE IS A SIMPLE EXAMPLE&rdquo;, sub = &ldquo;EXAMPLE&rdquo;。</p>
<p>1. 第 1 步</p>
<p>首先比较 &lsquo;S&rsquo; != &lsquo;E&rsquo;，那么需要把 sub 字符串移动到 &lsquo;S&rsquo; 的后面。因为 &lsquo;S&rsquo; 从来没有出现在 sub 字符串，所以 &lsquo;S&rsquo; 就是一个坏字符。</p>
<p>注意：坏字符指的是匹配失败的 main 字符串中对应的那个字符，而不是说没有在 sub 字符串里面出现的字符。</p>
<p>2. 第 2 步</p>
<p>&lsquo;P&rsquo; != &lsquo;E&rsquo;，此时 &lsquo;P&rsquo; 是一个坏字符，但是出现在 sub 中。那么我们移动 sub 字符串，让两个字符串在 &lsquo;P&rsquo; 字符这里对齐，移动的距离为 2。</p>
<p>由第 1 步和第 2 步，可以得到一个“坏字符”规则：</p>
<p>当匹配失败的时候，移动距离 = 坏字符的位置 - sub 中的上一次出现位置。</p>
<p>注意：这里“坏字符的位置”指的是坏字符在匹配失败的时候，在 sub 字符串中的下标。举 2 个例子：</p>
<p>例 1：在第 1 步比较失败之后，我们移动 7 步。如下图所示：</p>
<p>例 2：在第 2 步比较失败之后，我们移动 4 步。如下图所示：</p>
<p>当 &lsquo;P&rsquo; != &lsquo;E&rsquo; 时，坏字符对应 sub 中的比较位置为 6，而在 sub[6] 之前出现的 &lsquo;P&rsquo; 字符下标为 4，所以移动距离为 6 - 4 = 2。</p>
<p>3. 第 3 步</p>
<p>移动之后，我们依然从尾部开始比较。一直向前移动，如下图所示：</p>
<p>由于我们是从后往前进行比较，比较成功的字符串都是位于 sub 字符串的尾部（即后缀），所以可以把这些比较成功的后缀子串称为好后缀（good suffix）。</p>
<p>因此，&ldquo;E&rdquo;, &ldquo;LE&rdquo;, &ldquo;PLE&rdquo;, &ldquo;MPLE&rdquo; 都是好后缀。</p>
<p>4. 第 4 步</p>
<p>到此时，&lsquo;I&rsquo; 就是一个坏字符，因为比较失败了。此时正在比较 sub[2]，而 sub[0,1] 之前都没有 &lsquo;I&rsquo; 字符，所以移动距离为 2 - (-1) = 3。</p>
<p>那么问题是，有没有更好的移动办法？ 这个移动办法其实就在第 5 步。</p>
<p>5. 第 5 步</p>
<p>我先介绍一下思路：在前面的“坏字符规则”里介绍了当单个字符匹配失败的时候的移动距离。那么有没有可能把一些 sub 字符串连续的字符，当成一个整体处理呢？</p>
<p>如果你想到了这一点，就得到了 BM 算法的精髓：**好后缀规则。**这个规则还有以下 3 种情况。</p>
<p>1）如果我们将已匹配连续的字符串看成一个“整体”，这些整体也出现在 sub 字符串里面，就可以重新进行对齐。如下所示：</p>
<p>2）如果已匹配字符串的“好后缀”出现在 sub 的头部，那么只需要重新对齐就可以了。</p>
<p>3） 如果 1）2）都不满足，那么直接跳过这段已匹配字符串。</p>
<p>这里我需要特别地说明一下：</p>
<p>处理的时候，必须从 1）、2）、3）依次处理；</p>
<p>情况 1）只需要出现在 sub 子串中，而情况 2）中的“好后缀”必须要是 sub 字符串的前缀；</p>
<p>在处理情况 2）的时候，如果有很多个好后缀串，我们总是让“好后缀”更长的优先。</p>
<p>再回到例子中，看一下应该如何移动：</p>
<p>首先根据坏字符规则，因为 &lsquo;I&rsquo; != &lsquo;A&rsquo;，可以得到移动步数为 2 - (-1) = 3。根据**好后缀规则，**我们再分别看 1）、2）、3）这三种情况：</p>
<p>1）已匹配的字符串为 MPLE，这个字符串没有在 sub 字符串的更左边出现过，所以情况 1）不满足；</p>
<p>2）MPLE 的好后缀有 {&ldquo;PLE&rdquo;, &ldquo;LE&rdquo;, &ldquo;E&rdquo;}，其中只有 &ldquo;E&rdquo; 是 sub 字符串的前缀，所以需要移动 6 步将 &ldquo;E&rdquo; 对齐；</p>
<p>3）匹配到了 2），所以 3）不需要处理。</p>
<p>我们发现，在第 5 步，当使用“好后缀规则”的时候，能够移动更远的距离。所以我们最终选择这个更长的移动距离。</p>
<p>当然，选择“坏字符规则”与“好后缀规则”的时候，谁移动的距离更大，我们就用谁。</p>
<p>6. 第 6 步</p>
<p>第 6 步在第 5 步的基础上，只能使用坏字符规则。</p>
<p>因为没有好后缀可供使用。向后移动 6 - 4 = 2 位。</p>
<p>7. 第 7 步</p>
<p>匹配成功！不过，我们在进行编辑器中的文本搜索时，实际上还会继续往后面搜索。</p>
<p>suffix 和 prefix</p>
<p>前面我们介绍了关于坏字符的移动距离的计算，下面再看一下“好后缀规则”下的移动距离。这里需要引入两个数组，suffix 和 prefix。我们先看 suffix。</p>
<p>对于 sub = &ldquo;ABCABCABC&rdquo; 而言，suffix[4] 表示的含义如下图所示：</p>
<p>suffix[] 数组下标 i 表示长度为 i 的后缀串。suffix[i] 存放的值，表示在其左边出现相同字符串的最大起始位置。比如：</p>
<p>sub = &ldquo;ABCABCABC&rdquo; 时，对于子串 &ldquo;CABC&rdquo; 而言，suffix[4 = len(&ldquo;CABC&rdquo;)] = 2，还有一个同样的子串 &ldquo;CBAC&rdquo; 出现在 sub 字符串的下标 2 处；</p>
<p>sub = &ldquo;BBB&rdquo; 时，当子串为 &ldquo;B&rdquo; 时，suffix[1 = len(&ldquo;B&rdquo;)] = 1，对于后缀来说，有两个地方出现了这个子串，即 sub[0] 和 sub[1]，这里我们需要取最大的起始位置1。</p>
<p>而 prefix[i] 数组则表示长度为 i 的后缀串是不是 sub 的前缀。</p>
<p>算法实现</p>
<p>【代码】根据前面的分析，我们可以写出代码如下（代码并不长，只是我加了很多注释）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">  static private int[] bad = new int[256];
</span></span><span class="line"><span class="cl">  // suffix 后缀在sub字符串中的最右的起始位置：需要在其自身的左边。
</span></span><span class="line"><span class="cl">  // prefix[i]数组则表示长度为i的后缀串是不是sub的前缀。
</span></span><span class="line"><span class="cl">  static private int[] suffix = null;
</span></span><span class="line"><span class="cl">  static private boolean[] prefix = null;
</span></span><span class="line"><span class="cl">  /**
</span></span><span class="line"><span class="cl">   * 记录每个字符在sub字符串中的出现的最右端的下标位置
</span></span><span class="line"><span class="cl">   * 如果没有出现，那么设置为-1
</span></span><span class="line"><span class="cl">   * 用于坏字符规则
</span></span><span class="line"><span class="cl">   * @param sub
</span></span><span class="line"><span class="cl">   */
</span></span><span class="line"><span class="cl">  private void buildBadCharPos(String sub) {
</span></span><span class="line"><span class="cl">    for (int j = 0; j &lt; 256; j++) {
</span></span><span class="line"><span class="cl">      bad[j] = -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    for (int j = 0; j &lt; sub.length(); j++) {
</span></span><span class="line"><span class="cl">      bad[(int)sub.charAt(j)] = j;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  /**
</span></span><span class="line"><span class="cl">   * 这个函数负责生成suffix和prefix
</span></span><span class="line"><span class="cl">   * 这段代码需要仔细读注释
</span></span><span class="line"><span class="cl">   * @param sub 要在main字符串中查找的字符串sub
</span></span><span class="line"><span class="cl">   */
</span></span><span class="line"><span class="cl">  private void buildSuffixPrefix(String sub) {
</span></span><span class="line"><span class="cl">    int i = 0;
</span></span><span class="line"><span class="cl">    int j = 0;
</span></span><span class="line"><span class="cl">    int len = 0;
</span></span><span class="line"><span class="cl">    final int n = sub.length();
</span></span><span class="line"><span class="cl">    // 初始化
</span></span><span class="line"><span class="cl">    // 设置所有的 prefix[] = false
</span></span><span class="line"><span class="cl">    // 设置所有的 suffix[] = -1
</span></span><span class="line"><span class="cl">    for (i = 0; i &lt; n; i++) {
</span></span><span class="line"><span class="cl">      prefix[i] = false;
</span></span><span class="line"><span class="cl">      suffix[i] = -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    for (i = 0; i &lt; n - 1; i++) {
</span></span><span class="line"><span class="cl">      j = i;
</span></span><span class="line"><span class="cl">      len = 0;
</span></span><span class="line"><span class="cl">      // 两个字符串：
</span></span><span class="line"><span class="cl">      // 前缀字符串是P = sub[0...j]
</span></span><span class="line"><span class="cl">      // 后缀字符串是S = t[(n-j-1)...n-1];
</span></span><span class="line"><span class="cl">      // 当然，P和S是一样长的!
</span></span><span class="line"><span class="cl">      // 比较顺序:
</span></span><span class="line"><span class="cl">      // 在比较前缀字符串P和后缀字符串S的时候
</span></span><span class="line"><span class="cl">      // 是从: `后面` 开始向前比较的
</span></span><span class="line"><span class="cl">      // HINT:
</span></span><span class="line"><span class="cl">      // 我们当然没有必要取出P和S
</span></span><span class="line"><span class="cl">      // 在比较的时候，j--可以保证从后往前匹配
</span></span><span class="line"><span class="cl">      // len++表示已经匹配的长度
</span></span><span class="line"><span class="cl">      while (j &gt;= 0 &amp;&amp; sub.charAt(j) == sub.charAt(n - 1 - len)) {
</span></span><span class="line"><span class="cl">        len++;
</span></span><span class="line"><span class="cl">        // 这段代码非常有意思。
</span></span><span class="line"><span class="cl">        // 我们要考虑以下场景才容易看懂：
</span></span><span class="line"><span class="cl">        // 假设字符串sub = &#34;ABABABAB&#34;;
</span></span><span class="line"><span class="cl">        //
</span></span><span class="line"><span class="cl">        // * i = 1:
</span></span><span class="line"><span class="cl">        //      前缀字符串P = &#34;AB&#34; = sub[0,1];
</span></span><span class="line"><span class="cl">        //      后缀字符串S = &#34;AB&#34; = sub[6,7];
</span></span><span class="line"><span class="cl">        //   &gt; j = 1:
</span></span><span class="line"><span class="cl">        //     P[j=1] = &#39;B&#39; == S[7] = &#39;B&#39; 成立
</span></span><span class="line"><span class="cl">        //     所以suffix[1=len(&#39;B&#39;)] = 1
</span></span><span class="line"><span class="cl">        //     表示后缀串“B”在sub字符串左边的开始位置在1
</span></span><span class="line"><span class="cl">        //   &gt; j = 0:
</span></span><span class="line"><span class="cl">        //     P[j=0] = &#39;A&#39; == S[6] = &#39;A&#39; 成立
</span></span><span class="line"><span class="cl">        //     所以suffix[2=len(&#39;AB&#39;)] = 0
</span></span><span class="line"><span class="cl">        //     表示后缀串&#34;AB&#34;在sub字符串左边的开始位置在0
</span></span><span class="line"><span class="cl">        //
</span></span><span class="line"><span class="cl">        // 接下来我们看当处理到i = 5的时候发生什么?
</span></span><span class="line"><span class="cl">        //
</span></span><span class="line"><span class="cl">        // * i = 5
</span></span><span class="line"><span class="cl">        //      前缀字符串P = &#34;ABABAB&#34; = sub[0...5];
</span></span><span class="line"><span class="cl">        //      后缀字符串S = &#34;ABABAB&#34; = sub[2...7];
</span></span><span class="line"><span class="cl">        //   &gt; j = 5
</span></span><span class="line"><span class="cl">        //     P[j=5] = &#39;B&#39; == Sub[7] = &#39;B&#39; 成立
</span></span><span class="line"><span class="cl">        //     所以suffix[1=len(&#39;B&#39;)] = j = 5
</span></span><span class="line"><span class="cl">        //     表示后缀串“B”在sub字符串左边的开始位置在5
</span></span><span class="line"><span class="cl">        //   &gt; j = 4
</span></span><span class="line"><span class="cl">        //     P[j=4] = &#39;A&#39; == Sub[6] = &#39;A&#39;成立
</span></span><span class="line"><span class="cl">        //     所以suffix[2=len(&#39;AB&#39;)] = j = 4
</span></span><span class="line"><span class="cl">        //     表示后缀串“AB”在sub字符串左边的开始位置在4
</span></span><span class="line"><span class="cl">        // 到这里，我们发现
</span></span><span class="line"><span class="cl">        // 通过这一行代码，我们可以找到每个后缀串在sub里面“最右边”的起始位置。
</span></span><span class="line"><span class="cl">        // 注意：这里的最右边当然不能是后缀串本身，需要在后缀串的左边!
</span></span><span class="line"><span class="cl">        suffix[len] = j;
</span></span><span class="line"><span class="cl">        j--;
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      // 如果P字符串和S字符串完全一样
</span></span><span class="line"><span class="cl">      // 那么说明，后缀字符串S能够匹配前缀
</span></span><span class="line"><span class="cl">      // 这里要进行标记
</span></span><span class="line"><span class="cl">      if (-1 == j) {
</span></span><span class="line"><span class="cl">        prefix[len] = true;
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  /**
</span></span><span class="line"><span class="cl">   * @param j
</span></span><span class="line"><span class="cl">   *   sub字符串和main字符串从后往前匹配的时候，在sub[j]位置与main匹配失败
</span></span><span class="line"><span class="cl">   *   也就是说: sub[j+1,...,n)都和main字符串匹配成功了，是一个好后缀
</span></span><span class="line"><span class="cl">   * @param n sub字符串的长度
</span></span><span class="line"><span class="cl">   * @return 依次使用1), 2), 3)返回相应的值
</span></span><span class="line"><span class="cl">   */
</span></span><span class="line"><span class="cl">  private int moveBySuffixPrefix(int j, int n) {
</span></span><span class="line"><span class="cl">    // 因为已经匹配的位置是sub[j+1,n)
</span></span><span class="line"><span class="cl">    // len表示已经匹配的字符串的长度
</span></span><span class="line"><span class="cl">    int len = n - (j + 1);
</span></span><span class="line"><span class="cl">    // 使用规则 1)
</span></span><span class="line"><span class="cl">    if (suffix[len] != -1) {
</span></span><span class="line"><span class="cl">      return j + 1 - suffix[len];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 使用规则 2)
</span></span><span class="line"><span class="cl">    // 这里也可以从r = j + 1开始。但是如果j+1是有效的。那么
</span></span><span class="line"><span class="cl">    // 前面的suffix[len] != -1就会处理掉。
</span></span><span class="line"><span class="cl">    // 所以这里没有必要再看j + 1
</span></span><span class="line"><span class="cl">    // 直接找到一个可以匹配的后缀子串与前缀子串匹配的位置就可以了。
</span></span><span class="line"><span class="cl">    // r表示在sub字符串中的下标，那么n - r就表示相应的后缀串
</span></span><span class="line"><span class="cl">    for (int r = j + 2; r &lt;= n - 1; r++) {
</span></span><span class="line"><span class="cl">      if (prefix[n - r]) {
</span></span><span class="line"><span class="cl">        return r;
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 使用规则3)
</span></span><span class="line"><span class="cl">    return n;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  public int strStr(String main, String sub) {
</span></span><span class="line"><span class="cl">    if (sub == null || sub.length() == 0) {
</span></span><span class="line"><span class="cl">      return 0;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    if (main == null || main.length() == 0) {
</span></span><span class="line"><span class="cl">      return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">     buildBadCharPos(sub);
</span></span><span class="line"><span class="cl">     final int mainLen = main.length();
</span></span><span class="line"><span class="cl">    final int subLen = sub.length();
</span></span><span class="line"><span class="cl">     suffix = new int[subLen];
</span></span><span class="line"><span class="cl">    prefix = new boolean[subLen];
</span></span><span class="line"><span class="cl">     buildSuffixPrefix(sux);
</span></span><span class="line"><span class="cl">     int i = 0;
</span></span><span class="line"><span class="cl">    int j = 0;
</span></span><span class="line"><span class="cl">    while (i &lt;= mainLen - subLen) {
</span></span><span class="line"><span class="cl">      for (j = subLen - 1; j &gt;= 0; j--) {
</span></span><span class="line"><span class="cl">        if (main.charAt(i + j) != sub.charAt(j)) {
</span></span><span class="line"><span class="cl">          break;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      if (j &lt; 0) {
</span></span><span class="line"><span class="cl">        return i;
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      int badMoveLength = j - bad[(int)main.charAt(i + j)];
</span></span><span class="line"><span class="cl">      int goodSuffixMoveLength = 0;
</span></span><span class="line"><span class="cl">      // 有后缀串的时候，我们才去使用
</span></span><span class="line"><span class="cl">      // 好后缀规则
</span></span><span class="line"><span class="cl">      // 因为是在sub[j]匹配失败
</span></span><span class="line"><span class="cl">      // 所以当j &gt;= subLen - 1的时候
</span></span><span class="line"><span class="cl">      // 是没有后缀串的!
</span></span><span class="line"><span class="cl">      // 当然也没有好后缀串了
</span></span><span class="line"><span class="cl">      if (j &lt; subLen - 1) {
</span></span><span class="line"><span class="cl">        goodSuffixMoveLength 
</span></span><span class="line"><span class="cl">             moveBySuffixPrefix(j, subLex);
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      i += Math.max(badMoveLength, goodSuffixMoveLength);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return -1;
</span></span><span class="line"><span class="cl">  }
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度，由于需要预处理 sub 字符串得到 suffix 和 prefix，这里的复杂度为 O(M2)。最差情况下，时间复杂度会下降到 O(N×M)。空间复杂度为 O(M)。不过对于无周期的模式串，大部分时间复杂度为 O(N)。其中 N 表示 main 字符串的长度，M 表示 sub 字符串的长度。</p>
<p>【小结】这里我们引入了 BM 算法的一些概念，以及如何从右向左查找的时候进行优化。虽然 BM 算法最差情况下时间复杂度会掉到 O(N×M)，不过再加入一些优化，还是可以将这个算法更改为 O(N) 的线性算法。优化的具体细节，你可以阅读Turbo-BM 算法。</p>
<p>Sunday 算法</p>
<p>Sunday 算法应该是除了暴力算法中最好懂的字符串匹配算法了（不过它在最差情况下是时间复杂度是 O(N×M)，看来跑得快的算法都需要“挠头发”）。</p>
<p>思路与步骤</p>
<p>我们直接做个让你一看就懂的演示。首先假定字符串为 main = &ldquo;substring searching&rdquo; 中查找 sub = &ldquo;search&rdquo;。下图中 m 表示的是 sub 字符串的长度。</p>
<p>匹配失败的时候，直接看 main 字符串对齐之后，紧接着的那个字符。比如当 &lsquo;u&rsquo; != &rsquo;e&rsquo; 的时候，立马去看字符 &lsquo;i&rsquo;，我们称为Target Char。</p>
<p>由于 sub 中不存在字符 i，所以会移动 7 步（下面我们讲这个步数的计算）。</p>
<p>再接着比较 &rsquo;n&rsquo; != &rsquo;s&rsquo;，那么会去看Target Char字符 &lsquo;r&rsquo;，而 &lsquo;r&rsquo; 字符在 search 中的位置为 3。</p>
<p>经过再次移动，匹配成功。</p>
<p>移动规则</p>
<p>匹配失败时，只需要向前移动 i + = sub.length() - lastPos[Target Char]。这里 lastPos[] 数组记录的是 sub 字符串中每个字符在 sub 最右边的位置。如果字符没有在 sub 中出现，则标记为 -1。</p>
<p>【代码】至此，我们就可以写出如下代码了（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    static private int[] pos = new int[256];
</span></span><span class="line"><span class="cl">    public int strStr(String main, String sub) {
</span></span><span class="line"><span class="cl">        if (sub == null || sub.length() == 0) {
</span></span><span class="line"><span class="cl">            return 0;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if (main == null || main.length() == 0) {
</span></span><span class="line"><span class="cl">            return -1;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">        final int mainLen = main.length();
</span></span><span class="line"><span class="cl">        final int subLen = sub.length();
</span></span><span class="line"><span class="cl">        int i = 0;
</span></span><span class="line"><span class="cl">        int j = 0;
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">        // pos数组记录sub中每个字符在sub最右边的位置。
</span></span><span class="line"><span class="cl">        // 如果不存在，用-1表示。
</span></span><span class="line"><span class="cl">        for (j = 0; j &lt; pos.length; j++) {
</span></span><span class="line"><span class="cl">            pos[j] = -1;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        for (j = 0; j &lt; subLen; j++) {
</span></span><span class="line"><span class="cl">            pos[(int)sub.charAt(j)] = j;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">        while (i &lt;= mainLen - subLen) {
</span></span><span class="line"><span class="cl">            j = 0;
</span></span><span class="line"><span class="cl">            while (main.charAt(i + j) == sub.charAt(j)) {
</span></span><span class="line"><span class="cl">                j++;
</span></span><span class="line"><span class="cl">                if (j &gt;= subLen) {
</span></span><span class="line"><span class="cl">                    return i;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            // 如果Target Char不在main的范围里面了
</span></span><span class="line"><span class="cl">            if (i + subLen &gt;= mainLen) {
</span></span><span class="line"><span class="cl">                return -1;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            final int targetChar = (int)main.charAt(i + subLen);
</span></span><span class="line"><span class="cl">            i += subLen - pos[targetChar];
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度为 O(N×M)，其中 N 为 main 字符串的长度，M 为 sub 字符串的长度。空间复杂度为 O(256)。</p>
<p>【小结】除了暴力算法，Sunday 算法应该是最好写的算法了。不过实现代码的时候，你仍需要注意两个地方：</p>
<p>主循环中 while (i &lt;= mainLen - subLen)，如果取 i &lt; mainLen - subLen，那么无法处理 strStr(&ldquo;a&rdquo;, &ldquo;a&rdquo;) 这种查找；</p>
<p>在取 target char 的时候，需要注意判断是不是越界。</p>
<p>总结</p>
<p>为了方便你复习，我把本讲重点介绍的知识点整理在一张思维导图里：</p>
<p>学完本讲，我希望你可以思考一下，是哪些基础知识点导致你对算法没有清晰地理解。然后对照着上图，进行重点突破。</p>
<p>比如，你发现看不懂 KMP 算法的时候，可以查一下，是不是 PMT 的用途没有看懂？看不懂 BM 算法的时候，是不是因为没有弄明白坏字符规则与好后缀规则。</p>
<p>思考题</p>
<p>最后我还给你留了一个思考题。</p>
<p>思考题：给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p>
<p>输入：s = &ldquo;aacecaaa&rdquo;</p>
<p>输出：&ldquo;aaacecaaa&rdquo;</p>
<p>代码 :Java/C++/Python</p>
<p>我们的字符串查找算法就讲到这里了，接下来我们将要介绍 16 |如何利用 DP 与单调队列寻找最大矩形？让我们继续前进。</p>
<p>-&ndash; ### 精选评论 ##### **辉： &gt; 从这句话开始看不懂了：凡是比较失败下标小于 4 的情况，都是无效比较（比如第 2 轮，第 4 轮）。因为这种比较还没有跑到 main[4] 就挂了（第 2 轮挂在 main[1]，第 4 轮挂在 main[3]）。 ######     讲师回复： &gt;     首先暴力法实际上是把所有可能的情况都进行了比较。KMP在暴力法的基础上进行的优化是：我把情况分为两部分，一部分有效比较；另外一部分是无效比较。那么如何区分有效比较与无效比较。这里的原则是。如果main[i]与sub[j]在这里匹配失败。那么暴力法重新匹配的时候，如果在main[k] = sub[l]比较失败，并且k &lt; i。那么这种比较就是无效比较。因为k &lt; i。这种比较是!!绝对不可能!!产生匹配成功的情况的，因此，也称之为无效比较。这种无效比较是可以直接跳过的！如何跳过这些无效比较，也就是KMP算法要解决的问题。 ##### **岳： &gt; 虽然看了一遍没有看懂，但还是觉得写的真好呀 ######     编辑回复： &gt;     小伙伴具体哪里没听懂可以留言提问哦，老师会帮你解答哈，加油～ ##### **彬： &gt; 赞 ##### **威： &gt; 太强了，老师的算法能力很厉害</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">数据结构与算法面试宝典</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/21%E8%AE%B2%E5%90%83%E9%80%8F%E5%AE%9E%E6%97%B6%E6%B5%81%E8%AE%A1%E7%AE%97/14%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E6%B5%81%E8%AE%A1%E7%AE%97%E6%98%AF%E6%9C%89%E7%8A%B6%E6%80%81%E7%9A%84/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">14状态管理：为什么说流计算是有“状态”的？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%AE%9E%E7%94%A8%E5%AF%86%E7%A0%81%E5%AD%A6/15__aead%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%89%E5%85%A8%E9%99%B7%E9%98%B1/">
            <span class="next-text nav-default">15__AEAD有哪些安全陷阱？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
