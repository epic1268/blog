<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>02队列：FIFO队列与单调队列的深挖与扩展 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="队列在日常生活中很常见，当我们排队买票看电影的时候，排在队列前面的人先入场，排在队列后面的人只能后入场。在计算机系统中常用先进先出（First In First Out）的队列来表示这种场景。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02%E9%98%9F%E5%88%97fifo%E9%98%9F%E5%88%97%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E7%9A%84%E6%B7%B1%E6%8C%96%E4%B8%8E%E6%89%A9%E5%B1%95/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02%E9%98%9F%E5%88%97fifo%E9%98%9F%E5%88%97%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E7%9A%84%E6%B7%B1%E6%8C%96%E4%B8%8E%E6%89%A9%E5%B1%95/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="02队列：FIFO队列与单调队列的深挖与扩展">
  <meta property="og:description" content="队列在日常生活中很常见，当我们排队买票看电影的时候，排在队列前面的人先入场，排在队列后面的人只能后入场。在计算机系统中常用先进先出（First In First Out）的队列来表示这种场景。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="数据结构与算法面试宝典">

  <meta itemprop="name" content="02队列：FIFO队列与单调队列的深挖与扩展">
  <meta itemprop="description" content="队列在日常生活中很常见，当我们排队买票看电影的时候，排在队列前面的人先入场，排在队列后面的人只能后入场。在计算机系统中常用先进先出（First In First Out）的队列来表示这种场景。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="17240">
  <meta itemprop="keywords" content="数据结构与算法面试宝典">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="02队列：FIFO队列与单调队列的深挖与扩展">
  <meta name="twitter:description" content="队列在日常生活中很常见，当我们排队买票看电影的时候，排在队列前面的人先入场，排在队列后面的人只能后入场。在计算机系统中常用先进先出（First In First Out）的队列来表示这种场景。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">02队列：FIFO队列与单调队列的深挖与扩展</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 17240 字 </span>
          <span class="more-meta"> 预计阅读 35 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>队列在日常生活中很常见，当我们排队买票看电影的时候，排在队列前面的人先入场，排在队列后面的人只能后入场。在计算机系统中常用先进先出（First In First Out）的队列来表示这种场景。</p>
<p>但是除了这种 FIFO 队列以外，还有一种队列需要注意，就是单调队列，由于课本上不常讲，面试中又容易出现，因此需要格外注意。让我们一起把这个数据结构的知识图谱丰富起来。</p>
<p>下面我要介绍的内容在实际的工程应用中也经常会用到，比如：</p>
<p>Redis 的消息队列，用来搭建秒杀系统；</p>
<p>LevelDB 的写入队列，可以保证数据写入的顺序；</p>
<p>Qemu 的 Ring Buffer，用来完成数据的高效传输。</p>
<p>它们是很多基础设施的基本算法，比如操作系统、数据库、TCP/IP 协议栈等。OK, Let&rsquo;s Go!</p>
<p>FIFO 队列</p>
<p>我们先从基本的 FIFO 队列入手，其特点用动画表示如下：</p>
<p>可以发现 FIFO 有两个特点：</p>
<p>push 元素时，总是将元素放在队列尾部；</p>
<p>pop 元素时，总是将队列首部的元素扔掉。</p>
<p>但只知道 FIFO 的特性，并不能从容地应对复杂的面试。因此我们还需要进一步对FIFO 加以深挖，力求在面试中游刃有余。接下来我将通过大厂面试题，带你学习这块重点知识。</p>
<p>例 1：二叉树的层次遍历（两种方法）</p>
<p>【题目】从上到下按层打印二叉树，同一层结点按从左到右的顺序打印，每一层打印到一行。</p>
<p>输入：</p>
<p>输出：[[3], [9, 8], [6, 7]]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 二叉树结点的定义
</span></span><span class="line"><span class="cl">public class TreeNode {
</span></span><span class="line"><span class="cl">  // 树结点中的元素值
</span></span><span class="line"><span class="cl">  int val = 0;
</span></span><span class="line"><span class="cl">  // 二叉树结点的左子结点
</span></span><span class="line"><span class="cl">  TreeNode left = null;
</span></span><span class="line"><span class="cl">  // 二叉树结点的右子结点
</span></span><span class="line"><span class="cl">  TreeNode right = null;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>【分析】这道题已经在非常多的大厂面试中出现过了，比如微软，美团，腾讯等，因此你务必要掌握题目涉及的思想和原理。在真正开始写代码之前，我们还是参考“第 01 讲”中给出的深度思考的路线，从分析题目到写出代码“走”一遍。</p>
<p>1. 模拟首先我们在这棵树上进行模拟，动图演示效果如下所示：</p>
<p>2. 规律通过运行的模拟，可以总结出以下两个特点。</p>
<p>（1）广度遍历（层次遍历）：由于二叉树的特点，当我们拿到第 N 层的结点 A 之后，可以通过 A 的 left 和 right 指针拿到下一层的结点。</p>
<p>（2）顺序输出：每层输出时，排在左边的结点，它的子结点同样排在下一层最左边。</p>
<p>3. 匹配</p>
<p>当你发现题目具备广度遍历（分层遍历）和顺序输出的特点，就应该想到用FIFO 队列来试一试。</p>
<p>4.. 边界</p>
<p>关于二叉树的边界，需要考虑一种空二叉树的情况。当遇到一棵空的二叉树，有两种解决办法。</p>
<p>（1）特殊判断：如果发现是一棵空二叉树，就直接返回空结果。</p>
<p>（2）制定一个规则：不要让空指针进入到 FIFO 队列。</p>
<p>我个人比较喜欢第 2 种方案，因为代码一致性更好（一致性是指不需要为各种特殊情况再添加额外的 if/else 来处理）。所以接下来我将从“制定一个规则：不要让空指针进入队列”上考虑代码的实现。</p>
<p>【画图】当我们拿到一道题，脑海中已经关联了相应的数据结构：FIFO 队列，下面就可以利用它来画图了。</p>
<p>不过，二叉树的层次遍历与标准的 FIFO 队列不太一样，需要在每一层开始处理之前，记录一下 Queue Size（当前层里面结点的个数），演示如下图所示：</p>
<p>Step1. 在一开始首先将根结点 3 加入队列中。</p>
<p>Step 2. 开始新一层遍历，记录下当前队列长度 QSize=1，初始化当前层存放结果的[]。</p>
<p>Step 3. 将结点 3 出队，然后将其放到当前层中。</p>
<p>Step 4. 再将结点 3 的左右子结点分别入队。QSize = 1 的这一层已经处理完毕。</p>
<p>Step 5. 开始新一层的遍历。记录下新一层的 QSize = 2，初始化新的当前层存放当前层结果的[]。</p>
<p>Step 6. 从队列中取出 9，放到当前层结果中。结点 9 没有左右子结点，不需要继续处理左右子结点。</p>
<p>Step 7. 从队列中取出 8，放到当前层结果中。</p>
<p>Step 8. 将结点 8 的左右子结点分别入队。此时，QSize = 2 的部分已经全部处理完成。</p>
<p>Step 9.开始新一层的遍历，记录下当前队列中的结点数 QSize = 2，并且生成存放当前层结果的 list[]。</p>
<p>Step 10. 将队首结点 6 出队放到当前层结果中。结点 6 没有左右子结点，没有元素要入队。</p>
<p>Step 11. 将队首结点 7 出队，放到当前层结果中。结点 7 没有左右子结点，没有元素要入队。</p>
<p>结束，返回我们层次遍历的结果。</p>
<p>【代码】现在我们有解题思路，也有运行图，接下来就可以写出以下核心代码（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
</span></span><span class="line"><span class="cl">        // 生成FIFO队列
</span></span><span class="line"><span class="cl">        Queue&lt;TreeNode&gt; Q = new LinkedList&lt;&gt;();
</span></span><span class="line"><span class="cl">        // 如果结点不为空，那么加入FIFO队列
</span></span><span class="line"><span class="cl">        if (root != null) {
</span></span><span class="line"><span class="cl">            Q.offer(root);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // ans用于保存层次遍历的结果
</span></span><span class="line"><span class="cl">        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();
</span></span><span class="line"><span class="cl">        // 开始利用FIFO队列进行层次遍历
</span></span><span class="line"><span class="cl">        while (Q.size() &gt; 0) {
</span></span><span class="line"><span class="cl">            // 取出当前层里面元素的个数
</span></span><span class="line"><span class="cl">            final int qSize = Q.size();
</span></span><span class="line"><span class="cl">            // 当前层的结果存放于tmp链表中
</span></span><span class="line"><span class="cl">            List&lt;Integer&gt; tmp = new LinkedList&lt;&gt;();
</span></span><span class="line"><span class="cl">            // 遍历当前层的每个结点
</span></span><span class="line"><span class="cl">            for (int i = 0; i &lt; qSize; i++) {
</span></span><span class="line"><span class="cl">                // 当前层前面的结点先出队
</span></span><span class="line"><span class="cl">                TreeNode cur = Q.poll();
</span></span><span class="line"><span class="cl">                // 把结果存放当于当前层中
</span></span><span class="line"><span class="cl">                tmp.add(cur.val);
</span></span><span class="line"><span class="cl">                // 把下一层的结点入队，注意入队时需要非空才可以入队。
</span></span><span class="line"><span class="cl">                if (cur.left != null) {
</span></span><span class="line"><span class="cl">                    Q.offer(cur.left);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                if (cur.right != null) {
</span></span><span class="line"><span class="cl">                    Q.offer(cur.right);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // 把当前层的结果放到返回值里面。
</span></span><span class="line"><span class="cl">            ans.add(tmp);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return ans;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：由于二叉树的每个结点，我们都只访问了一遍，所以时间复杂度为 O(n)。如果不算返回的数组，那么空间复杂度为 O(k)，这里的 k 表示二叉树横向最宽的那一层的结点数目。</p>
<p>【小结】写完代码之后，对 FIFO 队列进行一轮总结。现在除了知道先进先出的特点之外，还可以进一步细化知识点，如下图所示：</p>
<p>这道题是很多高频面试题的“母题”，可以衍生出很多子题出来，因此建议你把这道题研究透彻。如果还有哪里不理解，可以在留言区提问。</p>
<p>在依靠 FIFO 队列的解法中，我们利用 QSize 得到当前层的元素个数，然后再开始执行 FIFO 是处理分层遍历的关键。下面我再向你介绍另外一种更直观的思路。</p>
<p>【解法二】再来回顾一下题目的特点：</p>
<p>分层遍历</p>
<p>顺序遍历</p>
<p>那么我们是不是可以用 List 来表示每一层，把下一层的结点统一放到一个新生成的 List 里面。示意图如下：</p>
<p>Step 1. 首先将结点 3 加入 cur,，形成 cur=[3]。</p>
<p>Step 2. 开始依次遍历当前层 cur, 这里 cur 只有结点 3，依次把结点 3 的左子结点和右子结点加入 next，形成 [9, 8]。</p>
<p>Step 3. 将 cur 指向 next，并且 next 设置为 []</p>
<p>Step 4. 依次遍历 cur，并将每个结点的左右子结点放到 next 中。</p>
<p>Step 5. 将 cur 指向 next。并依次遍历。由于这是最后一层，所以不会再生成 next。</p>
<p>Step 6. 最后得到层次遍历的结果。</p>
<p>根据这个思路，写出的代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
</span></span><span class="line"><span class="cl">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">        // 初始化当前层结点
</span></span><span class="line"><span class="cl">        List&lt;TreeNode&gt; curLevel = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">        // 注意：需要root不空的时候才加到里面。
</span></span><span class="line"><span class="cl">        if (root != null) {
</span></span><span class="line"><span class="cl">            curLevel.add(root);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        while (curLevel.size() &gt; 0) {
</span></span><span class="line"><span class="cl">            // 准备用来存放下一层的结点
</span></span><span class="line"><span class="cl">            List&lt;TreeNode&gt; nextLevel = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">            // 用来存放当前层的结果
</span></span><span class="line"><span class="cl">            List&lt;Integer&gt; curResult = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">            // 遍历当前层的每个结点
</span></span><span class="line"><span class="cl">            for (TreeNode cur: curLevel) {
</span></span><span class="line"><span class="cl">                // 把当前层的值存放到当前结果里面
</span></span><span class="line"><span class="cl">                curResult.add(cur.val);
</span></span><span class="line"><span class="cl">                // 生成下一层
</span></span><span class="line"><span class="cl">                if (cur.left != null) {
</span></span><span class="line"><span class="cl">                    nextLevel.add(cur.left);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                if (cur.right != null) {
</span></span><span class="line"><span class="cl">                    nextLevel.add(cur.right);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // 注意这里的更迭!滚动前进
</span></span><span class="line"><span class="cl">            curLevel = nextLevel;
</span></span><span class="line"><span class="cl">            // 把当前层的值放到结果里面
</span></span><span class="line"><span class="cl">            ans.add(curResult);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return ans;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>通过这个有趣的解法，我们知道，FIFO 队列不仅可以用 Queue 表示，还可以用两层 ArrayList 来表示，均可达到同样的效果。再把思路扩展一下，思考是否还有其他的形式可以表达 FIFO 队列呢？请看下面这道思考题。</p>
<p>【思考题】给定一棵二叉树，如下图所示，树中的结点稍微有点变化，定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">struct Node {
</span></span><span class="line"><span class="cl">  int val = 0;
</span></span><span class="line"><span class="cl">  Node *left = null;
</span></span><span class="line"><span class="cl">  Node *right = null;
</span></span><span class="line"><span class="cl">  Node *next = null;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>希望你能修改二叉树里所有的 next 指针，使其指向右边的结点，如果右边没有结点，那么设置为空指针。</p>
<p>代码：Java/C++/Python</p>
<p>至此，经过我们的“浇灌”，FIFO 队列长出了更多的“树叶”。为了方便你理解，我把解决这类题目的重点总结在一张大图中：</p>
<p>【题目扩展】切忌盲目刷题，其实只要吃透一道题，就可以解决很多类似的题目。只要掌握分层遍历的技巧，以后再碰到类似的题目，就再也难不住你了。这里我为你总结了一张关于“二叉树的层次遍历”的解题技巧，如下图所示：</p>
<p>可以点开这里，查看题目的信息，代码。</p>
<p>例 2：循环队列</p>
<p>【题目】设计一个可以容纳 k 个元素的循环队列。需要实现以下接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class MyCircularQueue {
</span></span><span class="line"><span class="cl">    // 参数k表示这个循环队列最多只能容纳k个元素
</span></span><span class="line"><span class="cl">    public MyCircularQueue(int k);
</span></span><span class="line"><span class="cl">    // 将value放到队列中, 成功返回true
</span></span><span class="line"><span class="cl">    public boolean enQueue(int value);
</span></span><span class="line"><span class="cl">    // 删除队首元素，成功返回true
</span></span><span class="line"><span class="cl">    public boolean deQueue();
</span></span><span class="line"><span class="cl">    // 得到队首元素，如果为空，返回-1
</span></span><span class="line"><span class="cl">    public int Front();
</span></span><span class="line"><span class="cl">    // 得到队尾元素，如果队列为空，返回-1
</span></span><span class="line"><span class="cl">    public int Rear();
</span></span><span class="line"><span class="cl">    // 看一下循环队列是否为空
</span></span><span class="line"><span class="cl">    public boolean isEmpty();
</span></span><span class="line"><span class="cl">    // 看一下循环队列是否已放满k个元素
</span></span><span class="line"><span class="cl">    public boolean isFull();
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>【分析】循环队列是一个书本上非常经典的关于队列的例子，在工程实践中也有很多运用，比如 Ring Buffer、生产者消费者队列。我去微软面试的时候也遇到了这道经典的题目。正好借着讲 FIFO 队列的机会，我再给你介绍一下循环队列。</p>
<p>循环队列的重点在于循环使用固定空间，难点在于控制好 front/rear 两个首尾指示器。这里我会介绍两种实现。</p>
<p>【方法 1】只使用 k 个元素的空间，三个变量 front, rear, used 来控制循环队列的使用。分别标记 k = 6 时，循环队列的三种情况，如下图所示：</p>
<p>由图可知，在一般情况下，front 和 rear 都是不相等的。但是，如果仔细观察，你会发现在空队列与满队列的时候，front 和 rear 是相等的。那此时该怎么处理呢？</p>
<p>通过上述分析，可以知道只用 front 和 rear 两个变量，还不足以区分是空队列还是满队列，因此我们还需要用到额外的变量做进一步区分。一种比较简单的办法就是采用 used 变量，标记已经放了多少个元素在循环队列里面。</p>
<p>如图（a）所示，当队列为空的时候，used == 0；</p>
<p>如图（b）所示，当队列满的时候，used == k。</p>
<p>虽然从图片来看这是一个循环数组，但是面试官要求只能使用一个普通的数组来实现。在下标的移动上，要特别注意不要越界。下标只能在 [0, k-1] 范围里面移动。以下 3 点需要你格外注意，正常情况下：</p>
<p>index = i 的后一个是 i + 1，前一个是 i - 1</p>
<p>index = k-1 的后一个就是 index = 0</p>
<p>index = 0 的前一个是 index = k-1</p>
<p>实际上，这三个式子都可以利用取模的技巧来统一处理：</p>
<p>index = i 的后一个 (i + 1) % capacity</p>
<p>index = i 的前一个(i - 1 + capacity) % capacity</p>
<p>注意：所有的循环数组下标的处理都需要按照这个取模方法来。</p>
<p>通过前面的分析， 我们可以利用 front, rear, used 来写出循环队列的代码，如下所示（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class MyCircularQueue {
</span></span><span class="line"><span class="cl">    // 已经使用的元素个数
</span></span><span class="line"><span class="cl">    private int used = 0;
</span></span><span class="line"><span class="cl">    // 第一个元素所在位置
</span></span><span class="line"><span class="cl">    private int front = 0;
</span></span><span class="line"><span class="cl">    // rear是enQueue可在存放的位置
</span></span><span class="line"><span class="cl">    // 注意开闭原则
</span></span><span class="line"><span class="cl">    // [front, rear)
</span></span><span class="line"><span class="cl">    private int rear = 0;
</span></span><span class="line"><span class="cl">    // 循环队列最多可以存放的元素个数
</span></span><span class="line"><span class="cl">    private int capacity = 0;
</span></span><span class="line"><span class="cl">    // 循环队列的存储空间
</span></span><span class="line"><span class="cl">    private int[] a = null;
</span></span><span class="line"><span class="cl">    public MyCircularQueue(int k) {
</span></span><span class="line"><span class="cl">        // 初始化循环队列
</span></span><span class="line"><span class="cl">        capacity = k;
</span></span><span class="line"><span class="cl">        a = new int[capacity];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public boolean enQueue(int value) {
</span></span><span class="line"><span class="cl">        // 如果已经放满了
</span></span><span class="line"><span class="cl">        if (isFull()) {
</span></span><span class="line"><span class="cl">            return false;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 如果没有放满，那么a[rear]用来存放新进来的元素
</span></span><span class="line"><span class="cl">        a[rear] = value;
</span></span><span class="line"><span class="cl">        // rear注意取模
</span></span><span class="line"><span class="cl">        rear = (rear + 1) % capacity;
</span></span><span class="line"><span class="cl">        // 已经使用的空间
</span></span><span class="line"><span class="cl">        used++;
</span></span><span class="line"><span class="cl">        // 存放成功!
</span></span><span class="line"><span class="cl">        return true;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public boolean deQueue() {
</span></span><span class="line"><span class="cl">        // 如果是一个空队列，当然不能出队
</span></span><span class="line"><span class="cl">        if (isEmpty()) {
</span></span><span class="line"><span class="cl">            return false;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 第一个元素取出
</span></span><span class="line"><span class="cl">        int ret = a[front];
</span></span><span class="line"><span class="cl">        // 注意取模
</span></span><span class="line"><span class="cl">        front = (front + 1) % capacity;
</span></span><span class="line"><span class="cl">        // 已经存放的元素减减
</span></span><span class="line"><span class="cl">        used--;
</span></span><span class="line"><span class="cl">        // 取出元素成功
</span></span><span class="line"><span class="cl">        return true;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public int Front() {
</span></span><span class="line"><span class="cl">        // 如果为空，不能取出队首元素
</span></span><span class="line"><span class="cl">        if (isEmpty()) {
</span></span><span class="line"><span class="cl">            return -1;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 取出队首元素
</span></span><span class="line"><span class="cl">        return a[front];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public int Rear() {
</span></span><span class="line"><span class="cl">        // 如果为空，不能取出队尾元素
</span></span><span class="line"><span class="cl">        if (isEmpty()) {
</span></span><span class="line"><span class="cl">            return -1;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 注意：这里不能使用rear - 1
</span></span><span class="line"><span class="cl">        // 需要取模
</span></span><span class="line"><span class="cl">        int tail = (rear - 1 + capacity) % capacity;
</span></span><span class="line"><span class="cl">        return a[tail];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 队列是否为空
</span></span><span class="line"><span class="cl">    public boolean isEmpty() {
</span></span><span class="line"><span class="cl">        return used == 0;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 队列是否满了
</span></span><span class="line"><span class="cl">    public boolean isFull() {
</span></span><span class="line"><span class="cl">        return used == capacity;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：入队操作与出队操作都是 O(1)。</p>
<p>【方法 2】方法 1 利用 used 变量对满队列和空队列进行了区分。实际上，这种区分方式还有另外一种办法，使用 k+1 个元素的空间，两个变量 front, rear 来控制循环队列的使用。具体如下：</p>
<p>在申请数组空间的时候，申请 k + 1 个空间；</p>
<p>在放满循环队列的时候，必须要保证 rear 与 front 之间有空隙。</p>
<p>如下图（此时 k = 5）所示：</p>
<p>此时，可以发现，循环队列实际上是浪费了一个元素的空间。这个浪费的元素必须卡在 front 与 rear 之间。判断队列空或者满可以：</p>
<p>front == rear 此时队列为空；</p>
<p>(rear + 1) % capacity == front，此时队列为满。</p>
<p>注意：由于浪费了一个元素的空间，在申请数组的时候，要申请的空间大小为 k + 1, 并且 capacity 也必须为 k + 1。</p>
<p>除此之后，由于是循环数组，下标的活动范围是[0, k]（capacity 为 k+1，所以最大只能取到k）。下标的移动仍然需要利用取模的技巧。</p>
<p>【代码】第二种方法的思路，我们写出代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class MyCircularQueue {
</span></span><span class="line"><span class="cl">    // 队列的头部元素所在位置
</span></span><span class="line"><span class="cl">    private int front = 0;
</span></span><span class="line"><span class="cl">    // 队列的尾巴
</span></span><span class="line"><span class="cl">    // 注意我们采用的是前开后闭原则
</span></span><span class="line"><span class="cl">    // [front, rear)
</span></span><span class="line"><span class="cl">    private int rear = 0;
</span></span><span class="line"><span class="cl">    private int[] a = null;
</span></span><span class="line"><span class="cl">    private int capacity = 0;
</span></span><span class="line"><span class="cl">    public MyCircularQueue(int k) {
</span></span><span class="line"><span class="cl">        // 初始化队列，注意此时队列中元素个数为
</span></span><span class="line"><span class="cl">        // k + 1
</span></span><span class="line"><span class="cl">        capacity = k + 1;
</span></span><span class="line"><span class="cl">        a = new int[k + 1];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public boolean enQueue(int value) {
</span></span><span class="line"><span class="cl">        // 如果已经满了，无法入队
</span></span><span class="line"><span class="cl">        if (isFull()) {
</span></span><span class="line"><span class="cl">            return false;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 把元素放到rear位置
</span></span><span class="line"><span class="cl">        a[rear] = value;
</span></span><span class="line"><span class="cl">        // rear向后移动
</span></span><span class="line"><span class="cl">        rear = (rear + 1) % capacity;
</span></span><span class="line"><span class="cl">        return true;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public boolean deQueue() {
</span></span><span class="line"><span class="cl">        // 如果为空，无法出队
</span></span><span class="line"><span class="cl">        if (isEmpty()) {
</span></span><span class="line"><span class="cl">            return false;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 出队之后，front要向前移
</span></span><span class="line"><span class="cl">        front = (front + 1) % capacity;
</span></span><span class="line"><span class="cl">        return true;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public int Front() {
</span></span><span class="line"><span class="cl">        // 如果能取出第一个元素，取a[front];
</span></span><span class="line"><span class="cl">        return isEmpty() ? -1 : a[front];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public int Rear() {
</span></span><span class="line"><span class="cl">        // 由于我们使用的是前开后闭原则
</span></span><span class="line"><span class="cl">        // [front, rear)
</span></span><span class="line"><span class="cl">        // 所以在取最后一个元素时，应该是
</span></span><span class="line"><span class="cl">        // (rear - 1 + capacity) % capacity;
</span></span><span class="line"><span class="cl">        int tail = (rear - 1 + capacity) % capacity;
</span></span><span class="line"><span class="cl">        return isEmpty() ? -1 : a[tail];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public boolean isEmpty() {
</span></span><span class="line"><span class="cl">        // 队列是否为空
</span></span><span class="line"><span class="cl">        return front == rear;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public boolean isFull() {
</span></span><span class="line"><span class="cl">        // rear与front之间至少有一个空格
</span></span><span class="line"><span class="cl">        // 当rear指向这个最后的一个空格时，
</span></span><span class="line"><span class="cl">        // 队列就已经放满了!
</span></span><span class="line"><span class="cl">        return (rear + 1) % capacity == front;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：入队与出队操作都是 O(1)。</p>
<p>我们介绍了两种方法来实现循环队列，下面我分别从相似点、差别，以及适用范围对这两种方法进行总结。</p>
<p>1. 相似点</p>
<p>两种方法都是利用了取模的技巧，强调一下，在取模的时候，如果需要向前移动，不要写成 (i - 1) % capacity，注意一定要加上 capacity 之后再取模，否则在 i = 0 的时候就出错了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pre = (i - 1 + capacity) % capacity
</span></span></code></pre></td></tr></table>
</div>
</div><p>2. 差别</p>
<p>这两种方法的唯一区别在于区分空队列与满队列时，方法不一样：</p>
<p>方法 1 引入了另外一个变量 used 进行区分</p>
<p>方法 2 采用了浪费一个存储空间的办法进行区分</p>
<p>3. 适用范围</p>
<p>你可能认为方法 2 在队列元素较大时，存在浪费的情况，实际上这两种办法都有不同的适用范围。</p>
<p>方法 1 的缺点在于控制变量较多，达到 3 个。而方法 2 虽然浪费了一个存储空间，但是控制变量较少，只有 2 个。</p>
<p>在多线程编程里面，控制变量越少，越容易实现无锁编程，因此，在无锁队列里面，利用方法 2 较容易实现无锁队列。</p>
<p>至此，我们已经可以将循环队列总结在一张思维导图中，如下图所示：</p>
<p>一会儿我们还会遇到循环队列的内容，比如用途等，下面我们先来讲讲单调队列。</p>
<p>单调队列</p>
<p>单调队列属于双端队列的一种。双端队列与 FIFO 队列的区别在于：</p>
<p>FIFO 队列只能从尾部添加元素，首部弹出元素；</p>
<p>双端队列可以从首尾两端 push/pop 元素。</p>
<p>为了让你更直观地看出两者的区别，我分别绘制了 FIFO 队列和双端队列的图片，如下图所示：</p>
<p>FIFO 队列</p>
<p>双端队列</p>
<p>虽然双端队列经常用于工程实践中，但在面试中出现得较多的往往是单调队列，因此，本讲我会重点介绍单调队列。</p>
<p>什么是单调队列</p>
<p>首先来看一下单调队列的定义：要求队列中的元素必须满足单调性，比如单调递增，或者单调整递减。那么在入栈与出栈的时候，就与普通的队列不一样了。</p>
<p>接下来我将以单调递减为例，详细讲解单调队列的特性，希望你可以自己推导单调递增的情况。如果有什么疑问可以在评论区留言，我会定期给大家解答。</p>
<p>单调队列在入队的时候，需要满足 2 点：</p>
<p>入队前队列已经满足单调性；</p>
<p>入队后队列仍然满足单调性。</p>
<p>这里以单调递减队列为例，具体操作如下图所示（为了更直观地展示，我将不同大小的数值绘制为不同的高度）：</p>
<p>Step 1. 已有单调队列满足单调递减。</p>
<p>Step 2. 元素 5 要从尾部加入队列中。</p>
<p>Step 3. 元素 5 与尾部元素 3 比较，3 &lt; 5，因此扔掉 3。</p>
<p>Step 4. 元素 5 与尾部元素 4 比较，4 &lt; 5，因此扔掉 4。</p>
<p>Step 5. 元素 5 与尾部元素 6 比较，6 &gt; 5，因此将 5 入队。</p>
<p>可以发现，每次入队的时候，为了保证队列的单调性，还要剔除掉尾部的元素。直到尾部的元素大于等于入队元素（因为是单调递减队列）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    private void push(int val) {
</span></span><span class="line"><span class="cl">        while (!Q.isEmpty() &amp;&amp; Q.getLast() &lt; val) {
</span></span><span class="line"><span class="cl">            Q.removeLast();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 将元素入队
</span></span><span class="line"><span class="cl">        Q.addLast(val);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>单调队列在出队时，也与普通的队列出队方式不一样。出队时，需要给出一个 value，如果 value 与队首相等，才能将这个数出队，代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    // 出队的时候，要相等的时候才会出队
</span></span><span class="line"><span class="cl">    private void pop(int val) {
</span></span><span class="line"><span class="cl">        if (!Q.isEmpty() &amp;&amp; Q.getFirst() == val) {
</span></span><span class="line"><span class="cl">            Q.removeFirst();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么，采用这种比较特殊的入队与出队的方式有什么巧妙的地方呢？</p>
<p>入队之后，队首元素 Q.getFirst() 就是队列中的最大值。这个比较容易想到，因为我们这里是以单调递减队列为例，所以队首元素就是最大值。</p>
<p>出队时，如果一个元素已经被其他元素剔除出去了，就不会再出队。但如果一个元素是当前队列中的最大值，那么就会再出队。</p>
<p>关于这一点，你可以参考下面的动图演示（为了更清晰地演示此过程，被叉掉的元素还保留在原处，但实际上已经不在队列中了）：</p>
<p>Step 1. 将元素 5 入队，元素 3,4 会被剔除掉。区间 [8,6,4,3,5] 最大值为队首元素 8。</p>
<p>Step 2. 将元素 8 出队，元素相等，直接出队。区间 [6,4,3,5] 最大值为队首元素 6。</p>
<p>Step 3. 将元素 6 出队，元素相等，直接出队。区间 [4,3,5] 最大值为队首元素 5。</p>
<p>Step 4. 将元素 4 出队，此时元素不等，队列不变。区间 [3,5] 最大值为队首元素 5。</p>
<p>Step 5. 将元素 3 出队，此时元素不等，队列不变。区间 [5] 最大值为队首元素 5。</p>
<p>Step 6. 将元素 5 出队，此时元素相等，直接出队。</p>
<p>可以发现，单调递减队列最重要的特性是：入队与出队的组合，可以在 O(1) 时间得到某个区间上的最大值。</p>
<p>前面说了利用单调队列可以得到某个区间上的最大值。可是这个区间是什么？怎么定量地描述这个区间？与队列中的元素个数有什么关系？</p>
<p>针对以上 3 个疑问，可以分两种情况展开讨论：</p>
<p>只有入队的情况</p>
<p>有出队与入队的情况</p>
<p>为了更直观地展示，我分别制作了两种情况对应的动图演示。先来看只有入队的情况，如下图所示：</p>
<p>Step 1. 元素 3 入队，此时队首元素为 3，表示着区间[3]最大值为 3。</p>
<p>Step 2. 元素 2 入队，此时队列首元素为 3，表示区间[3,2]最大值为 3。</p>
<p>Step 3. 元素 5 入队，此时队首元素为 5，此时队列覆盖范围长度为 3，可以得到区间 [3,2,5] 最大值为 5。</p>
<p>继续执行入队，想必你也能得出结论了：在没有出队的情况下，黄色覆盖范围会一直增加，队首元素就表示这个黄色覆盖范围的最大值。</p>
<p>下面我们再来看出队与入队混合的情况。在上图 Step3 的基础上，如果再把 A[3] = 6 入队，这个时候，队列的覆盖范围长度为 4，假设我们想控制这个覆盖范围长度为 3，应该怎么办？</p>
<p>此时，我们只需要将 A[0] 出队即可。如下图所示：</p>
<p>Step 4. 将元素 A[0] = 3 出队，由于此时 3 != Q.getFirst()，所以什么也不做。队列覆盖范围为 [2, 5]，长度为 2。</p>
<p>Step 5. 将 A[3] = 6 入队，此时队首元素为 6，覆盖范围为[2,5,6]，覆盖长度为 3，可以得到区间 [2,5,6] 最大值为 6。</p>
<p>Step 6. 将 A[1] = 2 出队，此时 2 != Q.getFirst()，所以什么也不做。此时队列覆盖范围为 [5, 6]，长度为 2。</p>
<p>Step 7. 将 A[4] = 4 入队，此时覆盖范围为 [5, 6, 4]，覆盖长度为 3，区间 [5,6,4] 最大值为 6。</p>
<p>从上图中可以发现以下几个重点：</p>
<p>入队，扩张单调队列的覆盖范围；</p>
<p>出队，控制单调递减队列的覆盖范围；</p>
<p>队首元素就是覆盖范围的最大值；</p>
<p>队列中的元素个数小于覆盖范围元素的个数。</p>
<p>这里，虽然我们只讨论了单调递减队列，实际上单调递增队列的特性也非常类似，你可以下来自己推导一下。下面我们深入到题目中，趁热打铁，把刚学到的知识运用起来。</p>
<p>例 3：滑动窗口的最大值</p>
<p>【题目】给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。</p>
<p>输入：nums = [1,3,-1,-3,5,3], k = 3</p>
<p>输出：[3,3,5,5]</p>
<p>解释：</p>
<p>【分析】这是一道来自 eBay 的面试题。拿到时题目之后，可以发现，题目要求还是比较赤裸裸的，不妨先模拟一下，看看能不能想到比较好的解决办法。</p>
<p>1. 模拟</p>
<p>首先我们发现窗口在滑动的时候，有元素不停地进出。因此，可以采用队列来试一下。由于窗口长度为 3，所以将队列的长度固定为 3。</p>
<p>Step 1. 首先将元素 1 入队。</p>
<p>Step 2. 再将元素 3 入队。</p>
<p>Step 3. 再将 -1 入队，此时队列长度为 3，可以从 [1, 3, -1] 中得到最大值 3。</p>
<p>Step 4. 将 1 出队，然后将 3 入队，可以得到 [3,-1,3] 的最大值为3。</p>
<p>Step 5. 将 3 出队，然后再将 5 入队，可以得到 [-1, 3, 5] 的最大值为 5。</p>
<p>Step 6. 将 -1 队出，然后再将 3 入队，可以得到 [3,5,3] 的最大值为 5。</p>
<p>2. 规律</p>
<p>我们发现两点：</p>
<p>（1）不停地有元素出队入队</p>
<p>（2）需要拿到队列中的最大值</p>
<p>如果能够在 O(1) 时间内拿到队列中的最大值，那么就可以在 O(N) 时间解决掉这个问题。</p>
<p>3. 匹配</p>
<p>到这里为止，已经匹配到了你学过的数据结构了——单调递减队列！</p>
<p>4. 边界</p>
<p>接下来，你可能准备开始写代码了，不过我还需要和你讨论一些细节与边界。</p>
<p>滑动窗口的大小与队列的大小。</p>
<p>哪种单调递减？为什么？</p>
<p>首先我们看窗口的大小。当使用 Q.getFirst() 时，得到的是整个队列的最大值，因此队列的大小，必须与滑动窗口的大小一样。也就是说，当 A[i] 入队的时候，A[i-k] 必须要出队！这样才能保证队列中的元素最多有 k 个。</p>
<p>虽然我们已经知道要使用单调递减队列求解这道题目了，但单调递减有两种：</p>
<p>严格单调递减（队列中没有重复元素）</p>
<p>单调递减</p>
<p>那么，应该用哪种呢？首先我们看一下严格单调递减是否可以工作，如下图所示：</p>
<p>假设执行到 A[2] = 3 时，采用严格单调递减（队列中相等的元素也会被踢出去），入队时，A[2] 将会把所有的元素都踢出队列，队列变成 [3]，那么可以得到 [3,2,3] 的最大值为 3。</p>
<p>但是由于窗口滑动的时候，接着需要把 A[0] = 3 出队，出队之后，队列为空。然后再将 A[3] = 1 入队得到。</p>
<p>此时得到 [2,3,1] 的最大值为 1，这就出错了！所以我们不能使用严格单调递减队列求解。</p>
<p>注意：严格意义上来说，是可以使用严格单调递减队列，不过需要换一种出队方式，我会在例 4 讲解，在这里你可以先这么认为。</p>
<p>【画图】这部分运行过程与“覆盖范围”完全类似。经过前面的分析，现在你可以尝试自己画一下利用单调队列运行的过程图。如果你有什么疑问，可以在评论区留言，我们一起讨论。</p>
<p>【代码】现在我们已经分析清楚算法与数据结构，接下来就可以写代码了，代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    // 单调队列使用双端队列来实现
</span></span><span class="line"><span class="cl">    private ArrayDeque&lt;Integer&gt; Q = new ArrayDeque&lt;Integer&gt;();
</span></span><span class="line"><span class="cl">    // 入队的时候，last方向入队，但是入队的时候
</span></span><span class="line"><span class="cl">    // 需要保证整个队列的数值是单调的
</span></span><span class="line"><span class="cl">    // (在这个题里面我们需要是递减的)
</span></span><span class="line"><span class="cl">    // 并且需要注意，这里是Q.getLast() &lt; val
</span></span><span class="line"><span class="cl">    // 如果写成Q.getLast() &lt;= val就变成了严格单调递增
</span></span><span class="line"><span class="cl">    private void push(int val) {
</span></span><span class="line"><span class="cl">        while (!Q.isEmpty() &amp;&amp; Q.getLast() &lt; val) {
</span></span><span class="line"><span class="cl">            Q.removeLast();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 将元素入队
</span></span><span class="line"><span class="cl">        Q.addLast(val);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 出队的时候，要相等的时候才会出队
</span></span><span class="line"><span class="cl">    private void pop(int val) {
</span></span><span class="line"><span class="cl">        if (!Q.isEmpty() &amp;&amp; Q.getFirst() == val) {
</span></span><span class="line"><span class="cl">            Q.removeFirst();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public int[] maxSlidingWindow(int[] nums, int k) {
</span></span><span class="line"><span class="cl">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; nums.length; i++) {
</span></span><span class="line"><span class="cl">            push(nums[i]);
</span></span><span class="line"><span class="cl">            // 如果队列中的元素还少于k个
</span></span><span class="line"><span class="cl">            // 那么这个时候，还不能去取最大值
</span></span><span class="line"><span class="cl">            if (i &lt; k - 1) {
</span></span><span class="line"><span class="cl">                continue;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // 队首元素就是最大值
</span></span><span class="line"><span class="cl">            ans.add(Q.getFirst());
</span></span><span class="line"><span class="cl">            // 尝试去移除元素
</span></span><span class="line"><span class="cl">            pop(nums[i - k + 1]);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 将ans转换成为数组返回!
</span></span><span class="line"><span class="cl">        return ans.stream().mapToInt(Integer::valueOf).toArray();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：每个元素都只入队一次，出队一次，每次入队与出队都是 O(1) 的复杂度，因此整个算法的复杂度为 O(n)。</p>
<p>【小结】至此，我们已经学习了利用单调队列来解决滑动窗口的最大值。下面还可以扩展一下，比如：如何解决滑动窗口的最大值与最小值？具体你可以参考“题目与代码”。</p>
<p>我们再对单调队列的特性做一下总结：</p>
<p>入队，扩展单调队列的覆盖范围</p>
<p>出队，缩小单调队列的覆盖范围</p>
<p>队首元素，是覆盖范围的最大值/最小值</p>
<p>范围内的最大值，需要用单调递减队列</p>
<p>范围内的最小值，需要用单调递增队列</p>
<p>单调队列在解决滑动窗口的最大值的时候，由于这个滑动窗口的大小是固定的。因此，单调队列的大小也是固定的。那么，你能不能用循环队列来模拟单调队列，求解滑动窗口最大值的题目呢？</p>
<p>代码：Java/C++/Python</p>
<p>例 4：捡金币游戏</p>
<p>【题目】给定一个数组 A[]，每个位置 i 放置了金币 A[i]，小明从 A[0] 出发。当小明走到 A[i] 的时候，下一步他可以选择 A[i+1, i+k]（当然，不能超出数组边界）。每个位置一旦被选择，将会把那个位置的金币收走（如果为负数，就要交出金币）。请问，最多能收集多少金币？</p>
<p>输入：[1,-1,-100,-1000,100,3], k = 2</p>
<p>输出：4</p>
<p>解释：从 A[0] = 1 出发，收获金币 1。下一步走往 A[2] = -100, 收获金币 -100。再下一步走到 A[4] = 100，收获金币 100，最后走到 A[5] = 3，收获金币 3。最多收获 1 - 100 + 100 + 3 = 4。没有比这个更好的走法了。</p>
<p>【分析】这是一道来自头条的面试题。首先要纠正一种容易出错的想法：当走到 A[i] 的时候，选择 A[i+1, i+k] 里面的最大值作为下一步的落脚点。</p>
<p>如果是采用这种做法，那么根据示例会得到以下信息：</p>
<p>从 A[0] = 1 出发，收获金币 1。接下来面临的区间是 [-1, -100]。由于 -1 更大，所以选择A[1] = -1 为落脚点；</p>
<p>从 A[1] = -1 出发，收获金币 -1。接下来面临的区间是 [-100, -1000]，由于 -100 更大，所以选择 A[2] = -100 为落脚点；</p>
<p>从 A[2] = -100 出发，收获金币 -100。接下来面临的区间是 [-1000, 100]，由于 A[4] = 100 更大，所以选择 A[4] = 100 为落脚点；</p>
<p>从 A[4] = 100 出发，收获金币 100，接下来走到 A[5] = 3；</p>
<p>停在 A[5] = 3，收获金币 3。一共收获金币 1 + (-1) + (-100) + 100 + 3 = 3。并不是最优的 4 个金币。</p>
<p>所以，这道题目，不能采用上述方法。下面我们利用“四步分析法”继续寻找更优解法。</p>
<p>1. 模拟</p>
<p>在分析题目时，一种办法是顺着题意走，另外一种办法是做假设。假设我们已经知道了走到 [0, i-1] 时收获的金币数目，用 get[] 数组来存放，那么走到 A[i] 最多可以收获的金币数目可以是下图这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">get[i] = max(get[i-k, ...., i-1]) + A[i]
</span></span></code></pre></td></tr></table>
</div>
</div><p>考虑到 i - k 实际上可能会小于 0，对于这种情况，只需要取 max(0, i-k) 就可以了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">get[i] = max(get[max(i-k, 0), ...., i-1]) + A[i]
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来采用上述方法来进行一波演算，以 [1,-1,-100,-100000,100,3], k = 2 为例，具体动图如下：</p>
<p>1. index = 0 时，前面没有元素，所以 get[0] = A[0]</p>
<p>2. index = 1 时，只有 get[0] 可以选。所以 get[1] = 1 + -1 = 0。</p>
<p>3. index = 2 时，前面有 get[0], get[1] 可以选，较大的数为1，因此get[2] = 1 - 100 = -99。</p>
<p>4. index = 3 时，前面有 get[1],get[2] 可以选，当然选较大的数 0 了。因此，get[3] = 0 - 1000 = -1000。</p>
<p>5. index = 4 时，前面有 get[2],get[3] 可以选。 当然选较大的数 get[2]。因此，get[4] = -99 + 100 = 1。</p>
<p>6. index = 5 时，前面有 get[3],get[4] 可以选。当然选较大的数 get[4]。因此，get[5] = 1 + 3 = 4。此时我们得到了最终答案 4。</p>
<p>2. 规律经过模拟之后，我们发现，如果按照模拟的方法来写代码，那么复杂度会达到 O(Nk)。现在的问题是，每次要求 get[i] 的时候，都需要从前面长度为 k 的黄色范围里面选择一个最大值。有没有什么办法可以优化呢？</p>
<p>如果专注于黄色区域，会发现一个特点：黄色区域就是一个滑动窗口，我们要选的是滑动窗口的最大值。</p>
<p>3. 匹配现在我们已经发现了滑动窗口，并且要求这个滑动窗口的最大值。那么数据结构已经呼之欲出了——单调队列。</p>
<p>4. 边界这里要特别注意的是第一个元素 get[0]。此时单调队列为空。在求 get[0] 的时候，不能去单调队列中找最大值，要直接设置 get[0] = A[0]。</p>
<p>Step1. 当 index = 0 时，队列 Q[] 为空，那么 get[0] = A[0]。然后将 A[0] 入队。</p>
<p>Step 2. 当 index = 1 时，get[1] = 队首元素 + A[1] = 1 + -1 = 0。然后将 0 入队。</p>
<p>Step 3. 当 index = 2 时，get[2] = 队首元素 + A[2] = 1 - 100 = -99。然后将 -99 入队。</p>
<p>Step 4. 当 index = 3 时，首先将超出范围的元素出队。然后，get[3] = 队首元素 + A[3] = 0 - 1000 = -1000。然后将 -1000 入队。</p>
<p>Step 5. 当 index = 4 时，首先将队列中超出范围的元素出队，然后 get[4] = 队首元素 + A[4] = -99 + 100 = 1。然后再将 1 入队。</p>
<p>接下来我们重点看一下入队，由于 1 比队列中的元素都要大，按照单调队列的定义，所以队列中的元素都被清空。</p>
<p>Step 6. 当 index = 5 时，首先将队列中超出范围的元素出队（只不过此时队首元素和要出队的元素并不相等）。然后 get[5] = 1 + 3 = 4。</p>
<p>【代码】结合上述的讲解，写出代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public int maxResult(int[] A, int k) {
</span></span><span class="line"><span class="cl">        // 处理掉各种边界条件!
</span></span><span class="line"><span class="cl">        if (A == null || A.length == 0 || k &lt;= 0) {
</span></span><span class="line"><span class="cl">            return 0;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        final int N = A.length;
</span></span><span class="line"><span class="cl">        // 每个位置可以收集到的金币数目
</span></span><span class="line"><span class="cl">        int[] get = new int[N];
</span></span><span class="line"><span class="cl">        // 单调队列，这里并不是严格递减
</span></span><span class="line"><span class="cl">        ArrayDeque&lt;Integer&gt; Q = new ArrayDeque&lt;Integer&gt;();
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">            // 在取最大值之前，需要保证单调队列中都是有效值。
</span></span><span class="line"><span class="cl">            // 也就是都在区间里面的值
</span></span><span class="line"><span class="cl">            // 当要求get[i]的时候，
</span></span><span class="line"><span class="cl">            // 单调队列中应该是只能保存[i-k, i-1]这个范围
</span></span><span class="line"><span class="cl">            if (i - k &gt; 0) {
</span></span><span class="line"><span class="cl">                if (!Q.isEmpty() &amp;&amp; Q.getFirst() == get[i-k-1]) {
</span></span><span class="line"><span class="cl">                    Q.removeFirst();
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // 从单调队列中取得较大值
</span></span><span class="line"><span class="cl">            int old = Q.isEmpty() ? 0 : Q.getFirst();
</span></span><span class="line"><span class="cl">            get[i] = old + A[i];
</span></span><span class="line"><span class="cl">            // 入队的时候，采用单调队列入队
</span></span><span class="line"><span class="cl">            while (!Q.isEmpty() &amp;&amp; Q.getLast() &lt; get[i]) {
</span></span><span class="line"><span class="cl">                Q.removeLast();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            Q.addLast(get[i]);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return get[N-1];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：每个元素只入队一次，出队一次，每次入队与出队复杂度都是 O(n)。因此，时间复杂度为 O(n)，空间复杂度为 O(n)。</p>
<p>【小结】这仍然是一个单调队列的题目。不同之处在于操作的时候，是通过了一个 get[] 数组来进行滑动窗口的。因此，这道题的考点就是两方面：</p>
<p>找到 get[] 数组，并且知道如何生成；</p>
<p>利用单调队列在 get[] 数组上操作，找到滑动窗口的最大值。</p>
<p>通过这道题你应该明白，有的时候，滑动窗口不一定是在给定的数组上操作，还可能会在一个隐藏的数组上操作。</p>
<p>拓展：是否存在不同的出队方式？</p>
<p>前面我们在学习单调队列的时候，利用了元素相等来判断是否出队。这种出队方式的特点是必须要保证单调队列不能是严格递减或者严格递增。</p>
<p>那么是否还有别的出队方式？是否可以不通过元素值相等的方式进行出队？针对上述两个问题，我们一起来看一下具体如何处理。</p>
<p>入队：入队的时候，将值和下标一起入队。</p>
<p>出队：直接判断队首元素的下标，进而判断是否应该将队首元素出队。</p>
<p>基于这种思想，我们可以将这道题换种写法。代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    // 走到下标index = idx的记录
</span></span><span class="line"><span class="cl">    class Node {
</span></span><span class="line"><span class="cl">        // 累计取得的金币!
</span></span><span class="line"><span class="cl">        int sum = 0;
</span></span><span class="line"><span class="cl">        // 在index = idx的时候
</span></span><span class="line"><span class="cl">        // 取得的最大金币为sum
</span></span><span class="line"><span class="cl">        int idx = 0;
</span></span><span class="line"><span class="cl">        public Node(int s, int i) {
</span></span><span class="line"><span class="cl">            sum = s;
</span></span><span class="line"><span class="cl">            idx = i;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    };
</span></span><span class="line"><span class="cl">    public int maxResult(int[] A, int k) {
</span></span><span class="line"><span class="cl">        // 严格单调递减队列
</span></span><span class="line"><span class="cl">        // 里面存放的是每个位置可以收集到的金币以及下标index
</span></span><span class="line"><span class="cl">        ArrayDeque&lt;Node&gt; Q = new ArrayDeque&lt;Node&gt;();
</span></span><span class="line"><span class="cl">        // 走到i位置时，最大的金币收益
</span></span><span class="line"><span class="cl">        int ans = 0;
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; A.length; i++) {
</span></span><span class="line"><span class="cl">            // 出队！
</span></span><span class="line"><span class="cl">            // 对于i而言，
</span></span><span class="line"><span class="cl">            // [i-k, i-1]可以跳到A[i]
</span></span><span class="line"><span class="cl">            // 最远i - (i - k) = k
</span></span><span class="line"><span class="cl">            // 因此超出这个范围的，必须要出队
</span></span><span class="line"><span class="cl">            while (!Q.isEmpty() &amp;&amp; i - Q.getFirst().idx &gt; k) {
</span></span><span class="line"><span class="cl">                Q.removeFirst();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // 获得在位置i时的收益
</span></span><span class="line"><span class="cl">            if (Q.isEmpty()) {
</span></span><span class="line"><span class="cl">                ans = A[i];
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                ans = Q.getFirst().sum + A[i];
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // 入队，当A[i]入队的时候，要把小于他的那些
</span></span><span class="line"><span class="cl">            // 收益比他低，又比他旧的给踢除掉
</span></span><span class="line"><span class="cl">            // 注意！这里使用的是严格的单调递减!
</span></span><span class="line"><span class="cl">            while (!Q.isEmpty() &amp;&amp; Q.getLast().sum &lt;= ans) {
</span></span><span class="line"><span class="cl">                Q.removeLast();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            Q.addLast(new Node(ans, i));
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return ans;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：每个元素只入队一次，出队一次，每次入队与出队复杂度都是 O(n)。因此，时间复杂度为 O(n)，空间复杂度为 O(n)。</p>
<p>总结与延伸</p>
<p>至此，你已经了解了单调队列的用法和特性。和“第 01 讲”一样，经过不断地“浇灌”，我们又得到了一棵枝繁叶茂的“大树”。回到知识层面，我把本讲重点介绍、且需要你掌握的内容总结在一张思维导图中，如下图所示：</p>
<p>每个学科都会涉及很多知识，靠做题记知识点，就容易出现知识之间的割裂而形成孤立地，无法将知识系统化。希望你在做题的过程中能够主动尝试建立知识之间的联系，主动思考如何让新知识与原有知识相关联，提高学习效率。比如，循环队列实际上也是单调队列的好帮手，当然你也可以用来实现 FIFO 队列。</p>
<p>FIFO 队列和单调队列帮助我们解决了很多有趣的题目，通过这些题目，希望你能够整理出以下模板：</p>
<p>分层遍历</p>
<p>循环队列</p>
<p>单调队列</p>
<p>思考题</p>
<p>我再给你留一道思考题：在专栏的前两讲里学习了栈和队列，让我想到了曾经在面试中遇到过两道有意思的题目：</p>
<p>请利用栈来实现一个队列的操作</p>
<p>请用队列来实现一个栈的操作</p>
<p>你可以把答案写在评论区，我们一起讨论。接下来请和我一起踏上更加奇妙的算法与数据结构的旅程。让我们继续前进。</p>
<p>下一讲将介绍 03 | 优先级队列：堆与优先级队列，如何筛选最优元素。记得按时来探险。</p>
<p>-&ndash; ### 精选评论 ##### **6011： &gt; 老师讲的真好，不仅仅是知识，更是学习方式 ##### **宇： &gt; 对于循环队列里的取模技巧，index = i 的前一个(i - 1 + capacity) % capacity为什么不可以写成(i - 1) % capacity ######     讲师回复： &gt;     如果直接 (i - 1) % capacity。当i = 0的时候，就变成了 -1 % capacity。结果等于 -1. 再作为下标访问数组，直接就挂了。 ##### **婷： &gt; 老师，可以出一套javascript版本的吗 ######     编辑回复： &gt;     可以考虑哦，小编再关注一下大家的需求度哈 ##### **军： &gt; 老师问一个问题，在求二叉树的最大宽度的时候，根结点那个编号串0和1好像结果都是一样的，这个有什么区别嘛？ ######     讲师回复： &gt;     没有本质上的区别。但是真正在工程上的时候，如果你用int64来表示，如果根结点标记为1，由于整棵树所有的结点二进制的前缀都是1，所以相当于你浪费了一个bit。推而广之，你也可以把根结点设置为3，但是你在用int64/int128表示的时候，你就浪费了2个bit ##### **勿扰： &gt; 这是我见过写得最好的算法课程了，通俗易懂，希望出个javascript版本的 ######     编辑回复： &gt;     感谢小伙伴的肯定，我们会继续努力的。JS版本后续会考虑的（老师已经听到大家的呼声了～～） ##### **臣： &gt; 一块钱花的挺值。课程确实硬核。 ######     编辑回复： &gt;     感谢小伙伴的认可，我们会继续加油做出更优质的内容！！ ##### **桂： &gt; &ldquo;&ldquo;&ldquo;1.请利用栈来实现一个队列的操作2.请用队列来实现一个栈的操作思路2：用2个栈实现一个队列：准备2个空栈A,B，向A中push元素；当需要pop操作，把栈A的元素全部pop，并push到栈B中，再弹出栈B中的栈顶元素。如继续pop操作，考虑栈B是否为空，如栈B非空，再弹出栈顶元素；否则继续上面的操作。用2个队列实现一个栈：准备两个空队列A,B，向A中push元素；当需要pop操作时，把队列A中的前n-1个元素pop，并push到队列B中，再弹出A中的元素。如果继续pop操作，交换队列A和B，继续上面的操作，直至两个队列均为空。&ldquo;&ldquo;&ldquo;classStack:def__init__(self):self.queueA[]self.queueB[]defpush(self,val):&ldquo;&ldquo;&ldquo;val:int:rtype&rdquo;&ldquo;&ldquo;self.queueA.append(val)defpop(self):&ldquo;&ldquo;&ldquo;int&rdquo;&ldquo;&ldquo;whilelen(self.queueA)1:self.queueB.append(self.queueA.pop(0))resself.queueA.pop(0)self.queueA,self.queueBself.queueB,self.queueAreturnresdefstack(self):&ldquo;&ldquo;&ldquo;List&rdquo;&ldquo;&ldquo;returnself.queueAclassQueue:def__init__(self):self.stackA[]self.stackB[]defpush(self,val):&ldquo;&ldquo;&ldquo;int&rdquo;&ldquo;&ldquo;self.stackA.append(val)defpop(self):whilelen(self.stackB)0:returnself.stackB.pop(-1)whilelen(self.stackA)0:self.stackB.append(self.stackA.pop(-1))returnself.stackB.pop(-1)defqueue(self):&ldquo;&ldquo;&ldquo;List&rdquo;&ldquo;&ldquo;returnlist(reversed(self.stackB))self.stackAif__name__&rdquo;__main__&quot;:sStack()foriinrange(5):s.push(i)print(&rsquo;\nStack:&rsquo;,s.stack())print(&lsquo;pop&rsquo;,s.pop())print(&lsquo;push1000&rsquo;)s.push(1000)print(&lsquo;Stack:&rsquo;,s.stack())print(&lsquo;pop&rsquo;,s.pop())print(&lsquo;pop&rsquo;,s.pop())print(&lsquo;Stack:&rsquo;,s.stack())qQueue()foriinrange(5):q.push(i)print(&rsquo;\nQueue:&rsquo;,q.queue())print(&lsquo;pop&rsquo;,q.pop())print(&lsquo;push1000&rsquo;)q.push(1000)print(&lsquo;Queue:&rsquo;,q.queue())print(&lsquo;pop&rsquo;,q.pop())print(&lsquo;Queue:&rsquo;,q.queue()) ######     讲师回复： &gt;     赞！ ##### **邪： &gt; 捡金币备注： 题目中使用k=2做示例，每个结果和后面两个数求和，得到最优结果，那么该index是最优路径。 ######     讲师回复： &gt;     k=2当然是可以手算啦。哈哈。面试官不会让你那么爽就把题做出来的。数组是有可能长达10^5.如果k = 数组长度，算起来就没那么爽了。 ##### **邪： &gt; // 队首元素就是最大值// 尝试去移除元素练习需验证：如果push的数都比较小，覆盖队列会一直增加？ ######     讲师回复： &gt;     也会有pop操作的啊。pop元素的时候，队列不就变短了么？ ##### **华： &gt; 例题4用动态规划解法更好理解 ######     讲师回复： &gt;     是可以用DP的。但是你可以想一下时间复杂度，时间复杂度就上去了。会达到O(NK) ##### **阳： &gt; 老师，为什么需要判断相等才出队列，这个判断有什么意义呢？单调队列的存在不就只是保证队列内部单调性吗 ######     讲师回复： &gt;     假设我们用的是单调递减的队列。你1米8的个子去排队喝奶茶，然后你排队的时候。你直接把前面个子比你小的人都扔出队列。直到前面的人都比你高，或者跟你一样。 老板叫2米2的人来拿奶茶，你知道肯定不是你。因为你是1.8米。 老板再叫1米9的人来拿奶茶。 老板再叫1米8，如果你发现你前面没有1米8个子的人，那妥妥地就是轮到你出队了啊。 不过不建议你用这种方式去买奶茶。 &gt; 保证单调性与出队并不矛盾。不能说，为了保证单调性，就不出队了是吧。比如，你排队买了奶茶，总不能继续让你排着队吧。^_^ 其实呢，在02讲的后面我也讲了另外一种出队的技巧。也就是例4的拓展部分。！！ 拓展：是否存在不同的出队方式？ 前面我们在学习单调队列的时候，利用了元素相等来判断是否出队。这种出队方式的特点是必须要保证单调队列不能是严格递减或者严格递增。 ##### *琪： &gt; 老师，请教个问题，deQueue函数内部，为什么this.front+1呢？ 把队列的首指针指向下一个元素，队列原本的首元素就自动被回收了吗？还有一个困惑，希望老师指点迷津： 学习队列和二叉树以来，感觉写的这些算法代码 没有实际的运行场景，比如二叉树用来数组来做测试用例，但是root.left root.right这些是都不存在数组上；循环队列的例子也一样，好像没办法运行。。。望老师百忙之中解答一下，困惑很久了。 ######     讲师回复： &gt;     1. 关于队首元素的回收。这里我们要实现的是一个循环队列，它只是提供一个空间给你放东西。现在我告诉你这个空间现在空出来了。可以放给后面的人用了。注意：空间还在。空间还在。相当于公交车上空出来了一个空位，位置还在啊。2. 实际运行的场景。你需要点开我提供给你的下面的Java/C++/Python那个链接。那个链接里面会说，这些代码可以到些测试平台上运行。比如：循环队列这个。你点开下面Java的链接，就可以找到测试平台： * [622] 设计循环队列 * * <a href="https://leetcode-cn.com/problems/design-circular-queue/description/">https://leetcode-cn.com/problems/design-circular-queue/description/</a> 后面的这个链接就是LeetCode的测试平台的链接。直接把代码粘贴过去就可以运行了。（注意选择正确的编程语言） ##### **凌： &gt; 感谢老师的分享，我觉得比自己刷题或者看书来得记忆更深刻，更简单易懂。但是还是需要大量练习去理解和加深记忆 ##### **林： &gt; 也可以出一套go语言的。 ######     讲师回复： &gt;     哈哈哈可以考虑一下 ##### *林： &gt; 捡金币能用动态规划解答吧？ ######     讲师回复： &gt;     是可以用DP的。但是你可以想一下时间复杂度，时间复杂度就上去了。会达到O(NK) ##### **兵： &gt; 为什么根据队列中第一个元素与i-k+1的值是否相等就能确定是否需要出队，实在理解不了呀 ######     讲师回复： &gt;     假设我们用的是单调递减的队列。你1米8的个子去排队喝奶茶，然后你排队的时候。你直接把前面个子比你小的人都扔出队列。直到前面的人都比你高，或者跟你一样。 老板叫2米2的人来拿奶茶，你知道肯定不是你。因为你是1.8米。 老板再叫1米9的人来拿奶茶。 老板再叫1米8，如果你发现你前面没有1米8个子的人，那妥妥地就是轮到你出队了啊。 不过不建议你用这种方式去买奶茶。 ##### *中： &gt; 例 4：捡金币游戏return get[N-1];返回的不是get[]元素最大值啊， ######     讲师回复： &gt;     题目是要求你一定要走到n-1这个位置的。然后你需要找一种走法，使得走到这个位置的金币最大化。所以返回get[N-1]。 ##### **6191： &gt; 老师，没能理解例三例四循环体的&quot;if(ik-1)&ldquo;和&quot;if(i - k 0)&ldquo;为什么能控制范围，不是只能控制刚开始队列未满不出列吗 ######     讲师回复： &gt;     对于例3和例4，这两句话，就是为了保证开始队列未满不出列。这样理解是对的。但是，如果没有了这两个if。那么队列里面存放的元素的范围也是无法保证的。 ##### **生： &gt; front应该是队头的前一个位置吧 ######     讲师回复： &gt;     front就是队首元素所在位置，（不是前面一个），它就是队首元素! ##### **帆： &gt; used 版本的循环队列，deQueue 在 ret = a[front] 后应该加一句 ######     讲师回复： &gt;     其实更精简的做法是直接不要ret = a[front]； 加在这里主要是为了做个说明，ret就是我们要deQueue出来的元素。 ##### **帆： &gt; 感觉 used 方式实现循环队列的 deQueue 方法有点问题。1&rdquo;```jspublic boolean deQueue() { if (isEmpty()) { }&quot;&gt;a[front] = null; }``` ######     讲师回复： &gt;     while (true) {printf(&ldquo;解法是原题 LeetCode 622，100%包过，不包过罚我抄INT_MAX遍&rdquo;);} ##### **9545： &gt; js版本也得需要啊 ##### *炜： &gt; 我有个地方没听明白，为什么在pop元素的时候，要将value传进去，判断和队列第一个元素相等才移除呢？直接移除队列的第一个元素不行吗 ######     讲师回复： &gt;     1. 如果直接出队的话，就和FIFO队列没有区别了。2. 此外，在入队的时候，已经保证了有序性。把一些元素弹出去了。如果直接出栈就会出错。3. 判断相等的过程，实际上就是在判断“这些元素是不是之前被弹出去过了？“如果在入栈时就被弹出去了，那么就应该什么也不做。 最后，还有另外一种弹栈方法的，在后面有介绍，可以看一下。 ##### *程： &gt; 可以的</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">数据结构与算法面试宝典</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90mybatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/02%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F%E6%8C%81%E4%B9%85%E5%B1%82%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%9020%E5%88%86%E9%92%9F%E5%B8%A6%E4%BD%A0%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bmybati/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">02订单系统持久层示例分析，20分钟带你快速上手MyBati</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%A9%E8%BD%ACserverless%E6%9E%B6%E6%9E%84/02%E6%A6%82%E5%BF%B5%E6%96%B0%E7%9F%A5%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AFserverle/">
            <span class="next-text nav-default">02概念新知：到底什么是Serverle</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
