<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>05链表：如何利用“假头、新链表、双指针”解决链表题？（下） - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="在上一讲中，我给你介绍了解决链表问题的“三板斧”中的第一斧：假头，你知道了带假头的链表一共有 6 种基本的操作，分别是初始化、追加结点、头部插入结点、查找结点、插入指定位置之前和删除结点。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/05%E9%93%BE%E8%A1%A8%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%81%87%E5%A4%B4%E6%96%B0%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E5%86%B3%E9%93%BE%E8%A1%A8%E9%A2%98%E4%B8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/05%E9%93%BE%E8%A1%A8%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%81%87%E5%A4%B4%E6%96%B0%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E5%86%B3%E9%93%BE%E8%A1%A8%E9%A2%98%E4%B8%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="05链表：如何利用“假头、新链表、双指针”解决链表题？（下）">
  <meta property="og:description" content="在上一讲中，我给你介绍了解决链表问题的“三板斧”中的第一斧：假头，你知道了带假头的链表一共有 6 种基本的操作，分别是初始化、追加结点、头部插入结点、查找结点、插入指定位置之前和删除结点。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="数据结构与算法面试宝典">

  <meta itemprop="name" content="05链表：如何利用“假头、新链表、双指针”解决链表题？（下）">
  <meta itemprop="description" content="在上一讲中，我给你介绍了解决链表问题的“三板斧”中的第一斧：假头，你知道了带假头的链表一共有 6 种基本的操作，分别是初始化、追加结点、头部插入结点、查找结点、插入指定位置之前和删除结点。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="11234">
  <meta itemprop="keywords" content="数据结构与算法面试宝典">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="05链表：如何利用“假头、新链表、双指针”解决链表题？（下）">
  <meta name="twitter:description" content="在上一讲中，我给你介绍了解决链表问题的“三板斧”中的第一斧：假头，你知道了带假头的链表一共有 6 种基本的操作，分别是初始化、追加结点、头部插入结点、查找结点、插入指定位置之前和删除结点。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">05链表：如何利用“假头、新链表、双指针”解决链表题？（下）</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 11234 字 </span>
          <span class="more-meta"> 预计阅读 23 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>在上一讲中，我给你介绍了解决链表问题的“三板斧”中的第一斧：假头，你知道了带假头的链表一共有 6 种基本的操作，分别是初始化、追加结点、头部插入结点、查找结点、插入指定位置之前和删除结点。</p>
<p>如果说三板斧的第一斧平平淡淡，大巧不工；第二斧就是鬼斧神工，生成新链表后，链表的交换、反转求解都会变得极其简单 ；第三斧则是奇思妙想，双指针（也叫快慢指针）用在链表上经常可以解决一些单个指针难以解决的问题。学会了这两种思路，算法面试中的链表题就如同探囊取物了。</p>
<p>注：大部分链表题主要考查动手能力，因此在本讲将不再按照“分析四步法”进行讲解。</p>
<p>三板斧的第二斧：新链表</p>
<p>做链表的反转、交换等操作时，我不建议直接在原来的链表上进行操作。一种可取的思路是，把这些操作想象成要生成新的链表，然后借助这些新的链表，完成原本比较复杂的操作。这个方法就是我们今天要讲的**“第二斧”——新链表**。</p>
<p>接下来，我将采用这种新思路，带你解决一些面试中经常会遇到的疑难题目。</p>
<p>例 1：链表反转</p>
<p>【题目】输入一个链表的头结点，反转该链表，并返回反转后链表的头结点。</p>
<p>输入：1-&gt;2-&gt;3</p>
<p>输出：3-&gt;2-&gt;1</p>
<p>【分析】这里借助假头和新链表求解，思路如下：</p>
<p>建立一个新的带假头的空链表；</p>
<p>遍历旧链表，依次取出旧链表中的每个结点；</p>
<p>采用头部插入的方法放到新链表中；</p>
<p>返回 dummy.next。</p>
<p>【画图】这里我们利用示意图演示如下：</p>
<p>【代码】对应的代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public ListNode reverseList(ListNode head) {
</span></span><span class="line"><span class="cl">        // 建立一个新的带假头的新链表
</span></span><span class="line"><span class="cl">        ListNode dummy = new ListNode();
</span></span><span class="line"><span class="cl">        // 开始遍历旧链表
</span></span><span class="line"><span class="cl">        while (head != null) {
</span></span><span class="line"><span class="cl">            ListNode tmp = head.next;
</span></span><span class="line"><span class="cl">            // 把旧链表中的结点取出来，采用头部插入的方法添加到新链表中
</span></span><span class="line"><span class="cl">            head.next = dummy.next;
</span></span><span class="line"><span class="cl">            dummy.next = head;
</span></span><span class="line"><span class="cl">            head = tmp;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 返回新链表的头，注意，不要返回dummy!!
</span></span><span class="line"><span class="cl">        return dummy.next;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：每个结点只遍历一次，所以时间复杂度为 O(N)，内存空间只使用了常量空间，因此空间复杂度为 O(1)。</p>
<p>【小结】仔细查看代码之后，链表反转的考点就是之前我们学到的基本操作：假头，头部插入法，再结合今天学习的新链表的思路。可以总结如下：</p>
<p>例 2：删除结点</p>
<p>【题目】给定一个链表头及一个整数值，要求把链表里面等于整数值的结点都从链表中移除出去。</p>
<p>输入：1-&gt;2-&gt;3-&gt;2-&gt;4, remove = 2</p>
<p>输出：1-&gt;3-&gt;4。</p>
<p>解释：要移除的整数值是 2。那么移除之后，返回的结果应该是 1-&gt;3-&gt;4。</p>
<p>【分析】这里我们不采用在原来的链表上进行删除的办法，而是采用新链表的操作思路：</p>
<p>建立一个新的带假头的空链表；</p>
<p>遍历旧链表，依次取出旧链表中的每个点，如果不删除这个结点，那么就采用尾部插入方法接到新链表中。</p>
<p>可以发现，在这里没有出现结点交换的操作。采用新链表的思路，避免了在原链表上不停地做结点的删除。为了方便你理解，我制作了动图演示，如下所示：</p>
<p>【代码】基于以上思想，可以写出代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public ListNode removeElements(ListNode head, int val) {
</span></span><span class="line"><span class="cl">        // 生成一个新链表
</span></span><span class="line"><span class="cl">        ListNode dummy = new ListNode();
</span></span><span class="line"><span class="cl">        ListNode tail = dummy;
</span></span><span class="line"><span class="cl">        // 依次取出旧链表中的每个结点
</span></span><span class="line"><span class="cl">        ListNode p = head;
</span></span><span class="line"><span class="cl">        while (p != null) {
</span></span><span class="line"><span class="cl">            ListNode back = p.next;
</span></span><span class="line"><span class="cl">            // 如果结点值需要保留，那么采用属部追加的方法
</span></span><span class="line"><span class="cl">            // 添加到新链表中
</span></span><span class="line"><span class="cl">            if (p.val != val) {
</span></span><span class="line"><span class="cl">                tail.next = p;
</span></span><span class="line"><span class="cl">                tail = p;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            p = back;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 注意设置尾巴的next为空
</span></span><span class="line"><span class="cl">        tail.next = null;
</span></span><span class="line"><span class="cl">        // 注意返回的是dummy.next
</span></span><span class="line"><span class="cl">        return dummy.next;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度 O(N)，空间复杂度 O(1)。</p>
<p>【小结】我们将这道题的考点层层剥离之后，就只剩下生成 dummy 新链表，尾巴追加新结点，以及新链表的思路。关于解决这道这类题目的思路、重点以及分析方法，建议你先尝试自己梳理总结，再来看我给出的思维导图：</p>
<p>如果我们仔细对比链表反转与删除结点，会发现，这两者的不同之处在于：</p>
<p>链表反转使用的是头部插入的方法</p>
<p>删除结点采用的是尾部追加的方法</p>
<p>只是换了一个考点，题目就完全大变样了。如果我们再严格地对比这两个题目，可以发现：</p>
<p>链表反转时，头部插入是无条件的</p>
<p>删除结点时，尾部 append 是有条件的</p>
<p>这种条件的千变万化，会带来很多有趣的题目。比如下面这道练习题。</p>
<p>练习题 1：给定一个排序链表，删除重复出现的元素，使得每个元素只出现一次。</p>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</p>
<p>输出: 1-&gt;2-&gt;3</p>
<p>代码：Java/C++/Python</p>
<p>练习题 2：给定一个排序链表，删除重复出现的元素，只留下没有重复出现的元素。</p>
<p>输入：1-&gt;1-&gt;2-&gt;3-&gt;3</p>
<p>输出：2</p>
<p>代码：Java/C++/Python</p>
<p>你可以把答案或者思考的过程写在评论区，我们一起讨论。</p>
<p>例 3 ：合并</p>
<p>【题目】合并给定的两个有序链表。</p>
<p>输入：a = 1-&gt;4-&gt;6, b = 3-&gt;5-&gt;7</p>
<p>输出：1-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7</p>
<p>【分析】首先应该是生成一个带假头的新链表 C，然后把 A，B 中的元素从小到大，依次添加到新生成的链表 C 中。因此，我们还需要使用到尾部插入法。</p>
<p>具体操作方法如下。</p>
<p>第一步：A，B 两个指针分别指向 A，B 链表的表头。</p>
<p>第二步：依次取出 A，B 两个指针中更小的值加入新链表中。</p>
<p>第三步：返回 C 链表假头的 next。</p>
<p>具体演示如下所示：</p>
<p>【代码】有了前面的思路，可以写出代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
</span></span><span class="line"><span class="cl">        // 首先生成空链表
</span></span><span class="line"><span class="cl">        ListNode dummy = new ListNode();
</span></span><span class="line"><span class="cl">        ListNode tail = dummy;
</span></span><span class="line"><span class="cl">        // 遍历两个有序链表,每次只取一个结点append到新链表里面
</span></span><span class="line"><span class="cl">        while (l1 != null || l2 != null) {
</span></span><span class="line"><span class="cl">            // 如果l2链表为空，或者l1链表里面的值更小，那么取l1结点追加到
</span></span><span class="line"><span class="cl">            // 新链表尾部
</span></span><span class="line"><span class="cl">            if (l2 == null || l1 != null &amp;&amp; l1.val &lt; l2.val) {
</span></span><span class="line"><span class="cl">                tail.next = l1;
</span></span><span class="line"><span class="cl">                tail = l1;
</span></span><span class="line"><span class="cl">                l1 = l1.next;
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                // 其他情况，则把l2结点添加到新链表尾部
</span></span><span class="line"><span class="cl">                tail.next = l2;
</span></span><span class="line"><span class="cl">                tail = l2;
</span></span><span class="line"><span class="cl">                l2 = l2.next;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 注意：这里一定要记得把tail.next设置为空。
</span></span><span class="line"><span class="cl">        // 虽然这个题可能并不需要，但是应该养成收尾的好习惯
</span></span><span class="line"><span class="cl">        tail.next = null;
</span></span><span class="line"><span class="cl">        // 返回dummy.next, 不要返回dummy!!
</span></span><span class="line"><span class="cl">        return dummy.next;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度 O(N)，空间复杂度 O(1)。</p>
<p>【小结】如果我们再分析一下这道题目，可以发现考点仍然是：</p>
<p>生成 dummy 新链表</p>
<p>选择结点往新链表尾部追加数据</p>
<p>此时的尾部 append 是有条件的：需要从两个链表头中选择一个较小的数据进行追加。当然，有条件的 append 还可以变成各种其他的条件来操作。不过即使千变万化，只要你看清楚题的考点，就能轻松应对、。</p>
<p>那么这里我们不妨再选择其中一个考点“选择较小的数”进行练习。在原题中，只有两个链表，所以可以直接通过比较得到较小的结点。可是如果有 k 个链表要合并的时候，又应该怎么做呢？比如下面这道练习题：</p>
<p>练习题 3：给定 k 个有序链表，合并成一个有序链表</p>
<p>输入：[1-&gt;4-&gt;5，1-&gt;3-&gt;4, 2-&gt;6]</p>
<p>输出：[1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6]</p>
<p>代码：Java/C++/Python</p>
<p>你可以把答案或者思考的过程写在评论区，我们一起讨论。</p>
<p>例 4：交换链表中的结点</p>
<p>【题目】给定一个链表，需要将里面的结点两两交换。</p>
<p>输入：[1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6]</p>
<p>输出：[2-&gt;1-&gt;4-&gt;3-&gt;6-&gt;5]</p>
<p>【分析】经过观察发现，只不过把偶数位置与奇数位置的结点进行了交换。为了避免在原始链表中进行结点间的交换操作，我们可以采用如下方法：</p>
<p>生成两个新链表，一个用来存放奇数位置结点的链表 odd，一个用来存放偶数位置结点的链表 even；</p>
<p>遍历旧链表，并且把奇数位置上的结点放到 odd 链表中，把偶数位置的结点放到链表 even 中；</p>
<p>合并 odd 链表与 even 链表。</p>
<p>为了方便你理解，我同样制作了动图演示，如下：</p>
<p>到这里，新增链表已经从一条变成了两条，来帮助我们解决这道题目。</p>
<p>【代码】有了思路，我们可以写出代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    private ListNode mergeList(ListNode a, ListNode b) {
</span></span><span class="line"><span class="cl">        ListNode dummy = new ListNode();
</span></span><span class="line"><span class="cl">        ListNode tail = dummy;
</span></span><span class="line"><span class="cl">        // 合并两个链表
</span></span><span class="line"><span class="cl">        while (a != null || b != null) {
</span></span><span class="line"><span class="cl">            // 如果a不空，那么先取a结点
</span></span><span class="line"><span class="cl">            if (a != null) {
</span></span><span class="line"><span class="cl">                tail.next = a;
</span></span><span class="line"><span class="cl">                tail = a;
</span></span><span class="line"><span class="cl">                a = a.next;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // 如果b不空，再取b结点
</span></span><span class="line"><span class="cl">            if (b != null) {
</span></span><span class="line"><span class="cl">                tail.next = b;
</span></span><span class="line"><span class="cl">                tail = b;
</span></span><span class="line"><span class="cl">                b = b.next;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 注意收尾
</span></span><span class="line"><span class="cl">        tail.next = null;
</span></span><span class="line"><span class="cl">        return dummy.next;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public ListNode swapPairs(ListNode head) {
</span></span><span class="line"><span class="cl">        // 生成奇数index应该存放的链表
</span></span><span class="line"><span class="cl">        ListNode oddDummy = new ListNode();
</span></span><span class="line"><span class="cl">        ListNode oddTail = oddDummy;
</span></span><span class="line"><span class="cl">        // 生成偶数index应该存放的链表
</span></span><span class="line"><span class="cl">        ListNode evenDummy = new ListNode();
</span></span><span class="line"><span class="cl">        ListNode evenTail = evenDummy;
</span></span><span class="line"><span class="cl">        int index = 0;
</span></span><span class="line"><span class="cl">        ListNode p = head;
</span></span><span class="line"><span class="cl">        while (p != null) {
</span></span><span class="line"><span class="cl">            ListNode back = p.next;
</span></span><span class="line"><span class="cl">            //  如果是偶数，放到偶数链表中
</span></span><span class="line"><span class="cl">            if ((index &amp; 0x01) == 0) {
</span></span><span class="line"><span class="cl">                evenTail.next = p;
</span></span><span class="line"><span class="cl">                evenTail = p;
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                // 如果是奇数，放到奇数链表中
</span></span><span class="line"><span class="cl">                oddTail.next = p;
</span></span><span class="line"><span class="cl">                oddTail = p;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            index++;
</span></span><span class="line"><span class="cl">            p = back;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 注意两个链表的收尾
</span></span><span class="line"><span class="cl">        oddTail.next = null;
</span></span><span class="line"><span class="cl">        evenTail.next = null;
</span></span><span class="line"><span class="cl">        // 注意这里传入的是oddDummy.next和evenDummy.next
</span></span><span class="line"><span class="cl">        return mergeList(oddDummy.next, evenDummy.next);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：每个结点会访问两次，拆分一次，合并一次，所以时间复杂度为 O(N)，空间复杂度为 O(1)。</p>
<p>【小结】这道题的考点也比较明确了，可以拆分出以下考点：</p>
<p>拆分链表</p>
<p>新链表的思路</p>
<p>合并链表的操作</p>
<p>尤其需要注意的是，使用新链表思路时，可以通过生成多条新链表来解决以前处理起来比较麻烦的问题。至此，我们一起进一步扩展了链表知识。此外，还发现了一些小型的组合操作，比如：**拆分链表，合并链表。**在合并时，如果按照不同的条件合并，就需要写出不一样的合并代码，结合前面例 3，可以知道合并分两种：</p>
<p>有序合并</p>
<p>先后合并</p>
<p>到这里可以总结出我们更加丰富的知识路线图，如下图所示：</p>
<p>在这道题中，链表是两两成对进行了反转，那么如果是 k 个一组进行反转应该怎么办呢？我们再来看看与交换有关的练习题。</p>
<p>练习题 4：给定一个链表，要求将链表 k 个一组进行反转，如果最后一组不足 k 个，那么不反转。返回反转之后的链表。</p>
<p>输入：A = [1, 2, 3, 4, 5], k = 2</p>
<p>输出: [2, 1, 4, 3, 5]</p>
<p>代码：Java/C++/Python</p>
<p>练习题 5：给定一个链表，从链表尾部开始，k 个一组进行反转，如果左边的分组不足 k 个，那么不反转。返回反转之后的链表。</p>
<p>输入：A = [1, 2, 3, 4, 5], k = 2</p>
<p>输出：[1, 3, 2, 5, 4]</p>
<p>解释：注意是从链表的尾部开始k个一组的。所以这里是[1], [2, 3], [4, 5]这样分组来进行反转。</p>
<p>代码：Java/C++/Python</p>
<p>三板斧的第三斧：双指针</p>
<p>虽然新链表的思路非常有趣，但是关于它的更多探索还是应该留给你自己。收拾好行囊，我们将要去看更加瑰丽的奇景——双指针。</p>
<p>双指针，顾名思义就是两个指针在链表上移动。实际上，我们在前面链表的查找中已经使用过双指针了：比如链表中指定位置插入一个新结点，就使用了两个指针，一前一后两个指针在链表上前进。</p>
<p>其实两个指针在链表上前进时，有很多种形式，常见的主要有以下两种。</p>
<p>间隔指针：前面的指针先走一步，然后后面的指针再一起走；前面的指针先走 k 步，后面的指针再一起走。</p>
<p>快慢指针：两个指针的速度一快一慢前进，比如一个每次走一步，一个每次走两步。</p>
<p>接下来，我们来看看双指针能解决什么类型的问题。</p>
<p>例 5：链表的倒数第 k 个结点</p>
<p>【题目】给定一个链表，删除链表中的倒数第 k 个结点。这里我们认为最后一个结点是倒数第 1 个。</p>
<p>输入：1-&gt;2-&gt;3, k = 2</p>
<p>输出： 1-&gt;3</p>
<p>【分析】首先第一种常规思路是，先统计出整个链表的长度 len, 再去取第 len-k 结点的前驱进行删除。</p>
<p>但是，面试的时候，面试官往往会加一个限制条件 ：只能遍历链表一次。</p>
<p>以后凡是遇到链表题，看到这句话，实际上就是在告诉你“用双指针吧”。思路如下：</p>
<p>在原链表前面加上 dummy，变成带假头的链表</p>
<p>front 指针从 dummy 开始，走 k 步，然后停下来</p>
<p>back 指针指向链表 dummy 假头</p>
<p>然后两个指针再一起走</p>
<p>当 front 指针指向最后一个结点时，back 指针刚好指向倒数第 k 个结点的前驱。</p>
<p>解题思路有了，还有两个细节需要你特别注意。</p>
<p>【细节 1】你需要小心处理三种情况：</p>
<p>链表长度 &lt; k，此时什么也不做；</p>
<p>链表长度 == k，此时删除原来的链表头结点；</p>
<p>链表长度 &gt; k，此时找到倒数第 k 个结点的前驱，然后删除倒数第 k 个结点。</p>
<p>接下来，我们分别讨论这三种情况。</p>
<p>情况 1：链表长度小于 k。front 指针会先走 k 步，如果链表长度小于 k，那么必然会导致 front 指针行走的步数小于 k，此时应该什么也不做。</p>
<p>情况 2：链表长度等于 k。此时需要删除倒数第 k 个结点，也就是旧链表的 head 结点。</p>
<p>当 front 指针先走完 k 步之后，back 指针刚好位于 dummy 结点。而 dummy 结点就是倒数第 k+1 个结点，那么此时可以直接通过 back 指针删除它后面的结点（刚好是 head，也就是倒数第 k 个）。</p>
<p>情况 3：链表长度大于 k。back 指针刚好位于倒数第 k+1 个结点，此时可以直接通过 back 指针删除它后面的结点（刚好是倒数第 k 个)。</p>
<p>我们发现：情况 2 和情况 3 实际上都是用 back 指针来删除后面的结点。因此，这两种情况可以一起处理。</p>
<p>【细节 2】任何时候，front 最后停下来的位置一定要位于链表的最后一个结点。这是因为：要想删除倒数第 k 个结点的前驱结点，需要 back 刚好指向倒数第 k+1 个结点，那么就必须要让 front 非空，即指向倒数第一个结点。</p>
<p>【代码】有了思路以及相应的细节，我们就可以利用代码来解决问题了（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public ListNode removeNthFromEnd(ListNode head, int k) {
</span></span><span class="line"><span class="cl">        // 将链表改造成带假头的链表
</span></span><span class="line"><span class="cl">        ListNode dummy = new ListNode();
</span></span><span class="line"><span class="cl">        dummy.next = head;
</span></span><span class="line"><span class="cl">        // 链表长度
</span></span><span class="line"><span class="cl">        int preWalkedSteps = 0;
</span></span><span class="line"><span class="cl">        // front指针从dummy开始先走k步
</span></span><span class="line"><span class="cl">        ListNode front = dummy;
</span></span><span class="line"><span class="cl">        // 注意front不能为空，需要指向链表的最后一个结点
</span></span><span class="line"><span class="cl">        while (preWalkedSteps &lt; k &amp;&amp;
</span></span><span class="line"><span class="cl">               front != null &amp;&amp; front.next != null) {
</span></span><span class="line"><span class="cl">            front = front.next;
</span></span><span class="line"><span class="cl">            preWalkedSteps++;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // back指针指向dummy，然后front与back指针一起走
</span></span><span class="line"><span class="cl">        ListNode back = dummy;
</span></span><span class="line"><span class="cl">        // 注意front不能为空，需要指向链表的最后一个结点
</span></span><span class="line"><span class="cl">        while (front != null &amp;&amp; front.next != null) {
</span></span><span class="line"><span class="cl">            back = back.next;
</span></span><span class="line"><span class="cl">            front = front.next;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 如果preWalkedSteps == k
</span></span><span class="line"><span class="cl">        // 说明处于情况2和情况3，需要删除倒数第k个结点
</span></span><span class="line"><span class="cl">        if (preWalkedSteps == k) {
</span></span><span class="line"><span class="cl">            back.next = back.next.next;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 返回新的链表头
</span></span><span class="line"><span class="cl">        return dummy.next;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度 O(N)，空间复杂度 O(1)</p>
<p>【小结】当做完这道题之后，我们可以进一步完善双指针的技巧，总结的思维导图如下：</p>
<p>然后，我们再来总结一下这道题目的考点。首先除了思路“双指针”以外，你还需要注意写代码的技巧。</p>
<p>将旧链表改造成带 dummy 结点的链表，方便删除 head 结点。这是能让情况 2 和情况 3 统一处理的关键。</p>
<p>让指针指向链表最后一个结点的 while 语句的写法。</p>
<p>利用移动步数来判断链表长度与 k 的关系。</p>
<p>接下来我们一起看一下双指针的另外一种形式，快慢指针。</p>
<p>例 6：拆分链表</p>
<p>【题目】给定一个链表，需要把链表从中间拆分成长度相等的两半（如果链表长度为奇数，那么拆分之后，前半部分长度更长一点）。</p>
<p>输入：[1-&gt;2-&gt;3-&gt;4-&gt;5]</p>
<p>输出：[1-&gt;2-&gt;3, 4-&gt;5]</p>
<p>【分析】我们需要分为 2 步：</p>
<p>找到链表的中间结点</p>
<p>从中间结点把链表分为两半</p>
<p>那么问题是，如何找到中间结点呢？如果是首先求出链表的长度，然后再利用 getPreNode(len/2) 函数的前驱，再把链表拆分成两半。</p>
<p>但是，这可能不是面试官想要的解法，因为这种解法会将链表遍历两遍，面试官可能会说：“只能遍历一次”。又听到了这个声音，这就是告诉你需要用双指针了。</p>
<p>所以问题的关键就是如何使用双指针找到链表的中间结点，可以采用如下办法：</p>
<p>假设链表头在左边，尾巴在右边，两个指针 s1、s2 从链表头开始往右走；</p>
<p>s1 表示每次只往前走一步，s2 则表示每次只往前走 2 步；</p>
<p>在同样的时间内，当 s2 指向链表的末尾，s1 指针便指向链表的中间结点。</p>
<p>只是在写代码的时候，需要特别注意以下 2 点：</p>
<p>1.当有偶数个结点，s2 是空指针，此时，s1 位于后半部分指针的头部，因此需要返回s1 的前驱；</p>
<p>2.当有奇数个结点，s2 是最后一个结点，此时 s1 指针位于前半部分的最后，直接返回 s1即可。</p>
<p>如果找到了中间结点，那么就可以直接进行拆分了。</p>
<p>【代码】接下来我们就实现拆分链表的逻辑，代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    private ListNode findMiddleNode(ListNode head) {
</span></span><span class="line"><span class="cl">        // 注意这里转化为带假头的链表，免去了空链表的判断
</span></span><span class="line"><span class="cl">        ListNode dummy = new ListNode();
</span></span><span class="line"><span class="cl">        dummy.next = head;
</span></span><span class="line"><span class="cl">        // 注意，假头并不算是链表的一部分，所以这里是从head开始走
</span></span><span class="line"><span class="cl">        ListNode s2 = head;
</span></span><span class="line"><span class="cl">        ListNode s1 = head;
</span></span><span class="line"><span class="cl">        // dummy就是head的前驱，所以pre要指向dummy.
</span></span><span class="line"><span class="cl">        ListNode pre = dummy;
</span></span><span class="line"><span class="cl">        // 两个指针开始同时走
</span></span><span class="line"><span class="cl">        // 因为s2指针每次都要走两步，所以判空需要这样判断。
</span></span><span class="line"><span class="cl">        while (s2 != null &amp;&amp; s2.next != null) {
</span></span><span class="line"><span class="cl">            pre = s1;
</span></span><span class="line"><span class="cl">            s1 = s1.next;
</span></span><span class="line"><span class="cl">            s2 = s2.next.next;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 当有偶数个结点的时候，s2是空指针，
</span></span><span class="line"><span class="cl">        // 此时，s1位于后半部分指针的头部，因此需要返回s1的前驱。
</span></span><span class="line"><span class="cl">        // 当有奇数个结点的时候，s2是最后一个结点，
</span></span><span class="line"><span class="cl">        // 此时s1指针位于前半部分的最后，直接返回s1即可。
</span></span><span class="line"><span class="cl">        return s2 != null ? s1 : pre;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public ListNode[] split(ListNode head) {
</span></span><span class="line"><span class="cl">        // 这里获取了链表的中间结点
</span></span><span class="line"><span class="cl">        ListNode mid = findMiddleNode(head);
</span></span><span class="line"><span class="cl">        // 拿到链表的中间结点之后，可以得到链表的后半部分的开头
</span></span><span class="line"><span class="cl">        ListNode back = mid.next;
</span></span><span class="line"><span class="cl">        // 把链表拆分为两半
</span></span><span class="line"><span class="cl">        mid.next = null;
</span></span><span class="line"><span class="cl">        // 返回两个链表的头部
</span></span><span class="line"><span class="cl">        return new ListNode[]{head, back};
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度 O(N)，空间复杂度 O(1)。</p>
<p>【小结】这道题的核心就是如何通过双指针找到链表的中间结点。考点还是清晰明了，我们可以再将双指针的分析要点总结如下：</p>
<p>不过对于这道题，我想给你留几个有趣的小问题，可以帮助你加深代码的理解，希望你可以尝试回答以下两个问题，并写在留言区，我们一起讨论。</p>
<p>为什么没有判断空链表，对于空链表的支持是怎么完成的？</p>
<p>为什么 s1, s2 要从 head 开始走，如果从 dummy 开始走可以吗？如果可以，会有什么样的代码改动？</p>
<p>练习题 6： 将一个链表进行重排，如果我们用 L[x] 表示链表的第 x 个结点（从 0 开始）。将链表 L[0]-&gt;L[1]-&gt;L[2]-&gt;L[3]-&gt; &hellip;. -&gt;L[N-1] 重新排列为 L[0]-&gt;L[N-1]-&gt;L[1]-&gt;L[N-2]-&gt;L[2]-&gt;L[N-3]&hellip;..。</p>
<p>输入：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>输出：1-&gt;5-&gt;2-&gt;4-&gt;3</p>
<p>代码：Java/C++/Python</p>
<p>例 7：链表环问题</p>
<p>【题目】给定一个链表，原本的链表尾巴如果不为空，并且指向了链表的中间结点，这样我们就认为这个链表存在一个环。给定一个链表，判断链表中是否存在环？</p>
<p>【分析】首先，如果链表中存在环，只用一个指针遍历肯定是永无止境的，这一个指针会在环里面打转。因此，我们可以再次利用双指针，s1，s2 两个指针都从链表头开始，s1 指针表示每次只往前走一步，s2 指针则是每次只往前走两步。那么链表最终只有两种情况：</p>
<p>1.s1 == s2，这个时候链表存在环；</p>
<p>2.s1 != s2，这个时候链表不存在环。</p>
<p>不过我们还是需要处理两种边界条件：</p>
<p>当为空链表的时候，s1 == s2，但是实际上此时链表无环；</p>
<p>当链表中只存在一个结点，并且无环的时候，运行的结果也会是 s1 == s2。</p>
<p>这两种边界条件的处理，只需要特殊判断一下即可。</p>
<p>【代码】有了前面了思路，那么我们就可以写出解问题的代码了（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class Solution {
</span></span><span class="line"><span class="cl">    public boolean hasCycle(ListNode head) {
</span></span><span class="line"><span class="cl">        // 空链表和只有一个结点的链表的实现。
</span></span><span class="line"><span class="cl">        if (head == null || head.next == null) {
</span></span><span class="line"><span class="cl">            return false;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 分别设置两个快慢指针，他们都从head出发。
</span></span><span class="line"><span class="cl">        // s1表示慢指针，一次只走一步
</span></span><span class="line"><span class="cl">        // s2表示快指针，一次走两步
</span></span><span class="line"><span class="cl">        ListNode s1 = head;
</span></span><span class="line"><span class="cl">        ListNode s2 = head;
</span></span><span class="line"><span class="cl">        // 开始走动两个指针，
</span></span><span class="line"><span class="cl">        // 当相遇到的时候就停下来
</span></span><span class="line"><span class="cl">        while (s2 != null &amp;&amp; s2.next != null) {
</span></span><span class="line"><span class="cl">            s2 = s2.next.next;
</span></span><span class="line"><span class="cl">            s1 = s1.next;
</span></span><span class="line"><span class="cl">            if (s1 == s2) {
</span></span><span class="line"><span class="cl">                break;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 判断是否有环。如果有环，那么两个指针必定相遇。
</span></span><span class="line"><span class="cl">        return s1 == s2;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度为 O(N)，空间复杂度为 O(1)。</p>
<p>【小结】至此，我们完成了快慢指针的学习，可以在知识图谱中加上链表环问题了，如下图所示：</p>
<p>这里我还想给你留一个小问题：在寻找链表环的过程中，对于两种特殊情况，我们实际上进行了特殊判断，那么有没有什么办法可以避免这种特殊的断呢？</p>
<p>小提示：想想我们之前学习过的假头。</p>
<p>老规矩，希望你尝试思考并把想法写在留言区，期待和你一起讨论。另外，我也会根据大家的留言反馈，不定时输出加餐内容，比如练习题详解、留言区问题点评等。</p>
<p>【扩展】在面试中，伴随着链表环问题的，往往还有后招：如果链表中存在环，能不能把形成环的那个结点找出来？</p>
<p>我们可以把这个问题转化成一个数学问题。我们一起看一下下面这张图：</p>
<p>这里我们只考虑链表存在环的情况。假设 s1 慢指针与 s2 快指针在环中某个位置相遇。此时：</p>
<p>s1 指针走过的路径长度为 a = x + y</p>
<p>s2 指针走过的路径长度为 b = x + y + n * (y + z)</p>
<p>由于两个指针都是从同一个地点出发，s2 指针走得更快，那么走的长度肯定是 s1 指针的两倍。所以可以得到 b = 2a，即 b = x + y + n * (y + z) = 2x + 2y</p>
<p>由此，可以推导出 x = n * (y + z) - y = (n-1)*(y+z) + z，即 x - z = (n-1) * (y + z)</p>
<p>从 x-z 表达式可以看出，如果有两个指针同时从头结点，相遇结点这两个地方出发，它们肯定会在环形入口相遇。因为它**们之间的差值刚好是圆环长度的整数倍（**更加严格一点的证明可以用数学归纳法）。</p>
<p>经过数学证明，我们可以写出求解代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class Solution {
</span></span><span class="line"><span class="cl">    public ListNode detectCycle(ListNode head) {
</span></span><span class="line"><span class="cl">        // 这里都是判断链表是否存在环
</span></span><span class="line"><span class="cl">        if (head == null || head.next == null) {
</span></span><span class="line"><span class="cl">            return null;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        ListNode s1 = head;
</span></span><span class="line"><span class="cl">        ListNode s2 = head;
</span></span><span class="line"><span class="cl">        while (s2 != null &amp;&amp; s2.next != null) {
</span></span><span class="line"><span class="cl">            s1 = s1.next;
</span></span><span class="line"><span class="cl">            s2 = s2.next.next;
</span></span><span class="line"><span class="cl">            if (s1 == s2) {
</span></span><span class="line"><span class="cl">                break;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 当不存在链表环的时候，直接返回null
</span></span><span class="line"><span class="cl">        if (s1 != s2) {
</span></span><span class="line"><span class="cl">            return null;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // s1指针重新指向链表head，从head出发
</span></span><span class="line"><span class="cl">        s1 = head;
</span></span><span class="line"><span class="cl">        // s2指针此时位于相遇的位置
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 然后两个指针一起走
</span></span><span class="line"><span class="cl">        while (s1 != s2) {
</span></span><span class="line"><span class="cl">            s1 = s1.next;
</span></span><span class="line"><span class="cl">            s2 = s2.next;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 返回环形的入口结点
</span></span><span class="line"><span class="cl">        return s1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度为 O(N)，空间复杂度为 O(1)。</p>
<p>总结与延伸</p>
<p>经过这两讲的学习，你终于可以用这三板斧来毒打链表题了，在抄家伙之前，我们一起回想下每招式的作用吧。</p>
<p>第一斧：假头。假头的作用主要是避免关于空链表的判断与讨论，假头还可以用来避免检查前驱结点为空的情况。</p>
<p>第二斧：新链表。新链表的引入是为了解决在旧链表中进行原地的交换、插入、删除，把复杂的操作变成在新链表中头部插入或者尾部添加。</p>
<p>第三斧：双指针。双指针主要是用于寻找链表中的特定结点，双指针的走法可以一次一步，可以有快有慢，出发点也可以有前有后。</p>
<p>了解了思路，你还需要深入理解操作的代码模板，然后就可以成功地进行解题实战了。这里我已经为你总结好了《链表题通关路线图》，请参照此地图来通关链表题吧。</p>
<p>链表操作是很多其他复杂算法的基础，需要你熟练掌握，比如 LRU，跳表等数据结构里面都会用到链表。希望你课后能熟练地运行本讲介绍的思路。</p>
<p>此外，从算法的难度上来说，实际上链表题并不算太难，但是非常考验基本功。我在处理链表题时，经常把文中介绍的题目作为模板深刻理解，达到熟练记忆的程度。我希望你在理解解题思路的基础上，也能够熟练记忆这些模板，逐渐建立一个系统的知识体系。</p>
<p>思考题</p>
<p>最后，我再给你留一道思考题。</p>
<p>链表排序：给定一个单向链表，如何给这个链表排序，要求复杂度达到 O(nlogn)。</p>
<p>你能使用所讲的创建新链表 + 快排的思想吗？</p>
<p>你能使用快慢指针 + 合并排序的思想来解决吗？</p>
<p>解法 1：Java/C++/Python解法 2：Java/C++/Python</p>
<p>学会了链表的三板斧，处理链表问题，变得越来越容易了。不过我们可不能总是待在舒适区，还有很多算法与数结构等着我们去征服。下一讲将介绍 06 | 树：如何深度运用树的遍历？记得按时来探险。</p>
<p>-&ndash; ### 精选评论 ##### *明： &gt; 德老师，总结的太到位了！回答一下合并k个有序链表的解题思路：（1）可以创建一个大小为 k 的 最小堆，先把所有链表的头部结点全部添加进去；（2）利用假头 dummy，初始化一个新链表，每次从最小堆中取出一个结点，即最小值，把它 append 到新链表的末尾；同时把该结点的下一个结点添加到 最小堆中（如果该结点的下一个结点不为空）。（3）返回 dummy. next。 ##### **4943： &gt; 对于练习6的思考题：（1）由于增加了dummy节点作为假头，而s1和s2都是从head开始的，存在的两种特殊情况是head本身就是空节点和head.next为空节点，但是这两种情况都会由于pre的存在使得返回的mid就是pre,对应的分隔链表也就是正确的。（2）s1和s2从head开始就是为了不需要判断链表为空的情况；从dummy开始也是可以的，但是findMiddleNode方法里while的循环条件要改变，要改成s2.next != null s2.next.next != null,此时能同样解决（1）中提到的两种情况。如果分析的不对请老师指正 ######     讲师回复： &gt;     不错哦。(2)可能还需要想一下。 （1）做个参考：https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/splitList.2.java （2）做个参考：https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/splitList.3.java ##### **伟： &gt; tail.next=xxxtail=xxx老师，我这两行代码任是没有绕过弯来，不知道啥意思？😂 ######     讲师回复： &gt;     你玩老鹰抓小鸡游戏，你去抓住排在最后一只小鸡的尾巴(tail.next = p)。 然后，你就变成了队伍里面的最后一只小鸡。tail = p; ##### **0960： &gt; 链表中点的题目：如果使用dummy作为起始位置的话：奇数：最后front的节点是null，back走到了前半部分的最后一个，偶数：最后front的节点的next是null，back走到了前半部分的最后一个，所以没有必要区分 ######     讲师回复： &gt;     赞！ ##### **8113： &gt; 老师，请问 例2 ，// 注意设置尾巴的next为空 尾部移到最新的节点，下一个节点应该也是为null的，为啥要这一步的操作呢？ ######     讲师回复： &gt;     并不是所有的题目都能够保证最后的这个尾巴是空的。这里补刀是要保证所有的链表你的屁股都是擦干净的。养成好习惯。^_^ ##### **健： &gt; 有个细节问题，在cpp的链表删除代码里，是否要对删去的节点进行内存回收呢？ ######     讲师回复： &gt;     在面试的时候，一定要记得写上！在leetcode里面，如果是自己new的，那么删除的时候就自己delete。如果不是自己new的，那么就不要动它。 ##### **亚： &gt; 不太懂为什么s1重新赋值然后和s2一块走😂 ######     讲师回复： &gt;     嗯。这里不要直接看代码，要先去看前面的那个数学上的证明。你可以想象成：你人在食堂。你室友在宿舍。你们约好一起去跑步（为什么要约室友去跑步，这个不重要！）。你们相约在操场入口碰头。假设你的路程更近（你们两个人移速一样！）先到了操场入口。然后你看你室友还没到。你就围着操场跑了起来。如果最后的跑的路程 - 室友走的路程 = 操场环形跑道的整数倍。 那么最后你和室友肯定是在操场入口相遇。而前面那一坨数学，就是在证明，这个路程就是圆环的整数倍。所以，你只需要保证移动速度一样就可以了。所以两个指针分别从各自的地方出发。然后再一步一步走。 s1指针就是你室友。s2指针就是你。你们移动速度一样。必然在操场入口碰头 ##### **帆： &gt; 老师，关于新链表解题的空间复杂度是o(1)而不是o(n)是这样理解吗？我们虽然新建了一个链表，但链表中的每个节点只是原链表中对应节点的引用(并没有通过 new Node). ######     讲师回复： &gt;     正解! ##### 周： &gt; 老师您好，扩展题里找链表开始入环的第一个节点那题，快指针s2走过的路径长度是不是应该是b = x + y + n * (y + z) 呢？这样才能推导出: x - z = (n - 1)*(y + z) 呢。另外，老师真的是总结很好，感觉以后链表题都有思路了而不是无从下手，谢谢老师的讲解！！ ######     讲师回复： &gt;     非常感谢你的指正。已更正 ##### **一郎： &gt; 老师，这些题目都是从leetcode上面找的吧，下次能否把题目编号也给贴出来。 ######     编辑回复： &gt;     在每一道题的git repo里面的链接，有完整的代码，以及相应的测试平台或者leetcode 链接。 ##### **7225： &gt; 双指针方法找链表倒数第k个数，相当于第一个指针遍历所有节点，第二个只是少遍历k个，总起来来说不是遍历一遍列表啊 ######     讲师回复： &gt;     遍历一遍与每个结点只访问一次是两个概念。并不是说每个结点只能访问一次！它的含义是指你只能从头到尾看一次。如果你先用while循环求出链表的长度，再一个while循环求倒数第k个。这样你遍历链表，你就遍历了两遍。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">数据结构与算法面试宝典</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%A9%E8%BD%ACserverless%E6%9E%B6%E6%9E%84/05%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%92%8C%E9%83%A8%E7%BD%B2%E6%95%88%E7%8E%87/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">05开发框架：如何提高应用开发调试和部署效率？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%A7%A3%E8%AF%BB%E4%BD%A0%E8%BA%AB%E8%BE%B9%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6/05%E7%BE%8E%E5%9B%BD%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%80%E7%89%B9%E6%9C%97%E6%99%AE%E7%9A%84%E7%BB%8F%E6%B5%8E%E8%A7%82/">
            <span class="next-text nav-default">05美国失败的原因（一）：特朗普的经济观</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
