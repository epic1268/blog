<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>22 数据结构模板：如何让解题变成搭积木？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="在这个模块，我把常见的“套路”题，帮你总结成手写代码时应该准备的各种代码模板。还会把自己压箱底的独家代码模板分享给你，利用它，我多次在 10 分钟以内拿下了算法面试。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF%E5%A6%82%E4%BD%95%E8%AE%A9%E8%A7%A3%E9%A2%98%E5%8F%98%E6%88%90%E6%90%AD%E7%A7%AF%E6%9C%A8/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF%E5%A6%82%E4%BD%95%E8%AE%A9%E8%A7%A3%E9%A2%98%E5%8F%98%E6%88%90%E6%90%AD%E7%A7%AF%E6%9C%A8/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="22 数据结构模板：如何让解题变成搭积木？">
  <meta property="og:description" content="在这个模块，我把常见的“套路”题，帮你总结成手写代码时应该准备的各种代码模板。还会把自己压箱底的独家代码模板分享给你，利用它，我多次在 10 分钟以内拿下了算法面试。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="数据结构与算法面试宝典">

  <meta itemprop="name" content="22 数据结构模板：如何让解题变成搭积木？">
  <meta itemprop="description" content="在这个模块，我把常见的“套路”题，帮你总结成手写代码时应该准备的各种代码模板。还会把自己压箱底的独家代码模板分享给你，利用它，我多次在 10 分钟以内拿下了算法面试。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7289">
  <meta itemprop="keywords" content="数据结构与算法面试宝典">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="22 数据结构模板：如何让解题变成搭积木？">
  <meta name="twitter:description" content="在这个模块，我把常见的“套路”题，帮你总结成手写代码时应该准备的各种代码模板。还会把自己压箱底的独家代码模板分享给你，利用它，我多次在 10 分钟以内拿下了算法面试。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">22 数据结构模板：如何让解题变成搭积木？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7289 字 </span>
          <span class="more-meta"> 预计阅读 15 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>在这个模块，我把常见的“套路”题，帮你总结成手写代码时应该准备的各种代码模板。还会把自己压箱底的独家代码模板分享给你，利用它，我多次在 10 分钟以内拿下了算法面试。</p>
<p>今天我先带你把数据结构部分做一个归纳和整理，方便你考前复习和平日积累。可以想象一下，如果在准备面试期间，你已经刷了很多题，那么在临近面试时还可以做些什么呢？</p>
<p>把所有写过的代码再看一遍？</p>
<p>把前面 20 讲的内容从头到尾再复习一遍？</p>
<p>还是继续刷题？</p>
<p>在我个人看来，以上这些方法都不可取，此时最行之有效的方法是将学过的知识尽可能地压缩、再压缩，最后形成模板。整理模板，有以下几个好处。</p>
<p>组合：其实大部分面试题都是一些算法模块的组合，并不需要我们真正去发明一个算法。</p>
<p>速度：面试写题时速度更快，一些常用的功能性代码可以直接粘贴过去，不用在打字和调试上浪费时间。</p>
<p>重点：可以在有限的时间里重点关注整理好的代码模板，告别“大海捞针”式的复习。</p>
<p>其实面试中考察的那些高频知识点，就像一块块“积木”，而面试求解过程就像“搭积木的游戏”。高效利用代码模版的技巧，能够帮助你在面试时写出更高效和 0 Bug 的代码。</p>
<p>说明：一些扩展知识点，我会通过练习题的形式给出来。</p>
<p>栈</p>
<p>在《01 | 栈：从简单栈到单调栈，解决经典栈问题》中，我们将栈的知识总结在了下面这张知识导图中。</p>
<p>简单栈的性质</p>
<p>后面我们又在《20 | 5 种解法，如何利用常量空间求解最长有效括号长度？》的“特点 4”中，介绍了另一个栈的重点性质——括号匹配时栈的性质。我们可以用如下代码模板展示这个性质：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int longestValidParentheses(String s) {
</span></span><span class="line"><span class="cl">    final int N = s == null ? 0 : s.length();
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    if (N &lt;= 1) {
</span></span><span class="line"><span class="cl">      return 0;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    Stack&lt;Integer&gt; st = new Stack&lt;&gt;();
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    // 最长的有效长度
</span></span><span class="line"><span class="cl">    int ans = 0;
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    int start = 0;
</span></span><span class="line"><span class="cl">    for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">      final char c = s.charAt(i);
</span></span><span class="line"><span class="cl">      if (c == &#39;)&#39;) {
</span></span><span class="line"><span class="cl">        // 如果从[start, i]这个区间里面
</span></span><span class="line"><span class="cl">        // 右括号已经可以匹配掉所有的左括号了
</span></span><span class="line"><span class="cl">        if (st.isEmpty()) {
</span></span><span class="line"><span class="cl">          // 问题2:更新新字符串的开头
</span></span><span class="line"><span class="cl">          start = i + 1;
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">          st.pop();
</span></span><span class="line"><span class="cl">          // 注意问题1，3在这里统一处理
</span></span><span class="line"><span class="cl">          final int base =
</span></span><span class="line"><span class="cl">              st.isEmpty() ? start : st.peek() + 1;
</span></span><span class="line"><span class="cl">          ans = Math.max(ans, i - base + 1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">      } else { /* 如果字符是左括号 */
</span></span><span class="line"><span class="cl">        st.push(i);
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">    } // end for
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    return ans;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>栈的模拟主要是使用其他数据结构来模拟栈的 push/pop 操作，主要涉及 3 个经典的题目，即下面的练习题 1、练习题 2 以及练习题 3。</p>
<p>练习题 1：请使用两个队列实现栈的 push/pop/empty/size 四种操作。</p>
<p>代码：Java/C++/Python</p>
<p>练习题 2：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<p>代码：Java/C++/Python</p>
<p>练习题 3：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p>代码：Java/C++/Python</p>
<p>单调栈</p>
<p>单调栈中经常还会用来解决这类题目：数组中元素右边第一个比元素自身小的元素的位置。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int[] findRightSmall(int[] A) {
</span></span><span class="line"><span class="cl">  // 结果数组
</span></span><span class="line"><span class="cl">  int[] ans = new int[A.length];
</span></span><span class="line"><span class="cl">  // 注意，栈中的元素记录的是下标
</span></span><span class="line"><span class="cl">  Stack&lt;Integer&gt; t = new Stack();
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt; A.length; i++) {
</span></span><span class="line"><span class="cl">    final int x = A[i];
</span></span><span class="line"><span class="cl">    // 每个元素都向左遍历栈中的元素完成消除动作
</span></span><span class="line"><span class="cl">    while (!t.empty() &amp;&amp; A[t.peek()] &gt; x) {
</span></span><span class="line"><span class="cl">      // 消除的时候，记录一下被谁消除了
</span></span><span class="line"><span class="cl">      ans[t.peek()] = i;
</span></span><span class="line"><span class="cl">      // 消除时候，值更大的需要从栈中消失
</span></span><span class="line"><span class="cl">      t.pop();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 剩下的入栈
</span></span><span class="line"><span class="cl">    t.push(i);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  // 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。
</span></span><span class="line"><span class="cl">  while (!t.empty()) {
</span></span><span class="line"><span class="cl">    ans[t.peek()] = -1;
</span></span><span class="line"><span class="cl">    t.pop();
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return ans;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>还有 3 类问题与上面这道题目类似，一般而言，深入理解其中一个模板即可。</p>
<p>数组中元素右边第一个比我大的元素的位置</p>
<p>数组中元素左边离我最近且比我小的元素的位置</p>
<p>数组中元素左边离我最近且比我大的元素的位置</p>
<p>单调栈的性质</p>
<p>我们将单调栈的性质总结为以下两点，更详细的介绍你可以回到《16 | 如何利用 DP 与单调队列寻找最大矩形？》进行复习。</p>
<p>当单调递增栈中存放数组下标 i, j, k 时，其中 (i, k] 中的元素 &gt; A[j]；</p>
<p>当单调递增栈中存放数组下标 i, j，并且当 A[k] 入栈，会把栈顶元素 A[j]“削”出栈时，其中 (j, k) 元素 &gt; A[j]。</p>
<p>我们曾经用到单调栈性质的模板代码求解最大矩形，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int largestRectangleArea(int[] A) {
</span></span><span class="line"><span class="cl">  final int N = A == null ? 0 : A.length;
</span></span><span class="line"><span class="cl">  // 虽然可以用Stack&lt;Integer&gt;，但是这里为了更快地操作，我们用
</span></span><span class="line"><span class="cl">  // 数组模拟栈来运行，因为我们知道最多存放的内容实际上就是N个
</span></span><span class="line"><span class="cl">  int top = 0;
</span></span><span class="line"><span class="cl">  // s[top-1]表示栈顶元素
</span></span><span class="line"><span class="cl">  int[] s = new int[N];
</span></span><span class="line"><span class="cl">  int ans = 0;
</span></span><span class="line"><span class="cl">  // 注意，这里我们取到了i == N
</span></span><span class="line"><span class="cl">  // 按理说，不应该取到i == N的。但是这时候主要是为了处理这种数组
</span></span><span class="line"><span class="cl">  // A = [1, 2, 3]
</span></span><span class="line"><span class="cl">  // 没有任何元素会出栈。
</span></span><span class="line"><span class="cl">  // 那么最后我们用一个0元素，把所有的元素都削出栈。
</span></span><span class="line"><span class="cl">  // 这样代码就可以统一处理掉。
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt;= N; i++) {
</span></span><span class="line"><span class="cl">    // 注意：当i == N的时候，x = -1;
</span></span><span class="line"><span class="cl">    // 比数组中的元素都要小。
</span></span><span class="line"><span class="cl">    final int x = i == N ? -1 : A[i];
</span></span><span class="line"><span class="cl">    while (top &gt; 0 &amp;&amp; A[s[top - 1]] &gt; x) {
</span></span><span class="line"><span class="cl">      // 计算以A[s[top]]的元素的高度的矩形。
</span></span><span class="line"><span class="cl">      final int height = A[s[--top]];
</span></span><span class="line"><span class="cl">      // i元素要将index = s[top-1]的元素出栈。
</span></span><span class="line"><span class="cl">      // 那么根据性质2/3：
</span></span><span class="line"><span class="cl">      // 此时A[s[top-1] .... i) 这个区间里面的元素都是
</span></span><span class="line"><span class="cl">      // 大于A[s[top-1]]的
</span></span><span class="line"><span class="cl">      final int rightPos = i;
</span></span><span class="line"><span class="cl">      // 这里需要使用性质1.
</span></span><span class="line"><span class="cl">      // 注意：当栈中一个元素都没有的时候，要取-1
</span></span><span class="line"><span class="cl">      final int leftPos = top &gt; 0 ? s[top - 1] : -1;
</span></span><span class="line"><span class="cl">      final int width = rightPos - leftPos - 1;
</span></span><span class="line"><span class="cl">      final int area = height * width;
</span></span><span class="line"><span class="cl">      ans = Math.max(ans, area);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    s[top++] = i;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return ans;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>队列</p>
<p>关于队列的知识点，我们同样总结在了一张思维导图中，如下所示：</p>
<p>队列的数据结构知识点一般有 5 个：</p>
<p>FIFO 队列</p>
<p>循环队列（模板）</p>
<p>单调队列（模板）</p>
<p>堆（模板）</p>
<p>优先级队列</p>
<p>不过一般而言，需要重点掌握的数据结构的模板只有 3 个，即循环队列、单调队列以及堆。</p>
<p>循环队列</p>
<p>首先我们看一下使用数组来实现循环队列的写法，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class MyCircularQueue {
</span></span><span class="line"><span class="cl">    // 已经使用的元素个数
</span></span><span class="line"><span class="cl">    private int used = 0;
</span></span><span class="line"><span class="cl">    // 第一个元素所在位置
</span></span><span class="line"><span class="cl">    private int front = 0;
</span></span><span class="line"><span class="cl">    // rear是enQueue可在存放的位置
</span></span><span class="line"><span class="cl">    // 注意开闭原则
</span></span><span class="line"><span class="cl">    // [front, rear)
</span></span><span class="line"><span class="cl">    private int rear = 0;
</span></span><span class="line"><span class="cl">    // 循环队列最多可以存放的元素个数
</span></span><span class="line"><span class="cl">    private int capacity = 0;
</span></span><span class="line"><span class="cl">    // 循环队列的存储空间
</span></span><span class="line"><span class="cl">    private int[] a = null;
</span></span><span class="line"><span class="cl">    public MyCircularQueue(int k) {
</span></span><span class="line"><span class="cl">        // 初始化循环队列
</span></span><span class="line"><span class="cl">        capacity = k;
</span></span><span class="line"><span class="cl">        a = new int[capacity];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public boolean enQueue(int value) {
</span></span><span class="line"><span class="cl">        // 如果已经放满了
</span></span><span class="line"><span class="cl">        if (isFull()) {
</span></span><span class="line"><span class="cl">            return false;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 如果没有放满，那么a[rear]用来存放新进来的元素
</span></span><span class="line"><span class="cl">        a[rear] = value;
</span></span><span class="line"><span class="cl">        // rear注意取模
</span></span><span class="line"><span class="cl">        rear = (rear + 1) % capacity;
</span></span><span class="line"><span class="cl">        // 已经使用的空间
</span></span><span class="line"><span class="cl">        used++;
</span></span><span class="line"><span class="cl">        // 存放成功!
</span></span><span class="line"><span class="cl">        return true;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public boolean deQueue() {
</span></span><span class="line"><span class="cl">        // 如果是一个空队列，当然不能出队
</span></span><span class="line"><span class="cl">        if (isEmpty()) {
</span></span><span class="line"><span class="cl">            return false;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 第一个元素取出
</span></span><span class="line"><span class="cl">        int ret = a[front];
</span></span><span class="line"><span class="cl">        // 注意取模
</span></span><span class="line"><span class="cl">        front = (front + 1) % capacity;
</span></span><span class="line"><span class="cl">        // 已经存放的元素减减
</span></span><span class="line"><span class="cl">        used--;
</span></span><span class="line"><span class="cl">        // 取出元素成功
</span></span><span class="line"><span class="cl">        return true;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public int Front() {
</span></span><span class="line"><span class="cl">        // 如果为空，不能取出队首元素
</span></span><span class="line"><span class="cl">        if (isEmpty()) {
</span></span><span class="line"><span class="cl">            return -1;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 取出队首元素
</span></span><span class="line"><span class="cl">        return a[front];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public int Rear() {
</span></span><span class="line"><span class="cl">        // 如果为空，不能取出队尾元素
</span></span><span class="line"><span class="cl">        if (isEmpty()) {
</span></span><span class="line"><span class="cl">            return -1;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 注意：这里不能使用rear - 1
</span></span><span class="line"><span class="cl">        // 需要取模
</span></span><span class="line"><span class="cl">        int tail = (rear - 1 + capacity) % capacity;
</span></span><span class="line"><span class="cl">        return a[tail];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 队列是否为空
</span></span><span class="line"><span class="cl">    public boolean isEmpty() {
</span></span><span class="line"><span class="cl">        return used == 0;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 队列是否满了
</span></span><span class="line"><span class="cl">    public boolean isFull() {
</span></span><span class="line"><span class="cl">        return used == capacity;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>单调队列</p>
<p>接下来，我们看一下单调队列的实现代码。单调队列有两种，即递增队列和递减队列。由于这两种队列的代码模版非常类似，因此只需要记住其中一个就可以了，递减队列代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    // 单调队列使用双端队列来实现
</span></span><span class="line"><span class="cl">    private ArrayDeque&lt;Integer&gt; Q = new ArrayDeque&lt;Integer&gt;();
</span></span><span class="line"><span class="cl">    // 入队的时候，last方向入队，但是入队的时候
</span></span><span class="line"><span class="cl">    // 需要保证整个队列的数值是单调的
</span></span><span class="line"><span class="cl">    // (在这个题里面我们需要是递减的)
</span></span><span class="line"><span class="cl">    // 并且需要注意，这里是Q.getLast() &lt; val
</span></span><span class="line"><span class="cl">    // 如果写成Q.getLast() &lt;= val就变成了严格单调递增
</span></span><span class="line"><span class="cl">    private void push(int val) {
</span></span><span class="line"><span class="cl">        while (!Q.isEmpty() &amp;&amp; Q.getLast() &lt; val) {
</span></span><span class="line"><span class="cl">            Q.removeLast();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 将元素入队
</span></span><span class="line"><span class="cl">        Q.addLast(val);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 出队的时候，要相等的时候才会出队
</span></span><span class="line"><span class="cl">    private void pop(int val) {
</span></span><span class="line"><span class="cl">        if (!Q.isEmpty() &amp;&amp; Q.getFirst() == val) {
</span></span><span class="line"><span class="cl">            Q.removeFirst();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>此外，单调队列还可以使用“&lt; 元素值，下标 &gt; 同时入队和出队”的方法来实现。这两种实现本质上没有太大的区别。你可以根据你对单调队列理解程度选择一种作为做通用模板。</p>
<p>代码：Java/C++/Python</p>
<p>堆</p>
<p>由于堆往往用来实现优先级队列，因此，这里我也整理好了堆的实现的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Heap {
</span></span><span class="line"><span class="cl">    private int[] a = null;
</span></span><span class="line"><span class="cl">    private int n = 0;
</span></span><span class="line"><span class="cl">    // 下沉
</span></span><span class="line"><span class="cl">    public void sink(int i) {
</span></span><span class="line"><span class="cl">        int j = 0;
</span></span><span class="line"><span class="cl">        int t = a[i];
</span></span><span class="line"><span class="cl">        // 找到i结点的左子结点
</span></span><span class="line"><span class="cl">        while ((j = (i &lt;&lt; 1) + 1) &lt; n) {
</span></span><span class="line"><span class="cl">            // j &lt; n - 1判断是否有右子结点
</span></span><span class="line"><span class="cl">            // 如果有，并且右子结点更大，那么
</span></span><span class="line"><span class="cl">            // j指向右子结点
</span></span><span class="line"><span class="cl">            if (j &lt; n - 1 &amp;&amp; a[j] &lt; a[j + 1]) {
</span></span><span class="line"><span class="cl">                j++;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // 如果子结点比t大
</span></span><span class="line"><span class="cl">            // 那么t的位置还需要往后排
</span></span><span class="line"><span class="cl">            if (a[j] &gt; t) {
</span></span><span class="line"><span class="cl">                a[i] = a[j];
</span></span><span class="line"><span class="cl">                i = j;
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                // 找到了t的位置
</span></span><span class="line"><span class="cl">                // 此时t是大于所有的子结点的
</span></span><span class="line"><span class="cl">                break;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 将t放在找到的位置那里
</span></span><span class="line"><span class="cl">        a[i] = t;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 上浮
</span></span><span class="line"><span class="cl">    public void swim(int i) {
</span></span><span class="line"><span class="cl">        int t = a[i];
</span></span><span class="line"><span class="cl">        int par = 0;
</span></span><span class="line"><span class="cl">        // 如果还存在父结点
</span></span><span class="line"><span class="cl">        while (i &gt; 0 &amp;&amp; (par = (i - 1) &gt;&gt; 1) != i) {
</span></span><span class="line"><span class="cl">            // 如果父结点比t值小
</span></span><span class="line"><span class="cl">            if (a[par] &lt; t) {
</span></span><span class="line"><span class="cl">                a[i] = a[par];
</span></span><span class="line"><span class="cl">                i = par;
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                break;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        a[i] = t;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public void push(int v) {
</span></span><span class="line"><span class="cl">        // push是先把元素追加到数组尾巴上，然后再执行上浮操作
</span></span><span class="line"><span class="cl">        a[n++] = v;
</span></span><span class="line"><span class="cl">        swim(n - 1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public int pop() {
</span></span><span class="line"><span class="cl">        int ret = a[0];
</span></span><span class="line"><span class="cl">        a[0] = a[--n];
</span></span><span class="line"><span class="cl">        sink(0);
</span></span><span class="line"><span class="cl">        return ret;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public int size() {
</span></span><span class="line"><span class="cl">        return n;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>链表</p>
<p>要想解决链表题，我们首先需要掌几种最基本的操作，如下图所示：</p>
<p>不知道你是否还记得，我在《04 | 链表：如何利用“假头、新链表、双指针”解决链表题？（上）》中，将这几种操作整理成了一个代码模板。其核心思想就是链表的“第一斧”：假头。如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class MyLinkedList {
</span></span><span class="line"><span class="cl">    // 实现单链表
</span></span><span class="line"><span class="cl">    // 1. 假设链表中的所有节点都是 0-index的。
</span></span><span class="line"><span class="cl">    class ListNode {
</span></span><span class="line"><span class="cl">        public int val = 0;
</span></span><span class="line"><span class="cl">        public ListNode next = null;
</span></span><span class="line"><span class="cl">        public ListNode() {}
</span></span><span class="line"><span class="cl">        public ListNode(int x) {
</span></span><span class="line"><span class="cl">            val = x;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    private ListNode dummy = new ListNode();
</span></span><span class="line"><span class="cl">    private ListNode tail = dummy;
</span></span><span class="line"><span class="cl">    private int length = 0;
</span></span><span class="line"><span class="cl">    /** Initialize your data structure here. */
</span></span><span class="line"><span class="cl">    public MyLinkedList() {
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    private ListNode getPreNode(int index) {
</span></span><span class="line"><span class="cl">        ListNode front = dummy.next;
</span></span><span class="line"><span class="cl">        ListNode back = dummy;
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; index; i++) {
</span></span><span class="line"><span class="cl">            back = front;
</span></span><span class="line"><span class="cl">            front = front.next;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return back;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 获取链表中第 index 个节点的值。如果索引无效，则返回-1。
</span></span><span class="line"><span class="cl">    public int get(int index) {
</span></span><span class="line"><span class="cl">        if (index &lt; 0 || index &gt;= length) {
</span></span><span class="line"><span class="cl">            return -1;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return getPreNode(index).next.val;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 在链表的第一个元素之前添加一个值为 val 的节点。
</span></span><span class="line"><span class="cl">    // 插入后，新节点将成为链表的第一个节点。
</span></span><span class="line"><span class="cl">    public void addAtHead(int val) {
</span></span><span class="line"><span class="cl">        ListNode p = new ListNode(val);
</span></span><span class="line"><span class="cl">        p.next = dummy.next;
</span></span><span class="line"><span class="cl">        dummy.next = p;
</span></span><span class="line"><span class="cl">        // NOTE change tail
</span></span><span class="line"><span class="cl">        if (tail == dummy) {
</span></span><span class="line"><span class="cl">            tail = p;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        length++;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 将值为 val 的节点追加到链表的最后一个元素。
</span></span><span class="line"><span class="cl">    public void addAtTail(int val) {
</span></span><span class="line"><span class="cl">        tail.next = new ListNode(val);
</span></span><span class="line"><span class="cl">        tail = tail.next;
</span></span><span class="line"><span class="cl">        length++;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 在链表中的第 index 个节点之前添加值为 val  的节点。
</span></span><span class="line"><span class="cl">    // 1. 如果 index 等于链表的长度，则该节点将附加到链表的末尾。
</span></span><span class="line"><span class="cl">    // 2. 如果 index 大于链表长度，则不会插入节点。
</span></span><span class="line"><span class="cl">    // 3. 如果index小于0，则在头部插入节点。
</span></span><span class="line"><span class="cl">    public void addAtIndex(int index, int val) {
</span></span><span class="line"><span class="cl">        if (index &gt; length) {
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        } else if (index == length) {
</span></span><span class="line"><span class="cl">            addAtTail(val);
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        } else if (index &lt;= 0) {
</span></span><span class="line"><span class="cl">            addAtHead(val);
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        ListNode pre = getPreNode(index);
</span></span><span class="line"><span class="cl">        ListNode p = new ListNode(val);
</span></span><span class="line"><span class="cl">        p.next = pre.next;
</span></span><span class="line"><span class="cl">        pre.next = p;
</span></span><span class="line"><span class="cl">        // NOTE: here tail has been changed
</span></span><span class="line"><span class="cl">        length++;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 如果索引 index 有效，则删除链表中的第 index 个节点。
</span></span><span class="line"><span class="cl">    public void deleteAtIndex(int index) {
</span></span><span class="line"><span class="cl">        if (index &lt; 0 || index &gt;= length) {
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        ListNode pre = getPreNode(index);
</span></span><span class="line"><span class="cl">        // NOTE: delete -&gt; change tail
</span></span><span class="line"><span class="cl">        if (tail == pre.next) {
</span></span><span class="line"><span class="cl">            tail = pre;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        length--;
</span></span><span class="line"><span class="cl">        pre.next = pre.next.next;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>此外，关于链表，我们还需要掌握另外的“两板斧”。这里我已经将知识点整理如下：</p>
<p>树</p>
<p>在《06 | 树：如何深度运用树的遍历？》中，我们深入探讨了三种遍历，并且发现只要我们掌握这三种遍历的模板代码，就能够轻松解决二叉树问题。</p>
<p>在这一讲中，我们需要熟练掌握三种遍历的代码模板有 6 个：</p>
<p>前序遍历的递归实现与栈的实现</p>
<p>中序遍历的递归实现与栈的实现</p>
<p>后序遍历的递归实现与栈的实现</p>
<p>下面我们分别整理一下。</p>
<p>前序遍历</p>
<p>采用递归的前序遍历的代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void preOrder(TreeNode root, List&lt;Integer&gt; ans) {
</span></span><span class="line"><span class="cl">    // 边界处理：如果树为空，那么不需要处理
</span></span><span class="line"><span class="cl">    if (root != null) {
</span></span><span class="line"><span class="cl">        // 先访问根结点
</span></span><span class="line"><span class="cl">        ans.add(root.val);
</span></span><span class="line"><span class="cl">        // 再分别访问左子树
</span></span><span class="line"><span class="cl">        preOrder(root.left, ans);
</span></span><span class="line"><span class="cl">        // 再访问右子树
</span></span><span class="line"><span class="cl">        preOrder(root.right, ans);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>使用栈来实现的前序遍历的代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
</span></span><span class="line"><span class="cl">        // 用来进行递归的栈
</span></span><span class="line"><span class="cl">        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();
</span></span><span class="line"><span class="cl">        // 用来存放遍历的结果，不算在空间复杂度里面 
</span></span><span class="line"><span class="cl">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">        // 开始利用栈来进行遍历
</span></span><span class="line"><span class="cl">        while (root != null || !s.empty()) {
</span></span><span class="line"><span class="cl">            // 模拟递归的压栈过程
</span></span><span class="line"><span class="cl">            while (root != null) {
</span></span><span class="line"><span class="cl">                s.push(root);
</span></span><span class="line"><span class="cl">                ans.add(root.val);
</span></span><span class="line"><span class="cl">                root = root.left;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // 当无法压栈的时候，将root.right进行压栈
</span></span><span class="line"><span class="cl">            root = s.peek();
</span></span><span class="line"><span class="cl">            s.pop();
</span></span><span class="line"><span class="cl">            root = root.right;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return ans;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>中序遍历</p>
<p>采用递归的中序遍历代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void preOrder(TreeNode root, List&lt;Integer&gt; ans) {
</span></span><span class="line"><span class="cl">    if (root != null) {
</span></span><span class="line"><span class="cl">        // 先遍历左子树
</span></span><span class="line"><span class="cl">        preOrder(root.left, ans);
</span></span><span class="line"><span class="cl">        // 然后遍历中间的根结点
</span></span><span class="line"><span class="cl">        ans.add(root.val);
</span></span><span class="line"><span class="cl">        // 最后遍历右子树
</span></span><span class="line"><span class="cl">        preOrder(root.right, ans);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>采用非递归的中序代码（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
</span></span><span class="line"><span class="cl">        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();
</span></span><span class="line"><span class="cl">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">        // 注意这里的判断条件，需要root 或 stack非空
</span></span><span class="line"><span class="cl">        while (root != null || !s.empty()) {
</span></span><span class="line"><span class="cl">            // 往左边走，连续入栈，直到不能再走为止
</span></span><span class="line"><span class="cl">            while (root != null) {
</span></span><span class="line"><span class="cl">                s.push(root);
</span></span><span class="line"><span class="cl">                root = root.left;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // 到达了最左边，把结点弹出来，进行遍历
</span></span><span class="line"><span class="cl">            root = s.peek();
</span></span><span class="line"><span class="cl">            s.pop();
</span></span><span class="line"><span class="cl">            ans.add(root.val);
</span></span><span class="line"><span class="cl">            // 转向右子树
</span></span><span class="line"><span class="cl">            root = root.right;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 返回遍历的结果
</span></span><span class="line"><span class="cl">        return ans;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>后序遍历</p>
<p>采用递归实现的后序遍历代码模板如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void postOrder(TreeNode root, List&lt;Integer&gt; ans) {
</span></span><span class="line"><span class="cl">  if (root != null) {
</span></span><span class="line"><span class="cl">    // 先遍历左子树
</span></span><span class="line"><span class="cl">    postOrder(root.left, ans);
</span></span><span class="line"><span class="cl">    // 最后遍历右子树
</span></span><span class="line"><span class="cl">    postOrder(root.right, ans);
</span></span><span class="line"><span class="cl">    // 然后遍历中间的根结点
</span></span><span class="line"><span class="cl">    ans.add(root.val);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>采用非递归的后序遍历代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public List&lt;Integer&gt; postorderTraversal(TreeNode t) {
</span></span><span class="line"><span class="cl">        // 存放遍历的结果
</span></span><span class="line"><span class="cl">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">        // pre表示遍历时前面一个已经遍历过的结点
</span></span><span class="line"><span class="cl">        TreeNode pre = null;
</span></span><span class="line"><span class="cl">        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();
</span></span><span class="line"><span class="cl">        // 如果栈中还有元素，或者当前结点t非空
</span></span><span class="line"><span class="cl">        while (!s.isEmpty() || t != null) {
</span></span><span class="line"><span class="cl">            // 顺着左子树走，并且将所有的元素压入栈中
</span></span><span class="line"><span class="cl">            while (t != null) {
</span></span><span class="line"><span class="cl">                s.push(t);
</span></span><span class="line"><span class="cl">                t = t.left;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // 当没有任何元素可以压栈的时候
</span></span><span class="line"><span class="cl">            // 拿栈顶元素，注意这里并不将栈顶元素弹出
</span></span><span class="line"><span class="cl">            // 因为在迭代时，根结点需要遍历两次，这里需要判断一下
</span></span><span class="line"><span class="cl">            // 右子树是否遍历完毕
</span></span><span class="line"><span class="cl">            t = s.peek();
</span></span><span class="line"><span class="cl">            // 如果要遍历当前结点，需要确保右子树已经遍历完毕
</span></span><span class="line"><span class="cl">            // 1. 如果当前结点右子树为空，那么右子树没有遍历的必要
</span></span><span class="line"><span class="cl">            // 需要将当前结点放到ans中
</span></span><span class="line"><span class="cl">            // 2. 当t.right == pre时，说明右子树已经被打印过了
</span></span><span class="line"><span class="cl">            // 那么此时需要将当前结点放到ans中
</span></span><span class="line"><span class="cl">            if (t.right == null || t.right == pre) {
</span></span><span class="line"><span class="cl">                // 右子树已经遍历完毕，放到ans中。
</span></span><span class="line"><span class="cl">                ans.add(t.val);
</span></span><span class="line"><span class="cl">                // 弹栈
</span></span><span class="line"><span class="cl">                s.pop();
</span></span><span class="line"><span class="cl">                // 因为已经遍历了当前结点，所以需要更新pre结点
</span></span><span class="line"><span class="cl">                pre = t;
</span></span><span class="line"><span class="cl">                // 已经打印完毕。需要设置为空，否则下一轮循环
</span></span><span class="line"><span class="cl">                // 还会遍历t的左子树。
</span></span><span class="line"><span class="cl">                t = null;
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                // 第一次走到t结点，不能放到ans中，因为t的右子树还没有遍历。
</span></span><span class="line"><span class="cl">                // 需要将t结点的右子树遍历
</span></span><span class="line"><span class="cl">                t = t.right;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return ans;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>【面试建议】在面试的时候，大部分情况都应该优先写递归的代码，除非面试官特别要求你必须使用“非递归”来实现。主要有以下几点原因：</p>
<p>递归代码更加简单，因此不容易出错；</p>
<p>不要为了“炫技”展示“非递归”代码；</p>
<p>如果我们要进行二叉树上的搜索、DP、二分等情况的时候，“非递归”的代码往往会增加代码的复杂度，面试的时候不容易完全写对。</p>
<p>并查集</p>
<p>虽然并查集的代码模板只有一个，但是涉及的知识点却不少，这里我们将重点的内容浓缩在下面这张图里：</p>
<p>最后，我们给出并查集的代码模板如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class UF {
</span></span><span class="line"><span class="cl">  // 并查集数组
</span></span><span class="line"><span class="cl">  int[] F = null;
</span></span><span class="line"><span class="cl">  // 记录并查集中集合的个数
</span></span><span class="line"><span class="cl">  int count = 0;
</span></span><span class="line"><span class="cl">  // 记录集合中点的个数，比如要知道i所在集合的点有多少个: C[Find(i)]
</span></span><span class="line"><span class="cl">  // 注意：这里不能直接使用C[i]
</span></span><span class="line"><span class="cl">  // 因为只有根结点的统计才是正确的
</span></span><span class="line"><span class="cl">  int[] Cnt = null;
</span></span><span class="line"><span class="cl">  // 并查集的初始化
</span></span><span class="line"><span class="cl">  void Init(int n)
</span></span><span class="line"><span class="cl">  {
</span></span><span class="line"><span class="cl">    F = new int[n];
</span></span><span class="line"><span class="cl">    Cnt = new int[n];
</span></span><span class="line"><span class="cl">    for (int i = 0; i &lt; n; i++) {
</span></span><span class="line"><span class="cl">      F[i] = i;
</span></span><span class="line"><span class="cl">      Cnt[i] = 1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    count = n;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  int Find(int x)
</span></span><span class="line"><span class="cl">  {
</span></span><span class="line"><span class="cl">    if (x == F[x]) {
</span></span><span class="line"><span class="cl">      return x;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    F[x] = Find(F[x]);
</span></span><span class="line"><span class="cl">    return F[x];
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  void Union(int x, int y)
</span></span><span class="line"><span class="cl">  {
</span></span><span class="line"><span class="cl">    int xpar = Find(x);
</span></span><span class="line"><span class="cl">    int ypar = Find(y);
</span></span><span class="line"><span class="cl">    // 将x所在集合，合并到y所在集合
</span></span><span class="line"><span class="cl">    if (xpar != ypar) {
</span></span><span class="line"><span class="cl">      F[xpar] = ypar;
</span></span><span class="line"><span class="cl">      // y集合里面的个数要增加
</span></span><span class="line"><span class="cl">      Cnt[ypar] += Cnt[xpar];
</span></span><span class="line"><span class="cl">      count--;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  int Size(int i) {return Cnt[Find(i); }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>总结</p>
<p>在这一讲中，我们通过整理代码模板，将“第 01 讲” 到“第 07 讲”学习的所有知识点都整理好了。这样你复习起来是不是压力要小很多呢。下面我再和你分享两个代码模板的“小秘密”。</p>
<p>模板代码要精练</p>
<p>其实在整理模板的时候，要尽量将代码压缩得越短越好（指的并不是不换行），代码压缩得短，有以下好处：</p>
<p>如果是自己熟悉的代码，在需要记忆的情况下，越短越好记；</p>
<p>较短的代码可以更精练，一眼看上去没有那么大的心理压力。</p>
<p>比如就我自己而言，在复习并查集的代码时，就经常使用下面这段更短的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int Find(int x) { return x == F[x] ? x : F[x] = Find(F[x]); }
</span></span><span class="line"><span class="cl">void Union(int x, int y) {  F[find(x)] = find(y); }
</span></span></code></pre></td></tr></table>
</div>
</div><p>自己整理可复用的代码模版</p>
<p>和你分享一下自己整理的模板的好处。主要是基于以下两点原因。</p>
<ol>
<li>变量的命名要有规律，而这些规律都是自己平时约定使用的，当你复习代码时会更熟练，比如：</li>
</ol>
<p>1）返回值一律设置为 ans 或者 ret；</p>
<p>2）遍历下标设置为 i,j,k；</p>
<p>3）长度变量设置为 len。</p>
<ol start="2">
<li>同一个算法往往有很多种写法，自己的写法会更熟悉，而且可以不断迭代和复用。</li>
</ol>
<p>所以，本讲的练习题，就是希望你能把“第 01 讲”到“第 07 讲”刷过的题的代码整理成模板。当临近面试，你只需要对着思维导图和代码模板过一下思路就可以了。</p>
<p>这一讲我们就介绍到这里。下一讲介绍《23 | 算法模板：如何让高频算法考点秒变默写题？》，让我们继续前进。</p>
<p>-&ndash; ### 精选评论 ##### **6400： &gt; 老师，1.请问美国大厂的应届生SDE面试，是不是用python语言会更有优势？原因是中国学生面试的主要瓶颈在英语表达，python解题思路更清晰、代码行数少、解题时间短，从而给口头表达留出更多时间。2.如果是的话，老师有什么好的python语法资料可以推荐吗？javascript是我的主语言，但我想快速入门python，但是看到leetcode解题区的很多python语法非常简练，感觉比较trick，因此有时看不懂题解 ######     讲师回复： &gt;     不一定的。最好还是用你最拿手的语言！因为python在面试的时候，有个很关键的问题是，有可能面试官不允许你用那些X炸天的库。事实上，我在写python的题解的时候，也是尽量没有用库（除了优先级队列用了heapq，因为没办法，虽然也可以自己写堆，但我也不想每个题都去写堆，读者看起来也会觉得代码太长，有压力）。此外，写题首先要保证的是，你要把代码写对！！写对！！写对之后，然后再说口头表达的事儿。大部分情况下，时间复杂度，空间复杂度满足要求，思路正确，面试官都可以看懂。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">数据结构与算法面试宝典</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/shardingsphere%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%B2%BE%E8%AE%B2/21%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E5%88%86%E7%89%87%E7%8E%AF%E5%A2%83%E4%B8%8Bsql%E6%89%A7%E8%A1%8C%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8A%BD%E8%B1%A1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">21执行引擎：分片环境下SQL执行的整体流程应该如何进行抽象？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/openresty%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/22__%E8%A7%86%E9%A2%91%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E8%AF%B4%E8%B5%B7%E6%8E%A2%E5%AF%BBapi%E6%80%A7%E8%83%BD%E5%92%8C%E5%AE%89%E5%85%A8%E7%9A%84%E5%B9%B3%E8%A1%A1/">
            <span class="next-text nav-default">22__[视频]从一个安全漏洞说起，探寻API性能和安全的平衡</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
