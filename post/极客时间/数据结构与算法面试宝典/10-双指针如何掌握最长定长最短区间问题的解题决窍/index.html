<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>10 双指针：如何掌握最长、定长、最短区间问题的解题决窍？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="双指针的使用方法，在前面学习链表的时候，已经有所涉及。不过在那时，主要介绍的快慢指针。在这一讲，我们主要介绍双指针在数组上的应用。
双指针，通常是命名用两个指针在数组/链表上遍历，然后解决满足某种性质的区间问题。在链表中我们已经介绍过双指针（也可以叫作快慢指针）。不过今天我们将重点介绍：如何利用双指针处理以下 3 方面的区间问题：
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/10-%E5%8F%8C%E6%8C%87%E9%92%88%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8F%A1%E6%9C%80%E9%95%BF%E5%AE%9A%E9%95%BF%E6%9C%80%E7%9F%AD%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E9%A2%98%E5%86%B3%E7%AA%8D/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/10-%E5%8F%8C%E6%8C%87%E9%92%88%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8F%A1%E6%9C%80%E9%95%BF%E5%AE%9A%E9%95%BF%E6%9C%80%E7%9F%AD%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E9%A2%98%E5%86%B3%E7%AA%8D/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="10 双指针：如何掌握最长、定长、最短区间问题的解题决窍？">
  <meta property="og:description" content="双指针的使用方法，在前面学习链表的时候，已经有所涉及。不过在那时，主要介绍的快慢指针。在这一讲，我们主要介绍双指针在数组上的应用。
双指针，通常是命名用两个指针在数组/链表上遍历，然后解决满足某种性质的区间问题。在链表中我们已经介绍过双指针（也可以叫作快慢指针）。不过今天我们将重点介绍：如何利用双指针处理以下 3 方面的区间问题：">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="数据结构与算法面试宝典">

  <meta itemprop="name" content="10 双指针：如何掌握最长、定长、最短区间问题的解题决窍？">
  <meta itemprop="description" content="双指针的使用方法，在前面学习链表的时候，已经有所涉及。不过在那时，主要介绍的快慢指针。在这一讲，我们主要介绍双指针在数组上的应用。
双指针，通常是命名用两个指针在数组/链表上遍历，然后解决满足某种性质的区间问题。在链表中我们已经介绍过双指针（也可以叫作快慢指针）。不过今天我们将重点介绍：如何利用双指针处理以下 3 方面的区间问题：">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="10806">
  <meta itemprop="keywords" content="数据结构与算法面试宝典">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="10 双指针：如何掌握最长、定长、最短区间问题的解题决窍？">
  <meta name="twitter:description" content="双指针的使用方法，在前面学习链表的时候，已经有所涉及。不过在那时，主要介绍的快慢指针。在这一讲，我们主要介绍双指针在数组上的应用。
双指针，通常是命名用两个指针在数组/链表上遍历，然后解决满足某种性质的区间问题。在链表中我们已经介绍过双指针（也可以叫作快慢指针）。不过今天我们将重点介绍：如何利用双指针处理以下 3 方面的区间问题：">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">10 双指针：如何掌握最长、定长、最短区间问题的解题决窍？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 10806 字 </span>
          <span class="more-meta"> 预计阅读 22 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>双指针的使用方法，在前面学习链表的时候，已经有所涉及。不过在那时，主要介绍的快慢指针。在这一讲，我们主要介绍双指针在数组上的应用。</p>
<p>双指针，通常是命名用两个指针在数组/链表上遍历，然后解决满足某种性质的区间问题。在链表中我们已经介绍过双指针（也可以叫作快慢指针）。不过今天我们将重点介绍：如何利用双指针处理以下 3 方面的区间问题：</p>
<p>最长区间</p>
<p>定长区间</p>
<p>最短区间</p>
<p>学完本讲，你将收获双指针的 3 个模板，帮助你通杀所有面试中可能碰到的双指针题目。Ready, Go Go!</p>
<p>双指针基础</p>
<p>考察双指针的题目，绝大多数题眼就在区间。见面不含糊，直接尝试挖出题目的两个特点：</p>
<p>弄清楚题目要的是什么样的区间？是最长，定长，最短这三种里面的哪一种。</p>
<p>区间需要满足的条件是什么？</p>
<p>如果发现题目符合这两个特点，还需要让题目中的连续子串（后文区间 = 连续子串）符合单调性。让我们一起看一下什么是单调性。</p>
<p>注：这里的双指针只是一种算法的命名，有的人喜欢叫滑动窗口，或者尺取法。我觉得用双指针更加形象一点。“指针”二字并不能对应到 C/C++ 里面的指针类型。在使用的时候，往往是两个下标。</p>
<p>单调性</p>
<p>使用双指针，需要区间满足一个条件：区间状态的单调性。这里可以用一个例子进行描述。比如我们想在如下数组中找到小于等于 6 的最长子串。现在只看以 3 为区间最右端元素的各种情况，如下图所示：</p>
<p>那么区间可以分为 3 种：</p>
<p>第一种区间：以 3 为右端，其和大于 6。</p>
<p>第二种区间：以 3 为右端的区间，其和等于 6。</p>
<p>第三种区间：以 3 为右端的区间，其和小于 6。</p>
<p>如果我们将这些区间的累计和呈现到数轴上，就会得到如下图所示的一个图像：</p>
<p>可以看出，区间的状态的变化是单调的，并且是连续的：这就是双指针算法使用的条件。</p>
<p>有个快速判断区间属性是否满足单调性的办法，那就是，当往区间里面添加元素的时候，不能出现波折，比如不允许“满足条件→不满足条件→满足条件”的情况。</p>
<p>比如，我们这里的限定条件改成：需要区间满足 &gt;= 6。我们看一下如下操作步骤：</p>
<p>那么区间的状态变化就是 “满足条件→不满足条件→满足条件”。这样就不符合单调性。</p>
<p>工作原理</p>
<p>那么双指针为什么可以在 O(N)？它的合理性在哪？这里我尽量尝试用最直白的语言来把题目证明一下。</p>
<p>首先我们来看区间右端固定集合（这个名词是我自创的，因为我没有找到相关的术语来描述这种非常基础的操作）：</p>
<p>把 A[i] 元素固定为区间的右端点，只变动区间的左边界形成的所有区间，并且按区间长度需要从长到短排列。</p>
<p>比如要遍历如下数组：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int[] A = new int{1,2,3,4};
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如以 A[i = 2] = 3 为例，形成的区间右端固定集合为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[1, 2, 3]
</span></span><span class="line"><span class="cl">   [2, 3]
</span></span><span class="line"><span class="cl">      [3]
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果对每个元素找到区间右端固定集合，我们同样可以遍历一个数组里面的所有的子区间：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">i = 0, A[0] = 1 =&gt; [1]
</span></span><span class="line"><span class="cl">i = 1, A[1] = 2 =&gt; [1, 2], [2]
</span></span><span class="line"><span class="cl">i = 2, A[2] = 3 =&gt; [1, 2, 3], [2, 3], [3]
</span></span><span class="line"><span class="cl">i = 3, A[3] = 4 =&gt; [1, 2, 3, 4], [2, 3, 4], [3, 4], [4]
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来我们只分析 A[i] 元素的区间右端固定集合。比如要找出和 &lt;= 7 的最长区间。当已经处理到 A[2] = 3 的时候，当发现 [1, 2, 3] 这个区间之和 6 已经 &lt;=7 时（满足要求），实际上就没有必要再去处理 [2, 3] 区间和 [3] 区间。因为我们要的就是最长区间！</p>
<p>通过上述分析，我们可以总结一个区间最优原则：从左向右遍历区间右端固定集合中的每个区间，找到一个满足条件的解即可停止。</p>
<p>利用这个性质，我们可以再加一个指针 left, 指向区间的左边，与 A[i] 元素构成区间 (left, i]，注意这里我们又用到了开闭原则，只不过此时是左开右闭。那么寻找以 A[i] 为右边界的最优解可以分 3 步走：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">step1. 将A[i]加到区间中，形成新区间(left, i]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 遍历A[i]的区间右端固定集合，直找到以A[i]为右端点的最优解
</span></span><span class="line"><span class="cl">step2. while (left &lt; i &amp;&amp; (left,i]区间不满足要求) {
</span></span><span class="line"><span class="cl">  left++;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// 此时要么得到一个满足要求的
</span></span><span class="line"><span class="cl">step 3. (left, i]区间满足要求
</span></span></code></pre></td></tr></table>
</div>
</div><p>前面我们已经找到了 A[2] = 3 的合法最长区间为 (-1, 2]，那么接下来看一下如何再接着处理 A[3] = 4。</p>
<p>通过上述分析，我们可以拿出求解最长区间时双指针的结论：最长区间问题的最优解→只需要遍历每个元素 A[i] 的最优解即可。</p>
<p>以前面给的 A[2] = 3, A[3] = 4 两个元素为例，在找整个最优解的时候，只需要看两个区间：</p>
<p>[1, 2, 3]</p>
<p>[3, 4]</p>
<p>我们发现，在寻找最优解的时候，已经比暴力算法少了很多需要查看的区间。</p>
<p>最长区间</p>
<p>使用双指针算法来解决最长区间的问题，一般题目需要具备如下特点：</p>
<p>给定一个条件</p>
<p>求最长区间/最长子串</p>
<p>题目给出的区间需要具备单调性</p>
<p>这里需要特别指出，不是看到题目要求最长子串/最长区间就使用双指针，而是需要题目的求解空间具有单调性。这是一个非常重要具必备的条件。</p>
<p>面试必杀技</p>
<p>不过，真正在面试的时候，可没有那么多时间让你慢慢去证明，慢慢去推导。放心，我这里已经给你准备好了最长区间的面试必杀技，关键就两招：</p>
<p>两个指针，left 指针和 right 指针，两个指针形成的区间为 (left, right]。这里的开闭原则是左开右闭；</p>
<p>惰性原则，如果把 left 指针当成一个人，那么这个人是非常懒惰的，他总是要等到火烧屁股（条件不满足了）才向右移动。</p>
<p>求最长区间的代码模板大概会长成这样（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int maxLength(int[] A) {
</span></span><span class="line"><span class="cl">  int N = A.length;
</span></span><span class="line"><span class="cl">  // 区间的左指针
</span></span><span class="line"><span class="cl">  int left = -1;
</span></span><span class="line"><span class="cl">  int ans = 0;
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">    // assert 在加入A[i]之前，(left, i-1]是一个合法有效的区间
</span></span><span class="line"><span class="cl">    // step 1. 直接将A[i]加到区间中，形成(left, i]
</span></span><span class="line"><span class="cl">    // step 2. 将A[i]加入之后，惰性原则
</span></span><span class="line"><span class="cl">    while (check((left, i]))/*TODO 检查区间状态是否满足条件*/) {
</span></span><span class="line"><span class="cl">      ++left; // 如果不满足条件，移动左指针
</span></span><span class="line"><span class="cl">      // TODO 修改区间的状态
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // assert 此时(left, i]必然满足条件
</span></span><span class="line"><span class="cl">    ans = max(ans, i - left);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return ans; // 返回最优解
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>好了，我们的刀已经磨好了，下面就开始准备切题吧。注意上方代码中的两个“TODO”，我们已经把写算法题，变成填空题了。</p>
<p>例 1：不含重复字符的最长区间</p>
<p>【题目】找出一个字符串 s 中无重复字符子串的长度。</p>
<p>输入： s = &ldquo;abcdc&rdquo;</p>
<p>输出：4</p>
<p>解释：因为最长的子串就是&quot;abcd&quot;</p>
<p>【分析】首先看题目的特点：</p>
<p>求最长子串</p>
<p>条件为无重复字符</p>
<p>单调性</p>
<p>子串是数组的一个区间。那么题目的特点已经和最长区间的特点非常匹配了。再看单调性，当子串在变长的时候，不可能出现“无重复字符 → 重复字符 → 无重复字符”这种可能。因此满足单调性。</p>
<p>那么这里我们直接使用双指针进行求解。</p>
<p>其实可以直接套用前面总结出的模板，但是我们立马会发现模板中代码并不完整，还有两个“TODO”需要处理。下面我们看一下如何像处理填空题一样把这两个空给填上。</p>
<p>1. 检查区间状态</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">while (check((left, i]))是否满足条件)
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先，我们检查区间是否满足条件，那么如何检查？当我们把新字符 s[i] 加入合法区间 (left, i-1]，形成 (left, i] 区间之后，区间的状态就会变成如下图所示的样子：</p>
<p>这个时候，可以发现区间里面 (left, i] 里面已经有一个&rsquo;a&rsquo;了。也就是说：如果我们发现当加入一个字符的时候，这个字符位置在 (left, i-1] 区间里面，此时就产生了重复字符。所以检查条件可以修改成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// pos[]数组用来记录每个字符的位置
</span></span><span class="line"><span class="cl">while (left &lt; i &amp;&amp; pos[字符] &gt; left) {
</span></span><span class="line"><span class="cl">  // 然后移动left
</span></span><span class="line"><span class="cl">  // TODO 修改区间状态
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>2. 修改区间状态</p>
<p>我们来看一个例子，当产生重复字符的时候，如何修改呢？具体操作如下：</p>
<p>也就是 left = pos[&lsquo;a&rsquo;] 就可以。那么状态的更新就可以写成如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// pos[]数组用来记录每个字符的位置
</span></span><span class="line"><span class="cl">while (left &lt; i &amp;&amp; pos[字符] &gt; left) {
</span></span><span class="line"><span class="cl">  // 然后移动left
</span></span><span class="line"><span class="cl">  left = pos[字符];
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>【代码】填好空的代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int lengthOfLongestSubstring(String s) {
</span></span><span class="line"><span class="cl">  final int N = s == null ? 0 : s.length();
</span></span><span class="line"><span class="cl">  int[] pos = new int[256];
</span></span><span class="line"><span class="cl">  Arrays.fill(pos, -1);
</span></span><span class="line"><span class="cl">  int ans = 0;
</span></span><span class="line"><span class="cl">  int left = -1;
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">    final int idx = (int)s.charAt(i);
</span></span><span class="line"><span class="cl">    // (left, i)已经是一个有效的解
</span></span><span class="line"><span class="cl">    // 现在要把s[i]加进来
</span></span><span class="line"><span class="cl">    // 1. 坏了才移动
</span></span><span class="line"><span class="cl">    // 那么看一下是否会坏？
</span></span><span class="line"><span class="cl">    while (pos[idx] &gt; left) {
</span></span><span class="line"><span class="cl">      // 如果(left, i)里面已经有了s[i]
</span></span><span class="line"><span class="cl">      // 那么需要移动左边，
</span></span><span class="line"><span class="cl">      // 移动的时候，怎么移动？
</span></span><span class="line"><span class="cl">      // 可以直接将left 移动到pos[s[i]]
</span></span><span class="line"><span class="cl">      // 因为我们采用的区间是左开右闭
</span></span><span class="line"><span class="cl">      left = pos[idx];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    pos[idx] = i;
</span></span><span class="line"><span class="cl">    ans = Math.max(ans, i - left);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return ans;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度 O(N)，空间复杂度 O(1)。</p>
<p>【小结】到这里，我们已经学习了最长区间的原理，模板，以及将它巧妙地变成填空题来快速破题。</p>
<p>关于最长区间问题，我们可以总结如下：</p>
<p>接下来，为了巩固已学的知识，我们再一起看几道练习题。</p>
<p>练习题 1：给定一个字符串，你可以把字符串里面的某些字符替换成任意字符 k 次。请返回你可以得到的最长相同字符的长度。</p>
<p>输入：s = &lsquo;ABACD&rsquo;, k = 1</p>
<p>输出：3</p>
<p>解释：只需要把 &lsquo;ABA&rsquo; 里面的 B 替换成 &lsquo;A&rsquo; 即可。</p>
<p>代码：Java/C++/Python</p>
<p>练习题 2：你需要实现一个类，实现里面的 insert(char c) 函数，调用者会通过 insert 接口给你一个字符。此外，调用者还会立马调用 firstAppearingOnce() 函数来查询第一个出现的字符。如果不存在，返回 &lsquo;#&rsquo; 字符。</p>
<p>输入：google</p>
<p>输出：ggg#ll</p>
<p>代码：Java/C++/Python</p>
<p>练习题 3：给定一个数组 A[]，请你找到一个最长区间，这个区间里面最多包含两个不一样的数。</p>
<p>输入：A = [1, 2, 1, 2, 3]</p>
<p>输出：4</p>
<p>解释：区间 [1, 2, 1, 2] 里面只有两个数，并且是最长区间。</p>
<p>代码：Java/C++/Python</p>
<p>练习题 4：在练习题 3 的基础上，做了一点点扩展，最多包含 k 个不一样的数。</p>
<p>代码：Java/C++/Python</p>
<p>练习题 5：一个数组里面的数总是增增减减，会出现升序，然后再降序的情况，请找出这个数组里面最长的子串，这个子串刚好形成先升后降的大山峰。</p>
<p>代码:Java/C++/Python</p>
<p>最长区间问题，经过一小点改动还可以用来解决区间计数问题。下面我们一起来看一下。</p>
<p>例 2: 区间计数</p>
<p>【题目】给定一个正数数组A[]，以及一个正整数 k，求乘积小于 k 的子数组的个数。</p>
<p>输入：A = [100, 1, 1, 1, 2, 3, 4], k = 6</p>
<p>输出：12</p>
<p>解释：乘积小于 6 的子数组一共有 12 个。比如 [1]、 [1]、[1,1,1]，等等。</p>
<p>【分析】前面我们介绍的是使用模板求解最长区间，这道题目问题却是在求区间的个数。那么这两者之间有什么联系呢？</p>
<p>这里我们只看 A[4] = 2 元素的区间右端固定集合。如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">A[3] = 2:
</span></span><span class="line"><span class="cl">[100, 1, 1, 1, 2]
</span></span><span class="line"><span class="cl">     [1, 1, 1, 2] &lt;-- 最优解：乘积 &lt; 6的最长区间
</span></span><span class="line"><span class="cl">        [1, 1, 2]
</span></span><span class="line"><span class="cl">           [1, 2]
</span></span><span class="line"><span class="cl">              [2]
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以发现，[1, 1, 1, 2] 是我们寻找最长区间时候的最优解。让我们再回想一下前面提到的区间最优原则：</p>
<p>区间右端固定集合合里面，一旦找到一个最优解，那么最优解右边的区间如果满足条件，但都不是最优解。</p>
<p>区间最优原则也在疯狂暗示我们，如果找到以 A[i] 为右端的最优解，那么余下的更短的以 A[i] 为右端的区间，也是满足小于等于 k 的。在统计的时候，我们只需要累计每个 A[i] 的最优解区间的长度就可以了。</p>
<p>那么区间计数的模板就变成如下所示的样子（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int rangeCounter(int[] A) {
</span></span><span class="line"><span class="cl">  int N = A.length;
</span></span><span class="line"><span class="cl">  // 区间的左指针
</span></span><span class="line"><span class="cl">  int left = -1;
</span></span><span class="line"><span class="cl">  int ans = 0;
</span></span><span class="line"><span class="cl">  // 不变式0: 最开始的区间为(-1, -1] 是一个空区间
</span></span><span class="line"><span class="cl">  //         我们认为空区间总是满足条件!
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">    // 不变式1: 在加入A[i]之前，(left, i-1]是一个合法有效的区间
</span></span><span class="line"><span class="cl">    // step 1. 直接将A[i]加到区间中，形成(left, i]
</span></span><span class="line"><span class="cl">    // step 2. 将A[i]加入之后，惰性原则
</span></span><span class="line"><span class="cl">    while (check((left, i]))/*TODO 检查区间状态是否满足条件*/) {
</span></span><span class="line"><span class="cl">      ++left; // 如果不满足条件，移动左指针
</span></span><span class="line"><span class="cl">      // TODO 修改区间的状态
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 不变式2：此时(left, i]必然合法
</span></span><span class="line"><span class="cl">    // 累计区间个数
</span></span><span class="line"><span class="cl">    ans += i - left;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return ans; // 返回最优解
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>好吧，经过上述一番分析，我们又把区间计数问题变成填空题。下面只需要再填好那两个“TODO”的地方就可以了：</p>
<p>区间状态是否满足条件</p>
<p>移动左指针的时候，修改区间的状态</p>
<p>根据题意，这两个都是比较好填的：</p>
<p>区间状态，我们直接用累积就可以了</p>
<p>条件的判断只需要 s &gt; k</p>
<p>当移动左指针的时候，只需要 s /= A[++left] 即可</p>
<p>【代码】填好空的代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int numSubarrayProductLessThanK(int[] A, int k) {
</span></span><span class="line"><span class="cl">  final int N = A == null ? 0 : A.length;
</span></span><span class="line"><span class="cl">  int left = -1;
</span></span><span class="line"><span class="cl">  long ans = 0;
</span></span><span class="line"><span class="cl">  long s = 1;
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">    long x = A[i];
</span></span><span class="line"><span class="cl">    // 将x加到子数组中
</span></span><span class="line"><span class="cl">    s *= x;
</span></span><span class="line"><span class="cl">    // 如果破坏了约束，那么移动左指针
</span></span><span class="line"><span class="cl">    while (s &gt;= k &amp;&amp; left &lt; i) {
</span></span><span class="line"><span class="cl">      s /= A[++left];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 此时必然满足要求
</span></span><span class="line"><span class="cl">    ans += i - left;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return (int)ans;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度 O(N)，空间复杂度 O(1)。</p>
<p>【小结】这里我们再次提到**区间最优原则，**这个原则非常重要，是使用双指针来解决问题的关键与依赖。你可以尝试求解下面这道练习题，细细体会该原则。</p>
<p>练习题 6：给定一个有正数也有负数的数组 A[] 和 k，请找到最长的子数组，其和等于 k。</p>
<p>解法 1：Java/C++/Python</p>
<p>注：这里可能需要你好好想一下，为什么不能使用我们刚才所讲的模板。</p>
<p>下面我们整理一下最长区间题目的特点，以及代码模板的适用条件：</p>
<p>最长区间的知识点就讲到这里。接下来我们看一下定长区间问题的求解。</p>
<p>定长区间</p>
<p>定长区间问题是要找到一个固定长度的区间，并且这个区间必须满足某种条件。所以求解定长区间问题，实质上是需要找满足两个条件的子串。</p>
<p>子串的长度固定。由于长度固定，因此，定长区间问题不需要满足单调性。</p>
<p>子串必须满足某种条件。</p>
<p>定长区间的解法通常也被称为“滑动窗口算法”。在“第 09 讲”讲解二分搜索“例 4: 最大平均值”的时候，我们对这种方法有涉及，但是并没有深入地详细展开。这里我们再总结一下这种算法的模板与套路。</p>
<p>定长区间，由于长度固定，你可以想象成有一个固定的长度的窗口在数组上滑动。比如有一个长度为 3 的窗口在一个数组上滑动。</p>
<p>写定长区间的代码也比较容易。如果我们比较两者的变化，可以发现，只有首尾元素发生了变动。</p>
<p>那么我们在处理时，只需要保证加入元素和删除元素的时候，去更新区间的性质，查看是否满足约束条件即可。</p>
<p>面试必杀技</p>
<p>在面试的时候，如果拿到题目再去慢慢想滑动窗口应该怎么写，会浪费不少时间。这里我已经给你总结好了方法，你拿到题的时候，需要从题目中分析两个特点。</p>
<p>固定长度：题目要求解的是不是一个固定长度的子串？</p>
<p>约束条件： 这个定长区间必须要满足什么性质？</p>
<p>如果从题目中分析出以上 2 个特点，那么基本上可以直接套用定长区间的“滑动窗口”解法了。这里我已经整理好了一个通用的模板，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int fixedLength(int[] A, int windowSize) {
</span></span><span class="line"><span class="cl">  final int N = A == null ? 0 : A.length;
</span></span><span class="line"><span class="cl">  int left = -1;
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">    // step 1. 直接将A[i]加到区间中，形成(left, i]
</span></span><span class="line"><span class="cl">    // TODO 修改区间的状态
</span></span><span class="line"><span class="cl">    // 如果滑动窗口还太小
</span></span><span class="line"><span class="cl">    if (i - left &lt; windowSize) {
</span></span><span class="line"><span class="cl">      continue;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // assert 此时(left, i]长度必然等于windowSize
</span></span><span class="line"><span class="cl">    // TODO 判断区间的状态是否满足约束条件
</span></span><span class="line"><span class="cl">    left++;
</span></span><span class="line"><span class="cl">    // step 2. 移除A[left]
</span></span><span class="line"><span class="cl">    // TODO 修改区间状态
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return ans; // 返回最优解
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意，模板中只有**3 个“ TODO”**要根据题目的具体情况来填。这样，我们又把定长区间算法题变成了填空题。接下来我们再拿两道题来试刀。</p>
<p>例 3: 定长子串 1</p>
<p>【题目】给定两个字符串 A，B。判断 B 字符串是否有包含 A 字符串的任意排列。</p>
<p>输入：A = &ldquo;ab&rdquo;, B = &ldquo;bac&rdquo;</p>
<p>输出：true</p>
<p>解释：因为 B 字符串是包含 &ldquo;ba&rdquo;，而 &ldquo;ba&rdquo; 是字符串 &ldquo;ab&rdquo; 的一个排列。</p>
<p>【分析】首先我们看题目的特点，A 字符串的任意排列，透露出两个特点：</p>
<p>任意排列的长度肯定等于 A.length()</p>
<p>任意排列的字符的数目的统计结果必然相同</p>
<p>从这两个特点，我们可以知道：</p>
<p>固定长度，并且区间的长度就是 A 字符串的长度；</p>
<p>约束条件，区间里面的字符的统计个数必须相等。</p>
<p>如果现在我们直接套用模板，并且直接用数组来统计字符个数。就可以写出如下代码了（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">boolean checkInclusion(String A, String B) {
</span></span><span class="line"><span class="cl">  // B contains A的任意排列？
</span></span><span class="line"><span class="cl">  final int blen = B == null ? 0 : B.length();
</span></span><span class="line"><span class="cl">  final int alen = A == null ? 0 : A.length();
</span></span><span class="line"><span class="cl">  // 统计A字符串里面各个字符的出现次数
</span></span><span class="line"><span class="cl">  int[] astat = new int[256];
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt; alen; i++) {
</span></span><span class="line"><span class="cl">    astat[A.charAt(i)]++;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  // 统计B字符串里面的子串的字符的出现次数
</span></span><span class="line"><span class="cl">  int[] bstat = new int[256];
</span></span><span class="line"><span class="cl">  // 滑动窗口的左边起始点，我们使用(left, i]来表示这个
</span></span><span class="line"><span class="cl">  // 定长区间
</span></span><span class="line"><span class="cl">  int left = -1;
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt; blen; i++) {
</span></span><span class="line"><span class="cl">    // step 1. 直接将A[i]加到区间中，形成(left, i]
</span></span><span class="line"><span class="cl">    // DONE 修改区间的状态
</span></span><span class="line"><span class="cl">    Character c = B.charAt(i);
</span></span><span class="line"><span class="cl">    bstat[c]++;
</span></span><span class="line"><span class="cl">    // 如果窗口还太小，此时不满足定长的条件
</span></span><span class="line"><span class="cl">    if (i - left &lt; alen) {
</span></span><span class="line"><span class="cl">      continue;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // assert 此时(left, i]长度必然等于windowSize
</span></span><span class="line"><span class="cl">    // DONE 判断区间的状态是否满足约束
</span></span><span class="line"><span class="cl">    boolean same = true;
</span></span><span class="line"><span class="cl">    for (int j = 0; j &lt; 256 &amp;&amp; same; j++) {
</span></span><span class="line"><span class="cl">      same = astat[j] == bstat[j];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    if (same)
</span></span><span class="line"><span class="cl">      return true;
</span></span><span class="line"><span class="cl">    // 移除滑动窗口的尾巴!
</span></span><span class="line"><span class="cl">    left++;
</span></span><span class="line"><span class="cl">    bstat[B.charAt(left)]--;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return false;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们发现，套用模板还是挺好求解的。不过这里面还有一个小问题，在对比统计结果的时候，我们采用的方式比较暴力，总是遍历了统计结果里面的每一项。那么有没有更好的办法呢？</p>
<p>不难发现，需要比较的 astat 与 bstat，其中 A 字符串的统计结果astat 是固定不变的。并且 bstat 里面的统计结果，每次仅有一项会发生增减 1的情况。那么我们可以采用这种办法：</p>
<p>equal = 0，表示一开始只有 0 项字符的统计结果是相等的；</p>
<p>当 bstat[x]++ 之后。如果发现 bstat[x] == astat[x]，那么证明其中又有一个字符的统计结果满足要求了，equal ++；</p>
<p>如果发现 equal 等于需要统计的字符个数，那么就得到了一个正确的解；</p>
<p>在滑动窗口的尾巴移除之前，如果 bstat[x] == astat[x]，那么说明我们要把一个统计结果相等的字符给删除掉，equal&ndash;。</p>
<p>为了方便你记忆，我把这四个办法总结为一句话，那就是：“刚好等于 astat[x] 时进行增/减”。这样我们就可以写出更加高效的代码了，不需要再去逐个对比统计结果里面的每一项是否相等。</p>
<p>【代码】最终优化后的代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="err">统计类</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Counter</span> <span class="k">extends</span> <span class="n">astatashMap</span><span class="o">&lt;</span><span class="n">Character</span><span class="p">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">public</span> <span class="ne">int</span> <span class="n">get</span><span class="p">(</span><span class="n">Character</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">containsKey</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="err">?</span> <span class="n">super</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">public</span> <span class="n">void</span> <span class="n">add</span><span class="p">(</span><span class="n">Character</span> <span class="n">k</span><span class="p">,</span> <span class="ne">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">put</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">remove</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">boolean</span> <span class="n">checkInclusion</span><span class="p">(</span><span class="ne">String</span> <span class="n">A</span><span class="p">,</span> <span class="ne">String</span> <span class="n">B</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">//</span> <span class="n">B</span> <span class="n">contains</span> <span class="n">A</span><span class="err">?</span>
</span></span><span class="line"><span class="cl">  <span class="n">final</span> <span class="ne">int</span> <span class="n">blen</span> <span class="o">=</span> <span class="n">B</span> <span class="o">==</span> <span class="n">null</span> <span class="err">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">B</span><span class="o">.</span><span class="n">length</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">final</span> <span class="ne">int</span> <span class="n">alen</span> <span class="o">=</span> <span class="n">A</span> <span class="o">==</span> <span class="n">null</span> <span class="err">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">A</span><span class="o">.</span><span class="n">length</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="o">//</span> <span class="err">统计</span><span class="n">A字符串里面每个字符的出现次数</span><span class="err">。</span>
</span></span><span class="line"><span class="cl">  <span class="n">Counter</span> <span class="n">astat</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Counter</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="ne">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">alen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">astat</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">charAt</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">//</span> <span class="err">统计</span><span class="n">B字符串里面每个字符的出现次数</span><span class="err">。</span>
</span></span><span class="line"><span class="cl">  <span class="n">Counter</span> <span class="n">bstat</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Counter</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="ne">int</span> <span class="n">left</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">//</span> <span class="err">比较</span><span class="n">bstat与astat</span><span class="err">，有多少个字符的统计结果已经是相等的。</span>
</span></span><span class="line"><span class="cl">  <span class="ne">int</span> <span class="n">equal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="ne">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">blen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">将</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="err">添加到区间中</span>
</span></span><span class="line"><span class="cl">    <span class="n">Character</span> <span class="n">c</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">charAt</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">更新区间的状态</span>
</span></span><span class="line"><span class="cl">    <span class="n">bstat</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">更新两个计数器相等的计数项的个数</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">bstat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">astat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">equal</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">如果窗口太小</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">alen</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="nb">assert</span> <span class="err">此时</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="err">长度必然等于</span><span class="n">windowSize</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">DONE</span> <span class="err">判断区间的状态是否满足约</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">equal</span> <span class="o">==</span> <span class="n">astat</span><span class="o">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="bp">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">移除滑动窗口的尾巴</span><span class="o">!</span>
</span></span><span class="line"><span class="cl">    <span class="n">left</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">更新移动后的区间的状态</span>
</span></span><span class="line"><span class="cl">    <span class="n">Character</span> <span class="n">rm</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">charAt</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">bstat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span> <span class="o">==</span> <span class="n">astat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rm</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">equal</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">bstat</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="bp">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度 O(N)，空间复杂度 O(1)。由于字符个数是固定的 256 个。虽然使用了哈希表，但是占用的空间是固定的。因此，空间复杂度为 O(1)。</p>
<p>【小结】接下来我们看一下定长区间的知识结构：</p>
<p>通过上图的总结我们可以发现：定长区间的核心问题就是关注区间状态的表达。所以，这道题目的考点也非常明确：</p>
<p>如何用统计的办法来表达区间的状态</p>
<p>如何验证两个哈希表是否相等</p>
<p>这里我再给你留个小练习，不要偷懒，一定要尝试自己解答！</p>
<p>练习题 7：在例 3 中我们使用了哈希表来处理字符的统计，主要是为了 Counter 类的通用性。由于字符只有 256 个。你能用数组来加速这个算法吗？</p>
<p>代码：Java/C++/Python</p>
<p>接下来我们看一下这道题目的一个变形。</p>
<p>例 4: 定长子串 2</p>
<p>【题目】给定一个字符串 s，以及一个相同长度的单词列表。请找到所有的子串，这些子串必须包含列表中所有的单词（单词的顺序可以乱）。所有符合要求的子串的起始位置。</p>
<p>输入：s = &ldquo;AABBCCBBAA&rdquo;, D = {&ldquo;AA&rdquo;, &ldquo;BB&rdquo;};</p>
<p>输出：[0, 6]</p>
<p>解释：在 s 字符串中，以下标 0 和下标 6 起始的子串 &ldquo;AABB&rdquo;, &ldquo;BBAA&rdquo; 符合要求。</p>
<p>【分析】每个单词的长度是固定的，设为 L，那么需要把 s 按长度 L 进行切分。那么当 L = 2 的时候，切分方式可以如下：</p>
<p>其他的切分方式都是这两种切分方式的子集。更进一步，我们可以有如下切分结论：字符串 s 要按固定长度 L 切分时，只有 L 种切分方式。</p>
<p>不同的切分方式，就好像生成了不同的数组一样，如下图所示：</p>
<p>这个操作代码可以写成如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int start = 0; start &lt; L; start++) {
</span></span><span class="line"><span class="cl">  // 这里开始遍历
</span></span><span class="line"><span class="cl">  // 数组0. [&#34;AA&#34;, &#34;BB&#34;, &#34;CC&#34;, &#34;BB&#34;, &#34;AA&#34;]
</span></span><span class="line"><span class="cl">  // 数组1. [&#34;AB&#34;, &#34;BC&#34;, &#34;CB&#34;, &#34;BA&#34;]
</span></span><span class="line"><span class="cl">  for (int i = start; i + L &lt;= s.length(); i+= L) {
</span></span><span class="line"><span class="cl">    String tmp = s.substring(i, i + L);
</span></span><span class="line"><span class="cl">    // tmp就是依次取出数组中的单词。
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>到此时，题目已经变成在 String[] 数组里面找一个子串，这个子串里面包含列表中所有的单词。这么一看，不就是我们前面学习过的例 3 吗。但是与例 3 不同的地方在于：</p>
<p>这里表面上看是一个字符串 s，实际上是通过字符串 s 生成 L 个数组；</p>
<p>例 3 中需要统计的是单个的字符，而在这里需要统计的是单词。</p>
<p>【代码】我们直接基于例 3，再加上一些代码（解析在注释里），就可以解决这道题了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Counter</span> <span class="k">extends</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="ne">String</span><span class="p">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">public</span> <span class="ne">int</span> <span class="n">get</span><span class="p">(</span><span class="ne">String</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">containsKey</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="err">?</span> <span class="n">super</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">public</span> <span class="n">void</span> <span class="n">add</span><span class="p">(</span><span class="ne">String</span> <span class="n">k</span><span class="p">,</span> <span class="ne">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">put</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">remove</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">findSubstring</span><span class="p">(</span><span class="ne">String</span> <span class="n">s</span><span class="p">,</span> <span class="ne">String</span><span class="p">[]</span> <span class="n">D</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Counter</span> <span class="n">H</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Counter</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="ne">int</span> <span class="n">wordLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">//</span> <span class="err">统计字典中单词出现的次数</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="ne">String</span> <span class="n">w</span> <span class="p">:</span> <span class="n">D</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">wordLength</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">length</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">H</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="ne">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">wordLength</span><span class="p">;</span> <span class="n">start</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">切分点从</span><span class="n">start开始</span><span class="err">，相当于我们得到了一个新的数组。</span>
</span></span><span class="line"><span class="cl">    <span class="n">Counter</span> <span class="n">R</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Counter</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">wordLength</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">equalCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">有效的区间是</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="ne">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">wordLength</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span> <span class="o">+=</span> <span class="n">wordLength</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">//</span> <span class="err">依次取出数组中的单词。</span>
</span></span><span class="line"><span class="cl">      <span class="ne">String</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">substring</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">wordLength</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">R</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">==</span> <span class="n">H</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">equalCount</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="o">//</span> <span class="err">如果窗口太小</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="n">D</span><span class="o">.</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="o">//</span> <span class="err">到这里时，窗口的长度已经一样了</span>
</span></span><span class="line"><span class="cl">      <span class="o">//</span> <span class="err">看一下命中率</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">equalCount</span> <span class="o">==</span> <span class="n">H</span><span class="o">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ans</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">wordLength</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="o">//</span> <span class="err">移除开头的那个元素</span>
</span></span><span class="line"><span class="cl">      <span class="n">left</span> <span class="o">+=</span> <span class="n">wordLength</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="ne">String</span> <span class="n">rm</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">substring</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">left</span> <span class="o">+</span> <span class="n">wordLength</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span> <span class="o">==</span> <span class="n">H</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rm</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">equalCount</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">R</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：当单词固定长度为 L 的时候，一共会切分出 L 个数组。每个数组上的单词个数为 N/L，滑动窗口遍历单个数组时间复杂度是O(N/L)，所以最终时间复杂度为 O(N)。空间复杂度由于使用了哈希表，等价于单词的个数。</p>
<p>【小结】到这里，我们再总结一下这个题目的考点：</p>
<p>我们可以发现，在面试中，只要掌握上图中总结的三个知识点，就可以顺利地解决这道面试题。</p>
<p>接下来我们看一下最短区间问题。</p>
<p>最短区间</p>
<p>在区间问题中，还有一类区间问题。那就是求最短区间。这类面试题的特点也很明确：</p>
<p>要求子串必须满足某个条件</p>
<p>要求子串的长度越小越好</p>
<p>要特别注意的是，最短区间问题，也必须满足单调性。</p>
<p>面试必杀技</p>
<p>不过，在真正面试的时候，可没有那么多时间让你慢慢去证明，慢慢去推导。放心，我这里已经给你准备好了最短区间的面试必杀技，关键就两招：</p>
<p>两个指针，left 指针和 right 指针，这两个指针形成的区间为 (left, right]，这里的开闭原则是左开右闭；</p>
<p>积极原则，如果把 left 指针当成一个人，那么这个人是非常积极的，他总是主动积极地破坏区间已经满足的条件。</p>
<p>代码模板如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int minimalRange(int[] A) {
</span></span><span class="line"><span class="cl">  final int N = A == null ? 0 : A.length;
</span></span><span class="line"><span class="cl">  // 子串的左边，采用左开右闭原则(left, i]表示一个子串
</span></span><span class="line"><span class="cl">  int left = -1;
</span></span><span class="line"><span class="cl">  // 记录最短的子串的长度
</span></span><span class="line"><span class="cl">  int ans = A.length + 1;
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">    // 注意 在加入A[i]之前，(left, i-1]可能不满足条件!
</span></span><span class="line"><span class="cl">    // step 1. 直接将A[i]加到区间中，形成(left, i]
</span></span><span class="line"><span class="cl">    // step 2. TODO 更新区间的状态
</span></span><span class="line"><span class="cl">    while (区间超出/满足条件) {
</span></span><span class="line"><span class="cl">      ans = Math.min(ans, i - left);
</span></span><span class="line"><span class="cl">      // step 3. 移除A[++left];
</span></span><span class="line"><span class="cl">      // step 4. TODO 更新区间的状态
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // assert ! 区间(left, i]到这里肯定不满足条件
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return ans;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意，这里需要与最长区间的代码模板进行对比。两者的差异部分在于里面的 while 循环处理逻辑不同。在最短区间求解时，当满足条件的时候，仍然需要在这个 while 里面进行处理。</p>
<p>比如我们仍然以数组 [1, 2, 0, 0, 1, 2, 3] 寻找等于 6 的最短子串为例，如下图所示：</p>
<p>当找到一个满足条件的解之后，我们开始不停地查看更短的子串，看看有没有更好的解，并且不停地更新最优解。最终可以得到最优解：长度为 3 的子串 [1, 2, 3]。</p>
<p>例 5：最短子串</p>
<p>【题目】求 A 字符串中的最短子串，要能够包含 B 字符串中的所有字符。</p>
<p>输入：A = &ldquo;AXCDEFCFCB&rdquo;, B = &ldquo;CBC&rdquo;</p>
<p>输出：4</p>
<p>解释：因为 A 字符串有子串 &ldquo;CFCB&rdquo;，包含了 B 字符串的所有字符&quot;CBC&quot;。</p>
<p>【分析】不知道你还有没有印象，“第 09 讲”中讲解关于二分搜索的练习题 5 时，我们也提到了这道题。不过现在我们要尝试使用复杂度更低的双指针来解决它。首先我们来看题目的特点。</p>
<p>最短区间：题目要求一个最短的字符串。</p>
<p>约束条件：这个子串里面包含了 B 字符串的所有字符。</p>
<p>单调性：当区间变长时，包含的字符只会增加。</p>
<p>如果用哈希表（也可以用数组）来记录 B 字符串中字符出现的次数，也同样用哈希表来记录 A 的子串中各个字符出现的次数。那么我们还需要面临的一个问题就是如何高效地比较两个哈希是否相等。</p>
<p>不过好在例 3 中我们已经学会了这一招，到这里就可以开始着手写代码了。</p>
<p>【代码】利用最短区间的代码模板以及判断哈希表相等的思路。我们可以写出代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">String minWindow(String A, String B) {
</span></span><span class="line"><span class="cl">  // A 中包含B中所有字符的最短子串。
</span></span><span class="line"><span class="cl">  // 两个字符串的长度。
</span></span><span class="line"><span class="cl">  final int alen = A == null ? 0 : A.length();
</span></span><span class="line"><span class="cl">  final int blen = B == null ? 0 : B.length();
</span></span><span class="line"><span class="cl">  // 统计B字符串里面字符出现的次数
</span></span><span class="line"><span class="cl">  int[] bstat = new int[256];
</span></span><span class="line"><span class="cl">  // items表示B字符串里面出现的字符的种类。类似于hash.size();
</span></span><span class="line"><span class="cl">  int items = 0;
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt; blen; i++) {
</span></span><span class="line"><span class="cl">    bstat[B.charAt(i)]++;
</span></span><span class="line"><span class="cl">    if (bstat[B.charAt(i)] == 1) {
</span></span><span class="line"><span class="cl">      items++;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  // 开始使用最短区间的模板
</span></span><span class="line"><span class="cl">  int left = -1;
</span></span><span class="line"><span class="cl">  int ans = alen + 1;
</span></span><span class="line"><span class="cl">  int start = 0;
</span></span><span class="line"><span class="cl">  // 用来记录子串里面字符出现的次数
</span></span><span class="line"><span class="cl">  int[] astat = new int[256];
</span></span><span class="line"><span class="cl">  // 用来判断两个哈希表中已经有多少项相等了。
</span></span><span class="line"><span class="cl">  int equal = 0;
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt; alen; i++) {
</span></span><span class="line"><span class="cl">    astat[A.charAt(i)]++;
</span></span><span class="line"><span class="cl">    if (astat[A.charAt(i)] == bstat[A.charAt(i)]) {
</span></span><span class="line"><span class="cl">      equal++;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 积极原则，最短区间要主动破坏条件
</span></span><span class="line"><span class="cl">    while (equal &gt;= items) {
</span></span><span class="line"><span class="cl">      // 更新最优解
</span></span><span class="line"><span class="cl">      if (ans &gt; i - left) {
</span></span><span class="line"><span class="cl">        start = left + 1;
</span></span><span class="line"><span class="cl">        ans = i - left;
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      // 移除最左端的元素，并且更新区间的状态
</span></span><span class="line"><span class="cl">      ++left;
</span></span><span class="line"><span class="cl">      if (astat[A.charAt(left)] == bstat[A.charAt(left)]) {
</span></span><span class="line"><span class="cl">        equal--;
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      astat[A.charAt(left)]--;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return ans &lt;= alen ? 
</span></span><span class="line"><span class="cl">    A.substring(start, start + ans) : new String(&#34;&#34;);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度 O(N)，空间复杂度 O(1)，两个 256 长度的数组，可以认为是常量空间。</p>
<p>【小结】到这里，我们可以总结一下这个题目的考点：</p>
<p>如果你能够在面试中清晰地理顺这三个考点，那么写出代码就不成问题了。</p>
<p>接下来我们看一个更加简单一点的练习题。</p>
<p>练习题 8：给定一个正整数数组 A，求一个最短子串，其和大于等于正整数T。</p>
<p>代码：Java/C++/Python</p>
<p>总结</p>
<p>在这一讲里面我们介绍了三种区间的解法，以及相应的模板，基本上覆盖了绝大部分双指针算法题。我们将这部分知识点做个简单的小结，如下图所示：</p>
<p>思考题</p>
<p>这里我给你再留一道思考题：在“第 09 讲”中，我们可以利用二分搜索的办法解决一些最长子串、最短子串的题目。其根本原因是什么？练习题 6 不能使用双指针模板，那么二分搜索可以吗？</p>
<p>希望你可以把思考写在留言区，我们一起讨论，如果看到有趣的想法，我也会做成加餐和大家分享。：）</p>
<p>关于双指针的知识我们就学到这里，并且有相应的代码模板。可是，并不是所有的问题都有模板可以套用的，接下来我们进入没有代码模板的算法类型。11｜贪心：这种思想，没有模板，如何才能掌握它？请和我一起踏上更加奇妙的算法旅程，记得按时来探险。</p>
<p>-&ndash; ### 精选评论 ##### **6011： &gt; 二分的提问破解法，需要单调性。双指针的最长最短区间也必须满足单调性！ ##### **辉： &gt; final int idx = (int)s.charAt(i);这个是字符串强转成是int???????,咋理解 ######     讲师回复： &gt;     你把pos数组当成一个哈希表。强制转换成为int，只是为了作为哈希的key去取这个字符相应的信息。 ##### **威： &gt; 老师，真是大牛，举重若轻～</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">数据结构与算法面试宝典</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/09%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93writeandfluh%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%89%96%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">09数据传输：writeAndFluh处理流程剖析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/etcd%E5%AE%9E%E6%88%98%E8%AF%BE/10__boltdb%E5%A6%82%E4%BD%95%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%E4%BD%A0%E7%9A%84key-value%E6%95%B0%E6%8D%AE/">
            <span class="next-text nav-default">10__boltdb：如何持久化存储你的key-value数据？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
