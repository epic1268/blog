<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>16 如何利用DP与单调队列寻找最大矩形？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="面试的场景与我们之前学习某个知识点的情况不再相同。在学习“一解多题”的时候，由于已经预设了前提，实际上我们是知道某个题会用到什么知识点的。
但是在面试中，当你拿到一个题目，可能一时想不到具体采用哪种解法。所以在本讲，我将带你回到面试场景，教你分析题目的思路。我们的目标就变成从题目出发，去考虑如何破解一个题。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/16-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8dp%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%AF%BB%E6%89%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/16-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8dp%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%AF%BB%E6%89%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="16 如何利用DP与单调队列寻找最大矩形？">
  <meta property="og:description" content="面试的场景与我们之前学习某个知识点的情况不再相同。在学习“一解多题”的时候，由于已经预设了前提，实际上我们是知道某个题会用到什么知识点的。
但是在面试中，当你拿到一个题目，可能一时想不到具体采用哪种解法。所以在本讲，我将带你回到面试场景，教你分析题目的思路。我们的目标就变成从题目出发，去考虑如何破解一个题。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="数据结构与算法面试宝典">

  <meta itemprop="name" content="16 如何利用DP与单调队列寻找最大矩形？">
  <meta itemprop="description" content="面试的场景与我们之前学习某个知识点的情况不再相同。在学习“一解多题”的时候，由于已经预设了前提，实际上我们是知道某个题会用到什么知识点的。
但是在面试中，当你拿到一个题目，可能一时想不到具体采用哪种解法。所以在本讲，我将带你回到面试场景，教你分析题目的思路。我们的目标就变成从题目出发，去考虑如何破解一个题。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="14182">
  <meta itemprop="keywords" content="数据结构与算法面试宝典">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="16 如何利用DP与单调队列寻找最大矩形？">
  <meta name="twitter:description" content="面试的场景与我们之前学习某个知识点的情况不再相同。在学习“一解多题”的时候，由于已经预设了前提，实际上我们是知道某个题会用到什么知识点的。
但是在面试中，当你拿到一个题目，可能一时想不到具体采用哪种解法。所以在本讲，我将带你回到面试场景，教你分析题目的思路。我们的目标就变成从题目出发，去考虑如何破解一个题。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">16 如何利用DP与单调队列寻找最大矩形？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 14182 字 </span>
          <span class="more-meta"> 预计阅读 29 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>面试的场景与我们之前学习某个知识点的情况不再相同。在学习“一解多题”的时候，由于已经预设了前提，实际上我们是知道某个题会用到什么知识点的。</p>
<p>但是在面试中，当你拿到一个题目，可能一时想不到具体采用哪种解法。所以在本讲，我将带你回到面试场景，教你分析题目的思路。我们的目标就变成从题目出发，去考虑如何破解一个题。</p>
<p>本讲将会重点学习：</p>
<p>如何挖掘题目的特点</p>
<p>如何利用特点匹配到数据结构和算法知识点</p>
<p>完成这两步动作，需要你熟练地掌握前面“一解多题”模块介绍的数据结构与算法知识点。养兵千日，用在一时，是时候派上用场了。</p>
<p>最大矩形</p>
<p>【题目】给定一个数组，里面有n个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p>输入：[2,1,5,6,2,3]</p>
<p>输出：10</p>
<p>解释：柱状图的示例，其中每个柱子的宽度为 1，给定的高度为
[2,1,5,6,2,3]
。</p>
<p>输入 最大矩形</p>
<p>暴力算法</p>
<p>当拿到题目之后，一种最简单、最暴力的算法立马会出现在我们脑海里面。那就是：</p>
<p>分别选定两个柱子，然后计算这两个柱子为边界，构成的最大矩形的面积；</p>
<p>取出所有的矩形面积中的最大面积。</p>
<p>那么根据这个思路，可以得到代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    private int minHeight(int[] A, int l, int r) {
</span></span><span class="line"><span class="cl">        int h = Integer.MAX_VALUE;
</span></span><span class="line"><span class="cl">        for (int k = l; k &lt;= r; k++) {
</span></span><span class="line"><span class="cl">            h = Math.min(h, A[k]);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return h;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public int largestRectangleArea(int[] A) {
</span></span><span class="line"><span class="cl">        final int N = A == null ? 0 : A.length;
</span></span><span class="line"><span class="cl">        int ans = 0;
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">            for (int j = i; j &lt; N; j++) {
</span></span><span class="line"><span class="cl">                ans = Math.max(ans,
</span></span><span class="line"><span class="cl">                   minHeight(A, i, j) * (j - i + 1));
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return ans;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是，这个代码的时间复杂度实在太高，达到 O(N3)，在面试中并不能给你加分。那么有没有什么更好的办法呢？</p>
<p>特点 1：区间</p>
<p>可以发现，求解的时候，我们非常依赖一个区域里面的最小值：就是 minHeight() 函数。</p>
<p>那么，有没有什么办法，可以快速地获取：一个数组区间里面的最小值呢？此时问题破解的关键聚焦到下面这个问题上。</p>
<p>给定一个数组：如何快速地查询一个区间里面的最小值？</p>
<p>如果我们能在 O(1) 的时间得到一个区间里面的最小值，那么就可以把暴力算法的时间复杂度优化到 O(N2)。</p>
<p>因此，此时我们需要快速匹配到一个算法和数据结构来满足这样的特点。想到这里，你的脑海里面应该浮现如下的场景：</p>
<p>那么，我们需要什么样的数据结构/算法呢？</p>
<p>如果是在面试中，你发现脑海里面空空如也，一点也想不到有什么办法可以处理这个区间查询问题，就需要立马转换思路，尝试寻找别的破题办法。因为很有可能，这里踩了你的知识盲区，要在短时间发现一种算法解决这个问题的可能性还是挺小的。</p>
<p>如果是在准备面试阶段，那么你应该立马搜索一下有什么样的数据结构可以满足这样的要求。大概率情况下，这种基础问题已经有很多现成的数据结构来支撑了，所以不需要你再去“挠破脑袋”当发明家了。</p>
<p>就现在而言，我们肯定是处在一个准备面试的阶段。所以，下面我会带你走一遍“搜索”的步骤。</p>
<p>求解区间的最小值/最大值问题，一般有 2 类算法与数据结构：</p>
<p>ST（Sparse Table）算法</p>
<p>线段树（Segment Tree）</p>
<p>接下来，我们分别介绍一下这两种算法（说不定哪天你在面试中碰到这个关键问题，就轻而易举答出来了）。</p>
<p>ST 算法</p>
<p>在面试时，我们总是先看到问题，然后希望匹配到一个算法，能够刚好满足我们期望的时间复杂度。那么 ST 算法可以满足我们的要求吗？</p>
<p>先来看一下 ST 算法的特点：</p>
<p>ST 算法需要预处理，并且在预处理阶段，时间复杂度为 O(NlgN)，空间复杂度为 O(NlgN)；</p>
<p>ST 算法预处理结束之后，在查询阶段，时间复杂度为 O(1)。</p>
<p>如果我们用上 ST 算法，那么时间复杂度可以从 O(N3) 变为 O(N2 + NlgN) = O(N2)。这样一来复杂度就下降了一个数量级，还是非常值得一试的。</p>
<p>下面我们讲一下 ST 算法 2 个核心思想。</p>
<p>1. 一分为二</p>
<p>任何一个区间都可以分为两个可能重合的区间。比如给定的区间为 [start, end]，那么：</p>
<p>这个区间可以分为 [start, end1], [start2, end]，即第一个区间必须以 start 为起点，第二个区间必须以 end 为终点；</p>
<p>两个区间可以重合；</p>
<p>两个区间的长度必须是 2p 长度（p 是非负整数）。</p>
<p>【例 1】比如有一个区间 [10, 17]，长度为 8，那么可以拆分为 [10, 13], [14,17] 长度为 22 的两个区间。下图是拆分之后不存在重合的情况：</p>
<p>【例 2】比如有一个区间 [10, 18]，长度为 9。那么可以拆分为 [10, 17] 和 [11, 18] 长度为 23 的两个区间。下图是拆分之后存在部分重合的情况：</p>
<p>【例 3】比如有一个区间 [10, 10]，长度为 1，那么可以拆分为 [10, 10] 和 [10, 10]，这两个区间完全重合，且长度为 20 的两个区间。这是拆分之后完全重合的情况。</p>
<p>基于此，我们可以得到结论 1。</p>
<p>给定一个数组，这个数组里面的任意一个有效区间总是可以表达为：可能重叠的两个 2p 长度区间。</p>
<p>那么，假设我们已经得到所有 2p 长度的区间的信息。那么“区间 [start, end] 上的最小值：可以先取出两个长度为 2p 的子区间的最小值，再从中选择最小的即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">区间[start, end]上的最小值 = min(区间[l, l+2&lt;sup&gt;p&lt;/sup&gt;)上的最小值
</span></span><span class="line"><span class="cl">                         区间[r-2&lt;sup&gt;p&lt;/sup&gt;+1, r]上的最小值)
</span></span></code></pre></td></tr></table>
</div>
</div><p>基于结论 1，我们可以得到结论 2。</p>
<p>计算顺序：</p>
<p>先计算出长度为 20 的所有区间的最小值；</p>
<p>再计算长度为 21 的所有区间的最小值；</p>
<p>然后计算长度为 22 的所有区间的最小值；</p>
<p>直到长度为 2x 的区间的最小值。</p>
<p>其中 2x 刚好大于等于给定的数组长度。</p>
<p>2. 指数表示法</p>
<p>当拆分完成之后，原本一个区间的表示是 [start, end]，分为两个长度（len）一样的区间。更进一步，这两个区间可以表示为 &lt;start1, len&gt;, &lt;start2, len&gt;。</p>
<p>例 1 中 [10, 18] 拆分之后，可以表示为 &lt;start1=10, len=8&gt;, &lt;start2=11, len=8&gt;。</p>
<p>例 2 中 [10, 17] 拆分之后，可以表示为 &lt;start1=10, len=4&gt;, &lt;start2=14,len=4&gt;。</p>
<p>重新表示之后，区间 &lt;start, len&gt; 中，由于长度信息 len 总是 2p，因此我们可以只记录指数 p。</p>
<p>例 1 中 [10, 18] 拆分之后，可以表示为 &lt;start1=10, p=3&gt;, &lt;start2=11, p=3&gt;。</p>
<p>例 2 中 [10, 17] 拆分之后，可以表示为 &lt;start1=10, p=2&gt;, &lt;start2=14,p=2&gt;。</p>
<p>如果我们将区间采用指数 p 表示之后，就只需要使用空间 st[N][log2(N)+1]，也就是空间复杂度为 O(NlgN)。</p>
<p>那么基于以上两个核心思想，我们可以写出 ST 算法的代码了。这里可以分为两步，一步是预处理，另一步是查询。</p>
<p>预处理构建 st[][] 数组代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void buildST(int[] A, int[][] st) {
</span></span><span class="line"><span class="cl">  final int N = A == null ? 0 : A.length;
</span></span><span class="line"><span class="cl">  // 第一步：
</span></span><span class="line"><span class="cl">  //    - 处理长度为1的区间
</span></span><span class="line"><span class="cl">  //      即[i, i + 1)
</span></span><span class="line"><span class="cl">  //
</span></span><span class="line"><span class="cl">  // 区间的表示：
</span></span><span class="line"><span class="cl">  //      [start=i, len=2&lt;sup&gt;0&lt;/sup&gt;]
</span></span><span class="line"><span class="cl">  //      也就是st[i][len=2&lt;sup&gt;0&lt;/sup&gt;]
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">    st[i][0] = A[i];
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  // 递推：
</span></span><span class="line"><span class="cl">  //      依次处理2&lt;sup&gt;j&lt;/sup&gt;长度。
</span></span><span class="line"><span class="cl">  //      其中2&lt;sup&gt;j&lt;/sup&gt; = 2&lt;sup&gt;(j-1)&lt;/sup&gt; + 2&lt;sup&gt;(j-1)&lt;/sup&gt;
</span></span><span class="line"><span class="cl">  //      注意：这里的长度都是完整的2&lt;sup&gt;j&lt;/sup&gt;的
</span></span><span class="line"><span class="cl">  for (int j = 1; (1 &lt;&lt; j) &lt;= N; j++) {
</span></span><span class="line"><span class="cl">    // 这里要处理的区间[i, i + (1&lt;&lt;j)]
</span></span><span class="line"><span class="cl">    // last = i + (1&lt;&lt;j)
</span></span><span class="line"><span class="cl">    // 根据左闭右开原则，last是可以取到n的。这点要注意。
</span></span><span class="line"><span class="cl">    for (int i = 0; (i + (1 &lt;&lt; j)) &lt;= N; i++) {
</span></span><span class="line"><span class="cl">      st[i][j] = Math.min(st[i][j - 1], 
</span></span><span class="line"><span class="cl">                          st[i + (1 &lt;&lt; (j - 1))][j - 1]);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>查询阶段的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int minHeight(int[][] st, int l, int r)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  // 这里我们将区间[l, r]分为两个区间
</span></span><span class="line"><span class="cl">  // [l, l+log2(len)] =&gt; [l, len=log2(len)]
</span></span><span class="line"><span class="cl">  // [r-log2(len)+1, r] =&gt; [r-log2(len) + 1, len=log2(len)]
</span></span><span class="line"><span class="cl">  int len = r - l + 1;
</span></span><span class="line"><span class="cl">  int j = log2(len);
</span></span><span class="line"><span class="cl">  return Math.min(st[l][j], st[r - (1 &lt;&lt; j) + 1][j]);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是，在查询阶段，如果一个区间的长度本来就是 2p，那么就可以拆分成两个完全重合的区间。</p>
<p>得到 ST 算法的代码之后，我们就可以开始解决这道题目了。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    private int log2(int N) {
</span></span><span class="line"><span class="cl">        return (int)(Math.log(N) / Math.log(2));
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    private int[][] createST(int N) {
</span></span><span class="line"><span class="cl">        final int powerOf2 = log2(N);
</span></span><span class="line"><span class="cl">        int[][] st = new int[N][powerOf2 + 1];
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">            st[i] = new int[powerOf2+1];
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return st;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    private void buildST(int[] A, int[][] st) {
</span></span><span class="line"><span class="cl">        final int N = A == null ? 0 : A.length;
</span></span><span class="line"><span class="cl">        // 第一步：
</span></span><span class="line"><span class="cl">        //    - 处理长度为1的区间
</span></span><span class="line"><span class="cl">        //      即[i, i + 1)
</span></span><span class="line"><span class="cl">        //
</span></span><span class="line"><span class="cl">        // 区间的表示：
</span></span><span class="line"><span class="cl">        //      [start=i, len=2&lt;sup&gt;0&lt;/sup&gt;]
</span></span><span class="line"><span class="cl">        //      也就是st[i][len=2&lt;sup&gt;0&lt;/sup&gt;]
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">            st[i][0] = A[i];
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 递推：
</span></span><span class="line"><span class="cl">        //      依次处理2&lt;sup&gt;j&lt;/sup&gt;长度。
</span></span><span class="line"><span class="cl">        //      其中2&lt;sup&gt;j&lt;/sup&gt; = 2&lt;sup&gt;(j-1)&lt;/sup&gt; + 2&lt;sup&gt;(j-1)&lt;/sup&gt;
</span></span><span class="line"><span class="cl">        //      注意：这里的长度都是完整的2&lt;sup&gt;j&lt;/sup&gt;的
</span></span><span class="line"><span class="cl">        for (int j = 1; (1 &lt;&lt; j) &lt;= N; j++) {
</span></span><span class="line"><span class="cl">            // 这里要处理的区间[i, i + (1&lt;&lt;j)]
</span></span><span class="line"><span class="cl">            // last = i + (1&lt;&lt;j)
</span></span><span class="line"><span class="cl">            // 根据左闭右开原则，last是可以取到n的。这点要注意。
</span></span><span class="line"><span class="cl">            for (int i = 0; (i + (1 &lt;&lt; j)) &lt;= N; i++) {
</span></span><span class="line"><span class="cl">                st[i][j] = Math.min(st[i][j - 1],
</span></span><span class="line"><span class="cl">                                    st[i + (1 &lt;&lt; (j - 1))][j - 1]);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    private int minHeight(int[][] st, int l, int r) {
</span></span><span class="line"><span class="cl">        // 这里我们将区间[l, r]分为两个区间
</span></span><span class="line"><span class="cl">        // [l, l+log2(len)] =&gt; [l, len=log2(len)]
</span></span><span class="line"><span class="cl">        // [r-log2(len)+1, r] =&gt; [r-log2(len) + 1, len=log2(len)]
</span></span><span class="line"><span class="cl">        int len = r - l + 1;
</span></span><span class="line"><span class="cl">        int j = log2(len);
</span></span><span class="line"><span class="cl">        return Math.min(st[l][j], st[r - (1 &lt;&lt; j) + 1][j]);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public int largestRectangleArea(int[] A) {
</span></span><span class="line"><span class="cl">        final int N = A == null ? 0 : A.length;
</span></span><span class="line"><span class="cl">        int[][] st = createST(N);
</span></span><span class="line"><span class="cl">        buildST(A, st);
</span></span><span class="line"><span class="cl">        int ans = 0;
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">            for (int j = i; j &lt; N; j++) {
</span></span><span class="line"><span class="cl">                ans = Math.max(ans, 
</span></span><span class="line"><span class="cl">                  minHeight(st, i, j) * (j - i + 1));
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return ans;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>不过，这种算法的时间复杂度仍然是 O(N2)。这里请你思考一下，还有没有更好的办法呢？</p>
<p>线段树</p>
<p>不妨尝试一下线段树。在处理区间信息的时候，线段树是一个非常有用的数据结构。下面我们来了解一下它的特点（可以先不管它长什么样）：</p>
<p>构建线段树，时间复杂度为 O(NlgN)；</p>
<p>查询阶段，时间复杂度为 O(lgN)；</p>
<p>空间复杂度为 O(4N)。</p>
<p>1. 线段树的思想</p>
<p>线段树的思想是用一棵平衡二叉树来表示一个数组区间上的信息：</p>
<p>根结点记录整个数组的信息；</p>
<p>左子树记录数组左半部分的信息；</p>
<p>右子树记录数组右半部分的信息。</p>
<p>【例 1】 假设给定的数组为 A[] = {1, 2, 3, 4}，需要记录的信息为区间里面的最小值。那么线段树构成如下：</p>
<p>那么查询的时候，就需要从根结点开始往下查。假设我们要基于这棵树查询区间 [1, 3] 的最小值信息。</p>
<p>第 1 步</p>
<p>首先，我们访问到根结点，可以发现 [0, 3] 区间与 [1, 3] 区间处于相交的情况，因此根结点的信息，对于我们要查询的结果是没有帮助的，所以需要将 [0, 3] 区间拆分为 [0, 1] 和 [2,3] 区间。</p>
<p>这里我们得到原则 1：</p>
<p>区间相交的时候，需要拆分树结点区间，然后分别看左右子树。</p>
<p>第 2 步</p>
<p>接下来，我们先看左子树，可以发现区间 [0, 1] 与区间 [1,3] 仍然是处于相交的状态。</p>
<p>因此还需要再次利用原则 1，分别观察它们的左右子树，如下图所示：</p>
<p>我们再接着遍历左右子树的时候，不难发现有以下两种情况:</p>
<p>Case 1. [0,0] 与区间 [1,3] 不相交，无视 [0,0] 区间上的信息；</p>
<p>Case 2. [1,1] 被区间 [1,3] 包含，需要保留这个区间上的信息。</p>
<p>由此，我们就得到原则 2 和原则 3。</p>
<p>原则 2：树结点区间与查询区间不相交时，无视树结点的信息。原则 3：树结点区间包含查询区间内部时，保留树结点的信息。</p>
<p>第 3 步</p>
<p>最后，看一下右边子树，我们发现 [2, 3] 树结点区间包含查询区间，因此，需要使用原则 3。</p>
<p>第 4 步</p>
<p>那么最终，我们只选取两个树结点的信息，如下图所示：</p>
<p>那么我们可以得到区间 [1,3] 上的最小值：</p>
<p>min([1,1] 区间上的最小值，[2,3] 区间上的最小值) = 2</p>
<p>经过上面的查询，这里我总结了 3 个原则。</p>
<p>原则 1：区间相交的时候，需要拆分树结点区间，然后分别看左右子树。原则 2：树结点区间与查询区间不相交时，无视树结点的信息。原则 3：树结点区间包含查询区间内部时，保留树结点的信息。</p>
<p>3 个原则分别代表区间之间的三种关系。你不需要去死记这个关系，只需要注意以下两点：</p>
<p>树中的结点的区间会不停地拆分；</p>
<p>查询区间一直固定不变。</p>
<p>2. 查询的本质</p>
<p>似乎让你单纯地记录这个查询流程太枯燥了，因此我们还需要更深入地去想一下线段树查询的本质，理解之后再去记忆就比较简单了。你可以这样想，给定一个二叉树，然后又给了一个查询区间，那么可以把查询的过程表示成 2 步。</p>
<p>第 1 步：裁剪</p>
<p>我们修剪一下这棵二叉树，让所有的叶子结点都在查询区间范围内。</p>
<p>需要注意的是，当区间 [2,3] 已经包含查询区间的时候，其子树上的结点就没有必要保留了。最终，我们将灰色的树结点都去掉，只保留：1） “包含”查询区间的叶结点；2）根结点到这些叶结点的路径。</p>
<p>第 2 步：收集叶子结点的信息</p>
<p>当裁剪完成之后，只需要再查看存留的二叉树的叶结点信息就可以了。</p>
<p>不过我们这里并不真正地去裁剪这棵二叉树，而是在遍历的时候，只提取出相应的信息（区间上的最小值）即可。</p>
<p>下面是一道关于二叉树的裁剪的练习题，希望你可以尝试解决一下。</p>
<p>练习题 1： 给你二叉搜索树的根结点 root ，同时给定最小边界 low 和最大边界 high。通过修剪二叉搜索树，使所有结点的值在 [low, high] 中。修剪树不应该改变保留在树中的元素的相对结构（如果没有被移除，原有的父代子代关系都应当保留）。可以证明，存在唯一的答案。所以结果应当返回修剪好的二叉搜索树的新的根结点。注意，根结点可能会根据给定的边界发生改变。</p>
<p>输入如下所示的二叉搜索树，并且 low = 1，high = 3。</p>
<p>输出：</p>
<p>代码：Java/C++/Python</p>
<p>完成练习题之后，你可以想一下，线段树查询与练习题 1 的裁剪有什么异同点？可以把你的思考写在留言区，我们一起讨论。</p>
<p>3. 线段树的更新</p>
<p>虽然这道题没有用到线段树的更新，但是面试的时候你可能会用到，所以我们还是要讲一下，</p>
<p>当我们要更新某个区间上的值时，需要将线段树路径上所有的点的区间信息都更新掉（更新的时候，采用后续遍历即可），如下图所示：</p>
<p>4. 线段树的存储</p>
<p>可能现在你准备开始用包含左右指针的二叉树写线段树了，不过还有更高效的方式——用数组表示一棵二叉树。</p>
<p>你可以回忆一下，“03 | 优先级队列：堆与优先级队列，筛选最优元素”学习堆的时候，我们已经用过一个数组来表示二叉树了，如下图所示：</p>
<p>这里也可以用数组来表示线段树，主要是因为：</p>
<p>数组具有更好的内存连续性；</p>
<p>内存连续性对 CPU 缓存更友好；</p>
<p>对 CPU 缓存更友好的数据结构能够运行得更快。</p>
<p>但是，通常我们学习的二叉树表示，会不停地 new TreeNode() 导致内存特别碎片化，因此对 CPU 缓存并不友好，导致运行得变慢。</p>
<p>当给定一个数组的时候，我们需要利用这个树创建一个线段树。根据线段树的定义：</p>
<p>根结点记录整个数组的信息；</p>
<p>左子树记录数组左半部分的信息；</p>
<p>右子树记录数组右半部分的信息。</p>
<p>这里我们可以肯定的是，根结点的信息，实际上需要依赖左子树的信息，以及右子树的信息才能够生成的。所以，这个二叉树的创建肯定是一个后序遍历。</p>
<p>然后再根据数组表示二叉树的方法，有以下 3 种：</p>
<p>i 结点的父结点 par = (i-1)/2；</p>
<p>i 结点的左子结点 2 * i + 1；</p>
<p>i 结点的右子结点 2 * i + 2。</p>
<p>5. 线段树的模板代码</p>
<p>此时，我们可以写出线段树的模板代码了（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 表示线段树的数组treeArray[]
</span></span><span class="line"><span class="cl">// 数组里面的值表示区间里面的最小值
</span></span><span class="line"><span class="cl">private int[] treeArray = null;
</span></span><span class="line"><span class="cl">private int leftNodePos(int rootPos) {
</span></span><span class="line"><span class="cl">    return (rootPos &lt;&lt; 1) + 1;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">private int rightNodePos(int rootPos) {
</span></span><span class="line"><span class="cl">    return (rootPos &lt;&lt; 1) + 2;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// treeArray[rootPos] 将会记录数组[start, end]
</span></span><span class="line"><span class="cl">// 这个区间上的信息。在本题中，信息为区间上的最小值
</span></span><span class="line"><span class="cl">private void buildTree(int rootPos, int[] A, int start, int end) {
</span></span><span class="line"><span class="cl">    // 范围为空
</span></span><span class="line"><span class="cl">    if (start &gt; end)
</span></span><span class="line"><span class="cl">        return;
</span></span><span class="line"><span class="cl">    // 如果区间：只有一个数
</span></span><span class="line"><span class="cl">    if (start == end) {
</span></span><span class="line"><span class="cl">        treeArray[rootPos] = A[start];
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        // 否则需要将区间分为两半
</span></span><span class="line"><span class="cl">        final int mid = start + ((end - start) &gt;&gt; 1);
</span></span><span class="line"><span class="cl">        buildTree(leftNodePos(rootPos), A, start, mid);
</span></span><span class="line"><span class="cl">        buildTree(rightNodePos(rootPos), A, mid + 1, end);
</span></span><span class="line"><span class="cl">        // 构建成功之后，需要利用左子树的信息和右子树的信息来
</span></span><span class="line"><span class="cl">        // 来更新 [start, end] rootNode 的信息
</span></span><span class="line"><span class="cl">        treeArray[rootPos] =
</span></span><span class="line"><span class="cl">            Math.min(treeArray[leftNodePos(rootPos)], 
</span></span><span class="line"><span class="cl">                     treeArray[rightNodePos(rootPos)]);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 查询区间[queryStart, queryEnd]这个区间上的最小值信息
</span></span><span class="line"><span class="cl"> *
</span></span><span class="line"><span class="cl"> * treeArray[rootPos]表示区间 [start, end]上的最小值。
</span></span><span class="line"><span class="cl"> * 可以把前面的三个参数看成
</span></span><span class="line"><span class="cl"> * class TreeNode {
</span></span><span class="line"><span class="cl"> *      int val;        &lt;-- arg: treeArray[rootPos];
</span></span><span class="line"><span class="cl"> *      int rangeStart; &lt;-- arg: start
</span></span><span class="line"><span class="cl"> *      int rangeEnd:   &lt;-- arg: end
</span></span><span class="line"><span class="cl"> *      TreeNode left;  &lt;-- leftNodePos(rootPos);
</span></span><span class="line"><span class="cl"> *      TreeNode right: &lt;-- rightNodePos(rootPos);
</span></span><span class="line"><span class="cl"> * }
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">private int queryTree(int rootPos, int start, int end,
</span></span><span class="line"><span class="cl">                      int queryStart, int queryEnd) {
</span></span><span class="line"><span class="cl">    // 无效区间，返回最大值
</span></span><span class="line"><span class="cl">    if (start &gt; end || queryStart &gt; queryEnd) {
</span></span><span class="line"><span class="cl">        return Integer.MAX_VALUE;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 原则1： 包含于查询区间内部
</span></span><span class="line"><span class="cl">    if (queryStart &lt;= start &amp;&amp; end &lt;= queryEnd) {
</span></span><span class="line"><span class="cl">        return treeArray[rootPos];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 原则2：不相交时，放弃区间信息，这里我们返回最大值
</span></span><span class="line"><span class="cl">    if (end &lt; queryStart || queryEnd &lt; start) {
</span></span><span class="line"><span class="cl">        return Integer.MAX_VALUE;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 原则3：当相交的时候，需要将[start, end]进行拆分
</span></span><span class="line"><span class="cl">    // 由于我们建树的时候，都是平分，所以这里将区间也进行平分
</span></span><span class="line"><span class="cl">    final int mid = start + ((end - start) &gt;&gt; 1);
</span></span><span class="line"><span class="cl">    return Math.min(queryTree(leftNodePos(rootPos),
</span></span><span class="line"><span class="cl">                               start, mid, queryStart, queryEnd),
</span></span><span class="line"><span class="cl">                    queryTree(rightNodePos(rootPos),
</span></span><span class="line"><span class="cl">                               mid + 1, end, queryStart, queryEnd));
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// 当我们要更新数组中A[inx] = value的时候
</span></span><span class="line"><span class="cl">// 线段树中存储的区间的信息，也是需要更新的
</span></span><span class="line"><span class="cl">void updateTree(int rootPos, int start, int end,
</span></span><span class="line"><span class="cl">                int idx, int value) {
</span></span><span class="line"><span class="cl">    // 如果树中的结点不在我们的更新路径上
</span></span><span class="line"><span class="cl">    if (start &gt; end || idx &lt; start || idx &gt; end) {
</span></span><span class="line"><span class="cl">        return;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 如果已经找到了叶子结点
</span></span><span class="line"><span class="cl">    if (start == idx &amp;&amp; idx == end) {
</span></span><span class="line"><span class="cl">        treeArray[rootPos] = value;
</span></span><span class="line"><span class="cl">        return;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 这里后序遍历
</span></span><span class="line"><span class="cl">    // 如果是非叶子结点，那么
</span></span><span class="line"><span class="cl">    // 先更新左右子结点，再更新根结点
</span></span><span class="line"><span class="cl">    final int mid = start + ((end - start) &gt;&gt; 1);
</span></span><span class="line"><span class="cl">    // 更新左子树
</span></span><span class="line"><span class="cl">    updateTree(leftNodePos(rootPos), start, mid, idx, value);
</span></span><span class="line"><span class="cl">    // 更新右子树
</span></span><span class="line"><span class="cl">    updateTree(rightNodePos(rootPos), mid + 1, end, idx, value);
</span></span><span class="line"><span class="cl">    // 更新根结点
</span></span><span class="line"><span class="cl">    treeArray[rootPos] =
</span></span><span class="line"><span class="cl">        Math.min(treeArray[leftNodePos(rootPos)],
</span></span><span class="line"><span class="cl">                 treeArray[rightNodePos(rootPos)]);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>那么我们通过使用线段树，就写出求解的代码了，如下所示（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    // ... 并查集的模板代码....
</span></span><span class="line"><span class="cl">   public
</span></span><span class="line"><span class="cl">    int largestRectangleArea(int[] heights) {
</span></span><span class="line"><span class="cl">        final int N = heights == null ? 0 : heights.length;
</span></span><span class="line"><span class="cl">        treeArray = new int[N &lt;&lt; 2];
</span></span><span class="line"><span class="cl">        buildTree(0, heights, 0, N - 1);
</span></span><span class="line"><span class="cl">        int ans = 0;
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">            for (int j = i; j &lt; N; j++) {
</span></span><span class="line"><span class="cl">                // rootPos = 0表示根结点
</span></span><span class="line"><span class="cl">                // [0, N-1]表示根结点代表：[0, N-1]这个区间上的最小值信息
</span></span><span class="line"><span class="cl">                final int minHeight = queryTree(0, 0, N - 1, i, j);
</span></span><span class="line"><span class="cl">                ans = Math.max(ans, minHeight * (j - i + 1));
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return ans;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>接下来，我们分析一下时间复杂度，一共会有 N x N 个区间需要查询，每次查询的时间复杂度为 O(lgN)，所以时间复杂度为 O(N2 lgN)，空间复杂度为 O(N)。</p>
<p>到这里，我们利用一些区间信息查找常用的手段进行了优化：</p>
<p>使用 ST 算法将时间复杂度优化到 O(N2)；</p>
<p>使用线段树将时间复杂度优化到O(N2 lgN)。</p>
<p>可是，这两种算法都还是会超时，接下来应该怎么办呢？</p>
<p>其实，真正面试的时候，你应该注意，一开始找到的题目特点是基于区间查询的方式，实际上就把优化的上限限定死了。一共有 N x N 个区间要查，无论查多快，时间复杂度都不会比 O(N x N) 更好。</p>
<p>这就意味着，一开始，我们破题的大方向就是错的。当然，在这里我是发扬了要把一个题的特点深挖到底的精神，在练习的时候可以这么操作。如果是在面试中，还没有走到使用 ST 算法，线段树，就应该尝试寻找题目的其他特点了。</p>
<p>特点 2：选与不选</p>
<p>首先，我们假设问题是有一个最优解的，而这个最优解肯定是原始数组的一个连续子数组。那么，对于数组中的元素而言，就存在 2 种可能：</p>
<p>被最优解选中</p>
<p>没有被最优解选中</p>
<p>但是，如果我们去讨论每个元素的选/不选，时间复杂度就会瞬间爆炸到 O(2N)。但是你先别着急放弃这个特点，我们决心把这个特点死磕到底。</p>
<p>接着看题目，由于最大矩形的制约因素是被选中区域的最小值制约的。那么当给定一个区域 [start, end] 的时候，对于这个区间里面的最小值而言，只有两种可能。</p>
<p>第一种可能：被最优解选中，此时解为 area = minHeight * (end - start + 1)。</p>
<p>第二种可能：没有被最优解选中，那么可以利用最小值，将区域切分为两半：</p>
<p>计算左边区域的最大矩形的面积；</p>
<p>计算右边区域的最大矩形的面积。</p>
<p>然后再取这两种可能的最大矩形面积。</p>
<p>我们发现，利用区间里面的最小值（选/不选），可以将区间切分为更小的区间。</p>
<p>此时，我们就可以使用分治算法了。</p>
<p>分治算法 1</p>
<p>根据前面的思路，我们可以写出分治的代码（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    // 这里得到一个区域里面的最大矩形面积
</span></span><span class="line"><span class="cl">    // 这个区间域为[b, e)
</span></span><span class="line"><span class="cl">    // 注意e是取不到的
</span></span><span class="line"><span class="cl">    private int getRangeMaxArea(int[] heights, int b, int e) {
</span></span><span class="line"><span class="cl">        // 如果为空区间
</span></span><span class="line"><span class="cl">        if (b &gt;= e) {
</span></span><span class="line"><span class="cl">            return 0;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 如果区间中只有一个元素
</span></span><span class="line"><span class="cl">        if (b + 1 == e) {
</span></span><span class="line"><span class="cl">            return heights[b];
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 如果有多个元素。那么找到范围里面的最小值
</span></span><span class="line"><span class="cl">        // 如果有多个最小值，那么我们就找离中心最近的那个，尽量把区域进行等分
</span></span><span class="line"><span class="cl">        int mid = b + ((e-b) &gt;&gt; 1);
</span></span><span class="line"><span class="cl">        int minIndex = b;
</span></span><span class="line"><span class="cl">        for (int i = b + 1; i &lt; e; i++) {
</span></span><span class="line"><span class="cl">            if (heights[i] &lt; heights[minIndex]) {
</span></span><span class="line"><span class="cl">                minIndex = i;
</span></span><span class="line"><span class="cl">            } else if (heights[i] == heights[minIndex]) {
</span></span><span class="line"><span class="cl">                // 多个最小值，那么谁离mid更近，我们用谁
</span></span><span class="line"><span class="cl">                if (Math.abs(mid - i) &lt; Math.abs(mid - minIndex)) {
</span></span><span class="line"><span class="cl">                    minIndex = i;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 在使用 最小值 情况下的面积
</span></span><span class="line"><span class="cl">        int useMinIndexArea = heights[minIndex] * (e - b);
</span></span><span class="line"><span class="cl">        // 不用 minIndex 那么就会把区间分为两部分
</span></span><span class="line"><span class="cl">        int leftMaxArea = getRangeMaxArea(heights, b, minIndex);
</span></span><span class="line"><span class="cl">        int rightMaxArea = getRangeMaxArea(heights, minIndex + 1, e);
</span></span><span class="line"><span class="cl">        return Math.max(useMinIndexArea,
</span></span><span class="line"><span class="cl">                         Math.max(leftMaxArea, rightMaxArea));
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public int largestRectangleArea(int[] heights) {
</span></span><span class="line"><span class="cl">        final int N = heights == null ? 0 : heights.length;
</span></span><span class="line"><span class="cl">        return getRangeMaxArea(heights, 0, N);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：正常情况下，时间复杂度为 O(NlgN)，最差情况下，比如数组是一个已排序的数组，并且里面元素都不相同，那么时间复杂度会变为 O(N2)，空间复杂度为 O(lgN)。</p>
<p>【小结】这里你可以回想一下我们在“08 | 排序：如何利用合并与快排的小技巧，解决算法难题？”学习的排序技巧，原来我们学习快速排序的时候，会用“三路切分”将区间分为三部分。而在这里，我们是用最小值将区间切分成两半。</p>
<p>那么有没有办法可以进一步优化呢？我们可以看到，分治的核心代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int mid = b + ((e - b) &gt;&gt; 1);
</span></span><span class="line"><span class="cl">int minIndex = b;
</span></span><span class="line"><span class="cl">for (int i = b + 1; i &lt; e; i++) {
</span></span><span class="line"><span class="cl">  if (heights[i] &lt; heights[minIndex]) {
</span></span><span class="line"><span class="cl">    minIndex = i;
</span></span><span class="line"><span class="cl">  } else if (heights[i] == heights[minIndex]) {
</span></span><span class="line"><span class="cl">    // 多个最小值，那么谁离mid更近，我们用谁
</span></span><span class="line"><span class="cl">    if (Math.abs(mid - i) &lt; Math.abs(mid - minIndex)) {
</span></span><span class="line"><span class="cl">      minIndex = i;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码本质就是在搜索一个区间里面的最小值。如果你还有印象，寻找一个区间的信息，我们可以得到如下信息：</p>
<p>ST 算法预处理时间复杂度 O(NlgN)，查询区间最小值 O(1)，空间复杂度 O(NlgN)；</p>
<p>线段树建树 O(NlgN)，查询区间最小值 O(lgN)，空间复杂度 O(N)。</p>
<p>下面我再给你留两个练习题，请你分别用这两个算法再优化一下分治算法。如果有什么疑问，可以写在留言区，我会逐一为你解答。</p>
<p>练习题 2：请使用 ST 算法优化分治算法。并且分析优化之后的时间/空间复杂度。</p>
<p>代码：Java/C++/Python</p>
<p>练习题 3：请使用线段树算法优化我们的分治算法，并且分析优化之后时间/空间复杂度。</p>
<p>代码：Java/C++/Python</p>
<p>分治算法 2</p>
<p>在前面的分治算法中，我们在切分数组的时候，采用了一个区域里面的最小值进行切分。在最差情况下（数组元素不同且有序），会得到 O(N2) 时间复杂度。</p>
<p>不知道你有没有想起我们切分数组的算法。</p>
<p>合并排序：切分的时候，直接从数组的中间开始切分。时间复杂度最差也为 O(NlgN)。</p>
<p>快速排序：切分的时候，采用数组中的随机值进行切分。时间复杂度最差也为O(N2)。</p>
<p>于是，我们可以得到一个结论。</p>
<p>我们在切分数组的时候：如果采用值进行切分，那么最差情况下的时间复杂度会掉到 O(N2)；如果采用中间的下标进行切分，那么时间复杂度为 O(NlgN)。</p>
<p>就这道题而言，如果我们想把分治算法变成 O(NlgN)，应该怎么办？相信你已经想到了方向，那就是切分的时候，采用下标进行切分。</p>
<p>到这里，我们已经可以写出伪代码了（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int getMaxRangeArea(int[] heights, int b, int e) {
</span></span><span class="line"><span class="cl">    if (b &gt;= e) {
</span></span><span class="line"><span class="cl">        return 0;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 如果只有一个元素
</span></span><span class="line"><span class="cl">    if (b + 1 == e) {
</span></span><span class="line"><span class="cl">        return heights[b];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 用数组中间的那个元素将数组分为两半
</span></span><span class="line"><span class="cl">    final int mid = b + ((e - b) &gt;&gt; 1);
</span></span><span class="line"><span class="cl">    // 不包含中间这个元素的时候，那么就只能在这个元素的左边和右边寻找了
</span></span><span class="line"><span class="cl">    int leftMaxArea = getMaxRangeArea(heights, b, mid);
</span></span><span class="line"><span class="cl">    int rightMaxArea = getMaxRangeArea(heights, mid + 1, e);
</span></span><span class="line"><span class="cl">    // 如果一定要包含heights[mid]
</span></span><span class="line"><span class="cl">    // 求出containsMidIndexArea; &lt;-- 那么这里怎么求?
</span></span><span class="line"><span class="cl">    return Math.max(containsMidIndexArea,
</span></span><span class="line"><span class="cl">                    Math.max(leftMaxArea, rightMaxArea));
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，我们看一下问题的核心部分，当包含 heights[mid] 的时候，应该如何计算？共有两种情况。</p>
<p>Case 1：其他元素都比 heights[mid] 大，heights[mid] 成了短板。</p>
<p>Case 2：存在比 heights[mid] 小的元素，heights[mid] 只是参与一下。</p>
<p>关于这两种情况的处理， 核心代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int minHeight = heights[mid];
</span></span><span class="line"><span class="cl">int containsMidIndexArea = minHeight;
</span></span><span class="line"><span class="cl">int left = m - 1, right = m + 1;
</span></span><span class="line"><span class="cl">while (left &gt;= b || right &lt; e) {
</span></span><span class="line"><span class="cl">    if (right &gt;= e || left &gt;= b &amp;&amp; heights[left] &gt;= heights[right]) {
</span></span><span class="line"><span class="cl">        minHeight = min(minHeight, heights[left]);
</span></span><span class="line"><span class="cl">        left--;
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        minHeight = min(minHeight, heights[right]);
</span></span><span class="line"><span class="cl">        right++;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    final int tmp = minHeight * (right - left - 1);
</span></span><span class="line"><span class="cl">    containsMidIndexArea = max(containsMidIndexArea, tmp);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么，到此为止，我们就可以写出完全是 O(NlgN) 的代码了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">  private int getMaxRangeArea(int[] heights, int b, int e) {
</span></span><span class="line"><span class="cl">    if (b &gt;= e) {
</span></span><span class="line"><span class="cl">      return 0;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 如果只有一个元素
</span></span><span class="line"><span class="cl">    if (b + 1 == e) {
</span></span><span class="line"><span class="cl">      return heights[b];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 用数组中间的那个元素将数组分为两半
</span></span><span class="line"><span class="cl">    final int mid = b + ((e - b) &gt;&gt; 1);
</span></span><span class="line"><span class="cl">    // 不包含中间这个元素的时候，那么就只能在这个元素的左边和右边寻找了
</span></span><span class="line"><span class="cl">    int leftMaxArea = getMaxRangeArea(heights, b, mid);
</span></span><span class="line"><span class="cl">    int rightMaxArea = getMaxRangeArea(heights, mid + 1, e);
</span></span><span class="line"><span class="cl">    // 如果一定要包含heights[mid]
</span></span><span class="line"><span class="cl">    // 那么就有两种情况。
</span></span><span class="line"><span class="cl">    int minHeight = heights[mid];
</span></span><span class="line"><span class="cl">    int containsMidIndexArea = minHeight;
</span></span><span class="line"><span class="cl">    int left = mid - 1, right = mid + 1;
</span></span><span class="line"><span class="cl">    while (left &gt;= b || right &lt; e) {
</span></span><span class="line"><span class="cl">      if (right &gt;= e || 
</span></span><span class="line"><span class="cl">          left &gt;= b &amp;&amp; heights[left] &gt;= heights[right]) {
</span></span><span class="line"><span class="cl">        minHeight = Math.min(minHeight, heights[left]);
</span></span><span class="line"><span class="cl">        left--;
</span></span><span class="line"><span class="cl">      } else {
</span></span><span class="line"><span class="cl">        minHeight = Math.min(minHeight, heights[right]);
</span></span><span class="line"><span class="cl">        right++;
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      final int tmp = minHeight * (right - left - 1);
</span></span><span class="line"><span class="cl">      containsMidIndexArea = Math.max(containsMidIndexArea, tmp);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return Math.max(containsMidIndexArea,
</span></span><span class="line"><span class="cl">                    Math.max(leftMaxArea, rightMaxArea));
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  public int largestRectangleArea(int[] heights) {
</span></span><span class="line"><span class="cl">    final int N = heights == null ? 0 : heights.length;
</span></span><span class="line"><span class="cl">    return getMaxRangeArea(heights, 0, N);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度 O(NlgN)，空间复杂度 O(1)（不算栈空间）。</p>
<p>【小结】在写这个算法的时候，我们需要注意两个地方。</p>
<p>其一：在处理 heights[mid] 的时候，将包含关系分为以下 2 种：</p>
<p>包含 heights[mid]，并且找到的区域内的元素都比 heights[mid] 大；</p>
<p>不包含 heights[mid]，这种情况需要递归处理 [b, mid) 和 [mid + 1, e)。</p>
<p>容易出错的地方在于，包含 heights[mid] 的时候，实际上有两种情况的（前面我们提到的Case 1 和 Case 2）。这里只处理了 Case 1，但是没有处理 Case 2。</p>
<p>其二：采用这种分治算法，包含 heights[mid] 的时候，采用了双指针的做法，left 和 right 分别向两边推进。但是你需要格外注意，推进的时候，哪边大，则移动哪边的指针。</p>
<p>你能想想为什么吗？请你完成下面的练习题 4，期待看到你理解与思考。</p>
<p>练习题 4：这里的分治算法在往左右两边推进的时候，为什么哪边大就往哪边移动呢？你能再想一下，这与“11 | 贪心：这种思想，没有模板，如何才能掌握它？”介绍的贪心算法的例 1 有什么异同吗？</p>
<p>特点 3：左右两边较小的数</p>
<p>构成一个矩形的面积的时候，有宽和高。无论是特点 1，还是特点 2，它们都有一个共同点：先固定矩形的宽，再去选择高。</p>
<p>有没有可能反过来呢？我们先去固定高度，再去决定宽度。当我们选择数组中的元素 heights[i] 作为矩形的高度时。寻找宽度需要满足以下两个条件：</p>
<p>i 元素必须要在这个范围内；</p>
<p>这个范围内的元素都必须要大于等于 heights[i]。</p>
<p>那么我们就可以称 heights[i] 决定了这个最大范围的面积。</p>
<p>小于我的位置</p>
<p>那么这也就意味着，我们需要解决如下的问题。</p>
<p>数组中元素右边离我最近且比我小的元素的位置</p>
<p>代码：Java/C++/Python</p>
<p>数组中元素左边离我最近且比我小的元素的位置</p>
<p>代码：Java/C++/Python</p>
<p>实际上，这两个问题，我们已经在“01 | 栈：从简单栈到单调栈，解决经典栈问题”介绍单调栈时学过了。那么你现在解决起来，应该是很容易了吧。本讲不再过多叙述，直接给出如下代码（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class LeftSmall
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  // 当我们要找左边比我小的元素的时候，需要用递增栈
</span></span><span class="line"><span class="cl">  public static int[] findLeftSmall(int[] A)
</span></span><span class="line"><span class="cl">  {
</span></span><span class="line"><span class="cl">    if (A == null || A.length == 0) {
</span></span><span class="line"><span class="cl">      return new int[0];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 结果数组
</span></span><span class="line"><span class="cl">    int[] ans = new int[A.length];
</span></span><span class="line"><span class="cl">    // 注意，栈中的元素记录的是下标
</span></span><span class="line"><span class="cl">    Stack&lt;Integer&gt; t = new Stack&lt;&gt;();
</span></span><span class="line"><span class="cl">    // 注意这里的遍历方向发生了变化，因为我们是要找到左边比我小的元素的位置
</span></span><span class="line"><span class="cl">    for (int i = A.length - 1; i &gt;= 0; i--) {
</span></span><span class="line"><span class="cl">      final int x = A[i];
</span></span><span class="line"><span class="cl">      // 每个元素都遍历栈中的元素完成消除动作
</span></span><span class="line"><span class="cl">      // 这里是递减栈
</span></span><span class="line"><span class="cl">      // 如果发现进来的元素x与栈中元素相比
</span></span><span class="line"><span class="cl">      // 如果大于栈中的元素，那么要把栈中的元素弹出去
</span></span><span class="line"><span class="cl">      while (!t.empty() &amp;&amp; A[t.peek()] &gt; x) {
</span></span><span class="line"><span class="cl">        // 消除的时候，记录一下被谁消除了
</span></span><span class="line"><span class="cl">        ans[t.peek()] = i;
</span></span><span class="line"><span class="cl">        // 消除时候，值更大的需要从栈中消失
</span></span><span class="line"><span class="cl">        t.pop();
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      // 剩下的入栈
</span></span><span class="line"><span class="cl">      t.push(i);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。
</span></span><span class="line"><span class="cl">    while (!t.empty()) {
</span></span><span class="line"><span class="cl">      ans[t.peek()] = -1;
</span></span><span class="line"><span class="cl">      t.pop();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return ans;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class RightSmall
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  public static int[] findRightSmall(int[] A)
</span></span><span class="line"><span class="cl">  {
</span></span><span class="line"><span class="cl">    // 结果数组
</span></span><span class="line"><span class="cl">    int[] ans = new int[A.length];
</span></span><span class="line"><span class="cl">    // 注意，栈中的元素记录的是下标
</span></span><span class="line"><span class="cl">    Stack&lt;Integer&gt; t = new Stack&lt;&gt;();
</span></span><span class="line"><span class="cl">    for (int i = 0; i &lt; A.length; i++) {
</span></span><span class="line"><span class="cl">      final int x = A[i];
</span></span><span class="line"><span class="cl">      // 每个元素都向左遍历栈中的元素完成消除动作
</span></span><span class="line"><span class="cl">      while (!t.empty() &amp;&amp; A[t.peek()] &gt; x) {
</span></span><span class="line"><span class="cl">        // 消除的时候，记录一下被谁消除了
</span></span><span class="line"><span class="cl">        ans[t.peek()] = i;
</span></span><span class="line"><span class="cl">        // 消除时候，值更大的需要从栈中消失
</span></span><span class="line"><span class="cl">        t.pop();
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      // 剩下的入栈
</span></span><span class="line"><span class="cl">      t.push(i);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。
</span></span><span class="line"><span class="cl">    while (!t.empty()) {
</span></span><span class="line"><span class="cl">      ans[t.peek()] = -1;
</span></span><span class="line"><span class="cl">      t.pop();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return ans;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class Solution
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  public int largestRectangleArea(int[] A)
</span></span><span class="line"><span class="cl">  {
</span></span><span class="line"><span class="cl">    final int N = A == null ? 0 : A.length;
</span></span><span class="line"><span class="cl">    int[] leftSmall = LeftSmall.findLeftSmall(A);
</span></span><span class="line"><span class="cl">    int[] rightSmall = RightSmall.findRightSmall(A);
</span></span><span class="line"><span class="cl">    int ans = 0;
</span></span><span class="line"><span class="cl">    for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">      final int height = A[i];
</span></span><span class="line"><span class="cl">      // 左边比我小的位置
</span></span><span class="line"><span class="cl">      // 右边比我小的位置
</span></span><span class="line"><span class="cl">      final int leftPos = leftSmall[i];
</span></span><span class="line"><span class="cl">      final int rightPos = rightSmall[i] == -1 ? N : rightSmall[i];
</span></span><span class="line"><span class="cl">      // 现在我们确定区间(leftPos, rightPos)
</span></span><span class="line"><span class="cl">      // 注意两边都是开区间。在这个区间里面，所有的数肯定都是 &gt;= A[i]的。
</span></span><span class="line"><span class="cl">      // 那么底部的宽度就是
</span></span><span class="line"><span class="cl">      final int width = rightPos - leftPos - 1;
</span></span><span class="line"><span class="cl">      final int area = height * width;
</span></span><span class="line"><span class="cl">      ans = Math.max(ans, area);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return ans;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/python</p>
<p>复杂度分析：时间复杂度 O(N)，空间复杂度 O(N)。</p>
<p>【小结】如果你看到这里，突然感觉代码都很神奇，充满了魔法，就是时候温习一下“01 | 栈：从简单栈到单调栈，解决经典栈问题”中单调栈的“魔法技能”部分了。通过复习有时候也能唤醒你算法的巨龙哦。</p>
<p>单调栈的性质</p>
<p>我们来看递增栈（不是严格递增），栈中元素存放的是数组 A[] 的下标。如下图所示：</p>
<p>说明：在这个图中，左边是栈底，右边是栈增长的方向。栈中不同的矩形表示相应 A[] 数组中下标位置相应值的大小。那么，首先基于递增栈的定义，我们可以知道它有如下特性：</p>
<p>栈中存放的下标，如果 i 在 j 之前入栈，那么必然满足 A[i] &lt;= A[j]。</p>
<p>“削”的定义：当需要把一个更小的元素入栈的时候，这个更小的元素就会把栈中大的元素出栈，直到栈为空，或者栈顶元素更小，再入栈。</p>
<p>例如：当栈中已经有 &lt;i, j&gt;，现在需要将 A[k] 入栈，但是 A[i] &lt; A[k] &amp;&amp; A[k] &lt; A[j]。那么 A[k] 就会把 A[j] 削出栈。如下图所示：</p>
<p>根据这个特性，我们肯定可以得到 A[i] &lt;= A[k] &lt; A[j]。基于这个特性，还可以得出 3 个有用的性质。</p>
<p>性质 1</p>
<p>如下图所示：</p>
<p>假设 i, j 这两个下标在单调栈中相邻，那么在原数组 A[] 中， (i, j) 这个开区间里面的数都大于 A[j]。</p>
<p>这里我们采用反证法来证明这个性质。首先给出反证法的条件：</p>
<p>单调栈中连续存放着下标 i, j（但并不代表下标 i,j 是连续的，也就是说 i + 1 不一定等于j）；</p>
<p>假设 A[] 数组在 (i, j) 范围中存在 1 个下标 k，即 i &lt; k &lt; j，并且使得 A[k] &lt; A[j] 成立。</p>
<p>证明：如果 A[k] &lt; A[j]，那么将 A[k] 放入单调队列之后，由于 (k, j) 范围里面的数组都大于 A[j]。那么当 A[j] 入栈之后，应该位于 A[k] 之后。于是栈中会形成 &lt;i, k, j&gt; 三个数。但实际上栈中只存放了 &lt;i, j&gt; 两个数，并且 i &lt; k &lt; j，这里存在矛盾。所以在 (i, j) 这个开区间范围里面的数，都必须大于 A[j]。</p>
<p>之所以这些大于 A[j] 的元素没有出现在栈中，是因为这些元素在 A[j] 入栈时可能都在栈中，但是立马都被 A[j] 削出栈了。</p>
<p>性质 2</p>
<p>然后，基于性质 1，当单调栈中有 &lt;i, j, k&gt;3 个原数组的下标。那么可以得到性质 2：</p>
<p>当单调栈中有 &lt;i, j, k&gt; 3 个数组下标时，其中 (i, k] 这个范围里面的元素，肯定 &gt;= A[j]。</p>
<p>证明如下：</p>
<p>根据性质 1，可以得到 (i, j) 里面的元素都大于 A[j]，即 A[(i,j)] &gt; A[j]；</p>
<p>根据性质 1，还可以得到 (j, k) 里面的元素都大于 A[k]，即 A[(j,k)] &gt; A[k]；</p>
<p>由于 j 在 k 之前入栈，所以可以肯定 A[j] &lt;= A[k]。</p>
<p>综上，A[(j,k)] &gt; A[k] &gt;= A[j]，所以可以得出结论 (i, k] 里面的元素肯定 &gt;= A[j]。</p>
<p>性质 3</p>
<p>现在我们遇到下面这种场景。在单调栈中，已经存放了原数组的两个下标 &lt;i, j&gt;，其中 j 是栈顶元素，现在要把一个更小的值 A[k] 对应的下标 k 入栈。如下图所示：</p>
<p>此时，根据单调栈的性质，需要将 A[j] 弹出栈（有可能 A[k] 已经削除了栈中的很多元素，现在轮到削除 A[j] 了）。那么此时我们可以得到一个性质 3：</p>
<p>原数组 (j, k) 范围里面的数，都大于 A[j]。</p>
<p>同样，我们可以采用反证法。先给出反证法的条件：</p>
<p>当 k 要入栈时，单调栈中连续存放着下标 i, j（但并不代表下标 i,j 是连续的，也就是说 i + 1 不一定等于 j）；</p>
<p>假设范围 (j, k) 中存在1 个下标 x；</p>
<p>使得 A[x] &lt;= A[j] 成立。</p>
<p>如果有 j &lt; x &lt; k，并且 A[x] &lt;= A[j] 成立，那么单调栈中现在必然存在 A[x] 元素。但是现在栈中存放着 A[j]，并且没有 A[x] 元素。所以得出矛盾。所以性质 3 成立。</p>
<p>其实性质 2 和性质 3 有个比较好记的地方。如果你将范围 (i,j), (j, k) 看成两个“空档”。那么 A[j] 就好像总是挑着两座大山，如下图所示：</p>
<p>至于 A[j] 和 A[k] 值的大小，当然是比较容易判断的：</p>
<p>如果栈中 j 在 k 之前（且相邻），那么 A[j] &lt; A[k]；</p>
<p>如果 A[k] 要削 A[j] 出栈，那么 A[k] &lt; A[j]。</p>
<p>到这里，我们就可以写出代码了（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public int largestRectangleArea(int[] A) {
</span></span><span class="line"><span class="cl">        final int N = A == null ? 0 : A.length;
</span></span><span class="line"><span class="cl">        // 虽然可以用Stack&lt;Integer&gt;，但是这里我们为了更快地操作，我们用
</span></span><span class="line"><span class="cl">        // 数组模拟栈来运行，因为我们知道最多存放的内容实际上就是N个
</span></span><span class="line"><span class="cl">        int top = 0;
</span></span><span class="line"><span class="cl">        // s[top-1]表示栈顶元素
</span></span><span class="line"><span class="cl">        int[] s = new int[N];
</span></span><span class="line"><span class="cl">        int ans = 0;
</span></span><span class="line"><span class="cl">        // 注意，这里我们取到了i == N
</span></span><span class="line"><span class="cl">        // 按理说，不应该取到i == N的。但是这时候，主要是为了处理这种数组
</span></span><span class="line"><span class="cl">        // A = [1, 2, 3]
</span></span><span class="line"><span class="cl">        // 没有任何元素会出栈。
</span></span><span class="line"><span class="cl">        // 那么最后我们用一个0元素，把所有的元素都削出栈。
</span></span><span class="line"><span class="cl">        // 这样代码就可以统一处理掉。
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt;= N; i++) {
</span></span><span class="line"><span class="cl">            // 注意：当i == N的时候，x = -1;
</span></span><span class="line"><span class="cl">            // 比数组中的元素都要小。
</span></span><span class="line"><span class="cl">            final int x = i == N ? -1 : A[i];
</span></span><span class="line"><span class="cl">            while (top &gt; 0 &amp;&amp; A[s[top - 1]] &gt; x) {
</span></span><span class="line"><span class="cl">                // 计算以A[s[top]]的元素的高度的矩形。
</span></span><span class="line"><span class="cl">                final int height = A[s[--top]];
</span></span><span class="line"><span class="cl">                // i元素要将index = s[top-1]的元素出栈。
</span></span><span class="line"><span class="cl">                // 那么根据性质2/3：
</span></span><span class="line"><span class="cl">                // 此时A[s[top-1] .... i) 这个区间里面的元素都是
</span></span><span class="line"><span class="cl">                // 大于A[s[top-1]]的
</span></span><span class="line"><span class="cl">                final int rightPos = i;
</span></span><span class="line"><span class="cl">                // 这里需要使用性质1.
</span></span><span class="line"><span class="cl">                // 注意：当栈中一个元素都没有的时候，要取-1
</span></span><span class="line"><span class="cl">                final int leftPos = top &gt; 0 ? s[top - 1] : -1;
</span></span><span class="line"><span class="cl">                final int width = rightPos - leftPos - 1;
</span></span><span class="line"><span class="cl">                final int area = height * width;
</span></span><span class="line"><span class="cl">                ans = Math.max(ans, area);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            s[top++] = i;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return ans;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度 O(N)，空间复杂度 O(N)。</p>
<p>DP</p>
<p>前面我们使用单调栈来求解一个左右两边第一个较小的元素的位置。现在我们重新来考虑一下这个问题。</p>
<p>题目：数组中左边离我最近且比我小的元素的位置。</p>
<p>我们在考虑的时候，直接考虑最后一个元素的情况（不知道你是否还记得我们DP 的最后一步），也就是求解 A[k+1] 左边第一个比较小元素的位置。假设 [0, k] 这个范围元素的解都放在 dp[] 数组里面。如果我们要求 A[k+1] 左边第一个比较小元素的位置。通常的写法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int pre = k; pre &gt;= 0; pre--) {
</span></span><span class="line"><span class="cl">  if (A[pre] &lt; A[k+1]) {
</span></span><span class="line"><span class="cl">    dp[k+1] = pre;
</span></span><span class="line"><span class="cl">    break;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是这么写，时间复杂度就变成 O(N)。如果要求解“数组中元素左边离我最近且比我小的元素的位置”，问题就秒变 O(N2)。而我们知道，如果使用单调栈，是可以在 O(N) 时间复杂度解决的。</p>
<p>我们立马会发现，求解 A[k+1] 的时候，还没有用上 dp[] 数组。那么我们可以这样操作：</p>
<p>首先 A[k] 与 A[k+1] 比较，如果 A[k] &gt;= A[k+1]，那么直接跳到下标 j = dp[k] 这个位置；</p>
<p>重复上述步骤，直到找到一个元素比 A[k+1] 小，或者没有任何元素为止。</p>
<p>通过这样的方式，我们可以快速跳过一些元素，使时间复杂度变为 O(lgN)。于是代码可以长成这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int pre = k + 1 - 1;
</span></span><span class="line"><span class="cl">while (pre != -1 &amp;&amp; A[pre] &gt;= A[k+1]) {
</span></span><span class="line"><span class="cl">    pre = dp[pre];
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">dp[k+1] = pre;
</span></span></code></pre></td></tr></table>
</div>
</div><p>联想 1：你可以想一下，这和 KMP 算法有没有什么相似的地方？联想 2：你可以再想一下，这和我们学过的并查集有没有什么相似的地方？</p>
<p>那么我们的求解最大矩形的代码，就可以利用这个思想，写出代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Solution {
</span></span><span class="line"><span class="cl">    public int largestRectangleArea(int [] A) {
</span></span><span class="line"><span class="cl">        final int N = A == null ? 0 : A.length;
</span></span><span class="line"><span class="cl">        if (N == 0) {
</span></span><span class="line"><span class="cl">            return 0;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        int[] lm = new int[N]; // left min的位置
</span></span><span class="line"><span class="cl">        int[] rm = new int[N]; // right min的位置
</span></span><span class="line"><span class="cl">        lm[0] = -1;
</span></span><span class="line"><span class="cl">        for (int i = 1; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">            int idx = i - 1;
</span></span><span class="line"><span class="cl">            while (idx != -1 &amp;&amp; A[idx] &gt;= A[i]) {
</span></span><span class="line"><span class="cl">                idx = lm[idx];
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            lm[i] = idx;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        rm[N - 1] = N;
</span></span><span class="line"><span class="cl">        for (int i = N - 2; i &gt;= 0; i--) {
</span></span><span class="line"><span class="cl">            int idx = i + 1;
</span></span><span class="line"><span class="cl">            while (idx != N &amp;&amp; A[idx] &gt;= A[i]) {
</span></span><span class="line"><span class="cl">                idx = rm[idx];
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            rm[i] = idx;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        int ans = 0;
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; N; i++) {
</span></span><span class="line"><span class="cl">            ans = Math.max(ans, A[i] * (rm[i] - lm[i] - 1));
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return ans;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度 O(NlgN)，时间复杂度可以类比并查集的跳跃方式，空间复杂度 O(N)。</p>
<p>总结</p>
<p>在这一讲里面，我们采用的总方针是：</p>
<p>深挖题目的特点；</p>
<p>对标数据结构/算法特点；</p>
<p>将特点进行结合，创造出新的解法。</p>
<p>我们再将本讲介绍的题目进行一个总结和归纳，如下图所示：</p>
<p>思考题</p>
<p>这里我再给你留了一下思考题：给定一个仅包含
0
和
1
、大小为
rows x cols
的二维二进制矩阵，找出只包含
1
的最大矩形，并返回其面积。</p>
<p>代码：Java/C++/Python</p>
<p>关于最大矩形这一道题，我们就介绍到这里。如果你发现这个题目还有新的特点，还能匹配到新的算法，那么有可能你还会发现新的解法哦。接下来我们将进入 17 | 深度思考子集：如何掌握 5 种通用解法？记得按时来探险。</p>
<p>-&ndash; ### 精选评论</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">数据结构与算法面试宝典</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%9838%E8%AE%B2/15%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">15微服务间如何进行远程方法调用？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2/16__order_by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/">
            <span class="next-text nav-default">16__“order_by”是怎么工作的？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
