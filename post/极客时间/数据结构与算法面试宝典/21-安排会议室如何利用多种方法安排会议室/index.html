<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>21 安排会议室：如何利用多种方法安排会议室？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="本讲是一题多解模块的最后一讲，之所以安排这一讲，是因为通常情况下，一道算法题目有多种的解法。我们与别人交流时，大家的思路和解题方法可能不同，每个人写出来的代码差异巨大。那么这些不同的正确解法，可以理解成“一题多解”吗？换句话说，你能分清什么是真正的“多解”，什么是“伪多解”吗？
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/21-%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%AE%A4%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%AE%A4/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/21-%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%AE%A4%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%AE%A4/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="21 安排会议室：如何利用多种方法安排会议室？">
  <meta property="og:description" content="本讲是一题多解模块的最后一讲，之所以安排这一讲，是因为通常情况下，一道算法题目有多种的解法。我们与别人交流时，大家的思路和解题方法可能不同，每个人写出来的代码差异巨大。那么这些不同的正确解法，可以理解成“一题多解”吗？换句话说，你能分清什么是真正的“多解”，什么是“伪多解”吗？">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="数据结构与算法面试宝典">

  <meta itemprop="name" content="21 安排会议室：如何利用多种方法安排会议室？">
  <meta itemprop="description" content="本讲是一题多解模块的最后一讲，之所以安排这一讲，是因为通常情况下，一道算法题目有多种的解法。我们与别人交流时，大家的思路和解题方法可能不同，每个人写出来的代码差异巨大。那么这些不同的正确解法，可以理解成“一题多解”吗？换句话说，你能分清什么是真正的“多解”，什么是“伪多解”吗？">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4991">
  <meta itemprop="keywords" content="数据结构与算法面试宝典">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="21 安排会议室：如何利用多种方法安排会议室？">
  <meta name="twitter:description" content="本讲是一题多解模块的最后一讲，之所以安排这一讲，是因为通常情况下，一道算法题目有多种的解法。我们与别人交流时，大家的思路和解题方法可能不同，每个人写出来的代码差异巨大。那么这些不同的正确解法，可以理解成“一题多解”吗？换句话说，你能分清什么是真正的“多解”，什么是“伪多解”吗？">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">21 安排会议室：如何利用多种方法安排会议室？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4991 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>本讲是一题多解模块的最后一讲，之所以安排这一讲，是因为通常情况下，一道算法题目有多种的解法。我们与别人交流时，大家的思路和解题方法可能不同，每个人写出来的代码差异巨大。那么这些不同的正确解法，可以理解成“一题多解”吗？换句话说，你能分清什么是真正的“多解”，什么是“伪多解”吗？</p>
<p>通过这些“伪多解”，有助于我们看透题目的本质，从而掌握核心知识点，同时也可以降低我们需要理解和记忆的知识量。</p>
<p>所以，在本讲，你将掌握以下三种思考方法：</p>
<p>如何通过“多解”看透知识点的本质（分清“伪多解”“真多解”）？</p>
<p>如何用多种技巧满足题目要求？</p>
<p>如何深挖题目特点，达到一题多解的目标？</p>
<p>题目</p>
<p>给定一系列的会议，时间间隔intervals，包括起始和结束时间
[[s<code>1</code>,e1],[s<code>2</code>,e2],<code>...</code>]````(<code>s</code>i &lt; ei)
，找到所需的最小的会议室数量。</p>
<p>输入：会议时间表 [[0, 30],[5, 10],[15, 20]]</p>
<p>输出：最少需要的会议室数量 2</p>
<p>注意：如果有两个会议 [6,8] 和 [8,10]，我们认为这两个会议不冲突。</p>
<p>特点 1：时间分布</p>
<p>拿到这个题时，我们要特别注意一点：</p>
<p>如果有两个会议，其中一个会议结束于时间点x，下一个会议同时从时间点y 开始，这两个会议可以用同一个会议室。也就是说，这两个时间段并不重合（虽然在时间点 x 相接）。</p>
<p>我们从时间点出发来考虑这个问题，有以下 3 种情况。</p>
<p>情况 1：需 1 个会议室</p>
<p>首先我们考虑一种简单的情况，假设会议与会议之间均没有重合的情况。比如输入如下：</p>
<p>intervals=[0,1],[1,2],[2, 3]</p>
<p>在下图中，x 轴表示会议的时间表，y 轴表示将哪些会议放在哪个会议室，蓝色、橘色和红色分别表示不同的会议。</p>
<p>在这种情况下，每个时间点只可以被染上一种颜色，时间衔接得非常好，此时只需要一个会议室。接下来我们再看一下衔接得不那么好的情况。</p>
<p>在这种情况下，每个时间点只可以被染上一种颜色，或者没有染上颜色，同样此时最多也只需要一个会议室。</p>
<p>不过，我们还需要处理一种很麻烦的情况，此时 [6, 8] 和 [8, 10] 两个会议的时间点都会将时间点 8 进行染色。那岂不是时间点 8 会有两种颜色？针对这种情况，我们在染色的时候，可以做一点更正。</p>
<p>针对会议时间[start,end]染色时，只需要渲染[start,end)，不需要将end点进行染色。</p>
<p>此时，即可满足：</p>
<p>区间 [6,8)与区间[8,10)不相交。</p>
<p>并且，我们不需要再对这种前后时间相接的情况做特殊判断。</p>
<p>情况 2：需 2 个会议室</p>
<p>前面我们考虑的都是没有重合的情况，接下来，再看一下两个会议室 [0, 2) 和 [1, 4) 有重合的情况。</p>
<p>此时，只需要对 [0, 2) 和区间 [1, 4) 进行染色。我们发现，如果在时刻 1画一条竖线，会分别遇到两种颜色：蓝色和红色。</p>
<p>情况 3：需多个会议室</p>
<p>前面考虑了需要 1 个和 2 个会议室的情况，接下来我们看一下稍微复杂一点的场景。</p>
<p>通过画图可以发现规律，y 轴的会议室的数目与某个点染色的次数相关。那么，我们可以把这个题转换为一个更加容易理解的题目：</p>
<p>给定一个数组A[]，再给定一系列区间[start, end)，我们将此区间中A[start&hellip;end)都加上1。最后求数组 A[] 中的最大值。</p>
<p>差分数组</p>
<p>差分数组是一种求解区间累加的有效手段。我们先考虑只有一个区间 [start, end) 的情况。</p>
<p>一种暴力的写法是下面这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 给定数组A[]已经初始化为0
</span></span><span class="line"><span class="cl">// 处理一个区间的情况
</span></span><span class="line"><span class="cl">for (int i = start; i &lt; end; i++) {
</span></span><span class="line"><span class="cl">  A[i]++;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// 这里是累加之后的A[]数组
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以通过画图表示操作后的结果，如下图所示：</p>
<p>如果我们只关心每个时间点的涨幅与跌幅，那么可以对每个点进行标注，如下图所示：</p>
<p>你可以按照如下操作，得到任意时刻的累计值（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 给定数组A[]已初始化全为0
</span></span><span class="line"><span class="cl">// 处理一个区间
</span></span><span class="line"><span class="cl">A[start] += 1;
</span></span><span class="line"><span class="cl">A[end] -= 1;
</span></span><span class="line"><span class="cl">// 最后求前缀和，得到任意时刻的值
</span></span><span class="line"><span class="cl">pre = 0;
</span></span><span class="line"><span class="cl">for (int i = start; i &lt; end; i++) {
</span></span><span class="line"><span class="cl">  pre += A[i];
</span></span><span class="line"><span class="cl">  A[i] += pre;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>无论是一个区间还是多个区间，我们都可以参考上述方式进行处理，代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 给定数组A[]已初始化全为0
</span></span><span class="line"><span class="cl">for (Interval range: intervals) {
</span></span><span class="line"><span class="cl">  A[range.start] += 1;
</span></span><span class="line"><span class="cl">  A[range.end] -= 1;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// 最后求前缀和，得到任意时刻的值
</span></span><span class="line"><span class="cl">pre = 0;
</span></span><span class="line"><span class="cl">for (int i = start; i &lt; end; i++) {
</span></span><span class="line"><span class="cl">  pre += A[i];
</span></span><span class="line"><span class="cl">  A[i] += pre;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>基于这个知识点，我还给你留了一个练习题。</p>
<p>练习题 1：假设你有一个长度为
n
的数组，数组的所有元素初始化为
0
，并且给定
k
个更新操作。每个更新操作表示为一个三元组：
[startIndex, endIndex, inc]
。这个更新操作给子数组
A[start<code>I</code>ndex````&hellip; endIndex]
（包括startIndex和endIndex）中的每一个元素增加
inc
。返回执行
k
个更新操作后的新数组。</p>
<p>代码：Java/C++/Python</p>
<p>改进 1： 哈希表</p>
<p>如果我们直接使用差分数组，好像无法直接破解这个题，因为题目中并没有约定所有整数的范围。比如，如果给定的某个会议时间段是 [0, 10000000000]，就无法直接申请 A[10000000000] 这么大的数组。</p>
<p>因此，我们还需要对差分数组做一点改进：可以尝试用哈希表来表示数组。</p>
<p>改进 2：范围</p>
<p>在标准的差分数组中，我们需要返回的是一个操作之后的数组，也就是求出每一个 A[i] 的值。但是在这个题中，只需要拿到数组的最大值就可以了。因此，我们也没有必要求出每一个 A[i] 的值。</p>
<p>综上，可以写出基于差分数组的改进的代码如下（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Counter</span> <span class="k">extends</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="ne">int</span> <span class="n">get</span><span class="p">(</span><span class="n">Integer</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">containsKey</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="err">?</span> <span class="n">super</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="n">void</span> <span class="n">add</span><span class="p">(</span><span class="n">Integer</span> <span class="n">k</span><span class="p">,</span> <span class="ne">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">put</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span> <span class="k">class</span> <span class="n">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">/**</span>
</span></span><span class="line"><span class="cl">   <span class="o">*</span> <span class="err">@</span><span class="n">param</span> <span class="n">intervals</span><span class="p">:</span> <span class="n">an</span> <span class="n">array</span> <span class="n">of</span> <span class="n">meeting</span> <span class="n">time</span> <span class="n">intervals</span>
</span></span><span class="line"><span class="cl">   <span class="o">*</span> <span class="err">@</span><span class="k">return</span><span class="p">:</span> <span class="n">the</span> <span class="n">minimum</span> <span class="n">number</span> <span class="n">of</span> <span class="n">conference</span> <span class="n">rooms</span> <span class="n">required</span>
</span></span><span class="line"><span class="cl">   <span class="o">*/</span>
</span></span><span class="line"><span class="cl">  <span class="n">public</span> <span class="ne">int</span> <span class="n">minMeetingRooms</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">intervals</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">//</span> <span class="n">Write</span> <span class="n">your</span> <span class="n">code</span> <span class="n">here</span>
</span></span><span class="line"><span class="cl">      <span class="o">//</span> <span class="err">利用</span><span class="n">Hash表生成A</span><span class="p">[]</span><span class="err">数组</span>
</span></span><span class="line"><span class="cl">      <span class="n">Counter</span> <span class="n">A</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Counter</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">Interval</span> <span class="nb">range</span><span class="p">:</span> <span class="n">intervals</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">final</span> <span class="ne">int</span> <span class="n">start</span> <span class="o">=</span> <span class="nb">range</span><span class="o">.</span><span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">final</span> <span class="ne">int</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">range</span><span class="o">.</span><span class="n">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">A</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">A</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">keySet</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="n">Collections</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="ne">int</span> <span class="n">pre</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="ne">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">Integer</span> <span class="n">i</span><span class="p">:</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pre</span> <span class="o">+=</span> <span class="n">A</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">pre</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度为 O(NlgN)，空间复杂度为 O(N)。</p>
<p>我们发现，这个题目的考点就是在差分数组上的两点变化：</p>
<p>利用哈希表表示数组；</p>
<p>由于只需要求最大值，因此我们求出区间端点的值就可以了。</p>
<p>接下来，我们来看另外一种思路。</p>
<p>特点 2：变招 1</p>
<p>我们继续讨论一下差分数组的解法。在本题中，我们需要的并不是一个标准的差分解法。经过分析之后，实际上只需要处理以下情况：</p>
<p>给定区间 [start, end)；</p>
<p>只需要遇到 start 时 +1；</p>
<p>只需要遇到 end时 -1；</p>
<p>然后再利用累计求和的方式计算每个位置的值。</p>
<p>在前面我们用了哈希数组的办法，那么，哈希数组就是必需的吗？</p>
<p>由于我们并不像差分数组一样返回操作之后的整个数组，而是返回最大值。因此只需要经过以下两步，就可以得到最大值。</p>
<p>Step 1. 将所有的下标放到一个数组中，并且进行排序。</p>
<p>Step 2. 从头倒尾遍历下标，如果遇到区间的起始点，那么 +1；如果遇到区间的终点，那么 -1。</p>
<p>操作伪代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">item = [收集了所有的下标]
</span></span><span class="line"><span class="cl">sort(item)
</span></span><span class="line"><span class="cl">ans = 0
</span></span><span class="line"><span class="cl">pre = 0
</span></span><span class="line"><span class="cl">for 坐标 in item:
</span></span><span class="line"><span class="cl">    if 坐标是区间的起始点:
</span></span><span class="line"><span class="cl">        pre += 1
</span></span><span class="line"><span class="cl">    else:
</span></span><span class="line"><span class="cl">        pre -= 1
</span></span><span class="line"><span class="cl">    ans = max(ans, pre)
</span></span><span class="line"><span class="cl">return ans
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里还有两个地方需要处理：</p>
<p>1 ) 如何判断经过排序之后的下标，是区间的终点还是一个区间的起始点？</p>
<p>解决方法：在放到 item 里面的时候，我们可以将起始点设置为正值，终点设置为负值。</p>
<p>2 ）如果经过排序之后的下标分了正负，那么一个区间的终点将会位于 x 轴的负半轴，起始点位于 x 轴的正半轴，这并没有按照原本的坐标排序。</p>
<p>解决方法：排序时，我们只需要按照下标的绝对值排序即可。</p>
<p>基于这样的处理技巧，可以写出代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class Solution {
</span></span><span class="line"><span class="cl">  /**
</span></span><span class="line"><span class="cl">   * @param intervals: an array of meeting time intervals
</span></span><span class="line"><span class="cl">   * @return: the minimum number of conference rooms required
</span></span><span class="line"><span class="cl">   */
</span></span><span class="line"><span class="cl">  public int minMeetingRooms(List&lt;Interval&gt; intervals) {
</span></span><span class="line"><span class="cl">    List&lt;Integer&gt; item = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">    for (Interval range: intervals) {
</span></span><span class="line"><span class="cl">      item.add(range.start);
</span></span><span class="line"><span class="cl">      item.add(0 - range.end);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    Collections.sort(item, new Comparator&lt;Integer&gt;() {
</span></span><span class="line"><span class="cl">        public int compare(Integer a, Integer b) {
</span></span><span class="line"><span class="cl">          return Math.abs(a) - Math.abs(b);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    });
</span></span><span class="line"><span class="cl">    int ans = 0;
</span></span><span class="line"><span class="cl">    int pre = 0;
</span></span><span class="line"><span class="cl">    for (int i = 0; i &lt; item.size(); i++) {
</span></span><span class="line"><span class="cl">      if (item.get(i) &gt;= 0) {
</span></span><span class="line"><span class="cl">        pre++;
</span></span><span class="line"><span class="cl">      } else {
</span></span><span class="line"><span class="cl">        pre--;
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      ans = Math.max(ans, pre);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return ans;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度为 O(NlgN)，空间复杂度为 O(N)。</p>
<p>在这里，我们已经快找不到差分数组的影子了，但是本质上还是基于差分数组进行求解。那么，还有其他的解法吗？</p>
<p>特点 3：变招 2</p>
<p>前面在处理区间的时候：是将所有区间的起始点标记为非负，区间的终点标记为负数；排序时按照绝对值进行排序。然后再利用差分数组的核心思想：遇到区间的起始点 +1；遇到区间的终点 -1。</p>
<p>那么还有没有其他的招法呢？我们再认真地研究一下这个题目，不难发现，破题的关键就在两处条件：</p>
<p>需要将所有的坐标排序，并且需要知道每个坐标是属于一个区间的起始点还是终点。即顺序遍历坐标，知道每个坐标是起始点还是终点；</p>
<p>利用差分数组的核心思想，然后求出最大值。</p>
<p>根据条件 2，我们已知可以利用差分数组的思路，那么条件 1 这里还可以用别的方法吗？下面我们尝试完成条件 1 。</p>
<p>首先将所有区间的起始点坐标放到 starts 数组中，将所有区间的终点坐标放到 end 数组中。然后，再将 starts 和 end 采用合并排序的方法进行合并（注意，此时我们不是直接使用合并排序，准确来说是使用合并排序中的合并的技巧）。</p>
<p>此时，我们可以达成条件 1 的两个目的：</p>
<p>顺序遍历每个坐标；</p>
<p>知道每个坐标是区间起始坐标，还是终点坐标。</p>
<p>伪代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">starts = [...区间的起始点...]
</span></span><span class="line"><span class="cl">ends = [...区间的终点...]
</span></span><span class="line"><span class="cl">sort(start);
</span></span><span class="line"><span class="cl">sort(ends);
</span></span><span class="line"><span class="cl">slen = len(starts)
</span></span><span class="line"><span class="cl">elen = len(ends)
</span></span><span class="line"><span class="cl">i = 0
</span></span><span class="line"><span class="cl">j = 0
</span></span><span class="line"><span class="cl">while i &lt; slen || j &lt; elen:
</span></span><span class="line"><span class="cl">    if j &gt;= elen || i &lt; slen:
</span></span><span class="line"><span class="cl">        遍历到了start[i]；并且我们知道这个坐标是区间的起始点
</span></span><span class="line"><span class="cl">    else:
</span></span><span class="line"><span class="cl">        遍历到了end[i]；并且我们知道这个坐标是区间的终点
</span></span></code></pre></td></tr></table>
</div>
</div><p>基于这样的思想，再加上我们的差分核心思路，那么就可以写出如下代码了（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class Solution {
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * @param intervals: an array of meeting time intervals
</span></span><span class="line"><span class="cl">     * @return: the minimum number of conference rooms required
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public int minMeetingRooms(List&lt;Interval&gt; intervals) {
</span></span><span class="line"><span class="cl">        // Write your code here
</span></span><span class="line"><span class="cl">        final int N = intervals == null ? 0 : intervals.size();
</span></span><span class="line"><span class="cl">        int[] start = new int[N];
</span></span><span class="line"><span class="cl">        int[] end = new int[N];
</span></span><span class="line"><span class="cl">        int i = 0;
</span></span><span class="line"><span class="cl">        for (Interval range: intervals) {
</span></span><span class="line"><span class="cl">          start[i] = range.start;
</span></span><span class="line"><span class="cl">          end[i] = range.end;
</span></span><span class="line"><span class="cl">          i++;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        Arrays.sort(start);
</span></span><span class="line"><span class="cl">        Arrays.sort(end);
</span></span><span class="line"><span class="cl">        i = 0;
</span></span><span class="line"><span class="cl">        int j = 0;
</span></span><span class="line"><span class="cl">        int pre = 0;
</span></span><span class="line"><span class="cl">        int ans = 0;
</span></span><span class="line"><span class="cl">        while (i &lt; N || j &lt; N) {
</span></span><span class="line"><span class="cl">          if (j &gt;= N || i &lt; N &amp;&amp; start[i] &lt; end[j]) {
</span></span><span class="line"><span class="cl">            // 是个坐标的起始点
</span></span><span class="line"><span class="cl">            pre++;
</span></span><span class="line"><span class="cl">            i++;
</span></span><span class="line"><span class="cl">          } else {
</span></span><span class="line"><span class="cl">            // 是个坐标的终点
</span></span><span class="line"><span class="cl">            pre--;
</span></span><span class="line"><span class="cl">            j++;
</span></span><span class="line"><span class="cl">          }
</span></span><span class="line"><span class="cl">          ans = Math.max(ans, pre);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return ans;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度为 O(NlgN)，空间复杂度为O(N)。</p>
<p>接下来，我们再看看有没有其他的解法。</p>
<p>特点 4：最少</p>
<p>再回到原始题目，要想会议室最少，那么我们在拿到一个 meeting = [start,end] 的时候，尽量不去开新的会议室，而是选择一个已有会议结束时间&lt;= start 的会议室开会。</p>
<p>要做到这一点，我们需要记录每个会议室的结束时间；当给定 meeting = [start,end] 的时候，就需要找到一个 &lt;= start 的会议室提供给这个 meeting使用。</p>
<p>到这里，不知道你是否想起了我们在《03 | 优先级队列：堆与优先级队列，筛选最优元素》中介绍的“例 3”。我们可以把会议室也放到优先级队列中，每次总是取出结束时间最早的会议室。</p>
<p>由于给定的所有的 meeting 并没有排好序。因此，我们还需要做一点预处理——对 meeting进行排序。此时你还会面临一个问题，在排序的时候，meeting有 [start,end]，那么应该按照 start 值来排序，还是按照 end 来排序呢？</p>
<p>答案是按照 start 值来排序。因为我们在选择会议室的时候，需要两个输入，分别是 meeting 的开始时间 start 和会议室的结束时间。</p>
<p>基于这样的思想，我们就可以写出如下的代码（解析在注释里）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class Solution {
</span></span><span class="line"><span class="cl">  public int minMeetingRooms(List&lt;Interval&gt; intervals) {
</span></span><span class="line"><span class="cl">      final int N = intervals == null ? 0 : intervals.size();
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      // 把所有的会议时间段都按start来排序
</span></span><span class="line"><span class="cl">      Collections.sort(intervals, new Comparator&lt;Interval&gt;() {
</span></span><span class="line"><span class="cl">        public int compare(Interval a, Interval b) {
</span></span><span class="line"><span class="cl">          return a.start - b.start;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">      });
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      // 这里要按照会议室的结束时间来排序
</span></span><span class="line"><span class="cl">      Queue&lt;Integer&gt; meetingRooms = 
</span></span><span class="line"><span class="cl">          new PriorityQueue&lt;&gt;((v1, v2) -&gt; v1 - v2);
</span></span><span class="line"><span class="cl">          
</span></span><span class="line"><span class="cl">      for (Interval meeting : intervals) {
</span></span><span class="line"><span class="cl">        if (!meetingRooms.isEmpty() &amp;&amp;
</span></span><span class="line"><span class="cl">              meetingRooms.peek() &lt;= meeting.start) {
</span></span><span class="line"><span class="cl">              
</span></span><span class="line"><span class="cl">          // 我们需要把这个会议室的结束时间修改一下
</span></span><span class="line"><span class="cl">          // 当然，优先级队列里面是不好直接修改元素值的
</span></span><span class="line"><span class="cl">          // 那我们只能采用先出队，再把当前会议结束时间入队的方式
</span></span><span class="line"><span class="cl">          meetingRooms.poll();
</span></span><span class="line"><span class="cl">          meetingRooms.add(meeting.end);
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">          // 如果找不到会议室，那么新开一间
</span></span><span class="line"><span class="cl">          // 标记其结束时间
</span></span><span class="line"><span class="cl">          meetingRooms.add(meeting.end);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      return meetingRooms.size();
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码：Java/C++/Python</p>
<p>复杂度分析：时间复杂度为O(NlgN)，空间复杂度为 O(N)。</p>
<p>总结</p>
<p>最后，我将本讲用到的知识整理成在一张思维导图中，方便你复习。</p>
<p>通过总结我们发现，这个题目的核心解法实际上只有两种，但是基于差分方法又出现了三种“伪多解”的做法，我们一一进行了分析，透过代码，相信你也学会了如何运用多种技巧来满足题目的条件。</p>
<p>当然，在面试中，如果你遇到这道题之后，面试官有可能还会深入地问你一些问题，比如下面这道一个思考题。</p>
<p>题目仍然不变，要求输出最少会议室的个数，并且还要输出每个会议室里面召开哪些会议。</p>
<p>输入：会议时间表[[0,30],[5,10],[15,20]]</p>
<p>输出：最少需要的会议室数量 2，[[0,30]] 放到会议室 1，[[5,10], [15,20]] 放到会议室 2。</p>
<p>代码：Java/C++/Python</p>
<p>你可以自己尝试求解这道题目，把答案写在留言区，我们一起讨论。关于这道会议室的题目就介绍到这里。接下来，下一讲介绍“22|数据结构模板：如何让解题变成搭积木？”，让我们继续前进。</p>
<p>-&ndash; ### 精选评论</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">数据结构与算法面试宝典</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kubernetes%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/20%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96kubernete%E4%B8%AD%E6%9C%89gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%90%97/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">20资源优化：Kubernete中有GC（垃圾回收）吗？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/21__0_eval_x__100__%E4%B8%80%E8%A1%8C%E8%AE%A9%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E5%BD%A2%E5%90%8C%E8%99%9A%E8%AE%BE%E7%9A%84%E7%A0%B4%E5%9D%8F%E6%80%A7%E8%AE%BE%E8%AE%A1%E4%B8%8B/">
            <span class="next-text nav-default">21__(0,_eval)(_x_=_100_)_：一行让严格模式形同虚设的破坏性设计（下）</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
