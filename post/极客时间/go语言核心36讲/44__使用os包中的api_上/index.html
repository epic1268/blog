<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>44__使用os包中的API_（上） - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="我们今天要讲的是os代码包中的 API。这个代码包可以让我们拥有操控计算机操作系统的能力。
前导内容：os 包中的 API 这个代码包提供的都是平台不相关的 API。那么说，什么叫平台不相关的 API 呢？
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2/44__%E4%BD%BF%E7%94%A8os%E5%8C%85%E4%B8%AD%E7%9A%84api_%E4%B8%8A/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2/44__%E4%BD%BF%E7%94%A8os%E5%8C%85%E4%B8%AD%E7%9A%84api_%E4%B8%8A/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="44__使用os包中的API_（上）">
  <meta property="og:description" content="我们今天要讲的是os代码包中的 API。这个代码包可以让我们拥有操控计算机操作系统的能力。
前导内容：os 包中的 API 这个代码包提供的都是平台不相关的 API。那么说，什么叫平台不相关的 API 呢？">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Go语言核心36讲">

  <meta itemprop="name" content="44__使用os包中的API_（上）">
  <meta itemprop="description" content="我们今天要讲的是os代码包中的 API。这个代码包可以让我们拥有操控计算机操作系统的能力。
前导内容：os 包中的 API 这个代码包提供的都是平台不相关的 API。那么说，什么叫平台不相关的 API 呢？">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3567">
  <meta itemprop="keywords" content="Go语言核心36讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="44__使用os包中的API_（上）">
  <meta name="twitter:description" content="我们今天要讲的是os代码包中的 API。这个代码包可以让我们拥有操控计算机操作系统的能力。
前导内容：os 包中的 API 这个代码包提供的都是平台不相关的 API。那么说，什么叫平台不相关的 API 呢？">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">44__使用os包中的API_（上）</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3567 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#前导内容os-包中的-api">前导内容：os 包中的 API</a></li>
        <li><a href="#问题解析">问题解析</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>我们今天要讲的是<code>os</code>代码包中的 API。这个代码包可以让我们拥有操控计算机操作系统的能力。</p>
<h2 id="前导内容os-包中的-api">前导内容：os 包中的 API</h2>
<p>这个代码包提供的都是平台不相关的 API。那么说，什么叫平台不相关的 API 呢？</p>
<p>它的意思是：这些 API 基于（或者说抽象自）操作系统，为我们使用操作系统的功能提供高层次的支持，但是，它们并不依赖于具体的操作系统。</p>
<p>不论是 Linux、macOS、Windows，还是 FreeBSD、OpenBSD、Plan9，<code>os</code>代码包都可以为之提供统一的使用接口。这使得我们可以用同样的方式，来操纵不同的操作系统，并得到相似的结果。</p>
<p><code>os</code>包中的 API 主要可以帮助我们使用操作系统中的文件系统、权限系统、环境变量、系统进程以及系统信号。</p>
<p>其中，操纵文件系统的 API 最为丰富。我们不但可以利用这些 API 创建和删除文件以及目录，还可以获取到它们的各种信息、修改它们的内容、改变它们的访问权限，等等。</p>
<p>说到这里，就不得不提及一个非常常用的数据类型：<code>os.File</code>。</p>
<p>从字面上来看，<code>os.File</code>类型代表了操作系统中的文件。但实际上，它可以代表的远不止于此。或许你已经知道，对于类 Unix 的操作系统（包括 Linux、macOS、FreeBSD 等），其中的一切都可以被看做是文件。</p>
<p>除了文本文件、二进制文件、压缩文件、目录这些常见的形式之外，还有符号链接、各种物理设备（包括内置或外接的面向块或者字符的设备）、命名管道，以及套接字（也就是 socket），等等。</p>
<p>因此，可以说，我们能够利用<code>os.File</code>类型操纵的东西太多了。不过，为了聚焦于<code>os.File</code>本身，同时也为了让本文讲述的内容更加通用，我们在这里主要把<code>os.File</code>类型应用于常规的文件。</p>
<p>下面这个问题，就是以<code>os.File</code>类型代表的最基本内容入手。<strong>我们今天的问题是：<code>os.File</code>类型都实现了哪些<code>io</code>包中的接口？</strong></p>
<p>这道题的<strong>典型回答</strong>是这样的。</p>
<p><code>os.File</code>类型拥有的都是指针方法，所以除了空接口之外，它本身没有实现任何接口。而它的指针类型则实现了很多<code>io</code>代码包中的接口。</p>
<p>首先，对于<code>io</code>包中最核心的 3 个简单接口<code>io.Reader</code>、<code>io.Writer</code>和<code>io.Closer</code>，<code>*os.File</code>类型都实现了它们。</p>
<p>其次，该类型还实现了另外的 3 个简单接口，即：<code>io.ReaderAt</code>、<code>io.Seeker</code>和<code>io.WriterAt</code>。</p>
<p>正是因为<code>*os.File</code>类型实现了这些简单接口，所以它也顺便实现了<code>io</code>包的 9 个扩展接口中的 7 个。</p>
<p>然而，由于它并没有实现简单接口<code>io.ByteReader</code>和<code>io.RuneReader</code>，所以它没有实现分别作为这两者的扩展接口的<code>io.ByteScanner</code>和<code>io.RuneScanner</code>。</p>
<p>总之，<code>os.File</code>类型及其指针类型的值，不但可以通过各种方式读取和写入某个文件中的内容，还可以寻找并设定下一次读取或写入时的起始索引位置，另外还可以随时对文件进行关闭。</p>
<p>但是，它们并不能专门地读取文件中的下一个字节，或者下一个 Unicode 字符，也不能进行任何的读回退操作。</p>
<p>不过，单独读取下一个字节或字符的功能也可以通过其他方式来实现，比如，调用它的<code>Read</code>方法并传入适当的参数值就可以做到这一点。</p>
<h2 id="问题解析">问题解析</h2>
<p>这个问题其实在间接地问“<code>os.File</code>类型能够以何种方式操作文件？”我在前面的典型回答中也给出了简要的答案。</p>
<p>在我进一步地说明一些细节之前，我们先来看看，怎样才能获得一个<code>os.File</code>类型的指针值（以下简称<code>File</code>值）。</p>
<p>在<code>os</code>包中，有这样几个函数，即：<code>Create</code>、<code>NewFile</code>、<code>Open</code>和<code>OpenFile</code>。</p>
<p><strong><code>os.Create</code>函数用于根据给定的路径创建一个新的文件。</strong> 它会返回一个<code>File</code>值和一个错误值。我们可以在该函数返回的<code>File</code>值之上，对相应的文件进行读操作和写操作。</p>
<p>不但如此，我们使用这个函数创建的文件，对于操作系统中的所有用户来说，都是可以读和写的。</p>
<p>换句话说，一旦这样的文件被创建出来，任何能够登录其所属的操作系统的用户，都可以在任意时刻读取该文件中的内容，或者向该文件写入内容。</p>
<p>注意，如果在我们给予<code>os.Create</code>函数的路径之上，已经存在了一个文件，那么该函数会先清空现有文件中的全部内容，然后再把它作为第一个结果值返回。</p>
<p>另外，<code>os.Create</code>函数是有可能返回非<code>nil</code>的错误值的。</p>
<p>比如，如果我们给定的路径上的某一级父目录并不存在，那么该函数就会返回一个<code>*os.PathError</code>类型的错误值，以表示“不存在的文件或目录”。</p>
<p><strong>再来看<code>os.NewFile</code>函数。</strong> 该函数在被调用的时候，需要接受一个代表文件描述符的、<code>uintptr</code>类型的值，以及一个用于表示文件名的字符串值。</p>
<p>如果我们给定的文件描述符并不是有效的，那么这个函数将会返回<code>nil</code>，否则，它将会返回一个代表了相应文件的<code>File</code>值。</p>
<p>注意，不要被这个函数的名称误导了，它的功能并不是创建一个新的文件，而是依据一个已经存在的文件的描述符，来新建一个包装了该文件的<code>File</code>值。</p>
<p>例如，我们可以像这样拿到一个包装了标准错误输出的<code>File</code>值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">file3 := os.NewFile(uintptr(syscall.Stderr), &#34;/dev/stderr&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，通过这个<code>File</code>值向标准错误输出上写入一些内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if file3 != nil {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> defer file3.Close()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> file3.WriteString(
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  &#34;The Go language program writes the contents into stderr.\n&#34;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong><code>os.Open</code>函数会打开一个文件并返回包装了该文件的<code>File</code>值。</strong> 然而，该函数只能以只读模式打开文件。换句话说，我们只能从该函数返回的<code>File</code>值中读取内容，而不能向它写入任何内容。</p>
<p>如果我们调用了这个<code>File</code>值的任何一个写入方法，那么都将会得到一个表示了“坏的文件描述符”的错误值。实际上，我们刚刚说的只读模式，正是应用在<code>File</code>值所持有的文件描述符之上的。</p>
<p>所谓的文件描述符，是由通常很小的非负整数代表的。它一般会由 I/O 相关的系统调用返回，并作为某个文件的一个标识存在。</p>
<p>从操作系统的层面看，针对任何文件的 I/O 操作都需要用到这个文件描述符。只不过，Go 语言中的一些数据类型，为我们隐匿掉了这个描述符，如此一来我们就无需时刻关注和辨别它了（就像<code>os.File</code>类型这样）。</p>
<p>实际上，我们在调用前文所述的<code>os.Create</code>函数、<code>os.Open</code>函数以及将会提到的<code>os.OpenFile</code>函数的时候，它们都会执行同一个系统调用，并且在成功之后得到这样一个文件描述符。这个文件描述符将会被储存在它们返回的<code>File</code>值中。</p>
<p><code>os.File</code>类型有一个指针方法，名叫<code>Fd</code>。它在被调用之后将会返回一个<code>uintptr</code>类型的值。这个值就代表了当前的<code>File</code>值所持有的那个文件描述符。</p>
<p>不过，在<code>os</code>包中，除了<code>NewFile</code>函数需要用到它，它也没有什么别的用武之地了。所以，如果你操作的只是常规的文件或者目录，那么就无需特别地在意它了。</p>
<p><strong>最后，再说一下<code>os.OpenFile</code>函数。</strong> 这个函数其实是<code>os.Create</code>函数和<code>os.Open</code>函数的底层支持，它最为灵活。</p>
<p>这个函数有 3 个参数，分别名为<code>name</code>、<code>flag</code>和<code>perm</code>。其中的<code>name</code>指代的就是文件的路径。而<code>flag</code>参数指的则是需要施加在文件描述符之上的模式，我在前面提到的只读模式就是这里的一个可选项。</p>
<p>在 Go 语言中，这个只读模式由常量<code>os.O_RDONLY</code>代表，它是<code>int</code>类型的。当然了，这里除了只读模式之外，还有几个别的模式可选，我们稍后再细说。</p>
<p><code>os.OpenFile</code>函数的参数<code>perm</code>代表的也是模式，它的类型是<code>os.FileMode</code>，此类型是一个基于<code>uint32</code>类型的再定义类型。</p>
<p>为了加以区别，我们把参数<code>flag</code>指代的模式叫做操作模式，而把参数<code>perm</code>指代的模式叫做权限模式。可以这么说，操作模式限定了操作文件的方式，而权限模式则可以控制文件的访问权限。关于权限模式的更多细节我们将在后面讨论。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2/e3b60a97fe9099f5ec7d82934f834c61.png" alt=""><br>
（获得 os.File 类型的指针值的几种方式）</p>
<p>到这里，你需要记住的是，通过<code>os.File</code>类型的值，我们不但可以对文件进行读取、写入、关闭等操作，还可以设定下一次读取或写入时的起始索引位置。</p>
<p>此外，<code>os</code>包中还有用于创建全新文件的<code>Create</code>函数，用于包装现存文件的<code>NewFile</code>函数，以及可被用来打开已存在的文件的<code>Open</code>函数和<code>OpenFile</code>函数。</p>
<h2 id="总结">总结</h2>
<p>我们今天讲的是<code>os</code>代码包以及其中的程序实体。我们首先讨论了<code>os</code>包存在的意义，和它的主要用途。代码包中所包含的 API，都是对操作系统的某方面功能的高层次抽象，这使得我们可以通过它以统一的方式，操纵不同的操作系统，并得到相似的结果。</p>
<p>在这个代码包中，操纵文件系统的 API 最为丰富，最有代表性的就是数据类型<code>os.File</code>。<code>os.File</code>类型不但可以代表操作系统中的文件，还可以代表很多其他的东西。尤其是在类 Unix 的操作系统中，它几乎可以代表一切可以操纵的软件和硬件。</p>
<p>在下一期的文章中，我会继续讲解 os 包中的 API 的内容。如果你对这部分的知识有什么问题，可以给我留言，感谢你的收听，我们下期再见。</p>
<p><a href="./Golang%5FPuzzlers.md">戳此查看 Go 语言专栏文章配套详细代码。</a></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2/6d035e7ef07f11a615a16b7e601fabe9.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2/">Go语言核心36讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/44__%E5%AE%9E%E6%88%98%E5%9B%9B%E7%94%BB%E5%9B%BE%E7%A8%8B%E5%BA%8F%E5%90%8E%E7%AB%AF%E5%AE%9E%E6%88%98/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">44__实战（四）：“画图”程序后端实战</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/44__%E5%A5%97%E8%B7%AF%E7%AF%87%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E5%87%A0%E4%B8%AA%E6%80%9D%E8%B7%AF%E4%B8%8B/">
            <span class="next-text nav-default">44__套路篇：网络性能优化的几个思路（下）</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
