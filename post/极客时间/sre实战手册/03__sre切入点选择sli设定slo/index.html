<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>03__SRE切入点：选择SLI，设定SLO - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是赵成，欢迎回来。
还是先来复习下上节课讲的“系统可用性”的两种计算方式，一种是从故障角度出发，以时长维度对系统进行稳定性评估；另一种是从成功请求占比角度出发，以请求维度对系统进行稳定性评估。同时，我们还讲到，在 SRE 实践中，通常会选择第二种，也就是根据成功请求的比例来衡量稳定性：
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/sre%E5%AE%9E%E6%88%98%E6%89%8B%E5%86%8C/03__sre%E5%88%87%E5%85%A5%E7%82%B9%E9%80%89%E6%8B%A9sli%E8%AE%BE%E5%AE%9Aslo/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/sre%E5%AE%9E%E6%88%98%E6%89%8B%E5%86%8C/03__sre%E5%88%87%E5%85%A5%E7%82%B9%E9%80%89%E6%8B%A9sli%E8%AE%BE%E5%AE%9Aslo/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="03__SRE切入点：选择SLI，设定SLO">
  <meta property="og:description" content="你好，我是赵成，欢迎回来。
还是先来复习下上节课讲的“系统可用性”的两种计算方式，一种是从故障角度出发，以时长维度对系统进行稳定性评估；另一种是从成功请求占比角度出发，以请求维度对系统进行稳定性评估。同时，我们还讲到，在 SRE 实践中，通常会选择第二种，也就是根据成功请求的比例来衡量稳定性：">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="SRE实战手册">

  <meta itemprop="name" content="03__SRE切入点：选择SLI，设定SLO">
  <meta itemprop="description" content="你好，我是赵成，欢迎回来。
还是先来复习下上节课讲的“系统可用性”的两种计算方式，一种是从故障角度出发，以时长维度对系统进行稳定性评估；另一种是从成功请求占比角度出发，以请求维度对系统进行稳定性评估。同时，我们还讲到，在 SRE 实践中，通常会选择第二种，也就是根据成功请求的比例来衡量稳定性：">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4836">
  <meta itemprop="keywords" content="SRE实战手册">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="03__SRE切入点：选择SLI，设定SLO">
  <meta name="twitter:description" content="你好，我是赵成，欢迎回来。
还是先来复习下上节课讲的“系统可用性”的两种计算方式，一种是从故障角度出发，以时长维度对系统进行稳定性评估；另一种是从成功请求占比角度出发，以请求维度对系统进行稳定性评估。同时，我们还讲到，在 SRE 实践中，通常会选择第二种，也就是根据成功请求的比例来衡量稳定性：">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">03__SRE切入点：选择SLI，设定SLO</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4836 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#sli-和-slo-到底是啥">SLI 和 SLO 到底是啥？</a></li>
          </ul>
        </li>
        <li><a href="#快速识别-sli-指标的方法valet">快速识别 SLI 指标的方法：VALET</a></li>
        <li><a href="#如何通过-slo-计算可用性">如何通过 SLO 计算可用性？</a></li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是赵成，欢迎回来。</p>
<p>还是先来复习下上节课讲的“系统可用性”的两种计算方式，一种是从故障角度出发，以时长维度对系统进行稳定性评估；另一种是从成功请求占比角度出发，以请求维度对系统进行稳定性评估。同时，我们还讲到，在 SRE 实践中，通常会选择第二种，也就是根据成功请求的比例来衡量稳定性：</p>
<p><strong>Availability = Successful request / Total request</strong></p>
<p>SRE 强调的稳定性，一般不是看单次请求的成功与否，而是看整体情况，所以我们会把成功请求的占比设定为一个可以接受的目标，也就是我们常说的“3 个 9”或“4 个 9”这样的可量化的数字。</p>
<p>那么，这个“确定成功请求条件，设定达成占比目标”的过程，在 SRE 中就是<strong>设定稳定性衡量标准的 SLI 和 SLO 的过程</strong>。</p>
<p>具体来看下这两个概念。SLI，Service Level Indicator，服务等级指标，其实就是我们选择哪些指标来衡量我们的稳定性。而 SLO，Service Level Objective，服务等级目标，指的就是我们设定的稳定性目标，比如“几个 9”这样的目标。</p>
<p>SLI 和 SLO 这两个概念你一定要牢牢记住，接下来我们会反复讲到它们，因为落地 SRE 的第一步其实就是“<strong>选择合适的 SLI，设定对应的 SLO</strong>”。</p>
<p>好，那我们就正式开始今天的内容。我会带你彻底理解 SLI 和 SLO 这两个概念，并掌握识别 SLI、设定 SLO 的具体方法。</p>
<h3 id="sli-和-slo-到底是啥">SLI 和 SLO 到底是啥？</h3>
<p>SLI 和 SLO 这两个概念比较有意思，看字面意思好像就已经很明白了，但是呢，仔细一想，你会发现它们很抽象。SLI 和 SLO 指的到底是啥呢？</p>
<p>接下来我给你讲一个具体的例子，讲完后，你肯定就能理解了。</p>
<p>我们以电商交易系统中的一个核心应用“购物车”为例，给它取名叫做 trade_cart。trade_cart 是以请求维度来衡量稳定性的，也就是说单次请求如果返回的是非 5xx 的状态码，我们认为该次请求是成功的；如果返回的是 5xx 状态码，如我们常见的 502 或 503，我们就判断这次请求是失败的。</p>
<p>但是，这个状态码只能标识单次请求的场景。我们之前讲过，单次的异常与否并不能代表这个应用是否稳定，所以，我们就要看在一个周期内，所有调用次数的成功率是多少，以此来确定它是否稳定。比如我们给这个“状态码返回为非 5xx 的比例”设定一个目标，如果大于等于 99.95%，我们就认为这个应用是稳定的。</p>
<p>在 SRE 实践中，我们用 SLI 和 SLO 来描述。“状态码为非 5xx 的比例”就是 SLI，“大于等于 99.95%”就是 SLO。说得更直接一点，SLO 是 SLI 要达成的目标。</p>
<p>通过这个例子，你现在是不是已经理解了这两个概念呢。SLI 就是我们要监控的指标，SLO 就是这个指标对应的目标。</p>
<p>好，那接下来我们要解决的问题就很具体了。我们应该选择哪些指标来监控系统的稳定性？指标选好后，对应地怎么定它的目标呢？下面咱们就一一来探索。</p>
<h4 id="系统运行状态指标那么多哪些适合-sli">系统运行状态指标那么多，哪些适合 SLI？</h4>
<p>我们先来讨论怎么选择 SLI。要回答怎么选择这个问题，我们得先来看看都有哪些可供选择的指标。</p>
<p>在下面这张图中，我列举了系统中常见的监控指标。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/SRE%E5%AE%9E%E6%88%98%E6%89%8B%E5%86%8C/a0b27a84bef8f822d8ed25f1db65a947.png" alt=""></p>
<p>这些指标是不是都很熟悉？那该怎么选呢？好像每一个指标都很重要啊！</p>
<p>确实，这些指标都很重要。我们可以通过问自己两个问题来选择。</p>
<p>第一个问题：<strong>我要衡量谁的稳定性？</strong> 也就是先找到稳定性的主体。主体确定后，我们继续问第二问题：<strong>这个指标能够标识这个实例是否稳定吗？</strong> 一般来说，这两个问题解决了，SLI 指标也就确认了。</p>
<p>从我的经验来看，给指标分层非常关键。就像上图那样分层后，再看稳定性主体是属于哪一层的，就可以在这一层里选择适合的指标。但是，你要注意，即便都是应用层的，针对具体的主体，这一层的指标也不是每一个都适合。</p>
<p>根据这几年的实践经验，我总结了选择 SLI 指标的两大原则。</p>
<p><strong>原则一：选择能够标识一个主体是否稳定的指标，如果不是这个主体本身的指标，或者不能标识主体稳定性的，就要排除在外。</strong></p>
<p><strong>原则二：针对电商这类有用户界面的业务系统，优先选择与用户体验强相关或用户可以明显感知的指标。</strong></p>
<p>还拿我们上面 trade_cart 的例子来说，主体确定了，就是 trade_cart，应用层面的，请求返回状态码和时延就是很好的指标，再来检查下它们能否标识的 trade_cart 稳定性，毫无疑问，这两个指标都可以，那么请求返回状态码和时延就可以作为 trade_cart 稳定性的 SLI 指标。</p>
<p>我们换一个指标，CPU 的使用率这个指标适合吗？根据我们刚才说的原则，既然我们关注的是 trade_cart 的运行状况，而 CPU 是系统层的指标，所以，在选择应用层 SLI 的指标时，自然会把 CPU 排除掉。</p>
<p>你可能会说，这样是不是太武断了呀？</p>
<p>我们简单来分析下。假设 CPU 使用率达到了 95%，但是只要 CPU 处理能力足够，状态码成功率可能还是保持在 4 个 9，时延还是在 80ms 以内，用户体验没有受到影响。另外一种情况，假设 CPU 使用率只有 10%，但是可能因为网络超时或中断，导致大量的请求失败，甚至是时延飙升，购物车这个应用的运行状态也不一定是正常的。所以结论就是，CPU 使用率不管是 10% 还是 95%，都不能直接反映 trade_cart 运行是正常还是异常，不适合作为 trade_cart 这样的应用运行稳定性的 SLI 指标。</p>
<p>讲到这里，你可能会问，哎呀，你说的这两个原则我理解了，分层也大概能做到，但是我还是需要做很多详细的分析才能选择出 SLI 指标，有没有什么更便捷、更快速的方法来帮助我选择啊？</p>
<p>嗯，不要着急，还真有这样一套方法。怎么选 SLI，我们可以直接借鉴 Google 的方法：VALET。</p>
<h2 id="快速识别-sli-指标的方法valet">快速识别 SLI 指标的方法：VALET</h2>
<p>VALET 是 5 个单词的首字母，分别是 Volume、Availability、Latency、Error 和 Ticket。这 5 个单词就是我们选择 SLI 指标的 5 个维度。我们还是结合 trade_cart 这个例子，一起看一下每个维度具体是什么。</p>
<p><strong>Volume- 容量</strong></p>
<p>Volume（容量）是指服务承诺的最大容量是多少。比如，一个应用集群的 QPS、TPS、会话数以及连接数等等，如果我们对日常设定一个目标，就是日常的容量 SLO，对双 11 这样的大促设定一个目标，就是大促 SLO。对于数据平台，我们要看它的吞吐能力，比如每小时能处理的记录数或任务数。</p>
<p><strong>Availablity- 可用性</strong></p>
<p>Availablity（可用性）代表服务是否正常。比如，我们前面介绍到的请求调用的非 5xx 状态码成功率，就可以归于可用性。对于数据平台，我们就看任务的执行成功情况，这个也可以根据不同的任务执行状态码来归类。</p>
<p><strong>Latency- 时延</strong></p>
<p>Latency（时延）是说响应是否足够快。这是一个会直接影响用户访问体验的指标。对于任务类的作业，我们会看每个任务是否在规定时间内完成了。</p>
<p>讲到这里，我要延伸下，因为通常对于时延这个指标，我们不会直接做所有请求时延的平均，因为整个时延的分布也符合正态分布，所以通常会以类似“90% 请求的时延 &lt;= 80ms，或者 95% 请求的时延 &lt;=120ms”这样的方式来设定时延 SLO，熟悉数理统计的同学应该知道，这个 90% 或 95% 我们称之为置信区间。</p>
<p>因为不排除很多请求从业务逻辑层面是不成功的，这时业务逻辑的处理时长就会非常短（可能 10ms），或者出现 404 这样的状态码（可能就 1ms）。从可用性来讲，这些请求也算成功，但是这样的请求会拉低整个均值。</p>
<p>同时，也会出现另一种极端情况，就是某几次请求因为各种原因，导致时延高了，到了 500ms，但是因为次数所占比例较低，数据被平均掉了，单纯从平均值来看是没有异常的。但是从实际情况看，有少部分用户的体验其实已经非常糟糕了。所以，为了识别出这种情况，我们就要设定不同的置信区间来找出这样的用户占比，有针对性地解决。</p>
<p><strong>Errors- 错误率</strong></p>
<p>错误率有多少？这里除了 5xx 之外，我们还可以把 4xx 列进来，因为前面我们的服务可用性不错，但是从业务和体验角度，4xx 太多，用户也是不能接受的。</p>
<p>或者可以增加一些自定义的状态码，看哪些状态是对业务有损的，比如某些热门商品总是缺货，用户登录验证码总是输入错误，这些虽不是系统错误，但从业务角度来看，对用户的体验影响还是比较大的。</p>
<p><strong>Tickets- 人工介入</strong></p>
<p>是否需要人工介入？如果一项工作或任务需要人工介入，那说明一定是低效或有问题的。举一个我们常见的场景，数据任务跑失败了，但是无法自动恢复，这时就要人工介入恢复；或者超时了，也需要人工介入，来中断任务、重启拉起来跑等等。</p>
<p>Tickets 的 SLO 可以想象成它的中文含义：门票。一个周期内，门票数量是固定的，比如每月 20 张，每次人工介入，就消耗一张，如果消耗完了，还需要人工介入，那就是不达标了。</p>
<p>这里我给出一个 Google 提供的，针对类似于我们 trade_cart 的一个应用服务，基于 VALET 设计出来的 SLO 的 Dashboard 样例，结合上面我们介绍的部分，就一目了然了。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/SRE%E5%AE%9E%E6%88%98%E6%89%8B%E5%86%8C/9ee69f579acfe234ea06b1ff445234e2.png" alt=""></p>
<p>VALET 示例图</p>
<p>好，VALET 我们就讲完了，怎么选 SLI 指标，你是不是一下子就清楚了。可以说，这是一个我们可以直接复用的工具。上面 Google 的这张 SLO 样例图，建议你多看几遍，看到时候，对比思考下自己系统的情况。</p>
<h2 id="如何通过-slo-计算可用性">如何通过 SLO 计算可用性？</h2>
<p>到这里，我们已经能够根据自己想要保障稳定性的主体，来选择合适的 SLI 指标了，也知道 SLO 就是对应 SLI 要实现的目标，比如“几个 9”。</p>
<p>但是，我们前面讲到了系统可用性：</p>
<p><strong>Availability = Successful request / Total request</strong></p>
<p>然后又深入到了提炼具体的 SLI，以及设定对应的 SLO，那这两者之间是什么关系呢？也就是通过 SLO 应该怎么去计算我们的系统可用性的呢？这就涉及到系统整体可用性的两种计算方式。</p>
<p><strong>第一种，直接根据成功的定义来计算</strong>。</p>
<p>也就是我们前面定义一个请求的返回状态码必须是非 5xx 才算成功，同时时延还要低于 80ms，同时满足这两个条件，我们才算是成功的，也就是纳入上述公式中 Successful request 的统计中，用公式来表示：</p>
<p><strong>Successful = （状态码非 5xx） &amp; （时延 &lt;= 80ms）</strong></p>
<p>如果还有其它条件，直接在后面增加做综合判定。</p>
<p>但是，这种计算方式存在的问题就是，对单次请求的成功与否的判定太过死板，容易错杀误判。比如我们前面讲对于时延，我们一般会设定置信区间，比如 90% 时延小于等于 200ms 这样的场景，用这种方式就很难体现出来。而且，对于状态码成功率和时延成功率的容忍度，通常也是也不一样的，通过这种方式就不够准确。所以，我们就会采取第二种方式。</p>
<p><strong>第二种方式，SLO 方式计算</strong>。</p>
<p>我们前面讲时延时讲过以下几个 SLO，这时我们设定稳定性的时候，就需要把公式计算方式灵活调整定义一下了。</p>
<ol>
<li>SLO1:99.95% 状态码成功率</li>
<li>SLO2:90% Latency &lt;= 80ms</li>
<li>SLO3:99% Latency &lt;= 200ms</li>
</ol>
<p>直接用公式表示：</p>
<p><strong>Availability = SLO1 &amp; SLO2 &amp; SLO3</strong></p>
<p>只有当这个三个 SLO 同时达标时，整个系统的稳定性才算达标，有一个不达标就不算达标，这样就可以很好地将 SLO 设定的合理性与最终可用性结合了起来。所以，通常在 SRE 实践中，我们通常会采用这种设定方式。</p>
<p>如果是这样，第一种方式是不是就没有用途了呢？当然不是。第一种计算方式也会有它特有的应用场景，它通常会被利用在第三方提供的服务承诺中，也就是 SLA（Service Level Agreement）。因为对于第三方提供商来说，比如云厂商，它们要面对的客户群体是非常大的，所以很难跟每一家客户都去制定像 SLO 这么细粒度稳定性目标，而且每家客户对稳定性的要求和感知也不同，就没法统一。</p>
<p>这种情况下，反而是第一种计算方式是相对简单直接的，但是这样也决定了 SLA 的承诺相比 SLO 肯定也相对比较宽松，因为 SLA 是商业服务承诺，如果达不成是要进行赔偿的。关于 SLA，最直接的参考资料，就是各个公有云厂商在官网公开的信息资料，你可以找到这些资料，作为自己的一个补充学习。</p>
<h2 id="总结">总结</h2>
<p>讲到这里，怎么选择 SLI 指标、如何制定 SLO 目标，我们就介绍完了。你需要掌握下面三个重点。</p>
<ol>
<li>对系统相关指标要分层，识别出我们要保障稳定性的主体（系统、业务或应用）是什么，然后基于这个主体来选择合适的 SLI 指标。</li>
<li>不是所有的指标都是适合做 SLI 指标，它一定要能够直接体现和反映主体的稳定性状态。可以优先选择用户或使用者能感受到的体验类指标，比如时延、可用性、错误率等。</li>
<li>掌握 VALET 方法，快速选择 SLI 指标。</li>
</ol>
<h2 id="思考题">思考题</h2>
<p>最后，给你留一个思考题。</p>
<p>下面我给出一个 Google 的 SLI 和 SLO 设定标准示例，内容很直观，需要你认真研究一下这个文档，结合今天我们所讲的内容，请你尝试按照 Google 提供的规范格式，制定一个自己所负责系统的 SLO。</p>
<p>Google 的 SLI 和 SLO 设定模板链接：https://landing.google.com/sre/workbook/chapters/slo-document</p>
<p>另外，对今天的内容如果你还有什么疑惑，都可以在留言区提问，也欢迎你把今天的内容分享给身边的朋友，和他一起学习讨论。</p>
<p>我是赵成，我们下节课见。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/sre%E5%AE%9E%E6%88%98%E6%89%8B%E5%86%8C/">SRE实战手册</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spark%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/03__rdd%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BF%85%E9%A1%BB%E8%A6%81%E7%90%86%E8%A7%A3%E5%BC%B9%E6%80%A7%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%9B%86/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">03__RDD：为什么你必须要理解弹性分布式数据集？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/webassembly%E5%85%A5%E9%97%A8%E8%AF%BE/03__webassembly_%E6%98%AF%E4%B8%80%E9%97%A8%E6%96%B0%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%90%97/">
            <span class="next-text nav-default">03__WebAssembly_是一门新的编程语言吗？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
