<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>22__撬动离线业务：Job与CronJob - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是张磊。今天我和你分享的主题是：撬动离线业务之 Job 与 CronJob。
在前面的几篇文章中，我和你详细分享了 Deployment、StatefulSet，以及 DaemonSet 这三个编排概念。你有没有发现它们的共同之处呢？
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes/22__%E6%92%AC%E5%8A%A8%E7%A6%BB%E7%BA%BF%E4%B8%9A%E5%8A%A1job%E4%B8%8Ecronjob/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes/22__%E6%92%AC%E5%8A%A8%E7%A6%BB%E7%BA%BF%E4%B8%9A%E5%8A%A1job%E4%B8%8Ecronjob/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="22__撬动离线业务：Job与CronJob">
  <meta property="og:description" content="你好，我是张磊。今天我和你分享的主题是：撬动离线业务之 Job 与 CronJob。
在前面的几篇文章中，我和你详细分享了 Deployment、StatefulSet，以及 DaemonSet 这三个编排概念。你有没有发现它们的共同之处呢？">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="深入剖析Kubernetes">

  <meta itemprop="name" content="22__撬动离线业务：Job与CronJob">
  <meta itemprop="description" content="你好，我是张磊。今天我和你分享的主题是：撬动离线业务之 Job 与 CronJob。
在前面的几篇文章中，我和你详细分享了 Deployment、StatefulSet，以及 DaemonSet 这三个编排概念。你有没有发现它们的共同之处呢？">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7047">
  <meta itemprop="keywords" content="深入剖析Kubernetes">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="22__撬动离线业务：Job与CronJob">
  <meta name="twitter:description" content="你好，我是张磊。今天我和你分享的主题是：撬动离线业务之 Job 与 CronJob。
在前面的几篇文章中，我和你详细分享了 Deployment、StatefulSet，以及 DaemonSet 这三个编排概念。你有没有发现它们的共同之处呢？">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">22__撬动离线业务：Job与CronJob</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7047 字 </span>
          <span class="more-meta"> 预计阅读 15 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#总结">总结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是张磊。今天我和你分享的主题是：撬动离线业务之 Job 与 CronJob。</p>
<p>在前面的几篇文章中，我和你详细分享了 Deployment、StatefulSet，以及 DaemonSet 这三个编排概念。你有没有发现它们的共同之处呢？</p>
<p>实际上，它们主要编排的对象，都是“在线业务”，即：Long Running Task（长作业）。比如，我在前面举例时常用的 Nginx、Tomcat，以及 MySQL 等等。这些应用一旦运行起来，除非出错或者停止，它的容器进程会一直保持在 Running 状态。</p>
<p>但是，有一类作业显然不满足这样的条件，这就是“离线业务”，或者叫作 Batch Job（计算业务）。这种业务在计算完成后就直接退出了，而此时如果你依然用 Deployment 来管理这种业务的话，就会发现 Pod 会在计算结束后退出，然后被 Deployment Controller 不断地重启；而像“滚动更新”这样的编排功能，更无从谈起了。</p>
<p>所以，早在 Borg 项目中，Google 就已经对作业进行了分类处理，提出了 LRS（Long Running Service）和 Batch Jobs 两种作业形态，对它们进行“分别管理”和“混合调度”。</p>
<p>不过，在 2015 年 Borg 论文刚刚发布的时候，Kubernetes 项目并不支持对 Batch Job 的管理。直到 v1.4 版本之后，社区才逐步设计出了一个用来描述离线业务的 API 对象，它的名字就是：Job。</p>
<p>Job API 对象的定义非常简单，我来举个例子，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: batch/v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: Job
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: pi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  template:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      containers:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      - name: pi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        image: resouer/ubuntu-bc 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        command: [&#34;sh&#34;, &#34;-c&#34;, &#34;echo &#39;scale=10000; 4*a(1)&#39; | bc -l &#34;]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      restartPolicy: Never
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  backoffLimit: 4
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时，相信你对 Kubernetes 的 API 对象已经不再陌生了。在这个 Job 的 YAML 文件里，你肯定一眼就会看到一位“老熟人”：Pod 模板，即 spec.template 字段。</p>
<p>在这个 Pod 模板中，我定义了一个 Ubuntu 镜像的容器（准确地说，是一个安装了 bc 命令的 Ubuntu 镜像），它运行的程序是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">echo &#34;scale=10000; 4*a(1)&#34; | bc -l 
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，bc 命令是 Linux 里的“计算器”；-l 表示，我现在要使用标准数学库；而 a(1)，则是调用数学库中的 arctangent 函数，计算 atan(1)。这是什么意思呢？</p>
<p>中学知识告诉我们：<code>tan(π/4) = 1</code>。所以，<code>4*atan(1)</code>正好就是π，也就是 3.1415926…。</p>
<blockquote>
<p>备注：如果你不熟悉这个知识也不必担心，我也是在查阅资料后才知道的。</p>
</blockquote>
<p>所以，这其实就是一个计算π值的容器。而通过 scale=10000，我指定了输出的小数点后的位数是 10000。在我的计算机上，这个计算大概用时 1 分 54 秒。</p>
<p>但是，跟其他控制器不同的是，Job 对象并不要求你定义一个 spec.selector 来描述要控制哪些 Pod。具体原因，我马上会讲解到。</p>
<p>现在，我们就可以创建这个 Job 了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl create -f job.yaml
</span></span></code></pre></td></tr></table>
</div>
</div><p>在成功创建后，我们来查看一下这个 Job 对象，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl describe jobs/pi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Name:             pi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Namespace:        default
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Selector:         controller-uid=c2db599a-2c9d-11e6-b324-0209dc45a495
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Labels:           controller-uid=c2db599a-2c9d-11e6-b324-0209dc45a495
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                  job-name=pi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Annotations:      &lt;none&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Parallelism:      1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Completions:      1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">..
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Pods Statuses:    0 Running / 1 Succeeded / 0 Failed
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Pod Template:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Labels:       controller-uid=c2db599a-2c9d-11e6-b324-0209dc45a495
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                job-name=pi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Containers:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Volumes:              &lt;none&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Events:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  FirstSeen    LastSeen    Count    From            SubobjectPath    Type        Reason            Message
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ---------    --------    -----    ----            -------------    --------    ------            -------
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  1m           1m          1        {job-controller }                Normal      SuccessfulCreate  Created pod: pi-rq5rl
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，这个 Job 对象在创建后，它的 Pod 模板，被自动加上了一个 controller-uid=&lt; 一个随机字符串 &gt; 这样的 Label。而这个 Job 对象本身，则被自动加上了这个 Label 对应的 Selector，从而 保证了 Job 与它所管理的 Pod 之间的匹配关系。</p>
<p>而 Job Controller 之所以要使用这种携带了 UID 的 Label，就是为了避免不同 Job 对象所管理的 Pod 发生重合。需要注意的是，<strong>这种自动生成的 Label 对用户来说并不友好，所以不太适合推广到 Deployment 等长作业编排对象上。</strong></p>
<p>接下来，我们可以看到这个 Job 创建的 Pod 进入了 Running 状态，这意味着它正在计算 Pi 的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get pods
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME                                READY     STATUS    RESTARTS   AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-rq5rl                            1/1       Running   0          10s
</span></span></code></pre></td></tr></table>
</div>
</div><p>而几分钟后计算结束，这个 Pod 就会进入 Completed 状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get pods
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME                                READY     STATUS      RESTARTS   AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-rq5rl                            0/1       Completed   0          4m
</span></span></code></pre></td></tr></table>
</div>
</div><p>这也是我们需要在 Pod 模板中定义 restartPolicy=Never 的原因：离线计算的 Pod 永远都不应该被重启，否则它们会再重新计算一遍。</p>
<blockquote>
<p>事实上，restartPolicy 在 Job 对象里只允许被设置为 Never 和 OnFailure；而在 Deployment 对象里，restartPolicy 则只允许被设置为 Always。</p>
</blockquote>
<p>此时，我们通过 kubectl logs 查看一下这个 Pod 的日志，就可以看到计算得到的 Pi 值已经被打印了出来：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl logs pi-rq5rl
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">3.141592653589793238462643383279...
</span></span></code></pre></td></tr></table>
</div>
</div><p>这时候，你一定会想到这样一个问题，<strong>如果这个离线作业失败了要怎么办？</strong></p>
<p>比如，我们在这个例子中<strong>定义了 restartPolicy=Never，那么离线作业失败后 Job Controller 就会不断地尝试创建一个新 Pod</strong>，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get pods
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME                                READY     STATUS              RESTARTS   AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-55h89                            0/1       ContainerCreating   0          2s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-tqbcz                            0/1       Error               0          5s
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，这时候会不断地有新 Pod 被创建出来。</p>
<p>当然，这个尝试肯定不能无限进行下去。所以，我们就在 Job 对象的 spec.backoffLimit 字段里定义了重试次数为 4（即，backoffLimit=4），而这个字段的默认值是 6。</p>
<p>需要注意的是，Job Controller 重新创建 Pod 的间隔是呈指数增加的，即下一次重新创建 Pod 的动作会分别发生在 10 s、20 s、40 s …后。</p>
<p>而如果你<strong>定义的 restartPolicy=OnFailure，那么离线作业失败后，Job Controller 就不会去尝试创建新的 Pod。但是，它会不断地尝试重启 Pod 里的容器</strong>。这也正好对应了 restartPolicy 的含义（你也可以借此机会再回顾一下第 15 篇文章<a href="./40466.md">《深入解析 Pod 对象（二）：使用进阶》</a>中的相关内容）。</p>
<p>如前所述，当一个 Job 的 Pod 运行结束后，它会进入 Completed 状态。但是，如果这个 Pod 因为某种原因一直不肯结束呢？</p>
<p>在 Job 的 API 对象里，有一个 spec.activeDeadlineSeconds 字段可以设置最长运行时间，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> backoffLimit: 5
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> activeDeadlineSeconds: 100
</span></span></code></pre></td></tr></table>
</div>
</div><p>一旦运行超过了 100 s，这个 Job 的所有 Pod 都会被终止。并且，你可以在 Pod 的状态里看到终止的原因是 reason: DeadlineExceeded。</p>
<p>以上，就是一个 Job API 对象最主要的概念和用法了。不过，离线业务之所以被称为 Batch Job，当然是因为它们可以以“Batch”，也就是并行的方式去运行。</p>
<p>接下来，我就来为你讲解一下Job Controller 对并行作业的控制方法。</p>
<p>在 Job 对象中，负责并行控制的参数有两个：</p>
<ol>
<li>spec.parallelism，它定义的是一个 Job 在任意时间最多可以启动多少个 Pod 同时运行；</li>
<li>spec.completions，它定义的是 Job 至少要完成的 Pod 数目，即 Job 的最小完成数。</li>
</ol>
<p>这两个参数听起来有点儿抽象，所以我准备了一个例子来帮助你理解。</p>
<p>现在，我在之前计算 Pi 值的 Job 里，添加这两个参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: batch/v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: Job
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: pi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  parallelism: 2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  completions: 4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  template:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      containers:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      - name: pi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        image: resouer/ubuntu-bc
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        command: [&#34;sh&#34;, &#34;-c&#34;, &#34;echo &#39;scale=5000; 4*a(1)&#39; | bc -l &#34;]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      restartPolicy: Never
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  backoffLimit: 4
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样，我们就指定了这个 Job 最大的并行数是 2，而最小的完成数是 4。</p>
<p>接下来，我们来创建这个 Job 对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl create -f job.yaml
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，这个 Job 其实也维护了两个状态字段，即 DESIRED 和 SUCCESSFUL，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get job
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME      DESIRED   SUCCESSFUL   AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi        4         0            3s
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，DESIRED 的值，正是 completions 定义的最小完成数。</p>
<p>然后，我们可以看到，这个 Job 首先创建了两个并行运行的 Pod 来计算 Pi：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get pods
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME       READY     STATUS    RESTARTS   AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-5mt88   1/1       Running   0          6s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-gmcq5   1/1       Running   0          6s
</span></span></code></pre></td></tr></table>
</div>
</div><p>而在 40 s 后，这两个 Pod 相继完成计算。</p>
<p>这时我们可以看到，每当有一个 Pod 完成计算进入 Completed 状态时，就会有一个新的 Pod 被自动创建出来，并且快速地从 Pending 状态进入到 ContainerCreating 状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get pods
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME       READY     STATUS    RESTARTS   AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-gmcq5   0/1       Completed   0         40s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-84ww8   0/1       Pending   0         0s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-5mt88   0/1       Completed   0         41s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-62rbt   0/1       Pending   0         0s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> $ kubectl get pods
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME       READY     STATUS    RESTARTS   AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-gmcq5   0/1       Completed   0         40s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-84ww8   0/1       ContainerCreating   0         0s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-5mt88   0/1       Completed   0         41s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-62rbt   0/1       ContainerCreating   0         0s
</span></span></code></pre></td></tr></table>
</div>
</div><p>紧接着，Job Controller 第二次创建出来的两个并行的 Pod 也进入了 Running 状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get pods 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME       READY     STATUS      RESTARTS   AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-5mt88   0/1       Completed   0          54s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-62rbt   1/1       Running     0          13s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-84ww8   1/1       Running     0          14s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-gmcq5   0/1       Completed   0          54s
</span></span></code></pre></td></tr></table>
</div>
</div><p>最终，后面创建的这两个 Pod 也完成了计算，进入了 Completed 状态。</p>
<p>这时，由于所有的 Pod 均已经成功退出，这个 Job 也就执行完了，所以你会看到它的 SUCCESSFUL 字段的值变成了 4：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get pods 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME       READY     STATUS      RESTARTS   AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-5mt88   0/1       Completed   0          5m
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-62rbt   0/1       Completed   0          4m
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-84ww8   0/1       Completed   0          4m
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi-gmcq5   0/1       Completed   0          5m
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> $ kubectl get job
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME      DESIRED   SUCCESSFUL   AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pi        4         4            5m
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过上述 Job 的 DESIRED 和 SUCCESSFUL 字段的关系，我们就可以很容易地理解Job Controller 的工作原理了。</p>
<p>首先，Job Controller 控制的对象，直接就是 Pod。</p>
<p>其次，Job Controller 在控制循环中进行的调谐（Reconcile）操作，是根据实际在 Running 状态 Pod 的数目、已经成功退出的 Pod 的数目，以及 parallelism、completions 参数的值共同计算出在这个周期里，应该创建或者删除的 Pod 数目，然后调用 Kubernetes API 来执行这个操作。</p>
<p>以创建 Pod 为例。在上面计算 Pi 值的这个例子中，当 Job 一开始创建出来时，实际处于 Running 状态的 Pod 数目 =0，已经成功退出的 Pod 数目 =0，而用户定义的 completions，也就是最终用户需要的 Pod 数目 =4。</p>
<p>所以，在这个时刻，需要创建的 Pod 数目 = 最终需要的 Pod 数目 - 实际在 Running 状态 Pod 数目 - 已经成功退出的 Pod 数目 = 4 - 0 - 0= 4。也就是说，Job Controller 需要创建 4 个 Pod 来纠正这个不一致状态。</p>
<p>可是，我们又定义了这个 Job 的 parallelism=2。也就是说，我们规定了每次并发创建的 Pod 个数不能超过 2 个。所以，Job Controller 会对前面的计算结果做一个修正，修正后的期望创建的 Pod 数目应该是：2 个。</p>
<p>这时候，Job Controller 就会并发地向 kube-apiserver 发起两个创建 Pod 的请求。</p>
<p>类似地，如果在这次调谐周期里，Job Controller 发现实际在 Running 状态的 Pod 数目，比 parallelism 还大，那么它就会删除一些 Pod，使两者相等。</p>
<p>综上所述，Job Controller 实际上控制了，作业执行的<strong>并行度</strong>，以及总共需要完成的<strong>任务数</strong>这两个重要参数。而在实际使用时，你需要根据作业的特性，来决定并行度（parallelism）和任务数（completions）的合理取值。</p>
<p>接下来，我再和你分享三种常用的、使用 Job 对象的方法。</p>
<p><strong>第一种用法，也是最简单粗暴的用法：外部管理器 +Job 模板。</strong></p>
<p>这种模式的特定用法是：把 Job 的 YAML 文件定义为一个“模板”，然后用一个外部工具控制这些“模板”来生成 Job。这时，Job 的定义方式如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: batch/v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: Job
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: process-item-$ITEM
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  labels:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    jobgroup: jobexample
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  template:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      name: jobexample
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      labels:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        jobgroup: jobexample
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      containers:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      - name: c
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        image: busybox
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        command: [&#34;sh&#34;, &#34;-c&#34;, &#34;echo Processing item $ITEM &amp;&amp; sleep 5&#34;]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      restartPolicy: Never
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，我们在这个 Job 的 YAML 里，定义了 $ITEM 这样的“变量”。</p>
<p>所以，在控制这种 Job 时，我们只要注意如下两个方面即可：</p>
<ol>
<li>创建 Job 时，替换掉 $ITEM 这样的变量；</li>
<li>所有来自于同一个模板的 Job，都有一个 jobgroup: jobexample 标签，也就是说这一组 Job 使用这样一个相同的标识。</li>
</ol>
<p>而做到第一点非常简单。比如，你可以通过这样一句 shell 把 $ITEM 替换掉：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ mkdir ./jobs
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ for i in apple banana cherry
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">do
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  cat job-tmpl.yaml | sed &#34;s/\$ITEM/$i/&#34; &gt; ./jobs/job-$i.yaml
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">done
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样，一组来自于同一个模板的不同 Job 的 yaml 就生成了。接下来，你就可以通过一句 kubectl create 指令创建这些 Job 了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl create -f ./jobs
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get pods -l jobgroup=jobexample
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME                        READY     STATUS      RESTARTS   AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">process-item-apple-kixwv    0/1       Completed   0          4m
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">process-item-banana-wrsf7   0/1       Completed   0          4m
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">process-item-cherry-dnfu9   0/1       Completed   0          4m
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个模式看起来虽然很“傻”，但却是 Kubernetes 社区里使用 Job 的一个很普遍的模式。</p>
<p>原因很简单：大多数用户在需要管理 Batch Job 的时候，都已经有了一套自己的方案，需要做的往往就是集成工作。这时候，Kubernetes 项目对这些方案来说最有价值的，就是 Job 这个 API 对象。所以，你只需要编写一个外部工具（等同于我们这里的 for 循环）来管理这些 Job 即可。</p>
<p>这种模式最典型的应用，就是 TensorFlow 社区的 KubeFlow 项目。</p>
<p>很容易理解，在这种模式下使用 Job 对象，completions 和 parallelism 这两个字段都应该使用默认值 1，而不应该由我们自行设置。而作业 Pod 的并行控制，应该完全交由外部工具来进行管理（比如，KubeFlow）。</p>
<p><strong>第二种用法：拥有固定任务数目的并行 Job</strong>。</p>
<p>这种模式下，我只关心最后是否有指定数目（spec.completions）个任务成功退出。至于执行时的并行度是多少，我并不关心。</p>
<p>比如，我们这个计算 Pi 值的例子，就是这样一个典型的、拥有固定任务数目（completions=4）的应用场景。它的 parallelism 值是 2；或者，你可以干脆不指定 parallelism，直接使用默认的并行度（即：1）。</p>
<p>此外，你还可以使用一个工作队列（Work Queue）进行任务分发。这时，Job 的 YAML 文件定义如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: batch/v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: Job
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: job-wq-1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  completions: 8
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  parallelism: 2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  template:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      name: job-wq-1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      containers:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      - name: c
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        image: myrepo/job-wq-1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        env:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        - name: BROKER_URL
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          value: amqp://guest:guest@rabbitmq-service:5672
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        - name: QUEUE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          value: job1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      restartPolicy: OnFailure
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以看到，它的 completions 的值是：8，这意味着我们总共要处理的任务数目是 8 个。也就是说，总共会有 8 个任务会被逐一放入工作队列里（你可以运行一个外部小程序作为生产者，来提交任务）。</p>
<p>在这个实例中，我选择充当工作队列的是一个运行在 Kubernetes 里的 RabbitMQ。所以，我们需要在 Pod 模板里定义 BROKER_URL，来作为消费者。</p>
<p>所以，一旦你用 kubectl create 创建了这个 Job，它就会以并发度为 2 的方式，每两个 Pod 一组，创建出 8 个 Pod。每个 Pod 都会去连接 BROKER_URL，从 RabbitMQ 里读取任务，然后各自进行处理。这个 Pod 里的执行逻辑，我们可以用这样一段伪代码来表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/* job-wq-1 的伪代码 */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">queue := newQueue($BROKER_URL, $QUEUE)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">task := queue.Pop()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">process(task)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">exit
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，每个 Pod 只需要将任务信息读取出来，处理完成，然后退出即可。而作为用户，我只关心最终一共有 8 个计算任务启动并且退出，只要这个目标达到，我就认为整个 Job 处理完成了。所以说，这种用法，对应的就是“任务总数固定”的场景。</p>
<p><strong>第三种用法，也是很常用的一个用法：指定并行度（parallelism），但不设置固定的 completions 的值。</strong></p>
<p>此时，你就必须自己想办法，来决定什么时候启动新 Pod，什么时候 Job 才算执行完成。在这种情况下，任务的总数是未知的，所以你不仅需要一个工作队列来负责任务分发，还需要能够判断工作队列已经为空（即：所有的工作已经结束了）。</p>
<p>这时候，Job 的定义基本上没变化，只不过是不再需要定义 completions 的值了而已：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: batch/v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: Job
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: job-wq-2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  parallelism: 2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  template:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      name: job-wq-2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      containers:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      - name: c
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        image: gcr.io/myproject/job-wq-2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        env:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        - name: BROKER_URL
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          value: amqp://guest:guest@rabbitmq-service:5672
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        - name: QUEUE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          value: job2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      restartPolicy: OnFailure
</span></span></code></pre></td></tr></table>
</div>
</div><p>而对应的 Pod 的逻辑会稍微复杂一些，我可以用这样一段伪代码来描述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/* job-wq-2 的伪代码 */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">for !queue.IsEmpty($BROKER_URL, $QUEUE) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  task := queue.Pop()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  process(task)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">print(&#34;Queue empty, exiting&#34;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">exit
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于任务数目的总数不固定，所以每一个 Pod 必须能够知道，自己什么时候可以退出。比如，在这个例子中，我简单地以“队列为空”，作为任务全部完成的标志。所以说，这种用法，对应的是“任务总数不固定”的场景。</p>
<p>不过，在实际的应用中，你需要处理的条件往往会非常复杂。比如，任务完成后的输出、每个任务 Pod 之间是不是有资源的竞争和协同等等。</p>
<p>所以，在今天这篇文章中，我就不再展开 Job 的用法了。因为，在实际场景里，要么干脆就用第一种用法来自己管理作业；要么，这些任务 Pod 之间的关系就不那么“单纯”，甚至还是“有状态应用”（比如，任务的输入 / 输出是在持久化数据卷里）。在这种情况下，我在后面要重点讲解的 Operator，加上 Job 对象一起，可能才能更好的满足实际离线任务的编排需求。</p>
<p>最后，我再来和你分享一个非常有用的 Job 对象，叫作：CronJob。</p>
<p>顾名思义，CronJob 描述的，正是定时任务。它的 API 对象，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: batch/v1beta1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: CronJob
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: hello
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  schedule: &#34;*/1 * * * *&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  jobTemplate:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      template:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          containers:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          - name: hello
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            image: busybox
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            args:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            - /bin/sh
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            - -c
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            - date; echo Hello from the Kubernetes cluster
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          restartPolicy: OnFailure
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个 YAML 文件中，最重要的关键词就是<strong>jobTemplate</strong>。看到它，你一定恍然大悟，原来 CronJob 是一个 Job 对象的控制器（Controller）！</p>
<p>没错，CronJob 与 Job 的关系，正如同 Deployment 与 Pod 的关系一样。CronJob 是一个专门用来管理 Job 对象的控制器。只不过，它创建和删除 Job 的依据，是 schedule 字段定义的、一个标准的<a href="./Cron.md">Unix Cron</a>格式的表达式。</p>
<p>比如，&quot;*/1 * * * *&quot;。</p>
<p>这个 Cron 表达式里 */1 中的 * 表示从 0 开始，/ 表示“每”，1 表示偏移量。所以，它的意思就是：从 0 开始，每 1 个时间单位执行一次。</p>
<p>那么，时间单位又是什么呢？</p>
<p>Cron 表达式中的五个部分分别代表：分钟、小时、日、月、星期。</p>
<p>所以，上面这句 Cron 表达式的意思是：从当前开始，每分钟执行一次。</p>
<p>而这里要执行的内容，就是 jobTemplate 定义的 Job 了。</p>
<p>所以，这个 CronJob 对象在创建 1 分钟后，就会有一个 Job 产生了，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl create -f ./cronjob.yaml
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">cronjob &#34;hello&#34; created
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> # 一分钟后
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get jobs
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME               DESIRED   SUCCESSFUL   AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">hello-4111706356   1         1         2s
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时，CronJob 对象会记录下这次 Job 执行的时间：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get cronjob hello
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME      SCHEDULE      SUSPEND   ACTIVE    LAST-SCHEDULE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">hello     */1 * * * *   False     0         Thu, 6 Sep 2018 14:34:00 -070
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是，由于定时任务的特殊性，很可能某个 Job 还没有执行完，另外一个新 Job 就产生了。这时候，你可以通过 spec.concurrencyPolicy 字段来定义具体的处理策略。比如：</p>
<ol>
<li>concurrencyPolicy=Allow，这也是默认情况，这意味着这些 Job 可以同时存在；</li>
<li>concurrencyPolicy=Forbid，这意味着不会创建新的 Pod，该创建周期被跳过；</li>
<li>concurrencyPolicy=Replace，这意味着新产生的 Job 会替换旧的、没有执行完的 Job。</li>
</ol>
<p>而如果某一次 Job 创建失败，这次创建就会被标记为“miss”。当在指定的时间窗口内，miss 的数目达到 100 时，那么 CronJob 会停止再创建这个 Job。</p>
<p>这个时间窗口，可以由 spec.startingDeadlineSeconds 字段指定。比如 startingDeadlineSeconds=200，意味着在过去 200 s 里，如果 miss 的数目达到了 100 次，那么这个 Job 就不会被创建执行了。</p>
<h2 id="总结">总结</h2>
<p>在今天这篇文章中，我主要和你分享了 Job 这个离线业务的编排方法，讲解了 completions 和 parallelism 字段的含义，以及 Job Controller 的执行原理。</p>
<p>紧接着，我通过实例和你分享了 Job 对象三种常见的使用方法。但是，根据我在社区和生产环境中的经验，大多数情况下用户还是更倾向于自己控制 Job 对象。所以，相比于这些固定的“模式”，掌握 Job 的 API 对象，和它各个字段的准确含义会更加重要。</p>
<p>最后，我还介绍了一种 Job 的控制器，叫作：CronJob。这也印证了我在前面的分享中所说的：用一个对象控制另一个对象，是 Kubernetes 编排的精髓所在。</p>
<h2 id="思考题">思考题</h2>
<p>根据 Job 控制器的工作原理，如果你定义的 parallelism 比 completions 还大的话，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> parallelism: 4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> completions: 2
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么，这个 Job 最开始创建的时候，会同时启动几个 Pod 呢？原因是什么？</p>
<p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/e870b7df0db49509e735e6becd4a9a9a.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes/">深入剖析Kubernetes</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/etcd%E5%AE%9E%E6%88%98%E8%AF%BE/22__%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E8%A7%A3%E6%9E%90etcd%E5%9C%A8api_gateway%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BA%94%E7%94%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">22__配置及服务发现：解析etcd在API_Gateway开源项目中应用</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/22__%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0%E7%82%AB%E9%85%B7%E7%9A%84%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/">
            <span class="next-text nav-default">22__如何构造炫酷的动画效果？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
