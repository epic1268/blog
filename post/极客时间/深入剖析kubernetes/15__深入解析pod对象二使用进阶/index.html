<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>15__深入解析Pod对象（二）：使用进阶 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是张磊。今天我和你分享的主题是：深入解析 Pod 对象之使用进阶。
在上一篇文章中，我深入解析了 Pod 的 API 对象，讲解了 Pod 和 Container 的关系。
作为 Kubernetes 项目里最核心的编排对象，Pod 携带的信息非常丰富。其中，资源定义（比如 CPU、内存等），以及调度相关的字段，我会在后面专门讲解调度器时再进行深入的分析。在本篇，我们就先从一种特殊的 Volume 开始，来帮助你更加深入地理解 Pod 对象各个重要字段的含义。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes/15__%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90pod%E5%AF%B9%E8%B1%A1%E4%BA%8C%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes/15__%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90pod%E5%AF%B9%E8%B1%A1%E4%BA%8C%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="15__深入解析Pod对象（二）：使用进阶">
  <meta property="og:description" content="你好，我是张磊。今天我和你分享的主题是：深入解析 Pod 对象之使用进阶。
在上一篇文章中，我深入解析了 Pod 的 API 对象，讲解了 Pod 和 Container 的关系。
作为 Kubernetes 项目里最核心的编排对象，Pod 携带的信息非常丰富。其中，资源定义（比如 CPU、内存等），以及调度相关的字段，我会在后面专门讲解调度器时再进行深入的分析。在本篇，我们就先从一种特殊的 Volume 开始，来帮助你更加深入地理解 Pod 对象各个重要字段的含义。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="深入剖析Kubernetes">

  <meta itemprop="name" content="15__深入解析Pod对象（二）：使用进阶">
  <meta itemprop="description" content="你好，我是张磊。今天我和你分享的主题是：深入解析 Pod 对象之使用进阶。
在上一篇文章中，我深入解析了 Pod 的 API 对象，讲解了 Pod 和 Container 的关系。
作为 Kubernetes 项目里最核心的编排对象，Pod 携带的信息非常丰富。其中，资源定义（比如 CPU、内存等），以及调度相关的字段，我会在后面专门讲解调度器时再进行深入的分析。在本篇，我们就先从一种特殊的 Volume 开始，来帮助你更加深入地理解 Pod 对象各个重要字段的含义。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="8200">
  <meta itemprop="keywords" content="深入剖析Kubernetes">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="15__深入解析Pod对象（二）：使用进阶">
  <meta name="twitter:description" content="你好，我是张磊。今天我和你分享的主题是：深入解析 Pod 对象之使用进阶。
在上一篇文章中，我深入解析了 Pod 的 API 对象，讲解了 Pod 和 Container 的关系。
作为 Kubernetes 项目里最核心的编排对象，Pod 携带的信息非常丰富。其中，资源定义（比如 CPU、内存等），以及调度相关的字段，我会在后面专门讲解调度器时再进行深入的分析。在本篇，我们就先从一种特殊的 Volume 开始，来帮助你更加深入地理解 Pod 对象各个重要字段的含义。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">15__深入解析Pod对象（二）：使用进阶</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 8200 字 </span>
          <span class="more-meta"> 预计阅读 17 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#总结">总结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是张磊。今天我和你分享的主题是：深入解析 Pod 对象之使用进阶。</p>
<p>在上一篇文章中，我深入解析了 Pod 的 API 对象，讲解了 Pod 和 Container 的关系。</p>
<p>作为 Kubernetes 项目里最核心的编排对象，Pod 携带的信息非常丰富。其中，资源定义（比如 CPU、内存等），以及调度相关的字段，我会在后面专门讲解调度器时再进行深入的分析。在本篇，我们就先从一种特殊的 Volume 开始，来帮助你更加深入地理解 Pod 对象各个重要字段的含义。</p>
<p>这种特殊的 Volume，叫作 Projected Volume，你可以把它翻译为“投射数据卷”。</p>
<blockquote>
<p>备注：Projected Volume 是 Kubernetes v1.11 之后的新特性</p>
</blockquote>
<p>这是什么意思呢？</p>
<p>在 Kubernetes 中，有几种特殊的 Volume，它们存在的意义不是为了存放容器里的数据，也不是用来进行容器和宿主机之间的数据交换。这些特殊 Volume 的作用，是为容器提供预先定义好的数据。所以，从容器的角度来看，这些 Volume 里的信息就是仿佛是<strong>被 Kubernetes“投射”（Project）进入容器当中的</strong>。这正是 Projected Volume 的含义。</p>
<p>到目前为止，Kubernetes 支持的 Projected Volume 一共有四种：</p>
<ol>
<li>Secret；</li>
<li>ConfigMap；</li>
<li>Downward API；</li>
<li>ServiceAccountToken。</li>
</ol>
<p>在今天这篇文章中，我首先和你分享的是 Secret。它的作用，是帮你把 Pod 想要访问的加密数据，存放到 Etcd 中。然后，你就可以通过在 Pod 的容器里挂载 Volume 的方式，访问到这些 Secret 里保存的信息了。</p>
<p>Secret 最典型的使用场景，莫过于存放数据库的 Credential 信息，比如下面这个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: Pod
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: test-projected-volume 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  containers:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  - name: test-secret-volume
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    image: busybox
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    args:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - sleep
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - &#34;86400&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    volumeMounts:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: mysql-cred
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      mountPath: &#34;/projected-volume&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      readOnly: true
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  volumes:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  - name: mysql-cred
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    projected:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      sources:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      - secret:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          name: user
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      - secret:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          name: pass
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个 Pod 中，我定义了一个简单的容器。它声明挂载的 Volume，并不是常见的 emptyDir 或者 hostPath 类型，而是 projected 类型。而这个 Volume 的数据来源（sources），则是名为 user 和 pass 的 Secret 对象，分别对应的是数据库的用户名和密码。</p>
<p>这里用到的数据库的用户名、密码，正是以 Secret 对象的方式交给 Kubernetes 保存的。完成这个操作的指令，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cat ./username.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">admin
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cat ./password.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">c1oudc0w!
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> $ kubectl create secret generic user --from-file=./username.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl create secret generic pass --from-file=./password.txt
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，username.txt 和 password.txt 文件里，存放的就是用户名和密码；而 user 和 pass，则是我为 Secret 对象指定的名字。而我想要查看这些 Secret 对象的话，只要执行一条 kubectl get 命令就可以了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get secrets
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME           TYPE                                DATA      AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">user          Opaque                                1         51s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pass          Opaque                                1         51s
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然，除了使用 kubectl create secret 指令外，我也可以直接通过编写 YAML 文件的方式来创建这个 Secret 对象，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: Secret
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: mysecret
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">type: Opaque
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">data:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  user: YWRtaW4=
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  pass: MWYyZDFlMmU2N2Rm
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，通过编写 YAML 文件创建出来的 Secret 对象只有一个。但它的 data 字段，却以 Key-Value 的格式保存了两份 Secret 数据。其中，“user”就是第一份数据的 Key，“pass”是第二份数据的 Key。</p>
<p>需要注意的是，Secret 对象要求这些数据必须是经过 Base64 转码的，以免出现明文密码的安全隐患。这个转码操作也很简单，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ echo -n &#39;admin&#39; | base64
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">YWRtaW4=
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ echo -n &#39;1f2d1e2e67df&#39; | base64
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">MWYyZDFlMmU2N2Rm
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里需要注意的是，像这样创建的 Secret 对象，它里面的内容仅仅是经过了转码，而并没有被加密。在真正的生产环境中，你需要在 Kubernetes 中开启 Secret 的加密插件，增强数据的安全性。关于开启 Secret 加密插件的内容，我会在后续专门讲解 Secret 的时候，再做进一步说明。</p>
<p>接下来，我们尝试一下创建这个 Pod：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl create -f test-projected-volume.yaml
</span></span></code></pre></td></tr></table>
</div>
</div><p>当 Pod 变成 Running 状态之后，我们再验证一下这些 Secret 对象是不是已经在容器里了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl exec -it test-projected-volume -- /bin/sh
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ ls /projected-volume/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">user
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pass
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cat /projected-volume/user
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">root
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cat /projected-volume/pass
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">1f2d1e2e67df
</span></span></code></pre></td></tr></table>
</div>
</div><p>从返回结果中，我们可以看到，保存在 Etcd 里的用户名和密码信息，已经以文件的形式出现在了容器的 Volume 目录里。而这个文件的名字，就是 kubectl create secret 指定的 Key，或者说是 Secret 对象的 data 字段指定的 Key。</p>
<p>更重要的是，像这样通过挂载方式进入到容器里的 Secret，一旦其对应的 Etcd 里的数据被更新，这些 Volume 里的文件内容，同样也会被更新。其实，<strong>这是 kubelet 组件在定时维护这些 Volume。</strong></p>
<p>需要注意的是，这个更新可能会有一定的延时。所以<strong>在编写应用程序时，在发起数据库连接的代码处写好重试和超时的逻辑，绝对是个好习惯。</strong></p>
<p><strong>与 Secret 类似的是 ConfigMap</strong>，它与 Secret 的区别在于，ConfigMap 保存的是不需要加密的、应用所需的配置信息。而 ConfigMap 的用法几乎与 Secret 完全相同：你可以使用 kubectl create configmap 从文件或者目录创建 ConfigMap，也可以直接编写 ConfigMap 对象的 YAML 文件。</p>
<p>比如，一个 Java 应用所需的配置文件（.properties 文件），就可以通过下面这样的方式保存在 ConfigMap 里：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># .properties 文件的内容
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cat example/ui.properties
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">color.good=purple
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">color.bad=yellow
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">allow.textmode=true
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">how.nice.to.look=fairlyNice
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> # 从.properties 文件创建 ConfigMap
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl create configmap ui-config --from-file=example/ui.properties
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> # 查看这个 ConfigMap 里保存的信息 (data)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get configmaps ui-config -o yaml
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">data:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ui.properties: |
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    color.good=purple
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    color.bad=yellow
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    allow.textmode=true
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    how.nice.to.look=fairlyNice
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: ConfigMap
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: ui-config
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ...
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>备注：kubectl get -o yaml 这样的参数，会将指定的 Pod API 对象以 YAML 的方式展示出来。</p>
</blockquote>
<p><strong>接下来是 Downward API</strong>，它的作用是：让 Pod 里的容器能够直接获取到这个 Pod API 对象本身的信息。</p>
<p>举个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: Pod
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: test-downwardapi-volume
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  labels:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    zone: us-est-coast
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cluster: test-cluster1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    rack: rack-22
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  containers:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: client-container
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      image: k8s.gcr.io/busybox
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      command: [&#34;sh&#34;, &#34;-c&#34;]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      args:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      - while true; do
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          if [[ -e /etc/podinfo/labels ]]; then
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            echo -en &#39;\n\n&#39;; cat /etc/podinfo/labels; fi;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          sleep 5;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        done;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      volumeMounts:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        - name: podinfo
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          mountPath: /etc/podinfo
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          readOnly: false
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  volumes:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: podinfo
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      projected:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        sources:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        - downwardAPI:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            items:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              - path: &#34;labels&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                fieldRef:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                  fieldPath: metadata.labels
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个 Pod 的 YAML 文件中，我定义了一个简单的容器，声明了一个 projected 类型的 Volume。只不过这次 Volume 的数据来源，变成了 Downward API。而这个 Downward API Volume，则声明了要暴露 Pod 的 metadata.labels 信息给容器。</p>
<p>通过这样的声明方式，当前 Pod 的 Labels 字段的值，就会被 Kubernetes 自动挂载成为容器里的 /etc/podinfo/labels 文件。</p>
<p>而这个容器的启动命令，则是不断打印出 /etc/podinfo/labels 里的内容。所以，当我创建了这个 Pod 之后，就可以通过 kubectl logs 指令，查看到这些 Labels 字段被打印出来，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl create -f dapi-volume.yaml
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl logs test-downwardapi-volume
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">cluster=&#34;test-cluster1&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">rack=&#34;rack-22&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">zone=&#34;us-est-coast&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>目前，Downward API 支持的字段已经非常丰富了，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">1. 使用 fieldRef 可以声明使用:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec.nodeName - 宿主机名字
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">status.hostIP - 宿主机 IP
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata.name - Pod 的名字
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata.namespace - Pod 的 Namespace
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">status.podIP - Pod 的 IP
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec.serviceAccountName - Pod 的 Service Account 的名字
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata.uid - Pod 的 UID
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata.labels[&#39;&lt;KEY&gt;&#39;] - 指定 &lt;KEY&gt; 的 Label 值
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata.annotations[&#39;&lt;KEY&gt;&#39;] - 指定 &lt;KEY&gt; 的 Annotation 值
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata.labels - Pod 的所有 Label
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata.annotations - Pod 的所有 Annotation
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> 2. 使用 resourceFieldRef 可以声明使用:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">容器的 CPU limit
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">容器的 CPU request
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">容器的 memory limit
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">容器的 memory request
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面这个列表的内容，随着 Kubernetes 项目的发展肯定还会不断增加。所以这里列出来的信息仅供参考，你在使用 Downward API 时，还是要记得去查阅一下官方文档。</p>
<p>不过，需要注意的是，Downward API 能够获取到的信息，<strong>一定是 Pod 里的容器进程启动之前就能够确定下来的信息</strong>。而如果你想要获取 Pod 容器运行后才会出现的信息，比如，容器进程的 PID，那就肯定不能使用 Downward API 了，而应该考虑在 Pod 里定义一个 sidecar 容器。</p>
<p>其实，Secret、ConfigMap，以及 Downward API 这三种 Projected Volume 定义的信息，大多还可以通过环境变量的方式出现在容器里。但是，通过环境变量获取这些信息的方式，不具备自动更新的能力。所以，一般情况下，我都建议你使用 Volume 文件的方式获取这些信息。</p>
<p>在明白了 Secret 之后，我再为你讲解 Pod 中一个与它密切相关的概念：Service Account。</p>
<p>相信你一定有过这样的想法：我现在有了一个 Pod，我能不能在这个 Pod 里安装一个 Kubernetes 的 Client，这样就可以从容器里直接访问并且操作这个 Kubernetes 的 API 了呢？</p>
<p>这当然是可以的。</p>
<p>不过，你首先要解决 API Server 的授权问题。</p>
<p>Service Account 对象的作用，就是 Kubernetes 系统内置的一种“服务账户”，它是 Kubernetes 进行权限分配的对象。比如，Service Account A，可以只被允许对 Kubernetes API 进行 GET 操作，而 Service Account B，则可以有 Kubernetes API 的所有操作的权限。</p>
<p>像这样的 Service Account 的授权信息和文件，实际上保存在它所绑定的一个特殊的 Secret 对象里的。这个特殊的 Secret 对象，就叫作<strong>ServiceAccountToken</strong>。任何运行在 Kubernetes 集群上的应用，都必须使用这个 ServiceAccountToken 里保存的授权信息，也就是 Token，才可以合法地访问 API Server。</p>
<p>所以说，Kubernetes 项目的 Projected Volume 其实只有三种，因为第四种 ServiceAccountToken，只是一种特殊的 Secret 而已。</p>
<p>另外，为了方便使用，Kubernetes 已经为你提供了一个的默认“服务账户”（default Service Account）。并且，任何一个运行在 Kubernetes 里的 Pod，都可以直接使用这个默认的 Service Account，而无需显示地声明挂载它。</p>
<p><strong>这是如何做到的呢？</strong></p>
<p>当然还是靠 Projected Volume 机制。</p>
<p>如果你查看一下任意一个运行在 Kubernetes 集群里的 Pod，就会发现，每一个 Pod，都已经自动声明一个类型是 Secret、名为 default-token-xxxx 的 Volume，然后 自动挂载在每个容器的一个固定目录上。比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="n">kubectl</span> <span class="n">describe</span> <span class="n">pod</span> <span class="n">nginx</span><span class="o">-</span><span class="n">deployment</span><span class="o">-</span><span class="mi">5</span><span class="n">c678cfb6d</span><span class="o">-</span><span class="n">lg9lw</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Containers</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Mounts</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">/</span><span class="k">var</span><span class="o">/</span><span class="n">run</span><span class="o">/</span><span class="n">secrets</span><span class="o">/</span><span class="n">kubernetes</span><span class="o">.</span><span class="n">io</span><span class="o">/</span><span class="n">serviceaccount</span> <span class="n">from</span> <span class="n">default</span><span class="o">-</span><span class="n">token</span><span class="o">-</span><span class="n">s8rbq</span> <span class="p">(</span><span class="n">ro</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Volumes</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">default</span><span class="o">-</span><span class="n">token</span><span class="o">-</span><span class="n">s8rbq</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Type</span><span class="p">:</span>       <span class="n">Secret</span> <span class="p">(</span><span class="n">a</span> <span class="n">volume</span> <span class="n">populated</span> <span class="n">by</span> <span class="n">a</span> <span class="n">Secret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">SecretName</span><span class="p">:</span>  <span class="n">default</span><span class="o">-</span><span class="n">token</span><span class="o">-</span><span class="n">s8rbq</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Optional</span><span class="p">:</span>    <span class="bp">false</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个 Secret 类型的 Volume，正是默认 Service Account 对应的 ServiceAccountToken。所以说，Kubernetes 其实在每个 Pod 创建的时候，自动在它的 spec.volumes 部分添加上了默认 ServiceAccountToken 的定义，然后自动给每个容器加上了对应的 volumeMounts 字段。这个过程对于用户来说是完全透明的。</p>
<p>这样，一旦 Pod 创建完成，容器里的应用就可以直接从这个默认 ServiceAccountToken 的挂载目录里访问到授权信息和文件。这个容器内的路径在 Kubernetes 里是固定的，即：/var/run/secrets/kubernetes.io/serviceaccount，而这个 Secret 类型的 Volume 里面的内容如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="n">ls</span> <span class="o">/</span><span class="k">var</span><span class="o">/</span><span class="n">run</span><span class="o">/</span><span class="n">secrets</span><span class="o">/</span><span class="n">kubernetes</span><span class="o">.</span><span class="n">io</span><span class="o">/</span><span class="n">serviceaccount</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ca</span><span class="o">.</span><span class="n">crt</span> <span class="n">namespace</span>  <span class="n">token</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以，你的应用程序只要直接加载这些授权文件，就可以访问并操作 Kubernetes API 了。而且，如果你使用的是 Kubernetes 官方的 Client 包（<code>k8s.io/client-go</code>）的话，它还可以自动加载这个目录下的文件，你不需要做任何配置或者编码操作。</p>
<p><strong>这种把 Kubernetes 客户端以容器的方式运行在集群里，然后使用 default Service Account 自动授权的方式，被称作“InClusterConfig”，也是我最推荐的进行 Kubernetes API 编程的授权方式。</strong></p>
<p>当然，考虑到自动挂载默认 ServiceAccountToken 的潜在风险，Kubernetes 允许你设置默认不为 Pod 里的容器自动挂载这个 Volume。</p>
<p>除了这个默认的 Service Account 外，我们很多时候还需要创建一些我们自己定义的 Service Account，来对应不同的权限设置。这样，我们的 Pod 里的容器就可以通过挂载这些 Service Account 对应的 ServiceAccountToken，来使用这些自定义的授权信息。在后面讲解为 Kubernetes 开发插件的时候，我们将会实践到这个操作。</p>
<p>接下来，我们再来看 Pod 的另一个重要的配置：容器健康检查和恢复机制。</p>
<p>在 Kubernetes 中，你可以为 Pod 里的容器定义一个健康检查“探针”（Probe）。这样，kubelet 就会根据这个 Probe 的返回值决定这个容器的状态，而不是直接以容器进行是否运行（来自 Docker 返回的信息）作为依据。这种机制，是生产环境中保证应用健康存活的重要手段。</p>
<p>我们一起来看一个 Kubernetes 文档中的例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: Pod
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  labels:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    test: liveness
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: test-liveness-exec
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  containers:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  - name: liveness
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    image: busybox
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    args:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - /bin/sh
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - -c
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    livenessProbe:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      exec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        command:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        - cat
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        - /tmp/healthy
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      initialDelaySeconds: 5
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      periodSeconds: 5
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个 Pod 中，我们定义了一个有趣的容器。它在启动之后做的第一件事，就是在 /tmp 目录下创建了一个 healthy 文件，以此作为自己已经正常运行的标志。而 30 s 过后，它会把这个文件删除掉。</p>
<p>与此同时，我们定义了一个这样的 livenessProbe（健康检查）。它的类型是 exec，这意味着，它会在容器启动后，在容器里面执行一句我们指定的命令，比如：“cat /tmp/healthy”。这时，如果这个文件存在，这条命令的返回值就是 0，Pod 就会认为这个容器不仅已经启动，而且是健康的。这个健康检查，在容器启动 5 s 后开始执行（initialDelaySeconds: 5），每 5 s 执行一次（periodSeconds: 5）。</p>
<p>现在，让我们来<strong>具体实践一下这个过程</strong>。</p>
<p>首先，创建这个 Pod：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl create -f test-liveness-exec.yaml
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，查看这个 Pod 的状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get pod
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME                READY     STATUS    RESTARTS   AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">test-liveness-exec   1/1       Running   0          10s
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，由于已经通过了健康检查，这个 Pod 就进入了 Running 状态。</p>
<p>而 30 s 之后，我们再查看一下 Pod 的 Events：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl describe pod test-liveness-exec
</span></span></code></pre></td></tr></table>
</div>
</div><p>你会发现，这个 Pod 在 Events 报告了一个异常：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">FirstSeen LastSeen    Count   From            SubobjectPath           Type        Reason      Message
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--------- --------    -----   ----            -------------           --------    ------      -------
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2s        2s      1   {kubelet worker0}   spec.containers{liveness}   Warning     Unhealthy   Liveness probe failed: cat: can&#39;t open &#39;/tmp/healthy&#39;: No such file or directory
</span></span></code></pre></td></tr></table>
</div>
</div><p>显然，这个健康检查探查到 /tmp/healthy 已经不存在了，所以它报告容器是不健康的。那么接下来会发生什么呢？</p>
<p>我们不妨再次查看一下这个 Pod 的状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get pod test-liveness-exec
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME           READY     STATUS    RESTARTS   AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">liveness-exec   1/1       Running   1          1m
</span></span></code></pre></td></tr></table>
</div>
</div><p>这时我们发现，Pod 并没有进入 Failed 状态，而是保持了 Running 状态。这是为什么呢？</p>
<p>其实，如果你注意到 RESTARTS 字段从 0 到 1 的变化，就明白原因了：这个异常的容器已经被 Kubernetes 重启了。在这个过程中，Pod 保持 Running 状态不变。</p>
<p>需要注意的是：Kubernetes 中并没有 Docker 的 Stop 语义。所以虽然是 Restart（重启），但实际却是重新创建了容器。</p>
<p>这个功能就是 Kubernetes 里的<strong>Pod 恢复机制</strong>，也叫 restartPolicy。它是 Pod 的 Spec 部分的一个标准字段（pod.spec.restartPolicy），默认值是 Always，即：任何时候这个容器发生了异常，它一定会被重新创建。</p>
<p>但一定要强调的是，Pod 的恢复过程，永远都是发生在当前节点上，而不会跑到别的节点上去。事实上，一旦一个 Pod 与一个节点（Node）绑定，除非这个绑定发生了变化（pod.spec.node 字段被修改），否则它永远都不会离开这个节点。这也就意味着，如果这个宿主机宕机了，这个 Pod 也不会主动迁移到其他节点上去。</p>
<p>而如果你想让 Pod 出现在其他的可用节点上，就必须使用 Deployment 这样的“控制器”来管理 Pod，哪怕你只需要一个 Pod 副本。这就是我在第 12 篇文章<a href="./40008.md">《牛刀小试：我的第一个容器化应用》</a>最后给你留的思考题的答案，即一个单 Pod 的 Deployment 与一个 Pod 最主要的区别。</p>
<p>而作为用户，你还可以通过设置 restartPolicy，改变 Pod 的恢复策略。除了 Always，它还有 OnFailure 和 Never 两种情况：</p>
<ul>
<li>Always：在任何情况下，只要容器不在运行状态，就自动重启容器；</li>
<li>OnFailure: 只在容器 异常时才自动重启容器；</li>
<li>Never: 从来不重启容器。</li>
</ul>
<p>在实际使用时，我们需要根据应用运行的特性，合理设置这三种恢复策略。</p>
<p>比如，一个 Pod，它只计算 1+1=2，计算完成输出结果后退出，变成 Succeeded 状态。这时，你如果再用 restartPolicy=Always 强制重启这个 Pod 的容器，就没有任何意义了。</p>
<p>而如果你要关心这个容器退出后的上下文环境，比如容器退出后的日志、文件和目录，就需要将 restartPolicy 设置为 Never。因为一旦容器被自动重新创建，这些内容就有可能丢失掉了（被垃圾回收了）。</p>
<p>值得一提的是，Kubernetes 的官方文档，把 restartPolicy 和 Pod 里容器的状态，以及 Pod 状态的对应关系，<a href="./pod-lifecycle.md#example-states">总结了非常复杂的一大堆情况</a>。实际上，你根本不需要死记硬背这些对应关系，只要记住如下两个基本的设计原理即可：</p>
<ol>
<li><strong>只要 Pod 的 restartPolicy 指定的策略允许重启异常的容器（比如：Always），那么这个 Pod 就会保持 Running 状态，并进行容器重启</strong>。否则，Pod 就会进入 Failed 状态。</li>
<li><strong>对于包含多个容器的 Pod，只有它里面所有的容器都进入异常状态后，Pod 才会进入 Failed 状态</strong>。在此之前，Pod 都是 Running 状态。此时，Pod 的 READY 字段会显示正常容器的个数，比如：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get pod test-liveness-exec
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">NAME           READY     STATUS    RESTARTS   AGE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">liveness-exec   0/1       Running   1          1m
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以，假如一个 Pod 里只有一个容器，然后这个容器异常退出了。那么，只有当 restartPolicy=Never 时，这个 Pod 才会进入 Failed 状态。而其他情况下，由于 Kubernetes 都可以重启这个容器，所以 Pod 的状态保持 Running 不变。</p>
<p>而如果这个 Pod 有多个容器，仅有一个容器异常退出，它就始终保持 Running 状态，哪怕即使 restartPolicy=Never。只有当所有容器也异常退出之后，这个 Pod 才会进入 Failed 状态。</p>
<p>其他情况，都可以以此类推出来。</p>
<p>现在，我们一起回到前面提到的 livenessProbe 上来。</p>
<p>除了在容器中执行命令外，livenessProbe 也可以定义为发起 HTTP 或者 TCP 请求的方式，定义格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">livenessProbe:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     httpGet:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       path: /healthz
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       port: 8080
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       httpHeaders:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       - name: X-Custom-Header
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         value: Awesome
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       initialDelaySeconds: 3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       periodSeconds: 3
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    livenessProbe:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      tcpSocket:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        port: 8080
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      initialDelaySeconds: 15
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      periodSeconds: 20
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以，你的 Pod 其实可以暴露一个健康检查 URL（比如 /healthz），或者直接让健康检查去检测应用的监听端口。这两种配置方法，在 Web 服务类的应用中非常常用。</p>
<p>在 Kubernetes 的 Pod 中，还有一个叫 readinessProbe 的字段。虽然它的用法与 livenessProbe 类似，但作用却大不一样。readinessProbe 检查结果的成功与否，决定的这个 Pod 是不是能被通过 Service 的方式访问到，而并不影响 Pod 的生命周期。这部分内容，我会留在讲解 Service 时再重点介绍。</p>
<p>在讲解了这么多字段之后，想必你对 Pod 对象的语义和描述能力，已经有了一个初步的感觉。</p>
<p>这时，你有没有产生这样一个想法：Pod 的字段这么多，我又不可能全记住，Kubernetes 能不能自动给 Pod 填充某些字段呢？</p>
<p>这个需求实际上非常实用。比如，开发人员只需要提交一个基本的、非常简单的 Pod YAML，Kubernetes 就可以自动给对应的 Pod 对象加上其他必要的信息，比如 labels，annotations，volumes 等等。而这些信息，可以是运维人员事先定义好的。</p>
<p>这么一来，开发人员编写 Pod YAML 的门槛，就被大大降低了。</p>
<p>所以，这个叫作 PodPreset（Pod 预设置）的功能 已经出现在了 v1.11 版本的 Kubernetes 中。</p>
<p>举个例子，现在开发人员编写了如下一个 pod.yaml 文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: Pod
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: website
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  labels:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    app: website
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    role: frontend
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  containers:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: website
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      image: nginx
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ports:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        - containerPort: 80
</span></span></code></pre></td></tr></table>
</div>
</div><p>作为 Kubernetes 的初学者，你肯定眼前一亮：这不就是我最擅长编写的、最简单的 Pod 嘛。没错，这个 YAML 文件里的字段，想必你现在闭着眼睛也能写出来。</p>
<p>可是，如果运维人员看到了这个 Pod，他一定会连连摇头：这种 Pod 在生产环境里根本不能用啊！</p>
<p>所以，这个时候，运维人员就可以定义一个 PodPreset 对象。在这个对象中，凡是他想在开发人员编写的 Pod 里追加的字段，都可以预先定义好。比如这个 preset.yaml：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: settings.k8s.io/v1alpha1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: PodPreset
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: allow-database
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  selector:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    matchLabels:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      role: frontend
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  env:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: DB_PORT
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      value: &#34;6379&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  volumeMounts:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - mountPath: /cache
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      name: cache-volume
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  volumes:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: cache-volume
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      emptyDir: {}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个 PodPreset 的定义中，首先是一个 selector。这就意味着后面这些追加的定义，只会作用于 selector 所定义的、带有“role: frontend”标签的 Pod 对象，这就可以防止“误伤”。</p>
<p>然后，我们定义了一组 Pod 的 Spec 里的标准字段，以及对应的值。比如，env 里定义了 DB_PORT 这个环境变量，volumeMounts 定义了容器 Volume 的挂载目录，volumes 定义了一个 emptyDir 的 Volume。</p>
<p>接下来，我们假定运维人员先创建了这个 PodPreset，然后开发人员才创建 Pod：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl create -f preset.yaml
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl create -f pod.yaml
</span></span></code></pre></td></tr></table>
</div>
</div><p>这时，Pod 运行起来之后，我们查看一下这个 Pod 的 API 对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl get pod website -o yaml
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: Pod
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: website
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  labels:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    app: website
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    role: frontend
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  annotations:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    podpreset.admission.kubernetes.io/podpreset-allow-database: &#34;resource version&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  containers:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: website
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      image: nginx
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      volumeMounts:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        - mountPath: /cache
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          name: cache-volume
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ports:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        - containerPort: 80
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      env:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        - name: DB_PORT
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          value: &#34;6379&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  volumes:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - name: cache-volume
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      emptyDir: {}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个时候，我们就可以清楚地看到，这个 Pod 里多了新添加的 labels、env、volumes 和 volumeMount 的定义，它们的配置跟 PodPreset 的内容一样。此外，这个 Pod 还被自动加上了一个 annotation 表示这个 Pod 对象被 PodPreset 改动过。</p>
<p>需要说明的是，<strong>PodPreset 里定义的内容，只会在 Pod API 对象被创建之前追加在这个对象本身上，而不会影响任何 Pod 的控制器的定义。</strong></p>
<p>比如，我们现在提交的是一个 nginx-deployment，那么这个 Deployment 对象本身是永远不会被 PodPreset 改变的，被修改的只是这个 Deployment 创建出来的所有 Pod。这一点请务必区分清楚。</p>
<p>这里有一个问题：如果你定义了同时作用于一个 Pod 对象的多个 PodPreset，会发生什么呢？</p>
<p>实际上，Kubernetes 项目会帮你合并（Merge）这两个 PodPreset 要做的修改。而如果它们要做的修改有冲突的话，这些冲突字段就不会被修改。</p>
<h2 id="总结">总结</h2>
<p>在今天这篇文章中，我和你详细介绍了 Pod 对象更高阶的使用方法，希望通过对这些实例的讲解，你可以更深入地理解 Pod API 对象的各个字段。</p>
<p>而在学习这些字段的同时，你还应该认真体会一下 Kubernetes“一切皆对象”的设计思想：比如应用是 Pod 对象，应用的配置是 ConfigMap 对象，应用要访问的密码则是 Secret 对象。</p>
<p>所以，也就自然而然地有了 PodPreset 这样专门用来对 Pod 进行批量化、自动化修改的工具对象。在后面的内容中，我会为你讲解更多的这种对象，还会和你介绍 Kubernetes 项目如何围绕着这些对象进行容器编排。</p>
<p>在本专栏中，Pod 对象相关的知识点非常重要，它是接下来 Kubernetes 能够描述和编排各种复杂应用的基石所在，希望你能够继续多实践、多体会。</p>
<h2 id="思考题">思考题</h2>
<p>在没有 Kubernetes 的时候，你是通过什么方法进行应用的健康检查的？Kubernetes 的 livenessProbe 和 readinessProbe 提供的几种探测机制，是否能满足你的需求？</p>
<p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/e870b7df0db49509e735e6becd4a9a9a.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes/">深入剖析Kubernetes</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%9D%A2%E8%AF%95%E7%8E%B0%E5%9C%BA/15__%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%BC%80%E5%9C%BA%E7%BB%99%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E5%8A%A0%E7%89%B9%E6%95%88/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">15__如何做好开场：给自我介绍加“特效”</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A6%82%E4%BD%95%E7%9C%8B%E6%87%82%E4%B8%80%E5%B9%85%E7%94%BB/15__%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E7%94%BB%E6%89%8D%E6%98%AF%E4%B8%80%E5%B9%85%E5%A5%BD%E7%94%BB/">
            <span class="next-text nav-default">15__什么样的画才是一幅好画？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
