<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>28__PV、PVC、StorageClass，这些到底在说啥？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是张磊。今天我和你分享的主题是：PV、PVC、StorageClass，这些到底在说啥？
在前面的文章中，我重点为你分析了 Kubernetes 的各种编排能力。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes/28__pvpvcstorageclass%E8%BF%99%E4%BA%9B%E5%88%B0%E5%BA%95%E5%9C%A8%E8%AF%B4%E5%95%A5/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes/28__pvpvcstorageclass%E8%BF%99%E4%BA%9B%E5%88%B0%E5%BA%95%E5%9C%A8%E8%AF%B4%E5%95%A5/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="28__PV、PVC、StorageClass，这些到底在说啥？">
  <meta property="og:description" content="你好，我是张磊。今天我和你分享的主题是：PV、PVC、StorageClass，这些到底在说啥？
在前面的文章中，我重点为你分析了 Kubernetes 的各种编排能力。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="深入剖析Kubernetes">

  <meta itemprop="name" content="28__PV、PVC、StorageClass，这些到底在说啥？">
  <meta itemprop="description" content="你好，我是张磊。今天我和你分享的主题是：PV、PVC、StorageClass，这些到底在说啥？
在前面的文章中，我重点为你分析了 Kubernetes 的各种编排能力。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7035">
  <meta itemprop="keywords" content="深入剖析Kubernetes">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="28__PV、PVC、StorageClass，这些到底在说啥？">
  <meta name="twitter:description" content="你好，我是张磊。今天我和你分享的主题是：PV、PVC、StorageClass，这些到底在说啥？
在前面的文章中，我重点为你分析了 Kubernetes 的各种编排能力。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">28__PV、PVC、StorageClass，这些到底在说啥？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7035 字 </span>
          <span class="more-meta"> 预计阅读 15 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#总结">总结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是张磊。今天我和你分享的主题是：PV、PVC、StorageClass，这些到底在说啥？</p>
<p>在前面的文章中，我重点为你分析了 Kubernetes 的各种编排能力。</p>
<p>在这些讲解中，你应该已经发现，容器化一个应用比较麻烦的地方，莫过于对其“状态”的管理。而最常见的“状态”，又莫过于存储状态了。</p>
<p>所以，从今天这篇文章开始，我会<strong>通过 4 篇文章为你剖析 Kubernetes 项目处理容器持久化存储的核心原理</strong>，从而帮助你更好地理解和使用这部分内容。</p>
<p>首先，我们来回忆一下我在第 19 篇文章<a href="./41154.md">《深入理解 StatefulSet（二）：存储状态》</a>中，和你分享 StatefulSet 如何管理存储状态的时候，介绍过的Persistent Volume（PV）和 Persistent Volume Claim（PVC）这套持久化存储体系。</p>
<p>其中，<strong>PV 描述的，是持久化存储数据卷</strong>。这个 API 对象主要定义的是一个持久化存储在宿主机上的目录，比如一个 NFS 的挂载目录。</p>
<p>通常情况下，PV 对象是由运维人员事先创建在 Kubernetes 集群里待用的。比如，运维人员可以定义这样一个 NFS 类型的 PV，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: PersistentVolume
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: nfs
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  storageClassName: manual
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  capacity:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    storage: 1Gi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  accessModes:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - ReadWriteMany
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  nfs:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    server: 10.244.1.4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    path: &#34;/&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>而<strong>PVC 描述的，则是 Pod 所希望使用的持久化存储的属性</strong>。比如，Volume 存储的大小、可读写权限等等。</p>
<p>PVC 对象通常由开发人员创建；或者以 PVC 模板的方式成为 StatefulSet 的一部分，然后由 StatefulSet 控制器负责创建带编号的 PVC。</p>
<p>比如，开发人员可以声明一个 1 GiB 大小的 PVC，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: PersistentVolumeClaim
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: nfs
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  accessModes:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - ReadWriteMany
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  storageClassName: manual
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  resources:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    requests:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      storage: 1Gi
</span></span></code></pre></td></tr></table>
</div>
</div><p>而用户创建的 PVC 要真正被容器使用起来，就必须先和某个符合条件的 PV 进行绑定。这里要检查的条件，包括两部分：</p>
<ul>
<li>第一个条件，当然是 PV 和 PVC 的 spec 字段。比如，PV 的存储（storage）大小，就必须满足 PVC 的要求。</li>
<li>而第二个条件，则是 PV 和 PVC 的 storageClassName 字段必须一样。这个机制我会在本篇文章的最后一部分专门介绍。</li>
</ul>
<p>在成功地将 PVC 和 PV 进行绑定之后，Pod 就能够像使用 hostPath 等常规类型的 Volume 一样，在自己的 YAML 文件里声明使用这个 PVC 了，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: Pod
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  labels:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    role: web-frontend
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  containers:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  - name: web
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    image: nginx
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ports:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      - name: web
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        containerPort: 80
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    volumeMounts:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        - name: nfs
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          mountPath: &#34;/usr/share/nginx/html&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  volumes:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  - name: nfs
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    persistentVolumeClaim:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      claimName: nfs
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，Pod 需要做的，就是在 volumes 字段里声明自己要使用的 PVC 名字。接下来，等这个 Pod 创建之后，kubelet 就会把这个 PVC 所对应的 PV，也就是一个 NFS 类型的 Volume，挂载在这个 Pod 容器内的目录上。</p>
<p>不难看出，<strong>PVC 和 PV 的设计，其实跟“面向对象”的思想完全一致。</strong></p>
<p>PVC 可以理解为持久化存储的“接口”，它提供了对某种持久化存储的描述，但不提供具体的实现；而这个持久化存储的实现部分则由 PV 负责完成。</p>
<p>这样做的好处是，作为应用开发者，我们只需要跟 PVC 这个“接口”打交道，而不必关心具体的实现是 NFS 还是 Ceph。毕竟这些存储相关的知识太专业了，应该交给专业的人去做。</p>
<p>而在上面的讲述中，其实还有一个比较棘手的情况。</p>
<p>比如，你在创建 Pod 的时候，系统里并没有合适的 PV 跟它定义的 PVC 绑定，也就是说此时容器想要使用的 Volume 不存在。这时候，Pod 的启动就会报错。</p>
<p>但是，过了一会儿，运维人员也发现了这个情况，所以他赶紧创建了一个对应的 PV。这时候，我们当然希望 Kubernetes 能够再次完成 PVC 和 PV 的绑定操作，从而启动 Pod。</p>
<p>所以在 Kubernetes 中，实际上存在着一个专门处理持久化存储的控制器，叫作 Volume Controller。这个 Volume Controller 维护着多个控制循环，其中有一个循环，扮演的就是撮合 PV 和 PVC 的“红娘”的角色。它的名字叫作 PersistentVolumeController。</p>
<p>PersistentVolumeController 会不断地查看当前每一个 PVC，是不是已经处于 Bound（已绑定）状态。如果不是，那它就会遍历所有的、可用的 PV，并尝试将其与这个“单身”的 PVC 进行绑定。这样，Kubernetes 就可以保证用户提交的每一个 PVC，只要有合适的 PV 出现，它就能够很快进入绑定状态，从而结束“单身”之旅。</p>
<p>而所谓将一个 PV 与 PVC 进行“绑定”，其实就是将这个 PV 对象的名字，填在了 PVC 对象的 spec.volumeName 字段上。所以，接下来 Kubernetes 只要获取到这个 PVC 对象，就一定能够找到它所绑定的 PV。</p>
<p>那么，这个 PV 对象，又是如何变成容器里的一个持久化存储的呢？</p>
<p>我在前面讲解容器基础的时候，已经为你详细剖析了容器 Volume 的挂载机制。用一句话总结，<strong>所谓容器的 Volume，其实就是将一个宿主机上的目录，跟一个容器里的目录绑定挂载在了一起。</strong>（你可以借此机会，再回顾一下专栏的第 8 篇文章<a href="./18119.md">《白话容器基础（四）：重新认识 Docker 容器》</a>中的相关内容）</p>
<p><strong>而所谓的“持久化 Volume”，指的就是这个宿主机上的目录，具备“持久性”</strong>。即：这个目录里面的内容，既不会因为容器的删除而被清理掉，也不会跟当前的宿主机绑定。这样，当容器被重启或者在其他节点上重建出来之后，它仍然能够通过挂载这个 Volume，访问到这些内容。</p>
<p>显然，我们前面使用的 hostPath 和 emptyDir 类型的 Volume 并不具备这个特征：它们既有可能被 kubelet 清理掉，也不能被“迁移”到其他节点上。</p>
<p>所以，大多数情况下，持久化 Volume 的实现，往往依赖于一个远程存储服务，比如：远程文件存储（比如，NFS、GlusterFS）、远程块存储（比如，公有云提供的远程磁盘）等等。</p>
<p>而 Kubernetes 需要做的工作，就是使用这些存储服务，来为容器准备一个持久化的宿主机目录，以供将来进行绑定挂载时使用。而所谓“持久化”，指的是容器在这个目录里写入的文件，都会保存在远程存储中，从而使得这个目录具备了“持久性”。</p>
<p><strong>这个准备“持久化”宿主机目录的过程，我们可以形象地称为“两阶段处理”。</strong></p>
<p>接下来，我通过一个具体的例子为你说明。</p>
<p>当一个 Pod 调度到一个节点上之后，kubelet 就要负责为这个 Pod 创建它的 Volume 目录。默认情况下，kubelet 为 Volume 创建的目录是如下所示的一个宿主机上的路径：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">/</span><span class="k">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">kubelet</span><span class="o">/</span><span class="n">pods</span><span class="o">/&lt;</span><span class="n">Pod</span> <span class="err">的</span> <span class="n">ID</span><span class="o">&gt;/</span><span class="n">volumes</span><span class="o">/</span><span class="n">kubernetes</span><span class="o">.</span><span class="n">io</span><span class="o">~&lt;</span><span class="n">Volume</span> <span class="err">类型</span> <span class="o">&gt;/&lt;</span><span class="n">Volume</span> <span class="err">名字</span> <span class="o">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，kubelet 要做的操作就取决于你的 Volume 类型了。</p>
<p>如果你的 Volume 类型是远程块存储，比如 Google Cloud 的 Persistent Disk（GCE 提供的远程磁盘服务），那么 kubelet 就需要先调用 Goolge Cloud 的 API，将它所提供的 Persistent Disk 挂载到 Pod 所在的宿主机上。</p>
<blockquote>
<p>备注：你如果不太了解块存储的话，可以直接把它理解为：一块<strong>磁盘</strong>。</p>
</blockquote>
<p>这相当于执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ gcloud compute instances attach-disk &lt; 虚拟机名字 &gt; --disk &lt; 远程磁盘名字 &gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>这一步<strong>为虚拟机挂载远程磁盘的操作，对应的正是“两阶段处理”的第一阶段。在 Kubernetes 中，我们把这个阶段称为 Attach。</strong></p>
<p>Attach 阶段完成后，为了能够使用这个远程磁盘，kubelet 还要进行第二个操作，即：格式化这个磁盘设备，然后将它挂载到宿主机指定的挂载点上。不难理解，这个挂载点，正是我在前面反复提到的 Volume 的宿主机目录。所以，这一步相当于执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 通过 lsblk 命令获取磁盘设备 ID</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="n">sudo</span> <span class="n">lsblk</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 格式化成 ext4 格式</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="n">sudo</span> <span class="n">mkfs</span><span class="o">.</span><span class="n">ext4</span> <span class="o">-</span><span class="n">m</span> <span class="mi">0</span> <span class="o">-</span><span class="n">F</span> <span class="o">-</span><span class="n">E</span> <span class="n">lazy_itable_init</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">lazy_journal_init</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">discard</span> <span class="o">/</span><span class="n">dev</span><span class="o">/&lt;</span> <span class="err">磁盘设备</span> <span class="n">ID</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 挂载到挂载点</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="n">sudo</span> <span class="n">mkdir</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span><span class="k">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">kubelet</span><span class="o">/</span><span class="n">pods</span><span class="o">/&lt;</span><span class="n">Pod</span> <span class="err">的</span> <span class="n">ID</span><span class="o">&gt;/</span><span class="n">volumes</span><span class="o">/</span><span class="n">kubernetes</span><span class="o">.</span><span class="n">io</span><span class="o">~&lt;</span><span class="n">Volume</span> <span class="err">类型</span> <span class="o">&gt;/&lt;</span><span class="n">Volume</span> <span class="err">名字</span> <span class="o">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个<strong>将磁盘设备格式化并挂载到 Volume 宿主机目录的操作，对应的正是“两阶段处理”的第二个阶段，我们一般称为：Mount。</strong></p>
<p>Mount 阶段完成后，这个 Volume 的宿主机目录就是一个“持久化”的目录了，容器在它里面写入的内容，会保存在 Google Cloud 的远程磁盘中。</p>
<p>而如果你的 Volume 类型是远程文件存储（比如 NFS）的话，kubelet 的处理过程就会更简单一些。</p>
<p>因为在这种情况下，kubelet 可以跳过“第一阶段”（Attach）的操作，这是因为一般来说，远程文件存储并没有一个“存储设备”需要挂载在宿主机上。</p>
<p>所以，kubelet 会直接从“第二阶段”（Mount）开始准备宿主机上的 Volume 目录。</p>
<p>在这一步，kubelet 需要作为 client，将远端 NFS 服务器的目录（比如：“/”目录），挂载到 Volume 的宿主机目录上，即相当于执行如下所示的命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="n">mount</span> <span class="o">-</span><span class="n">t</span> <span class="n">nfs</span> <span class="o">&lt;</span><span class="n">NFS</span> <span class="err">服务器地址</span> <span class="o">&gt;</span><span class="p">:</span><span class="o">/</span> <span class="o">/</span><span class="k">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">kubelet</span><span class="o">/</span><span class="n">pods</span><span class="o">/&lt;</span><span class="n">Pod</span> <span class="err">的</span> <span class="n">ID</span><span class="o">&gt;/</span><span class="n">volumes</span><span class="o">/</span><span class="n">kubernetes</span><span class="o">.</span><span class="n">io</span><span class="o">~&lt;</span><span class="n">Volume</span> <span class="err">类型</span> <span class="o">&gt;/&lt;</span><span class="n">Volume</span> <span class="err">名字</span> <span class="o">&gt;</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过这个挂载操作，Volume 的宿主机目录就成为了一个远程 NFS 目录的挂载点，后面你在这个目录里写入的所有文件，都会被保存在远程 NFS 服务器上。所以，我们也就完成了对这个 Volume 宿主机目录的“持久化”。</p>
<p><strong>到这里，你可能会有疑问，Kubernetes 又是如何定义和区分这两个阶段的呢？</strong></p>
<p>其实很简单，在具体的 Volume 插件的实现接口上，Kubernetes 分别给这两个阶段提供了两种不同的参数列表：</p>
<ul>
<li>对于“第一阶段”（Attach），Kubernetes 提供的可用参数是 nodeName，即宿主机的名字。</li>
<li>而对于“第二阶段”（Mount），Kubernetes 提供的可用参数是 dir，即 Volume 的宿主机目录。</li>
</ul>
<p>所以，作为一个存储插件，你只需要根据自己的需求进行选择和实现即可。在后面关于编写存储插件的文章中，我会对这个过程做深入讲解。</p>
<p>而经过了“两阶段处理”，我们就得到了一个“持久化”的 Volume 宿主机目录。所以，接下来，kubelet 只要把这个 Volume 目录通过 CRI 里的 Mounts 参数，传递给 Docker，然后就可以为 Pod 里的容器挂载这个“持久化”的 Volume 了。其实，这一步相当于执行了如下所示的命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">$</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">v</span> <span class="o">/</span><span class="k">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">kubelet</span><span class="o">/</span><span class="n">pods</span><span class="o">/&lt;</span><span class="n">Pod</span> <span class="err">的</span> <span class="n">ID</span><span class="o">&gt;/</span><span class="n">volumes</span><span class="o">/</span><span class="n">kubernetes</span><span class="o">.</span><span class="n">io</span><span class="o">~&lt;</span><span class="n">Volume</span> <span class="err">类型</span> <span class="o">&gt;/&lt;</span><span class="n">Volume</span> <span class="err">名字</span> <span class="o">&gt;</span><span class="p">:</span><span class="o">/&lt;</span> <span class="err">容器内的目标目录</span> <span class="o">&gt;</span> <span class="err">我的镜像</span> <span class="o">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>以上，就是 Kubernetes 处理 PV 的具体原理了。</p>
<blockquote>
<p>备注：对应地，在删除一个 PV 的时候，Kubernetes 也需要 Unmount 和 Dettach 两个阶段来处理。这个过程我就不再详细介绍了，执行“反向操作”即可。</p>
</blockquote>
<p>实际上，你可能已经发现，这个 PV 的处理流程似乎跟 Pod 以及容器的启动流程没有太多的耦合，只要 kubelet 在向 Docker 发起 CRI 请求之前，确保“持久化”的宿主机目录已经处理完毕即可。</p>
<p>所以，在 Kubernetes 中，上述<strong>关于 PV 的“两阶段处理”流程，是靠独立于 kubelet 主控制循环（Kubelet Sync Loop）之外的两个控制循环来实现的。</strong></p>
<p>其中，“第一阶段”的 Attach（以及 Dettach）操作，是由 Volume Controller 负责维护的，这个控制循环的名字叫作：<strong>AttachDetachController</strong>。而它的作用，就是不断地检查每一个 Pod 对应的 PV，和这个 Pod 所在宿主机之间挂载情况。从而决定，是否需要对这个 PV 进行 Attach（或者 Dettach）操作。</p>
<p>需要注意，作为一个 Kubernetes 内置的控制器，Volume Controller 自然是 kube-controller-manager 的一部分。所以，AttachDetachController 也一定是运行在 Master 节点上的。当然，Attach 操作只需要调用公有云或者具体存储项目的 API，并不需要在具体的宿主机上执行操作，所以这个设计没有任何问题。</p>
<p>而“第二阶段”的 Mount（以及 Unmount）操作，必须发生在 Pod 对应的宿主机上，所以它必须是 kubelet 组件的一部分。这个控制循环的名字，叫作：<strong>VolumeManagerReconciler</strong>，它运行起来之后，是一个独立于 kubelet 主循环的 Goroutine。</p>
<p>通过这样将 Volume 的处理同 kubelet 的主循环解耦，Kubernetes 就避免了这些耗时的远程挂载操作拖慢 kubelet 的主控制循环，进而导致 Pod 的创建效率大幅下降的问题。实际上，<strong>kubelet 的一个主要设计原则，就是它的主控制循环绝对不可以被 block</strong>。这个思想，我在后续的讲述容器运行时的时候还会提到。</p>
<p>在了解了 Kubernetes 的 Volume 处理机制之后，我再来为你介绍这个体系里最后一个重要概念：StorageClass。</p>
<p>我在前面介绍 PV 和 PVC 的时候，曾经提到过，PV 这个对象的创建，是由运维人员完成的。但是，在大规模的生产环境里，这其实是一个非常麻烦的工作。</p>
<p>这是因为，一个大规模的 Kubernetes 集群里很可能有成千上万个 PVC，这就意味着运维人员必须得事先创建出成千上万个 PV。更麻烦的是，随着新的 PVC 不断被提交，运维人员就不得不继续添加新的、能满足条件的 PV，否则新的 Pod 就会因为 PVC 绑定不到 PV 而失败。在实际操作中，这几乎没办法靠人工做到。</p>
<p>所以，Kubernetes 为我们提供了一套可以自动创建 PV 的机制，即：Dynamic Provisioning。</p>
<p>相比之下，前面人工管理 PV 的方式就叫作 Static Provisioning。</p>
<p>Dynamic Provisioning 机制工作的核心，在于一个名叫 StorageClass 的 API 对象。</p>
<p><strong>而 StorageClass 对象的作用，其实就是创建 PV 的模板。</strong></p>
<p>具体地说，StorageClass 对象会定义如下两个部分内容：</p>
<ul>
<li>第一，PV 的属性。比如，存储类型、Volume 的大小等等。</li>
<li>第二，创建这种 PV 需要用到的存储插件。比如，Ceph 等等。</li>
</ul>
<p>有了这样两个信息之后，Kubernetes 就能够根据用户提交的 PVC，找到一个对应的 StorageClass 了。然后，Kubernetes 就会调用该 StorageClass 声明的存储插件，创建出需要的 PV。</p>
<p>举个例子，假如我们的 Volume 的类型是 GCE 的 Persistent Disk 的话，运维人员就需要定义一个如下所示的 StorageClass：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: storage.k8s.io/v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: StorageClass
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: block-service
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">provisioner: kubernetes.io/gce-pd
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">parameters:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  type: pd-ssd
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个 YAML 文件里，我们定义了一个名叫 block-service 的 StorageClass。</p>
<p>这个 StorageClass 的 provisioner 字段的值是：<code>kubernetes.io/gce-pd</code>，这正是 Kubernetes 内置的 GCE PD 存储插件的名字。</p>
<p>而这个 StorageClass 的 parameters 字段，就是 PV 的参数。比如：上面例子里的 type=pd-ssd，指的是这个 PV 的类型是“SSD 格式的 GCE 远程磁盘”。</p>
<p>需要注意的是，由于需要使用 GCE Persistent Disk，上面这个例子只有在 GCE 提供的 Kubernetes 服务里才能实践。如果你想使用我们之前部署在本地的 Kubernetes 集群以及 Rook 存储服务的话，你的 StorageClass 需要使用如下所示的 YAML 文件来定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: ceph.rook.io/v1beta1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: Pool
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: replicapool
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  namespace: rook-ceph
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  replicated:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    size: 3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">---
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: storage.k8s.io/v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: StorageClass
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: block-service
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">provisioner: ceph.rook.io/block
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">parameters:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  pool: replicapool
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  #The value of &#34;clusterNamespace&#34; MUST be the same as the one in which your rook cluster exist
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  clusterNamespace: rook-ceph
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个 YAML 文件中，我们定义的还是一个名叫 block-service 的 StorageClass，只不过它声明使的存储插件是由 Rook 项目。</p>
<p>有了 StorageClass 的 YAML 文件之后，运维人员就可以在 Kubernetes 里创建这个 StorageClass 了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl create -f sc.yaml
</span></span></code></pre></td></tr></table>
</div>
</div><p>这时候，作为应用开发者，我们只需要在 PVC 里指定要使用的 StorageClass 名字即可，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">kind: PersistentVolumeClaim
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  name: claim1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  accessModes:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - ReadWriteOnce
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  storageClassName: block-service
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  resources:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    requests:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      storage: 30Gi
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，我们在这个 PVC 里添加了一个叫作 storageClassName 的字段，用于指定该 PVC 所要使用的 StorageClass 的名字是：block-service。</p>
<p>以 Google Cloud 为例。</p>
<p>当我们通过 kubectl create 创建上述 PVC 对象之后，Kubernetes 就会调用 Google Cloud 的 API，创建出一块 SSD 格式的 Persistent Disk。然后，再使用这个 Persistent Disk 的信息，自动创建出一个对应的 PV 对象。</p>
<p>我们可以一起来实践一下这个过程（如果使用 Rook 的话下面的流程也是一样的，只不过 Rook 创建出的是 Ceph 类型的 PV）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl create -f pvc.yaml
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，我们创建的 PVC 会绑定一个 Kubernetes 自动创建的 PV，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl describe pvc claim1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Name:           claim1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Namespace:      default
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">StorageClass:   block-service
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Status:         Bound
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Volume:         pvc-e5578707-c626-11e6-baf6-08002729a32b
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Labels:         &lt;none&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Capacity:       30Gi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Access Modes:   RWO
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">No Events.
</span></span></code></pre></td></tr></table>
</div>
</div><p>而且，通过查看这个自动创建的 PV 的属性，你就可以看到它跟我们在 PVC 里声明的存储的属性是一致的，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ kubectl describe pv pvc-e5578707-c626-11e6-baf6-08002729a32b
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Name:            pvc-e5578707-c626-11e6-baf6-08002729a32b
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Labels:          &lt;none&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">StorageClass:    block-service
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Status:          Bound
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Claim:           default/claim1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Reclaim Policy:  Delete
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Access Modes:    RWO
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Capacity:        30Gi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">No events.
</span></span></code></pre></td></tr></table>
</div>
</div><p>此外，你还可以看到，这个自动创建出来的 PV 的 StorageClass 字段的值，也是 block-service。<strong>这是因为，Kubernetes 只会将 StorageClass 相同的 PVC 和 PV 绑定起来。</strong></p>
<p>有了 Dynamic Provisioning 机制，运维人员只需要在 Kubernetes 集群里创建出数量有限的 StorageClass 对象就可以了。这就好比，运维人员在 Kubernetes 集群里创建出了各种各样的 PV 模板。这时候，当开发人员提交了包含 StorageClass 字段的 PVC 之后，Kubernetes 就会根据这个 StorageClass 创建出对应的 PV。</p>
<blockquote>
<p><a href="./storage-classes.md#provisioner">Kubernetes 的官方文档</a>里已经列出了默认支持 Dynamic Provisioning 的内置存储插件。而对于不在文档里的插件，比如 NFS，或者其他非内置存储插件，你其实可以通过<a href="./external-storage.md">kubernetes-incubator/external-storage</a>这个库来自己编写一个外部插件完成这个工作。像我们之前部署的 Rook，已经内置了 external-storage 的实现，所以 Rook 是完全支持 Dynamic Provisioning 特性的。</p>
</blockquote>
<p>需要注意的是，<strong>StorageClass 并不是专门为了 Dynamic Provisioning 而设计的。</strong></p>
<p>比如，在本篇一开始的例子里，我在 PV 和 PVC 里都声明了 storageClassName=manual。而我的集群里，实际上并没有一个名叫 manual 的 StorageClass 对象。这完全没有问题，这个时候 Kubernetes 进行的是 Static Provisioning，但在做绑定决策的时候，它依然会考虑 PV 和 PVC 的 StorageClass 定义。</p>
<p>而这么做的好处也很明显：这个 PVC 和 PV 的绑定关系，就完全在我自己的掌控之中。</p>
<p>这里，你可能会有疑问，我在之前讲解 StatefulSet 存储状态的例子时，好像并没有声明 StorageClass 啊？</p>
<p>实际上，如果你的集群已经开启了名叫 DefaultStorageClass 的 Admission Plugin，它就会为 PVC 和 PV 自动添加一个默认的 StorageClass；<strong>否则，PVC 的 storageClassName 的值就是“”，这也意味着它只能够跟 storageClassName 也是“”的 PV 进行绑定。</strong></p>
<h2 id="总结">总结</h2>
<p>在今天的分享中，我为你详细解释了 PVC 和 PV 的设计与实现原理，并为你阐述了 StorageClass 到底是干什么用的。这些概念之间的关系，可以用如下所示的一幅示意图描述：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/e111cccdc2ac582f5a77e3414a37e10b.png" alt=""><br>
从图中我们可以看到，在这个体系中：</p>
<ul>
<li>PVC 描述的，是 Pod 想要使用的持久化存储的属性，比如存储的大小、读写权限等。</li>
<li>PV 描述的，则是一个具体的 Volume 的属性，比如 Volume 的类型、挂载目录、远程存储服务器地址等。</li>
<li>而 StorageClass 的作用，则是充当 PV 的模板。并且，只有同属于一个 StorageClass 的 PV 和 PVC，才可以绑定在一起。</li>
</ul>
<p>当然，StorageClass 的另一个重要作用，是指定 PV 的 Provisioner（存储插件）。这时候，如果你的存储插件支持 Dynamic Provisioning 的话，Kubernetes 就可以自动为你创建 PV 了。</p>
<p>基于上述讲述，为了统一概念和方便叙述，在本专栏中，我以后凡是提到“Volume”，指的就是一个远程存储服务挂载在宿主机上的持久化目录；而“PV”，指的是这个 Volume 在 Kubernetes 里的 API 对象。</p>
<p>需要注意的是，这套容器持久化存储体系，完全是 Kubernetes 项目自己负责管理的，并不依赖于 docker volume 命令和 Docker 的存储插件。当然，这套体系本身就比 docker volume 命令的诞生时间还要早得多。</p>
<h2 id="思考题">思考题</h2>
<p>在了解了 PV、PVC 的设计和实现原理之后，你是否依然觉得它有“过度设计”的嫌疑？或者，你是否有更加简单、足以解决你 90% 需求的 Volume 的用法？</p>
<p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/e870b7df0db49509e735e6becd4a9a9a.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes/">深入剖析Kubernetes</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/28__pika_%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Essd%E5%AE%9E%E7%8E%B0%E5%A4%A7%E5%AE%B9%E9%87%8Fredis/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">28__Pika_如何基于SSD实现大容量Redis？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/openresty%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/28__test_nginx_%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E7%94%A8/">
            <span class="next-text nav-default">28__test_nginx_还可以这样用？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
