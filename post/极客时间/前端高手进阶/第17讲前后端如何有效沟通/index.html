<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>第17讲：前后端如何有效沟通？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="在第 14 课时中，我们重点介绍了前后端通信的重要协议 HTTP，但在实际通信场景中，光有协议是不够的。假设有下面的 GET 请求，返回结果是用户列表数据。
1 GET https://lagou.com/a 对于浏览器而言，可以通过头部字段 Content-Type 轻松判断出来，然后进行对应的逻辑处理。但对于工程师而言是不可读的，不知道 /a 代表什么。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%89%8D%E7%AB%AF%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/%E7%AC%AC17%E8%AE%B2%E5%89%8D%E5%90%8E%E7%AB%AF%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E6%B2%9F%E9%80%9A/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%89%8D%E7%AB%AF%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/%E7%AC%AC17%E8%AE%B2%E5%89%8D%E5%90%8E%E7%AB%AF%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E6%B2%9F%E9%80%9A/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="第17讲：前后端如何有效沟通？">
  <meta property="og:description" content="在第 14 课时中，我们重点介绍了前后端通信的重要协议 HTTP，但在实际通信场景中，光有协议是不够的。假设有下面的 GET 请求，返回结果是用户列表数据。
1 GET https://lagou.com/a 对于浏览器而言，可以通过头部字段 Content-Type 轻松判断出来，然后进行对应的逻辑处理。但对于工程师而言是不可读的，不知道 /a 代表什么。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="前端高手进阶">

  <meta itemprop="name" content="第17讲：前后端如何有效沟通？">
  <meta itemprop="description" content="在第 14 课时中，我们重点介绍了前后端通信的重要协议 HTTP，但在实际通信场景中，光有协议是不够的。假设有下面的 GET 请求，返回结果是用户列表数据。
1 GET https://lagou.com/a 对于浏览器而言，可以通过头部字段 Content-Type 轻松判断出来，然后进行对应的逻辑处理。但对于工程师而言是不可读的，不知道 /a 代表什么。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4862">
  <meta itemprop="keywords" content="前端高手进阶">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="第17讲：前后端如何有效沟通？">
  <meta name="twitter:description" content="在第 14 课时中，我们重点介绍了前后端通信的重要协议 HTTP，但在实际通信场景中，光有协议是不够的。假设有下面的 GET 请求，返回结果是用户列表数据。
1 GET https://lagou.com/a 对于浏览器而言，可以通过头部字段 Content-Type 轻松判断出来，然后进行对应的逻辑处理。但对于工程师而言是不可读的，不知道 /a 代表什么。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">第17讲：前后端如何有效沟通？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4862 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>在第 14 课时中，我们重点介绍了前后端通信的重要协议 HTTP，但在实际通信场景中，光有协议是不够的。假设有下面的 GET 请求，返回结果是用户列表数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">GET https://lagou.com/a
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于浏览器而言，可以通过头部字段 Content-Type 轻松判断出来，然后进行对应的逻辑处理。但对于工程师而言是不可读的，不知道 /a 代表什么。</p>
<p>解决这个问题的方法就是制定一种规范，让请求具有语义化，这种规范就是我们常说的 API 设计规范。下面就来介绍前后端通信中出现过的 3 种 API 规范。</p>
<p>RPC—远程过程调用</p>
<p>RPC（Remote Procedure Call，远程过程调用）常用于后端服务进程之间的通信。“远程”指的是不同服务器上的进程，“过程调用”里的“过程”可以理解为“函数”，这种接口设计和函数命名很相似，名称为动宾结构短语，类似下面的样子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">GET /getUsers
</span></span><span class="line"><span class="cl">POST /deleteUser
</span></span><span class="line"><span class="cl">POST /createUser
</span></span></code></pre></td></tr></table>
</div>
</div><p>可能有的前端工程师对 RPC 比较陌生，但在 Web 开发早期，编写页面逻辑的工作由后端（或全栈）工程师完成，自然而然的，RPC 风格就被移植到了前后端通信中。</p>
<p>从接口命名上不难看出，RPC 风格和我们平常编写模块的思路很像，提供了一个函数作为接口，供其他模块调用。这明显是站在后端工程师的视角而设置的：为了像在本地调用一个函数那样调用远程的代码。</p>
<p>RPC 这种设计规范对前端工程师而言是不够友好的，具体表现在以下 2 个方面。</p>
<p>紧耦合：当前端工程师需要获取或修改某个数据时，他有可能需要先调用接口 A ，再调用接口 B，这种调用需要对系统非常熟悉，让前端工程师熟悉后端逻辑和代码显然是难以办到的。</p>
<p>冗余：把执行动作写在 URL 上实际是冗余的，因为 HTTP 的 Method 头部可以表示不同的动作行为。</p>
<p>REST—表现层状态转换</p>
<p>REST（Representational State Transfer），即表现层状态转换 。</p>
<p>什么是“表现层”？</p>
<p>在理解“表现层”之前，我们先理解另一个概念“资源”。资源指的是一个实体信息，一个文本文件、一段 JSON 数据都可以称为资源。</p>
<p>而一个资源可以有不同的呈现形式，比如一份数据可以是 XML 格式，也可以是 JSON 格式，这种呈现形式叫作“表现层（Representation）”。</p>
<p>什么又是“状态转移”？</p>
<p>当用户通过浏览器访问网站时，通常会涉及状态的变化，比如登录。</p>
<p>HTTP 本身是无状态的，因此，如果客户端想要操作服务器，则必须通过某种手段让服务器发生“状态转移（State Transfer）”。而这种转移是建立在表现层之上的，即“表现层状态转移”。</p>
<p>REST 的核心要点有两个，那就是资源和方法。</p>
<p>REST 的 URL 指向某个或某类资源，所以不再是类似 RPC 的动宾结构，而是名词。比如像下面这些都是 REST 的设计风格，通常，当 URL 的路径以 ID 结尾则表示指代某个资源，无 ID 则指向一类资源。路径分隔符表示资源之间的嵌套关系。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/orgs
</span></span><span class="line"><span class="cl">/orgs/123asdf12d
</span></span><span class="line"><span class="cl">/orgs/ss1212sdf/users
</span></span><span class="line"><span class="cl">/orgs/ss1212sdf/users/111asdl234l
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以像下面这些 URL 是不符合 REST 规范的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">/</span><span class="n">createUser</span>
</span></span><span class="line"><span class="cl"><span class="o">/</span><span class="n">samples</span><span class="o">/</span><span class="k">export</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而要进行状态转移的时候，使用的是 HTTP 默认的语义化头部 Method 字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">GET（SELECT）：获取资源
</span></span><span class="line"><span class="cl">POST（CREATE）：新建一个资源
</span></span><span class="line"><span class="cl">PUT（UPDATE）：更新资源
</span></span><span class="line"><span class="cl">DELETE（DELETE）：从服务器删除资源
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然 REST 的低耦合、高度语义化的设计风格比较适合前后端通信，但也存在 3 个不足，具体如下。</p>
<p>弱约束。REST 定义请求路径和方法，但对非常重要的请求体和响应体并没有给出规范和约束。这就意味着需要借助工具来重新定义和校验这些内容，而不同工具之间的定义格式和校验方式都不相同，给工程师带来了一定的学习负担。</p>
<p>接口松散。 REST 风格的数据粒度一般都非常小，前端要进行复杂查询的时候可能会涉及多个 API 查询，那么会产生多个网络请求，很容易造成性能问题。通常的解决方案是通过类似 API 网关的中转服务器来实现对接口的聚合和缓存。</p>
<p>数据冗余。前端对网络请求性能是比较敏感的，所以传输的数据量尽可能小，但 REST API 在设计好之后，返回的字段值是固定的。所以很容易出现这样一个场景，对于后端工程师而言，为了减少代码修改，会尽可能地在返回结果中添加更多的字段；对于前端工程师而言，使用数据的场景往往是多变的，即使是调用同一个 API，在不同场景下也只会用到某些特定的字段。所以不可避免地产生数据冗余，从而造成带宽浪费，影响用户体验。</p>
<p>如果要改进上述不足，该怎样定义 API 规范呢？</p>
<p>GraphQL—图表查询语言</p>
<p>我们再次将关注点从资源转移到 API 的调用者上，从调用者的角度来思考 API 设计。对于调用者而言，最关心的不是资源和方法，而是响应内容。在前后端的交互中，请求体和响应内容一般都采用 JSON 格式。下面是 GitHub REST API 的响应内容示例，由于响应内容字段太多，只截取了部分字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;id&#34;: 1296269,
</span></span><span class="line"><span class="cl">  &#34;stargazers_count&#34;: 80,
</span></span><span class="line"><span class="cl">  &#34;name&#34;: &#34;Hello-World&#34;,
</span></span><span class="line"><span class="cl">  &#34;full_name&#34;: &#34;octocat/Hello-World&#34;,
</span></span><span class="line"><span class="cl">  &#34;owner&#34;: {
</span></span><span class="line"><span class="cl">    &#34;login&#34;: &#34;octocat&#34;,
</span></span><span class="line"><span class="cl">    &#34;id&#34;: 1，
</span></span><span class="line"><span class="cl">    &#34;avatar_url&#34;: &#34;https://github.com/images/error/octocat_happy.gif&#34;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>假设上面的响应内容是前端所需要的内容，现在来思考一个问题，该如何告诉后端所期望得到的数据结构呢？</p>
<p>如果只考虑对 JSON 数据的描述，其实已经有现成的规范来实现了，即用 JSON-Schema 来描述上面的 JSON 数据，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;type&#34;: &#34;object&#34;,
</span></span><span class="line"><span class="cl">  &#34;properties&#34;: {
</span></span><span class="line"><span class="cl">    &#34;id&#34;: {
</span></span><span class="line"><span class="cl">      &#34;name&#34;: &#34;id&#34;,
</span></span><span class="line"><span class="cl">      &#34;type&#34;: &#34;number&#34;
</span></span><span class="line"><span class="cl">    },
</span></span><span class="line"><span class="cl">    &#34;stargazers_count&#34;: {
</span></span><span class="line"><span class="cl">      &#34;name&#34;: &#34;stargazers_count&#34;,
</span></span><span class="line"><span class="cl">      &#34;type&#34;: &#34;number&#34;
</span></span><span class="line"><span class="cl">    },
</span></span><span class="line"><span class="cl">    &#34;name&#34;: {
</span></span><span class="line"><span class="cl">      &#34;name&#34;: &#34;name&#34;,
</span></span><span class="line"><span class="cl">      &#34;type&#34;: &#34;string&#34;
</span></span><span class="line"><span class="cl">    },
</span></span><span class="line"><span class="cl">    &#34;full_name&#34;: {
</span></span><span class="line"><span class="cl">      &#34;name&#34;: &#34;full_name&#34;,
</span></span><span class="line"><span class="cl">      &#34;type&#34;: &#34;string&#34;
</span></span><span class="line"><span class="cl">    },
</span></span><span class="line"><span class="cl">    &#34;owner&#34;: {
</span></span><span class="line"><span class="cl">      &#34;name&#34;: &#34;owner&#34;,
</span></span><span class="line"><span class="cl">      &#34;type&#34;: &#34;object&#34;,
</span></span><span class="line"><span class="cl">      &#34;properties&#34;: {
</span></span><span class="line"><span class="cl">        &#34;login&#34;: {
</span></span><span class="line"><span class="cl">          &#34;name&#34;: &#34;login&#34;,
</span></span><span class="line"><span class="cl">          &#34;type&#34;: &#34;string&#34;
</span></span><span class="line"><span class="cl">        },
</span></span><span class="line"><span class="cl">        &#34;id&#34;: {
</span></span><span class="line"><span class="cl">          &#34;name&#34;: &#34;id&#34;,
</span></span><span class="line"><span class="cl">          &#34;type&#34;: &#34;number&#34;
</span></span><span class="line"><span class="cl">        },
</span></span><span class="line"><span class="cl">        &#34;avatar_url&#34;: {
</span></span><span class="line"><span class="cl">          &#34;name&#34;: &#34;avatar_url&#34;,
</span></span><span class="line"><span class="cl">          &#34;type&#34;: &#34;string&#34;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">      },
</span></span><span class="line"><span class="cl">      &#34;required&#34;: [
</span></span><span class="line"><span class="cl">        &#34;login&#34;,
</span></span><span class="line"><span class="cl">        &#34;id&#34;,
</span></span><span class="line"><span class="cl">        &#34;avatar_url&#34;
</span></span><span class="line"><span class="cl">      ]
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  },
</span></span><span class="line"><span class="cl">  &#34;required&#34;: [
</span></span><span class="line"><span class="cl">    &#34;id&#34;,
</span></span><span class="line"><span class="cl">    &#34;stargazers_count&#34;,
</span></span><span class="line"><span class="cl">    &#34;name&#34;,
</span></span><span class="line"><span class="cl">    &#34;full_name&#34;,
</span></span><span class="line"><span class="cl">    &#34;owner&#34;
</span></span><span class="line"><span class="cl">  ]
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，描述信息本身大小已经超过了数据内容，所以这种烦琐的描述方式显然不适用于前后端通信，因为会占据较多的带宽。</p>
<p>既然不能做加法，那么就尝试做减法。对于 JSON 数据而言，重要的是描述其结构，值是可变的，所以可以把值去除。上述示例数据会变成下面的结构。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;id&#34;,
</span></span><span class="line"><span class="cl">  &#34;stargazers_count&#34;,
</span></span><span class="line"><span class="cl">  &#34;name&#34;,
</span></span><span class="line"><span class="cl">  &#34;full_name&#34;,
</span></span><span class="line"><span class="cl">  &#34;owner&#34;: {
</span></span><span class="line"><span class="cl">    &#34;login&#34;,
</span></span><span class="line"><span class="cl">    &#34;id&#34;，
</span></span><span class="line"><span class="cl">    &#34;avatar_url&#34;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在进行结构描述的时候，我们关注的是字段名称和层级关系，所以还有进一步的优化空间，那就是去掉一些不必要的符号，变成下面的形式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  id
</span></span><span class="line"><span class="cl">  stargazers_count
</span></span><span class="line"><span class="cl">  name
</span></span><span class="line"><span class="cl">  full_name
</span></span><span class="line"><span class="cl">  owner {
</span></span><span class="line"><span class="cl">    login
</span></span><span class="line"><span class="cl">    id
</span></span><span class="line"><span class="cl">    avatar_url
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>然而这个结构已经是最基础的 GraphQL 查询语句了，当然 GraphQL 并不止如此，还有更多的高级功能，比如参数变量、片段。下面就来介绍一下 GraphQL。</p>
<p>GraphQL（Graph Query Language） 是图表查询语言，在 REST 规范中，请求路径表示资源之间的嵌套关系，那么很容易形成树型结构，如下图所示。</p>
<p>REST 风格的树结构 API</p>
<p>GraphQL 中不同类型之间的关联关系通过图来表示。下面是一张通过 GraphQL 工具生成的示例图，描述了不同类型之间的关系。</p>
<p>GraphQL Voyager 示例图</p>
<p>虽然 GraphQL 的设计理念和 REST 有较大差别，而且还上升到了“语言”层面，但核心概念其实就两个：查询语句和模式，分别对应 API 的调用者和提供者。</p>
<p>GraphQL 的查询语句提供了 3 种操作：查询（Query）、变更（Mutation）和订阅（Subscription）。查询是最常用的操作，变更操作次之，订阅操作则使用场景就比较少了。</p>
<p>下面重点介绍一下查询操作中 3 个常用的高级功能。</p>
<p>别名（Aliases）</p>
<p>别名看上去是一个锦上添花的功能，但在开发中也会起到非常重要的作用。考虑一个场景，前端通过请求 GET /user/:uid 获取一个关于用户信息的 JSON 对象，并使用了返回结果中的 name 字段。如果后端调整了接口数据，将 name 字段改成了 username，那么对于前端来说只能被动地修改代码；而如果使用 GraphQL，只需要修改查询的别名即可。</p>
<p>下面是一个使用别名将 GitHub GraphQL API 的 createdAt 改为 createdTime 的代码示例。</p>
<p>片段（Fragments）</p>
<p>如果我们在查询中有重复的数据结构，可以通过片段来对它们进行抽象。下面是一个使用 GitHub GraphQL API 来查询当前仓库第一位 star 用户和最后一位 star 用户的例子。将 StargazerEdge 类型的部分字段抽取成了 Fragment，然后在查询中通过扩展符“&hellip;”来使用。</p>
<p>内省（Introspection）</p>
<p>调用 REST API 非常依赖文档，但 GraphQL 则不需要，因为它提供了一个内省系统来描述后端定义的类型。比如我要通过 GitHub GraphQL API 来查询某个仓库的 star 数量，可以先通过查询 __schema 字段来向 GraphQL 询问哪些类型是可用的。因为每个查询的根类型总是有 __schema 字段的。</p>
<p>__schema 查询根类型</p>
<p>通过搜索和查看描述信息 description 字段可以发现，其提供了一个 Repository 类型。</p>
<p>在返回的模式中找到 “Repository” 类型定义</p>
<p>然后再通过 __type 来查看 Repository 类型的字段，找到和 star 有关的 stargazers 字段描述，发现这个字段属于 StargazerConnection 类型，以此类推继续查找，后面的嵌套子类型查找过程就不一一截图了。</p>
<p>通过 __type 查找 Repository 类型字段</p>
<p>最终通过下面的查询语句获得了第一页的查询结果。</p>
<p>查询 Repository 的前100 个关注者</p>
<p>后端的模式与 Mongoose 及 JSON-Schema 的模式有些类似，都是通过声明数据类型来定义数据结构的。数据类型又可以分为默认的标量类型，如 Int、String 及自定义的对象类型。下面是一个类型声明的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type User{
</span></span><span class="line"><span class="cl">  id: ID!
</span></span><span class="line"><span class="cl">  name: String!
</span></span><span class="line"><span class="cl">  books: [Book!]!
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码定义了一个 User 类型，包含 3 个字段：ID 类型的 id 字段，String 类型的 name 字段以及 Book 类型列表 的 books 字段。其中 ID 和 String 为标量类型，Book 为对象类型，惊叹号表示字段值不能为 null。</p>
<p>GraphQL 的类型声明和 TypeScript 的类型定义除了在写法上有些类似，在一些高级功能上也有异曲同工之处，比如联合类型和接口定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">union Owner = User | Organization
</span></span><span class="line"><span class="cl">interface Member {
</span></span><span class="line"><span class="cl">  id: ID!
</span></span><span class="line"><span class="cl">  name: String
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">type User implements Member {
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">type Organization implements Member {
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>定义好模式之后，就要实现数据操作了。在 GraphQL 中这一部分逻辑称为解析器（Resolver），解析器与类型相对应，下面是类型定义以及对应的解析器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">schemaStr</span> <span class="o">=</span> <span class="err">`</span>
</span></span><span class="line"><span class="cl"><span class="n">type</span> <span class="n">Hero</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">id</span><span class="p">:</span> <span class="ne">String</span>
</span></span><span class="line"><span class="cl">  <span class="n">name</span><span class="p">:</span> <span class="ne">String</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 根类型</span>
</span></span><span class="line"><span class="cl"><span class="n">type</span> <span class="n">Query</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">hero</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="ne">String</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="ne">String</span><span class="p">):</span> <span class="p">[</span><span class="n">Hero</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="err">`</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">resolver</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">hero</span><span class="p">({</span><span class="n">id</span><span class="o">=</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;world&#39;</span><span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">id</span> <span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">[</span><span class="o">...</span><span class="n">data</span><span class="o">.</span><span class="n">hero</span><span class="p">,</span> <span class="p">{</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">}]</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">hero</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>总体而言，GraphQL 在弥补 REST 不足的同时也有所增强，表现在：</p>
<p>高聚合。GraphQL 提倡将系统所有请求路径都聚合在一起形成一个统一的地址，并使用 POST 方法来提交查询语句，比如 GitHub 使用的请求地址就是：https://api.github.com/graphql。</p>
<p>无冗余。后端会根据查询语句来返回值，不会出现冗余字段。</p>
<p>类型校验。由于有模式的存在，可以轻松实现对响应结果及查询语句进行校验。</p>
<p>代码即文档。内省功能可以直接查询模式，无须查询文档也可以通过命名及描述信息来进行查询。</p>
<p>对于前端而言，GraphQL 提供了一种基于特定语言的查询模式，让前端可以随心所欲地获得想要的数据类型，是相当友好的；而对于后端而言，把数据的查询结果编写成 REST API 还是 GraphQL 的解析器，工作量相差不大，最大的问题是带来的收益可能无法抵消学习和改造成本。这在很大程度上增加了 GraphQL 的推广难度。</p>
<p>所以 GraphQL 的大多数实际使用场景分为两类，一类是前端工程师主导的新项目，后端采用 Node.js 来实现，用 GraphQL 来替代 REST；另一类就是将 Node.js 服务器作为中转服务器，为前端提供一个 GraphQL 查询，但实际上仍然是调用后端的 REST API 来获取数据。</p>
<p>总结</p>
<p>从 RPC 到 REST 再到 GraphQL，可以看到 API 规范上的一些明显变化。</p>
<p>关注点发生了明显的转移。从 API 的提供者，到 API 数据，再到 API 的使用者。</p>
<p>语义化的特性更加明显。从最初通过路径命名的方式，到利用 HTTP 头部字段 Method，再到直接定义新的查询语言。</p>
<p>带来的副作用，约束更多，实现起来更加复杂。</p>
<p>站在前端工程师的角度再来看这些 API 规范，对于 RPC 风格，了解即可；对于 REST API，需要重点理解它通过路径指向资源，以及利用 HTTP 方法来指代动作的特性；对于 GraphQL，应该从 API 调用者和 API 提供者两个角度来分别学习查询语句和模式。</p>
<p>最后布置一道思考题：在谈到 REST 规范时，提到一个反例“/samples/export”，你还能找到常见的不符合 REST 规范的例子吗？</p>
<p>-&ndash; ### 精选评论 ##### **杰： &gt; login register就是典型的反例 ##### *聪： &gt; 这一讲没搞懂，没理解是开发中的哪个环节用到的，我工作中怎么没接触到😂 ######     讲师回复： &gt;     这一讲是定义接口的过程，在前后端分离的开发方式中，只有在定义接口之后，前端工程师和后端工程师才会分别进入编码阶段。 ##### **童： &gt; 如果接口是要导出用户信息为Excel文件，符合REST 规范的话，不写/export那应该写什么呢 ######     讲师回复： &gt;     以本讲内容为例，提供一种实现思路供参考：仍然使用 GET /samples，然后在头部添加一些字段进行区分~ ##### **1508： &gt; 请问老师能再详细讲一下关于RPC的缺点 -冗余：把执行动作写在 URL 上实际是冗余的，因为 HTTP 的 Method 头部可以表示不同的动作行为。到底是什么意思吗？ ######     讲师回复： &gt;     比如 REST API 发送的请求： GET /user ，使用 RPC 风格可能写成： GET /getUser ，“getUser” 中的 “get” 就是冗余的，因为 GET 方法本身表示的就是获的意思</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%89%8D%E7%AB%AF%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6/">前端高手进阶</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E7%AC%AC17%E8%AE%B2_%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E5%8C%85%E5%92%8C%E4%BF%9D%E5%AD%98%E6%9C%BA%E5%88%B6/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">第17讲_如何制作游戏资源包和保存机制？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%9845%E8%AE%B2/%E7%AC%AC17%E8%AE%B2%E5%AE%B9%E5%99%A8%E5%8C%96%E5%8D%87%E7%BA%A7%E5%AF%B9%E6%9C%8D%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BD%B1%E5%93%8D/">
            <span class="next-text nav-default">第17讲：容器化升级对服务有哪些影响？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
