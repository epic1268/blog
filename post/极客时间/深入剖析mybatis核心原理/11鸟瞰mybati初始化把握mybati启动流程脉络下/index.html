<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>11鸟瞰MyBati初始化，把握MyBati启动流程脉络（下） - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="在上一讲，我们深入分析了MyBatis 初始化过程中对 mybatis-config.xml 全局配置文件的解析，详细介绍了其中每个标签的解析流程以及涉及的经典设计模式——构造者模式。这一讲我们就紧接着上一讲的内容，继续介绍 MyBatis 初始化流程，重点介绍Mapper.xml 配置文件的解析以及 SQL 语句的处理逻辑。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90mybatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/11%E9%B8%9F%E7%9E%B0mybati%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8A%8A%E6%8F%A1mybati%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%84%89%E7%BB%9C%E4%B8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90mybatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/11%E9%B8%9F%E7%9E%B0mybati%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8A%8A%E6%8F%A1mybati%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%84%89%E7%BB%9C%E4%B8%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="11鸟瞰MyBati初始化，把握MyBati启动流程脉络（下）">
  <meta property="og:description" content="在上一讲，我们深入分析了MyBatis 初始化过程中对 mybatis-config.xml 全局配置文件的解析，详细介绍了其中每个标签的解析流程以及涉及的经典设计模式——构造者模式。这一讲我们就紧接着上一讲的内容，继续介绍 MyBatis 初始化流程，重点介绍Mapper.xml 配置文件的解析以及 SQL 语句的处理逻辑。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="深入剖析MyBatis核心原理">

  <meta itemprop="name" content="11鸟瞰MyBati初始化，把握MyBati启动流程脉络（下）">
  <meta itemprop="description" content="在上一讲，我们深入分析了MyBatis 初始化过程中对 mybatis-config.xml 全局配置文件的解析，详细介绍了其中每个标签的解析流程以及涉及的经典设计模式——构造者模式。这一讲我们就紧接着上一讲的内容，继续介绍 MyBatis 初始化流程，重点介绍Mapper.xml 配置文件的解析以及 SQL 语句的处理逻辑。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="10205">
  <meta itemprop="keywords" content="深入剖析MyBatis核心原理">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="11鸟瞰MyBati初始化，把握MyBati启动流程脉络（下）">
  <meta name="twitter:description" content="在上一讲，我们深入分析了MyBatis 初始化过程中对 mybatis-config.xml 全局配置文件的解析，详细介绍了其中每个标签的解析流程以及涉及的经典设计模式——构造者模式。这一讲我们就紧接着上一讲的内容，继续介绍 MyBatis 初始化流程，重点介绍Mapper.xml 配置文件的解析以及 SQL 语句的处理逻辑。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">11鸟瞰MyBati初始化，把握MyBati启动流程脉络（下）</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 10205 字 </span>
          <span class="more-meta"> 预计阅读 21 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>在上一讲，我们深入分析了MyBatis 初始化过程中对 mybatis-config.xml 全局配置文件的解析，详细介绍了其中每个标签的解析流程以及涉及的经典设计模式——构造者模式。这一讲我们就紧接着上一讲的内容，继续介绍 MyBatis 初始化流程，重点介绍Mapper.xml 配置文件的解析以及 SQL 语句的处理逻辑。</p>
<p>Mapper.xml 映射文件解析全流程</p>
<p>在上一讲分析 mybatis-config.xml 配置文件解析流程的时候我们看到，在 mybatis-config.xml 配置文件中可以定义多个
<mapper>
标签指定 Mapper 配置文件的地址，MyBatis 会为每个 Mapper.xml 映射文件创建一个 XMLMapperBuilder 实例完成解析。</p>
<p>与 XMLConfigBuilder 类似，XMLMapperBuilder也是具体构造者的角色，继承了 BaseBuilder 这个抽象类，解析 Mapper.xml 映射文件的入口是 XMLMapperBuilder.parse() 方法，其核心步骤如下：</p>
<p>执行 configurationElement() 方法解析整个Mapper.xml 映射文件的内容；</p>
<p>获取当前 Mapper.xml 映射文件指定的 Mapper 接口，并进行注册；</p>
<p>处理 configurationElement() 方法中解析失败的
<resultMap>
标签；</p>
<p>处理 configurationElement() 方法中解析失败的
<cache-ref>
标签；</p>
<p>处理 configurationElement() 方法中解析失败的SQL 语句标签。</p>
<p>可以清晰地看到，configurationElement() 方法才是真正解析 Mapper.xml 映射文件的地方，其中定义了处理 Mapper.xml 映射文件的核心流程：</p>
<p>获取
<mapper>
标签中的 namespace 属性，同时会进行多种边界检查；</p>
<p>解析
<cache>
标签；</p>
<p>解析
<cache-ref>
标签；</p>
<p>解析
<resultMap>
标签；</p>
<p>解析
<sql>
标签；</p>
<p>解析
<select>
、
<insert>
、
<update>
、
<delete>
等 SQL 标签。</p>
<p>下面我们就按照顺序逐一介绍这些方法的核心实现。</p>
<p>1. 处理
<cache>
标签</p>
<p>我们知道 Cache 接口及其实现是MyBatis 一级缓存和二级缓存的基础，其中，一级缓存是默认开启的，而二级缓存默认情况下并没有开启，如有需要，可以通过
<cache>
标签为指定的namespace 开启二级缓存。</p>
<p>XMLMapperBuilder 中解析
<cache>
标签的核心逻辑位于 cacheElement() 方法之中，其具体步骤如下：</p>
<p>获取
<cache>
标签中的各项属性（type、flushInterval、size 等属性）；</p>
<p>读取
<cache>
标签下的子标签信息，这些信息将用于初始化二级缓存；</p>
<p>MapperBuilderAssistant 会根据上述配置信息，创建一个全新的Cache 对象并添加到 Configuration.caches 集合中保存。</p>
<p>也就是说，解析
<cache>
标签得到的所有信息将会传给 MapperBuilderAssistant 完成 Cache 对象的创建，创建好的Cache 对象会添加到 Configuration.caches 集合中，这个 caches 字段是一个StrictMap
<Cache>
类型的集合，其中的 Key是Cache 对象的唯一标识，默认值是Mapper.xml 映射文件的namespace，Value 才是真正的二级缓存对应的 Cache 对象。</p>
<p>这里我们简单介绍一下 StrictMap的特性。</p>
<p>StrictMap 继承了 HashMap，并且覆盖了 HashMap 的一些行为，例如，相较于 HashMap 的 put() 方法，StrictMap 的 put() 方法有如下几点不同：</p>
<p>如果检测到重复 Key 的写入，会直接抛出异常；</p>
<p>在没有重复 Key的情况下，会正常写入 KV 数据，与此同时，还会根据 Key产生一个 shortKey，shortKey 与完整 Key 指向同一个 Value 值；</p>
<p>如果 shortKey 已经存在，则将 value 修改成 Ambiguity 对象，Ambiguity 对象表示这个 shortKey 存在二义性，后续通过 StrictMap的get() 方法获取该 shortKey 的时候，会抛出异常。</p>
<p>了解了 StrictMap 这个集合类的特性之后，我们回到MapperBuilderAssistant 这个类继续分析，在它的 useNewCache() 方法中，会根据前面解析得到的配置信息，通过 CacheBuilder 创建 Cache 对象。</p>
<p>通过名字你就能猜测到 CacheBuilder 是 Cache 的构造者，CacheBuilder 中最核心的方法是build() 方法，其中会根据传入的配置信息创建底层存储数据的 Cache 对象以及相关的 Cache 装饰器，具体实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="n">Cache</span> <span class="n">build</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">将</span><span class="n">implementation默认值设置为PerpetualCache</span><span class="err">，在</span><span class="n">decorators集合中默认添加LruCache装饰器</span><span class="err">，</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">都是在</span><span class="n">setDefaultImplementations</span><span class="p">()</span><span class="err">方法中完成的</span>
</span></span><span class="line"><span class="cl">    <span class="n">setDefaultImplementations</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">通过反射，初始化</span><span class="n">implementation指定类型的对象</span>
</span></span><span class="line"><span class="cl">    <span class="n">Cache</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">newBaseCacheInstance</span><span class="p">(</span><span class="n">implementation</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">创建</span><span class="n">Cache关联的MetaObject对象</span><span class="err">，并根据</span><span class="n">properties设置Cache中的各个字段</span>
</span></span><span class="line"><span class="cl">    <span class="n">setCacheProperties</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">根据上面创建的</span><span class="n">Cache对象类型</span><span class="err">，决定是否添加装饰器</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">PerpetualCache</span><span class="o">.</span><span class="k">class</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">cache</span><span class="o">.</span><span class="n">getClass</span><span class="p">()))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">如果是</span><span class="n">PerpetualCache类型</span><span class="err">，则为其添加</span><span class="n">decorators集合中指定的装饰器</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="err">?</span> <span class="k">extends</span> <span class="n">Cache</span><span class="o">&gt;</span> <span class="n">decorator</span> <span class="p">:</span> <span class="n">decorators</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="o">//</span> <span class="err">通过反射创建</span><span class="n">Cache装饰器</span>
</span></span><span class="line"><span class="cl">            <span class="n">cache</span> <span class="o">=</span> <span class="n">newCacheDecoratorInstance</span><span class="p">(</span><span class="n">decorator</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">//</span> <span class="err">依赖</span><span class="n">MetaObject将properties中配置信息设置到Cache的各个属性中</span><span class="err">，同时调用</span><span class="n">Cache的initialize</span><span class="p">()</span><span class="err">方法完成初始化</span>
</span></span><span class="line"><span class="cl">            <span class="n">setCacheProperties</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">根据</span><span class="n">readWrite</span><span class="err">、</span><span class="n">blocking</span><span class="err">、</span><span class="n">clearInterval等配置</span><span class="err">，</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">添加</span><span class="n">SerializedCache</span><span class="err">、</span><span class="n">ScheduledCache等装饰器</span>
</span></span><span class="line"><span class="cl">        <span class="n">cache</span> <span class="o">=</span> <span class="n">setStandardDecorators</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LoggingCache</span><span class="o">.</span><span class="k">class</span><span class="o">.</span><span class="n">isAssignableFrom</span><span class="p">(</span><span class="n">cache</span><span class="o">.</span><span class="n">getClass</span><span class="p">()))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">如果不是</span><span class="n">PerpetualCache类型</span><span class="err">，就是其他自定义类型的</span><span class="n">Cache</span><span class="err">，则添加一个</span><span class="n">LoggingCache装饰器</span>
</span></span><span class="line"><span class="cl">        <span class="n">cache</span> <span class="o">=</span> <span class="n">new</span> <span class="n">LoggingCache</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>2. 处理
<cache-ref>
标签</p>
<p>通过上述介绍我们知道，可以通过
<cache>
标签为每个 namespace 开启二级缓存，同时还会将 namespace 与关联的二级缓存 Cache对象记录到 Configuration.caches 集合中，也就是说二级缓存是 namespace 级别的。但是，在有的场景中，我们会需要在多个 namespace 共享同一个二级缓存，也就是共享同一个 Cache 对象。</p>
<p>为了解决这个需求，MyBatis提供了
<cache-ref>
标签来引用另一个 namespace 的二级缓存。cacheRefElement() 方法是处理
<cache-ref>
标签的核心逻辑所在，在 Configuration 中维护了一个 cacheRefMap 字段（HashMap&lt;String,String&gt; 类型），其中的 Key 是
<cache-ref>
标签所属的namespace 标识，Value 值是
<cache-ref>
标签引用的 namespace 值，这样的话，就可以将两个namespace 关联起来了，即这两个 namespace 共用一个 Cache对象。</p>
<p>这里会使用到一个叫 CacheRefResolver 的 Cache 引用解析器。CacheRefResolver 中记录了被引用的 namespace以及当前 namespace 关联的MapperBuilderAssistant 对象。前面在解析
<cache>
标签的时候我们介绍过，MapperBuilderAssistant 会在 useNewCache() 方法中通过 CacheBuilder 创建新的 Cache 对象，并记录到 currentCache 字段。而这里解析
<cache-ref>
标签的时候，MapperBuilderAssistant 会通过 useCacheRef() 方法从 Configuration.caches 集合中，根据被引用的namespace 查找共享的 Cache 对象来初始化 currentCache，而不再创建新的Cache 对象，从而实现二级缓存的共享。</p>
<p>3. 处理
<resultMap>
标签</p>
<p>有关系型数据库使用经验的同学应该知道，select 语句执行得到的结果集实际上是一张二维表，而 Java 是一门面向对象的程序设计语言，在使用 JDBC 的时候，我们需要手动写代码将select 语句的结果集转换成 Java 对象，这是一项重复性很大的操作。</p>
<p>为了将 Java 开发者从这种重复性的工作中解脱出来，MyBatis 提供了
<resultMap>
标签来定义结果集与 Java 对象之间的映射规则。</p>
<p>首先，
<resultMap>
标签下的每一个子标签，例如，
<column>
、
<id>
等，都被解析一个 ResultMapping 对象，其中维护了数据库表中一个列与对应 Java 类中一个属性之间的映射关系。</p>
<p>下面是 ResultMapping 中核心字段的含义。</p>
<p>column（String 类型）：当前标签中指定的 column 属性值，指向的是数据库表中的一个列名（或是别名）。</p>
<p>property（String 类型）：当前标签中指定的 property 属性值，指向的是与 column 列对应的属性名称。</p>
<p>javaType（Class<?> 类型）、jdbcType（JdbcType 类型）：当前标签指定的 javaType 属性值和 jdbcType 属性值，指定了 property 字段的 Java 类型以及对应列的 JDBC 类型。</p>
<p>typeHandler（TypeHandler<?> 类型）：当前标签的 typeHandler 属性值，这里指定的 TypeHandler 会覆盖默认的类型处理器。</p>
<p>nestedResultMapId（String类型）：当前标签的 resultMap 属性值，通过该属性我们可以引用另一个
<resultMap>
标签的id，然后由这个被引用的
<resultMap>
标签映射结果集中的一部分列。这样，我们就可以将一个查询结果集映射成多个对象，同时确定这些对象之间的关联关系。</p>
<p>nestedQueryId（String 类型）：当前标签的select 属性，我们可以通过该属性引用另一个
<select>
标签中的select 语句定义，它会将当前列的值作为参数传入这个 select 语句。由于当前结果集可能查询出多行数据，那么可能就会导致 select 属性指定的 SQL 语句会执行多次，也就是著名的 N+1 问题。</p>
<p>columnPrefix（String 类型）：当前标签的 columnPrefix 属性值，记录了表中列名的公共前缀。</p>
<p>resultSet（String 类型）：当前标签的 resultSet 属性值。</p>
<p>lazy（boolean 类型）：当前标签的fetchType 属性，表示是否延迟加载当前标签对应的列。</p>
<p>介绍完 ResultMapping 对象（即
<resultMap>
标签下各个子标签的解析结果）之后，我们再来看
<resultMap>
标签如何被解析。整个
<resultMap>
标签最终会被解析成 ResultMap 对象，它与 ResultMapping 之间的映射关系如下图所示：</p>
<p>ResultMap 结构图</p>
<p>通过上图我们可以看出，ResultMap 中有四个集合与 ResultMapping 紧密相连。</p>
<p>resultMappings 集合，维护了整个
<resultMap>
标签解析之后得到的全部映射关系，也就是全部 ResultMapping 对象。</p>
<p>idResultMappings 集合，维护了与唯一标识相关的映射，例如，
<id>
标签、
<constructor>
标签下的
<idArg>
子标签解析得到的 ResultMapping 对象。如果没有定义
<id>
等唯一性标签，则由 resultMappings 集合中全部映射关系来确定一条记录的唯一性，即 idResultMappings 集合与 resulMappings 集合相同。</p>
<p>constructorResultMappings 集合，维护了
<constructor>
标签下全部子标签定义的映射关系。</p>
<p>propertyResultMappings 集合，维护了不带 Constructor 标志的映射关系。</p>
<p>除了上述四个 ResultMapping 集合，ResultMap 中还维护了下列核心字段。</p>
<p>id（String 类型）：当前
<resultMap>
标签的 id 属性值。</p>
<p>type（Class 类型）：当前
<resultMap>
的 type 属性值。</p>
<p>mappedColumns（Set
<String>
类型）：维护了所有映射关系中涉及的 column 属性值，也就是所有的列名（或别名）。</p>
<p>hasNestedResultMaps（boolean 类型）：当前
<resultMap>
标签是否嵌套了其他
<resultMap>
标签，即这个映射关系中指定了 resultMap属性，且未指定 resultSet 属性。</p>
<p>hasNestedQueries（boolean 类型）：当前
<resultMap>
标签是否含有嵌套查询。也就是说，这个映射关系中是否指定了 select 属性。</p>
<p>autoMapping（Boolean 类型）：当前 ResultMap 是否开启自动映射的功能。</p>
<p>discriminator（Discriminator 类型）：对应
<discriminator>
标签。</p>
<p>接下来我们开始深入分析
<resultMap>
标签解析的流程。XMLMapperBuilder的resultMapElements() 方法负责解析 Mapper 配置文件中的全部
<resultMap>
标签，其中会通过 resultMapElement() 方法解析单个
<resultMap>
标签。</p>
<p>下面是 resultMapElement() 方法解析
<resultMap>
标签的核心流程。</p>
<p>获取
<resultMap>
标签的type 属性值，这个值表示结果集将被映射成 type 指定类型的对象。如果没有指定 type 属性的话，会找其他属性值，优先级依次是：type、ofType、resultType、javaType。在这一步中会确定映射得到的对象类型，这里支持别名转换。</p>
<p>解析
<resultMap>
标签下的各个子标签，每个子标签都会生成一个ResultMapping 对象，这个 ResultMapping 对象会被添加到resultMappings 集合（List
<ResultMapping>
类型）中暂存。这里会涉及
<id>
、
<result>
、
<association>
、
<collection>
、
<discriminator>
等子标签的解析。</p>
<p>获取
<resultMap>
标签的id 属性，默认值会拼装所有父标签的id、value 或 property 属性值。</p>
<p>获取
<resultMap>
标签的extends、autoMapping 等属性。</p>
<p>创建 ResultMapResolver 对象，ResultMapResolver 会根据上面解析到的ResultMappings 集合以及
<resultMap>
标签的属性构造 ResultMap 对象，并将其添加到 Configuration.resultMaps 集合（StrictMap 类型）中。</p>
<p>（1）解析
<id>
、
<result>
、
<constructor>
标签</p>
<p>在 resultMapElement() 方法中获取到 id 属性和 type 属性值之后，会调用 buildResultMappingFromContext() 方法解析上述标签得到 ResultMapping 对象，其核心逻辑如下：</p>
<p>获取当前标签的property的属性值作为目标属性名称（如果
<constructor>
标签使用的是 name 属性）；</p>
<p>获取 column、javaType、typeHandler、jdbcType、select 等一系列属性，与获取 property 属性的方式类似；</p>
<p>根据上面解析到的信息，调用 MapperBuilderAssistant.buildResultMapping() 方法创建 ResultMapping 对象。</p>
<p>正如 resultMapElement() 方法核心步骤描述的那样，经过解析得到 ResultMapping 对象集合之后，会记录到resultMappings 这个临时集合中，然后由 ResultMapResolver 调用 MapperBuilderAssistant.addResultMap() 方法创建 ResultMap 对象，将resultMappings 集合中的全部 ResultMapping 对象添加到其中，然后将ResultMap 对象记录到 Configuration.resultMaps 集合中。</p>
<p>下面是 MapperBuilderAssistant.addResultMap() 的具体实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="n">ResultMap</span> <span class="n">addResultMap</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="ne">String</span> <span class="n">id</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">Class</span><span class="o">&lt;</span><span class="err">?</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="ne">String</span> <span class="n">extend</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">Discriminator</span> <span class="n">discriminator</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">List</span><span class="o">&lt;</span><span class="n">ResultMapping</span><span class="o">&gt;</span> <span class="n">resultMappings</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">Boolean</span> <span class="n">autoMapping</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">ResultMap的完整id是</span><span class="s2">&#34;namespace.id&#34;</span><span class="err">的格式</span>
</span></span><span class="line"><span class="cl">    <span class="n">id</span> <span class="o">=</span> <span class="n">applyCurrentNamespace</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="bp">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">获取被继承的</span><span class="n">ResultMap的完整id</span><span class="err">，也就是父</span><span class="n">ResultMap对象的完整id</span>
</span></span><span class="line"><span class="cl">    <span class="n">extend</span> <span class="o">=</span> <span class="n">applyCurrentNamespace</span><span class="p">(</span><span class="n">extend</span><span class="p">,</span> <span class="bp">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">extend</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>  <span class="o">//</span> <span class="err">针对</span><span class="n">extend属性的处理</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">检测</span><span class="n">Configuration</span><span class="o">.</span><span class="n">resultMaps集合中是否存在被继承的ResultMap对象</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">configuration</span><span class="o">.</span><span class="n">hasResultMap</span><span class="p">(</span><span class="n">extend</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">throw</span> <span class="n">new</span> <span class="n">IncompleteElementException</span><span class="p">(</span><span class="s2">&#34;Could not find a parent resultmap with id &#39;&#34;</span> <span class="o">+</span> <span class="n">extend</span> <span class="o">+</span> <span class="s2">&#34;&#39;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">获取需要被继承的</span><span class="n">ResultMap对象</span><span class="err">，也就是父</span><span class="n">ResultMap对象</span>
</span></span><span class="line"><span class="cl">        <span class="n">ResultMap</span> <span class="n">resultMap</span> <span class="o">=</span> <span class="n">configuration</span><span class="o">.</span><span class="n">getResultMap</span><span class="p">(</span><span class="n">extend</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">获取父</span><span class="n">ResultMap对象中记录的ResultMapping集合</span>
</span></span><span class="line"><span class="cl">        <span class="n">List</span><span class="o">&lt;</span><span class="n">ResultMapping</span><span class="o">&gt;</span> <span class="n">extendedResultMappings</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">resultMap</span><span class="o">.</span><span class="n">getResultMappings</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">删除需要覆盖的</span><span class="n">ResultMapping集合</span>
</span></span><span class="line"><span class="cl">        <span class="n">extendedResultMappings</span><span class="o">.</span><span class="n">removeAll</span><span class="p">(</span><span class="n">resultMappings</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">如果当前</span><span class="o">&lt;</span><span class="n">resultMap</span><span class="o">&gt;</span><span class="err">标签中定义了</span><span class="o">&lt;</span><span class="n">constructor</span><span class="o">&gt;</span><span class="err">标签，则不需要使用父</span><span class="n">ResultMap中记录</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">的相应</span><span class="o">&lt;</span><span class="n">constructor</span><span class="o">&gt;</span><span class="err">标签，这里会将其对应的</span><span class="n">ResultMapping对象删除</span>
</span></span><span class="line"><span class="cl">        <span class="n">boolean</span> <span class="n">declaresConstructor</span> <span class="o">=</span> <span class="bp">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">ResultMapping</span> <span class="n">resultMapping</span> <span class="p">:</span> <span class="n">resultMappings</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">resultMapping</span><span class="o">.</span><span class="n">getFlags</span><span class="p">()</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">ResultFlag</span><span class="o">.</span><span class="n">CONSTRUCTOR</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">declaresConstructor</span> <span class="o">=</span> <span class="bp">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">declaresConstructor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">extendedResultMappings</span><span class="o">.</span><span class="n">removeIf</span><span class="p">(</span><span class="n">resultMapping</span> <span class="o">-&gt;</span> <span class="n">resultMapping</span><span class="o">.</span><span class="n">getFlags</span><span class="p">()</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">ResultFlag</span><span class="o">.</span><span class="n">CONSTRUCTOR</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">添加需要被继承下来的</span><span class="n">ResultMapping对象记录到resultMappings集合中</span>
</span></span><span class="line"><span class="cl">        <span class="n">resultMappings</span><span class="o">.</span><span class="n">addAll</span><span class="p">(</span><span class="n">extendedResultMappings</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">创建</span><span class="n">ResultMap对象</span><span class="err">，并添加到</span><span class="n">Configuration</span><span class="o">.</span><span class="n">resultMaps集合中保存</span>
</span></span><span class="line"><span class="cl">    <span class="n">ResultMap</span> <span class="n">resultMap</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ResultMap</span><span class="o">.</span><span class="n">Builder</span><span class="p">(</span><span class="n">configuration</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">resultMappings</span><span class="p">,</span> <span class="n">autoMapping</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="n">discriminator</span><span class="p">(</span><span class="n">discriminator</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="n">build</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">configuration</span><span class="o">.</span><span class="n">addResultMap</span><span class="p">(</span><span class="n">resultMap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">resultMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>至于
<constructor>
标签的流程，是由XMLMapperBuilder 中的processConstructorElement() 方法实现，其中会先获取
<constructor>
标签的全部子标签，然后为每个标签添加 CONSTRUCTOR 标志（为每个
<idArg>
标签添加额外的ID标志），最后通过 buildResultMappingFromContext()方法创建 ResultMapping对象并记录到 resultMappings 集合中暂存，这些 ResultMapping 对象最终也会添加到前面介绍的ResultMap 对象。</p>
<p>（2）解析
<association>
和
<collection>
标签</p>
<p>接下来，我们来介绍解析
<association>
和
<collection>
标签的核心流程，两者解析的过程基本一致。前面介绍的 buildResultMappingFromContext() 方法不仅完成了
<id>
、
<result>
等标签的解析，还完成了
<association>
和
<collection>
标签的解析，其中相关的代码片段如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private ResultMapping buildResultMappingFromContext(XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags) {
</span></span><span class="line"><span class="cl">    ... // &lt;association&gt;标签中其他属性的解析与&lt;result&gt;、&lt;id&gt;标签类似，这里不再展开
</span></span><span class="line"><span class="cl">    // 如果&lt;association&gt;标签没有指定resultMap属性，那么就是匿名嵌套映射，需要通过
</span></span><span class="line"><span class="cl">    //  processNestedResultMappings()方法解析该匿名的嵌套映射
</span></span><span class="line"><span class="cl">    String nestedResultMap = context.getStringAttribute(&#34;resultMap&#34;, () -&gt;
</span></span><span class="line"><span class="cl">            processNestedResultMappings(context, Collections.emptyList(), resultType));
</span></span><span class="line"><span class="cl">    ... // &lt;association&gt;标签中其他属性的解析与&lt;result&gt;、&lt;id&gt;标签类似，这里不再展开
</span></span><span class="line"><span class="cl">    // 根据上面解析到的属性值，创建ResultMapping对象
</span></span><span class="line"><span class="cl">    return builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的 processNestedResultMappings() 方法会递归执行resultMapElement() 方法解析
<association>
标签和
<collection>
标签指定的匿名嵌套映射，得到一个完整的ResultMap 对象，并添加到Configuration.resultMaps集合中。</p>
<p>（3）解析
<discriminator>
标签</p>
<p>最后一个要介绍的是
<discriminator>
标签的解析过程，我们将
<discriminator>
标签与
<case>
标签配合使用，根据结果集中某列的值改变映射行为。从 resultMapElement() 方法的逻辑我们可以看出，
<discriminator>
标签是由 processDiscriminatorElement() 方法专门进行解析的，具体实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private Discriminator processDiscriminatorElement(XNode context, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings) {
</span></span><span class="line"><span class="cl">    // 从&lt;discriminator&gt;标签中解析column、javaType、jdbcType、typeHandler四个属性的逻辑非常简单，这里将这部分代码省略
</span></span><span class="line"><span class="cl">    Map&lt;String, String&gt; discriminatorMap = new HashMap&lt;&gt;();
</span></span><span class="line"><span class="cl">    // 解析&lt;discriminator&gt;标签的&lt;case&gt;子标签
</span></span><span class="line"><span class="cl">    for (XNode caseChild : context.getChildren()) {
</span></span><span class="line"><span class="cl">        String value = caseChild.getStringAttribute(&#34;value&#34;);
</span></span><span class="line"><span class="cl">        // 通过前面介绍的processNestedResultMappings()方法，解析&lt;case&gt;标签，
</span></span><span class="line"><span class="cl">        // 创建相应的嵌套ResultMap对象
</span></span><span class="line"><span class="cl">        String resultMap = caseChild.getStringAttribute(&#34;resultMap&#34;,
</span></span><span class="line"><span class="cl">                processNestedResultMappings(caseChild, resultMappings, resultType));
</span></span><span class="line"><span class="cl">        // 记录该列值与对应选择的ResultMap的Id
</span></span><span class="line"><span class="cl">        discriminatorMap.put(value, resultMap);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 创建Discriminator对象
</span></span><span class="line"><span class="cl">    return builderAssistant.buildDiscriminator(resultType, column, javaTypeClass, jdbcTypeEnum, typeHandlerClass, discriminatorMap);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>SQL 语句解析全流程</p>
<p>在 Mapper.xml 映射文件中，除了上面介绍的标签之外，还有一类比较重要的标签，那就是
<select>
、
<insert>
、
<delete>
、
<update>
等 SQL 语句标签。虽然定义在 Mapper.xml 映射文件中，但是这些标签是由 XMLStatementBuilder 进行解析的，而不再由 XMLMapperBuilder 来完成解析。</p>
<p>在开始介绍 XMLStatementBuilder 解析 SQL 语句标签的具体实现之前，我们先来了解一下 MyBatis 在内存中是如何表示这些 SQL 语句标签的。在内存中，MyBatis 使用 SqlSource 接口来表示解析之后的 SQL 语句，其中的 SQL 语句只是一个中间态，可能包含动态 SQL 标签或占位符等信息，无法直接使用。SqlSource 接口的定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public interface SqlSource {
</span></span><span class="line"><span class="cl">    // 根据Mapper文件或注解描述的SQL语句，以及传入的实参，返回可执行的SQL
</span></span><span class="line"><span class="cl">    BoundSql getBoundSql(Object parameterObject);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>MyBatis 在内存中使用 MappedStatement 对象表示上述 SQL 标签。在 MappedStatement 中的 sqlSource 字段记录了 SQL 标签中定义的 SQL 语句，sqlCommandType 字段记录了 SQL 语句的类型（INSERT、UPDATE、DELETE、SELECT 或 FLUSH 类型）。</p>
<p>介绍完表示 SQL 标签的基础类之后，我们来分析 XMLStatementBuilder 解析 SQL 标签的入口方法—— parseStatementNode() 方法，在该方法中首先会根据 id 属性和 databaseId 属性决定加载匹配的 SQL 标签，然后解析其中的
<include>
标签和
<selectKey>
标签，相关的代码片段如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public void parseStatementNode() {
</span></span><span class="line"><span class="cl">    // 获取SQL标签的id以及databaseId属性
</span></span><span class="line"><span class="cl">    String id = context.getStringAttribute(&#34;id&#34;);
</span></span><span class="line"><span class="cl">    String databaseId = context.getStringAttribute(&#34;databaseId&#34;);
</span></span><span class="line"><span class="cl">    // 若databaseId属性值与当前使用的数据库不匹配，则不加载该SQL标签
</span></span><span class="line"><span class="cl">    // 若存在相同id且databaseId不为空的SQL标签，则不再加载该SQL标签
</span></span><span class="line"><span class="cl">    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) {
</span></span><span class="line"><span class="cl">        return;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 根据SQL标签的名称决定其SqlCommandType
</span></span><span class="line"><span class="cl">    String nodeName = context.getNode().getNodeName();
</span></span><span class="line"><span class="cl">    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));
</span></span><span class="line"><span class="cl">    // 获取SQL标签的属性值，例如，fetchSize、timeout、parameterType、parameterMap、
</span></span><span class="line"><span class="cl">    // resultMap、resultType、lang、resultSetType、flushCache、useCache等。
</span></span><span class="line"><span class="cl">    // 这些属性的具体含义在MyBatis官方文档中已经有比较详细的介绍了，这里不再赘述
</span></span><span class="line"><span class="cl">    ... ...
</span></span><span class="line"><span class="cl">    // 在解析SQL语句之前，先处理其中的&lt;include&gt;标签
</span></span><span class="line"><span class="cl">    XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);
</span></span><span class="line"><span class="cl">    includeParser.applyIncludes(context.getNode());
</span></span><span class="line"><span class="cl">    // 获取SQL标签的parameterType、lang两个属性
</span></span><span class="line"><span class="cl">    ... ...
</span></span><span class="line"><span class="cl">    // 解析&lt;selectKey&gt;标签
</span></span><span class="line"><span class="cl">    processSelectKeyNodes(id, parameterTypeClass, langDriver);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 暂时省略后面的逻辑
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>1. 处理
<include>
标签</p>
<p>在实际应用中，我们会在
<sql>
标签中定义一些能够被重用的SQL 片段，在 XMLMapperBuilder.sqlElement() 方法中会根据当前使用的 DatabaseId 匹配
<sql>
标签，只有匹配的 SQL 片段才会被加载到内存。</p>
<p>在解析 SQL 标签之前，MyBatis 会先将
<include>
标签转换成对应的 SQL 片段（即定义在
<sql>
标签内的文本），这个转换过程是在 XMLIncludeTransformer.applyIncludes() 方法中实现的（其中不仅包含了
<include>
标签的处理，还包含了“${}”占位符的处理）。</p>
<p>针对
<include>
标签的处理如下：</p>
<p>查找 refid 属性指向的
<sql>
标签，得到其对应的 Node 对象；</p>
<p>解析
<include>
标签下的
<property>
标签，将得到的键值对添加到 variablesContext 集合（Properties 类型）中，并形成新的 Properties 对象返回，用于替换占位符；</p>
<p>递归执行 applyIncludes()方法，因为在
<sql>
标签的定义中可能会使用
<include>
引用其他 SQL 片段，在 applyIncludes()方法递归的过程中，如果遇到“${}”占位符，则使用 variablesContext 集合中的键值对进行替换；</p>
<p>最后，将
<include>
标签替换成
<sql>
标签的内容。</p>
<p>通过上面逻辑可以看出，
<include>
标签和
<sql>
标签是可以嵌套多层的，此时就会涉及 applyIncludes()方法的递归，同时可以配合“${}”占位符，实现 SQL 片段模板化，更大程度地提高 SQL 片段的重用率。</p>
<p>2. 处理
<selectKey>
标签</p>
<p>在有的数据库表设计场景中，我们会添加一个自增 ID 字段作为主键，例如，用户 ID、订单 ID 或者这个自增 ID 本身并没有什么业务含义，只是一个唯一标识而已。在某些业务逻辑里面，我们希望在执行 insert 语句的时候返回这个自增 ID 值，
<selectKey>
标签就可以实现自增 ID 的获取。
<selectKey>
标签不仅可以获取自增 ID，还可以指定其他 SQL 语句，从其他表或执行数据库的函数获取字段值。</p>
<p>parseSelectKeyNode() 方法是解析
<selectKey>
标签的核心所在，其中会解析
<selectKey>
标签的各个属性，并根据这些属性值将其中的 SQL 语句解析成 MappedStatement 对象，具体实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private void parseSelectKeyNode(String id, XNode nodeToHandle, Class&lt;?&gt; parameterTypeClass, LanguageDriver langDriver, String databaseId) {
</span></span><span class="line"><span class="cl">    ... // 解析&lt;selectKey&gt;标签的resultType、statementType、keyProperty等属性
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 通过LanguageDriver解析&lt;selectKey&gt;标签中的SQL语句，得到对应的SqlSource对象
</span></span><span class="line"><span class="cl">    SqlSource sqlSource = langDriver.createSqlSource(configuration, nodeToHandle, parameterTypeClass);
</span></span><span class="line"><span class="cl">    SqlCommandType sqlCommandType = SqlCommandType.SELECT;
</span></span><span class="line"><span class="cl">    // 创建MappedStatement对象
</span></span><span class="line"><span class="cl">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,
</span></span><span class="line"><span class="cl">            fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,
</span></span><span class="line"><span class="cl">            resultSetTypeEnum, flushCache, useCache, resultOrdered,
</span></span><span class="line"><span class="cl">            keyGenerator, keyProperty, keyColumn, databaseId, langDriver, null);
</span></span><span class="line"><span class="cl">    id = builderAssistant.applyCurrentNamespace(id, false);
</span></span><span class="line"><span class="cl">    // 创建&lt;selectKey&gt;标签对应的KeyGenerator对象，这个KeyGenerator对象会添加到Configuration.keyGenerators集合中
</span></span><span class="line"><span class="cl">    MappedStatement keyStatement = configuration.getMappedStatement(id, false);
</span></span><span class="line"><span class="cl">    configuration.addKeyGenerator(id, new SelectKeyGenerator(keyStatement, executeBefore));
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>3. 处理 SQL 语句</p>
<p>经过
<include>
标签和
<selectKey>
标签的处理流程之后，XMLStatementBuilder 中的 parseStatementNode()方法接下来就要开始处理 SQL 语句了，相关的代码片段之前被省略了，这里我们详细分析一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public void parseStatementNode() {
</span></span><span class="line"><span class="cl">    // 前面是解析&lt;selectKey&gt;和&lt;include&gt;标签的逻辑，这里不再展示
</span></span><span class="line"><span class="cl">    // 当执行到这里的时候，&lt;selectKey&gt;和&lt;include&gt;标签已经被解析完毕，并删除掉了
</span></span><span class="line"><span class="cl">    // 下面是解析SQL语句的逻辑，也是parseStatementNode()方法的核心
</span></span><span class="line"><span class="cl">    // 通过LanguageDriver.createSqlSource()方法创建SqlSource对象
</span></span><span class="line"><span class="cl">    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 获取SQL标签中配置的resultSets、keyProperty、keyColumn等属性，以及前面解析&lt;selectKey&gt;标签得到的KeyGenerator对象等，
</span></span><span class="line"><span class="cl">    // 这些信息将会填充到MappedStatement对象中
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 根据上述属性信息创建MappedStatement对象，并添加到Configuration.mappedStatements集合中保存
</span></span><span class="line"><span class="cl">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,
</span></span><span class="line"><span class="cl">            fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,
</span></span><span class="line"><span class="cl">            resultSetTypeEnum, flushCache, useCache, resultOrdered,
</span></span><span class="line"><span class="cl">            keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里解析 SQL 语句使用的是 LanguageDriver 接口，其核心实现是 XMLLanguageDriver，继承关系如下图所示：</p>
<p>LanguageDriver 继承关系图</p>
<p>在 createSqlSource() 方法中，XMLLanguageDriver 会依赖 XMLScriptBuilder 创建 SqlSource 对象，XMLScriptBuilder 首先会判断 SQL 语句是否为动态SQL，判断的核心逻辑在 parseDynamicTags()方法中，核心实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">protected MixedSqlNode parseDynamicTags(XNode node) {
</span></span><span class="line"><span class="cl">    List&lt;SqlNode&gt; contents = new ArrayList&lt;&gt;(); // 解析后的SqlNode结果集合
</span></span><span class="line"><span class="cl">    NodeList children = node.getNode().getChildNodes();
</span></span><span class="line"><span class="cl">    // 获取SQL标签下的所有节点，包括标签节点和文本节点
</span></span><span class="line"><span class="cl">    for (int i = 0; i &lt; children.getLength(); i++) {
</span></span><span class="line"><span class="cl">        XNode child = node.newXNode(children.item(i));
</span></span><span class="line"><span class="cl">        if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE ||
</span></span><span class="line"><span class="cl">                child.getNode().getNodeType() == Node.TEXT_NODE) {
</span></span><span class="line"><span class="cl">            // 处理文本节点，也就是SQL语句
</span></span><span class="line"><span class="cl">            String data = child.getStringBody(&#34;&#34;);
</span></span><span class="line"><span class="cl">            TextSqlNode textSqlNode = new TextSqlNode(data);
</span></span><span class="line"><span class="cl">            // 解析SQL语句，如果含有未解析的&#34;${}&#34;占位符，则为动态SQL
</span></span><span class="line"><span class="cl">            if (textSqlNode.isDynamic()) {
</span></span><span class="line"><span class="cl">                contents.add(textSqlNode);
</span></span><span class="line"><span class="cl">                isDynamic = true; // 标记为动态SQL语句
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                contents.add(new StaticTextSqlNode(data));
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        } else if (child.getNode().getNodeType() == Node.ELEMENT_NODE) {
</span></span><span class="line"><span class="cl">            // 如果解析到一个子标签，那么一定是动态SQL
</span></span><span class="line"><span class="cl">            // 这里会根据不同的标签，获取不同的NodeHandler，然后由NodeHandler进行后续解析
</span></span><span class="line"><span class="cl">            String nodeName = child.getNode().getNodeName();
</span></span><span class="line"><span class="cl">            NodeHandler handler = nodeHandlerMap.get(nodeName);
</span></span><span class="line"><span class="cl">            if (handler == null) {
</span></span><span class="line"><span class="cl">                throw new BuilderException(&#34;Unknown element &lt;&#34; + nodeName + &#34;&gt; in SQL statement.&#34;);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // 处理动态SQL语句，并将解析得到的SqlNode对象记录到contents集合中
</span></span><span class="line"><span class="cl">            handler.handleNode(child, contents);
</span></span><span class="line"><span class="cl">            isDynamic = true;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 解析后的SqlNode集合将会被封装成MixedSqlNode返回
</span></span><span class="line"><span class="cl">    return new MixedSqlNode(contents);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里使用 SqlNode 接口来表示一条 SQL 语句的不同部分，其中，TextSqlNode 表示的是SQL 语句的文本（可能包含“${}”占位符），StaticTextSqlNode 表示的是不包含占位符的SQL 语句文本。</p>
<p>另外一个新接口是NodeHandler，它有很多实现类，如下图所示：</p>
<p>NodeHandler 继承关系图</p>
<p>NodeHandler接口负责解析动态 SQL 内的标签，生成相应的 SqlNode 对象，通过 NodeHandler 实现类的名称，我们就可以大概猜测到其解析的标签名称。以 IfHandler 为例，它解析的就是
<if>
标签，其核心实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private class IfHandler implements NodeHandler {
</span></span><span class="line"><span class="cl">    public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) {
</span></span><span class="line"><span class="cl">        // 通过parseDynamicTags()方法，解析&lt;if&gt;标签下嵌套的动态SQL
</span></span><span class="line"><span class="cl">        MixedSqlNode mixedSqlNode = parseDynamicTags(nodeToHandle);
</span></span><span class="line"><span class="cl">        // 获取&lt;if&gt;标签判断分支的条件
</span></span><span class="line"><span class="cl">        String test = nodeToHandle.getStringAttribute(&#34;test&#34;);
</span></span><span class="line"><span class="cl">        // 创建IfNode对象(也是SqlNode接口的实现)，并将其保存下来
</span></span><span class="line"><span class="cl">        IfSqlNode ifSqlNode = new IfSqlNode(mixedSqlNode, test);
</span></span><span class="line"><span class="cl">        targetContents.add(ifSqlNode);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>完成了对 SQL 语句的解析，得到了相应的 MixedSqlNode对象之后，XMLScriptBuilder 会根据 SQL 语句的类型生成不同的 SqlSource 实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public SqlSource parseScriptNode() {
</span></span><span class="line"><span class="cl">    // 对SQL语句进行解析
</span></span><span class="line"><span class="cl">    MixedSqlNode rootSqlNode = parseDynamicTags(context);
</span></span><span class="line"><span class="cl">    SqlSource sqlSource;
</span></span><span class="line"><span class="cl">    if (isDynamic) { // 根据该SQL是否为动态SQL，创建不同的SqlSource实现
</span></span><span class="line"><span class="cl">        sqlSource = new DynamicSqlSource(configuration, rootSqlNode);
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return sqlSource;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>总结</p>
<p>这一讲我们重点介绍了 MyBatis 在初始化过程中对 Mapper.xml 映射文件的解析。</p>
<p>首先，我们着重介绍了 Mapper.xml 映射文件中对
<cache>
标签、
<cache-ref>
标签以及
<resultMap>
标签（包括它的各个子标签）的解析流程，让我们知道 MyBatis是如何正确理解二级缓存的配置信息以及我们定义的各种映射规则。</p>
<p>然后，我们详细分析了 MyBatis 对 Mapper.xml 映射文件中 SQL 语句标签的解析，其中涉及
<include>
、
<selectKey>
等标签的处理逻辑。</p>
<p>在解析 SQL 语句的过程中，涉及了动态 SQL 语句的解析，不过这一讲只是让你找到了这一逻辑的入口，在下一讲，我们就会深入讲解 MyBatis 动态 SQL 的设计思想和解析流程，记得按时来听课。</p>
<p>《Java 工程师高薪训练营》</p>
<p>实战训练+面试模拟+大厂内推，想要提升技术能力，进大厂拿高薪，点击链接，提升自己！</p>
<p>-&ndash; ### 精选评论 ##### **红： &gt; 难度越来越大了 加油冲 ######     讲师回复： &gt;     一定坚持打卡哦！ ##### *鑫： &gt; 属实有点硬核啊</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90mybatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">深入剖析MyBatis核心原理</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/11%E5%8F%A6%E8%B5%B7%E7%82%89%E7%81%B6netty%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BD%BD%E4%BD%93bytebuf%E8%AF%A6%E8%A7%A3/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">11另起炉灶：Netty数据传输载体ByteBuf详解</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/11%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E4%B8%8E%E6%81%A2%E5%A4%8D%E4%B8%8B%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1/">
            <span class="next-text nav-default">11事务处理与恢复（下）：如何控制并发事务？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
