<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>16StatementHandler：参数绑定、SQL执行和结果映射的奠基者 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="StatementHandler 接口是 MyBatis 中非常重要的一个接口，其实现类完成 SQL 语句执行中最核心的一系列操作，这也是后面我们要介绍的 Executor 接口实现的基础。
StatementHandler 接口的定义如下图所示：
StatementHandler 接口中定义的方法
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90mybatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/16statementhandler%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9Asql%E6%89%A7%E8%A1%8C%E5%92%8C%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84%E7%9A%84%E5%A5%A0%E5%9F%BA%E8%80%85/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90mybatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/16statementhandler%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9Asql%E6%89%A7%E8%A1%8C%E5%92%8C%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84%E7%9A%84%E5%A5%A0%E5%9F%BA%E8%80%85/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="16StatementHandler：参数绑定、SQL执行和结果映射的奠基者">
  <meta property="og:description" content="StatementHandler 接口是 MyBatis 中非常重要的一个接口，其实现类完成 SQL 语句执行中最核心的一系列操作，这也是后面我们要介绍的 Executor 接口实现的基础。
StatementHandler 接口的定义如下图所示：
StatementHandler 接口中定义的方法">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="深入剖析MyBatis核心原理">

  <meta itemprop="name" content="16StatementHandler：参数绑定、SQL执行和结果映射的奠基者">
  <meta itemprop="description" content="StatementHandler 接口是 MyBatis 中非常重要的一个接口，其实现类完成 SQL 语句执行中最核心的一系列操作，这也是后面我们要介绍的 Executor 接口实现的基础。
StatementHandler 接口的定义如下图所示：
StatementHandler 接口中定义的方法">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3798">
  <meta itemprop="keywords" content="深入剖析MyBatis核心原理">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="16StatementHandler：参数绑定、SQL执行和结果映射的奠基者">
  <meta name="twitter:description" content="StatementHandler 接口是 MyBatis 中非常重要的一个接口，其实现类完成 SQL 语句执行中最核心的一系列操作，这也是后面我们要介绍的 Executor 接口实现的基础。
StatementHandler 接口的定义如下图所示：
StatementHandler 接口中定义的方法">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">16StatementHandler：参数绑定、SQL执行和结果映射的奠基者</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3798 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>StatementHandler 接口是 MyBatis 中非常重要的一个接口，其实现类完成 SQL 语句执行中最核心的一系列操作，这也是后面我们要介绍的 Executor 接口实现的基础。</p>
<p>StatementHandler 接口的定义如下图所示：</p>
<p>StatementHandler 接口中定义的方法</p>
<p>可以看到，其中提供了创建 Statement 对象（prepare() 方法）、为 SQL 语句绑定实参（parameterize() 方法）、执行单条 SQL 语句（query() 方法和 update() 方法）、批量执行 SQL 语句（batch() 方法）等多种功能。</p>
<p>下图展示了 MyBatis 中提供的所有 StatementHandler 接口实现类，以及它们的继承关系：</p>
<p>StatementHandler 接口继承关系图</p>
<p>今天这一讲我们就来详细分析该继承关系图中每个 StatementHandler 实现的核心逻辑。</p>
<p>RoutingStatementHandler</p>
<p>RoutingStatementHandler 这个 StatementHandler 实现，有点策略模式的意味。在 RoutingStatementHandler 的构造方法中，会根据 MappedStatement 中的 statementType 字段值，选择相应的 StatementHandler 实现进行创建，这个新建的 StatementHandler 对象由 RoutingStatementHandler 中的 delegate 字段维护。</p>
<p>RoutingStatementHandler 的构造方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
</span></span><span class="line"><span class="cl">    // 下面就是根据MappedStatement的配置，生成一个相应的StatementHandler对
</span></span><span class="line"><span class="cl">    // 象，并设置到delegate字段中维护
</span></span><span class="line"><span class="cl">    switch (ms.getStatementType()) {
</span></span><span class="line"><span class="cl">        case STATEMENT:
</span></span><span class="line"><span class="cl">            // 创建SimpleStatementHandler对象
</span></span><span class="line"><span class="cl">            delegate = new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        case PREPARED:
</span></span><span class="line"><span class="cl">            // 创建PreparedStatementHandler对象
</span></span><span class="line"><span class="cl">            delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        case CALLABLE:
</span></span><span class="line"><span class="cl">            // 创建CallableStatementHandler对象
</span></span><span class="line"><span class="cl">            delegate = new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        default: // 抛出异常
</span></span><span class="line"><span class="cl">            throw new ExecutorException(&#34;...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 RoutingStatementHandler 的其他方法中，都会委托给底层的 delegate 对象来完成具体的逻辑。</p>
<p>BaseStatementHandler</p>
<p>作为一个抽象类，BaseStatementHandler 只实现了 StatementHandler 接口的 prepare() 方法，其 prepare() 方法实现为新建的 Statement 对象设置了一些参数，例如，timeout、fetchSize 等。BaseStatementHandler 还新增了一个 instantiateStatement() 抽象方法给子类实现，来完成 Statement 对象的其他初始化操作。不过，BaseStatementHandler 中并没有实现 StatementHandler 接口中的数据库操作等核心方法。</p>
<p>了解了 BaseStatementHandler 对 StatementHandler 接口的实现情况之后，我们再来看一下 BaseStatementHandler 的构造方法，其中会初始化执行 SQL 需要的 Executor 对象、为 SQL 绑定实参的 ParameterHandler 对象以及生成结果对象的 ResultSetHandler 对象。这三个核心对象中，ResultSetHandler 对象我们已经在《14 | 探究 MyBatis 结果集映射机制背后的秘密（上）》中介绍过了，ParameterHandler 和 Executor 在后面会展开介绍。</p>
<p>1. KeyGenerator</p>
<p>这里需要关注的是 generateKeys() 方法，其中会通过 KeyGenerator 接口生成主键，下面我们就来看看 KeyGenerator 接口的相关内容。</p>
<p>我们知道不同数据库的自增 id 生成策略并不完全一样。例如，我们常见的 Oracle DB 是通过sequence 实现自增 id 的，如果使用自增 id 作为主键，就需要我们先获取到这个自增的 id 值，然后再使用；MySQL 在使用自增 id 作为主键的时候，insert 语句中可以不指定主键，在插入过程中由 MySQL 自动生成 id。KeyGenerator 接口支持 insert 语句执行前后获取自增的 id，分别对应 processBefore() 方法和 processAfter() 方法，下图展示了 MyBatis 提供的两个 KeyGenerator 接口实现：</p>
<p>KeyGenerator 接口继承关系图</p>
<p>Jdbc3KeyGenerator 用于获取数据库生成的自增 id（例如 MySQL 那种生成模式），其 processBefore() 方法是空实现，processAfter() 方法会将 insert 语句执行后生成的主键保存到用户传递的实参中。我们在使用 MyBatis 执行单行 insert 语句时，一般传入的实参是一个 POJO 对象或是 Map 对象，生成的主键会设置到对应的属性中；执行多条 insert 语句时，一般传入实参是 POJO 对象集合或 Map 对象的数组或集合，集合中每一个元素都对应一次插入操作，生成的多个自增 id 也会设置到每个元素的相应属性中。</p>
<p>Jdbc3KeyGenerator 中获取数据库自增 id 的核心代码片段如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 将数据库生成的自增id作为结果集返回
</span></span><span class="line"><span class="cl">try (ResultSet rs = stmt.getGeneratedKeys()) { 
</span></span><span class="line"><span class="cl">    final ResultSetMetaData rsmd = rs.getMetaData();
</span></span><span class="line"><span class="cl">    final Configuration configuration = ms.getConfiguration();
</span></span><span class="line"><span class="cl">    if (rsmd.getColumnCount() &lt; keyProperties.length) {
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        // 处理rs这个结果集，将生成的id设置到对应的属性中
</span></span><span class="line"><span class="cl">        assignKeys(configuration, rs, rsmd, keyProperties, parameter);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">} catch (Exception e) {
</span></span><span class="line"><span class="cl">    throw new ExecutorException(&#34;...&#34;);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果使用像 Oracle 这种不支持自动生成主键自增 id 的数据库时，我们可以使用 SelectkeyGenerator 来生成主键 id。Mapper 映射文件中的
<selectKey>
标签会被解析成 SelectkeyGenerator 对象，其中的 executeBefore 属性（boolean 类型）决定了是在 insert 语句执行之前获取主键，还是在 insert 语句执行之后获取主键 id。</p>
<p>SelectkeyGenerator 中的 processBefore() 方法和 processAfter() 方法都是通过 processGeneratedKeys() 这个私有方法获取主键 id 的，processGeneratedKeys() 方法会执行
<selectKey>
标签中指定的 select 语句，查询主键信息，并记录到用户传入的实参对象的对应属性中，核心代码片段如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 创建一个新的Executor对象来执行指定的select语句
</span></span><span class="line"><span class="cl">Executor keyExecutor = configuration.newExecutor(executor.getTransaction(), ExecutorType.SIMPLE);
</span></span><span class="line"><span class="cl">// 拿到主键信息
</span></span><span class="line"><span class="cl">List&lt;Object&gt; values = keyExecutor.query(keyStatement, parameter, RowBounds.DEFAULT, Executor.NO_RESULT_HANDLER);
</span></span><span class="line"><span class="cl">if (values.size() == 0) {
</span></span><span class="line"><span class="cl">    throw new ExecutorException(&#34;SelectKey returned no data.&#34;);
</span></span><span class="line"><span class="cl">} else if (values.size() &gt; 1) {
</span></span><span class="line"><span class="cl">    throw new ExecutorException(&#34;SelectKey returned more than one value.&#34;);
</span></span><span class="line"><span class="cl">} else {
</span></span><span class="line"><span class="cl">    // 创建实参对象的MetaObject对象
</span></span><span class="line"><span class="cl">    final MetaObject metaParam = configuration.newMetaObject(parameter);
</span></span><span class="line"><span class="cl">    MetaObject metaResult = configuration.newMetaObject(values.get(0));
</span></span><span class="line"><span class="cl">    if (keyProperties.length == 1) {
</span></span><span class="line"><span class="cl">        // 将主键信息记录到用户传入的实参对象中
</span></span><span class="line"><span class="cl">        if (metaResult.hasGetter(keyProperties[0])) {
</span></span><span class="line"><span class="cl">            setValue(metaParam, keyProperties[0], metaResult.getValue(keyProperties[0]));
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            setValue(metaParam, keyProperties[0], values.get(0));
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        ... // 多结果集的处理
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>2. ParameterHandler</p>
<p>介绍完 KeyGenerator 接口之后，我们再来看一下 BaseStatementHandler 中依赖的另一个辅助类—— ParameterHandler。</p>
<p>经过前面《13 | 深入分析动态 SQL 语句解析全流程（下）》介绍的一系列 SqlNode 的处理之后，我们得到的 SQL 语句（维护在 BoundSql 对象中）可能包含多个“?”占位符，与此同时，用于替换每个“?”占位符的实参都记录在 BoundSql.parameterMappings 集合中。</p>
<p>ParameterHandler 接口中定义了两个方法：一个是 getParameterObject() 方法，用来获取传入的实参对象；另一个是 setParameters() 方法，用来替换“?”占位符，这是 ParameterHandler 的核心方法。</p>
<p>DefaultParameterHandler 是 ParameterHandler 接口的唯一实现，其 setParameters() 方法会遍历 BoundSql.parameterMappings 集合，根据参数名称查找相应实参，最后会通过 PreparedStatement.set*() 方法与 SQL 语句进行绑定。setParameters() 方法的具体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int i = 0; i &lt; parameterMappings.size(); i++) {
</span></span><span class="line"><span class="cl">    ParameterMapping parameterMapping = parameterMappings.get(i);
</span></span><span class="line"><span class="cl">    Object value;
</span></span><span class="line"><span class="cl">    String propertyName = parameterMapping.getProperty();
</span></span><span class="line"><span class="cl">    // 获取实参值
</span></span><span class="line"><span class="cl">    if (boundSql.hasAdditionalParameter(propertyName)) {
</span></span><span class="line"><span class="cl">        value = boundSql.getAdditionalParameter(propertyName);
</span></span><span class="line"><span class="cl">    } else if (parameterObject == null) {
</span></span><span class="line"><span class="cl">        value = null;
</span></span><span class="line"><span class="cl">    } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
</span></span><span class="line"><span class="cl">        value = parameterObject;
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        MetaObject metaObject = configuration.newMetaObject(parameterObject);
</span></span><span class="line"><span class="cl">        value = metaObject.getValue(propertyName);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 获取TypeHandler
</span></span><span class="line"><span class="cl">    TypeHandler typeHandler = parameterMapping.getTypeHandler();
</span></span><span class="line"><span class="cl">    JdbcType jdbcType = parameterMapping.getJdbcType();
</span></span><span class="line"><span class="cl">    // 底层会调用PreparedStatement.set*()方法完成绑定
</span></span><span class="line"><span class="cl">    typeHandler.setParameter(ps, i + 1, value, jdbcType);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>SimpleStatementHandler</p>
<p>SimpleStatementHandler 是 StatementHandler 的具体实现之一，继承了 BaseStatementHandler 抽象类。SimpleStatementHandler 各个方法接收的是 java.sql.Statement 对象，并通过该对象来完成 CRUD 操作，所以在 SimpleStatementHandler 中维护的 SQL 语句不能存在“?”占位符，填充占位符的 parameterize() 方法也是空实现。</p>
<p>在 instantiateStatement() 这个初始化方法中，SimpleStatementHandler 会直接通过 JDBC Connection 创建 Statement 对象，这个对象也是后续 SimpleStatementHandler 其他方法的入参。</p>
<p>在 query() 方法实现中，SimpleStatementHandler 会直接通过上面创建的 Statement 对象，执行 SQL 语句，返回的结果集由 ResultSetHandler 完成映射，核心代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {、
</span></span><span class="line"><span class="cl">    // 获取SQL语句
</span></span><span class="line"><span class="cl">    String sql = boundSql.getSql();
</span></span><span class="line"><span class="cl">    // 执行SQL语句
</span></span><span class="line"><span class="cl">    statement.execute(sql);
</span></span><span class="line"><span class="cl">    // 处理ResultSet映射，得到结果对象
</span></span><span class="line"><span class="cl">    return resultSetHandler.handleResultSets(statement);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>queryCursor() 方法与 query() 方法实现类似，这里就不再赘述。</p>
<p>batch() 方法调用的是 Statement.addBatch() 方法添加批量执行的 SQL 语句，但并不是立即执行，而是等待 Statement.executeBatch() 方法执行时才会批量执行，这点你稍微注意一下即可。</p>
<p>至于 update() 方法，首先会通过 Statement.execute() 方法执行 insert、update 或 delete 类型的 SQL 语句，然后执行 KeyGenerator.processAfter() 方法查询主键并填充相应属性（processBefore() 方法已经在 prepare() 方法中执行过了），最后通过 Statement.getUpdateCount() 方法获取 SQL 语句影响的行数并返回。</p>
<p>PreparedStatementHandler</p>
<p>PreparedStatementHandler 是 StatementHandler 的具体实现之一，也是最常用的 StatementHandler 实现，它同样继承了 BaseStatementHandler 抽象类。PreparedStatementHandler 各个方法接收的是 java.sql.PreparedStatement 对象，并通过该对象来完成 CRUD 操作，在其 parameterize() 方法中会通过前面介绍的 ParameterHandler调用 PreparedStatement.set*() 方法为 SQL 语句绑定参数，所以在 PreparedStatementHandler 中维护的 SQL 语句是可以包含“?”占位符的。</p>
<p>在 instantiateStatement() 方法中，PreparedStatementHandler 会直接通过 JDBC Connection 的 prepareStatement() 方法创建 PreparedStatement 对象，该对象就是 PreparedStatementHandler 其他方法的入参。</p>
<p>PreparedStatementHandler 的 query() 方法、batch() 方法以及 update() 方法与 SimpleStatementHandler 的实现基本相同，只不过是把 Statement API 换成了 PrepareStatement API 而已。下面我们以 update() 方法为例进行简单介绍：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public int update(Statement statement) throws SQLException {
</span></span><span class="line"><span class="cl">    PreparedStatement ps = (PreparedStatement) statement;
</span></span><span class="line"><span class="cl">    ps.execute(); // 执行SQL语句，修改数据
</span></span><span class="line"><span class="cl">    int rows = ps.getUpdateCount(); // 获取影响行数
</span></span><span class="line"><span class="cl">    // 获取实参对象
</span></span><span class="line"><span class="cl">    Object parameterObject = boundSql.getParameterObject();
</span></span><span class="line"><span class="cl">    // 执行KeyGenerator
</span></span><span class="line"><span class="cl">    KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();
</span></span><span class="line"><span class="cl">    keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);
</span></span><span class="line"><span class="cl">    return rows; // 返回影响行数
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>CallableStatementHandler</p>
<p>CallableStatementHandler 是处理存储过程的 StatementHandler 实现，其 instantiateStatement() 方法会通过 JDBC Connection 的 prepareCall() 方法为指定存储过程创建对应的 java.sql.CallableStatement 对象。在 parameterize() 方法中，CallableStatementHandler 除了会通过 ParameterHandler 完成实参的绑定之外，还会指定输出参数的位置和类型。</p>
<p>在 CallableStatementHandler 的 query()、queryCursor()、update() 方法中，除了处理 SQL 语句本身的结果集（ResultSet 结果集或是影响行数），还会通过 ResultSetHandler 的 handleOutputParameters() 方法处理输出参数，这是与 PreparedStatementHandler 最大的不同。下面我们以 query() 方法为例进行简单分析：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {
</span></span><span class="line"><span class="cl">    CallableStatement cs = (CallableStatement) statement;
</span></span><span class="line"><span class="cl">    cs.execute(); // 执行存储过程
</span></span><span class="line"><span class="cl">    // 处理存储过程返回的结果集
</span></span><span class="line"><span class="cl">    List&lt;E&gt; resultList = resultSetHandler.handleResultSets(cs);
</span></span><span class="line"><span class="cl">    // 处理输出参数，可能修改resultList集合
</span></span><span class="line"><span class="cl">    resultSetHandler.handleOutputParameters(cs);
</span></span><span class="line"><span class="cl">    // 返回最后的结果对象
</span></span><span class="line"><span class="cl">    return resultList;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>总结</p>
<p>这一讲我们重点讲解了 MyBatis 中的 StatementHandler 接口及其核心实现，StatementHandler 接口中定义了执行一条 SQL 语句的核心方法。</p>
<p>首先，分析了 RoutingStatementHandler 实现，它可以帮助我们选择真正的 StatementHandler 实现类。</p>
<p>接下来，介绍了 BaseStatementHandler 这个抽象类的实现，同时还详细阐述了其中使用到的 KeyGenerator 和 ParameterHandler。</p>
<p>最后，又介绍了 SimpleStatementHandler、PreparedStatementHandler 等实现，它们基于 JDBC API 接口，实现了完整的 StatementHandler 功能。</p>
<p>下一讲，我们将开始讲解 MyBatis 中另一个核心接口—— Executor 接口，记得按时来听课。</p>
<p>《Java 工程师高薪训练营》</p>
<p>实战训练+面试模拟+大厂内推，想要提升技术能力，进大厂拿高薪，点击链接，提升自己！</p>
<p>-&ndash; ### 精选评论</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90mybatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">深入剖析MyBatis核心原理</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/16redi%E9%9B%86%E6%88%90%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9redi%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">16Redi集成：如何实现对Redi的响应式数据访问？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E5%AE%9E%E6%88%98%E8%AF%BE/1611%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E9%81%BF%E5%85%8Dcpu%E8%B5%84%E6%BA%90%E6%B5%AA%E8%B4%B9/">
            <span class="next-text nav-default">1611｜通过程序并行计算避免CPU资源浪费</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
