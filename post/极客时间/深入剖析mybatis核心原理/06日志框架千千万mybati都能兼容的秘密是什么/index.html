<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>06日志框架千千万，MyBati都能兼容的秘密是什么？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="Apache Commons Logging、Log4j、Log4j2、java.util.logging 等是 Java 开发中常用的几款日志框架，这些日志框架来源于不同的开源组织，给用户暴露的接口也有很多不同之处，所以很多开源框架会自己定义一套统一的日志接口，兼容上述第三方日志框架，供上层使用。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90mybatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/06%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%8D%83%E5%8D%83%E4%B8%87mybati%E9%83%BD%E8%83%BD%E5%85%BC%E5%AE%B9%E7%9A%84%E7%A7%98%E5%AF%86%E6%98%AF%E4%BB%80%E4%B9%88/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90mybatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/06%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%8D%83%E5%8D%83%E4%B8%87mybati%E9%83%BD%E8%83%BD%E5%85%BC%E5%AE%B9%E7%9A%84%E7%A7%98%E5%AF%86%E6%98%AF%E4%BB%80%E4%B9%88/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="06日志框架千千万，MyBati都能兼容的秘密是什么？">
  <meta property="og:description" content="Apache Commons Logging、Log4j、Log4j2、java.util.logging 等是 Java 开发中常用的几款日志框架，这些日志框架来源于不同的开源组织，给用户暴露的接口也有很多不同之处，所以很多开源框架会自己定义一套统一的日志接口，兼容上述第三方日志框架，供上层使用。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="深入剖析MyBatis核心原理">

  <meta itemprop="name" content="06日志框架千千万，MyBati都能兼容的秘密是什么？">
  <meta itemprop="description" content="Apache Commons Logging、Log4j、Log4j2、java.util.logging 等是 Java 开发中常用的几款日志框架，这些日志框架来源于不同的开源组织，给用户暴露的接口也有很多不同之处，所以很多开源框架会自己定义一套统一的日志接口，兼容上述第三方日志框架，供上层使用。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6555">
  <meta itemprop="keywords" content="深入剖析MyBatis核心原理">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="06日志框架千千万，MyBati都能兼容的秘密是什么？">
  <meta name="twitter:description" content="Apache Commons Logging、Log4j、Log4j2、java.util.logging 等是 Java 开发中常用的几款日志框架，这些日志框架来源于不同的开源组织，给用户暴露的接口也有很多不同之处，所以很多开源框架会自己定义一套统一的日志接口，兼容上述第三方日志框架，供上层使用。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">06日志框架千千万，MyBati都能兼容的秘密是什么？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6555 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>Apache Commons Logging、Log4j、Log4j2、java.util.logging 等是 Java 开发中常用的几款日志框架，这些日志框架来源于不同的开源组织，给用户暴露的接口也有很多不同之处，所以很多开源框架会自己定义一套统一的日志接口，兼容上述第三方日志框架，供上层使用。</p>
<p>一般实现的方式是使用适配器模式，将各个第三方日志框架接口转换为框架内部自定义的日志接口。MyBatis 也提供了类似的实现。</p>
<p>适配器模式</p>
<p>适配器模式主要解决的是由于接口不能兼容而导致类无法使用的问题，这在处理遗留代码以及集成第三方框架的时候用得比较多。其核心原理是：通过组合的方式，将需要适配的类转换成使用者能够使用的接口。</p>
<p>适配器模式的类图如下所示：</p>
<p>适配器模式类图</p>
<p>在该类图中，你可以看到适配器模式涉及的三个核心角色。</p>
<p>目标接口（Target）：使用者能够直接使用的接口。以处理遗留代码为例，Target 就是最新定义的业务接口。</p>
<p>需要适配的类/要使用的实现类（Adaptee）：定义了真正要执行的业务逻辑，但是其接口不能被使用者直接使用。这里依然以处理遗留代码为例，Adaptee 就是遗留业务实现，由于编写 Adaptee 的时候还没有定义 Target 接口，所以 Adaptee 无法实现 Target 接口。</p>
<p>适配器（Adapter）：在实现 Target 接口的同时，维护了一个指向 Adaptee 对象的引用。Adapter 底层会依赖 Adaptee 的逻辑来实现 Target 接口的功能，这样就能够复用 Adaptee 类中的遗留逻辑来完成业务。</p>
<p>适配器模式带来的最大好处就是复用已有的逻辑，避免直接去修改 Adaptee 实现的接口，这符合开放-封闭原则（也就是程序要对扩展开放、对修改关闭）。</p>
<p>MyBatis 使用的日志接口是自己定义的 Log 接口，但是 Apache Commons Logging、Log4j、Log4j2 等日志框架提供给用户的都是自己的 Logger 接口。为了统一这些第三方日志框架，MyBatis 使用适配器模式添加了针对不同日志框架的 Adapter 实现，使得第三方日志框架的 Logger 接口转换成 MyBatis 中的 Log 接口，从而实现集成第三方日志框架打印日志的功能。</p>
<p>日志模块</p>
<p>MyBatis 自定义的 Log 接口位于 org.apache.ibatis.logging 包中，相关的适配器也位于该包中，下面我们就来看看该模块的具体实现。</p>
<p>首先是 LogFactory 工厂类，它负责创建 Log 对象。这些 Log 接口的实现类中，就包含了多种第三方日志框架的适配器，如下图所示：</p>
<p>Log 接口继承关系图</p>
<p>在 LogFactory 类中有一段静态代码块，其中会依次加载各个第三方日志框架的适配器。在静态代码块执行的 tryImplementation() 方法中，首先会检测 logConstructor 字段是否为空，如果不为空，则表示已经成功确定当前使用的日志框架，直接返回；如果为空，则在当前线程中执行传入的 Runnable.run() 方法，尝试确定当前使用的日志框架。</p>
<p>以 JDK Logging 的加载流程（useJdkLogging() 方法）为例，其具体代码实现和注释如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="k">static</span> <span class="n">synchronized</span> <span class="n">void</span> <span class="n">useJdkLogging</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">setImplementation</span><span class="p">(</span><span class="n">org</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">ibatis</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">jdk14</span><span class="o">.</span><span class="n">Jdk14LoggingImpl</span><span class="o">.</span><span class="k">class</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">private</span> <span class="k">static</span> <span class="n">void</span> <span class="n">setImplementation</span><span class="p">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="err">?</span> <span class="k">extends</span> <span class="n">Log</span><span class="o">&gt;</span> <span class="n">implClass</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">获取</span><span class="n">implClass这个适配器的构造方法</span>
</span></span><span class="line"><span class="cl">    <span class="n">Constructor</span><span class="o">&lt;</span><span class="err">?</span> <span class="k">extends</span> <span class="n">Log</span><span class="o">&gt;</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">implClass</span><span class="o">.</span><span class="n">getConstructor</span><span class="p">(</span><span class="ne">String</span><span class="o">.</span><span class="k">class</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">尝试加载</span><span class="n">implClass这个适配器</span><span class="err">，加载失败会抛出异常</span>
</span></span><span class="line"><span class="cl">    <span class="n">Log</span> <span class="nb">log</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">.</span><span class="n">newInstance</span><span class="p">(</span><span class="n">LogFactory</span><span class="o">.</span><span class="k">class</span><span class="o">.</span><span class="n">getName</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">加载成功，则更新</span><span class="n">logConstructor字段</span><span class="err">，记录适配器的构造方法</span>
</span></span><span class="line"><span class="cl">    <span class="n">logConstructor</span> <span class="o">=</span> <span class="n">candidate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">throw</span> <span class="n">new</span> <span class="n">LogException</span><span class="p">(</span><span class="s2">&#34;Error setting Log implementation.  Cause: &#34;</span> <span class="o">+</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面我们以 Jdk14LoggingImpl 为例介绍一下 MyBatis Log 接口的实现。</p>
<p>Jdk14LoggingImpl 作为 Java Logging 的适配器，在实现 MyBatis Log 接口的同时，在内部还封装了一个 java.util.logging.Logger 对象（这是 JDK 提供的日志框架），如下图所示：</p>
<p>Jdk14LoggingImpl 继承关系图</p>
<p>Jdk14LoggingImpl 对 Log 接口的实现也比较简单，其中会将日志输出操作委托给底层封装的java.util.logging.Logger 对象的相应方法，这与前文介绍的典型适配器模式的实现完全一致。Jdk14LoggingImpl 中的核心实现以及注释如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class Jdk14LoggingImpl implements Log {
</span></span><span class="line"><span class="cl">  // 指向一个java.util.logging.Logger对象
</span></span><span class="line"><span class="cl">  private final Logger log;
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  public Jdk14LoggingImpl(String clazz) {
</span></span><span class="line"><span class="cl">    // 初始化log字段
</span></span><span class="line"><span class="cl">    log = Logger.getLogger(clazz);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  @Override
</span></span><span class="line"><span class="cl">  public void error(String s, Throwable e) {
</span></span><span class="line"><span class="cl">    // 全部调用依赖java.util.logging.Logger对象进行实现
</span></span><span class="line"><span class="cl">    log.log(Level.SEVERE, s, e);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  // 省略其他级别的日志输出方法
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 MyBatis 的 org.apache.ibatis.logging 包下面，除了集成三方日志框架的适配器实现之外，还有一个 jdbc 包，这个包的功能不是将日志写入数据库中，而是将数据库操作涉及的信息通过指定的 Log 打印到日志文件中。我们可以通过这个包，将执行的 SQL 语句、SQL 绑定的参数、SQL 执行之后影响的行数等信息，统统打印到日志中，这个功能主要是在测试环境进行调试的时候使用，很少在线上开启，因为这会产生非常多的日志，拖慢系统性能。</p>
<p>代理模式</p>
<p>在后面即将介绍的 org.apache.ibatis.logging.jdbc 包中，使用到了 JDK 动态代理的相关知识，所以这里我们就先来介绍一下经典的静态代理模式，以及 JDK 提供的动态代理。</p>
<p>1. 静态代理模式</p>
<p>经典的静态代理模式，其类图如下所示：</p>
<p>代理模式类图</p>
<p>从该类图中，你可以看到与代理模式相关的三个核心角色。</p>
<p>Subject：程序中的业务接口，定义了相关的业务方法。</p>
<p>RealSubject：实现了 Subject 接口的业务实现类，其实现中完成了真正的业务逻辑。</p>
<p>Proxy：代理类，实现了 Subject 接口，其中会持有一个 Subject 类型的字段，指向一个 RealSubject 对象。</p>
<p>在使用的时候，会将 RealSubject 对象封装到 Proxy 对象中，然后访问 Proxy 的相关方法，而不是直接访问 RealSubject 对象。在 Proxy 的方法实现中，不仅会调用 RealSubject 对象的相应方法完成业务逻辑，还会在 RealSubject 方法执行前后进行预处理和后置处理。</p>
<p>通过对代理模式的描述可知，Proxy 能够控制使用方对 RealSubject 对象的访问，或是在执行业务逻辑之前执行统一的预处理逻辑，在执行业务逻辑之后执行统一的后置处理逻辑。</p>
<p>代理模式除了实现访问控制以外，还能用于实现延迟加载。例如，查询数据库涉及网络 I/O 和磁盘 I/O，会是一个比较耗时的操作，有些时候从数据库加载到内存的数据，也并非系统真正会使用到的数据，所以就有了延迟加载这种优化操作。</p>
<p>延迟加载可以有效地避免数据库资源的浪费，其主要原理是：用户在访问数据库时，会立刻拿到一个代理对象，此时并没有执行任何 SQL 到数据库中查询数据，代理对象中自然也不会包含任何真正的有效数据；当用户真正需要使用数据时，会访问代理对象，此时会由代理对象去执行 SQL，完成数据库的查询。MyBatis 也提供了延迟加载功能，原理大同小异，具体的实现方式也是通过代理实现的。</p>
<p>针对每个 RealSubject 类，都需要创建一个 Proxy 代理类，当 RealSubject 这种需要被代理的类变得很多的时候，相应地就需要定义大量的 Proxy 类，这也是经典代理模式面临的一个问题。JDK 动态代理可以有效地解决这个问题，所以接下来我们就来一起分析 JDK 动态代理的核心原理。</p>
<p>2. JDK 动态代理</p>
<p>JDK 动态代理的核心是 InvocationHandler 接口。这里我先给出了一个 InvocationHandler 的示例实现，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class DemoInvokerHandler implements InvocationHandler {
</span></span><span class="line"><span class="cl">    private Object target; // 真正的业务对象，也就是RealSubject对象
</span></span><span class="line"><span class="cl">    // DemoInvokerHandler构造方法
</span></span><span class="line"><span class="cl">    public DemoInvokerHandler(Object target) { 
</span></span><span class="line"><span class="cl">        this.target = target;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public Object invoke(Object proxy, Method method, Object[] args)
</span></span><span class="line"><span class="cl">             throws Throwable {
</span></span><span class="line"><span class="cl">        ... // 在执行业务逻辑之前的预处理逻辑
</span></span><span class="line"><span class="cl">        Object result = method.invoke(target, args);
</span></span><span class="line"><span class="cl">        ... // 在执行业务逻辑之后的后置处理逻辑
</span></span><span class="line"><span class="cl">        return result;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public Object getProxy() {
</span></span><span class="line"><span class="cl">        // 创建代理对象
</span></span><span class="line"><span class="cl">        return Proxy.newProxyInstance(Thread.currentThread()
</span></span><span class="line"><span class="cl">            .getContextClassLoader(),
</span></span><span class="line"><span class="cl">                target.getClass().getInterfaces(), this);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，我们可以创建一个 main() 方法来模拟使用方创建并使用 DemoInvokerHandler 动态生成代理对象，示例代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class Main {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Subject subject = new RealSubject();
</span></span><span class="line"><span class="cl">        DemoInvokerHandler invokerHandler = 
</span></span><span class="line"><span class="cl">            new DemoInvokerHandler(subject);
</span></span><span class="line"><span class="cl">        // 获取代理对象
</span></span><span class="line"><span class="cl">        Subject proxy = (Subject) invokerHandler.getProxy();
</span></span><span class="line"><span class="cl">        // 调用代理对象的方法，它会调用DemoInvokerHandler.invoke()方法
</span></span><span class="line"><span class="cl">        proxy.operation();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在假设有多个业务逻辑类，需要相同的预处理逻辑和后置处理逻辑，那么只需要提供一个 InvocationHandler 接口实现类即可。在程序运行过程中，JDK 动态代理会为每个业务类动态生成相应的代理类实现，并加载到 JVM 中，然后创建对应的代理实例对象。</p>
<p>下面我们就接着来深入分析一下 JDK 动态代理底层动态创建代理类的原理。不同 JDK 版本 Proxy 类的实现会有些许差异，但总体的核心思路基本一致，这里我们就以 JDK 1.8.0 版本为例进行说明。</p>
<p>首先，从前面的示例代码中可以看出，JDK 动态代理的入口方法是 Proxy.newProxyInstance()，这个静态方法有以下三个参数。</p>
<p>loader（ClassLoader 类型）：加载动态生成的代理类的类加载器。</p>
<p>interfaces（Class[] 类型）：业务类实现的接口。</p>
<p>h（InvocationHandler 类型）：自定义的 InvocationHandler 对象。</p>
<p>下面进入 Proxy.newProxyInstance() 方法，查看其具体实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="k">static</span> <span class="ne">Object</span> <span class="n">newProxyInstance</span><span class="p">(</span><span class="n">ClassLoader</span> <span class="n">loader</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">     <span class="n">Class</span><span class="p">[]</span> <span class="n">interfaces</span><span class="p">,</span> <span class="n">InvocationHandler</span> <span class="n">h</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">         <span class="n">throws</span> <span class="n">IllegalArgumentException</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">final</span> <span class="n">Class</span><span class="o">&lt;</span><span class="err">?</span><span class="o">&gt;</span><span class="p">[]</span> <span class="n">intfs</span> <span class="o">=</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">clone</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span> <span class="o">//</span> <span class="err">省略权限检查等代码</span>
</span></span><span class="line"><span class="cl">    <span class="n">Class</span><span class="o">&lt;</span><span class="err">?</span><span class="o">&gt;</span> <span class="n">cl</span> <span class="o">=</span> <span class="n">getProxyClass0</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">intfs</span><span class="p">);</span>  <span class="o">//</span> <span class="err">获取代理类</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span> <span class="o">//</span> <span class="err">省略</span><span class="n">try</span><span class="o">/</span><span class="n">catch代码块和相关异常处理</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">获取代理类的构造方法</span>
</span></span><span class="line"><span class="cl">    <span class="n">final</span> <span class="n">Constructor</span><span class="o">&lt;</span><span class="err">?</span><span class="o">&gt;</span> <span class="n">cons</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">getConstructor</span><span class="p">(</span><span class="n">constructorParams</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">final</span> <span class="n">InvocationHandler</span> <span class="n">ih</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">cons</span><span class="o">.</span><span class="n">newInstance</span><span class="p">(</span><span class="n">new</span> <span class="ne">Object</span><span class="p">[]{</span><span class="n">h</span><span class="p">});</span>  <span class="o">//</span> <span class="err">创建代理对象</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从 newProxyInstance() 方法的具体实现代码中我们可以看到，JDK 动态代理是在 getProxyClass0() 方法中完成代理类的生成和加载。getProxyClass0() 方法的具体实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">private</span> <span class="k">static</span> <span class="n">Class</span> <span class="n">getProxyClass0</span> <span class="p">(</span><span class="n">ClassLoader</span> <span class="n">loader</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="n">Class</span><span class="o">...</span> <span class="n">interfaces</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">边界检查，限制接口数量（略）</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">如果指定的类加载器中已经创建了实现指定接口的代理类，则查找缓存；</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">否则通过</span><span class="n">ProxyClassFactory创建实现指定接口的代理类</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">proxyClassCache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">interfaces</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>proxyClassCache 是定义在 Proxy 类中一个静态字段，它是 WeakCache 类型的集合，用于缓存已经创建过的代理类，具体定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache
</span></span><span class="line"><span class="cl">     = new WeakCache&lt;&gt;(new KeyFactory(), 
</span></span><span class="line"><span class="cl">           new ProxyClassFactory());
</span></span></code></pre></td></tr></table>
</div>
</div><p>WeakCache.get() 方法会首先尝试从缓存中查找代理类，如果查找失败，则会创建相应的 Factory 对象并调用其 get() 方法获取代理类。Factory 是 WeakCache 中的内部类，在 Factory.get() 方法中会通过 ProxyClassFactory.apply() 方法创建并加载代理类。</p>
<p>在 ProxyClassFactory.apply() 方法中，首先会检测代理类需要实现的接口集合，然后确定代理类的名称，之后创建代理类并将其写入文件中，最后加载代理类，返回对应的 Class 对象用于后续的实例化代理类对象。该方法的具体实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="n">Class</span> <span class="n">apply</span><span class="p">(</span><span class="n">ClassLoader</span> <span class="n">loader</span><span class="p">,</span> <span class="n">Class</span><span class="p">[]</span> <span class="n">interfaces</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="o">...</span> <span class="err">对</span><span class="n">interfaces集合进行一系列检测</span><span class="err">（略）</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="o">...</span> <span class="err">选择定义代理类的包名（略）</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">代理类的名称是通过包名、代理类名称前缀以及编号这三项组成的</span>
</span></span><span class="line"><span class="cl">    <span class="n">long</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nextUniqueNumber</span><span class="o">.</span><span class="n">getAndIncrement</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="ne">String</span> <span class="n">proxyName</span> <span class="o">=</span> <span class="n">proxyPkg</span> <span class="o">+</span> <span class="n">proxyClassNamePrefix</span> <span class="o">+</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">生成代理类，并写入文件</span>
</span></span><span class="line"><span class="cl">    <span class="n">byte</span><span class="p">[]</span> <span class="n">proxyClassFile</span> <span class="o">=</span> <span class="n">ProxyGenerator</span><span class="o">.</span><span class="n">generateProxyClass</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">proxyName</span><span class="p">,</span> <span class="n">interfaces</span><span class="p">,</span> <span class="n">accessFlags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">加载代理类，并返回</span><span class="n">Class对象</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">defineClass0</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">proxyName</span><span class="p">,</span> <span class="n">proxyClassFile</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">      <span class="n">proxyClassFile</span><span class="o">.</span><span class="n">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>ProxyGenerator.generateProxyClass() 方法会按照指定的名称和接口集合生成代理类的字节码，并根据条件决定是否保存到磁盘上。该方法的具体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static byte[] generateProxyClass(final String name,
</span></span><span class="line"><span class="cl">       Class[] interfaces) {
</span></span><span class="line"><span class="cl">    ProxyGenerator gen = new ProxyGenerator(name, interfaces);
</span></span><span class="line"><span class="cl">    // 动态生成代理类的字节码，具体生成过程不再详细介绍
</span></span><span class="line"><span class="cl">    final byte[] classFile = gen.generateClassFile();
</span></span><span class="line"><span class="cl">    // 如果saveGeneratedFiles值为true，会将生成的代理类的字节码保存到文件中
</span></span><span class="line"><span class="cl">    if (saveGeneratedFiles) { 
</span></span><span class="line"><span class="cl">        java.security.AccessController.doPrivileged(
</span></span><span class="line"><span class="cl">            new java.security.PrivilegedAction() {
</span></span><span class="line"><span class="cl">                public Void run() {
</span></span><span class="line"><span class="cl">                    // 省略try/catch代码块
</span></span><span class="line"><span class="cl">                    FileOutputStream file = new FileOutputStream(
</span></span><span class="line"><span class="cl">                        dotToSlash(name) + &#34;.class&#34;);
</span></span><span class="line"><span class="cl">                    file.write(classFile);
</span></span><span class="line"><span class="cl">                    file.close();
</span></span><span class="line"><span class="cl">                    return null;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        );
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return classFile; // 返回上面生成的代理类的字节码
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后，为了清晰地看到 JDK 动态生成的代理类的真正代码，我们需要将上述生成的代理类的字节码进行反编译。上述示例为 RealSubject 生成的代理类，反编译后得到的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="n">final</span> <span class="k">class</span> <span class="o">$</span><span class="n">Proxy143</span> 
</span></span><span class="line"><span class="cl">      <span class="k">extends</span> <span class="n">Proxy</span> <span class="n">implements</span> <span class="n">Subject</span> <span class="p">{</span>  <span class="o">//</span> <span class="err">实现了</span><span class="n">Subject接口</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">这里省略了从</span><span class="n">Object类继承下来的相关方法和属性</span>
</span></span><span class="line"><span class="cl">    <span class="n">private</span> <span class="k">static</span> <span class="n">Method</span> <span class="n">m3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">省略了</span><span class="n">try</span><span class="o">/</span><span class="n">catch代码块</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">记录了</span><span class="n">operation</span><span class="p">()</span><span class="err">方法对应的</span><span class="n">Method对象</span>
</span></span><span class="line"><span class="cl">        <span class="n">m3</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="n">forName</span><span class="p">(</span><span class="s2">&#34;design.proxy.Subject&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">.</span><span class="n">getMethod</span><span class="p">(</span><span class="s2">&#34;operation&#34;</span><span class="p">,</span> <span class="n">new</span> <span class="n">Class</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">构造方法的参数就是我们在示例中使用的</span><span class="n">DemoInvokerHandler对象</span>
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="o">$</span><span class="n">Proxy11</span><span class="p">(</span><span class="n">InvocationHandler</span> <span class="n">var1</span><span class="p">)</span> <span class="n">throws</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">super</span><span class="p">(</span><span class="n">var1</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="n">final</span> <span class="n">void</span> <span class="n">operation</span><span class="p">()</span> <span class="n">throws</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">省略了</span><span class="n">try</span><span class="o">/</span><span class="n">catch代码块</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">调用</span><span class="n">DemoInvokerHandler对象的invoke</span><span class="p">()</span><span class="err">方法</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">最终调用</span><span class="n">RealSubject对象的对应方法</span>
</span></span><span class="line"><span class="cl">        <span class="n">super</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">m3</span><span class="p">,</span> <span class="p">(</span><span class="ne">Object</span><span class="p">[])</span> <span class="n">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>到此为止，JDK 动态代理的基本使用以及核心原理就分析完了。这里我做一个简单的总结，JDK 动态代理的实现原理是：动态创建代理类，然后通过指定类加载器进行加载。在创建代理对象时，需要将 InvocationHandler 对象作为构造参数传入；当调用代理对象时，会调用 InvocationHandler.invoke() 方法，从而执行代理逻辑，最终调用真正业务对象的相应方法。</p>
<p>JDBC Logger</p>
<p>了解了代理模式以及 JDK 动态代理的基础知识之后，下面我们开始分析 org.apache.ibatis.logging.jdbc 包中的内容。</p>
<p>首先来看其中最基础的抽象类—— BaseJdbcLogger，它是 jdbc 包下其他 Logger 类的父类，继承关系如下图所示：</p>
<p>BaseJdbcLogger 继承关系图</p>
<p>在 BaseJdbcLogger 这个抽象类中，定义了 SET_METHODS 和 EXECUTE_METHODS 两个 Set 类型的集合。其中，SET_METHODS 用于记录绑定 SQL 参数涉及的全部 set*() 方法名称，例如 setString() 方法、setInt() 方法等。EXECUTE_METHODS 用于记录执行 SQL 语句涉及的所有方法名称，例如 execute() 方法、executeUpdate() 方法、executeQuery() 方法、addBatch() 方法等。这两个集合都是在 BaseJdbcLogger 的静态代码块中被填充的。</p>
<p>从上面的 BaseJdbcLogger 继承关系图中可以看到，BaseJdbcLogger 的子类同时会实现 InvocationHandler 接口。</p>
<p>我们先来看其中的 ConnectionLogger 实现，其底层维护了一个 Connection 对象的引用，在ConnectionLogger.newInstance() 方法中会使用 JDK 动态代理的方式为这个 Connection 对象创建相应的代理对象。</p>
<p>invoke() 方法是代理对象的核心方法，在该方法中，ConnectionLogger 会为 prepareStatement()、prepareCall()、createStatement() 三个方法添加代理逻辑。下面来看 invoke() 方法的具体实现，具体代码以及注释如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public Object invoke(Object proxy, Method method, Object[] params)
</span></span><span class="line"><span class="cl">        throws Throwable {
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        if (Object.class.equals(method.getDeclaringClass())) {
</span></span><span class="line"><span class="cl">            // 如果调用的是从Object继承的方法，则直接调用，不做任何拦截
</span></span><span class="line"><span class="cl">            return method.invoke(this, params);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 调用prepareStatement()方法、prepareCall()方法的时候，
</span></span><span class="line"><span class="cl">        // 会在创建PreparedStatement对象之后，用PreparedStatementLogger为其创建代理对象
</span></span><span class="line"><span class="cl">        if (&#34;prepareStatement&#34;.equals(method.getName()) || &#34;prepareCall&#34;.equals(method.getName())) {
</span></span><span class="line"><span class="cl">            if (isDebugEnabled()) {
</span></span><span class="line"><span class="cl">                // 通过statementLog这个Log输出日志
</span></span><span class="line"><span class="cl">                debug(&#34; Preparing: &#34; + removeExtraWhitespace((String) params[0]), true);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);
</span></span><span class="line"><span class="cl">            stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);
</span></span><span class="line"><span class="cl">            return stmt;
</span></span><span class="line"><span class="cl">        } else if (&#34;createStatement&#34;.equals(method.getName())) {
</span></span><span class="line"><span class="cl">            // 调用createStatement()方法的时候，
</span></span><span class="line"><span class="cl">            // 会在创建Statement对象之后，用StatementLogger为其创建代理对象
</span></span><span class="line"><span class="cl">            Statement stmt = (Statement) method.invoke(connection, params);
</span></span><span class="line"><span class="cl">            stmt = StatementLogger.newInstance(stmt, statementLog, queryStack);
</span></span><span class="line"><span class="cl">            return stmt;
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            // 除了上述三个方法之外，其他方法的调用将直接传递给底层Connection对象的相应方法处理
</span></span><span class="line"><span class="cl">            return method.invoke(connection, params);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    } catch (Throwable t) {
</span></span><span class="line"><span class="cl">        throw ExceptionUtil.unwrapThrowable(t);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面我们来看 PreparedStatementLogger，在其 invoke() 方法中调用了 SET_METHODS 集合中的方法、EXECUTE_METHODS 集合中的方法或 getResultSet() 方法时，会添加相应的代理逻辑。StatementLogger 中的 Invoke() 方法实现与之类似，这里就不再赘述。</p>
<p>最后我们再看下 ResultSetLogger 对 InvocationHandler 接口的实现，其中会针对 ResultSet.next() 方法进行后置处理，主要是打印结果集中每一行数据以及统计结果集总行数等信息，具体实现和注释如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public Object invoke(Object proxy, Method method, Object[] params) throws Throwable {
</span></span><span class="line"><span class="cl">  try {
</span></span><span class="line"><span class="cl">      if (Object.class.equals(method.getDeclaringClass())) {
</span></span><span class="line"><span class="cl">          // 如果调用Object的方法，则直接调用，不做任何其他处理
</span></span><span class="line"><span class="cl">          return method.invoke(this, params);
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      Object o = method.invoke(rs, params);
</span></span><span class="line"><span class="cl">      // 针对ResultSet.next()方法进行后置处理
</span></span><span class="line"><span class="cl">      if (&#34;next&#34;.equals(method.getName())) { 
</span></span><span class="line"><span class="cl">          if ((Boolean) o) { // 检测next()方法的返回值，确定是否还存在下一行数据
</span></span><span class="line"><span class="cl">              rows++; // 记录ResultSet中的行数
</span></span><span class="line"><span class="cl">              if (isTraceEnabled()) {
</span></span><span class="line"><span class="cl">                  // 获取数据集的列元数据
</span></span><span class="line"><span class="cl">                  ResultSetMetaData rsmd = rs.getMetaData();
</span></span><span class="line"><span class="cl">                  // 获取数据集的列数
</span></span><span class="line"><span class="cl">                  final int columnCount = rsmd.getColumnCount();
</span></span><span class="line"><span class="cl">                  if (first) { // 如果是数据集的第一行数据，会输出表头信息
</span></span><span class="line"><span class="cl">                      first = false;
</span></span><span class="line"><span class="cl">                      // 这里除了输出表头，还会记录BLOB等超大类型的列名
</span></span><span class="line"><span class="cl">                      printColumnHeaders(rsmd, columnCount);
</span></span><span class="line"><span class="cl">                  }
</span></span><span class="line"><span class="cl">                  // 输出当前遍历的这行记录，这里会过滤掉超大类型列的数据，不进行输出
</span></span><span class="line"><span class="cl">                  printColumnValues(columnCount);
</span></span><span class="line"><span class="cl">              }
</span></span><span class="line"><span class="cl">          } else { // 完成结果集的遍历之后，这里会在日志中输出总行数
</span></span><span class="line"><span class="cl">              debug(&#34;     Total: &#34; + rows, false);
</span></span><span class="line"><span class="cl">          }
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      clearColumnInfo(); // 清空column*集合
</span></span><span class="line"><span class="cl">      return o;
</span></span><span class="line"><span class="cl">  } catch (Throwable t) {
</span></span><span class="line"><span class="cl">      throw ExceptionUtil.unwrapThrowable(t);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>总结</p>
<p>在这一讲中，我们主要介绍的是 MyBatis 基础模块中的日志模块。</p>
<p>首先，介绍了适配器模式的核心知识点，这也是日志模块底层的设计思想。</p>
<p>然后，说明了日志模块是如何基于适配器模式集成多种三方日志框架的。</p>
<p>接下来，详细讲解了静态代理模式以及 JDK 动态代理的实现原理。</p>
<p>最后，深入分析了 JDBC Logger 是如何基于 JDK 动态代理实现日志功能的。</p>
<p>关于 MyBatis 的日志模块，若你有什么经验或问题，期待在留言区与我分享和交流。</p>
<p>在下一讲，我会介绍 MyBatis 数据源和事务相关的内容，记得按时来听课。</p>
<p>《Java 工程师高薪训练营》</p>
<p>实战训练+面试模拟+大厂内推，想要提升技术能力，进大厂拿高薪，点击链接，提升自己！</p>
<p>-&ndash; ### 精选评论 ##### **生： &gt; 讲的很棒 ##### **诗： &gt; org.apache.ibatis.executor.BaseExecutor#getConnection，如果statementLog.isDebugEnable为true就返回connection的代理对象，不然就是直接返回connection ######     讲师回复： &gt;     对的。 ##### TFdream： &gt; UML类图 画的挺漂亮，想问一下是用的哪个UML画图工具呢？ ######     讲师回复： &gt;     <a href="https://app.diagrams.net/">https://app.diagrams.net/</a> ##### **用户2312： &gt; jdbc logger开关在哪里？</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90mybatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">深入剖析MyBatis核心原理</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/06%E6%97%A5%E5%BF%97%E5%8F%AF%E8%A7%86%E5%8C%96kibana%E8%AE%A9%E5%8D%83%E4%B8%87%E8%A1%8C%E6%97%A5%E5%BF%97%E6%9C%89%E5%BD%A2%E6%9C%89%E6%A0%B7/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">06日志可视化：Kibana让千万行日志有形有样</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/06%E5%AE%9E%E8%B7%B5%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/">
            <span class="next-text nav-default">06实践：设计一个最简单的分布式数据库</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
