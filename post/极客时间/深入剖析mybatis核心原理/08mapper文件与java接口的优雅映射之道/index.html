<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>08Mapper文件与Java接口的优雅映射之道 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="在使用 MyBatis 实现订单系统示例的时候，我们会为每个 Mapper.xml 配置文件创建一个对应的 Mapper 接口，例如，订单系统示例中的 CustomerMapper.xml 配置文件与 CustomerMapper 接口，定义完 CustomerMapper 接口之后，我们无须提供 CustomerMapper 接口实现，就可以直接调用 CustomerMapper 对象的方法执行 CustomerMapper.xml 配置文件中的 SQL 语句。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90mybatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/08mapper%E6%96%87%E4%BB%B6%E4%B8%8Ejava%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BC%98%E9%9B%85%E6%98%A0%E5%B0%84%E4%B9%8B%E9%81%93/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90mybatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/08mapper%E6%96%87%E4%BB%B6%E4%B8%8Ejava%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BC%98%E9%9B%85%E6%98%A0%E5%B0%84%E4%B9%8B%E9%81%93/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="08Mapper文件与Java接口的优雅映射之道">
  <meta property="og:description" content="在使用 MyBatis 实现订单系统示例的时候，我们会为每个 Mapper.xml 配置文件创建一个对应的 Mapper 接口，例如，订单系统示例中的 CustomerMapper.xml 配置文件与 CustomerMapper 接口，定义完 CustomerMapper 接口之后，我们无须提供 CustomerMapper 接口实现，就可以直接调用 CustomerMapper 对象的方法执行 CustomerMapper.xml 配置文件中的 SQL 语句。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="深入剖析MyBatis核心原理">

  <meta itemprop="name" content="08Mapper文件与Java接口的优雅映射之道">
  <meta itemprop="description" content="在使用 MyBatis 实现订单系统示例的时候，我们会为每个 Mapper.xml 配置文件创建一个对应的 Mapper 接口，例如，订单系统示例中的 CustomerMapper.xml 配置文件与 CustomerMapper 接口，定义完 CustomerMapper 接口之后，我们无须提供 CustomerMapper 接口实现，就可以直接调用 CustomerMapper 对象的方法执行 CustomerMapper.xml 配置文件中的 SQL 语句。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="8234">
  <meta itemprop="keywords" content="深入剖析MyBatis核心原理">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="08Mapper文件与Java接口的优雅映射之道">
  <meta name="twitter:description" content="在使用 MyBatis 实现订单系统示例的时候，我们会为每个 Mapper.xml 配置文件创建一个对应的 Mapper 接口，例如，订单系统示例中的 CustomerMapper.xml 配置文件与 CustomerMapper 接口，定义完 CustomerMapper 接口之后，我们无须提供 CustomerMapper 接口实现，就可以直接调用 CustomerMapper 对象的方法执行 CustomerMapper.xml 配置文件中的 SQL 语句。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">08Mapper文件与Java接口的优雅映射之道</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 8234 字 </span>
          <span class="more-meta"> 预计阅读 17 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>在使用 MyBatis 实现订单系统示例的时候，我们会为每个 Mapper.xml 配置文件创建一个对应的 Mapper 接口，例如，订单系统示例中的 CustomerMapper.xml 配置文件与 CustomerMapper 接口，定义完 CustomerMapper 接口之后，我们无须提供 CustomerMapper 接口实现，就可以直接调用 CustomerMapper 对象的方法执行 CustomerMapper.xml 配置文件中的 SQL 语句。</p>
<p>这里你可能会有几个疑惑：</p>
<p>为什么需要 CustomerMapper 接口来执行对应的 SQL 语句呢？</p>
<p>为什么无须提供 CustomerMapper 接口的实现类呢？</p>
<p>实际使用的 CustomerMapper 对象是什么呢？CustomerMapper 对象是怎么创建的呢？底层原理是什么呢？</p>
<p>学习完这一讲，你就会找到这些问题的答案。</p>
<p>MyBatis 的前身是 iBatis，我们在使用 iBatis 的时候，如果想查询一个 Customer 对象的话，可以调用 SqlSession.queryForObject (&ldquo;find&rdquo;, customerId) 方法，queryForObject() 方法的这两个参数分别是要执行的 SQL 语句唯一标识（示例中就是定义在 CustomerMapper.xml 中的 id 为 find 的 SQL 语句），以及 SQL 语句执行时需要的实参（示例中就是顾客 ID）。</p>
<p>这里 SQL 语句的唯一标识是一个字符串，如果我们在写代码的时候，不小心写错了这个唯一标识，例如将“find”写成了“finb”，在代码编译以及 iBatis 初始化的过程中，根本发现不了这个问题，而是在真正执行到这行代码的时候才会抛出异常，这样其实对流量是有损的。</p>
<p>MyBatis 中的 Mapper 接口就可以很好地解决这个问题。</p>
<p>示例中的 CustomerMapper 接口中定义了 SQL 语句唯一标识同名的 find() 方法，我们在写代码的时候使用的是 CustomerMapper.find() 方法，如果拼写成 CustomerMapper.finb()，编译会失败。这是因为 MyBatis 初始化的时候会尝试将 CustomerMapper 接口中的 find() 方法名与 CustomerMapper.xml 配置文件中的 SQL 唯一标识进行映射，如果 SQL 语句唯一标识写错成“finb”，MyBatis 会发现这个错误，并在初始化过程中就抛出异常，这样编译器以及 MyBatis 就可以帮助我们更早发现异常，避免线上流量的损失。</p>
<p>在 MyBatis 中，实现 CustomerMapper 接口与 CustomerMapper.xml 配置文件映射功能的是 binding 模块，其中涉及的核心类如下图所示：</p>
<p>binding 模块核心组件关系图</p>
<p>下面我们就开始详细分析 binding 模块中涉及的这些核心组件。</p>
<p>MapperRegistry</p>
<p>MapperRegistry 是 MyBatis 初始化过程中构造的一个对象，主要作用就是统一维护 Mapper 接口以及这些 Mapper 的代理对象工厂。</p>
<p>下面我们先来看 MapperRegistry 中的核心字段。</p>
<p>config（Configuration 类型）：指向 MyBatis 全局唯一的 Configuration 对象，其中维护了解析之后的全部 MyBatis 配置信息。</p>
<p>knownMappers（Map&lt;Class</p>
<?>
<p>, MapperProxyFactory<?>&gt; 类型）：维护了所有解析到的 Mapper 接口以及 MapperProxyFactory 工厂对象之间的映射关系。</p>
<p>在 MyBatis 初始化时，会读取全部 Mapper.xml 配置文件，还会扫描全部 Mapper 接口中的注解信息，之后会调用 MapperRegistry.addMapper() 方法填充 knownMappers 集合。在 addMapper() 方法填充 knownMappers 集合之前，MapperRegistry 会先保证传入的 type 参数是一个接口且 knownMappers 集合没有加载过 type 类型，然后才会创建相应的 MapperProxyFactory 工厂并记录到 knownMappers 集合中。</p>
<p>在我们使用 CustomerMapper.find() 方法执行数据库查询的时候，MyBatis 会先从MapperRegistry 中获取 CustomerMapper 接口的代理对象，这里就使用到 MapperRegistry.getMapper()方法，它会拿到前面创建的 MapperProxyFactory 工厂对象，并调用其 newInstance() 方法创建 Mapper 接口的代理对象。</p>
<p>MapperProxyFactory</p>
<p>正如分析 MapperRegistry 时介绍的那样，MapperProxyFactory 的核心功能就是创建 Mapper 接口的代理对象，其底层核心原理就是前面《06 | 日志框架千千万，MyBatis 都能兼容的秘密是什么？》介绍的 JDK 动态代理。</p>
<p>在 MapperRegistry 中会依赖 MapperProxyFactory 的 newInstance() 方法创建代理对象，底层则是通过 JDK 动态代理的方式生成代理对象的，如下代码所示，这里使用的 InvocationHandler 实现是 MapperProxy。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {
</span></span><span class="line"><span class="cl">    // 创建实现了mapperInterface接口的动态代理对象，这里使用的InvocationHandler 实现是MapperProxy
</span></span><span class="line"><span class="cl">    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(),
</span></span><span class="line"><span class="cl">            new Class[]{mapperInterface}, mapperProxy);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>MapperProxy</p>
<p>通过分析 MapperProxyFactory 这个工厂类，我们可以清晰地看到MapperProxy 是生成 Mapper 接口代理对象的关键，它实现了 InvocationHandler 接口。</p>
<p>下面我们先来介绍一下 MapperProxy 中的核心字段。</p>
<p>sqlSession（SqlSession 类型）：记录了当前 MapperProxy 关联的 SqlSession 对象。在与当前 MapperProxy 关联的代理对象中，会用该 SqlSession 访问数据库。</p>
<p>mapperInterface（Class
<T>
类型）：Mapper 接口类型，也是当前 MapperProxy 关联的代理对象实现的接口类型。</p>
<p>methodCache（Map&lt;Method, MapperMethodInvoker&gt; 类型）：用于缓存 MapperMethodInvoker 对象的集合。methodCache 中的 key 是 Mapper 接口中的方法，value 是该方法对应的 MapperMethodInvoker 对象。</p>
<p>lookupConstructor（Constructor 类型）：针对 JDK 8 中的特殊处理，该字段指向了 MethodHandles.Lookup 的构造方法。</p>
<p>privateLookupInMethod（Method 类型）：除了 JDK 8 之外的其他 JDK 版本会使用该字段，该字段指向 MethodHandles.privateLookupIn() 方法。</p>
<p>这里涉及 MethodHandle 的内容，所以下面我们就来简单介绍一下 MethodHandle 的基础知识点。</p>
<p>1. MethodHandle 简介</p>
<p>从 Java 7 开始，除了反射之外，在 java.lang.invoke 包中新增了 MethodHandle 这个类，它的基本功能与反射中的 Method 类似，但它比反射更加灵活。反射是 Java API 层面支持的一种机制，MethodHandle 则是 JVM 层支持的机制，相较而言，反射更加重量级，MethodHandle 则更轻量级，性能也比反射更好些。</p>
<p>使用 MethodHandle 进行方法调用的时候，往往会涉及下面几个核心步骤：</p>
<p>创建 MethodType 对象，确定方法的签名，这个签名会涉及方法参数及返回值的类型；</p>
<p>在 MethodHandles.Lookup 这个工厂对象中，根据方法名称以及上面创建的 MethodType 查找对应 MethodHandle 对象；</p>
<p>将 MethodHandle 绑定到一个具体的实例对象；</p>
<p>调用 MethodHandle.invoke()/invokeWithArguments()/invokeExact() 方法，完成方法调用。</p>
<p>下面是 MethodHandle 的一个简单示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="k">class</span> <span class="n">MethodHandleDemo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">定义一个</span><span class="n">sayHello</span><span class="p">()</span><span class="err">方法</span>
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="ne">String</span> <span class="n">sayHello</span><span class="p">(</span><span class="ne">String</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s2">&#34;Hello, &#34;</span> <span class="o">+</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="k">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="ne">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">初始化</span><span class="n">MethodHandleDemo实例</span>
</span></span><span class="line"><span class="cl">        <span class="n">MethodHandleDemo</span> <span class="n">subMethodHandleDemo</span> <span class="o">=</span> <span class="n">new</span> <span class="n">SubMethodHandleDemo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">定义</span><span class="n">sayHello</span><span class="p">()</span><span class="err">方法的签名，第一个参数是方法的返回值类型，第二个参数是方法的参数列表</span>
</span></span><span class="line"><span class="cl">        <span class="n">MethodType</span> <span class="n">methodType</span> <span class="o">=</span> <span class="n">MethodType</span><span class="o">.</span><span class="n">methodType</span><span class="p">(</span><span class="ne">String</span><span class="o">.</span><span class="k">class</span><span class="p">,</span> <span class="ne">String</span><span class="o">.</span><span class="k">class</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">根据方法名和</span><span class="n">MethodType在MethodHandleDemo中查找对应的MethodHandle</span>
</span></span><span class="line"><span class="cl">        <span class="n">MethodHandle</span> <span class="n">methodHandle</span> <span class="o">=</span> <span class="n">MethodHandles</span><span class="o">.</span><span class="n">lookup</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="n">findVirtual</span><span class="p">(</span><span class="n">MethodHandleDemo</span><span class="o">.</span><span class="k">class</span><span class="p">,</span> <span class="s2">&#34;sayHello&#34;</span><span class="p">,</span> <span class="n">methodType</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">将</span><span class="n">MethodHandle绑定到一个对象上</span><span class="err">，然后通过</span><span class="n">invokeWithArguments</span><span class="p">()</span><span class="err">方法传入实参并执行</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">methodHandle</span><span class="o">.</span><span class="n">bindTo</span><span class="p">(</span><span class="n">subMethodHandleDemo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="n">invokeWithArguments</span><span class="p">(</span><span class="s2">&#34;MethodHandleDemo&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">下面是调用</span><span class="n">MethodHandleDemo对象</span><span class="p">(</span><span class="err">即父类</span><span class="p">)</span><span class="err">的方法</span>
</span></span><span class="line"><span class="cl">        <span class="n">MethodHandleDemo</span> <span class="n">methodHandleDemo</span> <span class="o">=</span> <span class="n">new</span> <span class="n">MethodHandleDemo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">methodHandle</span><span class="o">.</span><span class="n">bindTo</span><span class="p">(</span><span class="n">methodHandleDemo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="n">invokeWithArguments</span><span class="p">(</span><span class="s2">&#34;MethodHandleDemo&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="k">static</span> <span class="k">class</span> <span class="n">SubMethodHandleDemo</span> <span class="k">extends</span> <span class="n">MethodHandleDemo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">定义一个</span><span class="n">sayHello</span><span class="p">()</span><span class="err">方法</span>
</span></span><span class="line"><span class="cl">        <span class="n">public</span> <span class="ne">String</span> <span class="n">sayHello</span><span class="p">(</span><span class="ne">String</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="s2">&#34;Sub Hello, &#34;</span> <span class="o">+</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 MethodHandle 调用方法的时候，也是支持多态的，在通过 bindTo() 方法绑定到某个实例对象的时候，在 bind 过程中会进行类型检查等一系列检查操作。</p>
<p>通过上面这个示例我们可以看出，使用 MethodHandle 实现反射的效果，更像我们平时通过 Java 代码生成的字节码，例如，在字节码中可以看到创建的方法签名（MethodType）、方法的具体调用方式（findStatic()、findSpecial()、findVirtual() 等方法）以及类型的隐式转换。</p>
<p>2. MethodProxy 中的代理逻辑</p>
<p>介绍完 MethodHandle 的基础之后，我们回到 MethodProxy 继续分析。</p>
<p>MapperProxy.invoke() 方法是代理对象执行的入口，其中会拦截所有非 Object 方法，针对每个被拦截的方法，都会调用 cachedInvoker() 方法获取对应的 MapperMethod 对象，并调用其 invoke() 方法执行代理逻辑以及目标方法。</p>
<p>在 cachedInvoker() 方法中，首先会查询 methodCache 缓存，如果查询的方法为 default 方法，则会根据当前使用的 JDK 版本，获取对应的 MethodHandle 并封装成 DefaultMethodInvoker 对象写入缓存；如果查询的方法是非 default 方法，则创建 PlainMethodInvoker 对象写入缓存。</p>
<p>cachedInvoker() 方法的具体实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private MapperMethodInvoker cachedInvoker(Method method) throws Throwable {
</span></span><span class="line"><span class="cl">    // 尝试从methodCache缓存中查询方法对应的MapperMethodInvoker
</span></span><span class="line"><span class="cl">    MapperMethodInvoker invoker = methodCache.get(method);
</span></span><span class="line"><span class="cl">    if (invoker != null) {
</span></span><span class="line"><span class="cl">        return invoker;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 如果方法在缓存中没有对应的MapperMethodInvoker，则进行创建
</span></span><span class="line"><span class="cl">    return methodCache.computeIfAbsent(method, m -&gt; {
</span></span><span class="line"><span class="cl">        if (m.isDefault()) { // 针对default方法的处理
</span></span><span class="line"><span class="cl">            // 这里根据JDK版本的不同，获取方法对应的MethodHandle的方式也有所不同
</span></span><span class="line"><span class="cl">            // 在JDK 8中使用的是lookupConstructor字段，而在JDK 9中使用的是
</span></span><span class="line"><span class="cl">            // privateLookupInMethod字段。获取到MethodHandle之后，会使用
</span></span><span class="line"><span class="cl">            // DefaultMethodInvoker进行封装
</span></span><span class="line"><span class="cl">            if (privateLookupInMethod == null) {
</span></span><span class="line"><span class="cl">                return new DefaultMethodInvoker(getMethodHandleJava8(method));
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                return new DefaultMethodInvoker(getMethodHandleJava9(method));
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            // 对于其他方法，会创建MapperMethod并使用PlainMethodInvoker封装
</span></span><span class="line"><span class="cl">            return new PlainMethodInvoker(
</span></span><span class="line"><span class="cl">                    new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    });
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中使用到的 DefaultMethodInvoker 和 PlainMethodInvoker 都是 MapperMethodInvoker 接口的实现，如下图所示：</p>
<p>MapperMethodInvoker 接口继承关系图</p>
<p>在 DefaultMethodInvoker.invoke() 方法中，会通过底层维护的 MethodHandle 完成方法调用，核心实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public Object invoke(Object proxy, Method method, Object[] args, SqlSession sqlSession) throws Throwable {
</span></span><span class="line"><span class="cl">    // 首先将MethodHandle绑定到一个实例对象上，然后调用invokeWithArguments()方法执行目标方法
</span></span><span class="line"><span class="cl">    return methodHandle.bindTo(proxy).invokeWithArguments(args);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 PlainMethodInvoker.invoke() 方法中，会通过底层维护的 MapperMethod 完成方法调用，其核心实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public Object invoke(Object proxy, Method method, Object[] args, SqlSession sqlSession) throws Throwable {
</span></span><span class="line"><span class="cl">    // 直接执行MapperMethod.execute()方法完成方法调用
</span></span><span class="line"><span class="cl">    return mapperMethod.execute(sqlSession, args);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>MapperMethod</p>
<p>通过对 MapperProxy 的分析我们知道，MapperMethod 是最终执行 SQL 语句的地方，同时也记录了 Mapper 接口中的对应方法，其核心字段也围绕这两方面的内容展开。</p>
<p>1. SqlCommand</p>
<p>MapperMethod 的第一个核心字段是 command（SqlCommand 类型），其中维护了关联 SQL 语句的相关信息。在 MapperMethod$SqlCommand 这个内部类中，通过 name 字段记录了关联 SQL 语句的唯一标识，通过 type 字段（SqlCommandType 类型）维护了 SQL 语句的操作类型，这里 SQL 语句的操作类型分为 INSERT、UPDATE、DELETE、SELECT 和 FLUSH 五种。</p>
<p>下面我们就来看看 SqlCommand 如何查找 Mapper 接口中一个方法对应的 SQL 语句的信息，该逻辑在 SqlCommand 的构造方法中实现，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public SqlCommand(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) {
</span></span><span class="line"><span class="cl">    // 获取Mapper接口中对应的方法名称
</span></span><span class="line"><span class="cl">    final String methodName = method.getName();
</span></span><span class="line"><span class="cl">    // 获取Mapper接口的类型
</span></span><span class="line"><span class="cl">    final Class&lt;?&gt; declaringClass = method.getDeclaringClass();
</span></span><span class="line"><span class="cl">    // 将Mapper接口名称和方法名称拼接起来作为SQL语句唯一标识，
</span></span><span class="line"><span class="cl">    // 到Configuration这个全局配置对象中查找SQL语句
</span></span><span class="line"><span class="cl">    // MappedStatement对象就是Mapper.xml配置文件中一条SQL语句解析之后得到的对象
</span></span><span class="line"><span class="cl">    MappedStatement ms = resolveMappedStatement(mapperInterface, 
</span></span><span class="line"><span class="cl">            methodName, declaringClass, configuration);
</span></span><span class="line"><span class="cl">    if (ms == null) { 
</span></span><span class="line"><span class="cl">        // 针对@Flush注解的处理
</span></span><span class="line"><span class="cl">        if (method.getAnnotation(Flush.class) != null) {
</span></span><span class="line"><span class="cl">            name = null;
</span></span><span class="line"><span class="cl">            type = SqlCommandType.FLUSH;
</span></span><span class="line"><span class="cl">        } else { // 没有@Flush注解，会抛出异常
</span></span><span class="line"><span class="cl">            throw new BindingException(&#34;...&#34;);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        // 记录SQL语句唯一标识
</span></span><span class="line"><span class="cl">        name = ms.getId();
</span></span><span class="line"><span class="cl">        // 记录SQL语句的操作类型
</span></span><span class="line"><span class="cl">        type = ms.getSqlCommandType();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里调用的 resolveMappedStatement() 方法不仅会尝试根据 SQL 语句的唯一标识从 Configuration 全局配置对象中查找关联的 MappedStatement 对象，还会尝试顺着 Mapper 接口的继承树进行查找，直至查找成功为止。具体实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private MappedStatement resolveMappedStatement(Class&lt;?&gt; mapperInterface, String methodName,
</span></span><span class="line"><span class="cl">                                                   Class&lt;?&gt; declaringClass, Configuration configuration) {
</span></span><span class="line"><span class="cl">        // 将Mapper接口名称和方法名称拼接起来作为SQL语句唯一标识
</span></span><span class="line"><span class="cl">        String statementId = mapperInterface.getName() + &#34;.&#34; + methodName;
</span></span><span class="line"><span class="cl">        // 检测Configuration中是否包含相应的MappedStatement对象
</span></span><span class="line"><span class="cl">        if (configuration.hasStatement(statementId)) {
</span></span><span class="line"><span class="cl">            return configuration.getMappedStatement(statementId);
</span></span><span class="line"><span class="cl">        } else if (mapperInterface.equals(declaringClass)) {
</span></span><span class="line"><span class="cl">            // 如果方法就定义在当前接口中，则证明没有对应的SQL语句，返回null
</span></span><span class="line"><span class="cl">            return null;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 如果当前检查的Mapper接口(mapperInterface)中不是定义该方法的接口(declaringClass)，
</span></span><span class="line"><span class="cl">        // 则会从mapperInterface开始，沿着继承关系向上查找递归每个接口，
</span></span><span class="line"><span class="cl">        // 查找该方法对应的MappedStatement对象
</span></span><span class="line"><span class="cl">        for (Class&lt;?&gt; superInterface : mapperInterface.getInterfaces()) {
</span></span><span class="line"><span class="cl">            if (declaringClass.isAssignableFrom(superInterface)) {
</span></span><span class="line"><span class="cl">                MappedStatement ms = resolveMappedStatement(superInterface, methodName,
</span></span><span class="line"><span class="cl">                        declaringClass, configuration);
</span></span><span class="line"><span class="cl">                if (ms != null) {
</span></span><span class="line"><span class="cl">                    return ms;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return null;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>2. MethodSignature</p>
<p>MapperMethod 的第二个核心字段是 method 字段（MethodSignature 类型），其中维护了 Mapper 接口中方法的相关信息。</p>
<p>首先是 Mapper 接口方法返回值的相关信息，涉及下面七个字段。</p>
<p>returnsMany、returnsMap、returnsVoid、returnsCursor、returnsOptional（boolean 类型）：用于表示方法返回值是否为 Collection 集合或数组、Map 集合、void、Cursor、Optional 类型。</p>
<p>returnType（Class<?> 类型）：方法返回值的具体类型。</p>
<p>mapKey（String 类型）：如果方法的返回值为 Map 集合，则通过 mapKey 字段记录了作为 key 的列名。mapKey 字段的值是通过解析方法上的 @MapKey 注解得到的。</p>
<p>接下来是与 Mapper 接口方法的参数列表相关的三个字段。</p>
<p>resultHandlerIndex（Integer 类型）：记录了 Mapper 接口方法的参数列表中 ResultHandler 类型参数的位置。</p>
<p>rowBoundsIndex（Integer 类型）：记录了 Mapper 接口方法的参数列表中 RowBounds 类型参数的位置。</p>
<p>paramNameResolver（ParamNameResolver 类型）：用来解析方法参数列表的工具类。</p>
<p>在上述字段中，需要着重讲解的是 ParamNameResolver 这个解析方法参数列表的工具类。</p>
<p>在 ParamNameResolver 中有一个 names 字段（SortedMap&lt;Integer, String&gt;类型）记录了各个参数在参数列表中的位置以及参数名称，其中 key 是参数在参数列表中的位置索引，value 为参数的名称。我们可以通过 @Param 注解指定一个参数名称，如果没有特别指定，则默认使用参数列表中的变量名称作为其名称，这与 ParamNameResolver 的 useActualParamName 字段相关。useActualParamName 是一个全局配置。</p>
<p>如果我们将 useActualParamName 配置为 false，ParamNameResolver 会使用参数的下标索引作为其名称。另外，names 集合会跳过 RowBounds 类型以及 ResultHandler 类型的参数，如果使用下标索引作为参数名称，在 names 集合中就会出现 KV 不一致的场景。例如下图就很好地说明了这种不一致的场景，其中 saveCustomer(long id, String name, RowBounds bounds, String address) 方法对应的 names 集合为 {{0, &ldquo;0&rdquo;}, {1, &ldquo;1&rdquo;}, {2, &ldquo;3&rdquo;}}。</p>
<p>names 集合中 KV 不一致示意图</p>
<p>从图中可以看到，由于 RowBounds 参数的存在，第四个参数在 names 集合中的 KV 出现了不一致（即 key = 2 与 value = &ldquo;3&rdquo; 不一致）。</p>
<p>完成 names 集合的初始化之后，我们再来看如何从 names 集合中查询参数名称，该部分逻辑在 ParamNameResolver.getNamedParams() 方法，其中会将 Mapper 接口方法的实参与 names 集合中记录的参数名称相关联，其核心逻辑如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public Object getNamedParams(Object[] args) {
</span></span><span class="line"><span class="cl">    // 获取方法中非特殊类型(RowBounds类型和ResultHandler类型)的参数个数
</span></span><span class="line"><span class="cl">    final int paramCount = names.size();
</span></span><span class="line"><span class="cl">    if (args == null || paramCount == 0) {
</span></span><span class="line"><span class="cl">        return null; // 方法没有非特殊类型参数，返回null即可
</span></span><span class="line"><span class="cl">    } else if (!hasParamAnnotation &amp;&amp; paramCount == 1) {
</span></span><span class="line"><span class="cl">        // 方法参数列表中没有使用@Param注解，且只有一个非特殊类型参数
</span></span><span class="line"><span class="cl">        Object value = args[names.firstKey()];
</span></span><span class="line"><span class="cl">        return wrapToMapIfCollection(value, useActualParamName ? names.get(0) : null);
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        // 处理存在@Param注解或是存在多个非特殊类型参数的场景
</span></span><span class="line"><span class="cl">        // param集合用于记录了参数名称与实参之间的映射关系
</span></span><span class="line"><span class="cl">        // 这里的ParamMap继承了HashMap，与HashMap的唯一不同是：
</span></span><span class="line"><span class="cl">        // 向ParamMap中添加已经存在的key时，会直接抛出异常，而不是覆盖原有的Key
</span></span><span class="line"><span class="cl">        final Map&lt;String, Object&gt; param = new ParamMap&lt;&gt;();
</span></span><span class="line"><span class="cl">        int i = 0;
</span></span><span class="line"><span class="cl">        for (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) {
</span></span><span class="line"><span class="cl">            // 将参数名称与实参的映射保存到param集合中
</span></span><span class="line"><span class="cl">            param.put(entry.getValue(), args[entry.getKey()]);
</span></span><span class="line"><span class="cl">            // 同时，为参数创建&#34;param+索引&#34;格式的默认参数名称，具体格式为：param1, param2等，
</span></span><span class="line"><span class="cl">            // 将&#34;param+索引&#34;的默认参数名称与实参的映射关系也保存到param集合中
</span></span><span class="line"><span class="cl">            final String genericParamName = GENERIC_NAME_PREFIX + (i + 1);
</span></span><span class="line"><span class="cl">            if (!names.containsValue(genericParamName)) {
</span></span><span class="line"><span class="cl">                param.put(genericParamName, args[entry.getKey()]);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            i++;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return param;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>了解了 ParamNameResolver 的核心功能之后，我们回到 MethodSignature 继续分析，在其构造函数中会解析方法中的返回值、参数列表等信息，并初始化前面介绍的核心字段，这里也会使用到前面介绍的 ParamNameResolver 工具类。下面是 MethodSignature 构造方法的核心实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public MethodSignature(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) {
</span></span><span class="line"><span class="cl">    ... // 通过TypeParameterResolver工具类解析方法的返回值类型，初始化returnType字段值，省略该解析部分代码
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 根据返回值类型，初始化returnsVoid、returnsMany、returnsCursor、
</span></span><span class="line"><span class="cl">    // returnsMap、returnsOptional这五个与方法返回值类型相关的字段
</span></span><span class="line"><span class="cl">    this.returnsVoid = void.class.equals(this.returnType);
</span></span><span class="line"><span class="cl">    ... 
</span></span><span class="line"><span class="cl">    // 如果返回值为Map类型，则从方法的@MapKey注解中获取Map中为key的字段名称
</span></span><span class="line"><span class="cl">    this.mapKey = getMapKey(method);
</span></span><span class="line"><span class="cl">    this.returnsMap = this.mapKey != null;
</span></span><span class="line"><span class="cl">    // 解析方法中RowBounds类型参数以及ResultHandler类型参数的下标索引位置，
</span></span><span class="line"><span class="cl">    // 初始化rowBoundsIndex和resultHandlerIndex字段
</span></span><span class="line"><span class="cl">    this.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class);
</span></span><span class="line"><span class="cl">    this.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);
</span></span><span class="line"><span class="cl">    // 创建ParamNameResolver工具对象，在创建ParamNameResolver对象的时候，
</span></span><span class="line"><span class="cl">    // 会解析方法的参数列表信息
</span></span><span class="line"><span class="cl">    this.paramNameResolver = new ParamNameResolver(configuration, method);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在初始化过程中，我们看到会调用 getUniqueParamIndex() 方法查找目标类型参数的下标索引位置，其核心原理就是遍历方法的参数列表，逐个匹配参数的类型是否为目标类型，如果匹配成功，则会返回当前参数的下标索引。getUniqueParamIndex() 方法的具体实现比较简单，这里就不再展示，你若感兴趣的话可以参考源码进行学习。</p>
<p>3. 深入 execute() 方法</p>
<p>分析完 MapperMethod 中的几个核心内部类，我们回到 MapperMethod 继续介绍。</p>
<p>execute() 方法是 MapperMethod 中最核心的方法之一。execute() 方法会根据要执行的 SQL 语句的具体类型执行 SqlSession 的相应方法完成数据库操作，其核心实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public Object execute(SqlSession sqlSession, Object[] args) {
</span></span><span class="line"><span class="cl">    Object result;
</span></span><span class="line"><span class="cl">    switch (command.getType()) { // 判断SQL语句的类型
</span></span><span class="line"><span class="cl">        case INSERT: {
</span></span><span class="line"><span class="cl">            // 通过ParamNameResolver.getNamedParams()方法将方法的实参与
</span></span><span class="line"><span class="cl">            // 参数的名称关联起来
</span></span><span class="line"><span class="cl">            Object param = method.convertArgsToSqlCommandParam(args);
</span></span><span class="line"><span class="cl">            // 通过SqlSession.insert()方法执行INSERT语句，
</span></span><span class="line"><span class="cl">            // 在rowCountResult()方法中，会根据方法的返回值类型对结果进行转换
</span></span><span class="line"><span class="cl">            result = rowCountResult(sqlSession.insert(command.getName(), param));
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        case UPDATE: {
</span></span><span class="line"><span class="cl">            Object param = method.convertArgsToSqlCommandParam(args);
</span></span><span class="line"><span class="cl">            // 通过SqlSession.update()方法执行UPDATE语句
</span></span><span class="line"><span class="cl">            result = rowCountResult(sqlSession.update(command.getName(), param));
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // DELETE分支与UPDATE类似，省略
</span></span><span class="line"><span class="cl">        case SELECT:
</span></span><span class="line"><span class="cl">            if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {
</span></span><span class="line"><span class="cl">                // 如果方法返回值为void，且参数中包含了ResultHandler类型的实参，
</span></span><span class="line"><span class="cl">                // 则查询的结果集将会由ResultHandler对象进行处理
</span></span><span class="line"><span class="cl">                executeWithResultHandler(sqlSession, args);
</span></span><span class="line"><span class="cl">                result = null;
</span></span><span class="line"><span class="cl">            } else if (method.returnsMany()) {
</span></span><span class="line"><span class="cl">                // executeForMany()方法处理返回值为集合或数组的场景
</span></span><span class="line"><span class="cl">                result = executeForMany(sqlSession, args);
</span></span><span class="line"><span class="cl">            } else ...// 省略针对Map、Cursor以及Optional返回值的处理
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">            // 省略FLUSH和default分支
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return result;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 execute() 方法中，对于 INSERT、UPDATE、DELETE 三类 SQL 语句的返回结果，都会通过 rowCountResult() 方法处理。我们知道，上述三种类型的 SQL 语句的执行结果是一个数字，多数场景中代表了 SQL 语句影响的数据行数（注意，这个返回值的具体含义根据 MySQL 的配置有所变化），rowCountResult() 方法会将这个 int 值转换成 Mapper 接口方法的返回值，具体规则如下：</p>
<p>Mapper 方法返回值为 void，则忽略 SQL 语句的 int 返回值，直接返回 null；</p>
<p>Mapper 方法返回值为 int 或 Integer 类型，则将 SQL 语句返回的 int 值直接返回；</p>
<p>Mapper 方法返回值为 long 或 Long 类型，则将 SQL 语句返回的 int 值转换成 long 类型之后返回；</p>
<p>Mapper 方法返回值为 boolean 或 Boolean 类型，则将 SQL 语句返回的 int 值与 0 比较大小，并将比较结果返回。</p>
<p>接下来看 execute() 方法针对 SELECT 语句查询到的结果集的处理。</p>
<p>如果在方法参数列表中有 ResultHandler 类型的参数存在，则会使用 executeWithResultHandler() 方法完成查询，底层依赖的是 SqlSession.select() 方法，结果集将会交由传入的 ResultHandler 对象进行处理。</p>
<p>如果方法返回值为集合类型或是数组类型，则会调用 executeForMany() 方法，底层依赖 SqlSession.selectList() 方法进行查询，并将得到的 List 转换成目标集合类型。</p>
<p>如果方法返回值为 Map 类型，则会调用 executeForMap() 方法，底层依赖 SqlSession.selectMap() 方法完成查询，并将结果集映射成 Map 集合。</p>
<p>针对 Cursor 以及 Optional返回值的处理，也是依赖的 SqlSession 的相关方法完成查询的，这里不再展开。</p>
<p>总结</p>
<p>在这一讲，我们重点介绍了 MyBatis 中的 binding 模块，正是该模块实现了 Mapper 接口与 Mapper.xml 配置文件的映射功能。</p>
<p>首先，介绍了 MapperRegistry 这个注册中心，其中维护了 Mapper 接口与代理工厂对象之间的映射关系。</p>
<p>然后，分析了 MapperProxy 和 MapperProxyFactory，其中 MapperProxyFactory 使用 JDK 动态代理方式为相应的 Mapper 接口创建了代理对象，MapperProxy 则封装了核心的代理逻辑，将拦截到的目标方法委托给对应的 MapperMethod 处理。</p>
<p>最后，详细讲解了 MapperMethod，分析了它是如何根据方法签名执行相应的 SQL 语句。</p>
<p>到这里，你应该就能回答开篇的那几个疑惑了吧？我这里也总结一下。</p>
<p>使用 CustomerMapper 接口来执行 SQL 语句，是因为可以在编译期提前暴露错误。</p>
<p>之所以不用为 CustomerMapper 接口提供具体实现，是因为调用的是 CustomerMapper 的代理对象。</p>
<p>CustomerMapper 对象是通过 JDK 动态代理生成的，在调用这些代理对象的方法时，就会按照我们今天这一讲整体讲解的逻辑和顺序（所以这一讲你要系统地去学习，各个知识点和步骤是串联在一起的），找到相应的 CustomerMapper.xml 中定义的 SQL 语句并执行这些 SQL 语句，完成数据库操作。</p>
<p>关于这一讲的内容，若你有什么问题，期待在留言区与我分享和交流。</p>
<p>在下一讲，我将会继续介绍 MyBatis 中的缓存模块，记得按时来听课。</p>
<p>《Java 工程师高薪训练营》</p>
<p>实战训练+面试模拟+大厂内推，想要提升技术能力，进大厂拿高薪，点击链接，提升自己！</p>
<p>-&ndash; ### 精选评论 ##### **林： &gt; 老师分析的丝丝入扣，太厉害(ง •̀_•́)ง了！ ##### *昊： &gt; 突然有点儿悲哀，感觉MyBatis就是一个干脏活儿、累活儿的框架，各种遍历、映射、针对不同情况的转换等等</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90mybatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">深入剖析MyBatis核心原理</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/ai%E6%8A%80%E6%9C%AF%E5%86%85%E5%8F%82/089%E5%B9%BF%E5%91%8A%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A8%A1%E5%9D%97/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">089广告系统核心技术模块</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/08reactor%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8B%E5%A6%82%E4%BD%95%E5%A4%9A%E6%A0%B7%E5%8C%96%E8%A3%81%E5%89%AA%E5%93%8D%E5%BA%94%E5%BC%8F%E6%B5%81/">
            <span class="next-text nav-default">08Reactor操作符（下）：如何多样化裁剪响应式流？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
