<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>06__x_break_x;_搞懂如何在循环外使用break，方知语句执行真解 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是周爱民。
上一讲的for语句为你揭开了 JavaScript 执行环境的一角。在执行系统的厚重面纱之下，到底还隐藏了哪些秘密呢？那些所谓的执行环境、上下文、闭包或块与块级作用域，到底有什么用，或者它们之间又是如何相互作用的呢？
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/06__x_break_x_%E6%90%9E%E6%87%82%E5%A6%82%E4%BD%95%E5%9C%A8%E5%BE%AA%E7%8E%AF%E5%A4%96%E4%BD%BF%E7%94%A8break%E6%96%B9%E7%9F%A5%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E7%9C%9F%E8%A7%A3/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/06__x_break_x_%E6%90%9E%E6%87%82%E5%A6%82%E4%BD%95%E5%9C%A8%E5%BE%AA%E7%8E%AF%E5%A4%96%E4%BD%BF%E7%94%A8break%E6%96%B9%E7%9F%A5%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E7%9C%9F%E8%A7%A3/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="06__x_break_x;_搞懂如何在循环外使用break，方知语句执行真解">
  <meta property="og:description" content="你好，我是周爱民。
上一讲的for语句为你揭开了 JavaScript 执行环境的一角。在执行系统的厚重面纱之下，到底还隐藏了哪些秘密呢？那些所谓的执行环境、上下文、闭包或块与块级作用域，到底有什么用，或者它们之间又是如何相互作用的呢？">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="JavaScript核心原理解析">

  <meta itemprop="name" content="06__x_break_x;_搞懂如何在循环外使用break，方知语句执行真解">
  <meta itemprop="description" content="你好，我是周爱民。
上一讲的for语句为你揭开了 JavaScript 执行环境的一角。在执行系统的厚重面纱之下，到底还隐藏了哪些秘密呢？那些所谓的执行环境、上下文、闭包或块与块级作用域，到底有什么用，或者它们之间又是如何相互作用的呢？">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5588">
  <meta itemprop="keywords" content="JavaScript核心原理解析">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="06__x_break_x;_搞懂如何在循环外使用break，方知语句执行真解">
  <meta name="twitter:description" content="你好，我是周爱民。
上一讲的for语句为你揭开了 JavaScript 执行环境的一角。在执行系统的厚重面纱之下，到底还隐藏了哪些秘密呢？那些所谓的执行环境、上下文、闭包或块与块级作用域，到底有什么用，或者它们之间又是如何相互作用的呢？">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">06__x_break_x;_搞懂如何在循环外使用break，方知语句执行真解</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5588 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#用中断break代替跳转">用中断（Break）代替跳转</a>
          <ul>
            <li><a href="#第一种中断">第一种中断</a></li>
            <li><a href="#第二种中断">第二种中断</a></li>
          </ul>
        </li>
        <li><a href="#执行现场的回收">执行现场的回收</a></li>
        <li><a href="#语句执行的意义">语句执行的意义</a></li>
        <li><a href="#中断语句的特殊性">中断语句的特殊性</a></li>
        <li><a href="#知识回顾">知识回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是周爱民。</p>
<p>上一讲的<code>for</code>语句为你揭开了 JavaScript 执行环境的一角。在执行系统的厚重面纱之下，到底还隐藏了哪些秘密呢？那些所谓的执行环境、上下文、闭包或块与块级作用域，到底有什么用，或者它们之间又是如何相互作用的呢？</p>
<p>接下来的几讲，我就将重点为你讲述这些方面的内容。</p>
<h2 id="用中断break代替跳转">用中断（Break）代替跳转</h2>
<p>在 Basic 语言还很流行的时代，许多语言的设计中都会让程序代码支持带地址的“语句”。例如，Basic 就为每行代码提供一个标号，你可以把它叫做“<strong>行号</strong>”，但它又不是绝对物理的行号，通常为了增减程序的方便，会使用“1，10，20……”等等这样的间隔。如果想在第 10 行后追加 1 行，就可以将它的行号命名为“11”。</p>
<p>行号是一种很有历史的程序逻辑控制技术，更早一些可以追溯到汇编语言，或可以手写机器代码的时代（确实存在这样的时代）。那时由于程序装入位置被标定成内存的指定位置，所以这个位置也通常就是个地址偏移量，可以用数字化或符号化的形式来表达。</p>
<p>所有这些“为代码语句标示一个位置”的做法，其根本目的都是为了实现“GOTO 跳转”，任何时候都可以通过“GOTO 标号”的语法来转移执行流程。</p>
<p>然而，这种黑科技在 20 世纪的 60~70 年代就已经普遍地被先辈们批判过了。这样的编程方式只会大大地降低程序的可维护性，其正确性或正确性验证都难以保障。所以，后面的故事想必你都知道了，半个多世纪之前开始的**“结构化”运动**一直影响至今，包括现在我与你讨论的这个 JavaScript，都是“结构化程序设计”思想的产物。</p>
<p>所以，简单地说：JavaScript 中没有 GOTO 语句了。取而代之的，是<strong>分块代码</strong>，以及<strong>基于代码分块的流程控制技术</strong>。这些控制逻辑基于一个简单而明了的原则：如果代码分块中需要 GOTO 的逻辑，那么就为它设计一个“自己的 GOTO”。</p>
<p>这样一来，所有的 GOTO 都是“块（或块所在语句）自己知道的”。这使得程序可以在“自己知情的前提下自由地 GOTO”。整体看起来，这还不错，很酷。然而，问题是那些“标号”啊，或者“程序地址”之类的东西已经被先辈们干掉了，因此就算设计了 GOTO 也找不到去处，那该怎么办呢？</p>
<h3 id="第一种中断">第一种中断</h3>
<p>第一种处理方法最为简洁，就是<strong>约定可以“通过 GOTO 到达的位置”</strong>。</p>
<p>在这种情况下，JavaScript 将 GOTO 的“离开某个语句”这一行为理解为“中断（Break）该语句的执行”。由于这个中断行为是明确针对于该语句的，所以“GOTO 到达的位置”也就可以毫无分歧地约定为该语句（作为代码块）的结束位置。这是“break”作为子句的由来。它用在某些“可中断语句（BreakableStatement）”的内部，用于中断并将程序流程“跳转（GOTO）到语句的结束位置”。</p>
<p>在语法上，这表示为（该语法只作用于对”可中断语句“的中断）：</p>
<blockquote>
<p><strong>break</strong>;</p>
</blockquote>
<p>所谓“可中断语句”其实只有两种，包括全部的<strong>循环语句</strong>，以及 <strong>swtich 语句</strong>。在这两种语句内部使用的“break;”，采用的就是这种处理机制——中断当前语句，将执行逻辑交到下一语句。</p>
<h3 id="第二种中断">第二种中断</h3>
<p>与第一种处理方法的限制不同，第二种中断语句可以中断“任意的标签化语句”。所谓标签化语句，就是在一般语句之前加上“xxx:”这样的标签，用以指示该语句。就如我在文章中写的这两段示例：</p>
<p>// 标签 aaa<br>
aaa: {<br>
&hellip;<br>
}</p>
<p>// 标符 bbb<br>
bbb: if (true) {<br>
&hellip;<br>
}</p>
<p>对比这两段示例代码，你难道不会有这么一个疑惑吗？在标签 aaa 中，显然 aaa 指示的是后续的“块语句”的块级作用域；而在标签 bbb 中，<code>if</code>语句是没有块级作用域的，那么 bbb 到底指示的是“if 语句”呢，还是其后的<code>then</code>分支中的“块语句”呢？</p>
<p>这个问题本质上是在“块级作用域”与“标签作用的（语句）范围”之间撕裂了一条鸿沟。由于标签 bbb 在语义上只是要“标识其后的一行语句”，因此这种指示是与“块级作用域（或词法环境）”没有关系的。简单地说，标签化语句理解的是“位置”，而不是“（语句在执行环境中的）范围”。</p>
<p>因此，中断这种标签化语句的“break”的语法，也是显式地用“标签”来标示位置的。例如：</p>
<blockquote>
<p><strong>break</strong>labelName;</p>
</blockquote>
<p>所以你才会看到，我在文章中写的这两种语句都是可行的：</p>
<p>// 在 if 语句的两个分支中都可以使用 break；<br>
// （在分支中深层嵌套的语句中也是可以使用 break 的）<br>
aaa: if (true) {<br>
&hellip;<br>
}<br>
else {<br>
&hellip;<br>
break bbb;<br>
}</p>
<p>// 在 try&hellip;catch&hellip;finally 中也可以使用 break;<br>
bbb: try {<br>
&hellip;<br>
}<br>
finally {<br>
break bbb;<br>
}</p>
<p>对于标签 bbb 的 finally 块中使用的这个特例，我需要再特别说明：如果在 try 或 try…except 块中使用了 return，那么这个 break 将发生于最后一行语句之后，但是却是在 return 语句之前。例如我在文章中写的这段代码：</p>
<p>var i = 100;<br>
function foo() {<br>
bbb: try {<br>
console.log(&ldquo;Hi&rdquo;);<br>
return i++; //  &lt;- 位置 1：i++ 表达式将被执行<br>
}<br>
finally {<br>
break bbb;<br>
}<br>
console.log(&ldquo;Here&rdquo;);<br>
return i; //  &lt;- 位置 2<br>
}</p>
<p>测试如下：</p>
<blockquote>
<p>foo()<br>
Hi<br>
Here<br>
101</p>
</blockquote>
<p>在这个例子中，你的预期可能会是“位置 1”返回的 100，而事实上将执行到输出“Here”并通过位置 2 返回 101。这也很好地说明了 **<code>break</code>语句本质上就是作用于其后的“一个语句”，而与它“有多少个块级作用域”无关 **。</p>
<h2 id="执行现场的回收">执行现场的回收</h2>
<p>break 将“语句的‘代码块’”理解为<strong>位置</strong>，而不是理解为作用域 / 环境，这是非常重要的前设！</p>
<p>然而，我在上面已经讲过了，程序代码中的“位置”已经被先辈们干掉了。他们用了半个世纪来证明了一件事情：<strong>想要更好、更稳定和更可读的代码，那么就忘掉“（程序的）位置”这个东西吧！</strong></p>
<p>通过“作用域”来管理代码的确很好，但是作用域与“语句的位置”以及“GOTO 到新的程序执行”这样的理念是矛盾的。它们并不在同一个语义系统内，这也是<strong>标签</strong>与<strong>变量</strong>可以重名而不相互影响的根本原因。由于这个原因，在使用标签的代码上下文中，<strong>执行现场的回收</strong>就与传统的“块”以及“块级作用域”根本上不同。</p>
<p>JavaScript 的执行机制包括“执行权”和“数据资源”两个部分，分别映射可计算系统中的“逻辑”与“数据”。而块级作用域（也称为词法作用域）以及其他的作用域本质上就是一帧数据，以保存执行现场的一个瞬时状态（也就是每一个执行步骤后的现场快照）。而 JavaScript 的运行环境被描述为一个后入先出的栈，这个栈顶永远就是当前“执行权”的所有者持用的那一帧数据，也就是代码活动的现场。</p>
<p>JavaScript 的运行环境通过函数的 CALL/RETURN 来模拟上述“数据帧”在栈上的入栈与出栈过程。任何一次函数的调用，即是向栈顶压入该函数的上下文环境（也就是作用域、数据帧等等，它们在不同场合下的相同概念）。所以，包括那些在全局或模块全局中执行的代码，以及 Promise 中执行调度的那些内部处理，所有的这些 JavaScript 内部过程或外部程序都统一地被封装成函数，通过 CALL/RETURN 来激活、挂起。</p>
<p>所以，“作用域”就是在上述过程中被操作的一个对象。</p>
<ol>
<li>作用域退出，就是函数 RETURN。</li>
<li>作用域挂起，就是执行权的转移。</li>
<li>作用域的创建，就是一个闭包的初始化。</li>
<li>……</li>
</ol>
<p>然而如之前所说的，“<strong>break</strong> labelName;”这一语法独立于“执行过程”的体系，它表达一个位置的跳转，而不是一个数据帧在栈上的进出栈。这是 labelName 独立于标识符体系（也就是词法环境）所带来的附加收益！</p>
<p>基于对“语句”的不同理解，JavaScript 设计了一种全新方法，用来清除这个跳转所带来的影响（也就是回收跳转之前的资源分配）。而这多余出来的设计，其实也是上述收益所需要付出的代价。</p>
<h2 id="语句执行的意义">语句执行的意义</h2>
<p>对于语句的跳转来说，“离开语句”意味着清除语句所持有的一切资源，如同函数退出时回收闭包。但是，这也同样意味着“语句”中发生的一切都消失了，对于函数来说，return 和 yield 是唯二从这个现场发出信息的方式。那么语句呢？语句的执行现场从这个“程序逻辑的世界”中湮灭之后，又留下了什么呢？</p>
<blockquote>
<p>NOTE: 确实存在从函数中传出信息的其他结构，但这些也将援引别的解释方式，这些就留待今后再讲了。</p>
</blockquote>
<p>语句执行与函数执行并不一样。函数是求值，所以返回的是对该函数求值的结果（Result），该结果或是值（Value），或是结果的引用（Reference）。而语句是命令，语句执行的返回结果是该命令得以完成的状态（Completion, Completion Record Specification Type）。</p>
<p>注意，JavaScript 是一门混合了函数式与命令式范型的语言，而这里对函数和语句的不同处理，正是两种语言范型根本上的不同抽象模型带来的差异。</p>
<p>在 ECMAScript 规范层面，本质上所有 JavaScript 的执行都是语句执行（这很大程度上解释了为什么 eval 是执行语句）。因此，ECMAScript 规范中对执行的描述都称为“运行期语义（Runtime Semantics）”，它描述一个 JavaScript 内部的行为或者用户逻辑的行为的过程与结果。也就是说这些运行期语义都最终会以一个完成状态（Completion）来返回。例如：</p>
<ol>
<li>一个函数的调用：调用函数——执行函数体（EvaluateBody）并得到它的“完成”结果（result）。</li>
<li>一个块语句的执行：执行块中的每行语句，得到它们的“完成”结果（result）。</li>
</ol>
<p>这些结果（result）包括的状态有五种，称为完成的类型：normal、break、continue、return、throw。也就是说，任何语句的行为，要么是包含了有效的、可用于计算的数据值（Value）：</p>
<ol>
<li>正常完成（normal）</li>
<li>一个函数调用的返回（return）</li>
</ol>
<p>要么是一个不可（像数据那样）用于计算或传递的纯粹状态：</p>
<ol>
<li>循环过程中的继续下次迭代（continue）</li>
<li>中断（break）</li>
<li>异常（throw）</li>
</ol>
<blockquote>
<p>NOTE: throw 是一个很特殊的流程控制语句，它与这里的讨论的流程控制有相似性，不同的地方它于：它并不需要标签。关于 throw 更多的特性，我还会在稍后的课程中给你具体地分析。</p>
</blockquote>
<p>所以当运行期出了一这个称为“中断（break）”的状态时，JavaScript 引擎需要找到这个“break”标示的目标位置（<strong>result</strong>.Target），然后与当前语句的标签（如果有的话）对比：</p>
<ol>
<li>如果一样，则取 break 源位置的语句执行结果为值（Value）并以正常完成状态返回；</li>
<li>如果不一样，则继续返回 break 状态。</li>
</ol>
<p>这与函数调用的过程有一点类似之处：由于对“break 状态”的拦截交给语句退出（完成）之后的下一个语句，因此如果语句是嵌套的，那么其后续（也就是外层的）语句就可以得到处理这个“break 状态”的机会。举例来说：</p>
<p>console.log(eval(<code>  aaa: {   1+2;   bbb: {   3+4;   break aaa;   }   }  </code>)); // 输出值：7</p>
<p>在这个示例中，“break aaa”语句是发生于 bbb 标签所示块中的。但当这个中断发生时，</p>
<ol>
<li>标签化语句 bbb 将首先捕获到这个语句完成状态，并携带有标签 aaa；</li>
<li>由于 bbb 语句完成时检查到的状态中的中断目标（Target）与自己的标签不同，所以它将这个状态继续作为自己的完成状态，返回给外层的 aaa 标签化语句 aaa；</li>
<li>语句 aaa 得到上述状态，并对比标签成功，返回结果值为语句<code>3+4</code>的值（作为完成状态传出）。</li>
</ol>
<p>所以，语句执行总是返回它的完成状态，且如果这个完成状态是包含值（Value）的话，那么它是可以作为 JavaScript 代码可访问的数据来使用的。例如，如果该语句被作为<code>eval()</code>来执行，那么它就是 eval() 函数返回的值。</p>
<h2 id="中断语句的特殊性">中断语句的特殊性</h2>
<p>最后的一个问题是：标题中的这行代码有什么特殊性呢？</p>
<p>相信你知道我总是会设计一些难解的，以及表面上矛盾和歧义的代码，并围绕这样的代码来组织我的专题的每一讲的内容。而今天这行代码在“貌似难解”的背后，其实并不包含任何特殊的执行效果，它的执行过程并不会对其他任何代码构成任何影响。</p>
<p>我列出这行代码的原因有两点。</p>
<ol>
<li>它是最小化的 break 语句的用法，你不可能写出更短的代码来做 break 的示例了；</li>
<li>这种所谓“不会对其他任何代码构成任何影响”的语句，也是 JavaScript 中的特有设计。</li>
</ol>
<p>首先，由于“标签化语句”必须作用于“一个”语句，而<strong>语句</strong>理论上的最小化形式是“空语句”。但是将空语句作为 break 的目标标签语句是不可能的，因为你还必须在标签语句所示的语句范围内使用 break 来中断。空语句以及其他一些单语句没有这样的语句范围，因此最小化的示例就只能是对 break 语句自身的中断。</p>
<p>其次，语句的返回与函数的返回有相似性。例如，函数可以不返回任何东西给外部，这种情况下外部代码得到的函数出口信息会是 undefined 值。</p>
<p>由于典型的函数式语言的“函数”应该是没有副作用的，所以这意味着该函数的执行过程不影响任何其他逻辑——也不在这个“程序逻辑的世界”中留下任何的状态。事实上，你还可以用“void”运算符来阻止一个函数返回的值影响它的外部世界。函数是“表达式运算”这个体系中的，因此用一个运算符来限制它的逻辑，这很合理。</p>
<p>虽然“<strong>break</strong> labelName”的中止过程是可以传出“最后执行语句”的状态的，但是你只要回忆一下这个过程就会发现一个悖论：任何被 break 的代码上下文中，最后执行语句必然会是“break 语句”本身！所以，如果要在这个逻辑中实现“语句执行状态”的传递，那么就必须确保：</p>
<ol>
<li>“break 语句”不返回任何值（ECMAScript 内部约定用“Empty”值来表示）；</li>
<li>上述“不返回任何值”的语句，也不会影响任何语句的既有返回值。</li>
</ol>
<p>所以，事实上我们已经探究了”break 语句“返回值的两个关键特性的由来：</p>
<ol>
<li>它的类型必然是“break”；</li>
<li>它的返回值必然是“空（Empty）”。</li>
</ol>
<p>对于 Empty 值，在 ECMAScript 中约定：在多行语句执行时它可以被其他非 Empty 值更新（UpdateEmpty），而 Empty 不可以覆盖其他任何值。</p>
<p>这就是空语句等也同样“不会对其他任何代码构成任何影响”的原因了。</p>
<h2 id="知识回顾">知识回顾</h2>
<p>今天的内容有一些非常重要的、关键的点，主要包括：</p>
<ol>
<li>“GOTO 语句是有害的”。1972 年图灵奖得主——迪杰斯特拉（Edsger Wybe Dijkstra, 1968）</li>
<li>很多新的语句或语法被设计出来用来替代 GOTO 的效果的，但考虑到 GOTO 的失败以及无与伦比的破坏性，这些新语法都被设计为功能受限的了。</li>
<li>任何的一种 GOTO 带来的都是对“顺序执行”过程的中断以及现场的破坏，所以也都存在相应的执行现场回收的机制。</li>
<li>有两种中断语句，它们的语义和应用场景都不相同。</li>
<li>语句有返回值。</li>
<li>在顺序执行时，当语句返回 Empty 的时候，不会改写既有的其他语句的返回值。</li>
<li>标题中的代码，是一个“最小化的 break 语句示例”。</li>
</ol>
<h2 id="思考题">思考题</h2>
<ol>
<li>找到其他返回 Empty 的语句。</li>
<li>尝试完整地对比函数执行与语句执行的过程。</li>
</ol>
<p>欢迎你在进行深入思考后，与其他同学分享自己的想法，也让我有机会能听听你的收获。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">JavaScript核心原理解析</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/webassembly%E5%85%A5%E9%97%A8%E8%AF%BE/06__wat%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AA_webassembly_%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A1%E5%9D%97%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%93%E4%BA%8E%E8%A7%A3%E8%AF%BB/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">06__WAT：如何让一个_WebAssembly_二进制模块的内容易于解读？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/06__x86%E6%9E%B6%E6%9E%84%E6%9C%89%E4%BA%86%E5%BC%80%E6%94%BE%E7%9A%84%E6%9E%B6%E6%9E%84%E6%89%8D%E8%83%BD%E6%89%93%E9%80%A0%E5%BC%80%E6%94%BE%E7%9A%84%E8%90%A5%E5%95%86%E7%8E%AF%E5%A2%83/">
            <span class="next-text nav-default">06__x86架构：有了开放的架构，才能打造开放的营商环境</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
