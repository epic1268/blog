<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>09__(...x)：不是表达式、语句、函数，但它却能执行 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是周爱民，欢迎回到我的专栏。
从之前的课程中，你应该已经对语句执行和函数执行有了基本的了解。事实上，这两种执行其实都是对顺序、分支与循环三种逻辑在语义上的表达。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/09__...x%E4%B8%8D%E6%98%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E5%8F%A5%E5%87%BD%E6%95%B0%E4%BD%86%E5%AE%83%E5%8D%B4%E8%83%BD%E6%89%A7%E8%A1%8C/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/09__...x%E4%B8%8D%E6%98%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E5%8F%A5%E5%87%BD%E6%95%B0%E4%BD%86%E5%AE%83%E5%8D%B4%E8%83%BD%E6%89%A7%E8%A1%8C/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="09__(...x)：不是表达式、语句、函数，但它却能执行">
  <meta property="og:description" content="你好，我是周爱民，欢迎回到我的专栏。
从之前的课程中，你应该已经对语句执行和函数执行有了基本的了解。事实上，这两种执行其实都是对顺序、分支与循环三种逻辑在语义上的表达。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="JavaScript核心原理解析">

  <meta itemprop="name" content="09__(...x)：不是表达式、语句、函数，但它却能执行">
  <meta itemprop="description" content="你好，我是周爱民，欢迎回到我的专栏。
从之前的课程中，你应该已经对语句执行和函数执行有了基本的了解。事实上，这两种执行其实都是对顺序、分支与循环三种逻辑在语义上的表达。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5180">
  <meta itemprop="keywords" content="JavaScript核心原理解析">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="09__(...x)：不是表达式、语句、函数，但它却能执行">
  <meta name="twitter:description" content="你好，我是周爱民，欢迎回到我的专栏。
从之前的课程中，你应该已经对语句执行和函数执行有了基本的了解。事实上，这两种执行其实都是对顺序、分支与循环三种逻辑在语义上的表达。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">09__(...x)：不是表达式、语句、函数，但它却能执行</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5180 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#递归与迭代">递归与迭代</a></li>
        <li><a href="#迭代对执行过程的重造和使用">迭代对执行过程的重造和使用</a></li>
        <li><a href="#展开语法">展开语法</a></li>
        <li><a href="#如何做到呢">如何做到呢？</a></li>
        <li><a href="#内部迭代过程">内部迭代过程</a></li>
      </ul>
    </li>
    <li><a href="#列举-x第一次迭代后即执行-break">列举 x，第一次迭代后即执行 break;</a>
      <ul>
        <li><a href="#异常处理">异常处理</a></li>
        <li><a href="#是谁的退出与异常">是谁的退出与异常？</a></li>
        <li><a href="#知识回顾">知识回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是周爱民，欢迎回到我的专栏。</p>
<p>从之前的课程中，你应该已经对语句执行和函数执行有了基本的了解。事实上，这两种执行其实都是对<strong>顺序</strong>、<strong>分支</strong>与<strong>循环</strong>三种逻辑在语义上的表达。</p>
<p>也就是说，无论一门语言的语法有什么特异之处，它对“执行逻辑”都可以归纳到这三种语义的表达方式上来。这种说法事实上也并不特别严谨，因为这三种基本逻辑还存在进一步抽象的空间（这些也会是我将来会讨论到的内容，今天暂且不论）。</p>
<p>今天这一讲中，主要讨论的是第二种执行的一些细节，也就是对“函数执行”的进一步补充。</p>
<p>在上一讲中，我有意地将函数分成三个语义组件来讲述。我相信在绝大多数的情况下，或者在绝大多数的语言教学中，都是不必要这样做的。这三个语义组件分别是指参数、执行体和结果，将它们分开来讨论，最主要的价值就在于：通过改造这三个语义组件的不同部分，我们可以得到不同的“函数式的”执行特征与效果。换而言之，可以通过更显式的、特指的或与应用概念更贴合的语法来表达新的语义。与所谓“特殊可执行结构”一样，这些语义也用于映射某种固定的、确定的逻辑。</p>
<p>语言的设计，本质就是为确定的语义赋以恰当的语法表达。</p>
<h2 id="递归与迭代">递归与迭代</h2>
<p>如果循环是一种确定的语义，那么如何在函数执行中为它设计合适的语法表达呢？</p>
<p>递归绝对是一个好的、经典的求解思路。递归将循环的次数直接映射成函数“执行体”的重复次数，将循环条件放在函数的参数界面中，并通过函数调用过程中的值运算来传递循环次数之间的数值变化。递归作为语义概念简单而自然，惟一与函数执行存在（潜在的）冲突的只是所谓栈的回收问题，亦即是尾递归的处理技巧等，但这些都是实现层面的要求，而与语言设计无关。</p>
<p>由于递归并不改变函数的三个语义组件之任一，因此它与函数执行过程完全没有冲突，也没有任何新的需求与设计。这句话的潜在意思是说，函数的三个语义组件都不需要为此作出任何的设计修改，例如：</p>
<p>const f = x =&gt; x &amp;&amp; f(&ndash;x);</p>
<p>在这段代码中，是没有出现任何特殊的语法和运算 / 操作符的，它只是对函数、（变量或常量的）声明、表达式以及函数调用等等的简单组合。</p>
<p>然而迭代不是。迭代也是循环语义的一种实现，它说明循环是“函数体”的重复执行——而不是“递归”所理解的“函数调用自己”——的语义。这是一种可受用户代码控制的循环体。你可以尝试创建这样一个简单的迭代函数：</p>
<p>// 迭代函数<br>
function foo(x = 5) {<br>
return {<br>
next: () =&gt; {<br>
return {done: !x, value: x &amp;&amp; x&ndash;};<br>
}<br>
}<br>
}</p>
<p>然而请仔细观察这样的两个实现，你需要注意在这个迭代函数中有“值 (value) 和状态 (done)”两个控制变量，并且它的实际执行代码与上面的函数 f() 是一样的：</p>
<p>// in 函数 f()<br>
x &amp;&amp; f(&ndash;x)</p>
<p>// in 迭代 foo()<br>
x &amp;&amp; x&ndash;</p>
<p>也就是说，递归函数“f()”和迭代函数“foo()”其实是在实现相同的过程。只是由于“递归完成与循环过程的结束”在这里是相同的语义，因此函数“f()”中不需要像迭代函数那样来处理“状态 (done)”的传出。——递归函数“f()”，要么结束，要么无穷递归。</p>
<h2 id="迭代对执行过程的重造和使用">迭代对执行过程的重造和使用</h2>
<p>在 JavaScript 中，是通过一个中间对象来使用迭代过程 _foo()_ 的。该中间对象称为迭代器，foo() 称为迭代器函数，用于返回该迭代器。例如：</p>
<p>var tor = foo(); // default <code>x</code> is 5<br>
&hellip;</p>
<p>迭代器具有<code>.next()</code>方法用于一次（或每次）迭代调用。由于没有约定迭代调用的方式，因此可以用任何过程来调用它。例如：</p>
<p>// 在循环语句中处理迭代调用<br>
var tor = foo(5), result = tor.next();<br>
while (!result.done) {<br>
console.log(result.value);<br>
result = tor.next();<br>
}</p>
<p>除了一些简单的、概念名词上的置换外，这些与你所见过的绝大多数有关“迭代器与生成器”的介绍并没有什么不同。并且你也应当理解，正是这个“.next()”调用的界面维护了迭代过程的上下文，以及值之间的相关性（例如一个值序列的连续性）。</p>
<p>根据约定，如果有一个对象“包含”这样一个迭代器函数（以返回一个迭代器），那么这个对象就是可迭代的。基于 JavaScript 中“对象是属性集（所以所有包含的东西都必然是属性）”的概念，这个迭代函数被设计为称为“Symbol.iterator”的符号属性。例如：</p>
<p>let x = new Object;<br>
x[Symbol.iterator] = foo; // default <code>x</code> is 5</p>
<p>现在，你可以使用这个可迭代对象了：</p>
<blockquote>
<p>console.log(&hellip;x);<br>
5 4 3 2 1</p>
</blockquote>
<p>现在，你看到了这一讲标题中的代码：</p>
<p>(&hellip;x)</p>
<p>不过，不同的是，标题中的代码是不能执行的。</p>
<h2 id="展开语法">展开语法</h2>
<p>问题的关键点在于：<code>...x</code>是什么？</p>
<p>在形式上，“…”看起来像是一个运算符，而<code>x</code>是它的操作数。但是，如果稍微深入地问一下这个问题，就会令人生疑了。例如：如果它是运算符，那么运算的返回值是什么？</p>
<p>答案是，它既不返回值，也不返回引用。</p>
<p>那么如果它不是运算符，或者说<code>...x</code>也并不是表达式，或许它们可以被理解为“语句”吗？即使如此，与上面相同的问题也会存在。例如：如果它是语句，那么该语句的返回值是什么？</p>
<p>答案是，既不是空（Empty），也不是其它结果值（Result）。因此它也不是语句（并且，因为 console.log() 是表达式，而表达式显然也“不可能包含语句”）。</p>
<p>所以，<code>...x</code>既不是表达式，也不是语句。它不是我们之前讲过的任何一种概念，而仅仅只是“语法”。作为语法，ECMAScript 在这里规定它只是对一个确定的语义的封装。</p>
<p>在语义上，它用于“展开一个可迭代对象”。</p>
<h2 id="如何做到呢">如何做到呢？</h2>
<p>为什么我要绕这么大个圈子来介绍这个“简单的”展开语法呢？又或者说，ECMAScript 为什么要弄出这么一个“新”概念呢？</p>
<p>这与函数的第三个语义组件——“值”是有关的。在 JavaScript 中——也包括在绝大多数支持函数的语言中，函数只能返回一个值。然而，如果迭代器表达的是一个重复执行的执行体，并且每次执行都返回一个值，那么又怎么可能用“返回一个值”的函数来返回呢？</p>
<p>与此类似，语句也只有一个这样的单值返回，所以批语句执行也仍然只是返回最后一行的结果。并且，一旦<code>...x</code>被理解为语句，那么它就不能用作操作数，成为一个表达式的部分。这在概念上是不容许的。所以，当在“函数”这个级别表达多次调用时，尽管它可以通过“对象（迭代对象）”来做形式上的封装，却无法有效的表达“多次调用的多个结果值”。这才是展开语法被设计出来的原因。</p>
<p>如果可迭代对象表达的是“多个值”，那么可以作用于它的操作或运算通常应该是那些面向“值的集合（Collections）”的。更确切地说，它是可以面向“索引集合（Indexed Collections）”和“键值集合（Keyed Collections）”设计的语法概念。因此在现在的，以及将来的 ECMAScript 规范中，你将会看到它的操作——例如通常包括的合并、映射、筛选等等，将在包括对象、数组、集（Set）、图（Map）等等数据的处理中大放异彩。</p>
<p>而现在，其实我想问的问题是，在函数中是如何做到迭代处理的呢？</p>
<h2 id="内部迭代过程">内部迭代过程</h2>
<p>迭代的本质是多次函数调用，在 JavaScript 内部实现这一机制，本质上就是管理这些多次调用之间的关系。这——显然的——包括一个循环过程，和至少一个循环控制变量。</p>
<p>这个迭代有一个开启过程，简单的如展开语法（“…”），复杂的如 for…of 语句。这些语法 / 语法结构通过类似如下两个步骤来完成迭代的开启：</p>
<p>var tor = foo(5), result = tor.next();<br>
while (!result.done) &hellip;</p>
<p>但是如同我在之前的课程，以及上面的讨论中一再强调的这是“一个执行过程”，既然是过程，那么就存在过程被中断的可能。简单的示例如下：</p>
<p>while (!result.done) {<br>
break;<br>
}</p>
<p>是的，这个过程什么也不会发生。如果是在经典的 while 循环里面，那么它的 result 和 tor，以及 foo() 调用所开启的那个函数闭包都被当前上下文管理或回收。然而，如果在一个展开过程，或者 for…of 循环中，相应的“语法”管理上述这些组件的时候又需要怎样的处理呢？例如：</p>
<p>function touch(x) {<br>
if (x==2) throw new Error(&ldquo;hard break&rdquo;);<br>
}</p>
<p>// 迭代函数<br>
function foo2(x = 5) {<br>
return {<br>
next: () =&gt; {<br>
touch(x); // some process methods<br>
return {done: !x, value: x &amp;&amp; x&ndash;};<br>
}<br>
}<br>
}</p>
<p>// 示例<br>
let x = new Object;<br>
x[Symbol.iterator] = foo2; // default <code>x</code> is</p>
<p>测试如下：</p>
<blockquote>
<p>console.log(&hellip;x);<br>
Error: hard break</p>
</blockquote>
<p>这个示例是一个简单异常，但如果这个异常发生于 for…of 中：</p>
<blockquote>
<p>for (let i of x) console.log(i);<br>
5<br>
4<br>
3<br>
Error: hard break</p>
</blockquote>
<p>在这两种示例中，异常都是发生于 foo2() 这个函数调用的一个外部处理过程中，而等到用户代码有机会操作时，已经处于 consolel.log() 调用或 for…of 循环中了，如果用户在这里设计异常处理过程，那么 foo2() 中的 touch(x) 管理和涉及的资源都无法处理。因此，ECMAScript 设计了另外两个方法来确保 foo2() 中的代码在“多次调用”中仍然是受控的。这包括两个回调方法：</p>
<blockquote>
<p>tor.return()，当迭代正常过程退出时回调</p>
<p>tor.throw()，当迭代过程异常退出时回调</p>
</blockquote>
<p>这并不难于证实：</p>
<blockquote>
<p>Object.getOwnPropertyNames(tor.constructor.prototype)<br>
[ &lsquo;constructor&rsquo;, &rsquo;next&rsquo;, &lsquo;return&rsquo;, &rsquo;throw&rsquo; ]</p>
</blockquote>
<p>现在如果给 tor 的 return 属性加一个回调函数，会发生什么呢？</p>
<p>// 迭代函数<br>
function foo2(x = 5) {<br>
return {<br>
// 每次.next() 都不会返回 done 状态，因此可列举无穷次<br>
&ldquo;next&rdquo;: () =&gt; new Object,  // result instance, etc.<br>
&ldquo;return&rdquo;: () =&gt; console.log(&ldquo;RETURN!&rdquo;)<br>
}<br>
}<br>
let x = new Object;<br>
x[Symbol.iterator] = foo2; // default <code>x</code> is 5</p>
<p>测试一下：</p>
<h1 id="列举-x第一次迭代后即执行-break">列举 x，第一次迭代后即执行 break;</h1>
<blockquote>
<p>for (let i of x) break;<br>
RETURN!</p>
</blockquote>
<p>结果是<code>RETURN!</code>？</p>
<p>什么鬼？！</p>
<h2 id="异常处理">异常处理</h2>
<p>并且如果你试图在 tor.throw 中去响应 foo() 迭代中的异常，却什么也得不到。例如：</p>
<p>// 迭代函数<br>
function foo3(x = 5) {<br>
return {<br>
// 第一个.next() 执行时即发生异常<br>
&ldquo;next&rdquo;: () =&gt; { throw new Error },<br>
&ldquo;throw&rdquo;: () =&gt; console.log(&ldquo;THROW!&rdquo;)<br>
}<br>
}<br>
let x = new Object;<br>
x[Symbol.iterator] = foo3;</p>
<p>在测试中，异常直接被抛给了全局：</p>
<blockquote>
<p>console.log(&hellip;x);<br>
Error<br>
at Object.next (repl:4:27)</p>
</blockquote>
<p>继续！显然可以把这个例子跟最开始使用的 foo() 组合起来，foo() 迭代可以正确的得到<code>5 4 3 2 1</code>，而上面的 return/throw 可以捕获过程的退出或异常。例如：</p>
<p>// 迭代函数<br>
function foo4(x = 5) {<br>
return {<br>
// foo() 中的 next<br>
next: () =&gt; {<br>
return {done: !x, value: x &amp;&amp; x&ndash;};<br>
},</p>
<pre><code>// foo2() 和 foo3() 中的 return 和 throw  
&quot;return&quot;: () =&gt; console.log(&quot;RETURN!&quot;),  
&quot;throw&quot;: () =&gt; console.log(&quot;THROW!&quot;)  
</code></pre>
<p>}<br>
}</p>
<p>let x = new Object;<br>
x[Symbol.iterator] = foo4</p>
<p>测试：</p>
<blockquote>
<blockquote>
<p>console.log(&hellip;x);<br>
5 4 3 2 1</p>
</blockquote>
</blockquote>
<p>Ok，成功是成功了！但是，“RETURN/THROW“呢？</p>
<p>这里简直就是迭代的地狱！</p>
<h2 id="是谁的退出与异常">是谁的退出与异常？</h2>
<p>回顾之前的内容，迭代过程并不是一个语法执行的过程，而是应该理解为一组函数执行的过程；对于这一批函数执行过程中的结束行为，也应该理解为函数内的异常或退出。因此，尽管在 for…of 的表面上看，是 break 发生了语句中的中止，而在迭代处理的内部发生的，却是“一个迭代过程的退出”。与此同样复杂的是，在这一批函数的多个执行上下文中，无论是在哪儿发生了异常，其实只有外层的第一个能捕获异常的环境能响应这个异常。</p>
<p>简单地说：“退出 (RETURN)”是执行过程的，“异常 (THROW)”是外部的。</p>
<p>JavaScript 中，迭代被处理为两个实现用的组件，一个是（循环的）迭代过程，另一个是（循环的）迭代控制变量。表现在 tor 这个迭代对象上来看，就是（对于循环来说，）“如果谁使用迭代变量 tor，那么就是谁管理迭代过程”。</p>
<p>这个“管理循环过程”意味着：</p>
<ol>
<li>如果迭代结束（无论它因为什么结束），那么触发 tor.return 事件；</li>
<li>如果发现异常（只要是当前环境能捕获到的异常），那么触发 tor.throw 事件。</li>
</ol>
<p>这两个过程总是发生在“管理循环过程”的行为框架中。例如在下面这个过程中：</p>
<p>for (let i of x) {<br>
if (i == 2) break;<br>
}</p>
<p>由于 <code>for .. of</code>语句将获得 x 对象的迭代变量 tor，那么它也将管理 x 对象的迭代过程。因此，在 for 语句 break 之后（在 for 语句将会退出自己的作用之前），它也就必须去“通知”x 对象迭代过程也结束了，于是这个语句触发了 tor.return 事件。</p>
<p>同样，如果是一个数组展开过程：</p>
<p>console.log(&hellip;x);</p>
<p>那么将是<code>...x</code>这个“展开语法”来负责上述的迭代过程的管理和“通知”，这个语法在它所在的位置上是无法响应异常的。该语法所在位置是一个表达式，不可能在它内部使用<code>try..catch</code>语句。</p>
<p>function touch(x) {<br>
if (x==2) throw new Error(&ldquo;hard break&rdquo;);<br>
}</p>
<p>// 迭代函数<br>
function foo5(x = 5) {<br>
return {<br>
// foo2() 中的 next<br>
next: () =&gt; {<br>
touch(x); // some process methods<br>
return {done: !x, value: x &amp;&amp; x&ndash;};<br>
},</p>
<pre><code>// foo3() 中的 return 和 throw  
&quot;return&quot;: () =&gt; console.log(&quot;RETURN!&quot;),  
&quot;throw&quot;: () =&gt; console.log(&quot;THROW!&quot;)  
</code></pre>
<p>}<br>
}</p>
<p>let x = new Object;<br>
x[Symbol.iterator] = foo5;</p>
<p>try {<br>
console.log(&hellip;x);<br>
}<br>
catch(e) {} // m</p>
<p>这段示例代码将 mute 掉一切：既没有 console.log() 输出，也没有异常信息，tor 的 return/throw 一个也没有发生。</p>
<p>对于 x 这个可迭代对象，以及 foo5() 这个迭代器函数来说，世界是安静的：它既不知道自己发生了什么，也不知道它的外部世界发生了什么。因为<code>...x</code>这个语法既没有管理迭代过程（因此不理解 tor 的退出 /return 行为），也没有在异常发生时向内“通知”tor.throw 事件的能力。</p>
<h2 id="知识回顾">知识回顾</h2>
<p>标题中的示例是不能执行的，因为其中的括号并不是表达式中分组运算符，也不是语句中的函数调用，也不是声明中的形式参数表。声明中的<code>...x</code>被定义为“展开语法”，是逻辑的映射（它返回的是处理逻辑），而不是“值”或“引用”。它在不同的位置被 JavaScript 解释成不同的语义，包括对象展开和数组展开，并通过一组特定的代码来实现上述的语义。</p>
<p>在<code>...x</code>被理解为数组展开时，本质上是将<code>x</code>视为一个可迭代对象，并通过一个迭代变量（例如 tor）来管理它的迭代过程。在 JavaScript 中的迭代对象 x 的生存周期是交由使用它的表达式、语句或语法来管理的，包括在必要的时候通过 tor 来向内通知 return/throw 事件。</p>
<p>在本讲的示例中，展开语法“…x”是没有向内通知的能力的，而“for … of”可以隐式地向内通知。对于后者，for…of 中的 break 和 continue，以及的循环正常退出都能够通知 return 事件，但它并没有内向通知 throw 的能力，因为 for…of 语句本身并不捕获和处理 throw。</p>
<h2 id="思考题">思考题</h2>
<ol>
<li>既然上面的过程完全不使用 tor.throw，那么它被设计出来做什么？</li>
<li><code>...x</code>为什么称为“展开语法”，为什么 ECMAScript 不提供一个表达式 / 语句之外的概念来指代它？</li>
<li>continue 在那种情况下触发 tor.return？</li>
<li>yield* x 将导致什么？</li>
</ol>
<p>欢迎你在进行深入思考后，与其他同学分享自己的想法，也让我有机会能听听你的收获。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">JavaScript核心原理解析</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/09-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E6%9C%89%E5%BA%8F%E7%9A%86%E5%8F%AF%E7%94%A8%E4%BA%8C%E5%88%86/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">09 二分搜索：为什么说有序皆可用二分？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B5%81%E7%A8%8B%E5%9E%8B%E7%BB%84%E7%BB%8715%E8%AE%B2/09__bpr%E9%A1%B9%E7%9B%AE%E8%BF%90%E4%BD%9C%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5bod%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8/">
            <span class="next-text nav-default">09__BPR项目运作的四个阶段：BOD模型的应用</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
