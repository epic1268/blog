<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>11__throw_1;：它在“最简单语法榜”上排名第三 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是周爱民，欢迎回到我的专栏。
今天我将为你介绍的是在 ECMAScript 规范中，实现起来“最简单”的 JavaScript 语法榜前三名的 JavaScript 语句。
标题中的throw 1就排在这个“最简单榜”第三名。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/11__throw_1%E5%AE%83%E5%9C%A8%E6%9C%80%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95%E6%A6%9C%E4%B8%8A%E6%8E%92%E5%90%8D%E7%AC%AC%E4%B8%89/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/11__throw_1%E5%AE%83%E5%9C%A8%E6%9C%80%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95%E6%A6%9C%E4%B8%8A%E6%8E%92%E5%90%8D%E7%AC%AC%E4%B8%89/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="11__throw_1;：它在“最简单语法榜”上排名第三">
  <meta property="og:description" content="你好，我是周爱民，欢迎回到我的专栏。
今天我将为你介绍的是在 ECMAScript 规范中，实现起来“最简单”的 JavaScript 语法榜前三名的 JavaScript 语句。
标题中的throw 1就排在这个“最简单榜”第三名。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="JavaScript核心原理解析">

  <meta itemprop="name" content="11__throw_1;：它在“最简单语法榜”上排名第三">
  <meta itemprop="description" content="你好，我是周爱民，欢迎回到我的专栏。
今天我将为你介绍的是在 ECMAScript 规范中，实现起来“最简单”的 JavaScript 语法榜前三名的 JavaScript 语句。
标题中的throw 1就排在这个“最简单榜”第三名。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5168">
  <meta itemprop="keywords" content="JavaScript核心原理解析">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="11__throw_1;：它在“最简单语法榜”上排名第三">
  <meta name="twitter:description" content="你好，我是周爱民，欢迎回到我的专栏。
今天我将为你介绍的是在 ECMAScript 规范中，实现起来“最简单”的 JavaScript 语法榜前三名的 JavaScript 语句。
标题中的throw 1就排在这个“最简单榜”第三名。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">11__throw_1;：它在“最简单语法榜”上排名第三</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5168 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#为什么讲最简单语法榜">为什么讲最简单语法榜</a></li>
        <li><a href="#在语句之外看语句">在语句之外看语句</a></li>
        <li><a href="#值的覆盖与读取">值的覆盖与读取</a></li>
      </ul>
    </li>
    <li><a href="#run-in-nodejs">Run in NodeJS</a></li>
    <li><a href="#run-in-nodejs-1">Run in NodeJS</a></li>
    <li><a href="#run-in-nodejs-510-or-nodejs-4">Run in NodeJS 5.10+ (or NodeJS 4)</a>
      <ul>
        <li><a href="#引用的值">引用的值</a></li>
        <li><a href="#还有一行代码">还有一行代码</a></li>
        <li><a href="#值-1">值 1</a></li>
        <li><a href="#知识回顾">知识回顾</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是周爱民，欢迎回到我的专栏。</p>
<p>今天我将为你介绍的是在 ECMAScript 规范中，实现起来“最简单”的 JavaScript 语法榜前三名的 JavaScript 语句。</p>
<p>标题中的<code>throw 1</code>就排在这个“最简单榜”第三名。</p>
<blockquote>
<p>NOTE: 预定的加餐将是下一讲的内容，敬请期待。^^.</p>
</blockquote>
<h2 id="为什么讲最简单语法榜">为什么讲最简单语法榜</h2>
<p>为什么要介绍这个所谓的“最简单的 JavaScript 语法榜”呢？</p>
<p>在我看来，在 ECMAScript 规范中，对 JavaScript 语法的实现，尤其是语句、表达式，以及基础特性最核心的部分等等，都可以在对这前三名的实现过程和渐次演进关系中展示出来。甚至基本上可以说，你只要理解了最简单榜的前三名，也就理解了设计一门计算机语言的基础模型与逻辑。</p>
<p><code>throw</code>语句在 ECMAScript 规范描述中，它的执行实现逻辑只有三行：</p>
<blockquote>
<p>ThrowStatement: <strong>throw</strong>Expression;</p>
<p>1.<strong>Let</strong> exprRef be the result of evaluating Expression.</p>
<p>2.<strong>Let</strong> exprValue be ? GetValue(exprRef).</p>
<p>3.<strong>Return</strong> ThrowCompletion(<strong>exprValue</strong>).</p>
</blockquote>
<p>将这三行代码倒过来看，最后一行的 ThrowCompletion() 调用其实是一个简写，完整的表示法是：</p>
<blockquote>
<p><strong>Return</strong> Completion { [Type]: <strong>exprValue</strong>, [[Target]]: empty }</p>
</blockquote>
<p>在 ECMAScript 规范的书写格式中，一对大括号“{ }”是记录的字面量（Record Literals）表示。也就是说，执行<code>throw</code>语句，在引擎层面的效果就是：<strong>返回一个类型为&quot;throw&quot;的一般记录。</strong></p>
<blockquote>
<p>NOTE：在之前的课程中讲到标签化语句的时候，提及过上述记录中的<code>[[target]]</code>字段的作用，也就是仅仅用作“<strong>break</strong>labelName”和“<strong>continue</strong>labelName”中的标签名。</p>
</blockquote>
<p>这行代码也反映了“<strong>JavaScript 语句执行是有值（Result）的</strong>”这一事实。也就是说，任何 JavaScript 语句执行时总是会“返回”一个值，包括空语句。</p>
<p>空语句其实也是上述“最简单榜”的 Top 1，因为它在 ECMAScript 的实现代码有且仅有一行：</p>
<blockquote>
<p>1.<strong>Return</strong> NormalCompletion(<strong>empty</strong>).</p>
</blockquote>
<p>与上面的代码类似，它也是一个简写，完整的表示法是：</p>
<blockquote>
<p><strong>Return</strong> Completion { [Type]: <strong>argument</strong>, [[Target]]: empty }</p>
</blockquote>
<p>而传入参数 argument 在这里是 empty，这是 ECMAScript 规范类型中的一个特殊值，理解为规范层面可以识别的 Null 值就可以了（例如它也用来指来没有<code>[[Target]]</code>）。也就是说，所谓“空语句（Empty statement）”，就是返回结果为“空值（Empty）”的一般语句。类似于此的，这一讲标题中的语句<code>throw 1</code>，就是一个返回&quot;throw&quot;类型结果的语句。</p>
<blockquote>
<p>NOTE：这样的返回结果（Result）在 ECMAScript 中称为完成记录，这在之前的课程中已经讲述过了。</p>
</blockquote>
<p>然而，向谁“返回”呢？以<code>throw 1</code>为例，谁才是<code>throw</code>语句的执行者呢？</p>
<h2 id="在语句之外看语句">在语句之外看语句</h2>
<p>在 JavaScript 中，除了<code>eval()</code>之外，从无“如何执行语句”一说。</p>
<p>这是因为任何情况下，“装载脚本 + 执行脚本”都是引擎自身的行为，用户代码在引擎内运行时，如“鱼不知水”一般，是难以知道语句本身的执行情况的。并且，即使是<code>eval()</code>，由于它的语义是“语句执行并求值”，所以事实上从<code>eval()</code>的结果来看是无法了解语句执行的状态的。</p>
<p>因为“求值”就意味着去除了“执行结果（Result）”中的状态信息。</p>
<p>ECMAScript 为 JavaScript 提供语言规范，出于 ECMAScript 规范书写的特殊性，它也同时是引擎实现的一个规范。在 ECMAScript 中，所有语句都被解析成待处理的结点，最顶层的位置总是被称为 _Script_ 或 _Module_ 的一个块（块语句），其他的语句将作为它的一级或更深层级的、嵌套的子级结点，这些结点称为“Parse Node”，它们构成的整个结构称为“Parse Tree”。</p>
<p>无论如何，语句总是一个树或子树，而表达式可以是一个子树或一个叶子结点。</p>
<blockquote>
<p>NOTE：空语句可以是叶子结点，因为没有表达式来作为它的子结点。</p>
</blockquote>
<p>执行语句与执行表达式在这样的结构中是没有明显区别的，而所谓“执行代码”，在实现上就被映射成执行这个树上的子树（或叶子结点）。</p>
<p>所谓“顺序执行的语句”表现在 _“Parse Tree_”这个树上，就是同一级的子树。它们之间平行（相同层级），并且相互之间没有“相互依赖的运算”，所以它们的值（也就是尝试执行它们共同的父结点所对应的语句）就将是最后一个语句的结果。所有顺序执行语句的结果向前覆盖，并返回最终语句的结果（Result）。</p>
<p>事实上在表达式中，也存在相同语句的执行过程。也就是如下两段代码在执行效果上其实没有什么差异：</p>
<p>// 表达式的顺序执行<br>
1, 2, 3, 4;</p>
<p>// 语句的顺序执行<br>
1; 2; 3; 4;</p>
<p>更进一步地说，如下两种语法，其抽象的语义上也是一样的：</p>
<p>// 通过分组来组合表达式<br>
(1, 2, 3, 4)</p>
<p>// 通过块语句来组合语句<br>
{1; 2; 3; 4;}</p>
<p>所以，从语法树的效果上来看，所谓“语句的执行者”，其实就是它外层的语句；而最外层的语句，总是被称为 _Script_ 或 _Module_ 的一个块，并且它会将结果返回给 shell、主进程或<code>eval()</code>。</p>
<p>除了<code>eval()</code>之外，所有外层语句都并不依赖内层语句的返回值；除了 shell 程序或主进程程序之外，也没有应用逻辑来读取这些语句缺省状态下的值。</p>
<h2 id="值的覆盖与读取">值的覆盖与读取</h2>
<p>语句的五种完成状态（normal, break, continue, return, 以及 throw）中，“Nomal（缺省状态）”大多数情况下是不被读取的，break 和 continue 用于循环和标签化语句，而 return 则是用于函数的返回值。于是，所有的状态中，就只剩下了本讲标题中的<code>throw 1</code>所指向的，也就是“异常抛出（throw）”这个状态。</p>
<blockquote>
<p>NOTE: 有且仅有 return 和 throw 两个状态是确保返回时携带有效值（包括 undefined）的。其他的完成类型则不同，可能在返回时携带“空（empty）”值，从而需要在语句外的代码（shell、主进程或 eval）进行特殊的处理。</p>
</blockquote>
<p>return 语句总是显式地返回值或隐式地置返回值为 undefined，也就是说它总是返回值，而 break 和 continue 则是不携带返回值的。那么是不是说，当一个“<strong>语句块</strong>”的最终语句是 break 或 continue 以及其他一些不携带返回值的语句时，该“<strong>语句块</strong>”总是没有返回值的呢？</p>
<p>答案是否。</p>
<p>ECMAScript 语言约定，在块中的多个语句顺序执行时，遵从两条规则：</p>
<ol>
<li>在向前覆盖既有的语句完成值时，<code>empty</code>值不覆盖任何值；</li>
<li>部分语句在没有有效返回值，且既有语句的返回值是<code>empty</code>时，默认用<code>undefined</code>覆盖之。</li>
</ol>
<p>规则 1 比较容易理解，表明一个语句块会尽量将块中最后有效的值返回出来。例如：</p>
<h1 id="run-in-nodejs">Run in NodeJS</h1>
<blockquote>
<p>eval(<code>{   1;   2;   ; // empty   x:break x; // empty   }</code>)<br>
2</p>
</blockquote>
<p>在这个例子中的后面两行语句都返回<code>empty</code>，因此不覆盖既有的值，所以整个语句块的执行结果是<code>2</code>。又例如：</p>
<h1 id="run-in-nodejs-1">Run in NodeJS</h1>
<blockquote>
<p>eval(<code>{   ; // empty   1;   ; // empty   }</code>)<br>
1</p>
</blockquote>
<p>在这个例子中第 1 行代码执行结果返回<code>empty</code>，于是第 2 行的结果值<code>1</code>覆盖了它；而第 3 行的结果值仍然是<code>empty</code>所以不导致覆盖，因此整个语句的返回值将是 1。</p>
<blockquote>
<p>NOTE: 参见 13.2.13 Block -&gt; RS: Evaluation, 以及 15.2.1.23 Module -&gt; RS: Evaluation 中，对 <strong>UpdateEmpty</strong>(s, sl) 的使用。</p>
</blockquote>
<p>而上述的规则 2，就比较复杂一些了。这出现在 if、do…while、while、for/for…in/for…of、with、switch 和 try 语句块中。在 ECMAScript 6 之后，这些语句约定不会返回 empty，因此它的执行结果“至少会返回一个 undefined 值”，而在此之前，它们的执行结果是不确定的，既可能返回 undefined 值，也可能返回 empty，并导致上一行语句值不覆盖。举例来说：</p>
<h1 id="run-in-nodejs-510-or-nodejs-4">Run in NodeJS 5.10+ (or NodeJS 4)</h1>
<blockquote>
<p>eval(<code>{   2;   if (true);   }</code>)<br>
undefined</p>
</blockquote>
<p>由于 ES6 约定<code>if</code>语句不返回<code>empty</code>，所以第 1 行返回的值<code>2</code>将被覆盖，最终显示为<code>undefined</code>。而在此之前（例如 NodeJS 4），它将返回值<code>2</code>;</p>
<blockquote>
<p>NOTE: 参考阅读《前端要给力之：语句在 JavaScript 中的值》。</p>
</blockquote>
<p>由此一来，ECMAScript 规范约定了 JavaScript 中所有语句的执行结果值的可能范围：<code>empty</code>，或一个既有的执行结果值（包括 undefined）。</p>
<h2 id="引用的值">引用的值</h2>
<p>现在还存在最后一个问题：所谓“引用”，算是什么值？</p>
<p>回顾第一讲的内容：表达式的本质是求值运算，而引用是不能直接作为最终求值的操作数的。因此引用实际上不能作为语句结果来返回，并且它在表达式计算中也仅是作为中间操作数（而非表达最终值的操作数）。所以在语句返回值的处理中，总是存在一个“执行表达式并‘取值’”的操作，以便确保不会有“引用”类型的数据作为语句的最终结果。而这，也就是在 ECMAScript 规中的<code>throw 1</code>语句的第二行代码的由来：</p>
<blockquote>
<p>2.<strong>Let</strong> exprValue be ? GetValue(exprRef).</p>
</blockquote>
<p>事实上在这里的符号“?opName()”语法也是一个简写，在 ECMAScript 中它表示一个 ReturnIfAbrupt(x) 的语义：如果设一个“处理（opName()）”的结果是 x，那么，</p>
<blockquote>
<p>如果 x 是特殊的（非 normal 类型的）完成记录，则返回 x；否则返回一个以 x.[[value]] 为值的、normal 类型的完成记录。</p>
</blockquote>
<p>简而言之，就是在 GetValue() 这个操作外面再封装一次异常处理。这往往是很有效的，例如：</p>
<p>throw 1/0;</p>
<p>那么 exprRef 作为表达式的计算结果，其本身就将是一个异常，于是<code>? GetValue(exprRef)</code>就可以返回这个异常对象（而不是异常的值）本身了。类似的，所谓“表达式语句”（这是排在“最简单语句榜”的第二名的语句）就直接返回这个值：</p>
<blockquote>
<p>ExpressionStatement:Expression;</p>
<p>1.<strong>Let</strong> exprRef be the result of evaluating Expression.</p>
<p>2.<strong>Return</strong> ? GetValue(exprRef).</p>
</blockquote>
<h2 id="还有一行代码">还有一行代码</h2>
<p>现在还有一行代码，也就是第一行的“<strong>let</strong>… result of evaluating …”。其中的“result of evaluating…”基本上算是 ECMAScript 中一个约定俗成的写法。不管是执行语句还是表达式，都是如此。这意味着引擎需要按之前我讲述过的那些执行逻辑来处理对应的代码块、表达式或值（操作数），然后将结果作为 Result 返回。</p>
<p>ECMAScript 所描述的引擎，能够理解“执行一行语句”与“执行一个表达式”的不同，并且由此决定它们返回的是一个“引用记录”还是“完成记录”（规范类型）。当外层的处理逻辑发现是一个引用时，会再根据当前逻辑的需要将“引用”理解为左操作数（取引用）或右操作数（取值）；否则当它是一个完成记录时，就尝试检测它的类型，也就是语句的完成状态（throw、return、normal 或其他）。</p>
<p>所以，throw 语句也好，return 语句也罢，所有的语句与它“外部的代码块（或<code>Parse Tree</code>中的父级结点）”间其实都是通过这个<strong>完成状态</strong>来通讯的。而外部代码块是否处理这个状态，则是由外部代码自己来决定的。</p>
<p>而几乎所有的外部代码块在执行一个语句（或表达式）时，都会采用上述的 ReturnIfAbrupt(x) 逻辑来封装，也就是说，如果是 normal，则继续处理；否则将该完成状态原样返回，交由外部的、其他的代码来处理。所以，就有了下面这样一些语法设计：</p>
<ol>
<li>循环语句用于处理非标签化的 continue 与 break，并处理为 normal；否则，</li>
<li>标签语句用于拦截那些“向外层返回”的 continue 和 break；且，如果能处理（例如是目标标签），则替换成 normal。</li>
<li>函数的内部过程<code>[[Call]]</code>，将检查“函数体执行”（将作为一个块语句执行）所返回状态是否是 return 类型，如果是，则替换成 normal。</li>
</ol>
<p>于是，显而易见的，所有语句行执行结果状态要么是 normal，要么就是还未被拦截的 throw 类型的语句完成状态。</p>
<p>try 语句用于处理那些漏网之鱼（throw 状态）：在 catch 块中替换成 normal，以表示 try 语句正常完成；或在 finally 中不做任何处理，以继续维持既有的完成状态，也就是 throw。</p>
<h2 id="值-1">值 1</h2>
<p>最后，本小节标题中的代码中只剩下了一个值<code>1</code>，在实际使用中，它既可以是一个其他表达式的执行结果，也可以是一个用户定义或创建的对象。无论如何，只要它是一个 JavaScript 可以处理的结果 Result（引用或值），那么它就可以通过内部运算<code>GetValue()</code>来得到一个真实数据，并放在一个 throw 类型的完成记录中，通过一层一层的<code>Parse Tree/Nodes</code>中的<code>ReturnIfAbrupt(x)</code>向上传递，直到有一个 try 块捕获它。例如：</p>
<p>try {<br>
throw 1;<br>
catch(e) {<br>
console.log(e);  // 1<br>
}</p>
<p>或者，它也可能溢出到代码的最顶层，成为根级<code>Parse Node</code>，也就是<code>Script</code>或<code>Module</code>类型的全局块的返回值。</p>
<p>这时，引擎或 Shell 程序就会得到它，于是……你的程序挂了。</p>
<h2 id="知识回顾">知识回顾</h2>
<p>在最近几讲，我讲的内容从语句执行到函数执行，从引用类型到完成类型，从循环到迭代，基本上已经完成了关于 JavaScript 执行过程的全部介绍。</p>
<p>当然，这些都是在串行环境中发生的事情，至于并行环境下的执行过程，在专栏的后续文章中我还会再讲给你。</p>
<p>作为一个概述，建议你回顾一下本专栏之前所讲的内容。包括（但不限于）：</p>
<ol>
<li>引用类型与值类型在 ECMAScript 和 JavaScript 中的不同含义；</li>
<li>基本逻辑（顺序、分支与循环）在语句执行和函数执行中的不同实现；</li>
<li>流程控制逻辑（中断、跳转和异步等）的实现方法，以及它们的要素，例如循环控制变量；</li>
<li>JavaScript 执行语句和函数的过程，引擎层面从装载到执行完整流程；</li>
<li>理解语法解析让物理代码到标记（Token）、标识符、语句、表达式等抽象元素的过程；</li>
<li>明确上述抽象元素的静态含义与动态含义之间的不同，明确语法元素与语义组件的实例化。</li>
</ol>
<p>综合来看，JavaScript 语言是面向程序员开发来使用的，是面子上的活儿，而 ECMAScript 既是规范也是实现，是藏在引擎底下的事情。ECMAScript 约定了一整套的框架、类型与体系化的术语，根本上就是为了严谨地叙述 JavaScript 的实现。并且，它提供了大量的语法或语义组件，用以规范和实现将来的 JavaScript。</p>
<p>直到现在，我向你的讲述的内容，在 ECMAScript 中大概也是十不过一。这些内容主要还是在刻画 ECMAScript 规范的梗概，以及它的核心逻辑。</p>
<p>从下一讲开始，我将向你正式地介绍 JavaScript 最重要的语言特性，也就是它的面向对象系统。</p>
<p>当然，一如本专栏之前的风格，我不会向你介绍类型 x.toString() 这样的、可以在手册上查阅的内容，我的本意，在于与你一起学习和分析：</p>
<p>JavaScript 是怎样的一门语言，以及它为什么是这样的一种语言。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">JavaScript核心原理解析</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/11__this%E4%BB%8Ejavascript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E8%A7%86%E8%A7%92%E8%AE%B2%E6%B8%85%E6%A5%9Athis/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">11__this：从JavaScript执行上下文的视角讲清楚this</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%B0%E4%BB%A3c&#43;&#43;%E5%AE%9E%E6%88%9830%E8%AE%B2/11__unicode%E8%BF%9B%E5%85%A5%E5%A4%9A%E6%96%87%E5%AD%97%E6%94%AF%E6%8C%81%E7%9A%84%E4%B8%96%E7%95%8C/">
            <span class="next-text nav-default">11__Unicode：进入多文字支持的世界</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
