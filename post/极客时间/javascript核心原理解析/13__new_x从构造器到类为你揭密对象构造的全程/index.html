<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>13__new_X：从构造器到类，为你揭密对象构造的全程 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是周爱民。
今天我只跟你聊一件事，就是 JavaScript 构造器。标题中的这行代码中规中矩，是我这个专栏题目列表中难得的正经代码。
NOTE：需要稍加说明的是：这行代码在 JavaScript 1.x 的某些版本或具体实现中是不能使用的。即使 ECMAScript ed1 开始就将它作为标准语法之一，当时也还有许多语言并不支持它。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/13__new_x%E4%BB%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%B0%E7%B1%BB%E4%B8%BA%E4%BD%A0%E6%8F%AD%E5%AF%86%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E7%9A%84%E5%85%A8%E7%A8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/13__new_x%E4%BB%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%B0%E7%B1%BB%E4%B8%BA%E4%BD%A0%E6%8F%AD%E5%AF%86%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E7%9A%84%E5%85%A8%E7%A8%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="13__new_X：从构造器到类，为你揭密对象构造的全程">
  <meta property="og:description" content="你好，我是周爱民。
今天我只跟你聊一件事，就是 JavaScript 构造器。标题中的这行代码中规中矩，是我这个专栏题目列表中难得的正经代码。
NOTE：需要稍加说明的是：这行代码在 JavaScript 1.x 的某些版本或具体实现中是不能使用的。即使 ECMAScript ed1 开始就将它作为标准语法之一，当时也还有许多语言并不支持它。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="JavaScript核心原理解析">

  <meta itemprop="name" content="13__new_X：从构造器到类，为你揭密对象构造的全程">
  <meta itemprop="description" content="你好，我是周爱民。
今天我只跟你聊一件事，就是 JavaScript 构造器。标题中的这行代码中规中矩，是我这个专栏题目列表中难得的正经代码。
NOTE：需要稍加说明的是：这行代码在 JavaScript 1.x 的某些版本或具体实现中是不能使用的。即使 ECMAScript ed1 开始就将它作为标准语法之一，当时也还有许多语言并不支持它。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5647">
  <meta itemprop="keywords" content="JavaScript核心原理解析">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="13__new_X：从构造器到类，为你揭密对象构造的全程">
  <meta name="twitter:description" content="你好，我是周爱民。
今天我只跟你聊一件事，就是 JavaScript 构造器。标题中的这行代码中规中矩，是我这个专栏题目列表中难得的正经代码。
NOTE：需要稍加说明的是：这行代码在 JavaScript 1.x 的某些版本或具体实现中是不能使用的。即使 ECMAScript ed1 开始就将它作为标准语法之一，当时也还有许多语言并不支持它。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">13__new_X：从构造器到类，为你揭密对象构造的全程</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5647 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#基于对象的-javascript">基于对象的 JavaScript</a></li>
        <li><a href="#类与构造器">类与构造器</a></li>
      </ul>
    </li>
    <li><a href="#x是-device-的子类实例吗"><code>x</code>是 <code>Device()</code> 的子类实例吗？</a>
      <ul>
        <li><a href="#ecmascript-6-之后的类">ECMAScript 6 之后的类</a></li>
      </ul>
    </li>
    <li><a href="#声明一个带有方法的对象字面量">声明一个带有方法的对象字面量</a></li>
    <li><a href="#对方法使用-new-运算会导致异常">对方法使用 new 运算会导致异常</a>
      <ul>
        <li><a href="#创建this的顺序问题">创建<code>this</code>的顺序问题</a></li>
        <li><a href="#用户返回-new-的结果">用户返回 new 的结果</a></li>
        <li><a href="#注es3-之前将抛出异常">(注：ES3 之前将抛出异常）</a></li>
        <li><a href="#非派生类的构造方法返回无效值">非派生类的构造方法返回无效值</a></li>
        <li><a href="#派生类的构造方法返回无效值">派生类的构造方法返回无效值</a></li>
        <li><a href="#知识回顾">知识回顾</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是周爱民。</p>
<p>今天我只跟你聊一件事，就是 JavaScript 构造器。标题中的这行代码中规中矩，是我这个专栏题目列表中难得的正经代码。</p>
<blockquote>
<p>NOTE：需要稍加说明的是：这行代码在 JavaScript 1.x 的某些版本或具体实现中是不能使用的。即使 ECMAScript ed1 开始就将它作为标准语法之一，当时也还有许多语言并不支持它。</p>
</blockquote>
<p><strong>构造器</strong>这个东西，是 JavaScript 中面向对象系统的核心概念之一。跟“属性”相比，如果属性是静态的结构，那么“构造器”就是动态的逻辑。</p>
<p>没有构造器的 JavaScript，就是一个充填了无数数据的、静态的对象空间。这些对象之间既没有关联，也不能衍生，更不可能发生交互。然而，这却真的就是 JavaScript 1.0 那个时代的所谓“面向对象系统”的基本面貌。</p>
<h2 id="基于对象的-javascript">基于对象的 JavaScript</h2>
<p>为什么呢？因为 JavaScript1.0 的时代，也就是最早最早的 JavaScript 其实是没有继承的。</p>
<p>你可能会说，既然是没有继承的，那么 JavaScript 为什么一开始就能声称自己是“面向对象”的、“类似 Java”的一门语言呢？其实这个讲法是前半句对，后半句不对。JavaScript 和 Java 名字相似，但语言特性却大是不同，这就跟北京的“海淀五路居”和“五路居”一样，差了得有 20 公里。</p>
<p>那前半句为什么是对的呢？JavaScript 1.0 连继承都没有，为什么又能称为面向对象的语言呢？</p>
<p>其实从我在前两讲中讲过的内容来看，JavaScript 1.0 确实已经可以将函数作为构造器，并且在函数中向它的实例（也就是<code>this</code>对象）抄写类声明的那些属性。在早期的面向对象理论里面，就已经可以称这个函数为<strong>类</strong>，而这个被创建出来的实例为<strong>对象</strong>了。</p>
<p>所以，有了类、对象，以及一个约定的构造过程，有了这三个东西，JavaScript 就声称了自己是一门“面向对象”的语言，并且还是一门“有类语言”。</p>
<p>所以 JavaScript 从 1.0 开始就有类，在这个类（也就是构造器）中采用的是所谓“类抄写”的方案，将类所拥有的属性声明一项一项地抄写到对象上面，而这个对象，就是我们现在大家都知道的 this 引用。</p>
<p>这样一来，一段声明类和构造对象的代码，大概写出来就是下面这个样子：</p>
<p>function Car() {<br>
this.name = &ldquo;Car&rdquo;;<br>
this.color = &ldquo;Red&rdquo;;<br>
}</p>
<p>var x = new Car();<br>
&hellip;</p>
<h2 id="类与构造器">类与构造器</h2>
<p>由于在这样的构造过程中，this 是作为 new 运算所构造出来的那个实例来使用的，因此 JavaScript 1.0 约定全局环境中不能使用 this 的。因为全局环境与 new 运算无关，全局环境中也并不存在一个被 new 创建出来的实例。</p>
<p>然而随着<code>JavaScript 1.1</code>的到来，JavaScript 支持“原型继承”了，于是“类抄写”成为了一个过时的方案。对于继承性来说，它显得无用；对于一个具体的实例来说，它又具有“类‘说明了’实例的结构”这样的语义。</p>
<p>因此，从“<strong>原型继承</strong>”在 JavaScript 中出现的第一天开始，“类继承 VS 原型继承”之间就存在不可调和的矛盾。在<code>JavaScript 1.1</code>中，类抄写是可以与原型继承混合使用的：</p>
<p>function Device() {<br>
this.id = 0; // or increment<br>
}</p>
<p>function Car() {<br>
this.name = &ldquo;Car&rdquo;;<br>
this.color = &ldquo;Red&rdquo;;<br>
}</p>
<p>Car.prototype = new Device();</p>
<p>var x = new Car();<br>
console.log(x.id); //</p>
<p>在这个例子中所创建出来的对象<code>x</code>是“Car()”的一个实例，但是在面向对象编程（OOP）中，<code>x</code>既是<code>Car()</code>的子类实例，也是“Device()”的子类实例，这是 OOP 的继承性所约定的基本概念。这正是这门语言很有趣的地方：**一方面使用了类继承的基础结构和概念，另一方面又要实现原型继承和基于原型链检查的逻辑。**例如：</p>
<h1 id="x是-device-的子类实例吗"><code>x</code>是 <code>Device()</code> 的子类实例吗？</h1>
<blockquote>
<p>x instanceof Device<br>
true</p>
</blockquote>
<p>这里的<code>instanceof</code>运算被实现为一个<strong>动态地访问原型链</strong>的过程：它将从<code>Car.prototype</code>属性逆向地在原型链中查到你指定的——“原型”。</p>
<p>首先，JavaScript 从对象<code>x</code>的内部结构中取得它的原型。这个原型的存在，与<code>new</code>运算是直接相关的——在早期的 JavaScript 中，有且仅有<code>new</code>运算会向对象内部写“原型”这个属性（称为&quot;[[Prototype]]&ldquo;内部槽）。由于 new 运算是依据它运算时所使用的构造器来填写这个属性的，所以这意味着如下的效果：</p>
<p>// x = new Car()<br>
x.[[Prototype]] === Car.prototype</p>
<p>在<code>instanceof</code>运算中，<code>x instanceof AClass</code>表达式的右侧是一个类名（对于之前的例子来说，它指向构造器 Car），但实际上 JavaScript 是使用<code>AClass.prototype</code>来做比对，对于“Car() 构造器”来说，就是“Car.prototype”。但是，如果上一个例子需要检查的是<code>x instanceof Device</code>，也就是“Device.prototype”，那么这二者显然是不等值的。</p>
<p>所以，<code>instanceof</code>运算会再次取“x.[[Prototype] [[Prototype]]”这个内部原型，也就是顺着原型链向上查找：</p>
<p>// 因为<br>
x.[[Prototype]] === Car.prototype<br>
// 且<br>
Car.prototype = new Device()</p>
<p>// 所以<br>
x.[[Prototype]].[[Prototype]] === Device.prototype</p>
<p>现在，由于在<code>x</code>的原型链上发现了“x instanceof Device”运算右侧的“Device.prototype”，所以这个表达式将返回 True 值，表明：</p>
<p>对象<code>x</code>是<code>Device()</code>或其子类的一个实例。</p>
<p>现在，对于大多数 JavaScript 程序员来说，上述过程应该都不是秘密，也并不是特别难解的核心技术。但是在它的实现过程中所带有的语言设计方面的这些历史痕迹，却不是那么容易一望即知的了。</p>
<h2 id="ecmascript-6-之后的类">ECMAScript 6 之后的类</h2>
<p>在 ECMAScript 6 之前，JavaScript 中的<strong>函数</strong>、<strong>类</strong>和<strong>构造器</strong>这三个概念是混用的。一般来说，它们都被统一为“<strong>函数 Car()</strong>”这个基础概念，而当它用作“x = new Car()”这样的运算，或从<code>x.constructor</code>这样的属性中读取时，它被理解为<strong>构造器</strong>；当它用作“x instanceof Car”这样的运算，或者讨论 OOP 的继承关系时，它被理解为<strong>类</strong>。</p>
<p>习惯上，如果程序要显式地、字面风格地说明一个函数是构造器、或者用作构造过程，那么它的函数名应该首字母大写。同时，如果一个函数要被明确声明为“静态类（也就不需要创建实例的类，例如 Math）”，那么它的函数名也应该首字母大写。</p>
<blockquote>
<p>NOTE: 仅从函数名的大小写来判断，只是惯例。没有任何方法来确认一个函数是不是“被设计为”构造器，或者静态类，又或者“事实上”是不是二者之一。</p>
</blockquote>
<p>从 ECMAScript 6 开始，JavaScript 有了使用<code>class</code>来声明“类”的语法。例如：</p>
<p>class AClass {<br>
&hellip;<br>
}</p>
<p>自此之后，JavaScript 的“类”与“函数”有了明确的区别：**类只能用 new 运算来创建，而不能使用“()”来做函数调用。**例如：</p>
<blockquote>
<p>new AClass()<br>
AClass {}</p>
</blockquote>
<blockquote>
<p>AClass()<br>
TypeError: Class constructor AClass cannot be invoked without &rsquo;new'</p>
</blockquote>
<p>在 ECMAScript 6 之后，JavaScript 内部是明确区分方法与函数的：不能对方法做 new 运算。例如：</p>
<h1 id="声明一个带有方法的对象字面量">声明一个带有方法的对象字面量</h1>
<blockquote>
<p>obj = { foo() {} }<br>
{ foo: [Function: foo] }</p>
</blockquote>
<h1 id="对方法使用-new-运算会导致异常">对方法使用 new 运算会导致异常</h1>
<blockquote>
<p>new obj.foo()<br>
TypeError: obj.foo is not a constructor</p>
</blockquote>
<p>注意这个异常中又出现了关键字“constructor”。这让我们的讨论又一次回到了开始的话题：<strong>什么是构造器？</strong></p>
<p>在 ECMAScript 6 之后，函数可以简单地分为三个大类：</p>
<ol>
<li>类：只可以做 new 运算；</li>
<li>方法：只可以做调用“( )”运算；</li>
<li>一般函数：（除部分函数有特殊限制外，）同时可以做 new 和调用运算。</li>
</ol>
<p>其中，典型的“方法”在内部声明时，有三个主要特征：</p>
<ol>
<li>具有一个名为“主对象<code>[[HomeObject]]</code>”的内部槽；</li>
<li>没有名为“构造器<code>[[Construct]]</code>”的内部槽；</li>
<li>没有名为“<code>prototype</code>”的属性。</li>
</ol>
<p>后两种特征（没有<code>[[Construct]]</code>内部槽和<code>prototype</code>属性）完全排除了一个普通方法用作构造器的可能。对照来看，所谓“类”其实也是作为方法来创建的，但它有独立的构造过程和原型属性。</p>
<p>函数的“.prototype”的属性描述符中的设置比较特殊，它不能删除，但可以修改（‘writable’is true）。当这个值被修改成 null 值时，它的子类对象是以 null 值为原型的；当它被修改成非对象值时，它的子类对象是以 Object.prototype 为原型的；否则，当它是一个对象类型的值时，它的子类才会使用该对象作为原型来创建实例。</p>
<p>运算符“new”总是依照这一规则来创建对象实例<code>this</code>。</p>
<p>不过，对于“类”和一般的“构造器（函数）”，这个创建过程会略有不同。</p>
<h2 id="创建this的顺序问题">创建<code>this</code>的顺序问题</h2>
<p>如前所述，如果对 ECMAScript 6 之前的构造器函数（例如<code>f</code>）使用<code>new</code>运算，那么这个 new 运算会使用<code>f.prototype</code>作为原型来创建一个<code>this</code>对象，然后才是调用<code>f()</code>函数，并将这个函数的执行过程理解为“类抄写（向用户实例抄写类所声明的属性）”。从用户代码的视角上来看，这个新对象就是由当前<code>new</code>运算所操作的那个函数<code>f()</code>创建的。</p>
<p>这在语义上非常简洁明了：由于<code>f()</code>是 this 的类，因此<code>f.prototype</code>决定了 this 的原型，而<code>f()</code>执行过程决定了初始化 this 实例的方式。但是它带了一个问题：从 JavaScript 1.1 开始至今都困扰 JavaScript 程序员的问题：</p>
<p>无法创建一个有特殊性质的对象，也无法声明一个具有这类特殊性质的类。</p>
<p>这是什么意思呢？比如说，所有的函数有一个公共的父类 / 祖先类，称为<code>Function()</code>。所以你可以用<code>new Function()</code>来创建一个普通函数，这个普通函数也是可以调用的，例如：</p>
<blockquote>
<p>f = new Function;</p>
</blockquote>
<blockquote>
<p>f instanceof Function<br>
true</p>
</blockquote>
<blockquote>
<p>f()<br>
undefine</p>
</blockquote>
<p>你也确实可以用传统方法写一个<code>Function()</code>的子类，但这样的子类创建的实例就不能调用。例如：</p>
<blockquote>
<p>MyFunction = function() {};</p>
</blockquote>
<blockquote>
<p>MyFunction.prototype = new Function;</p>
</blockquote>
<blockquote>
<p>f = new MyFunction;</p>
</blockquote>
<blockquote>
<p>[f instanceof MyFunction, f instanceof Functcion]<br>
[ true, true ]</p>
</blockquote>
<blockquote>
<p>f()<br>
TypeError: f is not a funct</p>
</blockquote>
<p>至于原因，你可能也已经知道了：JavaScript 所谓的函数，其实是“一个有<code>[[Call]]</code>内部槽的对象”。而<code>Function()</code>作为 JavaScript 原生的函数构造器，它能够在创建的对象（例如<code>this</code>）中添加这个内部槽，而当使用上面的继承逻辑时，用户代码（例如<code>MyFunction()</code>）就只是创建了一个普通的对象，因为用户代码没有能力操作 JavaScript 引擎层面才支持的那些“内部槽”。</p>
<p>所以，有一些“类 / 构造器”在 ECMAScript 6 之前是不能派生子类的，例如 Function，又例如 Date。</p>
<p>而到了 ECMAScript 6，它的“类声明”采用了不同的构造逻辑。ECMAScript 6 要求所有子类的构造过程都不得创建这个<code>this</code>实例，并主动的把这个创建的权力“交还”给父类、乃至祖先类。这也就是 ECMAScript 6 中类的两个著名特性的由来，即，如果类声明中通过 extends 指定了父类，那么：</p>
<ol>
<li>必须在构造器方法（constructor）中显式地使用<code>super()</code>来调用父类的构造过程；</li>
<li>在上述调用结束之前，是不能使用<code>this</code>引用的。</li>
</ol>
<p>显然，真实的<code>this</code>创建就通过层层的<code>super()</code>交给了父类或祖先类中支持创建这个实例的构造过程。这样一来，子类中也能得到一个“拥有父类所创建的带有内部槽的”实例，因此上述的<code>Function()</code>和<code>Date()</code>等等的子类也就可以实现了。例如：</p>
<blockquote>
<p>class MyFunction extends Function { }</p>
</blockquote>
<blockquote>
<p>f = new MyFunction;</p>
</blockquote>
<blockquote>
<p>f()<br>
undefine</p>
</blockquote>
<p>在上面个例子中，<code>MyFunction()</code>的类声明中缺省了“constructor()”构造方法。这种情况下 JavaScript 会为它自动创建一个，并且其内部也仅有一个“super()”代码。关于这些过程的细节，我将留待下一讲再具体地与你解析。在这里，你最应该关注的是这个过程带来的必然结果：</p>
<p>ECMAScript 6 的类是由父类或祖先类创建<code>this</code>实例的。</p>
<p>不过仍然有一点是需要补充的：如果类声明<code>class</code>中不带有<code>extends</code>子句，那么它所创建出来的类与传统 JavaScript 的函数 / 构造器是一样的，也就是由自己来创建<code>this</code>对象。很显然，这是因为它无法找到一个显式指示的父类。不过关于这种情况，仍然隐藏了许多实现细节，我将会在下一讲中与你一起来学习它。</p>
<h2 id="用户返回-new-的结果">用户返回 new 的结果</h2>
<p>在 JavaScript 中关于 new 运算与构造函数的最后一个有趣的设计，就是<strong>用户代码可以干涉 new 运算的结果值</strong>。默认情况下，这个结果就是上述过程所创建出来的<code>this</code>对象实例，但是用户可以通过在构造器函数 / 方法中使用<code>return</code>语句来显式地重置它。</p>
<p>这也是从 JavaScript 1.0 就开始具有的特性。因为 JavaScript 1.x 中的函数、类与构造器是混用的，所以用户代码在函数中“返回些什么东西”是正常的语法，也是正常的逻辑需求。但是 JavaScript 要求在构造器中返回的数据必须是一个对象，否则就将抛出一个运行期的异常。</p>
<p>从 ECMAScript ed3 开始，检测构造器返回值的逻辑从<code>new</code>运算符中移到了<code>[[Construct]]</code>的处理过程中，并且重新约定：当构造器返回无效值（非对象值或 null）时，使用原有已经创建的<code>this</code>对象作为构造过程<code>[[Constuct]]</code>的返回值。</p>
<p>因此到了 ECMAScript 6 之后，那些一般函数，以及非派生类，就延续了这一约定：<strong>使用已经创建的</strong><code>this</code><strong>对象来替代返回的无效值</strong>。这意味着它们总是能返回一个对象，要么是 new 运算按规则创建的 this，要么是用户代码返回的对象。</p>
<blockquote>
<p>NOTE: 关于为什么非派生类也支持这一约定的问题，我后续的课程中会再次讲到。基本上来说，你可以认为这是为了让它与一般构造器保持足够的“相似性”。</p>
</blockquote>
<p>然而严格来说，引擎是不能理解“为什么用户代码会在构造器中返回一个一般的值类型数据”的。因为对于类的预期是返回一个对象，返回这种“无效值”是与预期矛盾的。因此，对于那些派生的子类（即声明中使用了<code>extends</code>子句的类），ECMAScript 要求严格遵循“不得在构造器中返回非对象值（以及 null 值）”的设计约定，并在这种情况下直接抛出异常。例如：</p>
<h2 id="注es3-之前将抛出异常">(注：ES3 之前将抛出异常）</h2>
<blockquote>
<p>new (function() {return 1});<br>
{}</p>
</blockquote>
<h2 id="非派生类的构造方法返回无效值">非派生类的构造方法返回无效值</h2>
<blockquote>
<p>new (class { constructor() { return 1 } })<br>
{}</p>
</blockquote>
<h2 id="派生类的构造方法返回无效值">派生类的构造方法返回无效值</h2>
<blockquote>
<p>new (class extends Object { constructor() { return 1 } })<br>
TypeError: Derived constructors may only return object or undefine</p>
</blockquote>
<h2 id="知识回顾">知识回顾</h2>
<p>今天这一讲的一些知识点，是与你学习后续的专栏内容有关的。包括：</p>
<ol>
<li>在使用类声明来创建对象时，对象是由父类或祖先类创建的实例，并使用<code>this</code>引用传递到当前（子级的）类的。</li>
<li>在类的构造方法和一般构造器（函数）中返回值，是可以影响 new 运算的结果的，但 JavaScript 确保 new 运算不会得到一个非对象值。</li>
<li>类或构造器（函数）的首字母大写是一种惯例，而不是语言规范层面的约束。</li>
<li>类继承过程也依赖内部构造过程（<code>[[Contruct]]</code>）和原型属性（prototype），并且类继承实际上是原型继承的应用与扩展，不同于早期 JavaScript1.0 使用的类抄写。</li>
</ol>
<p>无论如何，从 JavaScript 1.0 开始的“类抄写”这一特性依然是可用的。无论是在普通函数、类还是构造器中，都可以向<code>this</code>引用上抄写属性，但这个过程变得与“如何实现继承性”完全无关。这里的<code>this</code>可以是函数调用时传入的，而不再仅仅来自于 new 运算的内置的构造过程创建。</p>
<h2 id="思考题">思考题</h2>
<ol>
<li>除使用 new X 运算，还有什么方法可以创建新的对象？</li>
<li>在 ECMAScript 6 之后，除了 new X 之外，还有哪些方法可以操作原型 / 原型链？</li>
</ol>
<p>这些问题既是对本小节内容的回顾，也是下一阶段的课程中会用到的一些基础知识。建议你好好的寻求一下答案。</p>
<p>最后，希望你喜欢我的分享，也欢迎你把文章分享给你的朋友。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/javascript%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">JavaScript核心原理解析</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98%E8%AF%BE/13__mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8C%E6%AD%A5%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">13__MySQL主从数据库同步是如何实现的？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%BB%84%E5%8B%87%E7%9A%84okr%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/13__okr%E5%A4%A7%E5%92%96%E8%AF%B4%E4%BB%8Ekpi%E5%88%B0okr%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/">
            <span class="next-text nav-default">13__OKR大咖说：从KPI到OKR的实践之路</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
