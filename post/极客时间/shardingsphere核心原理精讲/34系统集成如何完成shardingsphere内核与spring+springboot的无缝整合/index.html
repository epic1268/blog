<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>34系统集成：如何完成ShardingSphere内核与Spring&#43;SpringBoot的无缝整合？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="今天，我们将进入整个课程中最后一个模块——系统集成模块的介绍。这里所谓的系统集成，指的就是 ShardingSphere 和 Spring 框架的集成。
到目前为止，ShardingSphere 实现了两种系统集成机制：一种是命名空间（namespace）机制，即通过扩展 Spring Schema 来实现与 Spring 框架的集成；而另一种则是通过编写自定义的 starter 组件来完成与 Spring Boot 的集成。本课时我将分别讲解这两种系统集成机制。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/shardingsphere%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%B2%BE%E8%AE%B2/34%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90shardingsphere%E5%86%85%E6%A0%B8%E4%B8%8Espring&#43;springboot%E7%9A%84%E6%97%A0%E7%BC%9D%E6%95%B4%E5%90%88/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/shardingsphere%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%B2%BE%E8%AE%B2/34%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90shardingsphere%E5%86%85%E6%A0%B8%E4%B8%8Espring&#43;springboot%E7%9A%84%E6%97%A0%E7%BC%9D%E6%95%B4%E5%90%88/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="34系统集成：如何完成ShardingSphere内核与Spring&#43;SpringBoot的无缝整合？">
  <meta property="og:description" content="今天，我们将进入整个课程中最后一个模块——系统集成模块的介绍。这里所谓的系统集成，指的就是 ShardingSphere 和 Spring 框架的集成。
到目前为止，ShardingSphere 实现了两种系统集成机制：一种是命名空间（namespace）机制，即通过扩展 Spring Schema 来实现与 Spring 框架的集成；而另一种则是通过编写自定义的 starter 组件来完成与 Spring Boot 的集成。本课时我将分别讲解这两种系统集成机制。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="ShardingSphere核心原理精讲">

  <meta itemprop="name" content="34系统集成：如何完成ShardingSphere内核与Spring&#43;SpringBoot的无缝整合？">
  <meta itemprop="description" content="今天，我们将进入整个课程中最后一个模块——系统集成模块的介绍。这里所谓的系统集成，指的就是 ShardingSphere 和 Spring 框架的集成。
到目前为止，ShardingSphere 实现了两种系统集成机制：一种是命名空间（namespace）机制，即通过扩展 Spring Schema 来实现与 Spring 框架的集成；而另一种则是通过编写自定义的 starter 组件来完成与 Spring Boot 的集成。本课时我将分别讲解这两种系统集成机制。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4866">
  <meta itemprop="keywords" content="ShardingSphere核心原理精讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="34系统集成：如何完成ShardingSphere内核与Spring&#43;SpringBoot的无缝整合？">
  <meta name="twitter:description" content="今天，我们将进入整个课程中最后一个模块——系统集成模块的介绍。这里所谓的系统集成，指的就是 ShardingSphere 和 Spring 框架的集成。
到目前为止，ShardingSphere 实现了两种系统集成机制：一种是命名空间（namespace）机制，即通过扩展 Spring Schema 来实现与 Spring 框架的集成；而另一种则是通过编写自定义的 starter 组件来完成与 Spring Boot 的集成。本课时我将分别讲解这两种系统集成机制。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">34系统集成：如何完成ShardingSphere内核与Spring&#43;SpringBoot的无缝整合？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4866 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>今天，我们将进入整个课程中最后一个模块——系统集成模块的介绍。这里所谓的系统集成，指的就是 ShardingSphere 和 Spring 框架的集成。</p>
<p>到目前为止，ShardingSphere 实现了两种系统集成机制：一种是命名空间（namespace）机制，即通过扩展 Spring Schema 来实现与 Spring 框架的集成；而另一种则是通过编写自定义的 starter 组件来完成与 Spring Boot 的集成。本课时我将分别讲解这两种系统集成机制。</p>
<p>基于系统集成模块，无论开发人员采用哪一种 Spring 框架，对于使用 ShardingSphere 而言都是零学习成本。</p>
<p>基于命名空间集成 Spring</p>
<p>从扩展性的角度讲，基于 XML Schema 的扩展机制也是非常常见和实用的一种方法。在 Spring 中，允许我们自己定义 XML 的结构，并且可以用自己的 Bean 解析器进行解析。通过对 Spring Schema 的扩展，ShardingSphere 可以完成与 Spring 框架的有效集成。</p>
<p>1.基于命名空间集成 Spring 的通用开发流程</p>
<p>基于命名空间机制实现与 Spring 的整合，开发上通常采用的是固定的一个流程，包括如下所示的五大步骤：</p>
<p>这些步骤包括：编写业务对象、编写 XSD 文件、编写 BeanDefinitionParser 实现类、编写 NamespaceHandler 实现类，以及编写 spring.handlers 和 spring.schemas 配置文件，我们来看看 ShardingSphere 中实现这些步骤的具体做法。</p>
<p>2.ShardingSphere 集成 Spring</p>
<p>ShardingSphere 中存在两个以“spring-namespace”结尾的代码工程，即 sharding-jdbc-spring-namespace 和 sharding-jdbc-orchestration-spring-namespace，显然后者关注的是编排治理相关功能的集成，相对比较简单。再因为命名空间机制的实现过程也基本一致，因此，我们以 sharding-jdbc-spring-namespace 工程为例展开讨论。</p>
<p>而在 sharding-jdbc-spring-namespace 工程中，又包含了对普通分片、读写分离和数据脱敏这三块核心功能的集成内容，它们的实现也都是采用了类似的方式，因此我们也不会重复进行说明，这里就以普通分片为例进行介绍。</p>
<p>首先，我们发现了一个专门用于与 Spring 进行集成的 SpringShardingDataSource 类，这个类就是业务对象类，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="k">class</span> <span class="n">SpringShardingDataSource</span> <span class="k">extends</span> <span class="n">ShardingDataSource</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="n">SpringShardingDataSource</span><span class="p">(</span><span class="n">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="ne">String</span><span class="p">,</span> <span class="n">DataSource</span><span class="o">&gt;</span> <span class="n">dataSourceMap</span><span class="p">,</span> <span class="n">final</span> <span class="n">ShardingRuleConfiguration</span> <span class="n">shardingRuleConfiguration</span><span class="p">,</span> <span class="n">final</span> <span class="n">Properties</span> <span class="n">props</span><span class="p">)</span> <span class="n">throws</span> <span class="n">SQLException</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">super</span><span class="p">(</span><span class="n">dataSourceMap</span><span class="p">,</span> <span class="n">new</span> <span class="n">ShardingRule</span><span class="p">(</span><span class="n">shardingRuleConfiguration</span><span class="p">,</span> <span class="n">dataSourceMap</span><span class="o">.</span><span class="n">keySet</span><span class="p">()),</span> <span class="n">props</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到这个 SpringShardingDataSource 类实际上只是对 ShardingDataSource 的一种简单封装，没有包含任何实际操作。</p>
<p>然后，我们来看配置项标签的定义类，这种类是一种简单的工具类，其作用就是定义标签的名称。在命名上，ShardingSphere 中的这些类都以“BeanDefinitionParserTag”结尾，例如如下所示的 ShardingDataSourceBeanDefinitionParserTag：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final class ShardingDataSourceBeanDefinitionParserTag {
</span></span><span class="line"><span class="cl">    public static final String ROOT_TAG = &#34;data-source&#34;;
</span></span><span class="line"><span class="cl">    public static final String SHARDING_RULE_CONFIG_TAG = sharding-rule&#34;;
</span></span><span class="line"><span class="cl">    public static final String PROPS_TAG = &#34;props&#34;;
</span></span><span class="line"><span class="cl">	public static final String DATA_SOURCE_NAMES_TAG = &#34;data-source-names&#34;;
</span></span><span class="line"><span class="cl">	public static final String DEFAULT_DATA_SOURCE_NAME_TAG = &#34;default-data-source-name&#34;;
</span></span><span class="line"><span class="cl">    public static final String TABLE_RULES_TAG = &#34;table-rules&#34;; 
</span></span><span class="line"><span class="cl">    …
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里定义了一批 Tag 和一批 Attribute，我们不做 一 一 展开。可以对照如下所示的基于 XML 的配置示例来对这些定义的配置项进行理解：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&lt;sharding:data-source id=&#34;shardingDataSource&#34;&gt;
</span></span><span class="line"><span class="cl">        &lt;sharding:sharding-rule data-source-names=&#34;ds0,ds1&#34;&gt;
</span></span><span class="line"><span class="cl">            &lt;sharding:table-rules&gt;
</span></span><span class="line"><span class="cl">                &lt;sharding:table-rule …/&gt;
</span></span><span class="line"><span class="cl">	            &lt;sharding:table-rule …/&gt;
</span></span><span class="line"><span class="cl">	            …
</span></span><span class="line"><span class="cl">            &lt;/sharding:table-rules&gt;
</span></span><span class="line"><span class="cl">            …
</span></span><span class="line"><span class="cl">        &lt;/sharding:sharding-rule&gt;
</span></span><span class="line"><span class="cl">&lt;/sharding:data-source&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，我们在 sharding-jdbc-spring-namespace 代码工程的 META-INF/namespace 文件夹下找到了对应的 sharding.xsd 文件，其基本结构如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&lt;xsd:schema xmlns=&#34;http://shardingsphere.apache.org/schema/shardingsphere/sharding&#34;
</span></span><span class="line"><span class="cl">            xmlns:xsd=&#34;http://www.w3.org/2001/XMLSchema&#34;
</span></span><span class="line"><span class="cl">            xmlns:beans=&#34;http://www.springframework.org/schema/beans&#34;
</span></span><span class="line"><span class="cl">            xmlns:encrypt=&#34;http://shardingsphere.apache.org/schema/shardingsphere/encrypt&#34;
</span></span><span class="line"><span class="cl">            targetNamespace=&#34;http://shardingsphere.apache.org/schema/shardingsphere/sharding&#34;
</span></span><span class="line"><span class="cl">            elementFormDefault=&#34;qualified&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
</span></span><span class="line"><span class="cl">            xsi:schemaLocation=&#34;http://shardingsphere.apache.org/schema/shardingsphere/encrypt http://shardingsphere.apache.org/schema/shardingsphere/encrypt/encrypt.xsd&#34;&gt;
</span></span><span class="line"><span class="cl">    &lt;xsd:import namespace=&#34;http://www.springframework.org/schema/beans&#34; schemaLocation=&#34;http://www.springframework.org/schema/beans/spring-beans.xsd&#34; /&gt;
</span></span><span class="line"><span class="cl">    &lt;xsd:import namespace=&#34;http://shardingsphere.apache.org/schema/shardingsphere/encrypt&#34; schemaLocation=&#34;http://shardingsphere.apache.org/schema/shardingsphere/encrypt/encrypt.xsd&#34;/&gt;
</span></span><span class="line"><span class="cl">    &lt;xsd:element name=&#34;data-source&#34;&gt;
</span></span><span class="line"><span class="cl">        &lt;xsd:complexType&gt;
</span></span><span class="line"><span class="cl">            &lt;xsd:all&gt;
</span></span><span class="line"><span class="cl">                &lt;xsd:element ref=&#34;sharding-rule&#34; /&gt;
</span></span><span class="line"><span class="cl">                &lt;xsd:element ref=&#34;props&#34; minOccurs=&#34;0&#34; /&gt;
</span></span><span class="line"><span class="cl">            &lt;/xsd:all&gt;
</span></span><span class="line"><span class="cl">            &lt;xsd:attribute name=&#34;id&#34; type=&#34;xsd:string&#34; use=&#34;required&#34; /&gt;
</span></span><span class="line"><span class="cl">        &lt;/xsd:complexType&gt;
</span></span><span class="line"><span class="cl">	&lt;/xsd:element&gt;
</span></span><span class="line"><span class="cl">	…
</span></span><span class="line"><span class="cl">&lt;/xsd:schema&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到对于“data-source”这个 element 而言，包含了“sharding-rule”和“props”这两个子 element，其中“props”不是必需的。同时，“data-source”还可以包含一个“id”属性，而这个属性则是必填的，我们在前面的配置示例中已经看到了这一点。而对于“sharding-rule”而言，则可以有很多内嵌的属性，sharding.xsd 文件中对这些属性都做了定义。</p>
<p>同时，我们应该注意到的是，sharding.xsd 中通过使用 xsd:import 标签还引入了两个 namespace，一个是 Spring 中的http://www.springframework.org/schema/beans，另一个则是 ShardingSphere 自身的http://shardingsphere.apache.org/schema/shardingsphere/encrypt，这个命名空间的定义位于与 sharding.xsd 同目录下的 encrypt.xsd文件中。</p>
<p>有了业务对象类，以及 XSD 文件的定义，接下来我们就来看看 NamespaceHandler 实现类 ShardingNamespaceHandler，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="n">final</span> <span class="k">class</span> <span class="n">ShardingNamespaceHandler</span> <span class="k">extends</span> <span class="n">NamespaceHandlerSupport</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="err">@</span><span class="n">Override</span>
</span></span><span class="line"><span class="cl">	<span class="n">public</span> <span class="n">void</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="n">registerBeanDefinitionParser</span><span class="p">(</span><span class="n">ShardingDataSourceBeanDefinitionParserTag</span><span class="o">.</span><span class="n">ROOT_TAG</span><span class="p">,</span> <span class="n">new</span> <span class="n">ShardingDataSourceBeanDefinitionParser</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">	<span class="n">registerBeanDefinitionParser</span><span class="p">(</span><span class="n">ShardingStrategyBeanDefinitionParserTag</span><span class="o">.</span><span class="n">STANDARD_STRATEGY_ROOT_TAG</span><span class="p">,</span> <span class="n">new</span> <span class="n">ShardingStrategyBeanDefinitionParser</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">	<span class="err">…</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到这里也是直接使用了 registerBeanDefinitionParser 方法来完成标签项与具体的 BeanDefinitionParser 类之间的对应关系。我们来看这里的 ShardingDataSourceBeanDefinitionParser，其核心的 parseInternal 方法如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@Override
</span></span><span class="line"><span class="cl">protected AbstractBeanDefinition parseInternal(final Element element, final ParserContext parserContext) {
</span></span><span class="line"><span class="cl">	    //构建针对 SpringShardingDataSource 的 BeanDefinitionBuilder
</span></span><span class="line"><span class="cl">        BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition(SpringShardingDataSource.class);
</span></span><span class="line"><span class="cl">       //解析构造函数中的 DataSource 参数
</span></span><span class="line"><span class="cl">        factory.addConstructorArgValue(parseDataSources(element));
</span></span><span class="line"><span class="cl">//解析构造函数中 ShardingRuleConfiguration 参数        factory.addConstructorArgValue(parseShardingRuleConfiguration(element));
</span></span><span class="line"><span class="cl">       //解析构造函数中 Properties 参数
</span></span><span class="line"><span class="cl">        factory.addConstructorArgValue(parseProperties(element, parserContext));
</span></span><span class="line"><span class="cl">        factory.setDestroyMethodName(&#34;close&#34;);
</span></span><span class="line"><span class="cl">        return factory.getBeanDefinition();
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里，我们自己定义了一个 BeanDefinitionBuilder 并将其绑定到前面定义的业务对象类 SpringShardingDataSource。然后，我们通过三个 addConstructorArgValue 方法的调用，分别为 SpringShardingDataSource 构造函数中所需的 dataSourceMap、shardingRuleConfiguration 以及 props 参数进行赋值。</p>
<p>我们再来进一步看一下上述方法中的 parseDataSources 方法，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private Map&lt;String, RuntimeBeanReference&gt; parseDataSources(final Element element) {
</span></span><span class="line"><span class="cl">        Element shardingRuleElement = DomUtils.getChildElementByTagName(element, ShardingDataSourceBeanDefinitionParserTag.SHARDING_RULE_CONFIG_TAG);
</span></span><span class="line"><span class="cl">        List&lt;String&gt; dataSources = Splitter.on(&#34;,&#34;).trimResults().splitToList(shardingRuleElement.getAttribute(ShardingDataSourceBeanDefinitionParserTag.DATA_SOURCE_NAMES_TAG));
</span></span><span class="line"><span class="cl">        Map&lt;String, RuntimeBeanReference&gt; result = new ManagedMap&lt;&gt;(dataSources.size());
</span></span><span class="line"><span class="cl">        for (String each : dataSources) {
</span></span><span class="line"><span class="cl">            result.put(each, new RuntimeBeanReference(each));
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return result;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>基于前面介绍的配置示例，我们理解这段代码的作用是获取所配置的“ds0,ds1”字符串，并对其进行拆分，然后基于每个代表具体 DataSource 的名称构建 RuntimeBeanReference 对象并进行返回，这样就可以把在 Spring 容器中定义的其他 Bean 加载到 BeanDefinitionBuilder 中。</p>
<p>关于 ShardingDataSourceBeanDefinitionParser 中其他 parse 方法的使用，大家可以通过阅读对应的代码进行理解，处理方式都是非常类似的，就不再重复展开。</p>
<p>最后，我们需要在 META-INF 目录下提供spring.schemas 文件，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">http\://shardingsphere.apache.org/schema/shardingsphere/sharding/sharding.xsd=META-INF/namespace/sharding.xsd
</span></span><span class="line"><span class="cl">http\://shardingsphere.apache.org/schema/shardingsphere/masterslave/master-slave.xsd=META-INF/namespace/master-slave.xsd
</span></span><span class="line"><span class="cl">http\://shardingsphere.apache.org/schema/shardingsphere/encrypt/encrypt.xsd=META-INF/namespace/encrypt.xsd
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样，spring.handlers 的内容如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">http\://shardingsphere.apache.org/schema/shardingsphere/sharding=org.apache.shardingsphere.shardingjdbc.spring.namespace.handler.ShardingNamespaceHandler
</span></span><span class="line"><span class="cl">http\://shardingsphere.apache.org/schema/shardingsphere/masterslave=org.apache.shardingsphere.shardingjdbc.spring.namespace.handler.MasterSlaveNamespaceHandler
</span></span><span class="line"><span class="cl">http\://shardingsphere.apache.org/schema/shardingsphere/encrypt=org.apache.shardingsphere.shardingjdbc.spring.namespace.handler.EncryptNamespaceHandler
</span></span></code></pre></td></tr></table>
</div>
</div><p>至此，我们对 ShardingSphere 中基于命名空间机制与 Spring 进行系统集成的实现过程介绍完毕。</p>
<p>接下来，我们来看 ShardingSphere 中实现一个自定义 spring-boot-starter 的过程。</p>
<p>基于自定义 starter 集成 Spring Boot</p>
<p>与基于命名空间的实现方式一样，ShardingSphere 提供了 sharding-jdbc-spring-boot-starter 和 sharding-jdbc-orchestration-spring-boot-starter 这两个 starter 工程。篇幅关系，我们同样只关注于 sharding-jdbc-spring-boot-starter 工程。</p>
<p>对于 Spring Boot 工程，我们首先来关注 META-INF 文件夹下的 spring.factories 文件。Spring Boot 中提供了一个 SpringFactoriesLoader 类，该类的运行机制类似于 “13 | 微内核架构：ShardingSphere如何实现系统的扩展性？” 中所介绍的 SPI 机制，只不过以服务接口命名的文件是放在 META-INF/spring.factories 文件夹下，对应的 Key 为 EnableAutoConfiguration。SpringFactoriesLoader 会查找所有 META-INF/spring.factories 目录下的配置文件，并把 Key 为 EnableAutoConfiguration 所对应的配置项通过反射实例化为配置类并加载到容器。在 sharding-jdbc-spring-boot-starter 工程中，该文件内容如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
</span></span><span class="line"><span class="cl">org.apache.shardingsphere.shardingjdbc.spring.boot.SpringBootConfiguration
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在这里的 EnableAutoConfiguration 配置项指向了 SpringBootConfiguration 类。也就是说，这个类在 Spring Boot 启动过程中都能够通过 SpringFactoriesLoader 被加载到运行时环境中。</p>
<p>1.SpringBootConfiguration 中的注解</p>
<p>接下来，我们就来到这个 SpringBootConfiguration，首先关注于加在该类上的各种注解，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@Configuration
</span></span><span class="line"><span class="cl">@ComponentScan(&#34;org.apache.shardingsphere.spring.boot.converter&#34;)
</span></span><span class="line"><span class="cl">@EnableConfigurationProperties({
</span></span><span class="line"><span class="cl">        SpringBootShardingRuleConfigurationProperties.class, 
</span></span><span class="line"><span class="cl">        SpringBootMasterSlaveRuleConfigurationProperties.class, SpringBootEncryptRuleConfigurationProperties.class, SpringBootPropertiesConfigurationProperties.class})
</span></span><span class="line"><span class="cl">@ConditionalOnProperty(prefix = &#34;spring.shardingsphere&#34;, name = &#34;enabled&#34;, havingValue = &#34;true&#34;, matchIfMissing = true)
</span></span><span class="line"><span class="cl">@AutoConfigureBefore(DataSourceAutoConfiguration.class)
</span></span><span class="line"><span class="cl">@RequiredArgsConstructor
</span></span><span class="line"><span class="cl">public class SpringBootConfiguration implements EnvironmentAware
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先，我们看到了一个 @Configuration 注解。这个注解不是 Spring Boot 引入的新注解，而是属于 Spring 容器管理的内容。该注解表明这个类是一个配置类，可以启动组件扫描，用来将带有 @Bean 注解的实体进行实例化 bean。</p>
<p>然后，我们又看到了一个同样属于 Spring 容器管理范畴的老注解，即 @ComponentScan 注解。@ComponentScan 注解就是扫描基于 @Component 等注解所标注的类所在包下的所有需要注入的类，并把相关 Bean 定义批量加载到IoC容器中。</p>
<p>显然，Spring Boot 应用程序中同样需要这个功能。注意到，这里需要进行扫描的包路径位于另一个代码工程 sharding-spring-boot-util 的 org.apache.shardingsphere.spring.boot.converter 包中。</p>
<p>然后，我们看到了一个 @EnableConfigurationProperties 注解，该注解的作用就是使添加了 @ConfigurationProperties 注解的类生效。在 Spring Boot 中，如果一个类只使用了 @ConfigurationProperties 注解，然后该类没有在扫描路径下或者没有使用 @Component 等注解，就会导致无法被扫描为 bean，那么就必须在配置类上使用 @EnableConfigurationProperties 注解去指定这个类，才能使 @ConfigurationProperties 生效，并作为一个 bean 添加进 spring 容器中。这里的 @EnableConfigurationProperties 注解包含了四个具体的 ConfigurationProperties。以 SpringBootShardingRuleConfigurationProperties 为例，该类的定义如下所示，可以看到，这里直接继承了 sharding-core-common 代码工程中的 YamlShardingRuleConfiguration：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="err">@</span><span class="n">ConfigurationProperties</span><span class="p">(</span><span class="n">prefix</span> <span class="o">=</span> <span class="s2">&#34;spring.shardingsphere.sharding&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span> <span class="k">class</span> <span class="n">SpringBootShardingRuleConfigurationProperties</span> <span class="k">extends</span> <span class="n">YamlShardingRuleConfiguration</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>SpringBootConfiguration 上的下一个注解是 @ConditionalOnProperty，该注解的作用在于只有当所提供的属性属于 true 时才会实例化 Bean。</p>
<p>最后一个与自动加载相关的注解是 @AutoConfigureBefore，如果该注解用在类名上，其作用是标识在加载当前类之前需要加载注解中所设置的配置类。基于这一点，我们明确在加载 SpringBootConfiguration 类之前，Spring Boot 会先加载 DataSourceAutoConfiguration。这一步的作用与我们后面要看到的创建各种 DataSource 相关。</p>
<p>2.SpringBootConfiguration 中的功能</p>
<p>介绍完这些注解之后，我们来看一下 SpringBootConfiguration 类所提供的功能。</p>
<p>我们知道对于 ShardingSphere 而言，其对外的入口实际上就是各种 DataSource，因此 SpringBootConfiguration 中提供了一批创建不同 DataSource 的入口方法，例如如下所示的 shardingDataSource 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@Bean
</span></span><span class="line"><span class="cl">@Conditional(ShardingRuleCondition.class)
</span></span><span class="line"><span class="cl">public DataSource shardingDataSource() throws SQLException {
</span></span><span class="line"><span class="cl">        return ShardingDataSourceFactory.createDataSource(dataSourceMap, new ShardingRuleConfigurationYamlSwapper().swap(shardingRule), props.getProps());
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>该方法上添加了两个注解，一个是常见的 @Bean，另一个则是 @Conditional 注解，该注解的作用是只有满足指定条件的情况下才能加载这个 Bean。我们看到 @Conditional 注解中设置了一个 ShardingRuleCondition，该类如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="n">final</span> <span class="k">class</span> <span class="n">ShardingRuleCondition</span> <span class="k">extends</span> <span class="n">SpringBootCondition</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="err">@</span><span class="n">Override</span>
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="n">ConditionOutcome</span> <span class="n">getMatchOutcome</span><span class="p">(</span><span class="n">final</span> <span class="n">ConditionContext</span> <span class="n">conditionContext</span><span class="p">,</span> <span class="n">final</span> <span class="n">AnnotatedTypeMetadata</span> <span class="n">annotatedTypeMetadata</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">boolean</span> <span class="n">isMasterSlaveRule</span> <span class="o">=</span> <span class="n">new</span> <span class="n">MasterSlaveRuleCondition</span><span class="p">()</span><span class="o">.</span><span class="n">getMatchOutcome</span><span class="p">(</span><span class="n">conditionContext</span><span class="p">,</span> <span class="n">annotatedTypeMetadata</span><span class="p">)</span><span class="o">.</span><span class="n">isMatch</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">boolean</span> <span class="n">isEncryptRule</span> <span class="o">=</span> <span class="n">new</span> <span class="n">EncryptRuleCondition</span><span class="p">()</span><span class="o">.</span><span class="n">getMatchOutcome</span><span class="p">(</span><span class="n">conditionContext</span><span class="p">,</span> <span class="n">annotatedTypeMetadata</span><span class="p">)</span><span class="o">.</span><span class="n">isMatch</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">isMasterSlaveRule</span> <span class="o">||</span> <span class="n">isEncryptRule</span> <span class="err">?</span> <span class="n">ConditionOutcome</span><span class="o">.</span><span class="n">noMatch</span><span class="p">(</span><span class="s2">&#34;Have found master-slave or encrypt rule in environment&#34;</span><span class="p">)</span> <span class="p">:</span> <span class="n">ConditionOutcome</span><span class="o">.</span><span class="n">match</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到 ShardingRuleCondition 是一个标准的 SpringBootCondition，实现了 getMatchOutcome 抽象方法。我们知道 SpringBootCondition 的作用就是代表一种用于注册类或加载 Bean 的条件。ShardingRuleCondition 类的实现上分别调用了 MasterSlaveRuleCondition 和 EncryptRuleCondition 来判断是否满足这两个 SpringBootCondition。显然，对于 ShardingRuleCondition 而言，只有在两个条件都不满足的情况下才应该被加载。对于 masterSlaveDataSource 和 encryptDataSource 这两个方法而言，处理逻辑也类似，不做赘述。</p>
<p>最后，我们注意到 SpringBootConfiguration 还实现了 Spring 的 EnvironmentAware 接口。在 Spring Boot 中，当一个类实现了 EnvironmentAware 接口并重写了其中的 setEnvironment 方法之后，在代码工程启动时就可以获得 application.properties 配置文件中各个配置项的属性值。SpringBootConfiguration 中所重写的 setEnvironment 方法如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@Override
</span></span><span class="line"><span class="cl">public final void setEnvironment(final Environment environment) {
</span></span><span class="line"><span class="cl">        String prefix = &#34;spring.shardingsphere.datasource.&#34;;
</span></span><span class="line"><span class="cl">        for (String each : getDataSourceNames(environment, prefix)) {
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                dataSourceMap.put(each, getDataSource(environment, prefix, each));
</span></span><span class="line"><span class="cl">            } catch (final ReflectiveOperationException ex) {
</span></span><span class="line"><span class="cl">                throw new ShardingException(&#34;Can&#39;t find datasource type!&#34;, ex);
</span></span><span class="line"><span class="cl">            } catch (final NamingException namingEx) {
</span></span><span class="line"><span class="cl">                throw new ShardingException(&#34;Can&#39;t find JNDI datasource!&#34;, namingEx);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的代码逻辑是获取“spring.shardingsphere.datasource.name”或“spring.shardingsphere.datasource.names”配置项，然后根据该配置项中所指定的 DataSource 信息构建新的 DataSource 并加载到 dataSourceMap 这个 LinkedHashMap。这点我们可以结合课程案例中的配置项来加深理解：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">spring.shardingsphere.datasource.names=ds0,ds1
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">spring.shardingsphere.datasource.ds0.type=com.alibaba.druid.pool.DruidDataSource
</span></span><span class="line"><span class="cl">spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.jdbc.Driver
</span></span><span class="line"><span class="cl">spring.shardingsphere.datasource.ds0.url=jdbc:mysql://localhost/ds0
</span></span><span class="line"><span class="cl">spring.shardingsphere.datasource.ds0.username=root
</span></span><span class="line"><span class="cl">spring.shardingsphere.datasource.ds0.password=root
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">spring.shardingsphere.datasource.ds1.type=com.alibaba.druid.pool.DruidDataSource
</span></span><span class="line"><span class="cl">spring.shardingsphere.datasource.ds1.driver-class-name=com.mysql.jdbc.Driver
</span></span><span class="line"><span class="cl">spring.shardingsphere.datasource.ds1.url=jdbc:mysql://localhost/ds1
</span></span><span class="line"><span class="cl">spring.shardingsphere.datasource.ds1.username=root
</span></span><span class="line"><span class="cl">spring.shardingsphere.datasource.ds1.password=root
</span></span></code></pre></td></tr></table>
</div>
</div><p>至此，整个 SpringBootConfiguration 的实现过程介绍完毕。</p>
<p>从源码解析到日常开发</p>
<p>今天所介绍的关于 ShardingSphere 集成 Spring 的实现方法可以直接导入到日常开发过程中。如果我们需要实现一个自定义的框架或工具类，从面向开发人员的角度讲，最好能与 Spring 等主流的开发框架进行集成，以便提供最低的学习和维护成本。与 Spring 框架的集成过程都有固定的开发步骤，我们按照今天课时中所介绍的内容，就可以模仿 ShardingSphere 中的做法自己实现这些步骤。</p>
<p>小结与预告</p>
<p>本课时是 ShardingSphere 源码解析的最后一部分内容，我们围绕如何集成 Spring 框架这一主题对 ShardingSphere 的具体实现方法做了展开。ShardingSphere 在这方面提供了一种可以直接进行参考的模版式的实现方法，包括基于命名空间的 Spring 集成以及基于 starter的Spring Boot 集成方法。</p>
<p>这里给你留一道思考题：在 ShardingSphere 集成 Spring Boot 时，SpringBootConfiguration 类上的注解有哪些，分别起到了什么作用？</p>
<p>讲完 ShardingSphere 源码解析部分内容之后，下一课时是整个课程的最后一讲，我们将对 ShardingSphere 进行总结，并对它的后续发展进行展望。</p>
<p>课程评价入口，挑选 5 名小伙伴赠送小礼品~</p>
<p>-&ndash; ### 精选评论 ##### **超： &gt; 请教老师 <a href="https://github.com/apache/shardingsphere/issues/9067">https://github.com/apache/shardingsphere/issues/9067</a> 这个问题有遇到过么？该怎么解决 ######     讲师回复： &gt;     没有碰到哦 ##### *闰： &gt; 老师，请问我使用最新的4.1.1版本连接oracle数据库启动很久都不能启动起来 ######     讲师回复： &gt;     不大明确具体是什么问题，请同学描述得再详细些</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/shardingsphere%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%B2%BE%E8%AE%B2/">ShardingSphere核心原理精讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%A7%A3%E8%AF%BB%E4%BD%A0%E8%BA%AB%E8%BE%B9%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6/34%E8%AD%A6%E6%83%95%E6%B3%A1%E6%B2%AB%E7%BB%8F%E6%B5%8E%E5%9B%9B2015%E5%B9%B4%E4%B8%AD%E5%9B%BD%E8%82%A1%E5%B8%82%E7%9A%84%E5%A4%A7%E7%BC%A9%E6%B0%B4/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">34警惕泡沫经济（四）：2015年中国股市的大缩水</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/openresty%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/35__%E8%A7%86%E9%A2%91%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96ingress-nginx%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AApr%E8%A7%A3%E8%AF%BB/">
            <span class="next-text nav-default">35__[视频]实际项目中的性能优化：ingress-nginx中的几个PR解读</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
