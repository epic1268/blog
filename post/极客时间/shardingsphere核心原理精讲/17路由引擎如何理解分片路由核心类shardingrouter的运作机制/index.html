<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>17路由引擎：如何理解分片路由核心类ShardingRouter的运作机制？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="前面我们花了几个课时对 ShardingSphere 中的 SQL 解析引擎做了介绍，我们明白 SQL 解析的作用就是根据输入的 SQL 语句生成一个 SQLStatement 对象。
从今天开始，我们将进入 ShardingSphere 的路由（Routing）引擎部分的源码解析。从流程上讲，路由引擎是整个分片引擎执行流程中的第二步，即基于 SQL 解析引擎所生成的 SQLStatement，通过解析执行过程中所携带的上下文信息，来获取匹配数据库和表的分片策略，并生成路由结果。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/shardingsphere%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%B2%BE%E8%AE%B2/17%E8%B7%AF%E7%94%B1%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%88%86%E7%89%87%E8%B7%AF%E7%94%B1%E6%A0%B8%E5%BF%83%E7%B1%BBshardingrouter%E7%9A%84%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/shardingsphere%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%B2%BE%E8%AE%B2/17%E8%B7%AF%E7%94%B1%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%88%86%E7%89%87%E8%B7%AF%E7%94%B1%E6%A0%B8%E5%BF%83%E7%B1%BBshardingrouter%E7%9A%84%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="17路由引擎：如何理解分片路由核心类ShardingRouter的运作机制？">
  <meta property="og:description" content="前面我们花了几个课时对 ShardingSphere 中的 SQL 解析引擎做了介绍，我们明白 SQL 解析的作用就是根据输入的 SQL 语句生成一个 SQLStatement 对象。
从今天开始，我们将进入 ShardingSphere 的路由（Routing）引擎部分的源码解析。从流程上讲，路由引擎是整个分片引擎执行流程中的第二步，即基于 SQL 解析引擎所生成的 SQLStatement，通过解析执行过程中所携带的上下文信息，来获取匹配数据库和表的分片策略，并生成路由结果。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="ShardingSphere核心原理精讲">

  <meta itemprop="name" content="17路由引擎：如何理解分片路由核心类ShardingRouter的运作机制？">
  <meta itemprop="description" content="前面我们花了几个课时对 ShardingSphere 中的 SQL 解析引擎做了介绍，我们明白 SQL 解析的作用就是根据输入的 SQL 语句生成一个 SQLStatement 对象。
从今天开始，我们将进入 ShardingSphere 的路由（Routing）引擎部分的源码解析。从流程上讲，路由引擎是整个分片引擎执行流程中的第二步，即基于 SQL 解析引擎所生成的 SQLStatement，通过解析执行过程中所携带的上下文信息，来获取匹配数据库和表的分片策略，并生成路由结果。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6726">
  <meta itemprop="keywords" content="ShardingSphere核心原理精讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="17路由引擎：如何理解分片路由核心类ShardingRouter的运作机制？">
  <meta name="twitter:description" content="前面我们花了几个课时对 ShardingSphere 中的 SQL 解析引擎做了介绍，我们明白 SQL 解析的作用就是根据输入的 SQL 语句生成一个 SQLStatement 对象。
从今天开始，我们将进入 ShardingSphere 的路由（Routing）引擎部分的源码解析。从流程上讲，路由引擎是整个分片引擎执行流程中的第二步，即基于 SQL 解析引擎所生成的 SQLStatement，通过解析执行过程中所携带的上下文信息，来获取匹配数据库和表的分片策略，并生成路由结果。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">17路由引擎：如何理解分片路由核心类ShardingRouter的运作机制？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6726 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>前面我们花了几个课时对 ShardingSphere 中的 SQL 解析引擎做了介绍，我们明白 SQL 解析的作用就是根据输入的 SQL 语句生成一个 SQLStatement 对象。</p>
<p>从今天开始，我们将进入 ShardingSphere 的路由（Routing）引擎部分的源码解析。从流程上讲，路由引擎是整个分片引擎执行流程中的第二步，即基于 SQL 解析引擎所生成的 SQLStatement，通过解析执行过程中所携带的上下文信息，来获取匹配数据库和表的分片策略，并生成路由结果。</p>
<p>分层：路由引擎整体架构</p>
<p>与介绍 SQL 解析引擎时一样，我们通过翻阅 ShardingSphere 源码，首先梳理了如下所示的包结构：</p>
<p>上述包图总结了与路由机制相关的各个核心类，我们可以看到整体呈一种对称结构，即根据是 PreparedStatement 还是普通 Statement 分成两个分支流程。</p>
<p>同时，我们也可以把这张图中的类按照其所属的包结构分成两个层次：位于底层的 sharding-core-route 和位于上层的 sharding-core-entry，这也是 ShardingSphere 中所普遍采用的一种分包原则，即根据类的所属层级来组织包结构。关于 ShardingSphere 的分包原则我们在 《12 | 从应用到原理：如何高效阅读 ShardingSphere 源码？》中也已经进行了介绍，接下来我们具体分析这一原则在路由引擎中的应用。</p>
<p>1.sharding-core-route 工程</p>
<p>我们先来看图中的 ShardingRouter 类，该类是整个路由流程的启动点。ShardingRouter 类直接依赖于解析引擎 SQLParseEngine 类完成 SQL 解析并获取 SQLStatement 对象，然后供 PreparedStatementRoutingEngine 和 StatementRoutingEngine 进行使用。注意到这几个类都位于 sharding-core-route 工程中，处于底层组件。</p>
<p>2.sharding-core-entry 工程</p>
<p>另一方面，上图中的 PreparedQueryShardingEngine 和 SimpleQueryShardingEngine 则位于 sharding-core-entry 工程中。从包的命名上看，entry 相当于是访问的入口，所以我们可以判断这个工程中所提供的类属于面向应用层组件，处于更加上层的位置。PreparedQueryShardingEngine 和 SimpleQueryShardingEngine 的使用者分别是 ShardingPreparedStatement 和 ShardingStatement。这两个类再往上就是 ShardingConnection 以及 ShardingDataSource 这些直接面向应用层的类了。</p>
<p>路由核心类：ShardingRouter</p>
<p>通过以上分析，我们对路由引擎的整体结构有了一个初步的认识。对于采用分层结构的执行流程而言，有两种解析思路，即自上而下或自下而上。今天，我们的思路是从底层出发逐层往上分析流程的链路，先来看路由引擎中最底层的对象 ShardingRouter，变量定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private final ShardingRule shardingRule; 
</span></span><span class="line"><span class="cl">private final ShardingSphereMetaData metaData; 
</span></span><span class="line"><span class="cl">private final SQLParseEngine parseEngine;
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 ShardingRouter 中，我们首先看到了熟悉的 SQL 解析引擎 SQLParseEngine 以及它的使用方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public SQLStatement parse(final String logicSQL, final boolean useCache) { 
</span></span><span class="line"><span class="cl">        return parseEngine.parse(logicSQL, useCache); 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码非常简单，即通过 SQLParseEngine 对传入的 SQL 进行解析返回一个 SQLStatement 对象。这里将 SQL 命名为 logicSQL，以便区别在分片和读写分离情况下的真实 SQL。</p>
<p>接下来我们来看一下 ShardingRule，请注意这是一个基础类，代表着分片的各种规则信息。ShardingRule 类位于 sharding-core-common 工程中，主要保存着与分片相关的各种规则信息，以及 ShardingKeyGenerator 等分布式主键的创建过程，各个变量定义以及对应的注释如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//分片规则配置类，封装各种配置项信息 
</span></span><span class="line"><span class="cl">private final ShardingRuleConfiguration ruleConfiguration; 
</span></span><span class="line"><span class="cl">//DataSource 名称列表 
</span></span><span class="line"><span class="cl">private final ShardingDataSourceNames shardingDataSourceNames; 
</span></span><span class="line"><span class="cl">//针对表的规则列表 
</span></span><span class="line"><span class="cl">private final Collection&lt;TableRule&gt; tableRules; 
</span></span><span class="line"><span class="cl">//针对绑定表的规则列表 
</span></span><span class="line"><span class="cl">private final Collection&lt;BindingTableRule&gt; bindingTableRules; 
</span></span><span class="line"><span class="cl">//广播表名称列表 
</span></span><span class="line"><span class="cl">private final Collection&lt;String&gt; broadcastTables; 
</span></span><span class="line"><span class="cl">//默认的数据库分片策略 
</span></span><span class="line"><span class="cl">private final ShardingStrategy defaultDatabaseShardingStrategy; 
</span></span><span class="line"><span class="cl">//默认的数据表分片策略 
</span></span><span class="line"><span class="cl">private final ShardingStrategy defaultTableShardingStrategy; 
</span></span><span class="line"><span class="cl">//默认的分片键生成器 
</span></span><span class="line"><span class="cl">private final ShardingKeyGenerator defaultShardingKeyGenerator; 
</span></span><span class="line"><span class="cl">//针对读写分离的规则列表 
</span></span><span class="line"><span class="cl">private final Collection&lt;MasterSlaveRule&gt; masterSlaveRules; 
</span></span><span class="line"><span class="cl">//加密规则 
</span></span><span class="line"><span class="cl">private final EncryptRule encryptRule;
</span></span></code></pre></td></tr></table>
</div>
</div><p>ShardingRule 的内容非常丰富，但其定位更多是提供规则信息，而不属于核心流程，因此我们先不对其做详细展开。作为基础规则类，ShardingRule 会贯穿整个分片流程，在后续讲解过程中我们会穿插对它的介绍，这里先对上述变量的名称和含义有简单认识即可。</p>
<p>我们回到 ShardingRouter 类，发现其核心方法只有一个，即 route 方法。这个方法的逻辑比较复杂，我们梳理它的执行步骤，如下图所示：</p>
<p>ShardingRouter 是路由引擎的核心类，在接下来的内容中，我们将对上图中的 6 个步骤分别一 一 详细展开，帮忙你理解一个路由引擎的设计思想和实现机制。</p>
<p>1.分片合理性验证</p>
<p>我们首先来看 ShardingRouter 的第一个步骤，即验证分片信息的合理性，验证方式如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//使用ShardingStatementValidator对Statement进行验证 
</span></span><span class="line"><span class="cl">Optional&lt;ShardingStatementValidator&gt; shardingStatementValidator = ShardingStatementValidatorFactory.newInstance(sqlStatement); 
</span></span><span class="line"><span class="cl">if (shardingStatementValidator.isPresent()) { 
</span></span><span class="line"><span class="cl">     shardingStatementValidator.get().validate(shardingRule, sqlStatement, parameters); 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码使用 ShardingStatementValidator 对输入的 SQLStatement 进行验证，可以看到这里用到了典型的工厂模式，工厂类 ShardingStatementValidatorFactory 如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final class ShardingStatementValidatorFactory { 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static Optional&lt;ShardingStatementValidator&gt; newInstance(final SQLStatement sqlStatement) { 
</span></span><span class="line"><span class="cl">        if (sqlStatement instanceof InsertStatement) { 
</span></span><span class="line"><span class="cl">            return Optional.&lt;ShardingStatementValidator&gt;of(new ShardingInsertStatementValidator()); 
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">        if (sqlStatement instanceof UpdateStatement) { 
</span></span><span class="line"><span class="cl">            return Optional.&lt;ShardingStatementValidator&gt;of(new ShardingUpdateStatementValidator()); 
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">        return Optional.absent(); 
</span></span><span class="line"><span class="cl">    } 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意到 ShardingStatementValidator 要验证的只有 InsertStatement 和 UpdateStatement 这两个 SQLStatement。那么如何进行验证呢？我们来看一下 ShardingStatementValidator 的定义，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="n">interface</span> <span class="n">ShardingStatementValidator</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">extends</span> <span class="n">SQLStatement</span><span class="o">&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">//</span><span class="err">验证分片操作是否支持</span> 
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">validate</span><span class="p">(</span><span class="n">ShardingRule</span> <span class="n">shardingRule</span><span class="p">,</span> <span class="n">T</span> <span class="n">sqlStatement</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="ne">Object</span><span class="o">&gt;</span> <span class="n">parameters</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于验证过程而言，核心思想在于根据 SQLStatement 中的 Segment 与 ShardingRule 中的规则来判断它们之间是否有需要特殊处理的判断逻辑。我们以 ShardingInsertStatementValidator 为例来看验证过程，它的 validate 方法如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final class ShardingInsertStatementValidator implements ShardingStatementValidator&lt;InsertStatement&gt; { 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override 
</span></span><span class="line"><span class="cl">    public void validate(final ShardingRule shardingRule, final InsertStatement sqlStatement, final List&lt;Object&gt; parameters) { 
</span></span><span class="line"><span class="cl">        Optional&lt;OnDuplicateKeyColumnsSegment&gt; onDuplicateKeyColumnsSegment = sqlStatement.findSQLSegment(OnDuplicateKeyColumnsSegment.class); 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //如果是&#34;ON DUPLICATE KEY UPDATE&#34;语句，且如果当前操作的是分片Column时，验证不通过 
</span></span><span class="line"><span class="cl">        if (onDuplicateKeyColumnsSegment.isPresent() &amp;&amp; isUpdateShardingKey(shardingRule, onDuplicateKeyColumnsSegment.get(), sqlStatement.getTable().getTableName())) { 
</span></span><span class="line"><span class="cl">            throw new ShardingException(&#34;INSERT INTO .... ON DUPLICATE KEY UPDATE can not support update for sharding column.&#34;); 
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    … 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到这里的判断逻辑与“ON DUPLICATE KEY UPDATE”这一 Mysql 特有的语法相关，该语法允许我们通过 Update 的方式插入有重复主键的数据行（实际上这个语法也不是常规语法，本身也不大应该被使用）。</p>
<p>ShardingInsertStatementValidator 先判断是否存在 OnDuplicateKeyColumn，然后再判断这个 Column 是否是分片键，如果同时满足这两个条件，则直接抛出一个异常，不允许在分片 Column 上执行“INSERT INTO &hellip;. ON DUPLICATE KEY UPDATE”语法。</p>
<p>2.获取上下文</p>
<p>接下来我们来看 ShardingRouter 类中 route 方法的第二段代码，该段代码比较简单，用于获取运行时的 SQLStatement 上下文，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//获取 SQLStatementContext 
</span></span><span class="line"><span class="cl">SQLStatementContext sqlStatementContext = SQLStatementContextFactory.newInstance(metaData.getRelationMetas(), logicSQL, parameters, sqlStatement);
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到这里构建了上下文对象 SQLStatementContext，同样用到了工厂模式，工厂类 SQLStatementContextFactory 如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final class SQLStatementContextFactory { 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static SQLStatementContext newInstance(final RelationMetas relationMetas, final String sql, final List&lt;Object&gt; parameters, final SQLStatement sqlStatement) { 
</span></span><span class="line"><span class="cl">        if (sqlStatement instanceof SelectStatement) { 
</span></span><span class="line"><span class="cl">            return new SelectSQLStatementContext(relationMetas, sql, parameters, (SelectStatement) sqlStatement); 
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">        if (sqlStatement instanceof InsertStatement) { 
</span></span><span class="line"><span class="cl">            return new InsertSQLStatementContext(relationMetas, parameters, (InsertStatement) sqlStatement); 
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">        return new CommonSQLStatementContext(sqlStatement); 
</span></span><span class="line"><span class="cl">    } 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>请注意 SQLStatementContext 只有三种：</p>
<p>SelectSQLStatementContext</p>
<p>InsertSQLStatementContext</p>
<p>CommonSQLStatementContext</p>
<p>它们都实现了 SQLStatementContext 接口，顾名思义，所谓的 SQLStatementContext 就是一种上下文对象，保存着与特定 SQLStatement 相关的上下文信息，用于为后续处理提供数据存储和传递的手段。</p>
<p>我们可以想象在 SQLStatementContext 中势必都持有 SQLStatement 对象以及与表结构信息相关的上下文 TablesContext。</p>
<p>对于 SelectSQLStatement，通常也需要保存与查询相关的分组上下文 GroupByContext、排序上下文 OrderByContext 和分页上下文 PaginationContext；而对于InsertSQLStatementContext 而言，InsertValueContext 则包含了所有与插入操作相关的值对象。</p>
<p>3.自动生成主键</p>
<p>接下来的第三段代码与数据库主键相关，同样只有一句代码，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//如果是 InsertStatement 则自动生成主键 
</span></span><span class="line"><span class="cl">Optional&lt;GeneratedKey&gt; generatedKey = sqlStatement instanceof InsertStatement 
</span></span><span class="line"><span class="cl">            ? GeneratedKey.getGenerateKey(shardingRule, metaData.getTables(), parameters, (InsertStatement) sqlStatement) : Optional.&lt;GeneratedKey&gt;absent();
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码的逻辑比较明确，即如果输入的 SQLStatement 是 InsertStatement，则自动创建一个主键 GeneratedKey，反之就不做处理。</p>
<p>在数据分片的场景下，创建一个分布式主键实际上并没有那么简单，所以在这段代码背后有很多设计的思想和实现的技巧值得我们进行深入分析，关于这个主题，我们已经在 《14 | 分布式主键：ShardingSphere 中有哪些分布式主键实现方式？》中对分布式主键生成机制做了专题分享。</p>
<p>4.创建分片条件</p>
<p>我们来看 ShardingRouter 中 route 方法的第四个步骤，这个步骤的作用是创建分片条件，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//创建分片条件 
</span></span><span class="line"><span class="cl">ShardingConditions shardingConditions = getShardingConditions(parameters, sqlStatementContext, generatedKey.orNull(), metaData.getRelationMetas()); 
</span></span><span class="line"><span class="cl">boolean needMergeShardingValues = isNeedMergeShardingValues(sqlStatementContext); 
</span></span><span class="line"><span class="cl">if (sqlStatementContext.getSqlStatement() instanceof DMLStatement &amp;&amp; needMergeShardingValues) { 
</span></span><span class="line"><span class="cl">    checkSubqueryShardingValues(sqlStatementContext, shardingConditions); 
</span></span><span class="line"><span class="cl">    mergeShardingConditions(shardingConditions); 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 ShardingSphere 中，分片条件对象 ShardingCondition 定义如下所示，包含了一组路由信息和节点信息，其中路由信息包含表名和列名，而节点信息包含数据源名和表名：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class ShardingCondition { 
</span></span><span class="line"><span class="cl">    //路由信息 
</span></span><span class="line"><span class="cl">    private final List&lt;RouteValue&gt; routeValues = new LinkedList&lt;&gt;(); 
</span></span><span class="line"><span class="cl">    //节点信息 
</span></span><span class="line"><span class="cl">    private final Collection&lt;DataNode&gt; dataNodes = new LinkedList&lt;&gt;(); 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么如何获取分片条件呢？如下所示的 getShardingConditions 方法给出了具体的实现方式，可以看到这里根据输入的 SQL 类型，分别通过 InsertClauseShardingConditionEngine 和WhereClauseShardingConditionEngine 创建了 ShardingConditions：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private ShardingConditions getShardingConditions(final List&lt;Object&gt; parameters, final SQLStatementContext sqlStatementContext, final GeneratedKey generatedKey, final RelationMetas relationMetas) { 
</span></span><span class="line"><span class="cl">    if (sqlStatementContext.getSqlStatement() instanceof DMLStatement) { 
</span></span><span class="line"><span class="cl">     //如果是 InsertSQLStatement 上下文 
</span></span><span class="line"><span class="cl">        if (sqlStatementContext instanceof InsertSQLStatementContext) { 
</span></span><span class="line"><span class="cl">            InsertSQLStatementContext shardingInsertStatement = (InsertSQLStatementContext) sqlStatementContext; 
</span></span><span class="line"><span class="cl">            //通过 InsertClauseShardingConditionEngine 创建分片条件 
</span></span><span class="line"><span class="cl">            return new ShardingConditions(new InsertClauseShardingConditionEngine(shardingRule).createShardingConditions(shardingInsertStatement, generatedKey, parameters)); 
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">        //否则直接通过 WhereClauseShardingConditionEngine 创建分片条件 
</span></span><span class="line"><span class="cl">        return new ShardingConditions(new WhereClauseShardingConditionEngine(shardingRule, relationMetas).createShardingConditions(sqlStatementContext.getSqlStatement(), parameters)); 
</span></span><span class="line"><span class="cl">    } 
</span></span><span class="line"><span class="cl">    return new ShardingConditions(Collections.&lt;ShardingCondition&gt;emptyList()); 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于路由引擎而言，分片条件的主要目的就是提取用于路由的目标数据库、表和列之间的关系，InsertClauseShardingConditionEngine 和 WhereClauseShardingConditionEngine 中的处理逻辑都是为了构建包含这些关系信息的一组 ShardingCondition 对象。</p>
<p>当获取这些 ShardingCondition 之后，我们还看到有一个优化的步骤，即调用mergeShardingConditions，对可以合并的 ShardingCondition 进行合并。</p>
<p>5.执行路由</p>
<p>当我们获取了 SQLStatement 上下文，并创建了分片条件，接下来就是真正执行路由，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//获取 RoutingEngine 并执行路由 
</span></span><span class="line"><span class="cl">RoutingEngine routingEngine = RoutingEngineFactory.newInstance(shardingRule, metaData, sqlStatementContext, shardingConditions); 
</span></span><span class="line"><span class="cl">RoutingResult routingResult = routingEngine.route();
</span></span></code></pre></td></tr></table>
</div>
</div><p>这两句代码是 ShardingRouter 类的核心，我们获取了一个 RoutingEngine 实例，然后基于该实例执行路由并返回一个 RoutingResult 对象。RoutingEngine 定义如下，只有一个简单的 route 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public interface RoutingEngine {
</span></span><span class="line"><span class="cl">    //执行路由 
</span></span><span class="line"><span class="cl">    RoutingResult route(); 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 ShardingSphere 中存在一批 RoutingEngine 的实现类，RoutingEngineFactory 工厂类负责生成这些具体的 RoutingEngine，生成逻辑如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static RoutingEngine newInstance(final ShardingRule shardingRule, 
</span></span><span class="line"><span class="cl">                                            final ShardingSphereMetaData metaData, final SQLStatementContext sqlStatementContext, final ShardingConditions shardingConditions) { 
</span></span><span class="line"><span class="cl">        SQLStatement sqlStatement = sqlStatementContext.getSqlStatement(); 
</span></span><span class="line"><span class="cl">        Collection&lt;String&gt; tableNames = sqlStatementContext.getTablesContext().getTableNames(); 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //全库路由 
</span></span><span class="line"><span class="cl">        if (sqlStatement instanceof TCLStatement) { 
</span></span><span class="line"><span class="cl">            return new DatabaseBroadcastRoutingEngine(shardingRule); 
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">        //全库表路由 
</span></span><span class="line"><span class="cl">        if (sqlStatement instanceof DDLStatement) { 
</span></span><span class="line"><span class="cl">            return new TableBroadcastRoutingEngine(shardingRule, metaData.getTables(), sqlStatementContext); 
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">        //阻断路由 
</span></span><span class="line"><span class="cl">        if (sqlStatement instanceof DALStatement) { 
</span></span><span class="line"><span class="cl">            return getDALRoutingEngine(shardingRule, sqlStatement, tableNames); 
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">        //全实例路由 
</span></span><span class="line"><span class="cl">        if (sqlStatement instanceof DCLStatement) { 
</span></span><span class="line"><span class="cl">            return getDCLRoutingEngine(shardingRule, sqlStatementContext, metaData); 
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">        //默认库路由 
</span></span><span class="line"><span class="cl">        if (shardingRule.isAllInDefaultDataSource(tableNames)) { 
</span></span><span class="line"><span class="cl">            return new DefaultDatabaseRoutingEngine(shardingRule, tableNames); 
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">        //全库路由 
</span></span><span class="line"><span class="cl">        if (shardingRule.isAllBroadcastTables(tableNames)) { 
</span></span><span class="line"><span class="cl">            return sqlStatement instanceof SelectStatement ? new UnicastRoutingEngine(shardingRule, tableNames) : new DatabaseBroadcastRoutingEngine(shardingRule); 
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">        //默认库路由 
</span></span><span class="line"><span class="cl">        if (sqlStatementContext.getSqlStatement() instanceof DMLStatement &amp;&amp; tableNames.isEmpty() &amp;&amp; shardingRule.hasDefaultDataSourceName()) { 
</span></span><span class="line"><span class="cl">            return new DefaultDatabaseRoutingEngine(shardingRule, tableNames); 
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">        //单播路由 
</span></span><span class="line"><span class="cl">        if (sqlStatementContext.getSqlStatement() instanceof DMLStatement &amp;&amp; shardingConditions.isAlwaysFalse() || tableNames.isEmpty() || !shardingRule.tableRuleExists(tableNames)) { 
</span></span><span class="line"><span class="cl">            return new UnicastRoutingEngine(shardingRule, tableNames); 
</span></span><span class="line"><span class="cl">        } 
</span></span><span class="line"><span class="cl">        //分片路由 
</span></span><span class="line"><span class="cl">        return getShardingRoutingEngine(shardingRule, sqlStatementContext, shardingConditions, tableNames); 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这些 RoutingEngine 的具体介绍我们放在下一课时《18 | 路由引擎：如何实现数据访问的分片路由和广播路由？》中进行详细介绍，这里只需要了解 ShardingSphere 在包结构的设计上把具体的 RoutingEngine 分成了六大类：即广播（broadcast）路由、混合（complex）路由、默认数据库（defaultdb）路由、无效（ignore）路由、标准（standard）路由以及单播（unicast）路由，如下所示：</p>
<p>不同类型的 RoutingEngine 实现类</p>
<p>RoutingEngine 的执行结果是 RoutingResult，而 RoutingResult 中包含了一个 RoutingUnit集合，RoutingUnit 中的变量定义如下所示，可以看到有两个关于 DataSource 名称的变量以及一个 TableUnit 列表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//真实数据源名 
</span></span><span class="line"><span class="cl">private final String dataSourceName; 
</span></span><span class="line"><span class="cl">//逻辑数据源名 
</span></span><span class="line"><span class="cl">private final String masterSlaveLogicDataSourceName; 
</span></span><span class="line"><span class="cl">//表单元列表 
</span></span><span class="line"><span class="cl">private final List&lt;TableUnit&gt; tableUnits = new LinkedList&lt;&gt;();
</span></span></code></pre></td></tr></table>
</div>
</div><p>而 TableUnit 保存着逻辑表名和实际表名，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final class TableUnit { 
</span></span><span class="line"><span class="cl">    //逻辑表名 
</span></span><span class="line"><span class="cl">    private final String logicTableName; 
</span></span><span class="line"><span class="cl">    //真实表名 
</span></span><span class="line"><span class="cl">    private final String actualTableName; 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以 RoutingResult 中保存的实际上就是一组关于数据库与数据表的对应关系，其中库与表都存在逻辑值和真实值。</p>
<p>6.构建路由结果</p>
<p>当通过一系列的路由引擎处理之后，我们获得了 RoutingResult 对象，但并不是直接将其进行返回，而是会构建一个 SQLRouteResult 对象。这就是 ShardingRouter 的 route 方法最后一个步骤，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//构建 SQLRouteResult 
</span></span><span class="line"><span class="cl">SQLRouteResult result = new SQLRouteResult(sqlStatementContext, shardingConditions, generatedKey.orNull()); 
</span></span><span class="line"><span class="cl">result.setRoutingResult(routingResult); 
</span></span><span class="line"><span class="cl">//如果是Insert语句，则设置自动生成的分片键 
</span></span><span class="line"><span class="cl">if (sqlStatementContext instanceof InsertSQLStatementContext) { 
</span></span><span class="line"><span class="cl">    setGeneratedValues(result); 
</span></span><span class="line"><span class="cl">} 
</span></span><span class="line"><span class="cl">return result;
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们来到 SQLRouteResult 的定义，看看它与 RouteResult 之间有什么不同，SQLRouteResult中 的变量如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//SQLStatement 上下文 
</span></span><span class="line"><span class="cl">private final SQLStatementContext sqlStatementContext; 
</span></span><span class="line"><span class="cl">//分片条件 
</span></span><span class="line"><span class="cl">private final ShardingConditions shardingConditions; 
</span></span><span class="line"><span class="cl">//自动生成的分片键 
</span></span><span class="line"><span class="cl">private final GeneratedKey generatedKey; 
</span></span><span class="line"><span class="cl">//一组路由单元 
</span></span><span class="line"><span class="cl">private final Collection&lt;RouteUnit&gt; routeUnits = new LinkedHashSet&lt;&gt;(); 
</span></span><span class="line"><span class="cl">//由 RoutingEngine 生成的 RoutingResult 
</span></span><span class="line"><span class="cl">private RoutingResult routingResult;
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到 SQLRouteResult 中包含了 RoutingResult。我们可以认为 SQLRouteResult 是整个 SQL 路由返回的路由结果，在后续的流程中还会被 PreparedStatementRoutingEngine 等上层对象所使用，而 RoutingResult 只是 RoutingEngine 返回的路由结果，它的使用者就是位于底层的 ShardingRouter。</p>
<p>同时，我们注意到这里有一个新的 Unit 对象 RouteUnit，包含了数据源名称以及 SQL 单元对象 SQLUnit，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final class RouteUnit { 
</span></span><span class="line"><span class="cl">    //数据源名 
</span></span><span class="line"><span class="cl">    private final String dataSourceName; 
</span></span><span class="line"><span class="cl">    //SQL 单元 
</span></span><span class="line"><span class="cl">    private final SQLUnit sqlUnit; 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的 SQLUnit 中就是最终的一条 SQL 语句以及相应参数的组合。因为路由结果对象 SQLRouteResult 会继续传递到分片引擎的后续流程，且内部结构比较复杂，所以这里通过如下所示的类图对其包含的各种变量进行总结，方便你进行理解。</p>
<p>至此，我们把 ShardingRouter 类的核心流程做了介绍。在 ShardingSphere 的路由引擎中，ShardingRouter 可以说是一个承上启下的核心类，向下我们可以挖掘各种 RoutingEngine 的具体实现；向上我们可以延展到读写分离等面向应用的具体场景。</p>
<p>下图展示了 ShardingRouter 的这种定位关系。关于各种 RoutingEngine 的介绍是我们下一课时的内容，今天我们先将基于 ShardingRouter 讨论它的上层结构，从而引出了 ShardingEngine。</p>
<p>从底层 ShardingRouter 到上层 ShardingEngine</p>
<p>我们的思路仍然是从下往上，先来看上图中的 StatementRoutingEngine，其实现如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final class StatementRoutingEngine { 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private final ShardingRouter shardingRouter; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private final ShardingMasterSlaveRouter masterSlaveRouter; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public StatementRoutingEngine(final ShardingRule shardingRule, final ShardingSphereMetaData metaData, final SQLParseEngine sqlParseEngine) { 
</span></span><span class="line"><span class="cl">        shardingRouter = new ShardingRouter(shardingRule, metaData, sqlParseEngine); 
</span></span><span class="line"><span class="cl">        masterSlaveRouter = new ShardingMasterSlaveRouter(shardingRule.getMasterSlaveRules()); 
</span></span><span class="line"><span class="cl">    } 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public SQLRouteResult route(final String logicSQL) { 
</span></span><span class="line"><span class="cl">        SQLStatement sqlStatement = shardingRouter.parse(logicSQL, false); 
</span></span><span class="line"><span class="cl">        return masterSlaveRouter.route(shardingRouter.route(logicSQL, Collections.emptyList(), sqlStatement)); 
</span></span><span class="line"><span class="cl">    } 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到在 StatementRoutingEngine 的 route 方法中，通过 ShardingMasterSlaveRouter 对通过 ShardingRouter 所生成的 SQLRouteResult 进行了再一次路由，也就是说在分片路由的基础上添加了主从路由，关于读写分离和主从路由我们会在之后的《26 | 读写分离：普通主从架构和分片主从架构分别是如何实现的？》进行讨论。</p>
<p>现在我们来到 sharding-core-entry 工程，看看更上层的处理流程。整个 sharding-core-entry 工程只有三个类，即作为基类的 BaseShardingEngine 以及两个子类 PreparedQueryShardingEngine 和 SimpleQueryShardingEngine。我们先来看 BaseShardingEngine 类，它本质上是一个模板类，BaseShardingEngine 的 shard 方法如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public SQLRouteResult shard(final String sql, final List&lt;Object&gt; parameters) { 
</span></span><span class="line"><span class="cl">     //调用模板方法准备参数 
</span></span><span class="line"><span class="cl">    List&lt;Object&gt; clonedParameters = cloneParameters(parameters); 
</span></span><span class="line"><span class="cl">    //执行路由 
</span></span><span class="line"><span class="cl">    SQLRouteResult result = executeRoute(sql, clonedParameters); 
</span></span><span class="line"><span class="cl">    //执行 SQL 转换（Convert）和改写（Rewrite） 
</span></span><span class="line"><span class="cl">        result.getRouteUnits().addAll(HintManager.isDatabaseShardingOnly() ? convert(sql, clonedParameters, result) : rewriteAndConvert(sql, clonedParameters, result)); 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	//省略日志记录 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return result; 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里我们看到了 SQL 转换（Convert）和改写（Rewrite）的入口，这是路由引擎之外的执行流程，我们今天不做展开。上述代码与路由相关最核心的就是 executeRoute 方法，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private SQLRouteResult executeRoute(final String sql, final List&lt;Object&gt; clonedParameters) {
</span></span><span class="line"><span class="cl"> routingHook.start(sql); 
</span></span><span class="line"><span class="cl">    try { 
</span></span><span class="line"><span class="cl">         //调用模板方法执行路由并获取结果 
</span></span><span class="line"><span class="cl">        SQLRouteResult result = route(sql, clonedParameters); 
</span></span><span class="line"><span class="cl">        routingHook.finishSuccess(result, metaData.getTables()); 
</span></span><span class="line"><span class="cl">        return result; 
</span></span><span class="line"><span class="cl">    } catch (final Exception ex) { 
</span></span><span class="line"><span class="cl">        routingHook.finishFailure(ex); 
</span></span><span class="line"><span class="cl">        throw ex; 
</span></span><span class="line"><span class="cl">    } 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个方法的处理方式与 SQLParseEngine 的 parse 方法有着类似的代码结构，同样用到了 Hook 机制。</p>
<p>从设计模式上讲，BaseShardingEngine 采用了非常典型的模板方法。当我们需要完成一个过程或一系列步骤时，这些过程或步骤在某一细节层次保持一致，但个别步骤在更详细的层次上的实现可能不同时，可以考虑用模板方法模式来处理。实现模板方法的过程也非常简单，其实就是利用了类的继承机制。作为一个模板类，我们注意到 BaseShardingEngine 提供了两个模板方法供子类进行实现，分别是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//拷贝参数 
</span></span><span class="line"><span class="cl">protected abstract List&lt;Object&gt; cloneParameters(List&lt;Object&gt; parameters); 
</span></span><span class="line"><span class="cl">//执行路由 
</span></span><span class="line"><span class="cl">protected abstract SQLRouteResult route(String sql, List&lt;Object&gt; parameters);
</span></span></code></pre></td></tr></table>
</div>
</div><p>显然，对于 SimpleQueryShardingEngine 而言，不需要参数，所以 cloneParameters 直接返回空列表。而 route 方法则直接使用前面介绍的 StatementRoutingEngine 进行路由。SimpleQueryShardingEngine 类的完整实现如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="n">final</span> <span class="k">class</span> <span class="n">SimpleQueryShardingEngine</span> <span class="k">extends</span> <span class="n">BaseShardingEngine</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">private</span> <span class="n">final</span> <span class="n">StatementRoutingEngine</span> <span class="n">routingEngine</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="n">SimpleQueryShardingEngine</span><span class="p">(</span><span class="n">final</span> <span class="n">ShardingRule</span> <span class="n">shardingRule</span><span class="p">,</span> <span class="n">final</span> <span class="n">ShardingProperties</span> <span class="n">shardingProperties</span><span class="p">,</span> <span class="n">final</span> <span class="n">ShardingSphereMetaData</span> <span class="n">metaData</span><span class="p">,</span> <span class="n">final</span> <span class="n">SQLParseEngine</span> <span class="n">sqlParseEngine</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">super</span><span class="p">(</span><span class="n">shardingRule</span><span class="p">,</span> <span class="n">shardingProperties</span><span class="p">,</span> <span class="n">metaData</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">        <span class="n">routingEngine</span> <span class="o">=</span> <span class="n">new</span> <span class="n">StatementRoutingEngine</span><span class="p">(</span><span class="n">shardingRule</span><span class="p">,</span> <span class="n">metaData</span><span class="p">,</span> <span class="n">sqlParseEngine</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="err">@</span><span class="n">Override</span> 
</span></span><span class="line"><span class="cl">    <span class="n">protected</span> <span class="n">List</span><span class="o">&lt;</span><span class="ne">Object</span><span class="o">&gt;</span> <span class="n">cloneParameters</span><span class="p">(</span><span class="n">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="ne">Object</span><span class="o">&gt;</span> <span class="n">parameters</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Collections</span><span class="o">.</span><span class="n">emptyList</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="err">@</span><span class="n">Override</span> 
</span></span><span class="line"><span class="cl">    <span class="n">protected</span> <span class="n">SQLRouteResult</span> <span class="n">route</span><span class="p">(</span><span class="n">final</span> <span class="ne">String</span> <span class="n">sql</span><span class="p">,</span> <span class="n">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="ne">Object</span><span class="o">&gt;</span> <span class="n">parameters</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">routingEngine</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="n">sql</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>至此，关于 ShardingSphere 路由引擎部分的内容基本都介绍完毕。对于上层结构而言，我们以 SimpleQueryShardingEngine 为例进行了展开，对于 PreparedQueryShardingEngine 的处理方式也是类似。作为总结，我们通过如下所示的时序图来梳理这些路由的主流程。</p>
<p>从源码解析到日常开发</p>
<p>分包设计原则可以用来设计和规划开源框架的代码结构。在今天的内容中，我们看到了 ShardingSphere 中非常典型的一种分层和分包实现策略。通过 sharding-core-route 和 sharding-core-entry 这两个工程，我们把路由引擎中位于底层的核心类 ShardingRouter 和位于上层的 PreparedQueryShardingEngine 及 SimpleQueryShardingEngine 类进行了合理的分层管理。ShardingSphere 对于分层和分包策略的应用有很多具体的表现形式，随着课程的不断演进，我们还会看到更多的应用场景。</p>
<p>小结与预告</p>
<p>作为 ShardingSphere 分片引擎的第二个核心组件，路由引擎的目的在于生成 SQLRouteResult目标对象。而整个路由引擎中最核心的就是 ShardingRouter 类。今天，我们对 ShardingRouter 的整体执行流程进行了详细的讨论，同时也引出了路由引擎中的底层对象 RoutingEngine。</p>
<p>这里给你留一道思考题：ShardingSphere 中，一个完整的路由执行过程需要经历哪些步骤？ 欢迎你在留言区与大家讨论，我将一一点评解答。</p>
<p>在今天的课程中，我们也提到了 ShardingSphere 中存在多种 RoutingEngine。在下一课时的内容中，我们将关注于这些 RoutingEngine 的具体实现过程。</p>
<p>-&ndash; ### 精选评论 ##### **7834： &gt; 各版本间相差大在正文开头应该就说明的，看到现在也记了很多笔记了，再切到老师的版本也浪费时间 ######     讲师回复： &gt;     是的，版本之间差别比较大，可以选择自己想要学习的版本来看 ##### **杰： &gt; 打卡，整个路有过程很负责 ##### **宾： &gt; 老师，你这源码是哪个版本的？与我看的对不上啊？ ######     讲师回复： &gt;     用的是4.0.1版本，如果你看的是正在开发的5.X版本分支的话，确实很多会对不起来，4.X版本的话基本都是一致的，5.X和4.X版本的代码变动非常大</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/shardingsphere%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%B2%BE%E8%AE%B2/">ShardingSphere核心原理精讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/java-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%9821%E8%AE%B2/17%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6jvm%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">17高级进阶：JVM如何完成垃圾回收？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%A7%A3%E8%AF%BB%E4%BD%A0%E8%BA%AB%E8%BE%B9%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6/17%E4%B9%B0%E6%88%BF%E8%BF%98%E6%98%AF%E7%A7%9F%E6%88%BF%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%80%82%E5%90%88%E4%BD%A0/">
            <span class="next-text nav-default">17买房还是租房，哪个更适合你？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
