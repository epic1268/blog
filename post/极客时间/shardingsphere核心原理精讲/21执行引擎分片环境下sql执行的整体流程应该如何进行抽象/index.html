<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>21执行引擎：分片环境下SQL执行的整体流程应该如何进行抽象？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="从今天开始，我们将开始一个全新的主题，即 ShardingSphere 的执行引擎（ExecuteEngine）。一旦我们获取了从路由引擎和改写引擎中所生成的 SQL，执行引擎就会完成这些SQL在具体数据库中的执行。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/shardingsphere%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%B2%BE%E8%AE%B2/21%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E5%88%86%E7%89%87%E7%8E%AF%E5%A2%83%E4%B8%8Bsql%E6%89%A7%E8%A1%8C%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8A%BD%E8%B1%A1/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/shardingsphere%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%B2%BE%E8%AE%B2/21%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E5%88%86%E7%89%87%E7%8E%AF%E5%A2%83%E4%B8%8Bsql%E6%89%A7%E8%A1%8C%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8A%BD%E8%B1%A1/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="21执行引擎：分片环境下SQL执行的整体流程应该如何进行抽象？">
  <meta property="og:description" content="从今天开始，我们将开始一个全新的主题，即 ShardingSphere 的执行引擎（ExecuteEngine）。一旦我们获取了从路由引擎和改写引擎中所生成的 SQL，执行引擎就会完成这些SQL在具体数据库中的执行。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="ShardingSphere核心原理精讲">

  <meta itemprop="name" content="21执行引擎：分片环境下SQL执行的整体流程应该如何进行抽象？">
  <meta itemprop="description" content="从今天开始，我们将开始一个全新的主题，即 ShardingSphere 的执行引擎（ExecuteEngine）。一旦我们获取了从路由引擎和改写引擎中所生成的 SQL，执行引擎就会完成这些SQL在具体数据库中的执行。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5009">
  <meta itemprop="keywords" content="ShardingSphere核心原理精讲">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="21执行引擎：分片环境下SQL执行的整体流程应该如何进行抽象？">
  <meta name="twitter:description" content="从今天开始，我们将开始一个全新的主题，即 ShardingSphere 的执行引擎（ExecuteEngine）。一旦我们获取了从路由引擎和改写引擎中所生成的 SQL，执行引擎就会完成这些SQL在具体数据库中的执行。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">21执行引擎：分片环境下SQL执行的整体流程应该如何进行抽象？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5009 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>从今天开始，我们将开始一个全新的主题，即 ShardingSphere 的执行引擎（ExecuteEngine）。一旦我们获取了从路由引擎和改写引擎中所生成的 SQL，执行引擎就会完成这些SQL在具体数据库中的执行。</p>
<p>执行引擎是 ShardingSphere 的核心模块，接下来我们将通过三个课时来对其进行全面介绍。今天，我们先讨论在分片环境下，ShardingSphere 对 SQL 执行的整体流程的抽象过程，后两个课时会向你讲解“如何把握 ShardingSphere 中的 Executor 执行模型”。</p>
<p>ShardingSphere 执行引擎总体结构</p>
<p>在讲解具体的源代码之前，我们从《17 | 路由引擎：如何理解分片路由核心类 ShardingRouter 的运作机制？》中的 PreparedQueryShardingEngine 和 SimpleQueryShardingEngine 这两个类出发，看看在 ShardingSphere 中使用它们的入口。</p>
<p>我们在ShardingStatement类中找到了如下所示的一个 shard 方法，这里用到了 SimpleQueryShardingEngine：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private void shard(final String sql) {
</span></span><span class="line"><span class="cl">    //从 Connection 中获取 ShardingRuntimeContext 上下文
</span></span><span class="line"><span class="cl">    ShardingRuntimeContext runtimeContext = connection.getRuntimeContext();
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    //创建 SimpleQueryShardingEngine
</span></span><span class="line"><span class="cl">    SimpleQueryShardingEngine shardingEngine = new SimpleQueryShardingEngine(runtimeContext.getRule(), runtimeContext.getProps(), runtimeContext.getMetaData(), runtimeContext.getParseEngine());
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    //执行分片路由并获取路由结果
</span></span><span class="line"><span class="cl">    sqlRouteResult = shardingEngine.shard(sql, Collections.emptyList());
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>而在ShardingPreparedStatement中也存在一个类似的 shard 方法。</p>
<p>从设计模式上讲，ShardingStatement 和 ShardingPreparedStatement 实际上就是很典型的外观类，它们把与 SQL 路由和执行的入口类都整合在一起。</p>
<p>通过阅读源码，我们不难发现在 ShardingStatement 中存在一个 StatementExecutor；而在 ShardingPreparedStatement 中也存在 PreparedStatementExecutor 和 BatchPreparedStatementExecutor，这些类都以 Executor 结尾，显然这就是我们要找的 SQL 执行引擎的入口类。</p>
<p>我们发现上述三个 Executor 都位于 sharding-jdbc-core 工程中。</p>
<p>此外，还有一个与 sharding-core-route 和 sharding-core-rewrite 并列的sharding-core-execute 工程，从命名上看，这个工程应该也与执行引擎相关。果然，我们在这个工程中找到了ShardingExecuteEngine 类，这是分片执行引擎的入口类。</p>
<p>然后，我们又分别找到了 SQLExecuteTemplate 和 SQLExecutePrepareTemplate 类，这两个是典型的SQL 执行模板类。</p>
<p>根据到目前为止对 ShardingSphere 组件设计和代码分层风格的了解，可以想象，在层次关系上，ShardingExecuteEngine 是底层对象，SQLExecuteTemplate 应该依赖于 ShardingExecuteEngine；而 StatementExecutor、PreparedStatementExecutor 和 BatchPreparedStatementExecutor 属于上层对象，应该依赖于 SQLExecuteTemplate。我们通过简单阅读这些核心类之前的引用关系，印证了这种猜想。</p>
<p>基于以上分析，我们可以给出 SQL 执行引擎的整体结构图（如下图），其中横线以上部分位于 sharding-core-execute 工程，属于底层组件；而直线以下部分位于 sharding-jdbc-core 中，属于上层组件。这种分析源码的能力也是《12 | 从应用到原理：如何高效阅读 ShardingSphere 源码？》中提到的“基于分包设计原则阅读源码”的一种具体表现：</p>
<p>ShardingSphere 执行引擎核心类的分层结构图</p>
<p>另一方面，我们在上图中还看到 SQLExecuteCallback 和 SQLExecutePrepareCallback，显然，它们的作用是完成 SQL 执行过程中的回调处理，这也是一种非常典型的扩展性处理方式。</p>
<p>ShardingExecuteEngine</p>
<p>按照惯例，我们还是从位于底层的 ShardingExecuteEngine 开始切入。与路由和改写引擎不同，ShardingExecuteEngine 是 ShardingSphere 中唯一的一个执行引擎，所以直接设计为一个类而非接口，这个类包含了如下的变量和构造函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private final ShardingExecutorService shardingExecutorService;    
</span></span><span class="line"><span class="cl">private ListeningExecutorService executorService;
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">public ShardingExecuteEngine(final int executorSize) {
</span></span><span class="line"><span class="cl">    shardingExecutorService = new ShardingExecutorService(executorSize);
</span></span><span class="line"><span class="cl">    executorService = shardingExecutorService.getExecutorService();
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>1.ExecutorService</p>
<p>如上所示，我们可以看出，这里有两个以 ExecutorService 结尾的变量，显然从命名上不难看出它们都是执行器服务，与 JDK 中的 java.util.concurrent.ExecutorService 类似。其中ListeningExecutorService来自 Google 的工具包 Guava；而ShardingExecutorService是 ShardingSphere 中的自定义类，包含了 ListeningExecutorService 的构建过程。接下来我们对两者分别展开讲述。</p>
<p>ShardingExecutorService</p>
<p>我们发现 ShardingExecutorService 包含了一个 JDK 的 ExecutorService，它的创建过程如下，这里用到的 newCachedThreadPool 和 newFixedThreadPool 都是 JDK 提供的常见方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private ExecutorService getExecutorService(final int executorSize, final String nameFormat) {
</span></span><span class="line"><span class="cl">    ThreadFactory shardingThreadFactory = ShardingThreadFactoryBuilder.build(nameFormat);
</span></span><span class="line"><span class="cl">    return 0 == executorSize ? Executors.newCachedThreadPool(shardingThreadFactory) : Executors.newFixedThreadPool(executorSize, shardingThreadFactory);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>ListeningExecutorService</p>
<p>由于 JDK 中普通线程池返回的 Future 功能比较单一，所以 Guava 提供了 ListeningExecutorService 对其进行装饰。我们可以通过 ListeningExecutorService 对 ExecutorService 做一层包装，返回一个 ListenableFuture 实例，而 ListenableFuture 又是继承自 Future，扩展了一个 addListener 监听方法，这样当任务执行完成就会主动回调该方法。ListeningExecutorService 的构建过程如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">executorService = MoreExecutors.listeningDecorator(getExecutorService(executorSize, nameFormat));
</span></span><span class="line"><span class="cl">oreExecutors.addDelayedShutdownHook(executorService, 60, TimeUnit.SECONDS);
</span></span></code></pre></td></tr></table>
</div>
</div><p>明确了执行器 ExecutorService 之后，我们回到 ShardingExecuteEngine 类，该类以 groupExecute 方法为入口，这个方法参数比较多，也单独都列了一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/** 
</span></span><span class="line"><span class="cl"> * @param inputGroups：输入组
</span></span><span class="line"><span class="cl"> * @param firstCallback：第一次分片执行回调
</span></span><span class="line"><span class="cl"> * @param callback：分片执行回调
</span></span><span class="line"><span class="cl"> * @param serial：是否使用多线程进行执行
</span></span><span class="line"><span class="cl"> * @param &lt;I&gt;：输入值类型
</span></span><span class="line"><span class="cl"> * @param &lt;O&gt;：返回值类型
</span></span><span class="line"><span class="cl"> * @return 执行结果
</span></span><span class="line"><span class="cl"> * @throws SQLException：抛出异常
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">public &lt;I, O&gt; List&lt;O&gt; groupExecute(
</span></span><span class="line"><span class="cl">    final Collection&lt;ShardingExecuteGroup&lt;I&gt;&gt; inputGroups, final ShardingGroupExecuteCallback&lt;I, O&gt; firstCallback, final ShardingGroupExecuteCallback&lt;I, O&gt; callback, final boolean serial)
</span></span><span class="line"><span class="cl">    throws SQLException {
</span></span><span class="line"><span class="cl">    if (inputGroups.isEmpty()) {
</span></span><span class="line"><span class="cl">        return Collections.emptyList();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return serial ? serialExecute(inputGroups, firstCallback, callback) : parallelExecute(inputGroups, firstCallback, callback);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的分片执行组 ShardingExecuteGroup 对象实际上就是一个包含输入信息的列表，而上述 groupExecute 方法的输入是一个 ShardingExecuteGroup 的集合。通过判断输入参数 serial 是否为 true，上述代码流程分别转向了serialExecute 和 parallelExecute 这两个代码分支，接下来我来分别讲解一下这两个代码分支。</p>
<p>2.SerialExecute</p>
<p>我们先来看 serialExecute 方法，顾名思义，该方法用于串行执行的场景：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private &lt;I, O&gt; List&lt;O&gt; serialExecute(final Collection&lt;ShardingExecuteGroup&lt;I&gt;&gt; inputGroups, final ShardingGroupExecuteCallback&lt;I, O&gt; firstCallback,
</span></span><span class="line"><span class="cl">                                     final ShardingGroupExecuteCallback&lt;I, O&gt; callback) throws SQLException {
</span></span><span class="line"><span class="cl">    Iterator&lt;ShardingExecuteGroup&lt;I&gt;&gt; inputGroupsIterator = inputGroups.iterator();
</span></span><span class="line"><span class="cl">    //获取第一个输入的ShardingExecuteGroup
</span></span><span class="line"><span class="cl">    ShardingExecuteGroup&lt;I&gt; firstInputs = inputGroupsIterator.next();
</span></span><span class="line"><span class="cl">    //通过第一个回调 firstCallback 完成同步执行的 syncGroupExecute
</span></span><span class="line"><span class="cl">    List&lt;O&gt; result = new LinkedList&lt;&gt;(syncGroupExecute(firstInputs, null == firstCallback ? callback : firstCallback));
</span></span><span class="line"><span class="cl">    //对剩下的 ShardingExecuteGroup，通过回调 callback 逐个同步执行 syncGroupExecute
</span></span><span class="line"><span class="cl">    for (ShardingExecuteGroup&lt;I&gt; each : Lists.newArrayList(inputGroupsIterator)) {
</span></span><span class="line"><span class="cl">        result.addAll(syncGroupExecute(each, callback));
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return result;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码的基本流程是获取第一个输入的 ShardingExecuteGroup，通过第一个回调 firstCallback 完成同步执行的 syncGroupExecute 方法。然后对剩下的 ShardingExecuteGroup，通过回调 callback 逐个执行 syncGroupExecute 方法。这里的 syncGroupExecute 方法如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private &lt;I, O&gt; Collection&lt;O&gt; syncGroupExecute(final ShardingExecuteGroup&lt;I&gt; executeGroup, final ShardingGroupExecuteCallback&lt;I, O&gt; callback) throws SQLException {
</span></span><span class="line"><span class="cl">        return callback.execute(executeGroup.getInputs(), true, ShardingExecuteDataMap.getDataMap());
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们看到同步执行的过程实际上是交给了 ShardingGroupExecuteCallback 回调接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public interface ShardingGroupExecuteCallback&lt;I, O&gt; {
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    Collection&lt;O&gt; execute(Collection&lt;I&gt; inputs, boolean isTrunkThread, Map&lt;String, Object&gt; shardingExecuteDataMap) throws SQLException;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的 ShardingExecuteDataMap 相当于一个用于 SQL 执行的数据字典，这些数据字典保存在 ThreadLocal 中，从而确保了线程安全。我们可以根据当前的执行线程获取对应的 DataMap 对象。</p>
<p>3.ParallelExecute</p>
<p>这样，关于串行执行的流程就介绍完了，接下来我们来看并行执行的 parallelExecute 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private &lt;I, O&gt; List&lt;O&gt; parallelExecute(final Collection&lt;ShardingExecuteGroup&lt;I&gt;&gt; inputGroups, final ShardingGroupExecuteCallback&lt;I, O&gt; firstCallback,
</span></span><span class="line"><span class="cl">                                       final ShardingGroupExecuteCallback&lt;I, O&gt; callback) throws SQLException {
</span></span><span class="line"><span class="cl">    Iterator&lt;ShardingExecuteGroup&lt;I&gt;&gt; inputGroupsIterator = inputGroups.iterator();
</span></span><span class="line"><span class="cl">    //获取第一个输入的 ShardingExecuteGroup
</span></span><span class="line"><span class="cl">    ShardingExecuteGroup&lt;I&gt; firstInputs = inputGroupsIterator.next();
</span></span><span class="line"><span class="cl">    //通过 asyncGroupExecute 执行异步回调
</span></span><span class="line"><span class="cl">    Collection&lt;ListenableFuture&lt;Collection&lt;O&gt;&gt;&gt; restResultFutures = asyncGroupExecute(Lists.newArrayList(inputGroupsIterator), callback);
</span></span><span class="line"><span class="cl">    //获取执行结果并组装返回
</span></span><span class="line"><span class="cl">    return getGroupResults(syncGroupExecute(firstInputs, null == firstCallback ? callback : firstCallback), restResultFutures);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意到这里有一个异步执行方法 asyncGroupExecute，传入参数是一个 ShardingExecuteGroup 列表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private &lt;I, O&gt; Collection&lt;ListenableFuture&lt;Collection&lt;O&gt;&gt;&gt; asyncGroupExecute(final List&lt;ShardingExecuteGroup&lt;I&gt;&gt; inputGroups, final ShardingGroupExecuteCallback&lt;I, O&gt; callback) {
</span></span><span class="line"><span class="cl">    Collection&lt;ListenableFuture&lt;Collection&lt;O&gt;&gt;&gt; result = new LinkedList&lt;&gt;();
</span></span><span class="line"><span class="cl">    for (ShardingExecuteGroup&lt;I&gt; each : inputGroups) {
</span></span><span class="line"><span class="cl">        result.add(asyncGroupExecute(each, callback));
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return result;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个方法中针对每个传入的 ShardingExecuteGroup，再次调用一个重载的异步 asyncGroupExecute 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private &lt;I, O&gt; ListenableFuture&lt;Collection&lt;O&gt;&gt; asyncGroupExecute(final ShardingExecuteGroup&lt;I&gt; inputGroup, final ShardingGroupExecuteCallback&lt;I, O&gt; callback) {
</span></span><span class="line"><span class="cl">    final Map&lt;String, Object&gt; dataMap = ShardingExecuteDataMap.getDataMap();
</span></span><span class="line"><span class="cl">    return executorService.submit(new Callable&lt;Collection&lt;O&gt;&gt;() {
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        @Override
</span></span><span class="line"><span class="cl">        public Collection&lt;O&gt; call() throws SQLException {
</span></span><span class="line"><span class="cl">            return callback.execute(inputGroup.getInputs(), false, dataMap);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    });
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>显然，作为异步执行方法，这里就会使用 Guava 的 ListeningExecutorService 来提交一个异步执行的任务并返回一个 ListenableFuture，而这个异步执行的任务就是具体的回调。</p>
<p>最后，我们来看 parallelExecute 方法的最后一句，即调用 getGroupResults 方法获取执行结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private &lt;O&gt; List&lt;O&gt; getGroupResults(final Collection&lt;O&gt; firstResults, final Collection&lt;ListenableFuture&lt;Collection&lt;O&gt;&gt;&gt; restFutures) throws SQLException {
</span></span><span class="line"><span class="cl">        List&lt;O&gt; result = new LinkedList&lt;&gt;(firstResults);
</span></span><span class="line"><span class="cl">        for (ListenableFuture&lt;Collection&lt;O&gt;&gt; each : restFutures) {
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                result.addAll(each.get());
</span></span><span class="line"><span class="cl">            } catch (final InterruptedException | ExecutionException ex) {
</span></span><span class="line"><span class="cl">                return throwException(ex);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return result;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>熟悉 Future 用法的同学对上述代码应该不会陌生，我们遍历 ListenableFuture，然后调动它的 get 方法同步等待返回结果，最后当所有的结果都获取到之后组装成一个结果列表并返回，这种写法在使用 Future 时非常常见。</p>
<p>我们回过头来看，无论是 serialExecute 方法还是 parallelExecute 方法，都会从 ShardingExecuteGroup 中获取第一个 firstInputs 元素并进行执行，然后剩下的再进行同步或异步执行。ShardingSphere 这样使用线程的背后有其独特的设计思路。考虑到当前线程同样也是一种可用资源，让第一个任务由当前线程进行执行就可以充分利用当前线程，从而最大化线程的利用率。</p>
<p>至此，关于 ShardingExecuteEngine 类的介绍就告一段落。作为执行引擎，ShardingExecuteEngine 所做的事情就是提供一个多线程的执行环境。在系统设计上，这也是在日常开发过程中可以参考的一个技巧。我们可以设计并实现一个多线程执行环境，这个环境不需要完成具体的业务操作，而只需要负责执行传入的回调函数。ShardingSphere 中的ShardingExecuteEngine 就是提供了这样一种环境，同样的实现方式在其他诸如 Spring 等开源框架中也都可以看到。</p>
<p>接下来，就让我们来看一下 ShardingSphere 如何通过回调完成 SQL 的真正执行。</p>
<p>回调接口 ShardingGroupExecuteCallback</p>
<p>回调接口 ShardingGroupExecuteCallback 的定义非常简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public interface ShardingGroupExecuteCallback&lt;I, O&gt; {
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    Collection&lt;O&gt; execute(Collection&lt;I&gt; inputs, boolean isTrunkThread, Map&lt;String, Object&gt; shardingExecuteDataMap) throws SQLException;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>该接口根据传入的泛型 inputs 集合和 shardingExecuteDataMap 完成真正的 SQL 执行操作。在 ShardingSphere 中，使用匿名方法实现 ShardingGroupExecuteCallback 接口的地方有很多，但显式实现这一接口的只有一个类，即 SQLExecuteCallback 类，这是一个抽象类，它的 execute 方法如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@Override
</span></span><span class="line"><span class="cl">public final Collection&lt;T&gt; execute(final Collection&lt;StatementExecuteUnit&gt; statementExecuteUnits, 
</span></span><span class="line"><span class="cl">                                   final boolean isTrunkThread, final Map&lt;String, Object&gt; shardingExecuteDataMap) throws SQLException {
</span></span><span class="line"><span class="cl">    Collection&lt;T&gt; result = new LinkedList&lt;&gt;();
</span></span><span class="line"><span class="cl">    for (StatementExecuteUnit each : statementExecuteUnits) {
</span></span><span class="line"><span class="cl">        result.add(execute0(each, isTrunkThread, shardingExecuteDataMap));
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return result;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于每个输入的 StatementExecuteUnit 数据结构，上述 execute 方法会进一步执行一个 execute0 方法，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private T execute0(final StatementExecuteUnit statementExecuteUnit, final boolean isTrunkThread, final Map&lt;String, Object&gt; shardingExecuteDataMap) throws SQLException {
</span></span><span class="line"><span class="cl">    //设置 ExecutorExceptionHandler
</span></span><span class="line"><span class="cl">     ExecutorExceptionHandler.setExceptionThrown(isExceptionThrown);
</span></span><span class="line"><span class="cl">    //获取 DataSourceMetaData，这里用到了缓存机制
</span></span><span class="line"><span class="cl">     DataSourceMetaData dataSourceMetaData = getDataSourceMetaData(statementExecuteUnit.getStatement().getConnection().getMetaData());
</span></span><span class="line"><span class="cl">    //初始化 SQLExecutionHook
</span></span><span class="line"><span class="cl">     SQLExecutionHook sqlExecutionHook = new SPISQLExecutionHook();
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            RouteUnit routeUnit = statementExecuteUnit.getRouteUnit();
</span></span><span class="line"><span class="cl">            //启动执行钩子
</span></span><span class="line"><span class="cl">            sqlExecutionHook.start(routeUnit.getDataSourceName(), routeUnit.getSqlUnit().getSql(), routeUnit.getSqlUnit().getParameters(), dataSourceMetaData, isTrunkThread, shardingExecuteDataMap);
</span></span><span class="line"><span class="cl">            //执行 SQL
</span></span><span class="line"><span class="cl">            T result = executeSQL(routeUnit.getSqlUnit().getSql(), statementExecuteUnit.getStatement(), statementExecuteUnit.getConnectionMode());
</span></span><span class="line"><span class="cl">            //成功钩子
</span></span><span class="line"><span class="cl">            sqlExecutionHook.finishSuccess();
</span></span><span class="line"><span class="cl">            return result;
</span></span><span class="line"><span class="cl">        } catch (final SQLException ex) {
</span></span><span class="line"><span class="cl">            //失败钩子
</span></span><span class="line"><span class="cl">            sqlExecutionHook.finishFailure(ex);
</span></span><span class="line"><span class="cl">            //异常处理
</span></span><span class="line"><span class="cl">            ExecutorExceptionHandler.handleException(ex);
</span></span><span class="line"><span class="cl">            return null;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">	}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码每一句的含义都比较明确，这里引入了一个 ExecutorExceptionHandler 用于异常处理，同时也引入了一个 SPISQLExecutionHook 对执行过程嵌入钩子。关于基于 SPI 机制的 Hook 实现机制，我们在前面的 SQL 解析和路由引擎中已经看到过很多次，这里不再赘述。我们看到，真正执行 SQL 的过程是交给 executeSQL 模板方法进行完成，需要 SQLExecuteCallback 的各个子类实现这一模板方法。</p>
<p>在 ShardingSphere 中，没有提供任何的 SQLExecuteCallback 实现类，但大量采用匿名方法来完成 executeSQL 模板方法的实现。例如，在下一课时《22 | 执行引擎：如何把握 ShardingSphere 中的 Executor 执行模型？（上）》的 StatementExecutor 类中，executeQuery 方法就创建了一个 SQLExecuteCallback 匿名实现方法，用来完成查询操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public List&lt;QueryResult&gt; executeQuery() throws SQLException {
</span></span><span class="line"><span class="cl">final boolean isExceptionThrown = ExecutorExceptionHandler.isExceptionThrown();
</span></span><span class="line"><span class="cl">//创建 SQLExecuteCallback 并执行查询
</span></span><span class="line"><span class="cl">SQLExecuteCallback&lt;QueryResult&gt; executeCallback = new SQLExecuteCallback&lt;QueryResult&gt;(getDatabaseType(), isExceptionThrown) {
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected QueryResult executeSQL(final String sql, final Statement statement, final ConnectionMode connectionMode) throws SQLException {
</span></span><span class="line"><span class="cl">        return getQueryResult(sql, statement, connectionMode);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">//执行 SQLExecuteCallback 并返回结果
</span></span><span class="line"><span class="cl">return executeCallback(executeCallback);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>模板类 SQLExecuteTemplate</p>
<p>在 ShardingSphere 执行引擎的底层组件中，还有一个类需要展开，这就是模板类 SQLExecuteTemplate，它是 ShardingExecuteEngine 的直接使用者。从命名上看，这是一个典型的模板工具类，定位上就像 Spring 中的 JdbcTemplate 一样。但凡这种模板工具类，其实现一般都比较简单，基本就是对底层对象的简单封装。</p>
<p>SQLExecuteTemplate 也不例外，它要做的就是对 ShardingExecuteEngine 中的入口方法进行封装和处理。ShardingExecuteEngine 的核心方法就只有一个，即 executeGroup 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">executeGroup</span><span class="p">(</span><span class="n">final</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">ShardingExecuteGroup</span><span class="o">&lt;</span><span class="err">?</span> <span class="k">extends</span> <span class="n">StatementExecuteUnit</span><span class="o">&gt;&gt;</span> <span class="n">sqlExecuteGroups</span><span class="p">,</span> <span class="n">final</span> <span class="n">SQLExecuteCallback</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">firstCallback</span><span class="p">,</span> <span class="n">final</span> <span class="n">SQLExecuteCallback</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">callback</span><span class="p">)</span> <span class="n">throws</span> <span class="n">SQLException</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">executeEngine</span><span class="o">.</span><span class="n">groupExecute</span><span class="p">((</span><span class="n">Collection</span><span class="p">)</span> <span class="n">sqlExecuteGroups</span><span class="p">,</span> <span class="n">firstCallback</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">serial</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="n">final</span> <span class="n">SQLException</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ExecutorExceptionHandler</span><span class="o">.</span><span class="n">handleException</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Collections</span><span class="o">.</span><span class="n">emptyList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，这个方法所做的事情就是直接调用 ShardingExecuteEngine 的 groupExecute 方法完成具体的执行工作，并添加了异常处理机制而已。</p>
<p>从源码解析到日常开发</p>
<p>我们可以从今天的内容中，提炼出来许多技巧，并应用于日常开发过程中。比较实用的一个技巧是：我们可以使用 Guava 提供的 ListeningExecutorService 来强化 JDK 中基于普通 Future 的执行器服务 ExecutorService。同时，我们也看到了基于 Callback 的系统扩展机制，我们可以基于这种扩展机制，构建一个独立的运行环境，从而把与业务相关的所有操作通过回调得以实现。</p>
<p>小结与预告</p>
<p>本课时是介绍 ShardingSphere 执行引擎的第一部分内容，介绍了分片环境下 SQL 执行流程的抽象过程。我们先引出了执行引擎这个核心类，然后分别从执行器服务、执行回调以及执行模板类等维度对整个执行流程展开了详细讲述。</p>
<p>最后这里给你留一道思考题：在基于多线程技术实现 Executor 时，ShardingSphere 应用了哪些技巧？欢迎你在留言区与大家讨论，我将 一 一 点评解答。</p>
<p>下一课时，我们继续介绍 ShardingSphere 的执行引擎，我们将重点关注 SQL 的执行器 StatementExecutor。</p>
<p>-&ndash; ### 精选评论 ##### **健： &gt; 考虑到当前线程同样也是一种可用资源，让第一个任务由当前线程进行执行就可以充分利用当前线程，从而最大化线程的利用率。这个考虑很细心 ######     讲师回复： &gt;     对的，这个是设计上的一个亮点 ##### **辉： &gt; 个人感觉，老师应该多讲思想，原理和架构，代码不用太详细，只用关注核心类就行。 ######     讲师回复： &gt;     对的，ShardingSphere中分片引擎这块的代码实现比较复杂，目前代码的实现实际上讲的已经比较精炼了，很多细节没有展开，而思想和原理很多地方也都点到了</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/shardingsphere%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%B2%BE%E8%AE%B2/">ShardingSphere核心原理精讲</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/21%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%E5%A6%82%E4%BD%95%E5%8F%96%E5%BE%97%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E7%9A%84%E5%B9%B3%E8%A1%A1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">21知识串讲：如何取得性能和可扩展性的平衡？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF%E5%A6%82%E4%BD%95%E8%AE%A9%E8%A7%A3%E9%A2%98%E5%8F%98%E6%88%90%E6%90%AD%E7%A7%AF%E6%9C%A8/">
            <span class="next-text nav-default">22 数据结构模板：如何让解题变成搭积木？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
