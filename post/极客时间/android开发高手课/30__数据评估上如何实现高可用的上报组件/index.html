<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>30__数据评估（上）：如何实现高可用的上报组件？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="无论是“高效测试”中的实时监控，还是“版本发布”中的数据校验平台，我都多次提到了数据的重要性。
对于数据评估，我们的期望是“又快又准”。“快”，表示数据的时效性。我们希望在 1 小时内，甚至 1 分钟内就可以对数据进行评估，而不需要等上 1 天或者几天。“准”，表示数据的准确性，保证数据可以反映业务的真实情况，不会因为数据不准确导致做出错误的产品决策。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/30__%E6%95%B0%E6%8D%AE%E8%AF%84%E4%BC%B0%E4%B8%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E4%B8%8A%E6%8A%A5%E7%BB%84%E4%BB%B6/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/30__%E6%95%B0%E6%8D%AE%E8%AF%84%E4%BC%B0%E4%B8%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E4%B8%8A%E6%8A%A5%E7%BB%84%E4%BB%B6/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="30__数据评估（上）：如何实现高可用的上报组件？">
  <meta property="og:description" content="无论是“高效测试”中的实时监控，还是“版本发布”中的数据校验平台，我都多次提到了数据的重要性。
对于数据评估，我们的期望是“又快又准”。“快”，表示数据的时效性。我们希望在 1 小时内，甚至 1 分钟内就可以对数据进行评估，而不需要等上 1 天或者几天。“准”，表示数据的准确性，保证数据可以反映业务的真实情况，不会因为数据不准确导致做出错误的产品决策。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Android开发高手课">

  <meta itemprop="name" content="30__数据评估（上）：如何实现高可用的上报组件？">
  <meta itemprop="description" content="无论是“高效测试”中的实时监控，还是“版本发布”中的数据校验平台，我都多次提到了数据的重要性。
对于数据评估，我们的期望是“又快又准”。“快”，表示数据的时效性。我们希望在 1 小时内，甚至 1 分钟内就可以对数据进行评估，而不需要等上 1 天或者几天。“准”，表示数据的准确性，保证数据可以反映业务的真实情况，不会因为数据不准确导致做出错误的产品决策。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="3877">
  <meta itemprop="keywords" content="Android开发高手课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="30__数据评估（上）：如何实现高可用的上报组件？">
  <meta name="twitter:description" content="无论是“高效测试”中的实时监控，还是“版本发布”中的数据校验平台，我都多次提到了数据的重要性。
对于数据评估，我们的期望是“又快又准”。“快”，表示数据的时效性。我们希望在 1 小时内，甚至 1 分钟内就可以对数据进行评估，而不需要等上 1 天或者几天。“准”，表示数据的准确性，保证数据可以反映业务的真实情况，不会因为数据不准确导致做出错误的产品决策。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">30__数据评估（上）：如何实现高可用的上报组件？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 3877 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#统一高可用的上报组件">统一高可用的上报组件</a></li>
        <li><a href="#数据自监控">数据自监控</a></li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#课后作业">课后作业</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>无论是“高效测试”中的实时监控，还是“版本发布”中的数据校验平台，我都多次提到了数据的重要性。</p>
<p>对于数据评估，我们的期望是“又快又准”。“快”，表示数据的时效性。我们希望在 1 小时内，甚至 1 分钟内就可以对数据进行评估，而不需要等上 1 天或者几天。“准”，表示数据的准确性，保证数据可以反映业务的真实情况，不会因为数据不准确导致做出错误的产品决策。</p>
<p>但是“巧妇难为无米之炊”，数据平台的准确性和时效性依赖客户端数据采集和上报的能力。那应该如何保证客户端上报组件的实时性和准确性？如何实现一个“高可用”的上报组件呢？</p>
<h2 id="统一高可用的上报组件">统一高可用的上报组件</h2>
<p>可能有同学会疑惑，究竟什么是“高可用”的上报组件？我认为至少需要达到三个目标：</p>
<ul>
<li><strong>数据不会丢失</strong>。数据不会由于应用崩溃、被系统杀死这些异常情况而导致丢失。</li>
<li><strong>实时性高</strong>。无论是前台进程还是后台进程，所有的数据都可以在短时间内及时上报。</li>
<li><strong>高性能</strong>。这里主要有卡顿和流量两个维度，应用不能因为上报组件的 CPU 和 I/O 过度占用导致卡顿，也不能因为设计不合理导致用户的流量消耗过多。</li>
</ul>
<p>但是数据的完整性、实时性和性能就像天平的两端，我们无法同时把这三者都做到最好。因此我们只能在兼顾性能的同时，尽可能地保证数据不会丢失，让上报延迟更小。</p>
<p>在“网络优化”中，我不止一次的提到网络库的统一。网络库作为一个重要的基础组件，无论是应用内不同的业务，还是 Android 和 iOS 多端，都应该用同一个网络库。</p>
<p>同理，上报组件也是应用重要的基础组件，我们希望打造的是统一并且高可用的上报组件。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/3a69d245dc0e391aed79b58801f0a382.png" alt=""></p>
<p>一个数据埋点的过程，主要包括采样、存储、上报以及容灾这四个模块，下面我来依次拆解各个模块，一起看看其中的难点。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/99f0d4a50dcee8beb8f72db9ad30715f.png" alt=""></p>
<p><strong>1. 采样模块</strong></p>
<p>某些客户端数据量可能会非常大，我们并不需要将它们全部都上报到后台。比如说卡顿和内存这些性能数据，我们只需要抽取小部分用户统计就可以了。</p>
<p>采样模块是很多同学在设计时容易忽视的，但它却是所有模块中最为复杂的一项，需要考虑下面一些策略的选择。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/b16583746177b5e2e6952ecddb2f524b.png" alt=""></p>
<p>大多数的组件采用的都是 PV 次数采样，这样的确是最简单的。但是我们更多是在性能数据埋点上采样，为了降低用户的影响面，我更加倾向于使用 UV 采样的方式。而且为了可以让更多的用户上报，我也希望每天都可以更换一批新的用户。</p>
<p>最终我选择的方案是“UV 采样 + 用户标识随机 + 每日更换用户”的方式，但是采样还需要满足三个标准。</p>
<ul>
<li><strong>准确性</strong>。如果配置了 1% 的采样比例，需要保证某一时刻只有 1% 的用户会上报这个数据。</li>
<li><strong>均匀性</strong>。如果配置了 1% 的采样比例，每天都会更换不同的 1% 用户来上报这个数据。</li>
<li><strong>切换的平滑性</strong>。用户的切换需要平滑，不能在用一个时间例如 12 点，所有用户同时切换，这样会导致后台数据不连贯。</li>
</ul>
<p>实现上面这三个标准并不容易，在微信中我们采用了下面这个算法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// id：用户标识，例如微信号、QQ 号
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">id_index = Hash(id) % 采样率倒数
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">time_index = (unix_timestamp / (24*60*60)) % 采样率倒数
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">上报用户 =（id_index == time_index）
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个采样持续 24 小时，使整个切换可以很平滑，不会出现所有用户同时在 0 点更换采样策略。有些用户在早上 10 点切换，有些用户在 11 点切换，会分摊到 24 小时中。并且从一个小时或者一天的维度来看，也都可以保证采样是准确的。</p>
<p>不同的埋点可以设置不同的采样率，它们之间是独立的、互不影响的。当然除了采样率，在采样策略里我们还可以增加其他的控制参数，例如：</p>
<ul>
<li><strong>上报间隔</strong>：可以配置每个埋点的上报间隔，例如 1 秒、1 分钟、10 分钟、60 分钟等。</li>
<li><strong>上报网络</strong>：控制某些点只允许 WiFi 上传。</li>
</ul>
<p><strong>2. 存储模块</strong></p>
<p>对于存储模块，我们的目标是在兼顾性能的同时，保证数据完全不会丢失。那应该如何实现呢？我们首先要思考进程和存储模式的选择。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/e91961484060672302ef1b3b27cf2509.png" alt=""></p>
<p>业内最常见的上报组件是“单进程写 + 文件存储 + 内存缓存”，虽然这种方式实现最为简单，但是无论是跨进程的 IPC 调用堆积（IPC 调用总是很慢的）还是内存缓存，都可能会导致数据的丢失。</p>
<p>回顾一下在“I/O 优化”中，我列出的 mmap、内存与写文件的性能对比数据。</p>
<p>​<img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/0b4a4c839450642083d497667f9678da.png" alt=""></p>
<p>你可以看到 mmap 的性能非常不错，所以我们最终选择的是 <strong>“多进程写 + mmap”的方案，并且完全抛弃了内存缓存</strong>。不过 mmap 的性能也并不完美，它在某些时刻依然会出现异步落盘，所以每个进程 mmap 操作需要放到单独的线程中处理。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/a4c8469b8d25f89d5280c2073bcf95f0.png" alt=""></p>
<p><strong>“多进程写 + mmap”的方案可以实现完全无锁、无 IPC 并且数据基本不会丢失</strong>，看上去简直完美，但是真正实现时是不是像图中那么简单呢？肯定不会那么简单，因为我们需要考虑埋点数据的聚合以及上报数据优先级。</p>
<ul>
<li><strong>埋点数据的聚合</strong>。为了减少上报的数据量，尤其是部分性能埋点，我们需要支持聚合上报。大部分组件都是使用上报时聚合的方式，但是这样无法解决存储时的数据量问题。由于我们使用的是 mmap，可以像操作内存一样操作文件中的数据，可以实现性能更优的埋点数据的聚合功能。</li>
<li><strong>上报数据优先级</strong>。很多上报组件埋点时都会使用一个是否重要的参数，对于重要的数据采用直接落地的方式。对于我们的方案来说，已经默认所有的数据都是重要的。关于上报数据的优先级，我建议使用上报间隔来区分，例如 1 分钟、10 分钟或者 1 小时。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/63b254e1b6b5dc1eeb2f6a08e63adbe9.png" alt=""></p>
<p>对于一些敏感数据，可能还需要支持加密。对于加密的数据，我建议使用单独的另一个 mmap 文件存储。</p>
<p>为什么上面我说的是数据基本不会丢失，而不是完全不会丢失呢？因为当数据还没有 mmap 落盘，也就是处于采样、存储内部逻辑时，这个时候如果应用崩溃依然会造成数据丢失。为了减少这种情况发生，我们做了两个优化。</p>
<ul>
<li><strong>精简处理逻辑</strong>。尽量减少每个埋点的处理耗时，每个埋点的数据处理时间需要压缩到 0.1 毫秒以内。</li>
<li><strong>KillProcess 等待</strong>。在应用主动 KillProcess 之前，需要调用单独的函数，先等待所有队列中的埋点处理完毕。</li>
</ul>
<p><strong>3. 上报模块</strong></p>
<p>对于上报模块，我们不仅需要满足上报实时性，还需要合理地优化流量的使用，主要需要考虑的策略有：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/370a3a69ea9b4e390982611bda8155c6.png" alt=""></p>
<p>为了解决后台进程的上报实时性问题，我们采用了单进程上报的策略，我推荐使用保活能力比较强的进程作为唯一的上报进程。为了更加精细地控制上报间隔，我们采用更加复杂的班车制度模式。</p>
<p>后来经过仔细思考，最终的上报模块采用“多进程写 + 单进程上报”。这里有一个难点，那就是如何及时的收集所有已经停止的班车，会不会出现多进程同步的问题呢？我们是通过 Linux 的文件 rename 的原子性以及 FileObserver 机制，实现了一套完全无锁、高性能的文件同步模型。</p>
<p>每个进程在对应优先级的文件“停车”的时候，负责把文件 rename 到上报数据存放的目录中。因为 rename 是原子操作，所以不用担心两个进程会同时操作到同一个文件。而对应的上报进程只需要监听上报数据目录的变化，就可以实现文件状态的同步。这样就避免了多进程同步操作同一个文件的问题，整个过程也无需使用到跨进程的锁。</p>
<p>当然上报模块里的坑还有很多很多，例如合并上报文件时应该优先选择高优先级的文件；对于上报的包大小，在移动网络需要设置的比 WiFi 小一些，而不同优先级的文件需要合并组包，尽量吃满带宽；而且在弱网络的时候，我们需要把数据包设置得更小一些，先上报最高优先级的数据。</p>
<p><strong>4. 容灾模块</strong></p>
<p>虽然我们设计得上报模块已经很强大，但是如果使用者调用不合理，也可能会导致严重的性能问题。我曾经遇到过，某个同学在一个 for 循环连续埋了一百万个点；还有一次是某个用户因为长期没有网络，导致本地堆积了大量的数据。</p>
<p>一个强大的组件，它还需要具备容灾的能力，本地一般可以有下面这些策略。</p>
<p>​<img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/9069f62d31f4d6c4889abe64f08af19d.png" alt=""></p>
<p>容灾模块主要是保证即使出现开发者使用错误、组件内部异常等情况，也不会给用户的存储空间以及流量造成严重问题。</p>
<h2 id="数据自监控">数据自监控</h2>
<p>通过“多进程写 + mmap + 后台进程上报 + 班车模式”，我们实现了一套完全无锁、数据基本不会丢失、无跨进程 IPC 调用的高性能上报组件，并且通过容灾机制，它还可以实现异常情况的自动恢复。</p>
<p>那线上效果是不是真的这么完美？我们怎样确保上报组件的数据可靠性和时效性呢？答案依然是<strong>监控</strong>，我们需要建立一套完善的自监控体系，为后续进一步优化提供可靠的数据支撑。</p>
<p><strong>1. 质量监控</strong></p>
<p>上报组件的核心数据指标主要包括以下几个：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/08910966bf96c88e6bbd91115a66ca7d.png" alt=""></p>
<p>当然，如果我们追求更高的实时性，可以选择计算小时到达率，甚至是分钟到达率。</p>
<p><strong>2. 容灾监控</strong></p>
<p>当客户端出现容灾处理时，我们也会将数据单独上报到后台监控起来。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/5fdf936f1db5599eb8778a7ef22c550c.png" alt=""></p>
<p>除了异常情况的监控，我们还希望将用户每日使用的移动流量和 WiFi 流量做更加细粒度的分区间监控，例如 0～1MB 的占比、1～5MB 的占比等。</p>
<h2 id="总结">总结</h2>
<p>网络和数据都是非常重要的基础组件，今天我们一起打造了一款跨平台、高可用的上报组件。这也是目前比较先进的方案，在各方面的质量指标都比传统的方案有非常大的提升。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/4b42352c4835305568ce611ab6881d84.png" alt=""></p>
<p>当然真正落实到编码，这里面还有非常多的细节需要考虑，也还有大大小小很多暗坑。而且虽然我们使用 C++ 实现，但是也还需要处理不同平台的些许差异，比如 iOS 根本不需要考虑多进程问题等。</p>
<p>在实践中我的体会是，当我们亲自动手去实现一个网络库或者上报组件的时候，才会深深体会到把一个新东西做出来并不困难，但是如果想要做到极致，那必然需要经过精雕细琢，更需要经过长时间的迭代和优化。</p>
<h2 id="课后作业">课后作业</h2>
<p>你所在的公司，目前正在使用哪个数据上报组件？它存在哪些问题呢？欢迎留言跟我和其他同学一起讨论。</p>
<p>今天的课后作业是，在实现方案中我故意隐去了两个细节点，这里把它们当作课后作业留给你，请你在留言中写下自己的答案。</p>
<p><strong>1. 采样策略的更新</strong>。当我们服务器采样策略更新的时候，如果不使用推送，怎样保证新的采样策略可以以最快速度在客户端生效？<br>
<strong>2. 埋点进程突然崩溃</strong>。你有没有想到，如果 Process A 突然崩溃，那哪个进程、在什么时机、以哪种方式，应该负责把 Process A 对应的埋点数据及时 rename 到上报数据目录？</p>
<p>欢迎你点击“请朋友读”，把今天的内容分享给好友，邀请他一起学习。最后别忘了在评论区提交今天的作业，我也为认真完成作业的同学准备了丰厚的“学习加油礼包”，期待与你一起切磋进步哦。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/0e5461ae1393aa633b672fbee779c7e1.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/">Android开发高手课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/30__%E5%AE%9E%E6%88%98%E4%BA%94%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%94%BB%E5%9B%BE%E7%A8%8B%E5%BA%8F/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">30__实战（五）：怎么设计一个“画图”程序？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/30__%E5%A5%97%E8%B7%AF%E7%AF%87%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BA%E7%B3%BB%E7%BB%9Fi_o%E7%9A%84%E7%93%B6%E9%A2%88%E5%9C%A8%E5%93%AA%E9%87%8C/">
            <span class="next-text nav-default">30__套路篇：如何迅速分析出系统I_O的瓶颈在哪里？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
