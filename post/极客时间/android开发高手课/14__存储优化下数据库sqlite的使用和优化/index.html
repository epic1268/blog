<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>14__存储优化（下）：数据库SQLite的使用和优化 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="我们先来复习一下前面讲到的存储方法的使用场景：少量的 Key Value 数据可以直接使用 SharedPreferences，稍微复杂一些的数据类型也可以通过序列化成 JSON 或者 Protocol Buffers 保存，并且在开发中获取或者修改数据也很简单。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/14__%E5%AD%98%E5%82%A8%E4%BC%98%E5%8C%96%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93sqlite%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BC%98%E5%8C%96/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/14__%E5%AD%98%E5%82%A8%E4%BC%98%E5%8C%96%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93sqlite%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BC%98%E5%8C%96/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="14__存储优化（下）：数据库SQLite的使用和优化">
  <meta property="og:description" content="我们先来复习一下前面讲到的存储方法的使用场景：少量的 Key Value 数据可以直接使用 SharedPreferences，稍微复杂一些的数据类型也可以通过序列化成 JSON 或者 Protocol Buffers 保存，并且在开发中获取或者修改数据也很简单。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Android开发高手课">

  <meta itemprop="name" content="14__存储优化（下）：数据库SQLite的使用和优化">
  <meta itemprop="description" content="我们先来复习一下前面讲到的存储方法的使用场景：少量的 Key Value 数据可以直接使用 SharedPreferences，稍微复杂一些的数据类型也可以通过序列化成 JSON 或者 Protocol Buffers 保存，并且在开发中获取或者修改数据也很简单。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6415">
  <meta itemprop="keywords" content="Android开发高手课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="14__存储优化（下）：数据库SQLite的使用和优化">
  <meta name="twitter:description" content="我们先来复习一下前面讲到的存储方法的使用场景：少量的 Key Value 数据可以直接使用 SharedPreferences，稍微复杂一些的数据类型也可以通过序列化成 JSON 或者 Protocol Buffers 保存，并且在开发中获取或者修改数据也很简单。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">14__存储优化（下）：数据库SQLite的使用和优化</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6415 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#sqlite-的那些事儿">SQLite 的那些事儿</a></li>
        <li><a href="#sqlite-的其他特性">SQLite 的其他特性</a></li>
        <li><a href="#sqlite-的监控">SQLite 的监控</a></li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#课后作业">课后作业</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>我们先来复习一下前面讲到的存储方法的使用场景：少量的 Key Value 数据可以直接使用 SharedPreferences，稍微复杂一些的数据类型也可以通过序列化成 JSON 或者 Protocol Buffers 保存，并且在开发中获取或者修改数据也很简单。</p>
<p>不过这几种方法可以覆盖所有的存储场景吗？数据量在几百上千条这个量级时它们的性能还可以接受，但如果是几万条的微信聊天记录呢？而且如何实现快速地对某几个联系人的数据做增删改查呢？</p>
<p>对于大数据的存储场景，我们需要考虑稳定性、性能和<strong>可扩展性</strong>，这个时候就要轮到今天的“主角”数据库登场了。讲存储优化一定绕不开数据库，而数据库这个主题又非常大，我也知道不少同学学数据库的过程是从入门到放弃。那么考虑到我们大多是从事移动开发的工作，今天我就来讲讲移动端数据库 SQLite 的使用和优化。</p>
<h2 id="sqlite-的那些事儿">SQLite 的那些事儿</h2>
<p>虽然市面上有很多的数据库，但受限于库体积和存储空间，适合移动端使用的还真不多。当然使用最广泛的还是我们今天的主角 SQLite，但同样还是有一些其他不错的选择，例如创业团队的<a href="./realm-java.md">Realm</a>、Google 的<a href="./leveldb.md">LevelDB</a>等。</p>
<p>在国内那么多的移动团队中，微信对 SQLite 的研究可以算是最深入的。这其实是业务诉求导向的，用户聊天记录只会在本地保存，一旦出现数据损坏或者丢失，对用户来说都是不可挽回的。另一方面，微信有很大一批的重度用户，他们有几千个联系人、几千个群聊天，曾经做过一个统计，有几百万用户的数据库竟然大于 1GB。对于这批用户，如何保证他们可以正常地使用微信是一个非常大的挑战。</p>
<p>所以当时微信专门开展了一个重度用户优化的专项。一开始的时候我们集中在 SQLite 使用上的优化，例如表结构、索引等。但很快就发现由于系统版本的不同，SQLite 的实现也有所差异，经常会出现一些兼容性问题，并且也考虑到加密的诉求，我们决定单独引入自己的 SQLite 版本。</p>
<p>“源码在手，天下我有”，从此开启了一条研究数据库的“不归路”。那时我们投入了几个人专门去深入研究 SQLite 的源码，从 SQLite 的 PRAGMA 编译选项、<a href="./s_%5F%5Fbiz=MzAwNDY1ODY2OQ==&amp;mid=2649286603&amp;idx=1&amp;sn=d243dd27f2c6614631241cd00570e853&amp;chksm=8334c349b4434a5fd81809d656bfad6072f075d098cb5663a85823e94fc2363edd28758ab882&amp;mpshare=1&amp;scene=1&amp;srcid=0609GLAeaGGmI4zCHTc2U9ZX.md#rd">Cursor 实现优化</a>，到 SQLite 源码的优化，最后打造出从实验室到线上的整个监控体系。</p>
<p>在 2017 年，我们开源了内部使用的 SQLite 数据库<a href="./wiki.md">WCDB</a>。这里多说两句，看一个开源项目是否靠谱，就看这个项目对产品本身有多重要。微信开源坚持内部与外部使用同一个版本，虽然我现在已经离开了微信团队，但还是欢迎有需要的同学使用 WCDB。</p>
<p>在开始学习前我要提醒你，SQLite 的优化同样也很难通过一两篇文章就把每个细节都讲清楚。今天的内容我选择了一些比较重要的知识点，并且为你准备了大量的参考资料，遇到陌生或者不懂的地方需要结合参考资料反复学习。</p>
<p><strong>1. ORM</strong></p>
<p>坦白说可能很多 BAT 的高级开发工程师都不完全了解 SQLite 的内部机制，也不能正确地写出高效的 SQL 语句。大部分应用为了提高开发效率，会引入 ORM 框架。ORM（Object Relational Mapping）也就是对象关系映射，用面向对象的概念把数据库中表和对象关联起来，可以让我们不用关心数据库底层的实现。</p>
<p>Android 中最常用的 ORM 框架有开源<a href="./greenDAO.md">greenDAO</a>和 Google 官方的<a href="./room.md">Room</a>，那使用 ORM 框架会带来什么问题呢？</p>
<p>使用 ORM 框架真的非常简单，但是简易性是需要牺牲部分执行效率为代价的，具体的损耗跟 ORM 框架写得好不好很有关系。但可能更大的问题是让很多的开发者的思维固化，最后可能连简单的 SQL 语句都不会写了。</p>
<p>那我们的应用是否应该引入 ORM 框架呢？可能程序员天生追求偷懒，为了提高开发效率，应用的确应该引入 ORM 框架。<strong>但是这不能是我们可以不去学习数据库基础知识的理由，只有理解底层的一些机制，我们才能更加得心应手地解决疑难的问题</strong>。</p>
<p>考虑到可以更好的与 Android Jetpack 的组件互动，<a href="./Android-WCDB-%E4%BD%BF%E7%94%A8-Room-ORM-%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.md">WCDB 选择 Room 作为 ORM 框架</a>。</p>
<p><strong>2. 进程与线程并发</strong></p>
<p>如果我们在项目中有使用 SQLite，那么下面这个<a href="./SQLiteDatabaseLockedException.md">SQLiteDatabaseLockedException</a>就是经常会出现的一个问题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">android.database.sqlite.SQLiteDatabaseLockedException: database is locked
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  at android.database.sqlite.SQLiteDatabase.dbopen
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  at android.database.sqlite.SQLiteDatabase.openDatabase
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  at android.database.sqlite.SQLiteDatabase.openDatabase
</span></span></code></pre></td></tr></table>
</div>
</div><p>SQLiteDatabaseLockedException 归根到底是因为并发导致，而 SQLite 的并发有两个维度，一个是多进程并发，一个是多线程并发。下面我们分别来讲一下它们的关键点。</p>
<p><strong>多进程并发</strong></p>
<p>SQLite 默认是支持多进程并发操作的，它通过文件锁来控制多进程的并发。SQLite 锁的粒度并没有非常细，它针对的是整个 DB 文件，内部有 5 个状态，具体你可以参考下面的文章。</p>
<ul>
<li>官方文档：<a href="./lockingv3.md">SQLite locking</a></li>
<li>SQLite 源码分析：<a href="./machining.md">SQLite 锁机制简介</a></li>
<li><a href="./4761814.md">SQLite 封锁机制</a></li>
</ul>
<p>简单来说，多进程可以同时获取 SHARED 锁来读取数据，但是只有一个进程可以获取 EXCLUSIVE 锁来写数据库。对于 iOS 来说可能没有多进程访问数据库的场景，可以把 locking_mode 的默认值改为 EXCLUSIVE。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PRAGMA locking_mode = EXCLUSIVE
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 EXCLUSIVE 模式下，数据库连接在断开前都不会释放 SQLite 文件的锁，从而避免不必要的冲突，提高数据库访问的速度。</p>
<p><strong>多线程并发</strong></p>
<p>相比多进程，多线程的数据库访问可能会更加常见。SQLite 支持多线程并发模式，需要开启下面的配置，当然系统 SQLite 会默认开启多线程<a href="./threadsafe.md">Multi-thread 模式</a>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PRAGMA SQLITE_THREADSAFE = 2
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>跟多进程的锁机制一样，为了实现简单，SQLite 锁的粒度都是数据库文件级别，并没有实现表级甚至行级的锁</strong>。还有需要说明的是，<strong>同一个句柄同一时间只有一个线程在操作</strong>，这个时候我们需要打开连接池 Connection Pool。</p>
<p>如果使用 WCDB 在初始化的时候可以指定连接池的大小，在微信中我们设置的大小是 4。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public static SQLiteDatabase openDatabase (String path, 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    SQLiteDatabase.CursorFactory factory, 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    int flags, 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    DatabaseErrorHandler errorHandler, 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    int poolSize)
</span></span></code></pre></td></tr></table>
</div>
</div><p>跟多进程类似，多线程可以同时读取数据库数据，但是写数据库依然是互斥的。SQLite 提供了 Busy Retry 的方案，即发生阻塞时会触发 Busy Handler，此时可以让线程休眠一段时间后，重新尝试操作，你可以参考<a href="./8FjDqPtXWWqOInsiV79Chg.md">《微信 iOS SQLite 源码优化实践》</a>这篇文章。</p>
<p>为了进一步提高并发性能，我们还可以打开<a href="./wal.md">WAL</a>（Write-Ahead Logging）模式。WAL 模式会将修改的数据单独写到一个 WAL 文件中，同时也会引入了 WAL 日志文件锁。通过 WAL 模式读和写可以完全地并发执行，不会互相阻塞。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PRAGMA schema.journal_mode = WAL
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>但是需要注意的是，写之间是仍然不能并发</strong>。如果出现多个写并发的情况，依然有可能会出现 SQLiteDatabaseLockedException。这个时候我们可以让应用中捕获这个异常，然后等待一段时间再重试。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">} catch (SQLiteDatabaseLockedException e) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (sqliteLockedExceptionTimes &lt; (tryTimes - 1)) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            Thread.sleep(100);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        } catch (InterruptedException e1) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    sqliteLockedExceptionTimes++；
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>总的来说通过连接池与 WAL 模式，我们可以很大程度上增加 SQLite 的读写并发，大大减少由于并发导致的等待耗时，建议大家在应用中可以尝试开启。</strong></p>
<p><strong>3. 查询优化</strong></p>
<p>说到数据库的查询优化，你第一个想到的肯定是建索引，那我就先来讲讲 SQLite 的索引优化。</p>
<p><strong>索引优化</strong></p>
<p>正确使用索引在大部分的场景可以大大降低查询速度，微信的数据库优化也是通过索引开始。下面是索引使用非常简单的一个例子，我们先从索引表找到数据对应的 rowid，然后再从原数据表直接通过 rowid 查询结果。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/8e3c7b9bfe3149da2722664c704cddec.png" alt=""></p>
<p>关于 SQLite 索引的原理网上有很多文章，在这里我推荐一些参考资料给你：</p>
<ul>
<li><a href="./sqlite-suo-yin-de-yuan-li-ji-ying-yong.md">SQLite 索引的原理</a></li>
<li>官方文档：<a href="./queryplanner.md#searching">Query Planning</a></li>
<li><a href="./theory-of-mysql-index.md">MySQL 索引背后的数据结构及算法原理</a></li>
</ul>
<p>这里的关键在于如何正确的建立索引，很多时候我们以为已经建立了索引，但事实上并没有真正生效。例如使用了 BETWEEN、LIKE、OR 这些操作符、使用表达式或者 case when 等。更详细的规则可参考官方文档<a href="./optoverview.md">The SQLite Query Optimizer Overview</a>，下面是一个通过优化转换达到使用索引目的的例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">BETWEEN：myfiedl 索引无法生效
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">SELECT * FROM mytable WHERE myfield BETWEEN 10 and 20;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">转换成：myfiedl 索引可以生效
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">SELECT * FROM mytable WHERE myfield &gt;= 10 AND myfield &lt;= 20;
</span></span></code></pre></td></tr></table>
</div>
</div><p>建立索引是有代价的，需要一直维护索引表的更新。比如对于一个很小的表来说就没必要建索引；如果一个表经常是执行插入更新操作，那么也需要节制的建立索引。总的来说有几个原则：</p>
<ul>
<li>建立正确的索引。这里不仅需要确保索引在查询中真正生效，我们还希望可以选择最高效的索引。如果一个表建立太多的索引，那么在查询的时候 SQLite 可能不会选择最好的来执行。</li>
<li>单列索引、多列索引与复合索引的选择。索引要综合数据表中不同的查询与排序语句一起考虑，如果查询结果集过大，还是希望可以通过复合索引直接在索引表返回查询结果。</li>
<li>索引字段的选择。整型类型索引效率会远高于字符串索引，而对于主键 SQLite 会默认帮我们建立索引，所以主键尽量不要用复杂字段。</li>
</ul>
<p><strong>总的来说索引优化是 SQLite 优化中最简单同时也是最有效的，但是它并不是简单的建一个索引就可以了，有的时候我们需要进一步调整查询语句甚至是表的结构，这样才能达到最好的效果。</strong></p>
<p><strong>页大小与缓存大小</strong></p>
<p>在 I/O 文件系统中，我讲过数据库就像一个小文件系统一样，事实上它内部也有页和缓存的概念。</p>
<p>对于 SQLite 的 DB 文件来说，页（page）是最小的存储单位，如下图所示每个表对应的数据在整个 DB 文件中都是通过一个一个的页存储，属于同一个表不同的页以 B 树（B-tree）的方式组织索引，每一个表都是一棵 B 树。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/c21e9e93261c7016f29be6654722f3f7.png" alt=""></p>
<p>跟文件系统的页缓存（Page Cache）一样，SQLite 会将读过的页缓存起来，用来加快下一次读取速度。页大小默认是 1024Byte，缓存大小默认是 1000 页。更多的编译参数你可以查看官方文档<a href="./pragma.md#pragma%5Fjournal%5Fmode">PRAGMA Statements</a>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PRAGMA page_size = 1024
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PRAGMA cache_size = 1000
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个页永远只存放一个表或者一组索引的数据，即不可能同一个页存放多个表或索引的数据，表在整个 DB 文件的第一个页就是这棵 B 树的根页。继续以上图为例，如果想查询 rowID 为 N+2 的数据，我们首先要从 sqlite_master 查找出 table 的 root page 的位置，然后读取 root page、page4 这两个页，所以一共会需要 3 次 I/O。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/b5f27859c8ec4830862dcfdc21e3e786.png" alt=""></p>
<p>从上表可以看到，增大 page size 并不能不断地提升性能，在拐点以后可能还会有副作用。我们可以通过 PRAGMA 改变默认 page size 的大小，也可以再创建 DB 文件的时候进行设置。但是需要注意如果存在老的数据，需要调用 vacuum 对数据表对应的节点重新计算分配大小。</p>
<p>在微信的内部测试中，如果使用 4KB 的 page size 性能提升可以在 5%～10%。但是考虑到历史数据的迁移成本，最终还是使用 1024Byte。<strong>所以这里建议大家在新建数据库的时候，就提前选择 4KB 作为默认的 page size 以获得更好的性能。</strong></p>
<p><strong>其他优化</strong></p>
<p>关于 SQLite 的使用优化还有很多很多，下面我简单提几个点。</p>
<ul>
<li>慎用“<code>select*</code>”，需要使用多少列，就选取多少列。</li>
<li>正确地使用事务。</li>
<li>预编译与参数绑定，缓存被编译后的 SQL 语句。</li>
<li>对于 blob 或超大的 Text 列，可能会超出一个页的大小，导致出现超大页。建议将这些列单独拆表，或者放到表字段的后面。</li>
<li>定期整理或者清理无用或可删除的数据，例如朋友圈数据库会删除比较久远的数据，如果用户访问到这部分数据，重新从网络拉取即可。</li>
</ul>
<p>在日常的开发中，我们都应该对这些知识有所了解，再来复习一下上面学到的 SQLite 优化方法。<strong>通过引进 ORM，可以大大的提升我们的开发效率。通过 WAL 模式和连接池，可以提高 SQLite 的并发性能。通过正确的建立索引，可以提升 SQLite 的查询速度。通过调整默认的页大小和缓存大小，可以提升 SQLite 的整体性能。</strong></p>
<h2 id="sqlite-的其他特性">SQLite 的其他特性</h2>
<p>除了 SQLite 的优化经验，我在微信的工作中还积累了很多使用的经验，下面我挑选了几个比较重要的经验把它分享给你。</p>
<p><strong>1. 损坏与恢复</strong></p>
<p>微信中 SQLite 的损耗率在 1/20000～1/10000 左右，虽然看起来很低，不过意考虑到微信的体量，这个问题还是不容忽视的。特别是如果某些大佬的聊天记录丢失，我们团队都会承受超大的压力。</p>
<p>创新是为了解决焦虑，技术都是逼出来的。对于 SQLite 损坏与恢复的研究，可以说是微信投入比较大的一块。关于 SQLite 数据库的损耗与修复，以及微信在这里的优化成果，你可以参考下面这些资料。</p>
<ul>
<li><a href="./howtocorrupt.md">How To Corrupt An SQLite Database File</a></li>
<li><a href="./N1tuHTyg3xVfbaSd4du-tw.md">微信 SQLite 数据库修复实践</a></li>
<li><a href="./Ln7kNOn3zx589ACmn5ESQA.md">微信移动端数据库组件 WCDB 系列（二） — 数据库修复三板斧</a></li>
<li><a href="./Android%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%AE%E5%A4%8D.md">WCDB Android 数据库修复</a></li>
</ul>
<p><strong>2. 加密与安全</strong></p>
<p>数据库的安全主要有两个方面，一个是防注入，一个是加密。防注入可以通过静态安全扫描的方式，而加密一般会使用 SQLCipher 支持。</p>
<p>SQLite 的加解密都是以页为单位，默认会使用 AES 算法加密，加 / 解密的耗时跟选用的密钥长度有关。下面是<a href="./Android-Benchmark.md">WCDB Android Benchmark</a>的数据，详细的信息请查看链接里的说明，从结论来说对 Create 来说影响会高达到 10 倍。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/f1b777529716eb8952bfc6f4f0ef69fe.png" alt=""></p>
<p>关于 WCDB 加解密的使用，你可以参考<a href="./NFnYEXSxAaHBqpi7WofSPQ.md">《微信移动数据库组件 WCDB（四） — Android 特性篇》</a>。</p>
<p><strong>3. 全文搜索</strong></p>
<p>微信的全文搜索也是一个技术导向的项目，最开始的时候性能并不是很理想，经常会被人“批斗”。经过几个版本的优化迭代，目前看效果还是非常不错的。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/18fb6aa067e0e4481bd83dc34c1637be.png" alt=""></p>
<p>关于全文搜索，你可以参考这些资料：</p>
<ul>
<li><a href="./fts3.md">SQLite FTS3 and FTS4 Extensions</a></li>
<li><a href="./AhYECT3HVyn1ikB0YQ-UVg.md">微信全文搜索优化之路</a></li>
<li><a href="./GCznwCtjJ2XUszyMcbNz8Q.md">移动客户端多音字搜索</a></li>
</ul>
<p><strong>关于 SQLite 的这些特性，我们需要根据自己的项目情况综合考虑。假如某个数据库存储的数据并不重要，这个时候万分之一的数据损坏率我们并不会关心。同样是否需要使用数据库加密，也要根据存储的数据是不是敏感内容。</strong></p>
<h2 id="sqlite-的监控">SQLite 的监控</h2>
<p>首先我想说，正确使用索引，正确使用事务。对于大型项目来说，参与的开发人员可能有几十几百人，开发人员水平参差不齐，很难保证每个人都可以正确而高效地使用 SQLite，所以这次时候需要建立完善的监控体系。</p>
<p><strong>1. 本地测试</strong></p>
<p>作为一名靠谱的开发工程师，我们每写一个 SQL 语句，都应该先在本地测试。我们可以通过 EXPLAIN QUERY PLAN 测试 SQL 语句的查询计划，是全表扫描还是使用了索引，以及具体使用了哪个索引等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sqlite&gt; EXPLAIN QUERY PLAN SELECT * FROM t1 WHERE a=1 AND b&gt;2;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">QUERY PLAN
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">|--SEARCH TABLE t1 USING INDEX i2 (a=? AND b&gt;?)
</span></span></code></pre></td></tr></table>
</div>
</div><p>关于 SQLite 命令行与 EXPLAIN QUERY PLAN 的使用，可以参考<a href="./cli.md">Command Line Shell For SQLite</a>以及<a href="./eqp.md">EXPLAIN QUERY PLAN</a>。</p>
<p><strong>2. 耗时监控</strong></p>
<p>本地测试过于依赖开发人员的自觉性，所以很多时候我们依然需要建立线上大数据的监控。因为微信集成了自己的 SQLite 源码，所以可以非常方便地增加自己想要的监控模块。</p>
<p>WCDB 增加了<a href="./SQLiteTrace.md">SQLiteTrace</a>的监控模块，有以下三个接口：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/a48580fa57ba69739b7c52c7f3fdf859.png" alt=""></p>
<p>我们可以通过这些接口监控数据库 busy、损耗以及执行耗时。针对耗时比较长的 SQL 语句，需要进一步检查是 SQL 语句写得不好，还是需要建立索引。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/48642fefab6ce301aeb3df8671e5b13f.png" alt=""></p>
<p><strong>3. 智能监控</strong></p>
<p>对于查询结果的监控只是我们监控演进的第二阶段，在这个阶段我们依然需要人工介入分析，而且需要比较有经验的人员负责。</p>
<p>我们希望 SQL 语句的分析可以做到智能化，是完全不需要门槛的。微信开源的 Matrix 里面就有一个智能化分析 SQLite 语句的工具：<a href="./laUgOmAcMiZIOfM2sWrQgw.md">Matrix SQLiteLint – SQLite 使用质量检测</a>。<strong>它根据分析 SQL 语句的语法树，结合我们日常数据库使用的经验，抽象出索引使用不当、<code>select*</code>等六大问题。</strong></p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/520ef5f6568a1748307b7b4cc148361b.png" alt=""></p>
<p>可能有同学会感叹为什么微信的人可以想到这样的方式，事实上这个思路在 MySQL 中是非常常见的做法。美团也开源了它们内部的 SQL 优化工具 SQLAdvisor，你可以参考这些资料：</p>
<ul>
<li><a href="./SQL%5Fparser%5Fused%5Fin%5Fmtdp.md">SQL 解析在美团的应用</a></li>
<li><a href="./sqladvisor%5Fpr.md">美团点评 SQL 优化工具 SQLAdvisor 开源</a></li>
</ul>
<h2 id="总结">总结</h2>
<p>数据库存储是一个开发人员的基本功，清楚 SQLite 的底层机制对我们的工作会有很大的指导意义。</p>
<p>掌握了 SQLite 数据库并发的机制，在某些时候我们可以更好地决策应该拆数据表还是拆数据库。新建一个数据库好处是可以隔离其他库并发或者损坏的情况，而坏处是数据库初始化耗时以及更多内存的占用。一般来说，单独的业务都会使用独立数据库，例如专门的下载数据库、朋友圈数据库、聊天数据库。但是数据库也不宜太多，我们可以有一个公共数据库，用来存放一些相对不是太大的数据。</p>
<p>在了解 SQLite 数据库损坏的原理和概率以后，我们可以根据数据的重要程度决定是否要引入恢复机制。我还讲了如何实现数据库加密以及对性能的影响，我们可以根据数据的敏感程度决定是否要引入加密。</p>
<p>最后我再强调一下，SQLite 优化真的是一个很大的话题，在课后你还需要结合参考资料再进一步反复学习，才能把今天的内容理解透彻。</p>
<h2 id="课后作业">课后作业</h2>
<p>在你的应用中是否使用数据库存储呢，使用了哪种数据库？是否使用 ORM？在使用数据库过程中你有哪些疑问或者经验呢？欢迎留言跟我和其他同学一起讨论。</p>
<p>如果你的应用也在使用 SQLite 存储，今天的课后练习是尝试接入 WCDB，对比测试系统默认 SQLite 的性能。尝试接入<a href="./matrix-sqlite-lint.md">Matrix SQLiteLint</a>，查看是否存在不合理的 SQLite 使用。</p>
<p>除了今天文章中的参考资料，我还给希望进阶的同学准备了下面的资料，欢迎有兴趣的同学继续深入学习。</p>
<ul>
<li><a href="./docs.md">SQLite 官方文档</a></li>
<li><a href="./sqliteintro.md">SQLite 源码分析</a></li>
<li><a href="./%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90SQLite.pdf.md">全面解析 SQLite</a></li>
<li>图书《SQLite 权威指南（第 2 版）》</li>
</ul>
<p>欢迎你点击“请朋友读”，把今天的内容分享给好友，邀请他一起学习。最后别忘了在评论区提交今天的作业，我也为认真完成作业的同学准备了丰厚的“学习加油礼包”，期待与你一起切磋进步哦。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/0e5461ae1393aa633b672fbee779c7e1.png" alt=""></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/">Android开发高手课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B%E8%AF%BE/14__%E5%86%B2%E7%AA%81%E7%AE%A1%E7%90%861%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%AB%98%E5%8E%8B%E5%AF%B9%E8%AF%9D/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">14__冲突管理1：如何进行高压对话？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/14__%E7%AD%94%E7%96%91%E4%BA%8C%E5%A6%82%E4%BD%95%E7%94%A8perf%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90java%E7%A8%8B%E5%BA%8F/">
            <span class="next-text nav-default">14__答疑（二）：如何用perf工具分析Java程序？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
