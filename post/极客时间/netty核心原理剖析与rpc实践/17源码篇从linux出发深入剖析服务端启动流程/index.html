<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>17源码篇：从Linux出发深入剖析服务端启动流程 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="通过前几章课程的学习，我们已经对 Netty 的技术思想和基本原理有了初步的认识，从今天这节课开始我们将正式进入 Netty 核心源码学习的课程。希望能够通过源码解析的方式让你更加深入理解 Netty 的精髓，如 Netty 的设计思想、工程技巧等，为之后继续深入研究 Netty 打下坚实的基础。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/17%E6%BA%90%E7%A0%81%E7%AF%87%E4%BB%8Elinux%E5%87%BA%E5%8F%91%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/17%E6%BA%90%E7%A0%81%E7%AF%87%E4%BB%8Elinux%E5%87%BA%E5%8F%91%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="17源码篇：从Linux出发深入剖析服务端启动流程">
  <meta property="og:description" content="通过前几章课程的学习，我们已经对 Netty 的技术思想和基本原理有了初步的认识，从今天这节课开始我们将正式进入 Netty 核心源码学习的课程。希望能够通过源码解析的方式让你更加深入理解 Netty 的精髓，如 Netty 的设计思想、工程技巧等，为之后继续深入研究 Netty 打下坚实的基础。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Netty核心原理剖析与RPC实践">

  <meta itemprop="name" content="17源码篇：从Linux出发深入剖析服务端启动流程">
  <meta itemprop="description" content="通过前几章课程的学习，我们已经对 Netty 的技术思想和基本原理有了初步的认识，从今天这节课开始我们将正式进入 Netty 核心源码学习的课程。希望能够通过源码解析的方式让你更加深入理解 Netty 的精髓，如 Netty 的设计思想、工程技巧等，为之后继续深入研究 Netty 打下坚实的基础。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="8344">
  <meta itemprop="keywords" content="Netty核心原理剖析与RPC实践">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="17源码篇：从Linux出发深入剖析服务端启动流程">
  <meta name="twitter:description" content="通过前几章课程的学习，我们已经对 Netty 的技术思想和基本原理有了初步的认识，从今天这节课开始我们将正式进入 Netty 核心源码学习的课程。希望能够通过源码解析的方式让你更加深入理解 Netty 的精髓，如 Netty 的设计思想、工程技巧等，为之后继续深入研究 Netty 打下坚实的基础。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">17源码篇：从Linux出发深入剖析服务端启动流程</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 8344 字 </span>
          <span class="more-meta"> 预计阅读 17 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>通过前几章课程的学习，我们已经对 Netty 的技术思想和基本原理有了初步的认识，从今天这节课开始我们将正式进入 Netty 核心源码学习的课程。希望能够通过源码解析的方式让你更加深入理解 Netty 的精髓，如 Netty 的设计思想、工程技巧等，为之后继续深入研究 Netty 打下坚实的基础。</p>
<p>在课程开始之前，我想分享一下关于源码学习的几点经验和建议。第一，很多同学在开始学习源码时面临的第一个问题就是不知道从何下手，这个时候一定不能对着源码毫无意义地四处翻看。建议你可以通过 Hello World 或者 TestCase 作为源码学习的入口，然后再通过 Debug 断点的方式调试并跑通源码。第二，阅读源码一定要有全局观。首先要把握源码的主流程，避免刚开始陷入代码细节的死胡同。第三，源码一定要反复阅读，让自己每一次读都有不同的收获。我们可以通过画图、注释的方式帮助自己更容易理解源码的核心流程，方便后续的复习和回顾。</p>
<p>作为源码解析的第一节课，我们将深入分析 Netty 服务端的启动流程。启动服务的过程中我们可以了解到 Netty 各大核心组件的关系，这将是学习 Netty 源码一个非常好的切入点，让我们一起看看 Netty 的每个零件是如何运转起来的吧。</p>
<p>说明：本文参考的 Netty 源码版本为 4.1.42.Final。</p>
<p>从 Echo 服务器示例入手</p>
<p>在《引导器作用：客户端和服务端启动都要做些什么？》的课程中，我们介绍了如何使用引导器搭建服务端的基本框架。在这里我们实现了一个最简单的 Echo 服务器，用于调试 Netty 服务端启动的源码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class EchoServer {
</span></span><span class="line"><span class="cl">    public void startEchoServer(int port) throws Exception {
</span></span><span class="line"><span class="cl">        EventLoopGroup bossGroup = new NioEventLoopGroup();
</span></span><span class="line"><span class="cl">        EventLoopGroup workerGroup = new NioEventLoopGroup();
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            ServerBootstrap b = new ServerBootstrap();
</span></span><span class="line"><span class="cl">            b.group(bossGroup, workerGroup)
</span></span><span class="line"><span class="cl">                    .channel(NioServerSocketChannel.class)
</span></span><span class="line"><span class="cl">                    .handler(new LoggingHandler(LogLevel.INFO)) // 设置ServerSocketChannel 对应的 Handler
</span></span><span class="line"><span class="cl">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { // 设置 SocketChannel 对应的 Handler
</span></span><span class="line"><span class="cl">                        @Override
</span></span><span class="line"><span class="cl">                        public void initChannel(SocketChannel ch) {
</span></span><span class="line"><span class="cl">                            ch.pipeline().addLast(new FixedLengthFrameDecoder(10));
</span></span><span class="line"><span class="cl">                            ch.pipeline().addLast(new ResponseSampleEncoder());
</span></span><span class="line"><span class="cl">                            ch.pipeline().addLast(new RequestSampleHandler());
</span></span><span class="line"><span class="cl">                        }
</span></span><span class="line"><span class="cl">                    });
</span></span><span class="line"><span class="cl">            ChannelFuture f = b.bind(port).sync();
</span></span><span class="line"><span class="cl">            f.channel().closeFuture().sync();
</span></span><span class="line"><span class="cl">        } finally {
</span></span><span class="line"><span class="cl">            bossGroup.shutdownGracefully();
</span></span><span class="line"><span class="cl">            workerGroup.shutdownGracefully();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们以引导器 ServerBootstrap 为切入点，开始深入分析 Netty 服务端的启动流程。在服务端启动之前，需要配置 ServerBootstrap 的相关参数，这一步大致可以分为以下几个步骤：</p>
<p>配置 EventLoopGroup 线程组；</p>
<p>配置 Channel 的类型；</p>
<p>设置 ServerSocketChannel 对应的 Handler；</p>
<p>设置网络监听的端口；</p>
<p>设置 SocketChannel 对应的 Handler；</p>
<p>配置 Channel 参数。</p>
<p>配置 ServerBootstrap 参数的过程非常简单，把参数值保存在 ServerBootstrap 定义的成员变量里就可以了。我们可以看下 ServerBootstrap 的成员变量定义，基本与 ServerBootstrap 暴露出来的配置方法是一一对应的。如下所示，我以注释的形式说明每个成员变量对应的调用方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">volatile</span> <span class="n">EventLoopGroup</span> <span class="n">group</span><span class="p">;</span> <span class="o">//</span> <span class="n">group</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">volatile</span> <span class="n">EventLoopGroup</span> <span class="n">childGroup</span><span class="p">;</span> <span class="o">//</span> <span class="n">group</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">volatile</span> <span class="n">ChannelFactory</span><span class="o">&lt;</span><span class="err">?</span> <span class="k">extends</span> <span class="n">C</span><span class="o">&gt;</span> <span class="n">channelFactory</span><span class="p">;</span> <span class="o">//</span> <span class="n">channel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">volatile</span> <span class="n">SocketAddress</span> <span class="n">localAddress</span><span class="p">;</span> <span class="o">//</span> <span class="n">localAddress</span>
</span></span><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">ChannelOption</span><span class="o">&lt;</span><span class="err">?</span><span class="o">&gt;</span><span class="p">,</span> <span class="ne">Object</span><span class="o">&gt;</span> <span class="n">childOptions</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">ChannelOption</span><span class="o">&lt;</span><span class="err">?</span><span class="o">&gt;</span><span class="p">,</span> <span class="ne">Object</span><span class="o">&gt;</span><span class="p">();</span> <span class="o">//</span> <span class="n">childOption</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">volatile</span> <span class="n">ChannelHandler</span> <span class="n">childHandler</span><span class="p">;</span> <span class="o">//</span> <span class="n">childHandler</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">ServerBootstrapConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ServerBootstrapConfig</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>关于 ServerBootstrap 如何为每个成员变量保存参数的过程，我们就不一一展开了，你可以理解为这部分工作只是一个前置准备，课后你可以自己跟进下每个方法的源码。今天我们核心聚焦在 b.bind().sync() 这行代码，bind() 才是真正进行服务器端口绑定和启动的入口，sync() 表示阻塞等待服务器启动完成。接下来我们对 bind() 方法进行展开分析。</p>
<p>在开始源码分析之前，我们带着以下几个问题边看边思考：</p>
<p>Netty 自己实现的 Channel 与 JDK 底层的 Channel 是如何产生联系的？</p>
<p>ChannelInitializer 这个特殊的 Handler 处理器的作用是什么？</p>
<p>Pipeline 初始化的过程是什么样的？</p>
<p>服务端启动全过程</p>
<p>首先我们来看下 ServerBootstrap 中 bind() 方法的源码实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public ChannelFuture bind() {
</span></span><span class="line"><span class="cl">    validate();
</span></span><span class="line"><span class="cl">    SocketAddress localAddress = this.localAddress;
</span></span><span class="line"><span class="cl">    if (localAddress == null) {
</span></span><span class="line"><span class="cl">        throw new IllegalStateException(&#34;localAddress not set&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return doBind(localAddress);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">private ChannelFuture doBind(final SocketAddress localAddress) {
</span></span><span class="line"><span class="cl">    final ChannelFuture regFuture = initAndRegister();
</span></span><span class="line"><span class="cl">    final Channel channel = regFuture.channel();
</span></span><span class="line"><span class="cl">    if (regFuture.cause() != null) {
</span></span><span class="line"><span class="cl">        return regFuture;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    if (regFuture.isDone()) {
</span></span><span class="line"><span class="cl">        ChannelPromise promise = channel.newPromise();
</span></span><span class="line"><span class="cl">        doBind0(regFuture, channel, localAddress, promise);
</span></span><span class="line"><span class="cl">        return promise;
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
</span></span><span class="line"><span class="cl">        regFuture.addListener(new ChannelFutureListener() {
</span></span><span class="line"><span class="cl">            @Override
</span></span><span class="line"><span class="cl">            public void operationComplete(ChannelFuture future) throws Exception {
</span></span><span class="line"><span class="cl">                Throwable cause = future.cause();
</span></span><span class="line"><span class="cl">                if (cause != null) {
</span></span><span class="line"><span class="cl">                    promise.setFailure(cause);
</span></span><span class="line"><span class="cl">                } else {
</span></span><span class="line"><span class="cl">                    promise.registered();
</span></span><span class="line"><span class="cl">                    doBind0(regFuture, channel, localAddress, promise);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        });
</span></span><span class="line"><span class="cl">        return promise;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>由此可见，doBind() 方法是我们需要分析的重点。我们再一起看下 doBind() 具体做了哪些事情：</p>
<p>调用 initAndRegister() 初始化并注册 Channel，同时返回一个 ChannelFuture 实例 regFuture，所以我们可以猜测出 initAndRegister() 是一个异步的过程。</p>
<p>接下来通过 regFuture.cause() 方法判断 initAndRegister() 的过程是否发生异常，如果发生异常则直接返回。</p>
<p>regFuture.isDone() 表示 initAndRegister() 是否执行完毕，如果执行完毕则调用 doBind0() 进行 Socket 绑定。如果 initAndRegister() 还没有执行结束，regFuture 会添加一个 ChannelFutureListener 回调监听，当 initAndRegister() 执行结束后会调用 operationComplete()，同样通过 doBind0() 进行端口绑定。</p>
<p>doBind() 整个实现结构非常清晰，其中 initAndRegister() 负责 Channel 初始化和注册，doBind0() 用于端口绑定。这两个过程最为重要，下面我们分别进行详细的介绍。</p>
<p>服务端 Channel 初始化及注册</p>
<p>initAndRegister() 方法顾名思义，主要负责初始化和注册的相关工作，我们具体看下它的源码实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">final ChannelFuture initAndRegister() {
</span></span><span class="line"><span class="cl">    Channel channel = null;
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        channel = channelFactory.newChannel(); // 创建 Channel
</span></span><span class="line"><span class="cl">        init(channel); // 初始化 Channel
</span></span><span class="line"><span class="cl">    } catch (Throwable t) {
</span></span><span class="line"><span class="cl">        if (channel != null) {
</span></span><span class="line"><span class="cl">            channel.unsafe().closeForcibly();
</span></span><span class="line"><span class="cl">            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    ChannelFuture regFuture = config().group().register(channel); // 注册 Channel
</span></span><span class="line"><span class="cl">    if (regFuture.cause() != null) {
</span></span><span class="line"><span class="cl">        if (channel.isRegistered()) {
</span></span><span class="line"><span class="cl">            channel.close();
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            channel.unsafe().closeForcibly();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return regFuture;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>initAndRegister() 可以分为三步：创建 Channel、初始化 Channel 和注册 Channel，接下来我们一步步进行拆解分析。</p>
<p>创建服务端 Channel</p>
<p>首先看下创建 Channel 的过程，直接跟进 channelFactory.newChannel() 的源码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="k">class</span> <span class="n">ReflectiveChannelFactory</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">extends</span> <span class="n">Channel</span><span class="o">&gt;</span> <span class="n">implements</span> <span class="n">ChannelFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">private</span> <span class="n">final</span> <span class="n">Constructor</span><span class="o">&lt;</span><span class="err">?</span> <span class="k">extends</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">constructor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="n">ReflectiveChannelFactory</span><span class="p">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="err">?</span> <span class="k">extends</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">clazz</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ObjectUtil</span><span class="o">.</span><span class="n">checkNotNull</span><span class="p">(</span><span class="n">clazz</span><span class="p">,</span> <span class="s2">&#34;clazz&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">this</span><span class="o">.</span><span class="n">constructor</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="n">getConstructor</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="n">NoSuchMethodException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">throw</span> <span class="n">new</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s2">&#34;Class &#34;</span> <span class="o">+</span> <span class="n">StringUtil</span><span class="o">.</span><span class="n">simpleClassName</span><span class="p">(</span><span class="n">clazz</span><span class="p">)</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                    <span class="s2">&#34; does not have a public non-arg constructor&#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="err">@</span><span class="n">Override</span>
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="n">T</span> <span class="n">newChannel</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">constructor</span><span class="o">.</span><span class="n">newInstance</span><span class="p">();</span> <span class="o">//</span> <span class="err">反射创建对象</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">throw</span> <span class="n">new</span> <span class="n">ChannelException</span><span class="p">(</span><span class="s2">&#34;Unable to create Channel from class &#34;</span> <span class="o">+</span> <span class="n">constructor</span><span class="o">.</span><span class="n">getDeclaringClass</span><span class="p">(),</span> <span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">省略其他代码</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在前面 Echo 服务器的示例中，我们通过 channel(NioServerSocketChannel.class) 配置 Channel 的类型，工厂类 ReflectiveChannelFactory 是在该过程中被创建的。从 constructor.newInstance() 我们可以看出，ReflectiveChannelFactory 通过反射创建出 NioServerSocketChannel 对象，所以我们重点需要关注 NioServerSocketChannel 的构造函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public NioServerSocketChannel() {
</span></span><span class="line"><span class="cl">    this(newSocket(DEFAULT_SELECTOR_PROVIDER)); 
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">public NioServerSocketChannel(ServerSocketChannel channel) {
</span></span><span class="line"><span class="cl">    super(null, channel, SelectionKey.OP_ACCEPT); // 调用父类方法
</span></span><span class="line"><span class="cl">    config = new NioServerSocketChannelConfig(this, javaChannel().socket());
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">private static ServerSocketChannel newSocket(SelectorProvider provider) {
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        return provider.openServerSocketChannel(); // 创建 JDK 底层的 ServerSocketChannel
</span></span><span class="line"><span class="cl">    } catch (IOException e) {
</span></span><span class="line"><span class="cl">        throw new ChannelException(
</span></span><span class="line"><span class="cl">                &#34;Failed to open a server socket.&#34;, e);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>SelectorProvider 是 JDK NIO 中的抽象类实现，通过 openServerSocketChannel() 方法可以用于创建服务端的 ServerSocketChannel。而且 SelectorProvider 会根据操作系统类型和版本的不同，返回不同的实现类，具体可以参考 DefaultSelectorProvider 的源码实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static SelectorProvider create() {
</span></span><span class="line"><span class="cl">    String osname = AccessController
</span></span><span class="line"><span class="cl">        .doPrivileged(new GetPropertyAction(&#34;os.name&#34;));
</span></span><span class="line"><span class="cl">    if (osname.equals(&#34;SunOS&#34;))
</span></span><span class="line"><span class="cl">        return createProvider(&#34;sun.nio.ch.DevPollSelectorProvider&#34;);
</span></span><span class="line"><span class="cl">    if (osname.equals(&#34;Linux&#34;))
</span></span><span class="line"><span class="cl">        return createProvider(&#34;sun.nio.ch.EPollSelectorProvider&#34;);
</span></span><span class="line"><span class="cl">    return new sun.nio.ch.PollSelectorProvider();
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里我们只讨论 Linux 操作系统的场景，在 Linux 内核 2.6版本及以上都会默认采用 EPollSelectorProvider。如果是旧版本则使用 PollSelectorProvider。对于目前的主流 Linux 平台而言，都是采用 Epoll 机制实现的。</p>
<p>创建完 ServerSocketChannel，我们回到 NioServerSocketChannel 的构造函数，接着它会通过 super() 依次调用到父类的构造进行初始化工作，最终我们可以定位到 AbstractNioChannel 和 AbstractChannel 的构造函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) {
</span></span><span class="line"><span class="cl">    super(parent);
</span></span><span class="line"><span class="cl">    // 省略其他代码
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        ch.configureBlocking(false);
</span></span><span class="line"><span class="cl">    } catch (IOException e) {
</span></span><span class="line"><span class="cl">        // 省略其他代码
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">protected AbstractChannel(Channel parent) {
</span></span><span class="line"><span class="cl">    this.parent = parent;
</span></span><span class="line"><span class="cl">    id = newId(); // Channel 全局唯一 id 
</span></span><span class="line"><span class="cl">    unsafe = newUnsafe(); // unsafe 操作底层读写
</span></span><span class="line"><span class="cl">    pipeline = newChannelPipeline(); // pipeline 负责业务处理器编排
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先调用 AbstractChannel 的构造函数创建了三个重要的成员变量，分别为 id、unsafe、pipeline。id 表示全局唯一的 Channel，unsafe 用于操作底层数据的读写操作，pipeline 负责业务处理器的编排。初始化状态，pipeline 的内部结构只包含头尾两个节点，如下图所示。三个核心成员变量创建好之后，会回到 AbstractNioChannel 的构造函数，通过 ch.configureBlocking(false) 设置 Channel 是非阻塞模式。</p>
<p>创建服务端 Channel 的过程我们已经讲完了，简单总结下其中几个重要的步骤：</p>
<p>ReflectiveChannelFactory 通过反射创建 NioServerSocketChannel 实例；</p>
<p>创建 JDK 底层的 ServerSocketChannel；</p>
<p>为 Channel 创建 id、unsafe、pipeline 三个重要的成员变量；</p>
<p>设置 Channel 为非阻塞模式。</p>
<p>初始化服务端 Channel</p>
<p>回到 ServerBootstrap 的 initAndRegister() 方法，继续跟进用于初始化服务端 Channel 的 init() 方法源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void init(Channel channel) {
</span></span><span class="line"><span class="cl">    setChannelOptions(channel, options0().entrySet().toArray(newOptionArray(0)), logger); // 设置 Socket 参数
</span></span><span class="line"><span class="cl">    setAttributes(channel, attrs0().entrySet().toArray(newAttrArray(0))); // 保存用户自定义属性
</span></span><span class="line"><span class="cl">    ChannelPipeline p = channel.pipeline();
</span></span><span class="line"><span class="cl">    // 获取 ServerBootstrapAcceptor 的构造参数
</span></span><span class="line"><span class="cl">    final EventLoopGroup currentChildGroup = childGroup;
</span></span><span class="line"><span class="cl">    final ChannelHandler currentChildHandler = childHandler;
</span></span><span class="line"><span class="cl">    final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions =
</span></span><span class="line"><span class="cl">            childOptions.entrySet().toArray(newOptionArray(0));
</span></span><span class="line"><span class="cl">    final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0));
</span></span><span class="line"><span class="cl">    // 添加特殊的 Handler 处理器
</span></span><span class="line"><span class="cl">    p.addLast(new ChannelInitializer&lt;Channel&gt;() {
</span></span><span class="line"><span class="cl">        @Override
</span></span><span class="line"><span class="cl">        public void initChannel(final Channel ch) {
</span></span><span class="line"><span class="cl">            final ChannelPipeline pipeline = ch.pipeline();
</span></span><span class="line"><span class="cl">            ChannelHandler handler = config.handler();
</span></span><span class="line"><span class="cl">            if (handler != null) {
</span></span><span class="line"><span class="cl">                pipeline.addLast(handler);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            ch.eventLoop().execute(new Runnable() {
</span></span><span class="line"><span class="cl">                @Override
</span></span><span class="line"><span class="cl">                public void run() {
</span></span><span class="line"><span class="cl">                    pipeline.addLast(new ServerBootstrapAcceptor(
</span></span><span class="line"><span class="cl">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            });
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    });
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>init() 方法的源码比较长，我们依然拆解成两个部分来看：</p>
<p>第一步，设置 Socket 参数以及用户自定义属性。在创建服务端 Channel 时，Channel 的配置参数保存在 NioServerSocketChannelConfig 中，在初始化 Channel 的过程中，Netty 会将这些参数设置到 JDK 底层的 Socket 上，并把用户自定义的属性绑定在 Channel 上。</p>
<p>第二步，添加特殊的 Handler 处理器。首先 ServerBootstrap 为 Pipeline 添加了一个 ChannelInitializer，ChannelInitializer 是实现了 ChannelHandler 接口的匿名类，其中 ChannelInitializer 实现的 initChannel() 方法用于添加 ServerSocketChannel 对应的 Handler。然后 Netty 通过异步 task 的方式又向 Pipeline 一个处理器 ServerBootstrapAcceptor，从 ServerBootstrapAcceptor 的命名可以看出，这是一个连接接入器，专门用于接收新的连接，然后把事件分发给 EventLoop 执行，在这里我们先不做展开。此时服务端的 pipeline 内部结构又发生了变化，如下图所示。</p>
<p>思考一个问题，为什么需要 ChannelInitializer 处理器呢？ServerBootstrapAcceptor 的注册过程为什么又需要封装成异步 task 呢？因为我们在初始化时，还没有将 Channel 注册到 Selector 对象上，所以还无法注册 Accept 事件到 Selector 上，所以事先添加了 ChannelInitializer 处理器，等待 Channel 注册完成后，再向 Pipeline 中添加 ServerBootstrapAcceptor 处理器。</p>
<p>服务端 Channel 初始化的过程已经结束了。整体流程比较简单，主要是设置 Socket 参数以及用户自定义属性，并向 Pipeline 中添加了两个特殊的处理器。接下来我们继续分析，如何将初始化好的 Channel 注册到 Selector 对象上？</p>
<p>注册服务端 Channel</p>
<p>回到 initAndRegister() 的主流程，创建完服务端 Channel 之后，继续一层层跟进 register() 方法的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// MultithreadEventLoopGroup#register
</span></span><span class="line"><span class="cl">public ChannelFuture register(Channel channel) {
</span></span><span class="line"><span class="cl">    return next().register(channel); // 选择一个 eventLoop 注册
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// AbstractChannel#register
</span></span><span class="line"><span class="cl">public final void register(EventLoop eventLoop, final ChannelPromise promise) {
</span></span><span class="line"><span class="cl">    // 省略其他代码
</span></span><span class="line"><span class="cl">    AbstractChannel.this.eventLoop = eventLoop;
</span></span><span class="line"><span class="cl">    if (eventLoop.inEventLoop()) { // Reactor 线程内部调用
</span></span><span class="line"><span class="cl">        register0(promise);
</span></span><span class="line"><span class="cl">    } else { // 外部线程调用
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            eventLoop.execute(new Runnable() {
</span></span><span class="line"><span class="cl">                @Override
</span></span><span class="line"><span class="cl">                public void run() {
</span></span><span class="line"><span class="cl">                    register0(promise);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            });
</span></span><span class="line"><span class="cl">        } catch (Throwable t) {
</span></span><span class="line"><span class="cl">            // 省略其他代码
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Netty 会在线程池 EventLoopGroup 中选择一个 EventLoop 与当前 Channel 进行绑定，之后 Channel 生命周期内的所有 I/O 事件都由这个 EventLoop 负责处理，如 accept、connect、read、write 等 I/O 事件。可以看出，不管是 EventLoop 线程本身调用，还是外部线程用，最终都会通过 register0() 方法进行注册：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private void register0(ChannelPromise promise) {
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        if (!promise.setUncancellable() || !ensureOpen(promise)) {
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        boolean firstRegistration = neverRegistered;
</span></span><span class="line"><span class="cl">        doRegister(); // 调用 JDK 底层的 register() 进行注册
</span></span><span class="line"><span class="cl">        neverRegistered = false;
</span></span><span class="line"><span class="cl">        registered = true;
</span></span><span class="line"><span class="cl">        pipeline.invokeHandlerAddedIfNeeded(); // 触发 handlerAdded 事件
</span></span><span class="line"><span class="cl">        safeSetSuccess(promise);
</span></span><span class="line"><span class="cl">        pipeline.fireChannelRegistered(); // 触发 channelRegistered 事件
</span></span><span class="line"><span class="cl">        // 此时 Channel 还未注册绑定地址，所以处于非活跃状态
</span></span><span class="line"><span class="cl">        if (isActive()) {
</span></span><span class="line"><span class="cl">            if (firstRegistration) {
</span></span><span class="line"><span class="cl">                pipeline.fireChannelActive(); // Channel 当前状态为活跃时，触发 channelActive 事件
</span></span><span class="line"><span class="cl">            } else if (config().isAutoRead()) {
</span></span><span class="line"><span class="cl">                beginRead();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    } catch (Throwable t) {
</span></span><span class="line"><span class="cl">        // 省略其他代码
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>register0() 主要做了四件事：调用 JDK 底层进行 Channel 注册、触发 handlerAdded 事件、触发 channelRegistered 事件、Channel 当前状态为活跃时，触发 channelActive 事件。我们对它们逐一进行分析。</p>
<p>首先看下 JDK 底层注册 Channel 的过程，对应 doRegister() 方法的实现逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">protected void doRegister() throws Exception {
</span></span><span class="line"><span class="cl">    boolean selected = false;
</span></span><span class="line"><span class="cl">    for (;;) {
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this); // 调用 JDK 底层的 register() 进行注册
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        } catch (CancelledKeyException e) {
</span></span><span class="line"><span class="cl">            // 省略其他代码
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">public final SelectionKey register(Selector sel, int ops,
</span></span><span class="line"><span class="cl">                                   Object att)
</span></span><span class="line"><span class="cl">    throws ClosedChannelException
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    synchronized (regLock) {
</span></span><span class="line"><span class="cl">        // 省略其他代码
</span></span><span class="line"><span class="cl">        SelectionKey k = findKey(sel);
</span></span><span class="line"><span class="cl">        if (k != null) {
</span></span><span class="line"><span class="cl">            k.interestOps(ops);
</span></span><span class="line"><span class="cl">            k.attach(att);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if (k == null) {
</span></span><span class="line"><span class="cl">            synchronized (keyLock) {
</span></span><span class="line"><span class="cl">                if (!isOpen())
</span></span><span class="line"><span class="cl">                    throw new ClosedChannelException();
</span></span><span class="line"><span class="cl">                k = ((AbstractSelector)sel).register(this, ops, att);
</span></span><span class="line"><span class="cl">                addKey(k);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return k;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>javaChannel().register() 负责调用 JDK 底层，将 Channel 注册到 Selector 上，register() 的第三个入参传入的是 Netty 自己实现的 Channel 对象，调用 register() 方法会将它绑定在 JDK 底层 Channel 的 attachment 上。这样在每次 Selector 对象进行事件循环时，Netty 都可以从返回的 JDK 底层 Channel 中获得自己的 Channel 对象。</p>
<p>完成 Channel 向 Selector 注册后，接下来就会触发 Pipeline 一系列的事件传播。在事件传播之前，用户自定义的业务处理器是如何被添加到 Pipeline 中的呢？答案就在pipeline.invokeHandlerAddedIfNeeded() 当中，我们重点看下 handlerAdded 事件的处理过程。invokeHandlerAddedIfNeeded() 方法的调用层次比较深，推荐你结合上述 Echo 服务端示例，使用 IDE Debug 的方式跟踪调用栈，如下图所示。</p>
<p>我们首先抓住 ChannelInitializer 中的核心源码，逐层进行分析。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// ChannelInitializer
</span></span><span class="line"><span class="cl">public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
</span></span><span class="line"><span class="cl">    if (ctx.channel().isRegistered()) {
</span></span><span class="line"><span class="cl">        if (initChannel(ctx)) {
</span></span><span class="line"><span class="cl">            removeState(ctx);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">private boolean initChannel(ChannelHandlerContext ctx) throws Exception {
</span></span><span class="line"><span class="cl">    if (initMap.add(ctx)) {
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            initChannel((C) ctx.channel()); // 调用 ChannelInitializer 实现的 initChannel() 方法
</span></span><span class="line"><span class="cl">        } catch (Throwable cause) {
</span></span><span class="line"><span class="cl">            exceptionCaught(ctx, cause);
</span></span><span class="line"><span class="cl">        } finally {
</span></span><span class="line"><span class="cl">            ChannelPipeline pipeline = ctx.pipeline();
</span></span><span class="line"><span class="cl">            if (pipeline.context(this) != null) {
</span></span><span class="line"><span class="cl">                pipeline.remove(this); // 将 ChannelInitializer 自身从 Pipeline 中移出
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return true;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return false;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出 ChannelInitializer 首先会调用 initChannel() 抽象方法，然后 Netty 会把 ChannelInitializer 自身从 Pipeline 移出。其中 initChannel() 抽象方法是在哪里实现的呢？这就要跟踪到 ServerBootstrap 之前的 init() 方法，其中有这么一段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">p.addLast(new ChannelInitializer&lt;Channel&gt;() {
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void initChannel(final Channel ch) {
</span></span><span class="line"><span class="cl">        final ChannelPipeline pipeline = ch.pipeline();
</span></span><span class="line"><span class="cl">        ChannelHandler handler = config.handler();
</span></span><span class="line"><span class="cl">        if (handler != null) {
</span></span><span class="line"><span class="cl">            pipeline.addLast(handler);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        ch.eventLoop().execute(new Runnable() {
</span></span><span class="line"><span class="cl">            @Override
</span></span><span class="line"><span class="cl">            public void run() {
</span></span><span class="line"><span class="cl">                pipeline.addLast(new ServerBootstrapAcceptor(
</span></span><span class="line"><span class="cl">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        });
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">});
</span></span></code></pre></td></tr></table>
</div>
</div><p>在前面我们已经分析了 initChannel() 方法的实现逻辑，首先向 Pipeline 中添加 ServerSocketChannel 对应的 Handler，然后通过异步 task 的方式向 Pipeline 添加 ServerBootstrapAcceptor 处理器。其中有一个点不要混淆，handler() 方法是添加到服务端的Pipeline 上，而 childHandler() 方法是添加到客户端的 Pipeline 上。所以对应 Echo 服务器示例中，此时被添加的是 LoggingHandler 处理器。</p>
<p>因为添加 ServerBootstrapAcceptor 是一个异步过程，需要 EventLoop 线程负责执行。而当前 EventLoop 线程正在执行 register0() 的注册流程，所以等到 register0() 执行完之后才能被添加到 Pipeline 当中。完成 initChannel() 这一步之后，ServerBootstrapAcceptor 并没有被添加到 Pipeline 中，此时 Pipeline 的内部结构变化如下图所示。</p>
<p>我们回到 register0() 的主流程，接着向下分析。channelRegistered 事件是由 fireChannelRegistered() 方法触发，沿着 Pipeline 的 Head 节点传播到 Tail 节点，并依次调用每个 ChannelHandler 的 channelRegistered() 方法。然而此时 Channel 还未注册绑定地址，所以处于非活跃状态，所以并不会触发 channelActive 事件。</p>
<p>执行完整个 register0() 的注册流程之后，EventLoop 线程会将 ServerBootstrapAcceptor 添加到 Pipeline 当中，此时 Pipeline 的内部结构又发生了变化，如下图所示。</p>
<p>整个服务端 Channel 注册的流程我们已经讲完，注册过程中 Pipeline 结构的变化值得你再反复梳理，从而加深理解。目前服务端还是不能工作的，还差最后一步就是进行端口绑定，我们继续向下分析。</p>
<p>端口绑定</p>
<p>回到 ServerBootstrap 的 bind() 方法，我们继续跟进端口绑定 doBind0() 的源码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final void bind(final SocketAddress localAddress, final ChannelPromise promise) {
</span></span><span class="line"><span class="cl">    assertEventLoop();
</span></span><span class="line"><span class="cl">    // 省略其他代码
</span></span><span class="line"><span class="cl">    boolean wasActive = isActive();
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        doBind(localAddress); // 调用 JDK 底层进行端口绑定
</span></span><span class="line"><span class="cl">    } catch (Throwable t) {
</span></span><span class="line"><span class="cl">        safeSetFailure(promise, t);
</span></span><span class="line"><span class="cl">        closeIfClosed();
</span></span><span class="line"><span class="cl">        return;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    if (!wasActive &amp;&amp; isActive()) {
</span></span><span class="line"><span class="cl">        invokeLater(new Runnable() {
</span></span><span class="line"><span class="cl">            @Override
</span></span><span class="line"><span class="cl">            public void run() {
</span></span><span class="line"><span class="cl">                pipeline.fireChannelActive(); // 触发 channelActive 事件
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        });
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    safeSetSuccess(promise);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>bind() 方法主要做了两件事，分别为调用 JDK 底层进行端口绑定；绑定成功后并触发 channelActive 事件。下面我们逐一进行分析。</p>
<p>首先看下调用 JDK 底层进行端口绑定的 doBind() 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">protected void doBind(SocketAddress localAddress) throws Exception {
</span></span><span class="line"><span class="cl">    if (PlatformDependent.javaVersion() &gt;= 7) {
</span></span><span class="line"><span class="cl">        javaChannel().bind(localAddress, config.getBacklog());
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        javaChannel().socket().bind(localAddress, config.getBacklog());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Netty 会根据 JDK 版本的不同，分别调用 JDK 底层不同的 bind() 方法。我使用的是 JDK8，所以会调用 JDK 原生 Channel 的 bind() 方法。执行完 doBind() 之后，服务端 JDK 原生的 Channel 真正已经完成端口绑定了。</p>
<p>完成端口绑定之后，Channel 处于活跃 Active 状态，然后会调用 pipeline.fireChannelActive() 方法触发 channelActive 事件。我们可以一层层跟进 fireChannelActive() 方法，发现其中比较重要的部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// DefaultChannelPipeline#channelActive
</span></span><span class="line"><span class="cl">public void channelActive(ChannelHandlerContext ctx) {
</span></span><span class="line"><span class="cl">    ctx.fireChannelActive();
</span></span><span class="line"><span class="cl">    readIfIsAutoRead();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// AbstractNioChannel#doBeginRead
</span></span><span class="line"><span class="cl">protected void doBeginRead() throws Exception {
</span></span><span class="line"><span class="cl">    // Channel.read() or ChannelHandlerContext.read() was called
</span></span><span class="line"><span class="cl">    final SelectionKey selectionKey = this.selectionKey;
</span></span><span class="line"><span class="cl">    if (!selectionKey.isValid()) {
</span></span><span class="line"><span class="cl">        return;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    readPending = true;
</span></span><span class="line"><span class="cl">    final int interestOps = selectionKey.interestOps();
</span></span><span class="line"><span class="cl">    if ((interestOps &amp; readInterestOp) == 0) {
</span></span><span class="line"><span class="cl">        selectionKey.interestOps(interestOps | readInterestOp); // 注册 OP_ACCEPT 事件到服务端 Channel 的事件集合
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出，在执行完 channelActive 事件传播之后，会调用 readIfIsAutoRead() 方法触发 Channel 的 read 事件，而它最终调用到 AbstractNioChannel 中的 doBeginRead() 方法，其中 readInterestOp 参数就是在前面初始化 Channel 所传入的 SelectionKey.OP_ACCEPT 事件，所以 OP_ACCEPT 事件会被注册到 Channel 的事件集合中。</p>
<p>到此为止，整个服务端已经真正启动完毕。我们总结一下服务端启动的全流程，如下图所示。</p>
<p>创建服务端 Channel：本质是创建 JDK 底层原生的 Channel，并初始化几个重要的属性，包括 id、unsafe、pipeline 等。</p>
<p>初始化服务端 Channel：设置 Socket 参数以及用户自定义属性，并添加两个特殊的处理器 ChannelInitializer 和 ServerBootstrapAcceptor。</p>
<p>注册服务端 Channel：调用 JDK 底层将 Channel 注册到 Selector 上。</p>
<p>端口绑定：调用 JDK 底层进行端口绑定，并触发 channelActive 事件，把 OP_ACCEPT 事件注册到 Channel 的事件集合中。</p>
<p>加餐：服务端如何处理客户端新建连接</p>
<p>Netty 服务端完全启动后，就可以对外工作了。接下来 Netty 服务端是如何处理客户端新建连接的呢？主要分为四步：</p>
<p>Boss NioEventLoop 线程轮询客户端新连接 OP_ACCEPT 事件；</p>
<p>构造 Netty 客户端 NioSocketChannel；</p>
<p>注册 Netty 客户端 NioSocketChannel 到 Worker 工作线程中；</p>
<p>注册 OP_READ 事件到 NioSocketChannel 的事件集合。</p>
<p>下面我们对每个步骤逐一进行简单的介绍。</p>
<p>Netty 中 Boss NioEventLoop 专门负责接收新的连接，关于 NioEventLoop 的核心源码我们下节课会着重介绍，在这里我们只先了解基本的处理流程。当客户端有新连接接入服务端时，Boss NioEventLoop 会监听到 OP_ACCEPT 事件，源码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// NioEventLoop#processSelectedKey
</span></span><span class="line"><span class="cl">if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
</span></span><span class="line"><span class="cl">    unsafe.read();
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>NioServerSocketChannel 所持有的 unsafe 是 NioMessageUnsafe 类型，我们看下 NioMessageUnsafe.read() 方法中做了什么事。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public void read() {
</span></span><span class="line"><span class="cl">    assert eventLoop().inEventLoop();
</span></span><span class="line"><span class="cl">    final ChannelConfig config = config();
</span></span><span class="line"><span class="cl">    final ChannelPipeline pipeline = pipeline();
</span></span><span class="line"><span class="cl">    final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle(); 
</span></span><span class="line"><span class="cl">    allocHandle.reset(config);
</span></span><span class="line"><span class="cl">    boolean closed = false;
</span></span><span class="line"><span class="cl">    Throwable exception = null;
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            do {
</span></span><span class="line"><span class="cl">                int localRead = doReadMessages(readBuf);  // while 循环不断读取 Buffer 中的数据
</span></span><span class="line"><span class="cl">                if (localRead == 0) {
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                if (localRead &lt; 0) {
</span></span><span class="line"><span class="cl">                    closed = true;
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                allocHandle.incMessagesRead(localRead);
</span></span><span class="line"><span class="cl">            } while (allocHandle.continueReading());
</span></span><span class="line"><span class="cl">        } catch (Throwable t) {
</span></span><span class="line"><span class="cl">            exception = t;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        int size = readBuf.size();
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; size; i ++) {
</span></span><span class="line"><span class="cl">            readPending = false;
</span></span><span class="line"><span class="cl">            pipeline.fireChannelRead(readBuf.get(i)); // 传播读取事件
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        readBuf.clear();
</span></span><span class="line"><span class="cl">        allocHandle.readComplete();
</span></span><span class="line"><span class="cl">        pipeline.fireChannelReadComplete(); // 传播读取完毕事件
</span></span><span class="line"><span class="cl">        // 省略其他代码
</span></span><span class="line"><span class="cl">    } finally {
</span></span><span class="line"><span class="cl">        if (!readPending &amp;&amp; !config.isAutoRead()) {
</span></span><span class="line"><span class="cl">            removeReadOp();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出 read() 方法的核心逻辑就是通过 while 循环不断读取数据，然后放入 List 中，这里的数据其实就是新连接。需要重点跟进一下 NioServerSocketChannel 的 doReadMessages() 方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">protected int doReadMessages(List&lt;Object&gt; buf) throws Exception {
</span></span><span class="line"><span class="cl">    SocketChannel ch = SocketUtils.accept(javaChannel());
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        if (ch != null) {
</span></span><span class="line"><span class="cl">            buf.add(new NioSocketChannel(this, ch));
</span></span><span class="line"><span class="cl">            return 1;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    } catch (Throwable t) {
</span></span><span class="line"><span class="cl">        logger.warn(&#34;Failed to create a new channel from an accepted socket.&#34;, t);
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            ch.close();
</span></span><span class="line"><span class="cl">        } catch (Throwable t2) {
</span></span><span class="line"><span class="cl">            logger.warn(&#34;Failed to close a socket.&#34;, t2);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这时就开始执行第二个步骤：构造 Netty 客户端 NioSocketChannel。Netty 先通过 JDK 底层的 accept() 获取 JDK 原生的 SocketChannel，然后将它封装成 Netty 自己的 NioSocketChannel。新建 Netty 的客户端 Channel 的实现原理与上文中我们讲到的创建服务端 Channel 的过程是类似的，只是服务端 Channel 的类型是 NioServerSocketChannel，而客户端 Channel 的类型是 NioSocketChannel。NioSocketChannel 的创建同样会完成几件事：创建核心成员变量 id、unsafe、pipeline；注册 SelectionKey.OP_READ 事件；设置 Channel 的为非阻塞模式；新建客户端 Channel 的配置。</p>
<p>成功构造客户端 NioSocketChannel 后，接下来会通过 pipeline.fireChannelRead() 触发 channelRead 事件传播。对于服务端来说，此时 Pipeline 的内部结构如下图所示。</p>
<p>上文中我们提到了一种特殊的处理器 ServerBootstrapAcceptor，在这里它就发挥了重要的作用。channelRead 事件会传播到 ServerBootstrapAcceptor.channelRead() 方法，channelRead() 会将客户端 Channel 分配到工作线程组中去执行。具体实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public void channelRead(ChannelHandlerContext ctx, Object msg) {
</span></span><span class="line"><span class="cl">    final Channel child = (Channel) msg;
</span></span><span class="line"><span class="cl">    // 在客户端 Channel 中添加 childHandler，childHandler 是用户在启动类中通过 childHandler() 方法指定的
</span></span><span class="line"><span class="cl">    child.pipeline().addLast(childHandler);
</span></span><span class="line"><span class="cl">    setChannelOptions(child, childOptions, logger);
</span></span><span class="line"><span class="cl">    setAttributes(child, childAttrs);
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        // 注册客户端 Channel
</span></span><span class="line"><span class="cl">        childGroup.register(child).addListener(new ChannelFutureListener() {
</span></span><span class="line"><span class="cl">            @Override
</span></span><span class="line"><span class="cl">            public void operationComplete(ChannelFuture future) throws Exception {
</span></span><span class="line"><span class="cl">                if (!future.isSuccess()) {
</span></span><span class="line"><span class="cl">                    forceClose(child, future.cause());
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        });
</span></span><span class="line"><span class="cl">    } catch (Throwable t) {
</span></span><span class="line"><span class="cl">        forceClose(child, t);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>ServerBootstrapAcceptor 开始就把 msg 强制转换为 Channel。难道不会有其他类型的数据吗？因为 ServerBootstrapAcceptor 是服务端 Channel 中一个特殊的处理器，而服务端 Channel 的 channelRead 事件只会在新连接接入时触发，所以这里拿到的数据都是客户端新连接。</p>
<p>ServerBootstrapAcceptor 通过 childGroup.register() 方法会完成第三和第四两个步骤，将 NioSocketChannel 注册到 Worker 工作线程中，并注册 OP_READ 事件到 NioSocketChannel 的事件集合。在注册过程中比较有意思的一点是，它会调用 pipeline.fireChannelRegistered() 方法传播 channelRegistered 事件，然后再调用 pipeline.fireChannelActive() 方法传播 channelActive 事件。兜了一圈，这又会回到之前我们介绍的 readIfIsAutoRead() 方法，此时它会将 SelectionKey.OP_READ 事件注册到 Channel 的事件集合。</p>
<p>关于服务端如何处理客户端新建连接的具体源码，我在此就不继续展开了。这里留一个小任务，建议你亲自动手分析下 childGroup.register() 的相关源码，从而加深对服务端启动以及新连接处理流程的理解。有了服务端启动源码分析的基础，再去理解客户端新建连接的过程会相对容易很多。</p>
<p>总结</p>
<p>本节课我们深入分析了 Netty 服务端启动的全流程，对其中涉及的核心组件有了基本的认识。Netty 服务端启动的相关源码层次比较深，推荐大家在读源码的时候，可以先把主体流程梳理清楚，开始时先不用纠结具体的方法是用来做什么，自顶而下先画出完整的调用链路图（如下图所示），然后再逐一击破。</p>
<p>下节课，我们将学习 Netty 最核心的 Reactor 线程模型的源码，推荐你把两节课放在一起再进行复习，可以解答你目前不少的疑问，如异步 task 是如何封装并执行的？事件注册之后是如何被处理的？</p>
<p>-&ndash; ### 精选评论 ##### *开： &gt; 不错！ ##### **杰： &gt; 很清晰，感谢 ##### Q： &gt; 再确认了一遍，在「注册服务端 Channel」这个小节应该欠缺了一块内容，实际上在当前执行register操作的时候，线程是main主线程，并不会直接执行register0方法，而是执行eventloop的execute方法（这需要到SingleThreadEventExecutor）类中把当前的register0当做一个非IO的task丢到taskQueue中，并且创建一个线程交由executor执行该线程，此时该线程才会从taskQueue中获取当前的注册任务进行进一步的工作应该有入口进行线程的创建和启动，再处理丢给线程的任务的 ######     讲师回复： &gt;     如果当前 Reactor 线程，会直接调用 register0，如果不是会封装成异步 task。你学习的很认真，源码分析我没办法做到每个函数都面面俱到，还是要自己动手去看比较有效果。 ##### Q： &gt; 来回的看了好几遍，再配合基本的Nio工作流程去理解，终于是大致了解了本小结讲解的内容了。也发现了之前自己理解和认识上的一些错误。另外这里面大量的future和promise，能深入的介绍一下这两个玩意也挺重要的 ######     讲师回复： &gt;     future和promise确实是非常重要的组件，是非常值得研究源码的。这次专栏里我没有列入，有了专栏学习的基础再去研究 future和promise 的源码应该也会轻松一些。 ##### **威： &gt; 觉得受益匪浅，谢谢老师</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/">Netty核心原理剖析与RPC实践</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%9E%B6%E6%9E%8430%E8%AE%B2/17%E5%AD%A6%E4%B9%A0axio%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E6%B8%85%E6%99%B0%E7%9A%84fetch%E5%BA%93/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">17学习axio：封装一个结构清晰的Fetch库</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/18-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%E5%A6%82%E4%BD%95%E5%B7%A7%E7%94%A8%E6%B7%B1%E6%90%9C%E4%B8%8E%E5%B9%BF%E6%90%9C%E7%9A%84%E5%8F%98%E5%BD%A2/">
            <span class="next-text nav-default">18 单词接龙：如何巧用深搜与广搜的变形？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
