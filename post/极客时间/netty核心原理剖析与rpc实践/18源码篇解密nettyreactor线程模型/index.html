<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>18源码篇：解密NettyReactor线程模型 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="通过第一章 Netty 基础课程的学习，我们知道 Reactor 线程模型是 Netty 实现高性能的核心所在，在 Netty 中 EventLoop 是 Reactor 线程模型的核心处理引擎，那么 EventLoop 到底是如何实现的呢？又是如何保证高性能和线程安全性的呢？今天这节课让我们一起一探究竟。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/18%E6%BA%90%E7%A0%81%E7%AF%87%E8%A7%A3%E5%AF%86nettyreactor%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/18%E6%BA%90%E7%A0%81%E7%AF%87%E8%A7%A3%E5%AF%86nettyreactor%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="18源码篇：解密NettyReactor线程模型">
  <meta property="og:description" content="通过第一章 Netty 基础课程的学习，我们知道 Reactor 线程模型是 Netty 实现高性能的核心所在，在 Netty 中 EventLoop 是 Reactor 线程模型的核心处理引擎，那么 EventLoop 到底是如何实现的呢？又是如何保证高性能和线程安全性的呢？今天这节课让我们一起一探究竟。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Netty核心原理剖析与RPC实践">

  <meta itemprop="name" content="18源码篇：解密NettyReactor线程模型">
  <meta itemprop="description" content="通过第一章 Netty 基础课程的学习，我们知道 Reactor 线程模型是 Netty 实现高性能的核心所在，在 Netty 中 EventLoop 是 Reactor 线程模型的核心处理引擎，那么 EventLoop 到底是如何实现的呢？又是如何保证高性能和线程安全性的呢？今天这节课让我们一起一探究竟。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="9592">
  <meta itemprop="keywords" content="Netty核心原理剖析与RPC实践">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="18源码篇：解密NettyReactor线程模型">
  <meta name="twitter:description" content="通过第一章 Netty 基础课程的学习，我们知道 Reactor 线程模型是 Netty 实现高性能的核心所在，在 Netty 中 EventLoop 是 Reactor 线程模型的核心处理引擎，那么 EventLoop 到底是如何实现的呢？又是如何保证高性能和线程安全性的呢？今天这节课让我们一起一探究竟。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">18源码篇：解密NettyReactor线程模型</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 9592 字 </span>
          <span class="more-meta"> 预计阅读 20 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>通过第一章 Netty 基础课程的学习，我们知道 Reactor 线程模型是 Netty 实现高性能的核心所在，在 Netty 中 EventLoop 是 Reactor 线程模型的核心处理引擎，那么 EventLoop 到底是如何实现的呢？又是如何保证高性能和线程安全性的呢？今天这节课让我们一起一探究竟。</p>
<p>说明：本文参考的 Netty 源码版本为 4.1.42.Final。</p>
<p>Reactor 线程执行的主流程</p>
<p>在《事件调度层：为什么 EventLoop 是 Netty 的精髓》的课程中，我们介绍了 EventLoop 的概貌，因为 Netty 是基于 NIO 实现的，所以推荐使用 NioEventLoop 实现，我们再次通过 NioEventLoop 的核心入口 run() 方法回顾 Netty Reactor 线程模型执行的主流程，并以此为基础继续深入研究 NioEventLoop 的逻辑细节。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">protected void run() {
</span></span><span class="line"><span class="cl">    for (;;) {
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {
</span></span><span class="line"><span class="cl">                case SelectStrategy.CONTINUE:
</span></span><span class="line"><span class="cl">                    continue;
</span></span><span class="line"><span class="cl">                case SelectStrategy.BUSY_WAIT:
</span></span><span class="line"><span class="cl">                case SelectStrategy.SELECT:
</span></span><span class="line"><span class="cl">                    select(wakenUp.getAndSet(false)); // 轮询 I/O 事件
</span></span><span class="line"><span class="cl">                    if (wakenUp.get()) {
</span></span><span class="line"><span class="cl">                        selector.wakeup();
</span></span><span class="line"><span class="cl">                    }
</span></span><span class="line"><span class="cl">                default:
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            } catch (IOException e) {
</span></span><span class="line"><span class="cl">                rebuildSelector0();
</span></span><span class="line"><span class="cl">                handleLoopException(e);
</span></span><span class="line"><span class="cl">                continue;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            cancelledKeys = 0;
</span></span><span class="line"><span class="cl">            needsToSelectAgain = false;
</span></span><span class="line"><span class="cl">            final int ioRatio = this.ioRatio;
</span></span><span class="line"><span class="cl">            if (ioRatio == 100) {
</span></span><span class="line"><span class="cl">                try {
</span></span><span class="line"><span class="cl">                    processSelectedKeys(); // 处理 I/O 事件
</span></span><span class="line"><span class="cl">                } finally {
</span></span><span class="line"><span class="cl">                    runAllTasks(); // 处理所有任务
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                final long ioStartTime = System.nanoTime();
</span></span><span class="line"><span class="cl">                try {
</span></span><span class="line"><span class="cl">                    processSelectedKeys(); // 处理 I/O 事件
</span></span><span class="line"><span class="cl">                } finally {
</span></span><span class="line"><span class="cl">                    final long ioTime = System.nanoTime() - ioStartTime;
</span></span><span class="line"><span class="cl">                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio); // 处理完 I/O 事件，再处理异步任务队列
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        } catch (Throwable t) {
</span></span><span class="line"><span class="cl">            handleLoopException(t);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            if (isShuttingDown()) {
</span></span><span class="line"><span class="cl">                closeAll();
</span></span><span class="line"><span class="cl">                if (confirmShutdown()) {
</span></span><span class="line"><span class="cl">                    return;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        } catch (Throwable t) {
</span></span><span class="line"><span class="cl">            handleLoopException(t);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>NioEventLoop 的 run() 方法是一个无限循环，没有任何退出条件，在不间断循环执行以下三件事情，可以用下面这张图形象地表示。</p>
<p>轮询 I/O 事件（select）：轮询 Selector 选择器中已经注册的所有 Channel 的 I/O 事件。</p>
<p>处理 I/O 事件（processSelectedKeys）：处理已经准备就绪的 I/O 事件。</p>
<p>处理异步任务队列（runAllTasks）：Reactor 线程还有一个非常重要的职责，就是处理任务队列中的非 I/O 任务。Netty 提供了 ioRatio 参数用于调整 I/O 事件处理和任务处理的时间比例。</p>
<p>下面我们对 NioEventLoop 的三个步骤进行详细的介绍。</p>
<p>轮询 I/O 事件</p>
<p>我们首先聚焦在轮询 I/O 事件的关键代码片段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">case SelectStrategy.CONTINUE:
</span></span><span class="line"><span class="cl">    continue;
</span></span><span class="line"><span class="cl">case SelectStrategy.BUSY_WAIT:
</span></span><span class="line"><span class="cl">case SelectStrategy.SELECT:
</span></span><span class="line"><span class="cl">    select(wakenUp.getAndSet(false));
</span></span><span class="line"><span class="cl">    if (wakenUp.get()) {
</span></span><span class="line"><span class="cl">        selector.wakeup();
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>NioEventLoop 通过核心方法 select() 不断轮询注册的 I/O 事件。当没有 I/O 事件产生时，为了避免 NioEventLoop 线程一直循环空转，在获取 I/O 事件或者异步任务时需要阻塞线程，等待 I/O 事件就绪或者异步任务产生后才唤醒线程。NioEventLoop 使用 wakeUp 变量表示是否唤醒 selector，Netty 在每一次执行新的一轮循环之前，都会将 wakeUp 设置为 false。</p>
<p>Netty 提供了选择策略 SelectStrategy 对象，它用于控制 select 循环行为，包含 CONTINUE、SELECT、BUSY_WAIT 三种策略，因为 NIO 并不支持 BUSY_WAIT，所以 BUSY_WAIT 与 SELECT 的执行逻辑是一样的。在 I/O 事件循环的过程中 Netty 选择使用何种策略，具体的判断依据如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// DefaultSelectStrategy#calculateStrategy
</span></span><span class="line"><span class="cl">public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception {
</span></span><span class="line"><span class="cl">    return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// NioEventLoop#selectNowSupplier
</span></span><span class="line"><span class="cl">private final IntSupplier selectNowSupplier = new IntSupplier() {
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public int get() throws Exception {
</span></span><span class="line"><span class="cl">        return selectNow();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// NioEventLoop#selectNow
</span></span><span class="line"><span class="cl">int selectNow() throws IOException {
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        return selector.selectNow();
</span></span><span class="line"><span class="cl">    } finally {
</span></span><span class="line"><span class="cl">        if (wakenUp.get()) {
</span></span><span class="line"><span class="cl">            selector.wakeup();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果当前 NioEventLoop 线程存在异步任务，会通过 selectSupplier.get() 最终调用到 selectNow() 方法，selectNow() 是非阻塞，执行后立即返回。如果存在就绪的 I/O 事件，那么会走到 default 分支后直接跳出，然后执行 I/O 事件处理 processSelectedKeys 和异步任务队列处理 runAllTasks 的逻辑。所以在存在异步任务的场景，NioEventLoop 会优先保证 CPU 能够及时处理异步任务。</p>
<p>当 NioEventLoop 线程的不存在异步任务，即任务队列为空，返回的是 SELECT 策略, 就会调用 select(boolean oldWakenUp) 方法，接下来我们看看 select() 内部是如何实现的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private void select(boolean oldWakenUp) throws IOException {
</span></span><span class="line"><span class="cl">    Selector selector = this.selector;
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        int selectCnt = 0;
</span></span><span class="line"><span class="cl">        long currentTimeNanos = System.nanoTime();
</span></span><span class="line"><span class="cl">        long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); // 计算 select 阻塞操作的最后截止时间
</span></span><span class="line"><span class="cl">        long normalizedDeadlineNanos = selectDeadLineNanos - initialNanoTime();
</span></span><span class="line"><span class="cl">        if (nextWakeupTime != normalizedDeadlineNanos) {
</span></span><span class="line"><span class="cl">            nextWakeupTime = normalizedDeadlineNanos;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        for (;;) {
</span></span><span class="line"><span class="cl">            // ------ 1. 检测 select 阻塞操作是否超过截止时间 ------
</span></span><span class="line"><span class="cl">            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;
</span></span><span class="line"><span class="cl">            if (timeoutMillis &lt;= 0) {
</span></span><span class="line"><span class="cl">                if (selectCnt == 0) {
</span></span><span class="line"><span class="cl">                    selector.selectNow();
</span></span><span class="line"><span class="cl">                    selectCnt = 1;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                break;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // ------ 2. 轮询过程中如果有任务产生，中断本次轮询
</span></span><span class="line"><span class="cl">            if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) {
</span></span><span class="line"><span class="cl">                selector.selectNow();
</span></span><span class="line"><span class="cl">                selectCnt = 1;
</span></span><span class="line"><span class="cl">                break;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // ------ 3. select 阻塞等待获取 I/O 事件 ------
</span></span><span class="line"><span class="cl">            int selectedKeys = selector.select(timeoutMillis);
</span></span><span class="line"><span class="cl">            selectCnt ++;
</span></span><span class="line"><span class="cl">            if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {
</span></span><span class="line"><span class="cl">                break;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            if (Thread.interrupted()) {
</span></span><span class="line"><span class="cl">                if (logger.isDebugEnabled()) {
</span></span><span class="line"><span class="cl">                    logger.debug(&#34;Selector.select() returned prematurely because &#34; +
</span></span><span class="line"><span class="cl">                            &#34;Thread.currentThread().interrupt() was called. Use &#34; +
</span></span><span class="line"><span class="cl">                            &#34;NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop.&#34;);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                selectCnt = 1;
</span></span><span class="line"><span class="cl">                break;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // ------ 4. 解决臭名昭著的 JDK epoll 空轮询 Bug ------
</span></span><span class="line"><span class="cl">            long time = System.nanoTime();
</span></span><span class="line"><span class="cl">            if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) {
</span></span><span class="line"><span class="cl">                selectCnt = 1;
</span></span><span class="line"><span class="cl">            } else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;
</span></span><span class="line"><span class="cl">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) {
</span></span><span class="line"><span class="cl">                selector = selectRebuildSelector(selectCnt);
</span></span><span class="line"><span class="cl">                selectCnt = 1;
</span></span><span class="line"><span class="cl">                break;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            currentTimeNanos = time;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) {
</span></span><span class="line"><span class="cl">            if (logger.isDebugEnabled()) {
</span></span><span class="line"><span class="cl">                logger.debug(&#34;Selector.select() returned prematurely {} times in a row for Selector {}.&#34;,
</span></span><span class="line"><span class="cl">                        selectCnt - 1, selector);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    } catch (CancelledKeyException e) {
</span></span><span class="line"><span class="cl">        if (logger.isDebugEnabled()) {
</span></span><span class="line"><span class="cl">            logger.debug(CancelledKeyException.class.getSimpleName() + &#34; raised by a Selector {} - JDK bug?&#34;,
</span></span><span class="line"><span class="cl">                    selector, e);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Netty 为了解决臭名昭著的 JDK epoll 空轮询 Bug，造成整个 select() 方法是相对比较复杂的，我把它划分成四个部分逐一拆解来看。</p>
<p>第一步，检测 select 阻塞操作是否超过截止时间。 在进入无限循环之前，Netty 首先记录了当前时间 currentTimeNanos 以及定时任务队列中最近待执行任务的执行时间 selectDeadLineNanos，Netty 中定时任务队列是按照延迟时间从小到大进行排列的，通过调用 delayNanos(currentTimeNanos) 方法可以获得第一个待执行定时任务的延迟时间。然后代码会进入无限循环。首先判断 currentTimeNanos 是否超过 selectDeadLineNanos 0.5ms 以上，如果超过说明当前任务队列中有定时任务需要立刻执行，所以此时会退出无限循环。退出之前如果从未执行过 select 操作，那么会立即一次非阻塞的 selectNow 操作。那么这里有一个疑问，为什么会留出 0.5ms 的时间窗口呢？在任务队列为空的情况下，可能 select 操作没有获得到任何 I/O 事件就立即停止阻塞返回。</p>
<p>其中有一点容易混淆，Netty 的任务队列包括普通任务、定时任务以及尾部任务，hasTask() 判断的是普通任务队列和尾部队列是否为空，而 delayNanos(currentTimeNanos) 方法获取的是定时任务的延迟时间。</p>
<p>第二步，轮询过程中及时处理产生的任务。 Netty 为了保证任务能够及时执行，会立即一次非阻塞的 selectNow 操作后，立即跳出循环回到事件循环的主流程，确保接下来能够优先执行 runAllTasks。</p>
<p>第三步，select 阻塞等待获取 I/O 事件。 执行 select 阻塞操作，说明任务队列已经为空，而且第一个待执行定时任务还没有到达任务执行的截止时间，需要阻塞等待 timeoutMillis 的超时时间。假设一种极端情况，如果定时任务的截止时间非常久，那么 select 操作岂不是会一直阻塞造成 Netty 无法工作？所以 Netty 在外部线程添加任务的时候，可以唤醒 select 阻塞操作，具体源码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// SingleThreadEventExecutor#execute
</span></span><span class="line"><span class="cl">public void execute(Runnable task) {
</span></span><span class="line"><span class="cl">  	  // 省略其他代码
</span></span><span class="line"><span class="cl">    if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) {
</span></span><span class="line"><span class="cl">        wakeup(inEventLoop); 
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// NioEventLoop#wakeup
</span></span><span class="line"><span class="cl">protected void wakeup(boolean inEventLoop) {
</span></span><span class="line"><span class="cl">    // 如果是外部线程，设置 wakenUp 为true，则唤醒 select 阻塞操作
</span></span><span class="line"><span class="cl">    if (!inEventLoop &amp;&amp; wakenUp.compareAndSet(false, true)) {
</span></span><span class="line"><span class="cl">        selector.wakeup(); 
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>selector.wakeup() 操作的开销是非常大的，所以 Netty 并不是每次都直接调用，在每次调用之前都会先执行 wakenUp.compareAndSet(false, true)，只有设置成功之后才会执行 selector.wakeup() 操作。</p>
<p>第四步，解决臭名昭著的 JDK epoll 空轮询 Bug。 在之前的课程中已经初步介绍了 Netty 的解决方案，在这里结合整体 select 操作我们再做一次回顾。实际上 Netty 并没有从根源上解决该问题，而是巧妙地规避了这个问题。Netty 引入了计数变量 selectCnt，用于记录 select 操作的次数，如果事件轮询时间小于 timeoutMillis，并且在该时间周期内连续发生超过 SELECTOR_AUTO_REBUILD_THRESHOLD（默认512） 次空轮询，说明可能触发了 epoll 空轮询 Bug。Netty 通过重建新的 Selector 对象，将异常的 Selector 中所有的 SelectionKey 会重新注册到新建的 Selector，重建完成之后异常的 Selector 就可以废弃了。</p>
<p>NioEventLoop 轮询 I/O 事件 select 的过程已经讲完了，我们简单总结 select 过程所做的事情。select 操作也是一个无限循环，在事件轮询之前检查任务队列是否为空，确保任务队列中待执行的任务能够及时执行。如果任务队列中已经为空，然后执行 select 阻塞操作获取等待获取 I/O 事件。Netty 通过引入计数器变量，并统计在一定时间窗口内 select 操作的执行次数，识别出可能存在异常的 Selector 对象，然后采用重建 Selector 的方式巧妙地避免了 JDK epoll 空轮询的问题。</p>
<p>处理 I/O 事件</p>
<p>通过 select 过程我们已经获取到准备就绪的 I/O 事件，接下来就需要调用 processSelectedKeys() 方法处理 I/O 事件。在开始处理 I/O 事件之前，Netty 通过 ioRatio 参数控制 I/O 事件处理和任务处理的时间比例，默认为 ioRatio = 50。如果 ioRatio = 100，表示每次都处理完 I/O 事件后，会执行所有的 task。如果 ioRatio &lt; 100，也会优先处理完 I/O 事件，再处理异步任务队列。所以不论如何 processSelectedKeys() 都是先执行的，接下来跟进下 processSelectedKeys() 的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private void processSelectedKeys() {
</span></span><span class="line"><span class="cl">    if (selectedKeys != null) {
</span></span><span class="line"><span class="cl">        processSelectedKeysOptimized();
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        processSelectedKeysPlain(selector.selectedKeys());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>处理 I/O 事件时有两种选择，一种是处理 Netty 优化过的 selectedKeys，另外一种是正常的处理逻辑。根据是否设置了 selectedKeys 来判断使用哪种策略，这两种策略使用的 selectedKeys 集合是不一样的。Netty 优化过的 selectedKeys 是 SelectedSelectionKeySet 类型，而正常逻辑使用的是 JDK HashSet 类型。下面我们逐一介绍两种策略的实现。</p>
<p>1. processSelectedKeysPlain</p>
<p>首先看下正常的处理逻辑 processSelectedKeysPlain 的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private void processSelectedKeysPlain(Set&lt;SelectionKey&gt; selectedKeys) {
</span></span><span class="line"><span class="cl">    if (selectedKeys.isEmpty()) {
</span></span><span class="line"><span class="cl">        return;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    Iterator&lt;SelectionKey&gt; i = selectedKeys.iterator();
</span></span><span class="line"><span class="cl">    for (;;) {
</span></span><span class="line"><span class="cl">        final SelectionKey k = i.next();
</span></span><span class="line"><span class="cl">        final Object a = k.attachment();
</span></span><span class="line"><span class="cl">        i.remove();
</span></span><span class="line"><span class="cl">        if (a instanceof AbstractNioChannel) {
</span></span><span class="line"><span class="cl">            // I/O 事件由 Netty 负责处理
</span></span><span class="line"><span class="cl">            processSelectedKey(k, (AbstractNioChannel) a);
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            // 用户自定义任务
</span></span><span class="line"><span class="cl">            @SuppressWarnings(&#34;unchecked&#34;)
</span></span><span class="line"><span class="cl">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;
</span></span><span class="line"><span class="cl">            processSelectedKey(k, task);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if (!i.hasNext()) {
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if (needsToSelectAgain) {
</span></span><span class="line"><span class="cl">            selectAgain();
</span></span><span class="line"><span class="cl">            selectedKeys = selector.selectedKeys();
</span></span><span class="line"><span class="cl">            if (selectedKeys.isEmpty()) {
</span></span><span class="line"><span class="cl">                break;
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                i = selectedKeys.iterator();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Netty 会遍历依次处理已经就绪的 SelectionKey，SelectionKey 上面可以挂载 attachment。再根据 attachment 属性可以判断 SelectionKey 的类型，SelectionKey 的类型可能是 AbstractNioChannel 和 NioTask，这两种类型对应的处理方式也是不同的，AbstractNioChannel 类型由 Netty 框架负责处理，NioTask 是用户自定义的 task，一般不会是这种类型。我们着重看下 AbstractNioChannel 的处理场景，跟进 processSelectedKey() 的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
</span></span><span class="line"><span class="cl">    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
</span></span><span class="line"><span class="cl">    if (!k.isValid()) { // 检查 Key 是否合法
</span></span><span class="line"><span class="cl">        final EventLoop eventLoop;
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            eventLoop = ch.eventLoop();
</span></span><span class="line"><span class="cl">        } catch (Throwable ignored) {
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if (eventLoop != this || eventLoop == null) {
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        unsafe.close(unsafe.voidPromise()); // Key 不合法，直接关闭连接
</span></span><span class="line"><span class="cl">        return;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        int readyOps = k.readyOps();
</span></span><span class="line"><span class="cl">        // 处理连接事件
</span></span><span class="line"><span class="cl">        if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) {
</span></span><span class="line"><span class="cl">            int ops = k.interestOps();
</span></span><span class="line"><span class="cl">            ops &amp;= ~SelectionKey.OP_CONNECT;
</span></span><span class="line"><span class="cl">            k.interestOps(ops);
</span></span><span class="line"><span class="cl">            unsafe.finishConnect();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 处理可写事件
</span></span><span class="line"><span class="cl">        if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) {
</span></span><span class="line"><span class="cl">            ch.unsafe().forceFlush();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 处理可读事件
</span></span><span class="line"><span class="cl">        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
</span></span><span class="line"><span class="cl">            unsafe.read();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    } catch (CancelledKeyException ignored) {
</span></span><span class="line"><span class="cl">        unsafe.close(unsafe.voidPromise());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>从上述源码可知，processSelectedKey 一共处理了 OP_CONNECT、OP_WRITE、OP_READ 三个事件，我们分别了解下这三个事件的处理过程。</p>
<p>OP_CONNECT 连接建立事件。表示 TCP 连接建立成功, Channel 处于 Active 状态。处理 OP_CONNECT 事件首先将该事件从事件集合中清除，避免事件集合中一直存在连接建立事件，然后调用 unsafe.finishConnect() 方法通知上层连接已经建立。可以跟进 unsafe.finishConnect() 的源码发现会底层调用的 pipeline().fireChannelActive() 方法，这时会产生一个 Inbound 事件，然后会在 Pipeline 中进行传播，依次调用 ChannelHandler 的 channelActive() 方法，通知各个 ChannelHandler 连接建立成功。</p>
<p>OP_WRITE，可写事件。表示上层可以向 Channel 写入数据，通过执行 ch.unsafe().forceFlush() 操作，将数据冲刷到客户端，最终会调用 javaChannel 的 write() 方法执行底层写操作。</p>
<p>OP_READ，可读事件。表示 Channel 收到了可以被读取的新数据。Netty 将 READ 和 Accept 事件进行了统一的封装，都通过 unsafe.read() 进行处理。unsafe.read() 的逻辑可以归纳为几个步骤：从 Channel 中读取数据并存储到分配的 ByteBuf；调用 pipeline.fireChannelRead() 方法产生 Inbound 事件，然后依次调用 ChannelHandler 的 channelRead() 方法处理数据；调用 pipeline.fireChannelReadComplete() 方法完成读操作；最终执行 removeReadOp() 清除 OP_READ 事件。</p>
<p>我们再次回到 processSelectedKeysPlain 的主流程，接下来会判断 needsToSelectAgain 决定是否需要重新轮询。如果 needsToSelectAgain == true，会调用 selectAgain() 方法进行重新轮询，该方法会将 needsToSelectAgain 再次置为 false，然后调用 selectorNow() 后立即返回。</p>
<p>我们回顾一下 Reactor 线程的主流程，会发现每次在处理 I/O 事件之前，needsToSelectAgain 都会被设置为 false，那么在什么场景下 needsToSelectAgain 会再次设置为 true 呢？我们通过查找变量的引用，最后定位到 AbstractChannel#doDeregister。该方法的作用是将 Channel 从当前注册的 Selector 对象中移除，方法内部可能会把 needsToSelectAgain 设置为 true，具体源码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">protected void doDeregister() throws Exception {
</span></span><span class="line"><span class="cl">    eventLoop().cancel(selectionKey());
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">void cancel(SelectionKey key) {
</span></span><span class="line"><span class="cl">    key.cancel();
</span></span><span class="line"><span class="cl">    cancelledKeys ++;
</span></span><span class="line"><span class="cl">    // 当取消的 Key 超过默认阈值 256，needsToSelectAgain 设置为 true
</span></span><span class="line"><span class="cl">    if (cancelledKeys &gt;= CLEANUP_INTERVAL) {
</span></span><span class="line"><span class="cl">        cancelledKeys = 0;
</span></span><span class="line"><span class="cl">        needsToSelectAgain = true;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>当 Netty 在处理 I/O 事件的过程中，如果发现超过默认阈值 256 个 Channel 从 Selector 对象中移除后，会将 needsToSelectAgai 设置为 true，重新做一次轮询操作，从而确保 keySet 的有效性。</p>
<p>2. processSelectedKeysOptimized</p>
<p>介绍完正常的 I/O 事件处理 processSelectedKeysPlain 之后，回过头我们再来分析 Netty 优化的 processSelectedKeysOptimized 就会轻松很多，Netty 是否采用 SelectedSelectionKeySet 类型的优化策略由 DISABLE_KEYSET_OPTIMIZATION 参数决定。那么到底 SelectedSelectionKeySet 是如何进行优化的呢？我们继续跟进下 processSelectedKeysOptimized 的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private void processSelectedKeysOptimized() {
</span></span><span class="line"><span class="cl">    for (int i = 0; i &lt; selectedKeys.size; ++i) {
</span></span><span class="line"><span class="cl">        final SelectionKey k = selectedKeys.keys[i];
</span></span><span class="line"><span class="cl">        selectedKeys.keys[i] = null;
</span></span><span class="line"><span class="cl">        final Object a = k.attachment();
</span></span><span class="line"><span class="cl">        if (a instanceof AbstractNioChannel) {
</span></span><span class="line"><span class="cl">            processSelectedKey(k, (AbstractNioChannel) a);
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            @SuppressWarnings(&#34;unchecked&#34;)
</span></span><span class="line"><span class="cl">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;
</span></span><span class="line"><span class="cl">            processSelectedKey(k, task);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if (needsToSelectAgain) {
</span></span><span class="line"><span class="cl">            selectedKeys.reset(i + 1);
</span></span><span class="line"><span class="cl">            selectAgain();
</span></span><span class="line"><span class="cl">            i = -1;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以发现 processSelectedKeysOptimized 与 processSelectedKeysPlain 的代码结构非常相似，其中最重要的一点就是 selectedKeys 的遍历方式是不同的，所以还是需要看下 SelectedSelectionKeySet 的源码一探究竟。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">final</span> <span class="k">class</span> <span class="n">SelectedSelectionKeySet</span> <span class="k">extends</span> <span class="n">AbstractSet</span><span class="o">&lt;</span><span class="n">SelectionKey</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SelectionKey</span><span class="p">[]</span> <span class="n">keys</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">SelectedSelectionKeySet</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">keys</span> <span class="o">=</span> <span class="n">new</span> <span class="n">SelectionKey</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="err">@</span><span class="n">Override</span>
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="n">boolean</span> <span class="n">add</span><span class="p">(</span><span class="n">SelectionKey</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">o</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="bp">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">keys</span><span class="p">[</span><span class="n">size</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">keys</span><span class="o">.</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">increaseCapacity</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="bp">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">省略其他代码</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为 SelectedSelectionKeySet 内部使用的是 SelectionKey 数组，所以 processSelectedKeysOptimized 可以直接通过遍历数组取出 I/O 事件，相比 JDK HashSet 的遍历效率更高。SelectedSelectionKeySet 内部通过 size 变量记录数据的逻辑长度，每次执行 add 操作时，会把对象添加到 SelectionKey[] 尾部。当 size 等于 SelectionKey[] 的真实长度时，SelectionKey[] 会进行扩容。相比于 HashSet，SelectionKey[] 不需要考虑哈希冲突的问题，所以可以实现 O(1) 时间复杂度的 add 操作。</p>
<p>那么 SelectedSelectionKeySet 是什么时候生成的呢？通过查找 SelectedSelectionKeySet 的引用定位到 NioEventLoop#openSelector 方法，摘录核心源码片段如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private SelectorTuple openSelector() {
</span></span><span class="line"><span class="cl">    // 省略其他代码
</span></span><span class="line"><span class="cl">    final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet();
</span></span><span class="line"><span class="cl">    Object maybeException = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
</span></span><span class="line"><span class="cl">        @Override
</span></span><span class="line"><span class="cl">        public Object run() {
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                Field selectedKeysField = selectorImplClass.getDeclaredField(&#34;selectedKeys&#34;);
</span></span><span class="line"><span class="cl">                Field publicSelectedKeysField = selectorImplClass.getDeclaredField(&#34;publicSelectedKeys&#34;);
</span></span><span class="line"><span class="cl">                if (PlatformDependent.javaVersion() &gt;= 9 &amp;&amp; PlatformDependent.hasUnsafe()) {
</span></span><span class="line"><span class="cl">                    long selectedKeysFieldOffset = PlatformDependent.objectFieldOffset(selectedKeysField);
</span></span><span class="line"><span class="cl">                    long publicSelectedKeysFieldOffset =
</span></span><span class="line"><span class="cl">                            PlatformDependent.objectFieldOffset(publicSelectedKeysField);
</span></span><span class="line"><span class="cl">                    if (selectedKeysFieldOffset != -1 &amp;&amp; publicSelectedKeysFieldOffset != -1) {
</span></span><span class="line"><span class="cl">                        PlatformDependent.putObject(
</span></span><span class="line"><span class="cl">                                unwrappedSelector, selectedKeysFieldOffset, selectedKeySet);
</span></span><span class="line"><span class="cl">                        PlatformDependent.putObject(
</span></span><span class="line"><span class="cl">                                unwrappedSelector, publicSelectedKeysFieldOffset, selectedKeySet);
</span></span><span class="line"><span class="cl">                        return null;
</span></span><span class="line"><span class="cl">                    }
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                // 省略其他代码
</span></span><span class="line"><span class="cl">            } catch (NoSuchFieldException e) {
</span></span><span class="line"><span class="cl">                return e;
</span></span><span class="line"><span class="cl">            } catch (IllegalAccessException e) {
</span></span><span class="line"><span class="cl">                return e;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    });    
</span></span><span class="line"><span class="cl">    // 省略其他代码
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Netty 通过反射的方式，将 Selector 对象内部的 selectedKeys 和 publicSelectedKeys 替换为 SelectedSelectionKeySet，原先 selectedKeys 和 publicSelectedKeys 这两个字段都是 HashSet 类型。这真是很棒的一个小技巧，对于 JDK 底层的优化一般是很少见的，Netty 在细节优化上追求极致的精神值得我们学习。</p>
<p>到这里，Reactor 线程主流程的第二步。处理 I/O 事件 processSelectedKeys 已经讲完了，简单总结一下 processSelectedKeys 的要点。处理 I/O 事件时有两种选择，一种是处理 Netty 优化过的 selectedKeys，另外一种是正常的处理逻辑，两种策略的处理逻辑是相似的，都是通过获取 SelectionKey 上挂载的 attachment 判断 SelectionKey 的类型，不同的 SelectionKey 的类型又会调用不同的处理方法，然后通过 Pipeline 进行事件传播。Netty 优化过的 selectedKeys 是使用数组存储的 SelectionKey，相比于 JDK 的 HashSet 遍历效率更高效。processSelectedKeys 还做了更多的优化处理，如果发现超过默认阈值 256 个 Channel 从 Selector 对象中移除后，会重新做一次轮询操作，以确保 keySet 的有效性。</p>
<p>处理异步任务队列</p>
<p>继续分析 Reactor 线程主流程的最后一步，处理异步任务队列 runAllTasks。为什么 Netty 能够保证 Channel 的操作都是线程安全的呢？这要归功于 Netty 的任务机制。下面我们从任务添加和任务执行两个方面介绍 Netty 的任务机制。</p>
<p>任务添加</p>
<p>NioEventLoop 内部有两个非常重要的异步任务队列，分别为普通任务队列和定时任务队列。NioEventLoop 提供了 execute() 和 schedule() 方法用于向不同的队列中添加任务，execute() 用于添加普通任务，schedule() 方法用于添加定时任务。</p>
<p>首先我们看下如何添加普通任务。NioEventLoop 继承自 SingleThreadEventExecutor，SingleThreadEventExecutor 提供了 execute() 用于添加普通任务，源码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public void execute(Runnable task) {
</span></span><span class="line"><span class="cl">    if (task == null) {
</span></span><span class="line"><span class="cl">        throw new NullPointerException(&#34;task&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    boolean inEventLoop = inEventLoop();
</span></span><span class="line"><span class="cl">    addTask(task);
</span></span><span class="line"><span class="cl">    if (!inEventLoop) {
</span></span><span class="line"><span class="cl">        startThread();
</span></span><span class="line"><span class="cl">        if (isShutdown()) {
</span></span><span class="line"><span class="cl">            boolean reject = false;
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                if (removeTask(task)) {
</span></span><span class="line"><span class="cl">                    reject = true;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            } catch (UnsupportedOperationException e) {
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            if (reject) {
</span></span><span class="line"><span class="cl">                reject();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) {
</span></span><span class="line"><span class="cl">        wakeup(inEventLoop);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">protected void addTask(Runnable task) {
</span></span><span class="line"><span class="cl">    if (task == null) {
</span></span><span class="line"><span class="cl">        throw new NullPointerException(&#34;task&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    if (!offerTask(task)) {
</span></span><span class="line"><span class="cl">        reject(task);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">final boolean offerTask(Runnable task) {
</span></span><span class="line"><span class="cl">    if (isShutdown()) {
</span></span><span class="line"><span class="cl">        reject();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return taskQueue.offer(task);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们一步步跟进 addTask(task)，发现最后是将任务添加到了 taskQueue，SingleThreadEventExecutor 中 taskQueue 就是普通任务队列。taskQueue 默认使用的是 Mpsc Queue，可以理解为多生产者单消费者队列，关于 Mpsc Queue 我们会有一节课程单独介绍，在这里不详细展开。此外，在任务处理的场景下，inEventLoop() 始终是返回 true，始终都是在 Reactor 线程内执行，既然在 Reactor 线程内都是串行执行，可以保证线程安全，那为什么还需要 Mpsc Queue 呢？我们继续往下看。</p>
<p>这里举一种很常见的场景，比如在 RPC 业务线程池里处理完业务请求后，可以根据用户请求拿到关联的 Channel，将数据写回客户端。那么对于外部线程调用 Channel 的相关方法 Netty 是如何操作的呢？我们一直跟进下 channel.write() 的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// #AbstractChannel#write
</span></span><span class="line"><span class="cl">public ChannelFuture write(Object msg) {
</span></span><span class="line"><span class="cl">    return pipeline.write(msg);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// AbstractChannelHandlerContext#write
</span></span><span class="line"><span class="cl">private void write(Object msg, boolean flush, ChannelPromise promise) {
</span></span><span class="line"><span class="cl">    // 省略其他代码
</span></span><span class="line"><span class="cl">    final AbstractChannelHandlerContext next = findContextOutbound(flush ?
</span></span><span class="line"><span class="cl">            (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);
</span></span><span class="line"><span class="cl">    final Object m = pipeline.touch(msg, next);
</span></span><span class="line"><span class="cl">    EventExecutor executor = next.executor();
</span></span><span class="line"><span class="cl">    if (executor.inEventLoop()) { // Reactor 线程内部调用
</span></span><span class="line"><span class="cl">        if (flush) {
</span></span><span class="line"><span class="cl">            next.invokeWriteAndFlush(m, promise);
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            next.invokeWrite(m, promise);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    } else { // 外部线程调用会走到该分支
</span></span><span class="line"><span class="cl">        final AbstractWriteTask task;
</span></span><span class="line"><span class="cl">        if (flush) {
</span></span><span class="line"><span class="cl">            task = WriteAndFlushTask.newInstance(next, m, promise);
</span></span><span class="line"><span class="cl">        }  else {
</span></span><span class="line"><span class="cl">            task = WriteTask.newInstance(next, m, promise);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if (!safeExecute(executor, task, promise, m)) {
</span></span><span class="line"><span class="cl">            task.cancel();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// AbstractChannelHandlerContext#safeExecute
</span></span><span class="line"><span class="cl">private static boolean safeExecute(EventExecutor executor, Runnable runnable, ChannelPromise promise, Object msg) {
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        executor.execute(runnable);
</span></span><span class="line"><span class="cl">        return true;
</span></span><span class="line"><span class="cl">    } catch (Throwable cause) {
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            promise.setFailure(cause);
</span></span><span class="line"><span class="cl">        } finally {
</span></span><span class="line"><span class="cl">            if (msg != null) {
</span></span><span class="line"><span class="cl">                ReferenceCountUtil.release(msg);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return false;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果是 Reactor 线程发起调用 channel.write() 方法，inEventLoop() 返回 true，此时直接在 Reactor 线程内部直接交由 Pipeline 进行事件处理。如果是外部线程调用，那么会走到 else 分支，此时会将写操作封装成一个 WriteTask，然后通过 safeExecute() 执行，可以发现 safeExecute() 就是调用的 SingleThreadEventExecutor#execute() 方法，最终会将任务添加到 taskQueue 中。因为多个外部线程可能会并发操作同一个 Channel，这时候 Mpsc Queue 就可以保证线程的安全性。</p>
<p>接下来我们再分析定时任务的添加过程。与普通任务类似，定时任务也会有 Reactor 线程内和外部线程两种场景，我们直接跟进到 AbstractScheduledEventExecutor#schedule() 源码的深层，发现如下核心代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(final ScheduledFutureTask&lt;V&gt; task) {
</span></span><span class="line"><span class="cl">    if (inEventLoop()) { // Reactor 线程内部
</span></span><span class="line"><span class="cl">        scheduledTaskQueue().add(task.setId(nextTaskId++));
</span></span><span class="line"><span class="cl">    } else { // 外部线程
</span></span><span class="line"><span class="cl">        executeScheduledRunnable(new Runnable() {
</span></span><span class="line"><span class="cl">            @Override
</span></span><span class="line"><span class="cl">            public void run() {
</span></span><span class="line"><span class="cl">                scheduledTaskQueue().add(task.setId(nextTaskId++));
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }, true, task.deadlineNanos());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return task;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">PriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue() {
</span></span><span class="line"><span class="cl">    if (scheduledTaskQueue == null) {
</span></span><span class="line"><span class="cl">        scheduledTaskQueue = new DefaultPriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt;(
</span></span><span class="line"><span class="cl">                SCHEDULED_FUTURE_TASK_COMPARATOR,
</span></span><span class="line"><span class="cl">                11);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return scheduledTaskQueue;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">void executeScheduledRunnable(Runnable runnable,
</span></span><span class="line"><span class="cl">                                        @SuppressWarnings(&#34;unused&#34;) boolean isAddition,
</span></span><span class="line"><span class="cl">                                        @SuppressWarnings(&#34;unused&#34;) long deadlineNanos) {
</span></span><span class="line"><span class="cl">    execute(runnable);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>AbstractScheduledEventExecutor 中 scheduledTaskQueue 就是定时任务队列，可以看到 scheduledTaskQueue 的默认实现是优先级队列 DefaultPriorityQueue，这样可以方便队列中的任务按照时间进行排序。但是 DefaultPriorityQueue 是非线程安全的，如果是 Reactor 线程内部调用，因为是串行执行，所以不会有线程安全问题。如果是外部线程添加定时任务，我们发现 Netty 把添加定时任务的操作又再次封装成一个任务交由 executeScheduledRunnable() 处理，而 executeScheduledRunnable() 中又再次调用了普通任务的 execute() 的方法，巧妙地借助普通任务场景中 Mpsc Queue 解决了外部线程添加定时任务的线程安全问题。</p>
<p>任务执行</p>
<p>介绍完 Netty 中不同任务的添加过程，回过头我们再来分析 Reactor 线程是如何执行这些任务的呢？通过 Reactor 线程主流程的分析，我们知道处理异步任务队列有 runAllTasks() 和 runAllTasks(long timeoutNanos) 两种实现，第一种会处理所有任务，第二种是带有超时时间来处理任务。之所以设置超时时间是为了防止 Reactor 线程处理任务时间过长而导致 I/O 事件阻塞，我们着重分析下 runAllTasks(long timeoutNanos) 的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">protected boolean runAllTasks(long timeoutNanos) {
</span></span><span class="line"><span class="cl">    fetchFromScheduledTaskQueue(); // 1. 合并定时任务到普通任务队列
</span></span><span class="line"><span class="cl">    // 2. 从普通任务队列中取出任务并处理
</span></span><span class="line"><span class="cl">    Runnable task = pollTask();
</span></span><span class="line"><span class="cl">    if (task == null) {
</span></span><span class="line"><span class="cl">        afterRunningAllTasks();
</span></span><span class="line"><span class="cl">        return false;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 计算任务处理的超时时间
</span></span><span class="line"><span class="cl">    final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;
</span></span><span class="line"><span class="cl">    long runTasks = 0;
</span></span><span class="line"><span class="cl">    long lastExecutionTime;
</span></span><span class="line"><span class="cl">    for (;;) {
</span></span><span class="line"><span class="cl">        safeExecute(task); // 执行任务
</span></span><span class="line"><span class="cl">        runTasks ++;
</span></span><span class="line"><span class="cl">        // 每执行 64 个任务检查一下是否超时
</span></span><span class="line"><span class="cl">        if ((runTasks &amp; 0x3F) == 0) {
</span></span><span class="line"><span class="cl">            lastExecutionTime = ScheduledFutureTask.nanoTime();
</span></span><span class="line"><span class="cl">            if (lastExecutionTime &gt;= deadline) {
</span></span><span class="line"><span class="cl">                break;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        task = pollTask(); // 继续取出下一个任务
</span></span><span class="line"><span class="cl">        if (task == null) {
</span></span><span class="line"><span class="cl">            lastExecutionTime = ScheduledFutureTask.nanoTime();
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 3. 收尾工作
</span></span><span class="line"><span class="cl">    afterRunningAllTasks();
</span></span><span class="line"><span class="cl">    this.lastExecutionTime = lastExecutionTime;
</span></span><span class="line"><span class="cl">    return true;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>异步任务处理 runAllTasks 的过程可以分为三步：合并定时任务到普通任务队列，然后从普通任务队列中取出任务并处理，最后进行收尾工作。我们分别看看三个步骤都是如何实现的。</p>
<p>第一步，合并定时任务到普通任务队列，对应的实现是 fetchFromScheduledTaskQueue() 方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private boolean fetchFromScheduledTaskQueue() {
</span></span><span class="line"><span class="cl">    if (scheduledTaskQueue == null || scheduledTaskQueue.isEmpty()) {
</span></span><span class="line"><span class="cl">        return true;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    long nanoTime = AbstractScheduledEventExecutor.nanoTime();
</span></span><span class="line"><span class="cl">    for (;;) {
</span></span><span class="line"><span class="cl">        Runnable scheduledTask = pollScheduledTask(nanoTime); // 从定时任务队列中取出截止时间小于等于当前时间的定时任务
</span></span><span class="line"><span class="cl">        if (scheduledTask == null) {
</span></span><span class="line"><span class="cl">            return true;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if (!taskQueue.offer(scheduledTask)) {
</span></span><span class="line"><span class="cl">            // 如果普通任务队列已满，把定时任务放回
</span></span><span class="line"><span class="cl">            scheduledTaskQueue.add((ScheduledFutureTask&lt;?&gt;) scheduledTask);
</span></span><span class="line"><span class="cl">            return false;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">protected final Runnable pollScheduledTask(long nanoTime) {
</span></span><span class="line"><span class="cl">    assert inEventLoop();
</span></span><span class="line"><span class="cl">    Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = this.scheduledTaskQueue;
</span></span><span class="line"><span class="cl">    ScheduledFutureTask&lt;?&gt; scheduledTask = scheduledTaskQueue == null ? null : scheduledTaskQueue.peek();
</span></span><span class="line"><span class="cl">    // 如果定时任务的 deadlineNanos 小于当前时间就取出
</span></span><span class="line"><span class="cl">    if (scheduledTask == null || scheduledTask.deadlineNanos() - nanoTime &gt; 0) {
</span></span><span class="line"><span class="cl">        return null;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    scheduledTaskQueue.remove();
</span></span><span class="line"><span class="cl">    return scheduledTask;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>定时任务只有满足截止时间 deadlineNanos 小于当前时间，才可以取出合并到普通任务。由于定时任务是按照截止时间 deadlineNanos 从小到大排列的，所以取出的定时任务不满足合并条件，那么定时任务队列中剩下的所有任务都不会满足条件，合并操作完成并退出。</p>
<p>第二步，从普通任务队列中取出任务并处理，可以回过头再看 runAllTasks(long timeoutNanos) 第二部分的源码，我已经用注释标明。真正处理任务的 safeExecute() 非常简单，就是直接调用的 Runnable 的 run() 方法。因为异步任务处理是有超时时间的，所以 Netty 采取了定时检测的策略，每执行 64 个任务的时候就会检查一下是否超时，这也是出于对性能的折中考虑，如果异步队列中有大量的短时间任务，每一次执行完都检测一次超时性能会有所降低。</p>
<p>第三步，收尾工作，对应的是 afterRunningAllTasks() 方法实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">protected void afterRunningAllTasks() {
</span></span><span class="line"><span class="cl">    runAllTasksFrom(tailTasks);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">protected final boolean runAllTasksFrom(Queue&lt;Runnable&gt; taskQueue) {
</span></span><span class="line"><span class="cl">    Runnable task = pollTaskFrom(taskQueue);
</span></span><span class="line"><span class="cl">    if (task == null) {
</span></span><span class="line"><span class="cl">        return false;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    for (;;) {
</span></span><span class="line"><span class="cl">        safeExecute(task);
</span></span><span class="line"><span class="cl">        task = pollTaskFrom(taskQueue);
</span></span><span class="line"><span class="cl">        if (task == null) {
</span></span><span class="line"><span class="cl">            return true;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的尾部队列 tailTasks 相比于普通任务队列优先级较低，可以理解为是收尾任务，在每次执行完 taskQueue 中任务后会去获取尾部队列中任务执行。可以看出 afterRunningAllTasks() 就是把尾部队列 tailTasks 里的任务以此取出执行一遍。尾部队列并不常用，一般用于什么场景呢？例如你想对 Netty 的运行状态做一些统计数据，例如任务循环的耗时、占用物理内存的大小等等，都可以向尾部队列添加一个收尾任务完成统计数据的实时更新。</p>
<p>到这里，Netty 处理异步任务队列的流程就讲完了，再做一个简单的总结。异步任务主要分为普通任务和定时任务两种，在任务添加和任务执行时，都需要考虑 Reactor 线程内和外部线程两种情况。外部线程添加定时任务时，Netty 巧妙地借助普通任务的 Mpsc Queue 解决多线程并发操作时的线程安全问题。Netty 执行任务之前会将满足条件的定时任务合并到普通任务队列，由普通任务队列统一负责执行，并且每执行 64 个任务的时候就会检查一下是否超时。</p>
<p>总结</p>
<p>Reactor 线程模型是 Netty 最核心的内容，本节课我也花了大量的篇幅对其进行讲解。NioEventLoop 作为 Netty Reactor 线程的实现，它的设计原理是非常精妙的，值得我们反复阅读和思考。我们始终需要记住 NioEventLoop 的无限循环中所做的三件事：轮询 I/O 事件，处理 I/O 事件，处理异步任务队列。</p>
<p>关于 Netty Reactor 线程模型经常会遇到几个高频的面试问题，读完本节课之后你是否都已经清楚了呢？</p>
<p>Netty 的 NioEventLoop 是如何实现的？它为什么能够保证 Channel 的操作是线程安全的？</p>
<p>Netty 如何解决 JDK epoll 空轮询 Bug？</p>
<p>NioEventLoop 是如何实现无锁化的？</p>
<p>欢迎你在评论区留言，期待看到你分享关于 Reactor 线程模型更多的认识和思考。</p>
<p>-&ndash; ### 精选评论 ##### Q： &gt; 1 可以理解为线程池套线程池，只是里面的线程池只有1个线程，在group创建中会生成对应的eventloop，channel在boss生成包装成Niosocketchannel后，采用基于长度不同的两种策略方案丢到work的一个eventloop，也就是一个线程，必然可以保证线程安全。不过从另一个角度看也不能绝对的保证业务的线程安全，多个业务线程拿到channel后乱搞数据也说不定嘞2 不是解决，是规避，在约定的时间内，空转次数超标，就认为可能出现该bug，那就重新搞一个select，把之前的selectkey注册到新的select，废弃老的那个3 一个线程，死循环一般从自己关联的taskqueue获取任务执行，而且taskqueue添加任务保证了线程安全，那就不需要锁了，来一个处理一个，类似于最简单的生产消费模型 ######     讲师回复： &gt;     回答的很棒，有自己的理解。 ##### **亮： &gt; NioEventLoop是一个异步工作任务轮巡线程池，里面核心点就是任务处理，分为普通任务和定时任务。任务是由IO事件处理而来。处理IO事件的连接事件，可读，可写事件。这些IO事件是通过轮巡而来。轮巡又特别处理了epollo的空轮巡的问题，通过特定阈值来确定是否重建select。 ##### *雄： &gt; 有收获，谢谢老师 ##### **5134： &gt; 真好，点赞 ##### **新： &gt; 老师，可以问下配图是使用什么软件画的吗，好精致漂亮，希望老师回复下😁 ######     编辑回复： &gt;     Sketch ##### 无： &gt; 2020-12-21 打卡，文章很不错，需要反复阅读理解消化。 ######     编辑回复： &gt;     加油学习~ ##### **丁： &gt; 老师为什么 Netty 能够保证 Channel 的操作都是线程安全的呢。这句话我不是很明白，不是每个channel都会分配到一个EventGroupLoop下的其中一个NioEventLoop去执行的吗？这不就是相当于线程安全的吗 ######     讲师回复： &gt;     说明你已经很懂啦，我们需要掌握 Netty 串行无锁化的精髓。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/">Netty核心原理剖析与RPC实践</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/18%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8springcloudstream%E5%A6%82%E4%BD%95%E4%B8%BA%E7%B3%BB%E7%BB%9F%E6%8F%90%E5%8D%87%E4%BC%B8%E7%BC%A9%E6%80%A7/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">18消息驱动：SpringCloudStream如何为系统提升伸缩性？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/19-%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84%E5%A6%82%E4%BD%95%E7%AA%81%E7%A0%B4%E7%BB%8F%E5%85%B8%E9%A2%98%E5%9E%8B%E6%8E%8C%E6%8F%A1%E8%A7%A3%E9%A2%98%E6%A8%A1%E6%9D%BF/">
            <span class="next-text nav-default">19 最小体力消耗路径：如何突破经典题型，掌握解题模板？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
