<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>20技巧篇：Netty的FatThreadLocal究竟比ThreadLocal快在哪儿？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="在前面几篇源码解析的课程中，我们都有在源码中发现 FastThreadLocal 的身影。顾名思义，Netty 作为高性能的网络通信框架，FastThreadLocal 是比 JDK 自身的 ThreadLocal 性能更高的通信框架。FastThreadLocal 到底比 ThreadLocal 快在哪里呢？这节课我们就一起来探索 FastThreadLocal 高性能的奥秘。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/20%E6%8A%80%E5%B7%A7%E7%AF%87netty%E7%9A%84fatthreadlocal%E7%A9%B6%E7%AB%9F%E6%AF%94threadlocal%E5%BF%AB%E5%9C%A8%E5%93%AA%E5%84%BF/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/20%E6%8A%80%E5%B7%A7%E7%AF%87netty%E7%9A%84fatthreadlocal%E7%A9%B6%E7%AB%9F%E6%AF%94threadlocal%E5%BF%AB%E5%9C%A8%E5%93%AA%E5%84%BF/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="20技巧篇：Netty的FatThreadLocal究竟比ThreadLocal快在哪儿？">
  <meta property="og:description" content="在前面几篇源码解析的课程中，我们都有在源码中发现 FastThreadLocal 的身影。顾名思义，Netty 作为高性能的网络通信框架，FastThreadLocal 是比 JDK 自身的 ThreadLocal 性能更高的通信框架。FastThreadLocal 到底比 ThreadLocal 快在哪里呢？这节课我们就一起来探索 FastThreadLocal 高性能的奥秘。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Netty核心原理剖析与RPC实践">

  <meta itemprop="name" content="20技巧篇：Netty的FatThreadLocal究竟比ThreadLocal快在哪儿？">
  <meta itemprop="description" content="在前面几篇源码解析的课程中，我们都有在源码中发现 FastThreadLocal 的身影。顾名思义，Netty 作为高性能的网络通信框架，FastThreadLocal 是比 JDK 自身的 ThreadLocal 性能更高的通信框架。FastThreadLocal 到底比 ThreadLocal 快在哪里呢？这节课我们就一起来探索 FastThreadLocal 高性能的奥秘。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="7802">
  <meta itemprop="keywords" content="Netty核心原理剖析与RPC实践">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="20技巧篇：Netty的FatThreadLocal究竟比ThreadLocal快在哪儿？">
  <meta name="twitter:description" content="在前面几篇源码解析的课程中，我们都有在源码中发现 FastThreadLocal 的身影。顾名思义，Netty 作为高性能的网络通信框架，FastThreadLocal 是比 JDK 自身的 ThreadLocal 性能更高的通信框架。FastThreadLocal 到底比 ThreadLocal 快在哪里呢？这节课我们就一起来探索 FastThreadLocal 高性能的奥秘。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">20技巧篇：Netty的FatThreadLocal究竟比ThreadLocal快在哪儿？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 7802 字 </span>
          <span class="more-meta"> 预计阅读 16 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>在前面几篇源码解析的课程中，我们都有在源码中发现 FastThreadLocal 的身影。顾名思义，Netty 作为高性能的网络通信框架，FastThreadLocal 是比 JDK 自身的 ThreadLocal 性能更高的通信框架。FastThreadLocal 到底比 ThreadLocal 快在哪里呢？这节课我们就一起来探索 FastThreadLocal 高性能的奥秘。</p>
<p>说明：本文参考的 Netty 源码版本为 4.1.42.Final。</p>
<p>JDK ThreadLocal 基本原理</p>
<p>JDK ThreadLocal 不仅是高频的面试知识点，而且在日常工作中也是常用一种工具，所以首先我们先学习下 Java 原生的 ThreadLocal 的实现原理，可以帮助我们更好地对比和理解 Netty 的 FastThreadLocal。</p>
<p>如果你需要变量在多线程之间隔离，或者在同线程内的类和方法中共享，那么 ThreadLocal 大显身手的时候就到了。ThreadLocal 可以理解为线程本地变量，它是 Java 并发编程中非常重要的一个类。ThreadLocal 为变量在每个线程中都创建了一个副本，该副本只能被当前线程访问，多线程之间是隔离的，变量不能在多线程之间共享。这样每个线程修改变量副本时，不会对其他线程产生影响。</p>
<p>接下来我们通过一个例子看下 ThreadLocal 如何使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class ThreadLocalTest {
</span></span><span class="line"><span class="cl">    private static final ThreadLocal&lt;String&gt; THREAD_NAME_LOCAL = ThreadLocal.withInitial(() -&gt; Thread.currentThread().getName());
</span></span><span class="line"><span class="cl">    private static final ThreadLocal&lt;TradeOrder&gt; TRADE_THREAD_LOCAL = new ThreadLocal&lt;&gt;();
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 2; i++) {
</span></span><span class="line"><span class="cl">            int tradeId = i;
</span></span><span class="line"><span class="cl">            new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">                TradeOrder tradeOrder = new TradeOrder(tradeId, tradeId % 2 == 0 ? &#34;已支付&#34; : &#34;未支付&#34;);
</span></span><span class="line"><span class="cl">                TRADE_THREAD_LOCAL.set(tradeOrder);
</span></span><span class="line"><span class="cl">                System.out.println(&#34;threadName: &#34; + THREAD_NAME_LOCAL.get());
</span></span><span class="line"><span class="cl">                System.out.println(&#34;tradeOrder info：&#34; + TRADE_THREAD_LOCAL.get());
</span></span><span class="line"><span class="cl">            }, &#34;thread-&#34; + i).start();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    static class TradeOrder {
</span></span><span class="line"><span class="cl">        long id;
</span></span><span class="line"><span class="cl">        String status;
</span></span><span class="line"><span class="cl">        public TradeOrder(int id, String status) {
</span></span><span class="line"><span class="cl">            this.id = id;
</span></span><span class="line"><span class="cl">            this.status = status;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        @Override
</span></span><span class="line"><span class="cl">        public String toString() {
</span></span><span class="line"><span class="cl">            return &#34;id=&#34; + id + &#34;, status=&#34; + status;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在上述示例中，构造了 THREAD_NAME_LOCAL 和 TRADE_THREAD_LOCAL 两个 ThreadLocal 变量，分别用于记录当前线程名称和订单交易信息。ThreadLocal 是可以支持泛型的，THREAD_NAME_LOCAL 和 TRADE_THREAD_LOCAL 存放 String 类型和 TradeOrder 对象类型的数据，你可以通过 set()/get() 方法设置和读取 ThreadLocal 实例。一起看下示例代码的运行结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">threadName: thread-0
</span></span><span class="line"><span class="cl">threadName: thread-1
</span></span><span class="line"><span class="cl">tradeOrder info：id=1, status=未支付
</span></span><span class="line"><span class="cl">tradeOrder info：id=0, status=已支付
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出 thread-1 和 thread-2 虽然操作的是同一个 ThreadLocal 对象，但是它们取到了不同的线程名称和订单交易信息。那么一个线程内如何存在多个 ThreadLocal 对象，每个 ThreadLocal 对象是如何存储和检索的呢？</p>
<p>接下来我们看看 ThreadLocal 的实现原理。既然多线程访问 ThreadLocal 变量时都会有自己独立的实例副本，那么很容易想到的方案就是在 ThreadLocal 中维护一个 Map，记录线程与实例之间的映射关系。当新增线程和销毁线程时都需要更新 Map 中的映射关系，因为会存在多线程并发修改，所以需要保证 Map 是线程安全的。那么 JDK 的 ThreadLocal 是这么实现的吗？答案是 NO。因为在高并发的场景并发修改 Map 需要加锁，势必会降低性能。JDK 为了避免加锁，采用了相反的设计思路。以 Thread 入手，在 Thread 中维护一个 Map，记录 ThreadLocal 与实例之间的映射关系，这样在同一个线程内，Map 就不需要加锁了。示例代码中线程 Thread 和 ThreadLocal 的关系可以用以下这幅图表示。</p>
<p>那么在 Thread 内部，维护映射关系的 Map 是如何实现的呢？从源码中可以发现 Thread 使用的是 ThreadLocal 的内部类 ThreadLocalMap，所以 Thread、ThreadLocal 和 ThreadLocalMap 之间的关系可以用下图表示：</p>
<p>为了更加深入理解 ThreadLocal，了解 ThreadLocalMap 的内部实现是非常有必要的。ThreadLocalMap 其实与 HashMap 的数据结构类似，但是 ThreadLocalMap 不具备通用性，它是为 ThreadLocal 量身定制的。</p>
<p>ThreadLocalMap 是一种使用线性探测法实现的哈希表，底层采用数组存储数据。如下图所示，ThreadLocalMap 会初始化一个长度为 16 的 Entry 数组，每个 Entry 对象用于保存 key-value 键值对。与 HashMap 不同的是，Entry 的 key 就是 ThreadLocal 对象本身，value 就是用户具体需要存储的值。</p>
<p>当调用 ThreadLocal.set() 添加 Entry 对象时，是如何解决 Hash 冲突的呢？这就需要我们了解线性探测法的实现原理。每个 ThreadLocal 在初始化时都会有一个 Hash 值为 threadLocalHashCode，每增加一个 ThreadLocal， Hash 值就会固定增加一个魔术 HASH_INCREMENT = 0x61c88647。为什么取 0x61c88647 这个魔数呢？实验证明，通过 0x61c88647 累加生成的 threadLocalHashCode 与 2 的幂取模，得到的结果可以较为均匀地分布在长度为 2 的幂大小的数组中。有了 threadLocalHashCode 的基础，下面我们通过下面的表格来具体讲解线性探测法是如何实现的。</p>
<p>为了便于理解，我们采用一组简单的数据模拟 ThreadLocal.set() 的过程是如何解决 Hash 冲突的。</p>
<p>threadLocalHashCode = 4，threadLocalHashCode &amp; 15 = 4；此时数据应该放在数组下标为 4 的位置。下标 4 的位置正好没有数据，可以存放。</p>
<p>threadLocalHashCode = 19，threadLocalHashCode &amp; 15 = 4；但是下标 4 的位置已经有数据了，如果当前需要添加的 Entry 与下标 4 位置已存在的 Entry 两者的 key 相同，那么该位置 Entry 的 value 将被覆盖为新的值。我们假设 key 都是不相同的，所以此时需要向后移动一位，下标 5 的位置没有冲突，可以存放。</p>
<p>threadLocalHashCode = 33，threadLocalHashCode &amp; 15 = 3；下标 3 的位置已经有数据，向后移一位，下标 4 位置还是有数据，继续向后查找，发现下标 6 没有数据，可以存放。</p>
<p>ThreadLocal.get() 的过程也是类似的，也是根据 threadLocalHashCode 的值定位到数组下标，然后判断当前位置 Entry 对象与待查询 Entry 对象的 key 是否相同，如果不同，继续向下查找。由此可见，ThreadLocal.set()/get() 方法在数据密集时很容易出现 Hash 冲突，需要 O(n) 时间复杂度解决冲突问题，效率较低。</p>
<p>下面我们再聊聊 ThreadLocalMap 中 Entry 的设计原理。Entry 继承自弱引用类 WeakReference，Entry 的 key 是弱引用，value 是强引用。在 JVM 垃圾回收时，只要发现了弱引用的对象，不管内存是否充足，都会被回收。那么为什么 Entry 的 key 要设计成弱引用呢？我们试想下，如果 key 都是强引用，当 ThreadLocal 不再使用时，然而 ThreadLocalMap 中还是存在对 ThreadLocal 的强引用，那么 GC 是无法回收的，从而造成内存泄漏。</p>
<p>虽然 Entry 的 key 设计成了弱引用，但是当 ThreadLocal 不再使用被 GC 回收后，ThreadLocalMap 中可能出现 Entry 的 key 为 NULL，那么 Entry 的 value 一直会强引用数据而得不到释放，只能等待线程销毁。那么应该如何避免 ThreadLocalMap 内存泄漏呢？ThreadLocal 已经帮助我们做了一定的保护措施，在执行 ThreadLocal.set()/get() 方法时，ThreadLocal 会清除 ThreadLocalMap 中 key 为 NULL 的 Entry 对象，让它还能够被 GC 回收。除此之外，当线程中某个 ThreadLocal 对象不再使用时，立即调用 remove() 方法删除 Entry 对象。如果是在异常的场景中，记得在 finally 代码块中进行清理，保持良好的编码意识。</p>
<p>关于 JDK 的 ThreadLocal 的基本原理我们已经介绍完了，既然 ThreadLocal 已经非常成熟，而且在日常开发中也被广泛使用，Netty 为什么还要自己实现一个 FastThreadLocal 呢？性能真的比 ThreadLocal 高很多吗？我们接下来一起一探究竟。</p>
<p>FastThreadLocal 为什么快</p>
<p>FastThreadLocal 的实现与 ThreadLocal 非常类似，Netty 为 FastThreadLocal 量身打造了 FastThreadLocalThread 和 InternalThreadLocalMap 两个重要的类。下面我们看下这两个类是如何实现的。</p>
<p>FastThreadLocalThread 是对 Thread 类的一层包装，每个线程对应一个 InternalThreadLocalMap 实例。只有 FastThreadLocal 和 FastThreadLocalThread 组合使用时，才能发挥 FastThreadLocal 的性能优势。首先看下 FastThreadLocalThread 的源码定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="k">class</span> <span class="n">FastThreadLocalThread</span> <span class="k">extends</span> <span class="ne">Thread</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">private</span> <span class="n">InternalThreadLocalMap</span> <span class="n">threadLocalMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">省略其他代码</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出 FastThreadLocalThread 主要扩展了 InternalThreadLocalMap 字段，我们可以猜测到 FastThreadLocalThread 主要使用 InternalThreadLocalMap 存储数据，而不再是使用 Thread 中的 ThreadLocalMap。所以想知道 FastThreadLocalThread 高性能的奥秘，必须要了解 InternalThreadLocalMap 的设计原理。</p>
<p>上文中我们讲到了 ThreadLocal 的一个重要缺点，就是 ThreadLocalMap 采用线性探测法解决 Hash 冲突性能较慢，那么 InternalThreadLocalMap 又是如何优化的呢？首先一起看下 InternalThreadLocalMap 的内部构造。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="n">final</span> <span class="k">class</span> <span class="n">InternalThreadLocalMap</span> <span class="k">extends</span> <span class="n">UnpaddedInternalThreadLocalMap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">private</span> <span class="k">static</span> <span class="n">final</span> <span class="ne">int</span> <span class="n">DEFAULT_ARRAY_LIST_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">private</span> <span class="k">static</span> <span class="n">final</span> <span class="ne">int</span> <span class="n">STRING_BUILDER_INITIAL_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">private</span> <span class="k">static</span> <span class="n">final</span> <span class="ne">int</span> <span class="n">STRING_BUILDER_MAX_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="k">static</span> <span class="n">final</span> <span class="ne">Object</span> <span class="n">UNSET</span> <span class="o">=</span> <span class="n">new</span> <span class="ne">Object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">private</span> <span class="n">BitSet</span> <span class="n">cleanerFlags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">private</span> <span class="n">InternalThreadLocalMap</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">super</span><span class="p">(</span><span class="n">newIndexedVariableTable</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">private</span> <span class="k">static</span> <span class="ne">Object</span><span class="p">[]</span> <span class="n">newIndexedVariableTable</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="ne">Object</span><span class="p">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">new</span> <span class="ne">Object</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">Arrays</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">UNSET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="k">static</span> <span class="ne">int</span> <span class="n">nextVariableIndex</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="ne">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">nextIndex</span><span class="o">.</span><span class="n">getAndIncrement</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">nextIndex</span><span class="o">.</span><span class="n">decrementAndGet</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">throw</span> <span class="n">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s2">&#34;too many thread-local indexed variables&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">省略其他代码</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="n">UnpaddedInternalThreadLocalMap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">final</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">InternalThreadLocalMap</span><span class="o">&gt;</span> <span class="n">slowThreadLocalMap</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">InternalThreadLocalMap</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">final</span> <span class="n">AtomicInteger</span> <span class="n">nextIndex</span> <span class="o">=</span> <span class="n">new</span> <span class="n">AtomicInteger</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="ne">Object</span><span class="p">[]</span> <span class="n">indexedVariables</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">UnpaddedInternalThreadLocalMap</span><span class="p">(</span><span class="ne">Object</span><span class="p">[]</span> <span class="n">indexedVariables</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">this</span><span class="o">.</span><span class="n">indexedVariables</span> <span class="o">=</span> <span class="n">indexedVariables</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="err">省略其他代码</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从 InternalThreadLocalMap 内部实现来看，与 ThreadLocalMap 一样都是采用数组的存储方式。但是 InternalThreadLocalMap 并没有使用线性探测法来解决 Hash 冲突，而是在 FastThreadLocal 初始化的时候分配一个数组索引 index，index 的值采用原子类 AtomicInteger 保证顺序递增，通过调用 InternalThreadLocalMap.nextVariableIndex() 方法获得。然后在读写数据的时候通过数组下标 index 直接定位到 FastThreadLocal 的位置，时间复杂度为 O(1)。如果数组下标递增到非常大，那么数组也会比较大，所以 FastThreadLocal 是通过空间换时间的思想提升读写性能。下面通过一幅图描述 InternalThreadLocalMap、index 和 FastThreadLocal 之间的关系。</p>
<p>通过上面 FastThreadLocal 的内部结构图，我们对比下与 ThreadLocal 有哪些区别呢？FastThreadLocal 使用 Object 数组替代了 Entry 数组，Object[0] 存储的是一个Set&lt;FastThreadLocal<?>&gt; 集合，从数组下标 1 开始都是直接存储的 value 数据，不再采用 ThreadLocal 的键值对形式进行存储。</p>
<p>假设现在我们有一批数据需要添加到数组中，分别为 value1、value2、value3、value4，对应的 FastThreadLocal 在初始化的时候生成的数组索引分别为 1、2、3、4。如下图所示。</p>
<p>至此，我们已经对 FastThreadLocal 有了一个基本的认识，下面我们结合具体的源码分析 FastThreadLocal 的实现原理。</p>
<p>FastThreadLocal 源码分析</p>
<p>在讲解源码之前，我们回过头看下上文中的 ThreadLocal 示例，如果把示例中 ThreadLocal 替换成 FastThread，应当如何使用呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class FastThreadLocalTest {
</span></span><span class="line"><span class="cl">    private static final FastThreadLocal&lt;String&gt; THREAD_NAME_LOCAL = new FastThreadLocal&lt;&gt;();
</span></span><span class="line"><span class="cl">    private static final FastThreadLocal&lt;TradeOrder&gt; TRADE_THREAD_LOCAL = new FastThreadLocal&lt;&gt;();
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 2; i++) {
</span></span><span class="line"><span class="cl">            int tradeId = i;
</span></span><span class="line"><span class="cl">            String threadName = &#34;thread-&#34; + i;
</span></span><span class="line"><span class="cl">            new FastThreadLocalThread(() -&gt; {
</span></span><span class="line"><span class="cl">                THREAD_NAME_LOCAL.set(threadName);
</span></span><span class="line"><span class="cl">                TradeOrder tradeOrder = new TradeOrder(tradeId, tradeId % 2 == 0 ? &#34;已支付&#34; : &#34;未支付&#34;);
</span></span><span class="line"><span class="cl">                TRADE_THREAD_LOCAL.set(tradeOrder);
</span></span><span class="line"><span class="cl">                System.out.println(&#34;threadName: &#34; + THREAD_NAME_LOCAL.get());
</span></span><span class="line"><span class="cl">                System.out.println(&#34;tradeOrder info：&#34; + TRADE_THREAD_LOCAL.get());
</span></span><span class="line"><span class="cl">            }, threadName).start();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出，FastThreadLocal 的使用方法几乎和 ThreadLocal 保持一致，只需要把代码中 Thread、ThreadLocal 替换为 FastThreadLocalThread 和 FastThreadLocal 即可，Netty 在易用性方面做得相当棒。下面我们重点对示例中用得到 FastThreadLocal.set()/get() 方法做深入分析。</p>
<p>首先看下 FastThreadLocal.set() 的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final void set(V value) {
</span></span><span class="line"><span class="cl">    if (value != InternalThreadLocalMap.UNSET) { // 1. value 是否为缺省值
</span></span><span class="line"><span class="cl">        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get(); // 2. 获取当前线程的 InternalThreadLocalMap
</span></span><span class="line"><span class="cl">        setKnownNotUnset(threadLocalMap, value); // 3. 将 InternalThreadLocalMap 中数据替换为新的 value
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        remove();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>FastThreadLocal.set() 方法虽然入口只有几行代码，但是内部逻辑是相当复杂的。我们首先还是抓住代码主干，一步步进行拆解分析。set() 的过程主要分为三步：</p>
<p>判断 value 是否为缺省值，如果等于缺省值，那么直接调用 remove() 方法。这里我们还不知道缺省值和 remove() 之间的联系是什么，我们暂且把 remove() 放在最后分析。</p>
<p>如果 value 不等于缺省值，接下来会获取当前线程的 InternalThreadLocalMap。</p>
<p>然后将 InternalThreadLocalMap 中对应数据替换为新的 value。</p>
<p>首先我们看下 InternalThreadLocalMap.get() 方法，源码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static InternalThreadLocalMap get() {
</span></span><span class="line"><span class="cl">    Thread thread = Thread.currentThread();
</span></span><span class="line"><span class="cl">    if (thread instanceof FastThreadLocalThread) { // 当前线程是否为 FastThreadLocalThread 类型
</span></span><span class="line"><span class="cl">        return fastGet((FastThreadLocalThread) thread);
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        return slowGet();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">private static InternalThreadLocalMap fastGet(FastThreadLocalThread thread) {
</span></span><span class="line"><span class="cl">    InternalThreadLocalMap threadLocalMap = thread.threadLocalMap(); // 获取 FastThreadLocalThread 的 threadLocalMap 属性
</span></span><span class="line"><span class="cl">    if (threadLocalMap == null) {
</span></span><span class="line"><span class="cl">        thread.setThreadLocalMap(threadLocalMap = new InternalThreadLocalMap());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return threadLocalMap;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">private static InternalThreadLocalMap slowGet() {
</span></span><span class="line"><span class="cl">    ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap; 
</span></span><span class="line"><span class="cl">    InternalThreadLocalMap ret = slowThreadLocalMap.get(); // 从 JDK 原生 ThreadLocal 中获取 InternalThreadLocalMap
</span></span><span class="line"><span class="cl">    if (ret == null) {
</span></span><span class="line"><span class="cl">        ret = new InternalThreadLocalMap();
</span></span><span class="line"><span class="cl">        slowThreadLocalMap.set(ret);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return ret;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>InternalThreadLocalMap.get() 逻辑很简单，为了帮助你更好地理解，下面使用一幅图描述 InternalThreadLocalMap 的获取方式。</p>
<p>如果当前线程是 FastThreadLocalThread 类型，那么直接通过 fastGet() 方法获取 FastThreadLocalThread 的 threadLocalMap 属性即可。如果此时 InternalThreadLocalMap 不存在，直接创建一个返回。关于 InternalThreadLocalMap 的初始化在上文中已经介绍过，它会初始化一个长度为 32 的 Object 数组，数组中填充着 32 个缺省对象 UNSET 的引用。</p>
<p>那么 slowGet() 又是什么作用呢？从代码分支来看，slowGet() 是针对非 FastThreadLocalThread 类型的线程发起调用时的一种兜底方案。如果当前线程不是 FastThreadLocalThread，内部是没有 InternalThreadLocalMap 属性的，Netty 在 UnpaddedInternalThreadLocalMap 中保存了一个 JDK 原生的 ThreadLocal，ThreadLocal 中存放着 InternalThreadLocalMap，此时获取 InternalThreadLocalMap 就退化成 JDK 原生的 ThreadLocal 获取。</p>
<p>获取 InternalThreadLocalMap 的过程已经讲完了，下面看下 setKnownNotUnset() 如何将数据添加到 InternalThreadLocalMap 的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private void setKnownNotUnset(InternalThreadLocalMap threadLocalMap, V value) {
</span></span><span class="line"><span class="cl">    if (threadLocalMap.setIndexedVariable(index, value)) { // 1. 找到数组下标 index 位置，设置新的 value
</span></span><span class="line"><span class="cl">        addToVariablesToRemove(threadLocalMap, this); // 2. 将 FastThreadLocal 对象保存到待清理的 Set 中
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>setKnownNotUnset() 主要做了两件事：</p>
<p>找到数组下标 index 位置，设置新的 value。</p>
<p>将 FastThreadLocal 对象保存到待清理的 Set 中。</p>
<p>首先我们看下第一步 threadLocalMap.setIndexedVariable() 的源码实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public boolean setIndexedVariable(int index, Object value) {
</span></span><span class="line"><span class="cl">    Object[] lookup = indexedVariables;
</span></span><span class="line"><span class="cl">    if (index &lt; lookup.length) {
</span></span><span class="line"><span class="cl">        Object oldValue = lookup[index]; 
</span></span><span class="line"><span class="cl">        lookup[index] = value; // 直接将数组 index 位置设置为 value，时间复杂度为 O(1)
</span></span><span class="line"><span class="cl">        return oldValue == UNSET;
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        expandIndexedVariableTableAndSet(index, value); // 容量不够，先扩容再设置值
</span></span><span class="line"><span class="cl">        return true;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>indexedVariables 就是 InternalThreadLocalMap 中用于存放数据的数组，如果数组容量大于 FastThreadLocal 的 index 索引，那么直接找到数组下标 index 位置将新 value 设置进去，事件复杂度为 O(1)。在设置新的 value 之前，会将之前 index 位置的元素取出，如果旧的元素还是 UNSET 缺省对象，那么返回成功。</p>
<p>如果数组容量不够了怎么办呢？InternalThreadLocalMap 会自动扩容，然后再设置 value。接下来看看 expandIndexedVariableTableAndSet() 的扩容逻辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private void expandIndexedVariableTableAndSet(int index, Object value) {
</span></span><span class="line"><span class="cl">    Object[] oldArray = indexedVariables;
</span></span><span class="line"><span class="cl">    final int oldCapacity = oldArray.length;
</span></span><span class="line"><span class="cl">    int newCapacity = index;
</span></span><span class="line"><span class="cl">    newCapacity |= newCapacity &gt;&gt;&gt;  1;
</span></span><span class="line"><span class="cl">    newCapacity |= newCapacity &gt;&gt;&gt;  2;
</span></span><span class="line"><span class="cl">    newCapacity |= newCapacity &gt;&gt;&gt;  4;
</span></span><span class="line"><span class="cl">    newCapacity |= newCapacity &gt;&gt;&gt;  8;
</span></span><span class="line"><span class="cl">    newCapacity |= newCapacity &gt;&gt;&gt; 16;
</span></span><span class="line"><span class="cl">    newCapacity ++;
</span></span><span class="line"><span class="cl">    Object[] newArray = Arrays.copyOf(oldArray, newCapacity);
</span></span><span class="line"><span class="cl">    Arrays.fill(newArray, oldCapacity, newArray.length, UNSET);
</span></span><span class="line"><span class="cl">    newArray[index] = value;
</span></span><span class="line"><span class="cl">    indexedVariables = newArray;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码的位移操作是不是似曾相识？我们去翻阅下 JDK HashMap 中扩容的源码，其中有这么一段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">static final int tableSizeFor(int cap) {
</span></span><span class="line"><span class="cl">    int n = cap - 1;
</span></span><span class="line"><span class="cl">    n |= n &gt;&gt;&gt; 1;
</span></span><span class="line"><span class="cl">    n |= n &gt;&gt;&gt; 2;
</span></span><span class="line"><span class="cl">    n |= n &gt;&gt;&gt; 4;
</span></span><span class="line"><span class="cl">    n |= n &gt;&gt;&gt; 8;
</span></span><span class="line"><span class="cl">    n |= n &gt;&gt;&gt; 16;
</span></span><span class="line"><span class="cl">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出 InternalThreadLocalMap 实现数组扩容几乎和 HashMap 完全是一模一样的，所以多读源码还是可以给我们很多启发的。InternalThreadLocalMap 以 index 为基准进行扩容，将数组扩容后的容量向上取整为 2 的次幂。然后将原数组内容拷贝到新的数组中，空余部分填充缺省对象 UNSET，最终把新数组赋值给 indexedVariables。</p>
<p>为什么 InternalThreadLocalMap 以 index 为基准进行扩容，而不是原数组长度呢？假设现在初始化了 70 个 FastThreadLocal，但是这些 FastThreadLocal 从来没有调用过 set() 方法，此时数组还是默认长度 32。当第 index = 70 的 FastThreadLocal 调用 set() 方法时，如果按原数组容量 32 进行扩容 2 倍后，还是无法填充 index = 70 的数据。所以使用 index 为基准进行扩容可以解决这个问题，但是如果 FastThreadLocal 特别多，数组的长度也是非常大的。</p>
<p>回到 setKnownNotUnset() 的主流程，向 InternalThreadLocalMap 添加完数据之后，接下就是将 FastThreadLocal 对象保存到待清理的 Set 中。我们继续看下 addToVariablesToRemove() 是如何实现的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">private</span> <span class="k">static</span> <span class="n">void</span> <span class="n">addToVariablesToRemove</span><span class="p">(</span><span class="n">InternalThreadLocalMap</span> <span class="n">threadLocalMap</span><span class="p">,</span> <span class="n">FastThreadLocal</span><span class="o">&lt;</span><span class="err">?</span><span class="o">&gt;</span> <span class="n">variable</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="ne">Object</span> <span class="n">v</span> <span class="o">=</span> <span class="n">threadLocalMap</span><span class="o">.</span><span class="n">indexedVariable</span><span class="p">(</span><span class="n">variablesToRemoveIndex</span><span class="p">);</span> <span class="o">//</span> <span class="err">获取数组下标为</span> <span class="mi">0</span> <span class="err">的元素</span>
</span></span><span class="line"><span class="cl">    <span class="n">Set</span><span class="o">&lt;</span><span class="n">FastThreadLocal</span><span class="o">&lt;</span><span class="err">?</span><span class="o">&gt;&gt;</span> <span class="n">variablesToRemove</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">InternalThreadLocalMap</span><span class="o">.</span><span class="n">UNSET</span> <span class="o">||</span> <span class="n">v</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">variablesToRemove</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="n">newSetFromMap</span><span class="p">(</span><span class="n">new</span> <span class="n">IdentityHashMap</span><span class="o">&lt;</span><span class="n">FastThreadLocal</span><span class="o">&lt;</span><span class="err">?</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Boolean</span><span class="o">&gt;</span><span class="p">());</span> <span class="o">//</span> <span class="err">创建</span> <span class="n">FastThreadLocal</span> <span class="err">类型的</span> <span class="n">Set</span> <span class="err">集合</span>
</span></span><span class="line"><span class="cl">        <span class="n">threadLocalMap</span><span class="o">.</span><span class="n">setIndexedVariable</span><span class="p">(</span><span class="n">variablesToRemoveIndex</span><span class="p">,</span> <span class="n">variablesToRemove</span><span class="p">);</span> <span class="o">//</span> <span class="err">将</span> <span class="n">Set</span> <span class="err">集合填充到数组下标</span> <span class="mi">0</span> <span class="err">的位置</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">variablesToRemove</span> <span class="o">=</span> <span class="p">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">FastThreadLocal</span><span class="o">&lt;</span><span class="err">?</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="n">v</span><span class="p">;</span> <span class="o">//</span> <span class="err">如果不是</span> <span class="n">UNSET</span><span class="err">，</span><span class="n">Set</span> <span class="err">集合已存在，直接强转获得</span> <span class="n">Set</span> <span class="err">集合</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">variablesToRemove</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">variable</span><span class="p">);</span> <span class="o">//</span> <span class="err">将</span> <span class="n">FastThreadLocal</span> <span class="err">添加到</span> <span class="n">Set</span> <span class="err">集合中</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>variablesToRemoveIndex 是采用 static final 修饰的变量，在 FastThreadLocal 初始化时 variablesToRemoveIndex 被赋值为 0。InternalThreadLocalMap 首先会找到数组下标为 0 的元素，如果该元素是缺省对象 UNSET 或者不存在，那么会创建一个 FastThreadLocal 类型的 Set 集合，然后把 Set 集合填充到数组下标 0 的位置。如果数组第一个元素不是缺省对象 UNSET，说明 Set 集合已经被填充，直接强转获得 Set 集合即可。这就解释了 InternalThreadLocalMap 的 value 数据为什么是从下标为 1 的位置开始存储了，因为 0 的位置已经被 Set 集合占用了。</p>
<p>为什么 InternalThreadLocalMap 要在数组下标为 0 的位置存放一个 FastThreadLocal 类型的 Set 集合呢？这时候我们回过头看下 remove() 方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final void remove() {
</span></span><span class="line"><span class="cl">    remove(InternalThreadLocalMap.getIfSet());
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">public static InternalThreadLocalMap getIfSet() {
</span></span><span class="line"><span class="cl">    Thread thread = Thread.currentThread();
</span></span><span class="line"><span class="cl">    if (thread instanceof FastThreadLocalThread) {
</span></span><span class="line"><span class="cl">        return ((FastThreadLocalThread) thread).threadLocalMap();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return slowThreadLocalMap.get();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">public final void remove(InternalThreadLocalMap threadLocalMap) {
</span></span><span class="line"><span class="cl">    if (threadLocalMap == null) {
</span></span><span class="line"><span class="cl">        return;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    Object v = threadLocalMap.removeIndexedVariable(index); // 删除数组下标 index 位置对应的 value
</span></span><span class="line"><span class="cl">    removeFromVariablesToRemove(threadLocalMap, this); // 从数组下标 0 的位置取出 Set 集合，并删除当前 FastThreadLocal
</span></span><span class="line"><span class="cl">    if (v != InternalThreadLocalMap.UNSET) {
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            onRemoval((V) v); // 空方法，用户可以继承实现
</span></span><span class="line"><span class="cl">        } catch (Exception e) {
</span></span><span class="line"><span class="cl">            PlatformDependent.throwException(e);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在执行 remove 操作之前，会调用 InternalThreadLocalMap.getIfSet() 获取当前 InternalThreadLocalMap。有了之前的基础，理解 getIfSet() 方法就非常简单了，如果是 FastThreadLocalThread 类型，直接取 FastThreadLocalThread 中 threadLocalMap 属性。如果是普通线程 Thread，从 ThreadLocal 类型的 slowThreadLocalMap 中获取。</p>
<p>找到 InternalThreadLocalMap 之后，InternalThreadLocalMap 会从数组中定位到下标 index 位置的元素，并将 index 位置的元素覆盖为缺省对象 UNSET。接下来就需要清理当前的 FastThreadLocal 对象，此时 Set 集合就派上了用场，InternalThreadLocalMap 会取出数组下标 0 位置的 Set 集合，然后删除当前 FastThreadLocal。最后 onRemoval() 方法起到什么作用呢？Netty 只是留了一处扩展，并没有实现，用户需要在删除的时候做一些后置操作，可以继承 FastThreadLocal 实现该方法。</p>
<p>至此，FastThreadLocal.set() 的完成过程已经讲完了，接下来我们继续 FastThreadLocal.get() 方法的实现就易如反掌拉。FastThreadLocal.get() 的源码实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final V get() {
</span></span><span class="line"><span class="cl">    InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();
</span></span><span class="line"><span class="cl">    Object v = threadLocalMap.indexedVariable(index); // 从数组中取出 index 位置的元素
</span></span><span class="line"><span class="cl">    if (v != InternalThreadLocalMap.UNSET) {
</span></span><span class="line"><span class="cl">        return (V) v;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return initialize(threadLocalMap); // 如果获取到的数组元素是缺省对象，执行初始化操作
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">public Object indexedVariable(int index) {
</span></span><span class="line"><span class="cl">    Object[] lookup = indexedVariables;
</span></span><span class="line"><span class="cl">    return index &lt; lookup.length? lookup[index] : UNSET;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">private V initialize(InternalThreadLocalMap threadLocalMap) {
</span></span><span class="line"><span class="cl">    V v = null;
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        v = initialValue();
</span></span><span class="line"><span class="cl">    } catch (Exception e) {
</span></span><span class="line"><span class="cl">        PlatformDependent.throwException(e);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    threadLocalMap.setIndexedVariable(index, v);
</span></span><span class="line"><span class="cl">    addToVariablesToRemove(threadLocalMap, this);
</span></span><span class="line"><span class="cl">    return v;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先根据当前线程是否是 FastThreadLocalThread 类型找到 InternalThreadLocalMap，然后取出从数组下标 index 的元素，如果 index 位置的元素不是缺省对象 UNSET，说明该位置已经填充过数据，直接取出返回即可。如果 index 位置的元素是缺省对象 UNSET，那么需要执行初始化操作。可以看到，initialize() 方法会调用用户重写的 initialValue 方法构造需要存储的对象数据，如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private final FastThreadLocal&lt;String&gt; threadLocal = new FastThreadLocal&lt;String&gt;() {
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected String initialValue() {
</span></span><span class="line"><span class="cl">        return &#34;hello world&#34;;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>构造完用户对象数据之后，接下来就会将它填充到数组 index 的位置，然后再把当前 FastThreadLocal 对象保存到待清理的 Set 中。整个过程我们在分析 FastThreadLocal.set() 时都已经介绍过，就不再赘述了。</p>
<p>到此为止，FastThreadLocal 最核心的两个方法 set()/get() 我们已经分析完了。下面有两个问题我们再深入思考下。</p>
<p>FastThreadLocal 真的一定比 ThreadLocal 快吗？答案是不一定的，只有使用FastThreadLocalThread 类型的线程才会更快，如果是普通线程反而会更慢。</p>
<p>FastThreadLocal 会浪费很大的空间吗？虽然 FastThreadLocal 采用的空间换时间的思路，但是在 FastThreadLocal 设计之初就认为不会存在特别多的 FastThreadLocal 对象，而且在数据中没有使用的元素只是存放了同一个缺省对象的引用，并不会占用太多内存空间。</p>
<p>总结</p>
<p>本节课我们对比介绍了 ThreadLocal 和 FastThreadLocal，简单总结下 FastThreadLocal 的优势。</p>
<p>高效查找。FastThreadLocal 在定位数据的时候可以直接根据数组下标 index 获取，时间复杂度 O(1)。而 JDK 原生的 ThreadLocal 在数据较多时哈希表很容易发生 Hash 冲突，线性探测法在解决 Hash 冲突时需要不停地向下寻找，效率较低。此外，FastThreadLocal 相比 ThreadLocal 数据扩容更加简单高效，FastThreadLocal 以 index 为基准向上取整到 2 的次幂作为扩容后容量，然后把原数据拷贝到新数组。而 ThreadLocal 由于采用的哈希表，所以在扩容后需要再做一轮 rehash。</p>
<p>安全性更高。JDK 原生的 ThreadLocal 使用不当可能造成内存泄漏，只能等待线程销毁。在使用线程池的场景下，ThreadLocal 只能通过主动检测的方式防止内存泄漏，从而造成了一定的开销。然而 FastThreadLocal 不仅提供了 remove() 主动清除对象的方法，而且在线程池场景中 Netty 还封装了 FastThreadLocalRunnable，FastThreadLocalRunnable 最后会执行 FastThreadLocal.removeAll() 将 Set 集合中所有 FastThreadLocal 对象都清理掉，</p>
<p>FastThreadLocal 体现了 Netty 在高性能方面精益求精的设计精神，FastThreadLocal 仅仅是其中的冰山一角，下节课我们继续探索 Netty 中其他高效的数据结构技巧。</p>
<p>-&ndash; ### 精选评论 ##### **红： &gt; InternalThreadLocalMap 中初始化数组中第0个元素的set作用是? ######     讲师回复： &gt;     Set 集合是为了保存 FastThreadLocal对象，我认为 Set 集合设计的好处有几点：1. 删除 FastThreadLocal 留扩展接口。2. 提高 removeAll 的删除效率，不需要去遍历膨胀的数组。3. 可以更好地做内存泄露的管理。 ##### *迪： &gt; 有点不明白，既然threadLocalMap中的entry是个弱引用对象，为啥key都失去引用了gc还不回收，还能存在你说的null key，value有值的情况,如果是这样的话那弱引用的意义在哪？ ######     讲师回复： &gt;     如果 key 都是强引用，当 ThreadLocal 不再使用时，然而 ThreadLocalMap 中还是存在对 ThreadLocal 的强引用，那么 GC 是无法回收的，从而造成内存泄漏。弱引用可以避免长期存活的线程（例如线程池）导致 ThreadLocal 无法回收造成的内存泄漏。 ##### **杰： &gt; 666</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/">Netty核心原理剖析与RPC实践</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/20%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E4%B8%80%E6%AC%A1%E6%80%A7%E8%AF%B4%E6%B8%85%E6%A5%9Apaxoraft%E7%AD%89%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">20共识算法：一次性说清楚Paxo、Raft等算法的区别</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/20%E8%83%BD%E5%8A%9B%E8%BF%9B%E9%98%B6apm%E5%B7%A5%E5%85%B7%E8%87%AA%E7%87%83%E9%9A%8F%E6%97%B6%E5%AE%A2%E4%B8%B2apm%E5%B7%A5%E7%A8%8B%E5%B8%88/">
            <span class="next-text nav-default">20能力进阶：APM工具自燃？随时客串APM工程师</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
