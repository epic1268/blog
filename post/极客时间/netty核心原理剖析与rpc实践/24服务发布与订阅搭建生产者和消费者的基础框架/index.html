<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>24服务发布与订阅：搭建生产者和消费者的基础框架 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="从本节课开始，我们开始动手开发一个完整的 RPC 框架原型，通过整个实践课程的学习，你不仅可以熟悉 RPC 的实现原理，而且可以对之前 Netty 基础知识加深理解，同样在工作中也可以学以致用。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/24%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/24%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="24服务发布与订阅：搭建生产者和消费者的基础框架">
  <meta property="og:description" content="从本节课开始，我们开始动手开发一个完整的 RPC 框架原型，通过整个实践课程的学习，你不仅可以熟悉 RPC 的实现原理，而且可以对之前 Netty 基础知识加深理解，同样在工作中也可以学以致用。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Netty核心原理剖析与RPC实践">

  <meta itemprop="name" content="24服务发布与订阅：搭建生产者和消费者的基础框架">
  <meta itemprop="description" content="从本节课开始，我们开始动手开发一个完整的 RPC 框架原型，通过整个实践课程的学习，你不仅可以熟悉 RPC 的实现原理，而且可以对之前 Netty 基础知识加深理解，同样在工作中也可以学以致用。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5684">
  <meta itemprop="keywords" content="Netty核心原理剖析与RPC实践">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="24服务发布与订阅：搭建生产者和消费者的基础框架">
  <meta name="twitter:description" content="从本节课开始，我们开始动手开发一个完整的 RPC 框架原型，通过整个实践课程的学习，你不仅可以熟悉 RPC 的实现原理，而且可以对之前 Netty 基础知识加深理解，同样在工作中也可以学以致用。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">24服务发布与订阅：搭建生产者和消费者的基础框架</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5684 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>从本节课开始，我们开始动手开发一个完整的 RPC 框架原型，通过整个实践课程的学习，你不仅可以熟悉 RPC 的实现原理，而且可以对之前 Netty 基础知识加深理解，同样在工作中也可以学以致用。</p>
<p>我会从服务发布与订阅、远程通信、服务治理、动态代理四个方面详细地介绍一个通用 RPC 框架的实现过程，相信你只要坚持完成本次实践课，之后你再独立完成工作中项目研发会变得更加容易。你是不是已经迫不及待地想动手了呢？让我们一起开始吧！</p>
<p>源码参考地址：mini-rpc</p>
<p>环境搭建</p>
<p>工欲善其事必先利其器，首先我们需要搭建我们的开发环境，这是每个程序员的必备技能。以下是我的本机环境清单，仅供参考。</p>
<p>操作系统：MacOS Big Sur，11.0.1。</p>
<p>集成开发工具：IntelliJ IDEA 2020.3，当然你也可以选择 eclipse。</p>
<p>项目技术栈：SpringBoot 2.1.12.RELEASE + JDK 1.8.0_221 + Netty 4.1.42.Final。</p>
<p>项目依赖管理工具：Maven 3.5.4，你可以独立安装 Maven 或者使用 IDEA 的集成版，独立安装的 Maven 需要配置 MAVEN_HOME 和 PATH 环境变量。</p>
<p>注册中心：Zookeeeper 3.4.14，需要特别注意 Zookeeeper 和 Apache Curator 一定要搭配使用，Zookeeper 3.4.x 版本，Apache Curator 只有 2.x.x 才能支持。</p>
<p>项目结构</p>
<p>在动手开发项目之前，我们需要对项目结构有清晰的构思。根据上节课介绍的 RPC 框架设计架构，我们可以将项目结构划分为以下几个模块。</p>
<p>其中每个模块都是什么角色呢？下面我们一一进行介绍。</p>
<p>rpc-provider，服务提供者。负责发布 RPC 服务，接收和处理 RPC 请求。</p>
<p>rpc-consumer，服务消费者。使用动态代理发起 RPC 远程调用，帮助使用者来屏蔽底层网络通信的细节。</p>
<p>rpc-registry，注册中心模块。提供服务注册、服务发现、负载均衡的基本功能。</p>
<p>rpc-protocol，网络通信模块。包含 RPC 协议的编解码器、序列化和反序列化工具等。</p>
<p>rpc-core，基础类库。提供通用的工具类以及模型定义，例如 RPC 请求和响应类、RPC 服务元数据类等。</p>
<p>rpc-facade，RPC 服务接口。包含服务提供者需要对外暴露的接口，本模块主要用于模拟真实 RPC 调用的测试。</p>
<p>如下图所示，首先我们需要清楚各个模块之间的依赖关系，才能帮助我们更好地梳理 Maven 的 pom 定义。rpc-core 是最基础的类库，所以大部分模块都依赖它。rpc-consumer 用于发起 RPC 调用。rpc-provider 负责处理 RPC 请求，如果不知道远程服务的地址，那么一切都是空谈了，所以两者都需要依赖 rpc-registry 提供的服务发现和服务注册的能力。</p>
<p>如何使用</p>
<p>我们不着急开始动手实现代码细节，而是考虑一个问题，最终实现的 RPC 框架应该让用户如何使用呢？这就跟我们学习一门技术一样，你不可能刚开始就直接陷入源码的细节，而是先熟悉它的基本使用方式，然后找到关键的切入点再深入研究实现原理，会起到事半功倍的效果。</p>
<p>首先我们看下 RPC 框架想要实现的效果，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// rpc-facade # HelloFacade
</span></span><span class="line"><span class="cl">public interface HelloFacade {
</span></span><span class="line"><span class="cl">    String hello(String name);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// rpc-provider # HelloFacadeImpl
</span></span><span class="line"><span class="cl">@RpcService(serviceInterface = HelloFacade.class, serviceVersion = &#34;1.0.0&#34;)
</span></span><span class="line"><span class="cl">public class HelloFacadeImpl implements HelloFacade {
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public String hello(String name) {
</span></span><span class="line"><span class="cl">        return &#34;hello&#34; + name;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// rpc-consumer # HelloController
</span></span><span class="line"><span class="cl">@RestController
</span></span><span class="line"><span class="cl">public class HelloController {
</span></span><span class="line"><span class="cl">    @RpcReference(serviceVersion = &#34;1.0.0&#34;, timeout = 3000)
</span></span><span class="line"><span class="cl">    private HelloFacade helloFacade;
</span></span><span class="line"><span class="cl">    @RequestMapping(value = &#34;/hello&#34;, method = RequestMethod.GET)
</span></span><span class="line"><span class="cl">    public String sayHello() {
</span></span><span class="line"><span class="cl">        return helloFacade.hello(&#34;mini rpc&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了方便在本地模拟客户端和服务端，我会把 rpc-provider 和 rpc-consumer 两个模块能够做到独立启动。rpc-provider 通过 @RpcService 注解暴露 RPC 服务 HelloFacade，rpc-consumer 通过 @RpcReference 注解引用 HelloFacade 服务并发起调用，基本与我们常用的 RPC 框架使用方式保持一致。</p>
<p>梳理清楚项目结构和整体实现思路之后，下面我们从服务提供者开始入手开发。</p>
<p>服务提供者发布服务</p>
<p>服务提供者 rpc-provider 需要完成哪些事情呢？主要分为四个核心流程：</p>
<p>服务提供者启动服务，并暴露服务端口；</p>
<p>启动时扫描需要对外发布的服务，并将服务元数据信息发布到注册中心；</p>
<p>接收 RPC 请求，解码后得到请求消息；</p>
<p>提交请求至自定义线程池进行处理，并将处理结果写回客户端。</p>
<p>本节课我们先实现 rpc-provider 模块前面两个流程。</p>
<p>服务提供者启动</p>
<p>服务提供者启动的配置方式基本是固定模式，也是从引导器 Bootstrap 开始入手，你可以复习下基础课程《03 引导器作用：客户端和服务端启动都要做些什么？》。我们首先看下服务提供者的启动实现，代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private void startRpcServer() throws Exception {
</span></span><span class="line"><span class="cl">    this.serverAddress = InetAddress.getLocalHost().getHostAddress();
</span></span><span class="line"><span class="cl">    EventLoopGroup boss = new NioEventLoopGroup();
</span></span><span class="line"><span class="cl">    EventLoopGroup worker = new NioEventLoopGroup();
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        ServerBootstrap bootstrap = new ServerBootstrap();
</span></span><span class="line"><span class="cl">        bootstrap.group(boss, worker)
</span></span><span class="line"><span class="cl">                .channel(NioServerSocketChannel.class)
</span></span><span class="line"><span class="cl">                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
</span></span><span class="line"><span class="cl">                    @Override
</span></span><span class="line"><span class="cl">                    protected void initChannel(SocketChannel socketChannel) throws Exception {
</span></span><span class="line"><span class="cl">                    }
</span></span><span class="line"><span class="cl">                })
</span></span><span class="line"><span class="cl">                .childOption(ChannelOption.SO_KEEPALIVE, true);
</span></span><span class="line"><span class="cl">        ChannelFuture channelFuture = bootstrap.bind(this.serverAddress, this.serverPort).sync();
</span></span><span class="line"><span class="cl">        log.info(&#34;server addr {} started on port {}&#34;, this.serverAddress, this.serverPort);
</span></span><span class="line"><span class="cl">        channelFuture.channel().closeFuture().sync();
</span></span><span class="line"><span class="cl">    } finally {
</span></span><span class="line"><span class="cl">        boss.shutdownGracefully();
</span></span><span class="line"><span class="cl">        worker.shutdownGracefully();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>服务提供者采用的是主从 Reactor 线程模型，启动过程包括配置线程池、Channel 初始化、端口绑定三个步骤，我们暂时先不关注 Channel 初始化中自定义的业务处理器 Handler 是如何设计和实现的。</p>
<p>对于 RPC 框架而言，可扩展性是比较重要的一方面。接下来我们看下如何借助 Spring Boot 的能力将服务提供者启动所依赖的参数做成可配置化。</p>
<p>参数配置</p>
<p>服务提供者启动需要配置一些参数，我们不应该把这些参数固定在代码里，而是以命令行参数或者配置文件的方式进行输入。我们可以使用 Spring Boot 的 @ConfigurationProperties 注解很轻松地实现配置项的加载，并且可以把相同前缀类型的配置项自动封装成实体类。接下来我们为服务提供者提供参数映射的对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@Data
</span></span><span class="line"><span class="cl">@ConfigurationProperties(prefix = &#34;rpc&#34;)
</span></span><span class="line"><span class="cl">public class RpcProperties {
</span></span><span class="line"><span class="cl">    private int servicePort;
</span></span><span class="line"><span class="cl">    private String registryAddr;
</span></span><span class="line"><span class="cl">    private String registryType;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们一共提取了三个参数，分别为服务暴露的端口 servicePort、注册中心的地址 registryAddr 和注册中心的类型 registryType。@ConfigurationProperties 注解最经典的使用方式就是通过 prefix 属性指定配置参数的前缀，默认会与全局配置文件 application.properties 或者 application.yml 中的参数进行一一绑定。如果你想自定义一个配置文件，可以通过 @PropertySource 注解指定配置文件的位置。下面我们在 rpc-provider 模块的 resources 目录下创建全局配置文件 application.properties，并配置以上三个参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">rpc.servicePort=2781
</span></span><span class="line"><span class="cl">rpc.registryType=ZOOKEEPER
</span></span><span class="line"><span class="cl">rpc.registryAddr=127.0.0.1:2181
</span></span></code></pre></td></tr></table>
</div>
</div><p>application.properties 配置文件中的属性必须和实体类的成员变量是一一对应的，可以采用以下常用的命名规则，例如驼峰命名 rpc.servicePort=2781；或者虚线 - 分割的方式 rpc.service-port=2781；以及大写加下划线的形式 RPC_Service_Port，建议在环境变量中使用。@ConfigurationProperties 注解还可以支持更多复杂结构的配置，并且可以 Validation 功能进行参数校验，如果你有兴趣可以课后再进行深入研究。</p>
<p>有了 RpcProperties 实体类，我们接下来应该如何使用呢？如果只配置 @ConfigurationProperties 注解，Spring 容器并不能获取配置文件的内容并映射为对象，这时 @EnableConfigurationProperties 注解就登场了。@EnableConfigurationProperties 注解的作用就是将声明 @ConfigurationProperties 注解的类注入为 Spring 容器中的 Bean。具体用法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@Configuration
</span></span><span class="line"><span class="cl">@EnableConfigurationProperties(RpcProperties.class)
</span></span><span class="line"><span class="cl">public class RpcProviderAutoConfiguration {
</span></span><span class="line"><span class="cl">    @Resource
</span></span><span class="line"><span class="cl">    private RpcProperties rpcProperties;
</span></span><span class="line"><span class="cl">    @Bean
</span></span><span class="line"><span class="cl">    public RpcProvider init() throws Exception {
</span></span><span class="line"><span class="cl">        RegistryType type = RegistryType.valueOf(rpcProperties.getRegistryType());
</span></span><span class="line"><span class="cl">        RegistryService serviceRegistry = RegistryFactory.getInstance(rpcProperties.getRegistryAddr(), type);
</span></span><span class="line"><span class="cl">        return new RpcProvider(rpcProperties.getServicePort(), serviceRegistry);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们通过 @EnableConfigurationProperties 注解使得 RpcProperties 生效，并通过 @Configuration 和 @Bean 注解自定义了 RpcProvider 的生成方式。@Configuration 主要用于定义配置类，配置类内部可以包含多个 @Bean 注解的方法，可以替换传统 XML 的定义方式。被 @Bean 注解的方法会返回一个自定义的对象，@Bean 注解会将这个对象注册为 Bean 并装配到 Spring 容器中，@Bean 比 @Component 注解的自定义功能更强。</p>
<p>至此，我们服务提供者启动的准备工作就完成了，下面你需要添加 Spring Boot 的 main 方法，如下所示，然后尝试启动下 rpc-provider 模块吧。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@EnableConfigurationProperties
</span></span><span class="line"><span class="cl">@SpringBootApplication
</span></span><span class="line"><span class="cl">public class RpcProviderApplication {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        SpringApplication.run(RpcProviderApplication.class, args);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>发布服务</p>
<p>在服务提供者启动时，我们需要思考一个核心问题，服务提供者需要将服务发布到注册中心，怎么知道哪些服务需要发布呢？服务提供者需要定义需要发布服务类型、服务版本等属性，主流的 RPC 框架都采用 XML 文件或者注解的方式进行定义。以注解的方式暴露服务现在最为常用，省去了很多烦琐的 XML 配置过程。例如 Dubbo 框架中使用 @Service 注解替代 dubbo:service 的定义方式，服务消费者则使用 @Reference 注解替代 dubbo:reference。接下来我们看看作为服务提供者，如何通过注解暴露服务，首先给出我们自定义的 @RpcService 注解定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@Retention(RetentionPolicy.RUNTIME)
</span></span><span class="line"><span class="cl">@Target(ElementType.TYPE)
</span></span><span class="line"><span class="cl">@Component
</span></span><span class="line"><span class="cl">public @interface RpcService {
</span></span><span class="line"><span class="cl">    Class&lt;?&gt; serviceInterface() default Object.class;
</span></span><span class="line"><span class="cl">    String serviceVersion() default &#34;1.0&#34;;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>@RpcService 提供了两个必不可少的属性：服务类型 serviceInterface 和服务版本 serviceVersion，服务消费者必须指定完全一样的属性才能正确调用。有了 @RpcService 注解之后，我们就可以在服务实现类上使用它，@RpcService 注解本质上就是 @Component，可以将服务实现类注册成 Spring 容器所管理的 Bean，那么 serviceInterface、serviceVersion 的属性值怎么才能和 Bean 关联起来呢？这就需要我们就 Bean 的生命周期以及 Bean 的可扩展点有所了解。</p>
<p>Spring 的 BeanPostProcessor 接口给提供了对 Bean 进行再加工的扩展点，BeanPostProcessor 常用于处理自定义注解。自定义的 Bean 可以通过实现 BeanPostProcessor 接口，在 Bean 实例化的前后加入自定义的逻辑处理。如下所示，我们通过 RpcProvider 实现 BeanPostProcessor 接口，来实现对 声明 @RpcService 注解服务的自定义处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class RpcProvider implements InitializingBean, BeanPostProcessor {
</span></span><span class="line"><span class="cl">    // 省略其他代码
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    private final Map&lt;String, Object&gt; rpcServiceMap = new HashMap&lt;&gt;();
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
</span></span><span class="line"><span class="cl">        RpcService rpcService = bean.getClass().getAnnotation(RpcService.class);
</span></span><span class="line"><span class="cl">        if (rpcService != null) {
</span></span><span class="line"><span class="cl">            String serviceName = rpcService.serviceInterface().getName();
</span></span><span class="line"><span class="cl">            String serviceVersion = rpcService.serviceVersion();
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                ServiceMeta serviceMeta = new ServiceMeta();
</span></span><span class="line"><span class="cl">                serviceMeta.setServiceAddr(serverAddress);
</span></span><span class="line"><span class="cl">                serviceMeta.setServicePort(serverPort);
</span></span><span class="line"><span class="cl">                serviceMeta.setServiceName(serviceName);
</span></span><span class="line"><span class="cl">                serviceMeta.setServiceVersion(serviceVersion);
</span></span><span class="line"><span class="cl">                // TODO 发布服务元数据至注册中心
</span></span><span class="line"><span class="cl">                rpcServiceMap.put(RpcServiceHelper.buildServiceKey(serviceMeta.getServiceName(), serviceMeta.getServiceVersion()), bean);
</span></span><span class="line"><span class="cl">            } catch (Exception e) {
</span></span><span class="line"><span class="cl">                log.error(&#34;failed to register service {}#{}&#34;, serviceName, serviceVersion, e);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return bean;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>RpcProvider 重写了 BeanPostProcessor 接口的 postProcessAfterInitialization 方法，对所有初始化完成后的 Bean 进行扫描。如果 Bean 包含 @RpcService 注解，那么通过注解读取服务的元数据信息并构造出 ServiceMeta 对象，接下来准备将服务的元数据信息发布至注册中心，注册中心的实现我们先暂且跳过，后面会有单独一节课进行讲解注册中心的实现。此外，RpcProvider 还维护了一个 rpcServiceMap，存放服务初始化后所对应的 Bean，rpcServiceMap 起到了缓存的角色，在处理 RPC 请求时可以直接通过 rpcServiceMap 拿到对应的服务进行调用。</p>
<p>明白服务提供者如何处理 @RpcService 注解的原理之后，接下来再实现服务消费者就容易很多了。</p>
<p>服务消费者订阅服务</p>
<p>与服务提供者不同的是，服务消费者并不是一个常驻的服务，每次发起 RPC 调用时它才会去选择向哪个远端服务发送数据。所以服务消费者的实现要复杂一些，对于声明 @RpcReference 注解的成员变量，我们需要构造出一个可以真正进行 RPC 调用的 Bean，然后将它注册到 Spring 的容器中。</p>
<p>首先我们看下 @RpcReference 注解的定义，代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@Retention(RetentionPolicy.RUNTIME)
</span></span><span class="line"><span class="cl">@Target(ElementType.FIELD)
</span></span><span class="line"><span class="cl">@Autowired
</span></span><span class="line"><span class="cl">public @interface RpcReference {
</span></span><span class="line"><span class="cl">    String serviceVersion() default &#34;1.0&#34;;
</span></span><span class="line"><span class="cl">    String registryType() default &#34;ZOOKEEPER&#34;;
</span></span><span class="line"><span class="cl">    String registryAddress() default &#34;127.0.0.1:2181&#34;;
</span></span><span class="line"><span class="cl">    long timeout() default 5000;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>@RpcReference 注解提供了服务版本 serviceVersion、注册中心类型 registryType、注册中心地址 registryAddress 和超时时间 timeout 四个属性，接下来我们需要使用这些属性构造出一个自定义的 Bean，并对该 Bean 执行的所有方法进行拦截。</p>
<p>Spring 的 FactoryBean 接口可以帮助我们实现自定义的 Bean，FactoryBean 是一种特种的工厂 Bean，通过 getObject() 方法返回对象，而并不是 FactoryBean 本身。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class RpcReferenceBean implements FactoryBean&lt;Object&gt; {
</span></span><span class="line"><span class="cl">    private Class&lt;?&gt; interfaceClass;
</span></span><span class="line"><span class="cl">    private String serviceVersion;
</span></span><span class="line"><span class="cl">    private String registryType;
</span></span><span class="line"><span class="cl">    private String registryAddr;
</span></span><span class="line"><span class="cl">    private long timeout;
</span></span><span class="line"><span class="cl">    private Object object;
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public Object getObject() throws Exception {
</span></span><span class="line"><span class="cl">        return object;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public Class&lt;?&gt; getObjectType() {
</span></span><span class="line"><span class="cl">        return interfaceClass;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public void init() throws Exception {
</span></span><span class="line"><span class="cl">        // TODO 生成动态代理对象并赋值给 object
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public void setInterfaceClass(Class&lt;?&gt; interfaceClass) {
</span></span><span class="line"><span class="cl">        this.interfaceClass = interfaceClass;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public void setServiceVersion(String serviceVersion) {
</span></span><span class="line"><span class="cl">        this.serviceVersion = serviceVersion;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public void setRegistryType(String registryType) {
</span></span><span class="line"><span class="cl">        this.registryType = registryType;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public void setRegistryAddr(String registryAddr) {
</span></span><span class="line"><span class="cl">        this.registryAddr = registryAddr;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public void setTimeout(long timeout) {
</span></span><span class="line"><span class="cl">        this.timeout = timeout;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 RpcReferenceBean 中 init() 方法被我标注了 TODO，此处需要实现动态代理对象，并通过代理对象完成 RPC 调用。对于使用者来说只是通过 @RpcReference 订阅了服务，并不感知底层调用的细节。对于如何实现 RPC 通信、服务寻址等，都是在动态代理类中完成的，在后面我们会有专门的一节课详细讲解动态代理的实现。</p>
<p>有了 @RpcReference 注解和 RpcReferenceBean 之后，我们可以使用 Spring 的扩展点 BeanFactoryPostProcessor 对 Bean 的定义进行修改。上文中服务提供者使用的是 BeanPostProcessor，BeanFactoryPostProcessor 和 BeanPostProcessor 都是 Spring 的核心扩展点，它们之间有什么区别呢？BeanFactoryPostProcessor 是 Spring 容器加载 Bean 的定义之后以及 Bean 实例化之前执行，所以 BeanFactoryPostProcessor 可以在 Bean 实例化之前获取 Bean 的配置元数据，并允许用户对其修改。而 BeanPostProcessor 是在 Bean 初始化前后执行，它并不能修改 Bean 的配置信息。</p>
<p>现在我们需要对声明 @RpcReference 注解的成员变量构造出 RpcReferenceBean，所以需要实现 BeanFactoryPostProcessor 修改 Bean 的定义，具体实现如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@Component
</span></span><span class="line"><span class="cl">@Slf4j
</span></span><span class="line"><span class="cl">public class RpcConsumerPostProcessor implements ApplicationContextAware, BeanClassLoaderAware, BeanFactoryPostProcessor {
</span></span><span class="line"><span class="cl">    private ApplicationContext context;
</span></span><span class="line"><span class="cl">    private ClassLoader classLoader;
</span></span><span class="line"><span class="cl">    private final Map&lt;String, BeanDefinition&gt; rpcRefBeanDefinitions = new LinkedHashMap&lt;&gt;();
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
</span></span><span class="line"><span class="cl">        this.context = applicationContext;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void setBeanClassLoader(ClassLoader classLoader) {
</span></span><span class="line"><span class="cl">        this.classLoader = classLoader;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
</span></span><span class="line"><span class="cl">        for (String beanDefinitionName : beanFactory.getBeanDefinitionNames()) {
</span></span><span class="line"><span class="cl">            BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanDefinitionName);
</span></span><span class="line"><span class="cl">            String beanClassName = beanDefinition.getBeanClassName();
</span></span><span class="line"><span class="cl">            if (beanClassName != null) {
</span></span><span class="line"><span class="cl">                Class&lt;?&gt; clazz = ClassUtils.resolveClassName(beanClassName, this.classLoader);
</span></span><span class="line"><span class="cl">                ReflectionUtils.doWithFields(clazz, this::parseRpcReference);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
</span></span><span class="line"><span class="cl">        this.rpcRefBeanDefinitions.forEach((beanName, beanDefinition) -&gt; {
</span></span><span class="line"><span class="cl">            if (context.containsBean(beanName)) {
</span></span><span class="line"><span class="cl">                throw new IllegalArgumentException(&#34;spring context already has a bean named &#34; + beanName);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            registry.registerBeanDefinition(beanName, rpcRefBeanDefinitions.get(beanName));
</span></span><span class="line"><span class="cl">            log.info(&#34;registered RpcReferenceBean {} success.&#34;, beanName);
</span></span><span class="line"><span class="cl">        });
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    private void parseRpcReference(Field field) {
</span></span><span class="line"><span class="cl">        RpcReference annotation = AnnotationUtils.getAnnotation(field, RpcReference.class);
</span></span><span class="line"><span class="cl">        if (annotation != null) {
</span></span><span class="line"><span class="cl">            BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(RpcReferenceBean.class);
</span></span><span class="line"><span class="cl">            builder.setInitMethodName(RpcConstants.INIT_METHOD_NAME);
</span></span><span class="line"><span class="cl">            builder.addPropertyValue(&#34;interfaceClass&#34;, field.getType());
</span></span><span class="line"><span class="cl">            builder.addPropertyValue(&#34;serviceVersion&#34;, annotation.serviceVersion());
</span></span><span class="line"><span class="cl">            builder.addPropertyValue(&#34;registryType&#34;, annotation.registryType());
</span></span><span class="line"><span class="cl">            builder.addPropertyValue(&#34;registryAddr&#34;, annotation.registryAddress());
</span></span><span class="line"><span class="cl">            builder.addPropertyValue(&#34;timeout&#34;, annotation.timeout());
</span></span><span class="line"><span class="cl">            BeanDefinition beanDefinition = builder.getBeanDefinition();
</span></span><span class="line"><span class="cl">            rpcRefBeanDefinitions.put(field.getName(), beanDefinition);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>RpcConsumerPostProcessor 类中重写了 BeanFactoryPostProcessor 的 postProcessBeanFactory 方法，从 beanFactory 中获取所有 Bean 的定义信息，然后分别对每个 Bean 的所有 field 进行检测。如果 field 被声明了 @RpcReference 注解，通过 BeanDefinitionBuilder 构造 RpcReferenceBean 的定义，并为 RpcReferenceBean 的成员变量赋值，包括服务类型 interfaceClass、服务版本 serviceVersion、注册中心类型 registryType、注册中心地址 registryAddr 以及超时时间 timeout。构造完 RpcReferenceBean 的定义之后，会将RpcReferenceBean 的 BeanDefinition 重新注册到 Spring 容器中。</p>
<p>至此，我们已经将服务提供者服务消费者的基本框架搭建出来了，并且着重介绍了服务提供者使用 @RpcService 注解是如何发布服务的，服务消费者相应需要一个能够注入服务接口的注解 @RpcReference，被 @RpcReference 修饰的成员变量都会被构造成 RpcReferenceBean，并为它生成动态代理类，后面我们再继续深入介绍。</p>
<p>总结</p>
<p>本节课我们介绍了服务发布与订阅的实现原理，搭建出了服务提供者和服务消费者的基本框架。可以看出，如果采用 Java 语言实现 RPC 框架核心的服务发布与订阅的核心逻辑，需要你具备较为扎实的 Spring 框架基础。了解 Spring 重要的扩展接口，可以帮助我们开发出更优雅的代码。</p>
<p>留两个课后作业：</p>
<p>本节课我留下了几处待完成的 TODO，你可以独立思考下，从这些 TODO 入手，是否可以构思出整个 RPC 框架的脉络呢？</p>
<p>复习 Netty 自定义处理器 ChannelHandler 和编解码的基础知识，下节课我们将完成 RPC 框架的网络通信部分。</p>
<p>-&ndash; ### 精选评论 ##### **辉： &gt; 老师 RpcProvider是spring实例化吗？如果是单例的，他的rpcServiceMap会不会有线程安全问题？ ######     讲师回复： &gt;     是spring初始化完成的，不会有线程安全问题。 ##### **健： &gt; 不黑不吹，老师这种源码-源码的方式，让读者理解得更透彻，3连一个！！！ ##### *同： &gt; 老师讲解很细腻，突出了很多知识点，赞 ##### **家： &gt; 很不错 让我复习了IOC</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/">Netty核心原理剖析与RPC实践</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kubernetes%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/24%E8%B0%83%E5%BA%A6%E5%BC%95%E6%93%8Ekubernete%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%B0%83%E5%BA%A6pod/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">24调度引擎：Kubernete如何高效调度Pod？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/shardingsphere%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%B2%BE%E8%AE%B2/24%E5%BD%92%E5%B9%B6%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BD%92%E5%B9%B6%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BD%92%E5%B9%B6%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/">
            <span class="next-text nav-default">24归并引擎：如何理解数据归并的类型以及简单归并策略的实现过程？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
