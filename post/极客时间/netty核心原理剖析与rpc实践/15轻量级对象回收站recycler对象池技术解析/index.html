<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>15轻量级对象回收站：Recycler对象池技术解析 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="前面两节课，我们学习了 Netty 内存池的高性能设计原理，这节课会介绍 Netty 的另一种池化技术：Recycler 对象池。在刚接触到 Netty 对象池这个概念时，你是不是也会有类似的疑问：
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/15%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E7%AB%99recycler%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/15%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E7%AB%99recycler%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="15轻量级对象回收站：Recycler对象池技术解析">
  <meta property="og:description" content="前面两节课，我们学习了 Netty 内存池的高性能设计原理，这节课会介绍 Netty 的另一种池化技术：Recycler 对象池。在刚接触到 Netty 对象池这个概念时，你是不是也会有类似的疑问：">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Netty核心原理剖析与RPC实践">

  <meta itemprop="name" content="15轻量级对象回收站：Recycler对象池技术解析">
  <meta itemprop="description" content="前面两节课，我们学习了 Netty 内存池的高性能设计原理，这节课会介绍 Netty 的另一种池化技术：Recycler 对象池。在刚接触到 Netty 对象池这个概念时，你是不是也会有类似的疑问：">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6232">
  <meta itemprop="keywords" content="Netty核心原理剖析与RPC实践">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="15轻量级对象回收站：Recycler对象池技术解析">
  <meta name="twitter:description" content="前面两节课，我们学习了 Netty 内存池的高性能设计原理，这节课会介绍 Netty 的另一种池化技术：Recycler 对象池。在刚接触到 Netty 对象池这个概念时，你是不是也会有类似的疑问：">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">15轻量级对象回收站：Recycler对象池技术解析</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6232 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>前面两节课，我们学习了 Netty 内存池的高性能设计原理，这节课会介绍 Netty 的另一种池化技术：Recycler 对象池。在刚接触到 Netty 对象池这个概念时，你是不是也会有类似的疑问：</p>
<p>对象池和内存池有什么区别？它们有什么联系吗？</p>
<p>实现对象池的方法有很多，Netty 也是自己实现的吗？是如何实现的？</p>
<p>对象池在实践中我们应该怎么使用？</p>
<p>带着这些问题，我们进入今天课程的学习吧。</p>
<p>Recycler 快速上手</p>
<p>我们通过一个例子直观感受下 Recycler 如何使用，假设我们有一个 User 类，需要实现 User 对象的复用，具体实现代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class UserCache {
</span></span><span class="line"><span class="cl">    private static final Recycler&lt;User&gt; userRecycler = new Recycler&lt;User&gt;() {
</span></span><span class="line"><span class="cl">        @Override
</span></span><span class="line"><span class="cl">        protected User newObject(Handle&lt;User&gt; handle) {
</span></span><span class="line"><span class="cl">            return new User(handle);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    };
</span></span><span class="line"><span class="cl">    static final class User {
</span></span><span class="line"><span class="cl">        private String name;
</span></span><span class="line"><span class="cl">        private Recycler.Handle&lt;User&gt; handle;
</span></span><span class="line"><span class="cl">        public void setName(String name) {
</span></span><span class="line"><span class="cl">            this.name = name;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        public String getName() {
</span></span><span class="line"><span class="cl">            return name;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        public User(Recycler.Handle&lt;User&gt; handle) {
</span></span><span class="line"><span class="cl">            this.handle = handle;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        public void recycle() {
</span></span><span class="line"><span class="cl">            handle.recycle(this);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        User user1 = userRecycler.get(); // 1、从对象池获取 User 对象
</span></span><span class="line"><span class="cl">        user1.setName(&#34;hello&#34;); // 2、设置 User 对象的属性
</span></span><span class="line"><span class="cl">        user1.recycle(); // 3、回收对象到对象池
</span></span><span class="line"><span class="cl">        User user2 = userRecycler.get(); // 4、从对象池获取对象
</span></span><span class="line"><span class="cl">        System.out.println(user2.getName());
</span></span><span class="line"><span class="cl">        System.out.println(user1 == user2);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>控制台的输出结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">hello
</span></span><span class="line"><span class="cl">true
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码示例中定义了对象池实例 userRecycler，其中实现了 newObject() 方法，如果对象池没有可用的对象，会调用该方法新建对象。此外需要创建 Recycler.Handle 对象与 User 对象进行绑定，这样我们就可以通过 userRecycler.get() 从对象池中获取 User 对象，如果对象不再使用，通过调用 User 类实现的 recycle() 方法即可完成回收对象到对象池。</p>
<p>Recycler 的使用方式是不是特别简单，我们可以单独把它当作工具类在项目中使用。</p>
<p>Recycler 的设计理念</p>
<p>对象池与内存池的都是为了提高 Netty 的并发处理能力，我们知道 Java 中频繁地创建和销毁对象的开销是很大的，所以很多人会将一些通用对象缓存起来，当需要某个对象时，优先从对象池中获取对象实例。通过重用对象，不仅避免频繁地创建和销毁所带来的性能损耗，而且对 JVM GC 是友好的，这就是对象池的作用。</p>
<p>Recycler 是 Netty 提供的自定义实现的轻量级对象回收站，借助 Recycler 可以完成对象的获取和回收。既然 Recycler 是 Netty 自己实现的对象池，那么它是如何设计的呢？首先看下 Recycler 的内部结构，如下图所示：</p>
<p>通过 Recycler 的 UML 图可以看出，一共包含四个核心组件：Stack、WeakOrderQueue、Link、DefaultHandle，接下来我们逐一进行介绍。</p>
<p>首先我们先看下整个 Recycler 的内部结构中各个组件的关系，可以通过下面这幅图进行描述。</p>
<p>第一个核心组件是 Stack，Stack 是整个对象池的顶层数据结构，描述了整个对象池的构造，用于存储当前本线程回收的对象。在多线程的场景下，Netty 为了避免锁竞争问题，每个线程都会持有各自的对象池，内部通过 FastThreadLocal 来实现每个线程的私有化。FastThreadLocal 你可以理解为 Java 里的 ThreadLocal，后续会有专门的课程介绍它。</p>
<p>我们有必要先学习下 Stack 的数据结构，先看下 Stack 的源码定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">static final class Stack&lt;T&gt; {
</span></span><span class="line"><span class="cl">    final Recycler&lt;T&gt; parent; // 所属的 Recycler
</span></span><span class="line"><span class="cl">    final WeakReference&lt;Thread&gt; threadRef; // 所属线程的弱引用
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    final AtomicInteger availableSharedCapacity; // 异线程回收对象时，其他线程能保存的被回收对象的最大个数
</span></span><span class="line"><span class="cl">    final int maxDelayedQueues; // WeakOrderQueue最大个数
</span></span><span class="line"><span class="cl">    private final int maxCapacity; // 对象池的最大大小，默认最大为 4k
</span></span><span class="line"><span class="cl">    private final int ratioMask; // 控制对象的回收比率，默认只回收 1/8 的对象
</span></span><span class="line"><span class="cl">    private DefaultHandle&lt;?&gt;[] elements; // 存储缓存数据的数组
</span></span><span class="line"><span class="cl">    private int size; // 缓存的 DefaultHandle 对象个数
</span></span><span class="line"><span class="cl">    private int handleRecycleCount = -1; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // WeakOrderQueue 链表的三个重要节点
</span></span><span class="line"><span class="cl">    private WeakOrderQueue cursor, prev;
</span></span><span class="line"><span class="cl">    private volatile WeakOrderQueue head;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 省略其他代码
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>对应上面 Recycler 的内部结构图，Stack 包用于存储缓存数据的 DefaultHandle 数组，以及维护了 WeakOrderQueue 链表中的三个重要节点，关于 WeakOrderQueue 相关概念我们之后再详细介绍。除此之外，Stack 其他的重要属性我在源码中已经全部以注释的形式标出，大部分已经都非常清楚，其中 availableSharedCapacity 是比较难理解的，每个 Stack 会维护一个 WeakOrderQueue 的链表，每个 WeakOrderQueue 节点会保存非当前线程的其他线程所释放的对象，例如图中 ThreadA 表示当前线程，WeakOrderQueue 的链表存储着 ThreadB、ThreadC 等其他线程释放的对象。availableSharedCapacity 的初始化方式为 new AtomicInteger(max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY))，默认大小为 16K，其他线程在回收对象时，最多可以回收 ThreadA 创建的对象个数不能超过 availableSharedCapacity。还有一个疑问就是既然 Stack 是每个线程私有的，为什么 availableSharedCapacity 还需要用 AtomicInteger 呢？因为 ThreadB、ThreadC 等多个线程可能都会创建 ThreadA 的 WeakOrderQueue，存在同时操作 availableSharedCapacity 的情况。</p>
<p>第二个要介绍的组件是 WeakOrderQueue，WeakOrderQueue 用于存储其他线程回收到当前线程所分配的对象，并且在合适的时机，Stack 会从异线程的 WeakOrderQueue 中收割对象。如上图所示，ThreadB 回收到 ThreadA 所分配的内存时，就会被放到 ThreadA 的 WeakOrderQueue 当中。</p>
<p>第三个组件是 Link，每个 WeakOrderQueue 中都包含一个 Link 链表，回收对象都会被存在 Link 链表中的节点上，每个 Link 节点默认存储 16 个对象，当每个 Link 节点存储满了会创建新的 Link 节点放入链表尾部。</p>
<p>第四个组件是 DefaultHandle，DefaultHandle 实例中保存了实际回收的对象，Stack 和 WeakOrderQueue 都使用 DefaultHandle 存储回收的对象。在 Stack 中包含一个 elements 数组，该数组保存的是 DefaultHandle 实例。DefaultHandle 中每个 Link 节点所存储的 16 个对象也是使用 DefaultHandle 表示的。</p>
<p>到此为止，我们已经介绍完 Recycler 的内存结构，对 Recycler 有了初步的认识。Recycler 作为一个高性能的对象池，在多线程的场景下，Netty 是如何保证 Recycler 高效地分配和回收对象的呢？接下来我们一起看下 Recycler 对象获取和回收的原理。</p>
<p>从 Recycler 中获取对象</p>
<p>前面我们介绍了 Recycler 如何使用，从代码示例中可以看出，从对象池中获取对象的入口是在 Recycler#get() 方法，直接定位到源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final T get() {
</span></span><span class="line"><span class="cl">    if (maxCapacityPerThread == 0) {
</span></span><span class="line"><span class="cl">        return newObject((Handle&lt;T&gt;) NOOP_HANDLE);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    Stack&lt;T&gt; stack = threadLocal.get(); // 获取当前线程缓存的 Stack
</span></span><span class="line"><span class="cl">    DefaultHandle&lt;T&gt; handle = stack.pop(); // 从 Stack 中弹出一个 DefaultHandle 对象
</span></span><span class="line"><span class="cl">    if (handle == null) {
</span></span><span class="line"><span class="cl">        handle = stack.newHandle();
</span></span><span class="line"><span class="cl">        handle.value = newObject(handle); // 创建的对象并保存到 DefaultHandle
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return (T) handle.value;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Recycler#get() 方法的逻辑非常清晰，首先通过 FastThreadLocal 获取当前线程的唯一栈缓存 Stack，然后尝试从栈顶弹出 DefaultHandle 对象实例，如果 Stack 中没有可用的 DefaultHandle 对象实例，那么会调用 newObject 生成一个新的对象，完成 handle 与用户对象和 Stack 的绑定。</p>
<p>那么 Stack 是如何从 elements 数组中弹出 DefaultHandle 对象实例的呢？只是从 elements 数组中取出一个实例吗？我们一起跟进下 stack.pop() 的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">DefaultHandle&lt;T&gt; pop() {
</span></span><span class="line"><span class="cl">    int size = this.size;
</span></span><span class="line"><span class="cl">    if (size == 0) {
</span></span><span class="line"><span class="cl">        // 就尝试从其他线程回收的对象中转移一些到 elements 数组当中
</span></span><span class="line"><span class="cl">        if (!scavenge()) {
</span></span><span class="line"><span class="cl">            return null;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        size = this.size;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    size --;
</span></span><span class="line"><span class="cl">    DefaultHandle ret = elements[size]; // 将实例从栈顶弹出
</span></span><span class="line"><span class="cl">    elements[size] = null;
</span></span><span class="line"><span class="cl">    if (ret.lastRecycledId != ret.recycleId) {
</span></span><span class="line"><span class="cl">        throw new IllegalStateException(&#34;recycled multiple times&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    ret.recycleId = 0;
</span></span><span class="line"><span class="cl">    ret.lastRecycledId = 0;
</span></span><span class="line"><span class="cl">    this.size = size;
</span></span><span class="line"><span class="cl">    return ret;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果 Stack 的 elements 数组中有可用的对象实例，直接将对象实例弹出；如果 elements 数组中没有可用的对象实例，会调用 scavenge 方法，scavenge 的作用是从其他线程回收的对象实例中转移一些到 elements 数组当中，也就是说，它会想办法从 WeakOrderQueue 链表中迁移部分对象实例。每个 Stack 会有一个 WeakOrderQueue 链表，每个 WeakOrderQueue 节点都维持了相应异线程回收的对象，那么以什么样的策略从 WeakOrderQueue 链表中迁移对象实例呢？继续跟进 scavenge 的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">boolean scavenge() {
</span></span><span class="line"><span class="cl">    // 尝试从 WeakOrderQueue 中转移对象实例到 Stack 中
</span></span><span class="line"><span class="cl">    if (scavengeSome()) {
</span></span><span class="line"><span class="cl">        return true;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 如果迁移失败，就会重置 cursor 指针到 head 节点
</span></span><span class="line"><span class="cl">    prev = null;
</span></span><span class="line"><span class="cl">    cursor = head;
</span></span><span class="line"><span class="cl">    return false;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">boolean scavengeSome() {
</span></span><span class="line"><span class="cl">    WeakOrderQueue prev;
</span></span><span class="line"><span class="cl">    WeakOrderQueue cursor = this.cursor; // cursor 指针指向当前 WeakorderQueueu 链表的读取位置
</span></span><span class="line"><span class="cl">    // 如果 cursor 指针为 null, 则是第一次从 WeakorderQueueu 链表中获取对象
</span></span><span class="line"><span class="cl">    if (cursor == null) {
</span></span><span class="line"><span class="cl">        prev = null;
</span></span><span class="line"><span class="cl">        cursor = head;
</span></span><span class="line"><span class="cl">        if (cursor == null) {
</span></span><span class="line"><span class="cl">            return false;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        prev = this.prev;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    boolean success = false;
</span></span><span class="line"><span class="cl">    // 不断循环从 WeakOrderQueue 链表中找到一个可用的对象实例
</span></span><span class="line"><span class="cl">    do {
</span></span><span class="line"><span class="cl">        // 尝试迁移 WeakOrderQueue 中部分对象实例到 Stack 中
</span></span><span class="line"><span class="cl">        if (cursor.transfer(this)) {
</span></span><span class="line"><span class="cl">            success = true;
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        WeakOrderQueue next = cursor.next;
</span></span><span class="line"><span class="cl">        if (cursor.owner.get() == null) {
</span></span><span class="line"><span class="cl">            // 如果已退出的线程还有数据
</span></span><span class="line"><span class="cl">            if (cursor.hasFinalData()) {
</span></span><span class="line"><span class="cl">                for (;;) {
</span></span><span class="line"><span class="cl">                    if (cursor.transfer(this)) {
</span></span><span class="line"><span class="cl">                        success = true;
</span></span><span class="line"><span class="cl">                    } else {
</span></span><span class="line"><span class="cl">                        break;
</span></span><span class="line"><span class="cl">                    }
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // 将已退出的线程从 WeakOrderQueue 链表中移除
</span></span><span class="line"><span class="cl">            if (prev != null) {
</span></span><span class="line"><span class="cl">                prev.setNext(next);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            prev = cursor;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 将 cursor 指针指向下一个 WeakOrderQueue
</span></span><span class="line"><span class="cl">        cursor = next;
</span></span><span class="line"><span class="cl">    } while (cursor != null &amp;&amp; !success);
</span></span><span class="line"><span class="cl">    this.prev = prev;
</span></span><span class="line"><span class="cl">    this.cursor = cursor;
</span></span><span class="line"><span class="cl">    return success;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>scavenge 的源码中首先会从 cursor 指针指向的 WeakOrderQueue 节点回收部分对象到 Stack 的 elements 数组中，如果没有回收到数据就会将 cursor 指针移到下一个 WeakOrderQueue，重复执行以上过程直至回到到对象实例为止。具体的流程可以结合下图来理解。</p>
<p>此外，每次移动 cursor 时，都会检查 WeakOrderQueue 对应的线程是否已经退出了，如果线程已经退出，那么线程中的对象实例都会被回收，然后将 WeakOrderQueue 节点从链表中移除。</p>
<p>还有一个问题，每次 Stack 从 WeakOrderQueue 链表会回收多少数据呢？我们依然结合上图讲解，每个 WeakOrderQueue 中都包含一个 Link 链表，Netty 每次会回收其中的一个 Link 节点所存储的对象。从图中可以看出，Link 内部会包含一个读指针 readIndex，每个 Link 节点默认存储 16 个对象，读指针到链表尾部就是可以用于回收的对象实例，每次回收对象时，readIndex 都会从上一次记录的位置开始回收。</p>
<p>在回收对象实例之前，Netty 会计算出可回收对象的数量，加上 Stack 中已有的对象数量后，如果超过 Stack 的当前容量且小于 Stack 的最大容量，会对 Stack 进行扩容。为了防止回收对象太多导致 Stack 的容量激增，在每次回收时 Netty 会调用 dropHandle 方法控制回收频率，具体源码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">boolean dropHandle(DefaultHandle&lt;?&gt; handle) {
</span></span><span class="line"><span class="cl">    if (!handle.hasBeenRecycled) {
</span></span><span class="line"><span class="cl">        if ((++handleRecycleCount &amp; ratioMask) != 0) {
</span></span><span class="line"><span class="cl">            // Drop the object.
</span></span><span class="line"><span class="cl">            return true;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        handle.hasBeenRecycled = true;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return false;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>dropHandle 方法中主要靠 hasBeenRecycled 和 handleRecycleCount 两个变量控制回收的频率，会从每 8 个未被收回的对象中选取一个进行回收，其他的都被丢弃掉。</p>
<p>到此为止，从 Recycler 中获取对象的主流程已经讲完了，简单总结为两点：</p>
<p>当 Stack 中 elements 有数据时，直接从栈顶弹出。</p>
<p>当 Stack 中 elements 没有数据时，尝试从 WeakOrderQueue 中回收一个 Link 包含的对象实例到 Stack 中，然后从栈顶弹出。</p>
<p>Recycler 对象回收原理</p>
<p>理解了如何从 Recycler 获取对象之后，再学习 Recycler 对象回收的原理就会清晰很多了，同样上文代码示例中定位到对象回收的源码入口 DefaultHandle#recycle()。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// DefaultHandle#recycle
</span></span><span class="line"><span class="cl">public void recycle(Object object) {
</span></span><span class="line"><span class="cl">    if (object != value) {
</span></span><span class="line"><span class="cl">        throw new IllegalArgumentException(&#34;object does not belong to handle&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    Stack&lt;?&gt; stack = this.stack;
</span></span><span class="line"><span class="cl">    if (lastRecycledId != recycleId || stack == null) {
</span></span><span class="line"><span class="cl">        throw new IllegalStateException(&#34;recycled already&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    stack.push(this);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// Stack#push
</span></span><span class="line"><span class="cl">void push(DefaultHandle&lt;?&gt; item) {
</span></span><span class="line"><span class="cl">    Thread currentThread = Thread.currentThread();
</span></span><span class="line"><span class="cl">    if (threadRef.get() == currentThread) {
</span></span><span class="line"><span class="cl">        pushNow(item);
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        pushLater(item, currentThread);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>从源码中可以看出，在回收对象时，会向 Stack 中 push 对象，push 会分为同线程回收和异线程回收两种情况，分别对应 pushNow 和 pushLater 两个方法，我们逐一进行分析。</p>
<p>同线程对象回收</p>
<p>如果是当前线程回收自己分配的对象时，会调用 pushNow 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private void pushNow(DefaultHandle&lt;?&gt; item) {
</span></span><span class="line"><span class="cl">    if ((item.recycleId | item.lastRecycledId) != 0) { // 防止被多次回收
</span></span><span class="line"><span class="cl">        throw new IllegalStateException(&#34;recycled already&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    item.recycleId = item.lastRecycledId = OWN_THREAD_ID;
</span></span><span class="line"><span class="cl">    int size = this.size;
</span></span><span class="line"><span class="cl">    // 1. 超出最大容量 2. 控制回收速率
</span></span><span class="line"><span class="cl">    if (size &gt;= maxCapacity || dropHandle(item)) {
</span></span><span class="line"><span class="cl">        return;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    if (size == elements.length) {
</span></span><span class="line"><span class="cl">        elements = Arrays.copyOf(elements, min(size &lt;&lt; 1, maxCapacity));
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    elements[size] = item;
</span></span><span class="line"><span class="cl">    this.size = size + 1;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>同线程回收对象的逻辑非常简单，就是直接向 Stack 的 elements 数组中添加数据，对象会被存放在栈顶指针指向的位置。如果超过了 Stack 的最大容量，那么对象会被直接丢弃，同样这里使用了 dropHandle 方法控制对象的回收速率，每 8 个对象会有一个被回收到 Stack 中。</p>
<p>异线程对象回收</p>
<p>接下来我们分析异线程对象回收的场景，想必你已经猜到，异线程回收对象时，并不会添加到 Stack 中，而是会与 WeakOrderQueue 直接打交道，先看下 pushLater 的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private void pushLater(DefaultHandle&lt;?&gt; item, Thread thread) {
</span></span><span class="line"><span class="cl">    Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get(); // 当前线程帮助其他线程回收对象的缓存
</span></span><span class="line"><span class="cl">    WeakOrderQueue queue = delayedRecycled.get(this); // 取出对象绑定的 Stack 对应的 WeakOrderQueue
</span></span><span class="line"><span class="cl">    if (queue == null) {
</span></span><span class="line"><span class="cl">        // 最多帮助 2*CPU 核数的线程回收线程
</span></span><span class="line"><span class="cl">        if (delayedRecycled.size() &gt;= maxDelayedQueues) {
</span></span><span class="line"><span class="cl">            delayedRecycled.put(this, WeakOrderQueue.DUMMY); // WeakOrderQueue.DUMMY 表示当前线程无法再帮助该 Stack 回收对象
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 新建 WeakOrderQueue
</span></span><span class="line"><span class="cl">        if ((queue = WeakOrderQueue.allocate(this, thread)) == null) {
</span></span><span class="line"><span class="cl">            // drop object
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        delayedRecycled.put(this, queue);
</span></span><span class="line"><span class="cl">    } else if (queue == WeakOrderQueue.DUMMY) {
</span></span><span class="line"><span class="cl">        // drop object
</span></span><span class="line"><span class="cl">        return;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    queue.add(item); // 添加对象到 WeakOrderQueue 的 Link 链表中
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>pushLater 的实现过程可以总结为两个步骤：获取 WeakOrderQueue，添加对象到 WeakOrderQueue 中。</p>
<p>首先看下如何获取 WeakOrderQueue 对象。通过 FastThreadLocal 取出当前对象的 DELAYED_RECYCLED 缓存，DELAYED_RECYCLED 存放着当前线程帮助其他线程回收对象的映射关系。假如 item 是 ThreadA 分配的对象，当前线程是 ThreadB，此时 ThreadB 帮助 ThreadA 回收 item，那么 DELAYED_RECYCLED 放入的 key 是 StackA。然后从 delayedRecycled 中取出 StackA 对应的 WeakOrderQueue，如果 WeakOrderQueue 不存在，那么为 StackA 新创建一个 WeakOrderQueue，并将其加入 DELAYED_RECYCLED 缓存。WeakOrderQueue.allocate() 会检查帮助 StackA 回收的对象总数是否超过 2K 个，如果没有超过 2K，会将 StackA 的 head 指针指向新创建的 WeakOrderQueue，否则不再为 StackA 回收对象。</p>
<p>当然 ThreadB 不会只帮助 ThreadA 回收对象，它可以帮助其他多个线程回收，所以 DELAYED_RECYCLED 使用的 Map 结构，为了防止 DELAYED_RECYCLED 内存膨胀，Netty 也采取了保护措施，从 delayedRecycled.size() &gt;= maxDelayedQueues 可以看出，每个线程最多帮助 2 倍 CPU 核数的线程回收线程，如果超过了该阈值，假设当前对象绑定的为 StackX，那么将在 Map 中为 StackX 放入一种特殊的 WeakOrderQueue.DUMMY，表示当前线程无法帮助 StackX 回收对象。</p>
<p>接下来我们继续分析对象是如何被添加到 WeakOrderQueue 的，直接跟进 queue.add(item) 的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void add(DefaultHandle&lt;?&gt; handle) {
</span></span><span class="line"><span class="cl">    handle.lastRecycledId = id;
</span></span><span class="line"><span class="cl">    Link tail = this.tail;
</span></span><span class="line"><span class="cl">    int writeIndex;
</span></span><span class="line"><span class="cl">    // 如果链表尾部的 Link 已经写满，那么再新建一个 Link 追加到链表尾部
</span></span><span class="line"><span class="cl">    if ((writeIndex = tail.get()) == LINK_CAPACITY) {
</span></span><span class="line"><span class="cl">        // 检查是否超过对应 Stack 可以存放的其他线程帮助回收的最大对象数
</span></span><span class="line"><span class="cl">        if (!head.reserveSpace(LINK_CAPACITY)) {
</span></span><span class="line"><span class="cl">            // Drop it.
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        this.tail = tail = tail.next = new Link();
</span></span><span class="line"><span class="cl">        writeIndex = tail.get();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    tail.elements[writeIndex] = handle; // 添加对象到 Link 尾部
</span></span><span class="line"><span class="cl">    handle.stack = null; // handle 的 stack 属性赋值为 null
</span></span><span class="line"><span class="cl">    tail.lazySet(writeIndex + 1);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在向 WeakOrderQueue 写入对象之前，会先判断 Link 链表的 tail 节点是否还有空间存放对象。如果还有空间，直接向 tail Link 尾部写入数据，否则直接丢弃对象。如果 tail Link 已经没有空间，会新建一个 Link 之后再存放对象，新建 Link 之前会检查异线程帮助回收的对象总数超过了 Stack 设置的阈值，如果超过了阈值，那么对象也会被丢弃掉。</p>
<p>对象被添加到 Link 之后，handle 的 stack 属性被赋值为 null，而在取出对象的时候，handle 的 stack 属性又再次被赋值回来，为什么这么做呢，岂不是很麻烦？如果 Stack 不再使用，期望被 GC 回收，发现 handle 中还持有 Stack 的引用，那么就无法被 GC 回收，从而造成内存泄漏。</p>
<p>到此为止，Recycler 如何回收对象的实现原理就全部分析完了，在多线程的场景下，Netty 考虑的还是非常细致的，Recycler 回收对象时向 WeakOrderQueue 中存放对象，从 Recycler 获取对象时，WeakOrderQueue 中的对象会作为 Stack 的储备，而且有效地解决了跨线程回收的问题，是一个挺新颖别致的设计。</p>
<p>Recycler 在 Netty 中的应用</p>
<p>Recycler 在 Netty 里面使用也是非常频繁的，我们直接看下 Netty 源码中 newObject 相关的引用，如下图所示。</p>
<p>其中比较常用的有 PooledHeapByteBuf 和 PooledDirectByteBuf，分别对应的堆内存和堆外内存的池化实现。例如我们在使用 PooledDirectByteBuf 的时候，并不是每次都去创建新的对象实例，而是从对象池中获取预先分配好的对象实例，不再使用 PooledDirectByteBuf 时，被回收归还到对象池中。</p>
<p>此外，可以看到内存池的 MemoryRegionCache 也有使用到对象池，MemoryRegionCache 中保存着一个队列，队列中每个 Entry 节点用于保存内存块，Entry 节点在 Netty 中就是以对象池的形式进行分配和释放，在这里我就不展开了，建议你翻阅下源码，学习下 Entry 节点是何时被分配和释放的，从而加深下对 Recycler 对象池的理解。</p>
<p>总结</p>
<p>最后，简单总结下对象池几个重要的知识点：</p>
<p>对象池有两个重要的组成部分：Stack 和 WeakOrderQueue。</p>
<p>从 Recycler 获取对象时，优先从 Stack 中查找，如果 Stack 没有可用对象，会尝试从 WeakOrderQueue 迁移部分对象到 Stack 中。</p>
<p>Recycler 回收对象时，分为同线程对象回收和异线程对象回收两种情况，同线程回收直接向 Stack 中添加对象，异线程回收向 WeakOrderQueue 中的 Link 添加对象。</p>
<p>对象回收都会控制回收速率，每 8 个对象会回收一个，其他的全部丢弃。</p>
<p>学完内存池、对象池的设计之后，相信你已经有很大的收获，同时也感受到学好数据结构是多么重要。为了避免依赖，Netty 并没有借助第三方库实现对象池，而是采用了独特的思路自己实现了一个轻量级的对象池，其中优秀的设计思路在开发中是非常值得借鉴的。如果你已经理解了 Recycler，你可以直接在项目中当成工具类使用它，在一些高并发的场景下能够较好地提升应用的性能。</p>
<p>-&ndash; ### 精选评论 ##### 无： &gt; 2020-12-07 daka ##### **胜： &gt; 学到了，WeakOrderQueue的使用。一直不明白弱引用的使用场景 ##### **威： &gt; 老师讲得很深入，学到了很多 ##### **增： &gt; 为什么栈顶对象就是我想获取复用的呢，回收时各个handle绑定的都是不同的对象吧 ######     讲师回复： &gt;     每种类型的 Stack 都使用 FastThreadLocal 隔离的。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8Erpc%E5%AE%9E%E8%B7%B5/">Netty核心原理剖析与RPC实践</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/15%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE%E5%A6%82%E4%BD%95%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AE%89%E5%85%A8%E5%9C%B0%E5%8D%8F%E8%B0%83%E6%93%8D%E4%BD%9C/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">15领导选举：如何在分布式系统内安全地协调操作？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%8E%A9%E8%BD%ACserverless%E6%9E%B6%E6%9E%84/15%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%BD%BF%E7%94%A8serverle%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/">
            <span class="next-text nav-default">15身份认证：使用Serverle实现登录注册功能</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
