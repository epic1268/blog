<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>10_分析篇__内存泄漏时，我们该如何一步步找到根因？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是邵亚方。
通过我们前面的基础篇以及案例篇的学习，你对内存泄漏应该有了自己的一些理解。这节课我来跟你聊一聊系统性地分析内存泄漏问题的方法：也就是说，在面对内存泄漏时，我们该如何一步步去找到根因？
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/linux%E5%86%85%E6%A0%B8%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98%E8%AF%BE/10_%E5%88%86%E6%9E%90%E7%AF%87__%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%97%B6%E6%88%91%E4%BB%AC%E8%AF%A5%E5%A6%82%E4%BD%95%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%89%BE%E5%88%B0%E6%A0%B9%E5%9B%A0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/linux%E5%86%85%E6%A0%B8%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98%E8%AF%BE/10_%E5%88%86%E6%9E%90%E7%AF%87__%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%97%B6%E6%88%91%E4%BB%AC%E8%AF%A5%E5%A6%82%E4%BD%95%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%89%BE%E5%88%B0%E6%A0%B9%E5%9B%A0/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="10_分析篇__内存泄漏时，我们该如何一步步找到根因？">
  <meta property="og:description" content="你好，我是邵亚方。
通过我们前面的基础篇以及案例篇的学习，你对内存泄漏应该有了自己的一些理解。这节课我来跟你聊一聊系统性地分析内存泄漏问题的方法：也就是说，在面对内存泄漏时，我们该如何一步步去找到根因？">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Linux内核技术实战课">

  <meta itemprop="name" content="10_分析篇__内存泄漏时，我们该如何一步步找到根因？">
  <meta itemprop="description" content="你好，我是邵亚方。
通过我们前面的基础篇以及案例篇的学习，你对内存泄漏应该有了自己的一些理解。这节课我来跟你聊一聊系统性地分析内存泄漏问题的方法：也就是说，在面对内存泄漏时，我们该如何一步步去找到根因？">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="2632">
  <meta itemprop="keywords" content="Linux内核技术实战课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="10_分析篇__内存泄漏时，我们该如何一步步找到根因？">
  <meta name="twitter:description" content="你好，我是邵亚方。
通过我们前面的基础篇以及案例篇的学习，你对内存泄漏应该有了自己的一些理解。这节课我来跟你聊一聊系统性地分析内存泄漏问题的方法：也就是说，在面对内存泄漏时，我们该如何一步步去找到根因？">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">10_分析篇__内存泄漏时，我们该如何一步步找到根因？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 2632 字 </span>
          <span class="more-meta"> 预计阅读 6 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#如何定位出是谁在消耗内存">如何定位出是谁在消耗内存？</a></li>
        <li><a href="#如何去分析进程的内存泄漏原因">如何去分析进程的内存泄漏原因？</a></li>
        <li><a href="#课堂总结">课堂总结</a></li>
        <li><a href="#课后作业">课后作业</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是邵亚方。</p>
<p>通过我们前面的基础篇以及案例篇的学习，你对内存泄漏应该有了自己的一些理解。这节课我来跟你聊一聊系统性地分析内存泄漏问题的方法：也就是说，在面对内存泄漏时，我们该如何一步步去找到根因？</p>
<p>不过，我不会深入到具体语言的实现细节，以及具体业务的代码逻辑中，而是会从 Linux 系统上通用的一些分析方法来入手。这样，不论你使用什么开发语言，不论你在开发什么，它总能给你提供一些帮助。</p>
<h2 id="如何定位出是谁在消耗内存">如何定位出是谁在消耗内存？</h2>
<p>内存泄漏的外在表现通常是系统内存不够，严重的话可能会引起 OOM (Out of Memory)，甚至系统宕机。那在发生这些现象时，惯用的分析套路是什么呢？</p>
<p>首先，我们需要去找出到底是谁在消耗内存，/proc/meminfo 可以帮助我们来快速定位出问题所在。</p>
<p>/proc/meminfo 中的项目很多，我们没必要全部都背下来，不过有些项是相对容易出问题的，也是你在遇到内存相关的问题时，需要重点去排查的。我将这些项列了一张表格，也给出了每一项有异常时的排查思路。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/Linux%E5%86%85%E6%A0%B8%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98%E8%AF%BE/a455935aebc54df47201b2dd4f02c897.png" alt=""></p>
<p>总之，如果进程的内存有问题，那使用 top 就可以观察出来；如果进程的内存没有问题，那你可以从 /proc/meminfo 入手来一步步地去深入分析。</p>
<p>接下来，我们分析一个实际的案例，来看看如何分析进程内存泄漏是什么原因导致的。</p>
<h2 id="如何去分析进程的内存泄漏原因">如何去分析进程的内存泄漏原因？</h2>
<p>这是我多年以前帮助一个小伙伴分析的内存泄漏问题。这个小伙伴已经使用 top 排查出了业务进程的内存异常，但是不清楚该如何去进一步分析。</p>
<p>他遇到的这个异常是，业务进程的虚拟地址空间（VIRT）被消耗很大，但是物理内存（RES）使用得却很少，所以他怀疑是进程的虚拟地址空间有内存泄漏。</p>
<p>我们在“06 讲”中也讲过，出现该现象时，可以用 top 命令观察（这是当时保存的生产环境信息，部分信息做了脱敏处理）：</p>
<p>PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                    <br>
31108 app      20   0  285g 4.0g  19m S 60.6 12.7  10986:15 app_server</p>
<p>可以看到 app_server 这个程序的虚拟地址空间（VIRT 这一项）很大，有 285GB。</p>
<p>那该如何追踪 app_server 究竟是哪里存在问题呢？</p>
<p>我们可以用 pidstat 命令（关于该命令，你可以man pidstat）来追踪下该进程的内存行为，看看能够发现什么现象。</p>
<p>$ pidstat -r -p 31108  1</p>
<p>04:47:00 PM     31108    353.00      0.00 299029776 4182152  12.73  app_server<br>
&hellip;<br>
04:47:59 PM     31108    149.00      0.00 299029776 4181052  12.73  app_server<br>
04:48:00 PM     31108    191.00      0.00 299040020 4181188  12.73  app_server<br>
&hellip;<br>
04:48:59 PM     31108    179.00      0.00 299040020 4181400  12.73  app_server<br>
04:49:00 PM     31108    183.00      0.00 299050264 4181524  12.73  app_server<br>
&hellip;<br>
04:49:59 PM     31108    157.00      0.00 299050264 4181456  12.73  app_server<br>
04:50:00 PM     31108    207.00      0.00 299060508 4181560  12.73  app_server<br>
&hellip;<br>
04:50:59 PM     31108    127.00      0.00 299060508 4180816  12.73  app_server<br>
04:51:00 PM     31108    172.00      0.00 299070752 4180956  12.73  app_server</p>
<p>如上所示，在每个整分钟的时候，VSZ 会增大 10244KB，这看起来是一个很有规律的现象。然后，我们再来看下增大的这个内存区域到底是什么，你可以通过 /proc/PID/smaps 来看（关于 /proc 提供的信息，你可以回顾我们课程的“05 讲”）：</p>
<p>增大的内存区域，具体如下：</p>
<p>$ cat /proc/31108/smaps<br>
&hellip;<br>
7faae0e49000-7faae1849000 rw-p 00000000 00:00 0<br>
Size:              10240 kB<br>
Rss:                  80 kB<br>
Pss:                  80 kB<br>
Shared_Clean:          0 kB<br>
Shared_Dirty:          0 kB<br>
Private_Clean:         0 kB<br>
Private_Dirty:        80 kB<br>
Referenced:           60 kB<br>
Anonymous:            80 kB<br>
AnonHugePages:         0 kB<br>
Swap:                  0 kB<br>
KernelPageSize:        4 kB<br>
MMUPageSize:           4 kB<br>
7faae1849000-7faae184a000 &mdash;p 00000000 00:00 0<br>
Size:                  4 kB<br>
Rss:                   0 kB<br>
Pss:                   0 kB<br>
Shared_Clean:          0 kB<br>
Shared_Dirty:          0 kB<br>
Private_Clean:         0 kB<br>
Private_Dirty:         0 kB<br>
Referenced:            0 kB<br>
Anonymous:             0 kB<br>
AnonHugePages:         0 kB<br>
Swap:                  0 kB<br>
KernelPageSize:        4 kB<br>
MMUPageSize:           4 kB</p>
<p>可以看到，它包括：一个私有地址空间，这从 rw-p 这个属性中的 private 可以看出来；以及一个保护页，这从—p 这个属性可以看出来，即进程无法访问。对于有经验的开发者而言，从这个 4K 的保护页就可以猜测出应该跟线程栈有关了。</p>
<p>然后我们跟踪下进程申请这部分地址空间的目的是什么，通过 strace 命令来跟踪系统调用就可以了。因为 VIRT 的增加，它的系统调用函数无非是 mmap 或者 brk，那么我们只需要 strace 的结果来看下 mmap 或 brk 就可以了。</p>
<p>用 strace 跟踪如下：</p>
<p>$ strace -t -f -p 31108 -o 31108.strace</p>
<p>线程数较多，如果使用 -f 来跟踪线程，跟踪的信息量也很大，逐个搜索日志里面的 mmap 或者 brk 真是眼花缭乱，所以我们来 grep 一下这个大小 (10489856 即 10244KB)，然后过滤下就好了：</p>
<p>$ cat 31108.strace | grep 10489856   <br>
31152 23:00:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;<br>
31151 23:01:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;<br>
31157 23:02:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;<br>
31158 23:03:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;<br>
31165 23:04:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;<br>
31163 23:05:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;<br>
31153 23:06:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;<br>
31155 23:07:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;<br>
31149 23:08:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;<br>
31147 23:09:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;<br>
31159 23:10:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;<br>
31157 23:11:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;<br>
31148 23:12:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;<br>
31150 23:13:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;<br>
31173 23:14:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;</p>
<p>从这个日志我们可以看到，出错的是 mmap() 这个系统调用，那我们再来看下 mmap 这个内存的目的：</p>
<p>31151 23:01:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished &hellip;&gt;<br>
31151 23:01:00 mprotect(0x7fa94bbc0000, 4096, PROT_NONE &lt;unfinished &hellip;&gt;   &laquo;&lt; 创建一个保护页 <br>
31151 23:01:00 clone( &lt;unfinished &hellip;&gt;   &laquo;&lt; 创建线程<br>
31151 23:01:00 &lt;&hellip; clone resumed&gt; child_stack=0x7fa94c5afe50, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND<br>
|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID<br>
|CLONE_CHILD_CLEARTID, parent_tidptr=0x7fa94c5c09d0, tls=0x7fa94c5c0700, child_tidptr=0x7fa94c5c09d0) = 20610</p>
<p>可以看出，这是在 clone 时申请的线程栈。到这里你可能会有一个疑问：既然线程栈消耗了这么多的内存，那理应有很多才对啊？</p>
<p>但是实际上，系统中并没有很多 app_server 的线程，那这是为什么呢？答案其实比较简单：线程短暂执行完毕后就退出了，可是 mmap 的线程栈却没有被释放。</p>
<p>我们来写一个简单的程序复现这个现象，问题的复现是很重要的，如果很复杂的问题可以用简单的程序来复现，那就是最好的结果了。</p>
<p>如下是一个简单的复现程序：mmap 一个 40K 的线程栈，然后线程简单执行一下就退出。</p>
<p>#include &lt;stdio.h&gt;<br>
#include &lt;unistd.h&gt;<br>
#include &lt;sys/mman.h&gt;<br>
#include &lt;sys/types.h&gt;<br>
#include &lt;sys/wait.h&gt;<br>
#define _SCHED_H<br>
#define __USE_GNU<br>
#include &lt;bits/sched.h&gt;</p>
<p>#define STACK_SIZE 40960</p>
<p>int func(void *arg)<br>
{<br>
printf(&ldquo;thread enter.\n&rdquo;);<br>
sleep(1);<br>
printf(&ldquo;thread exit.\n&rdquo;);</p>
<pre><code>return 0;  
</code></pre>
<p>}</p>
<p>int main()<br>
{<br>
int thread_pid;<br>
int status;<br>
int w;</p>
<pre><code>while (1) {  
    void *addr = mmap(NULL, STACK_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0);  
    if (addr == NULL) {  
        perror(&quot;mmap&quot;);  
        goto error;  
    }  
    printf(&quot;creat new thread...\n&quot;);  
    thread_pid = clone(&amp;func, addr + STACK_SIZE, CLONE_SIGHAND|CLONE_FS|CLONE_VM|CLONE_FILES, NULL);  
    printf(&quot;Done! Thread pid: %d\n&quot;, thread_pid);  
    if (thread_pid != -1) {  
        do {  
            w = waitpid(-1, NULL, __WCLONE | __WALL);  
            if (w == -1) {  
                perror(&quot;waitpid&quot;);  
                goto error;  
            }  
        } while (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status));  
    }  
    sleep(10);  
</code></pre>
<p>}</p>
<p>error:<br>
return 0;<br>
}</p>
<p>然后我们用 pidstat 观察该进程的执行，可以发现它的现象跟生产环境中的问题是一致的：</p>
<p>$ pidstat -r -p 535 5<br>
11:56:51 PM   UID       PID  minflt/s  majflt/s     VSZ    RSS   %MEM  Command<br>
11:56:56 PM     0       535      0.20      0.00    4364    360   0.00  a.out<br>
11:57:01 PM     0       535      0.00      0.00    4364    360   0.00  a.out<br>
11:57:06 PM     0       535      0.20      0.00    4404    360   0.00  a.out<br>
11:57:11 PM     0       535      0.00      0.00    4404    360   0.00  a.out<br>
11:57:16 PM     0       535      0.20      0.00    4444    360   0.00  a.out<br>
11:57:21 PM     0       535      0.00      0.00    4444    360   0.00  a.out<br>
11:57:26 PM     0       535      0.20      0.00    4484    360   0.00  a.out<br>
11:57:31 PM     0       535      0.00      0.00    4484    360   0.00  a.out<br>
11:57:36 PM     0       535      0.20      0.00    4524    360   0.00  a.out<br>
^C<br>
Average:        0       535      0.11      0.00    4435    360   0.00  a.out</p>
<p>你可以看到，VSZ 每 10s 增大 40K，但是增加的那个线程只存在了 1s 就消失了。</p>
<p>至此我们就可以推断出 app_server 的代码哪里有问题了，然后小伙伴去修复该代码 Bug，很快就把该问题给解决了。</p>
<p>当然了，应用程序的内存泄漏问题其实是千奇百怪的，分析方法也不尽相同，我们讲述这个案例的目的是为了告诉你一些通用的分析技巧。我们掌握了这些通用分析技巧，很多时候就可以以不变来应万变了。</p>
<h2 id="课堂总结">课堂总结</h2>
<p>这节课我们讲述了系统性分析 Linux 上内存泄漏问题的分析方法，要点如下：</p>
<ol>
<li>top 工具和 /proc/meminfo 文件是分析 Linux 上内存泄漏问题，甚至是所有内存问题的第一步，我们先找出来哪个进程或者哪一项有异常，然后再针对性地分析；</li>
<li>应用程序的内存泄漏千奇百怪，所以你需要掌握一些通用的分析技巧，掌握了这些技巧很多时候就可以以不变应万变。但是，这些技巧的掌握，是建立在你的基础知识足够扎实的基础上。你需要熟练掌握我们这个系列课程讲述的这些基础知识，熟才能生巧。</li>
</ol>
<h2 id="课后作业">课后作业</h2>
<p>请写一个内存泄漏的程序，然后观察 /proc/[pid]/maps 以及 smaps 的变化（pid 即内存泄漏的程序的 pid）。欢迎你在留言区与我讨论。</p>
<p>感谢你的阅读，如果你认为这节课的内容有收获，也欢迎把它分享给你的朋友，我们下一讲见。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux%E5%86%85%E6%A0%B8%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98%E8%AF%BE/">Linux内核技术实战课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E8%AF%BE/10_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8B%E5%A6%82%E4%BD%95%E6%B1%82%E5%BE%97%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E5%B9%B6%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">10_动态规划（下）：如何求得状态转移方程并进行编程实现？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80%E8%AF%BE/10_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0__%E8%A1%8D%E5%8C%96%E8%87%B3%E7%B9%81%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/">
            <span class="next-text nav-default">10_机器学习__衍化至繁：逻辑回归</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
