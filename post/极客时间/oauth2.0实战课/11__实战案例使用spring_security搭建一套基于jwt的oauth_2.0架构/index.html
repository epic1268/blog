<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>11__实战案例：使用Spring_Security搭建一套基于JWT的OAuth_2.0架构 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我朱晔，是《Java 业务开发常见错误 100 例》专栏课程的作者。
《OAuth 2.0 实战课》上线之后，我也第一时间关注了这门课。在开篇词中，我看到有一些同学留言问道：“如何使用 Spring Security 来实现 OAuth 2.0？”这时，我想到之前自己写过一篇相关的文章，于是就直接在开篇词下留了言。后面我很快收到了不少用户的点赞和肯定，紧接着极客时间编辑也邀请我从自己的角度为专栏写篇加餐。好吧，功不唐捐，于是我就将之前我写的那篇老文章再次迭代、整理为今天的这一讲内容，希望可以帮助你掌握 OAuth 2.0。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/oauth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/11__%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E4%BD%BF%E7%94%A8spring_security%E6%90%AD%E5%BB%BA%E4%B8%80%E5%A5%97%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84oauth_2.0%E6%9E%B6%E6%9E%84/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/oauth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/11__%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E4%BD%BF%E7%94%A8spring_security%E6%90%AD%E5%BB%BA%E4%B8%80%E5%A5%97%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84oauth_2.0%E6%9E%B6%E6%9E%84/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="11__实战案例：使用Spring_Security搭建一套基于JWT的OAuth_2.0架构">
  <meta property="og:description" content="你好，我朱晔，是《Java 业务开发常见错误 100 例》专栏课程的作者。
《OAuth 2.0 实战课》上线之后，我也第一时间关注了这门课。在开篇词中，我看到有一些同学留言问道：“如何使用 Spring Security 来实现 OAuth 2.0？”这时，我想到之前自己写过一篇相关的文章，于是就直接在开篇词下留了言。后面我很快收到了不少用户的点赞和肯定，紧接着极客时间编辑也邀请我从自己的角度为专栏写篇加餐。好吧，功不唐捐，于是我就将之前我写的那篇老文章再次迭代、整理为今天的这一讲内容，希望可以帮助你掌握 OAuth 2.0。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="OAuth2.0实战课">

  <meta itemprop="name" content="11__实战案例：使用Spring_Security搭建一套基于JWT的OAuth_2.0架构">
  <meta itemprop="description" content="你好，我朱晔，是《Java 业务开发常见错误 100 例》专栏课程的作者。
《OAuth 2.0 实战课》上线之后，我也第一时间关注了这门课。在开篇词中，我看到有一些同学留言问道：“如何使用 Spring Security 来实现 OAuth 2.0？”这时，我想到之前自己写过一篇相关的文章，于是就直接在开篇词下留了言。后面我很快收到了不少用户的点赞和肯定，紧接着极客时间编辑也邀请我从自己的角度为专栏写篇加餐。好吧，功不唐捐，于是我就将之前我写的那篇老文章再次迭代、整理为今天的这一讲内容，希望可以帮助你掌握 OAuth 2.0。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="8066">
  <meta itemprop="keywords" content="OAuth2.0实战课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="11__实战案例：使用Spring_Security搭建一套基于JWT的OAuth_2.0架构">
  <meta name="twitter:description" content="你好，我朱晔，是《Java 业务开发常见错误 100 例》专栏课程的作者。
《OAuth 2.0 实战课》上线之后，我也第一时间关注了这门课。在开篇词中，我看到有一些同学留言问道：“如何使用 Spring Security 来实现 OAuth 2.0？”这时，我想到之前自己写过一篇相关的文章，于是就直接在开篇词下留了言。后面我很快收到了不少用户的点赞和肯定，紧接着极客时间编辑也邀请我从自己的角度为专栏写篇加餐。好吧，功不唐捐，于是我就将之前我写的那篇老文章再次迭代、整理为今天的这一讲内容，希望可以帮助你掌握 OAuth 2.0。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">11__实战案例：使用Spring_Security搭建一套基于JWT的OAuth_2.0架构</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 8066 字 </span>
          <span class="more-meta"> 预计阅读 17 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#项目准备工作">项目准备工作</a></li>
        <li><a href="#搭建授权服务器">搭建授权服务器</a></li>
        <li><a href="#搭建受保护资源服务器">搭建受保护资源服务器</a></li>
        <li><a href="#初始化数据配置">初始化数据配置</a></li>
        <li><a href="#演示三种授权许可类型">演示三种授权许可类型</a>
          <ul>
            <li><a href="#资源拥有者凭据许可类型">资源拥有者凭据许可类型</a></li>
            <li><a href="#客户端授权许可类型">客户端授权许可类型</a></li>
            <li><a href="#授权码许可类型">授权码许可类型</a></li>
          </ul>
        </li>
        <li><a href="#演示权限控制">演示权限控制</a></li>
        <li><a href="#搭建客户端程序">搭建客户端程序</a></li>
      </ul>
    </li>
    <li><a href="#level">level:</a></li>
    <li><a href="#root-debug">ROOT: DEBUG</a>
      <ul>
        <li><a href="#演示单点登录">演示单点登录</a></li>
        <li><a href="#演示客户端请求资源服务器资源">演示客户端请求资源服务器资源</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我朱晔，是《Java 业务开发常见错误 100 例》专栏课程的作者。</p>
<p>《OAuth 2.0 实战课》上线之后，我也第一时间关注了这门课。在开篇词中，我看到有一些同学留言问道：“如何使用 Spring Security 来实现 OAuth 2.0？”这时，我想到之前自己写过一篇相关的文章，于是就直接在开篇词下留了言。后面我很快收到了不少用户的点赞和肯定，紧接着极客时间编辑也邀请我从自己的角度为专栏写篇加餐。好吧，功不唐捐，于是我就将之前我写的那篇老文章再次迭代、整理为今天的这一讲内容，希望可以帮助你掌握 OAuth 2.0。</p>
<p>如果你熟悉 Spring Security 的话，肯定知道它因为功能多、组件抽象程度高、配置方式多样，导致了强大且复杂的特性。也因此，Spring Security 的学习成本几乎是 Spring 家族中最高的。但不仅于此，在结合实际的复杂业务场景使用 Spring Security 时，我们还要去理解一些组件的工作原理和流程，不然需要自定义和扩展框架的时候就会手足无措。这就让使用 Spring Security 的门槛更高了。</p>
<p>因此，在决定使用 Spring Security 搭建整套安全体系（授权、认证、权限、审计）之前，我们还需要考虑的是：将来我们的业务会多复杂，徒手写一套安全体系来得划算，还是使用 Spring Security 更好？我相信，这也是王老师给出课程配套代码中，并没有使用 Spring Security 来演示 OAuth 2.0 流程的原因之一。</p>
<p>反过来说，如果你的应用已经使用了 Spring Security 来做鉴权、认证和权限管理的话，那么仍然使用 Spring Security 来实现 OAuth 的成本是很低的。而且，在学习了 OAuth 2.0 的流程打下扎实的基础之后，我们再使用 Spring Security 来配置 OAuth 2.0 就不会那么迷茫了。这也是我在工作中使用 Spring Security 来实现 OAuth 2.0 的直观感受。</p>
<p>所以，我就结合自己的实践和积累，带你使用 Spring Security 来一步一步地搭建一套基于 JWT 的 OAuth 2.0 授权体系。这些内容会涉及 OAuth 2.0 的三角色（客户端、授权服务、受保护资源），以及资源拥有者凭据许可、客户端凭据许可和授权码许可这三种常用的授权许可类型（隐式许可类型，不太安全也不太常用）。同时，我还会演示 OAuth 2.0 的权限控制，以及使用 OAuth 2.0 实现 SSO 单点登录体系。</p>
<p>这样一来，今天这一讲涉及到的流程就会比较多，内容也会很长。不过不用担心，我会手把手带你从零开始，完成整个程序的搭建，并给出所有流程的演示。</p>
<h2 id="项目准备工作">项目准备工作</h2>
<p>实战之前，我们先来搭建项目父依赖和初始化数据库结构，为后面具体的编码做准备。</p>
<p>首先，我们来创建一个父 POM，内含三个模块：</p>
<ol>
<li>springsecurity101-cloud-oauth2-client，用来扮演客户端角色；</li>
<li>springsecurity101-cloud-oauth2-server，用来扮演授权服务器角色；</li>
<li>springsecurity101-cloud-oauth2-userservice，是用户服务，用来扮演资源提供者角色。</li>
</ol>
<p><project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xmlns="http://maven.apache.org/POM/4.0.0"  
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>
<modelVersion>4.0.0</modelVersion></p>
<pre><code>&lt;groupId&gt;me.josephzhu&lt;/groupId&gt;  
&lt;artifactId&gt;springsecurity101&lt;/artifactId&gt;  
&lt;packaging&gt;pom&lt;/packaging&gt;  
&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  

&lt;parent&gt;  
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  
    &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;  
    &lt;relativePath/&gt;  
&lt;/parent&gt;  

&lt;modules&gt;  
    &lt;module&gt;springsecurity101-cloud-oauth2-client&lt;/module&gt;  
    &lt;module&gt;springsecurity101-cloud-oauth2-server&lt;/module&gt;  
    &lt;module&gt;springsecurity101-cloud-oauth2-userservice&lt;/module&gt;  
&lt;/modules&gt;  

&lt;properties&gt;  
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;  
    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;  
    &lt;java.version&gt;1.8&lt;/java.version&gt;  
&lt;/properties&gt;  

&lt;dependencies&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;  
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;  
        &lt;optional&gt;true&lt;/optional&gt;  
    &lt;/dependency&gt;  
&lt;/dependencies&gt;  

&lt;dependencyManagement&gt;  
    &lt;dependencies&gt;  
        &lt;dependency&gt;  
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;  
            &lt;version&gt;Greenwich.SR4&lt;/version&gt;  
            &lt;type&gt;pom&lt;/type&gt;  
            &lt;scope&gt;import&lt;/scope&gt;  
        &lt;/dependency&gt;  
    &lt;/dependencies&gt;  
&lt;/dependencyManagement&gt;  
&lt;build&gt;  
    &lt;plugins&gt;  
        &lt;plugin&gt;  
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;  
        &lt;/plugin&gt;  
    &lt;/plugins&gt;  
&lt;/build&gt;  
</code></pre>
</project>
<p>然后，我们来创建一个 oauth 数据库，初始化将来会用到的 5 个表。</p>
<ol>
<li>authorities 表：记录账号的权限，需要我们在后面配置。</li>
<li>oauth_approvals 表：记录授权批准的状态。</li>
<li>oauth_client_details 表：记录 OAuth 的客户端，需要我们在后面做配置。</li>
<li>oauth_code 表：记录授权码。</li>
<li>users 表：记录账号，需要我们在后面做初始化。</li>
</ol>
<p>SET NAMES utf8mb4;<br>
SET FOREIGN_KEY_CHECKS = 0;</p>
<hr>
<p>&ndash; Table structure for authorities</p>
<hr>
<p>DROP TABLE IF EXISTS <code>authorities</code>;<br>
CREATE TABLE <code>authorities</code> (<br>
<code>username</code> varchar(50) NOT NULL,<br>
<code>authority</code> varchar(50) NOT NULL,<br>
UNIQUE KEY <code>ix_auth_username</code> (<code>username</code>,<code>authority</code>),<br>
CONSTRAINT <code>fk_authorities_users</code> FOREIGN KEY (<code>username</code>) REFERENCES <code>users</code> (<code>username</code>)<br>
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</p>
<hr>
<p>&ndash; Table structure for oauth_approvals</p>
<hr>
<p>DROP TABLE IF EXISTS <code>oauth_approvals</code>;<br>
CREATE TABLE <code>oauth_approvals</code> (<br>
<code>userId</code> varchar(256) DEFAULT NULL,<br>
<code>clientId</code> varchar(256) DEFAULT NULL,<br>
<code>partnerKey</code> varchar(32) DEFAULT NULL,<br>
<code>scope</code> varchar(256) DEFAULT NULL,<br>
<code>status</code> varchar(10) DEFAULT NULL,<br>
<code>expiresAt</code> datetime DEFAULT NULL,<br>
<code>lastModifiedAt</code> datetime DEFAULT NULL<br>
) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p>
<hr>
<p>&ndash; Table structure for oauth_client_details</p>
<hr>
<p>DROP TABLE IF EXISTS <code>oauth_client_details</code>;<br>
CREATE TABLE <code>oauth_client_details</code> (<br>
<code>client_id</code> varchar(255) NOT NULL,<br>
<code>resource_ids</code> varchar(255) DEFAULT NULL,<br>
<code>client_secret</code> varchar(255) DEFAULT NULL,<br>
<code>scope</code> varchar(255) DEFAULT NULL,<br>
<code>authorized_grant_types</code> varchar(255) DEFAULT NULL,<br>
<code>web_server_redirect_uri</code> varchar(255) DEFAULT NULL,<br>
<code>authorities</code> varchar(255) DEFAULT NULL,<br>
<code>access_token_validity</code> int(11) DEFAULT NULL,<br>
<code>refresh_token_validity</code> int(11) DEFAULT NULL,<br>
<code>additional_information</code> varchar(4096) DEFAULT NULL,<br>
<code>autoapprove</code> varchar(255) DEFAULT NULL,<br>
PRIMARY KEY (<code>client_id</code>)<br>
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</p>
<hr>
<p>&ndash; Table structure for oauth_code</p>
<hr>
<p>DROP TABLE IF EXISTS <code>oauth_code</code>;<br>
CREATE TABLE <code>oauth_code</code> (<br>
<code>code</code> varchar(255) DEFAULT NULL,<br>
<code>authentication</code> blob<br>
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</p>
<hr>
<p>&ndash; Table structure for users</p>
<hr>
<p>DROP TABLE IF EXISTS <code>users</code>;<br>
CREATE TABLE <code>users</code> (<br>
<code>username</code> varchar(50) NOT NULL,<br>
<code>password</code> varchar(100) NOT NULL,<br>
<code>enabled</code> tinyint(1) NOT NULL,<br>
PRIMARY KEY (<code>username</code>)<br>
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</p>
<p>SET FOREIGN_KEY_CHECKS = 1;</p>
<p>这 5 个表是 Spring Security OAuth 需要用到的存储表，我们不要去修改既有的表结构。这里可以看到，我们并没有在数据库中创建相应的表，来存放访问令牌和刷新令牌。这是因为，我们之后的实现会使用 JWT 来传输令牌信息，以便进行本地校验，所以并不一定要将其存放到数据库中。基本上所有的这些表都是可以自己扩展的，只需要继承实现 Spring 的一些既有类即可，这里不做展开。</p>
<p>接下来，我们开始搭建授权服务器和受保护资源服务器。</p>
<h2 id="搭建授权服务器">搭建授权服务器</h2>
<p>我们先创建第一个模块，也就是授权服务器。首先创建 POM，配置依赖：</p>
<p><project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xmlns="http://maven.apache.org/POM/4.0.0"  
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>
<parent><br>
<artifactId>springsecurity101</artifactId><br>
<groupId>me.josephzhu</groupId><br>
<version>1.0-SNAPSHOT</version><br>
</parent><br>
<modelVersion>4.0.0</modelVersion></p>
<pre><code>&lt;artifactId&gt;springsecurity101-cloud-oauth2-server&lt;/artifactId&gt;  

&lt;dependencies&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  
        &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;  
    &lt;/dependency&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  
        &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;  
    &lt;/dependency&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;mysql&lt;/groupId&gt;  
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  
    &lt;/dependency&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  
    &lt;/dependency&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  
        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;  
    &lt;/dependency&gt;  
&lt;/dependencies&gt;  
</code></pre>
</project>
<p>这里，我们使用了 Spring Cloud 的 spring-cloud-starter-oauth2 组件，而不是直接使用的 Spring Security，因为前者做了一些自动化配置的工作，使用起来会更方便。</p>
<p>此外，我们还在 POM 中加入了数据访问、Web 等依赖，因为我们的受保护资源服务器需要使用数据库来保存客户端的信息、用户信息等数据，同时也会引入 thymeleaf 模板引擎依赖，来稍稍美化一下登录页面。</p>
<p>然后创建一个配置文件 application.yml 实现程序配置：</p>
<p>server:<br>
port: 8080</p>
<p>spring:<br>
application:<br>
name: oauth2-server<br>
datasource:<br>
url: jdbc:mysql://localhost:6657/oauth?useSSL=false<br>
username: root<br>
password: kIo9u7Oi0eg<br>
driver-class-name: com.mysql.jdbc.Driver</p>
<p>可以看到，我们配置了 oauth 数据库的连接字符串，定义了授权服务器的监听端口是 8080。</p>
<p>最后，使用 keytool 工具生成密钥对，把密钥文件 jks 保存到资源目录下，并要导出一个公钥留作以后使用。</p>
<p>以上完成了项目框架搭建工作，接下来，我们正式开始编码。</p>
<p>第一步，创建一个最核心的类用于配置授权服务器。我把每段代码的作用放在了注释里，你可以直接看下。</p>
<p>@Configuration<br>
@EnableAuthorizationServer //开启授权服务器<br>
public class OAuth2ServerConfiguration extends AuthorizationServerConfigurerAdapter {<br>
@Autowired<br>
private DataSource dataSource;<br>
@Autowired<br>
private AuthenticationManager authenticationManager;</p>
<pre><code>/**  
 * 我们配置了使用数据库来维护客户端信息。虽然在各种 Demo 中我们经常看到的是在内存中维护客户端信息，通过配置直接写死在这里。  
 * 但是，对于实际的应用我们一般都会用数据库来维护这个信息，甚至还会建立一套工作流来允许客户端自己申请 ClientID，实现 OAuth 客户端接入的审批。  
 * @param clients  
 * @throws Exception  
 */  
@Override  
public void configure(ClientDetailsServiceConfigurer clients) throws Exception {  
    clients.jdbc(dataSource);  
}  

/**  
 * 这里干了两件事儿。首先，打开了验证 Token 的访问权限（以便之后我们演示）。  
 * 然后，允许 ClientSecret 明文方式保存，并且可以通过表单提交（而不仅仅是 Basic Auth 方式提交），之后会演示到这个。  
 * @param security  
 * @throws Exception  
 */  
@Override  
public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {  
    security.checkTokenAccess(&quot;permitAll()&quot;)  
            .allowFormAuthenticationForClients().passwordEncoder(NoOpPasswordEncoder.getInstance());  
}  

/**  
 * 干了以下 4 件事儿：  
 * 1. 配置我们的令牌存放方式为 JWT 方式，而不是内存、数据库或 Redis 方式。  
 * JWT 是 Json Web Token 的缩写，也就是使用 JSON 数据格式包装的令牌，由。号把整个 JWT 分隔为头、数据体、签名三部分。  
 * JWT 保存 Token 虽然易于使用但是不是那么安全，一般用于内部，且需要走 HTTPS 并配置比较短的失效时间。  
 * 2. 配置 JWT Token 的非对称加密来进行签名  
 * 3. 配置一个自定义的 Token 增强器，把更多信息放入 Token 中  
 * 4. 配置使用 JDBC 数据库方式来保存用户的授权批准记录  
 * @param endpoints  
 * @throws Exception  
 */  
@Override  
public void configure(AuthorizationServerEndpointsConfigurer endpoints) {  
    TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();  
    tokenEnhancerChain.setTokenEnhancers(  
            Arrays.asList(tokenEnhancer(), jwtTokenEnhancer()));  

    endpoints.approvalStore(approvalStore())  
            .authorizationCodeServices(authorizationCodeServices())  
            .tokenStore(tokenStore())  
            .tokenEnhancer(tokenEnhancerChain)  
            .authenticationManager(authenticationManager);  
}  

/**  
 * 使用 JDBC 数据库方式来保存授权码  
 * @return  
 */  
@Bean  
public AuthorizationCodeServices authorizationCodeServices() {  
    return new JdbcAuthorizationCodeServices(dataSource);  
}  

/**  
 * 使用 JWT 存储  
 * @return  
 */  
@Bean  
public TokenStore tokenStore() {  
    return new JwtTokenStore(jwtTokenEnhancer());  
}  

/**  
 * 使用 JDBC 数据库方式来保存用户的授权批准记录  
 * @return  
 */  
@Bean  
public JdbcApprovalStore approvalStore() {  
    return new JdbcApprovalStore(dataSource);  
}  

/**  
 * 自定义的 Token 增强器，把更多信息放入 Token 中  
 * @return  
 */  
@Bean  
public TokenEnhancer tokenEnhancer() {  
    return new CustomTokenEnhancer();  
}  

/**  
 * 配置 JWT 使用非对称加密方式来验证  
 * @return  
 */  
@Bean  
protected JwtAccessTokenConverter jwtTokenEnhancer() {  
    KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(new ClassPathResource(&quot;jwt.jks&quot;), &quot;mySecretKey&quot;.toCharArray());  
    JwtAccessTokenConverter converter = new JwtAccessTokenConverter();  
    converter.setKeyPair(keyStoreKeyFactory.getKeyPair(&quot;jwt&quot;));  
    return converter;  
}  

/**  
 * 配置登录页面的视图信息（其实可以独立一个配置类，这样会更规范）  
 */  
@Configuration  
static class MvcConfig implements WebMvcConfigurer {  
    @Override  
    public void addViewControllers(ViewControllerRegistry registry) {  
        registry.addViewController(&quot;login&quot;).setViewName(&quot;login&quot;);  
    }  
}  
</code></pre>
<p>}</p>
<p>第二步，还记得吗，刚才在第一步的代码中我们还用到了一个自定义的 Token 增强器，把用户信息嵌入到 JWT Token 中去（如果使用的是客户端凭据许可类型，这段代码无效，因为和用户没关系）。</p>
<p>这是一个常见需求。因为，默认情况下 Token 中只会有用户名这样的基本信息，我们往往需要把关于用户的更多信息返回给客户端（在实际应用中，你可能会从数据库或外部服务查询更多的用户信息加入到 JWT Token 中去）。这个时候，我们就可以自定义增强器来丰富 Token 的内容：</p>
<p>public class CustomTokenEnhancer implements TokenEnhancer {</p>
<pre><code>@Override  
public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {  
    Authentication userAuthentication = authentication.getUserAuthentication();  
    if (userAuthentication != null) {  
        Object principal = authentication.getUserAuthentication().getPrincipal();  
        //把用户标识嵌入 JWT Token 中去 (Key 是 userDetails)  
        Map&lt;String, Object&gt; additionalInfo = new HashMap&lt;&gt;();  
        additionalInfo.put(&quot;userDetails&quot;, principal);  
        ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInfo);  
    }  
    return accessToken;  
}  
</code></pre>
<p>}</p>
<p>第三步，实现安全方面的配置。你可以直接看下代码注释，来了解关键代码的作用。</p>
<p>@Configuration<br>
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {<br>
@Autowired<br>
private DataSource dataSource;</p>
<pre><code>@Override  
@Bean  
public AuthenticationManager authenticationManagerBean() throws Exception {  
    return super.authenticationManagerBean();  
}  

/**  
 * 配置用户账户的认证方式。显然，我们把用户存在了数据库中希望配置 JDBC 的方式。  
 * 此外，我们还配置了使用 BCryptPasswordEncoder 哈希来保存用户的密码（生产环境中，用户密码肯定不能是明文保存的）  
 * @param auth  
 * @throws Exception  
 */  
@Override  
protected void configure(AuthenticationManagerBuilder auth) throws Exception {  
    auth.jdbcAuthentication()  
            .dataSource(dataSource)  
            .passwordEncoder(new BCryptPasswordEncoder());  
}  

/**  
 * 开放/login 和/oauth/authorize 两个路径的匿名访问。前者用于登录，后者用于换授权码，这两个端点访问的时机都在登录之前。  
 * 设置/login 使用表单验证进行登录。  
 * @param http  
 * @throws Exception  
 */  
@Override  
protected void configure(HttpSecurity http) throws Exception {  
    http.authorizeRequests()  
            .antMatchers(&quot;/login&quot;, &quot;/oauth/authorize&quot;)  
            .permitAll()  
            .anyRequest().authenticated()  
            .and()  
            .formLogin().loginPage(&quot;/login&quot;);  
}  
</code></pre>
<p>}</p>
<p>第四步，在资源目录下创建一个 templates 文件夹，然后创建一个 login.html 登录页：</p>
<body class="uk-height-1-1">  
<div class="uk-vertical-align uk-text-center uk-height-1-1">  
    <div class="uk-vertical-align-middle" style="width: 250px;">  
        <h1>Login Form</h1>  
<pre><code>    &lt;p class=&quot;uk-text-danger&quot; th:if=&quot;${param.error}&quot;&gt;  
        用户名或密码错误...  
    &lt;/p&gt;  

    &lt;form class=&quot;uk-panel uk-panel-box uk-form&quot; method=&quot;post&quot; th:action=&quot;@{/login}&quot;&gt;  
        &lt;div class=&quot;uk-form-row&quot;&gt;  
            &lt;input class=&quot;uk-width-1-1 uk-form-large&quot; type=&quot;text&quot; placeholder=&quot;Username&quot; name=&quot;username&quot;  
                   value=&quot;reader&quot;/&gt;  
        &lt;/div&gt;  
        &lt;div class=&quot;uk-form-row&quot;&gt;  
            &lt;input class=&quot;uk-width-1-1 uk-form-large&quot; type=&quot;password&quot; placeholder=&quot;Password&quot; name=&quot;password&quot;  
                   value=&quot;reader&quot;/&gt;  
        &lt;/div&gt;  
        &lt;div class=&quot;uk-form-row&quot;&gt;  
            &lt;button class=&quot;uk-width-1-1 uk-button uk-button-primary uk-button-large&quot;&gt;Login&lt;/button&gt;  
        &lt;/div&gt;  
    &lt;/form&gt;  

&lt;/div&gt;  
</code></pre>
</div>  
</body>
<p>至此，授权服务器的编码工作就完成了。</p>
<h2 id="搭建受保护资源服务器">搭建受保护资源服务器</h2>
<p>接下来，我们搭建一个用户服务模拟资源提供者（受保护资源服务器）。我们先看看项目初始化工作。</p>
<p>这次创建的 POM 没有什么特殊，依赖了 spring-cloud-starter-oauth2：</p>
<p><project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xmlns="http://maven.apache.org/POM/4.0.0"  
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>
<parent><br>
<artifactId>springsecurity101</artifactId><br>
<groupId>me.josephzhu</groupId><br>
<version>1.0-SNAPSHOT</version><br>
</parent><br>
<modelVersion>4.0.0</modelVersion></p>
<pre><code>&lt;artifactId&gt;springsecurity101-cloud-oauth2-userservice&lt;/artifactId&gt;  

&lt;dependencies&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  
        &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;  
    &lt;/dependency&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  
    &lt;/dependency&gt;  
&lt;/dependencies&gt;  
</code></pre>
</project>
<p>配置文件非常简单，只是声明了资源服务端口为 8081：</p>
<p>server:<br>
port: 8081</p>
<p>同时，还要记得把我们之前在项目准备工作时生成的密钥对的公钥命名为 public.cert，并放到资源文件下。这样，资源服务器可以本地校验 JWT 的合法性。内容大概是这样的：</p>
<p>&mdash;&ndash;BEGIN PUBLIC KEY&mdash;&ndash;<br>
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwR84LFHwnK5GXErnwkmD<br>
mPOJl4CSTtYXCqmCtlbF+5qVOosu0YsM2DsrC9O2gun6wVFKkWYiMoBSjsNMSI3Z<br>
w5JYgh+ldHvA+MIex2QXfOZx920M1fPUiuUPgmnTFS+Z3lmK3/T6jJnmciUPY1pe<br>
h4MXL6YzeI0q4W9xNBBeKT6FDGpduc0FC3OlXHfLbVOThKmAUpAWFDwf9/uUA//l<br>
3PLchmV6VwTcUaaHp5W8Af/GU4lPGZbTAqOxzB9ukisPFuO1DikacPhrOQgdxtqk<br>
LciRTa884uQnkFwSguOEUYf3ni8GNRJauIuW0rVXhMOs78pKvCKmo53M0tqeC6ul<br>
+QIDAQAB<br>
&mdash;&ndash;END PUBLIC KEY&mdash;&ndash;</p>
<p>好了，让我们正式开始编码吧。</p>
<p>第一步，创建一个可以匿名访问的接口 GET /hello，用来测试无需登录就可以访问的服务端资源：</p>
<p>@RestController<br>
public class HelloController {<br>
@GetMapping(&ldquo;hello&rdquo;)<br>
public String hello() {<br>
return &ldquo;Hello&rdquo;;<br>
}<br>
}</p>
<p>第二步，创建三个需要登录 + 授权才能访问到的接口。我们通过 @PreAuthorize 在方法执行前进行权限控制：</p>
<ol>
<li>GET /user/name 接口，读权限或写权限可访问，返回登录用户名；</li>
<li>GET /user 接口，读权限或写权限可访问，返回登录用户信息；</li>
<li>POST /user 接口，只有写权限可以访问，返回访问令牌中的额外信息（也就是自定义的 Token 增强器 CustomTokenEnhancer 加入到访问令牌中的额外信息，Key 是 userDetails），这里也演示了使用 TokenStore 来解析 Token 的方式。</li>
</ol>
<p>@RestController<br>
@RequestMapping(&ldquo;user&rdquo;)<br>
public class UserController {</p>
<pre><code>@Autowired  
private TokenStore tokenStore;  

/***  
 * 读权限或写权限可访问，返回登录用户名  
 * @param authentication  
 * @return  
 */  
@PreAuthorize(&quot;hasAuthority('READ') or hasAuthority('WRITE')&quot;)  
@GetMapping(&quot;name&quot;)  
public String name(OAuth2Authentication authentication) {  
    return authentication.getName();  
}  

/**  
 * 读权限或写权限可访问，返回登录用户信息  
 * @param authentication  
 * @return  
 */  
@PreAuthorize(&quot;hasAuthority('READ') or hasAuthority('WRITE')&quot;)  
@GetMapping  
public OAuth2Authentication read(OAuth2Authentication authentication) {  
    return authentication;  
}  

/**  
 * 只有写权限可以访问，返回访问令牌中的额外信息  
 * @param authentication  
 * @return  
 */  
@PreAuthorize(&quot;hasAuthority('WRITE')&quot;)  
@PostMapping  
public Object write(OAuth2Authentication authentication) {  
    OAuth2AuthenticationDetails details = (OAuth2AuthenticationDetails) authentication.getDetails();  
    OAuth2AccessToken accessToken = tokenStore.readAccessToken(details.getTokenValue());  
    return accessToken.getAdditionalInformation().getOrDefault(&quot;userDetails&quot;, null);  
}  
</code></pre>
<p>}</p>
<p>第三步，创建核心的资源服务器配置类。这里我们需要注意下面两点：</p>
<ol>
<li>我们硬编码了资源服务器的 ID 为 userservice；</li>
<li>现在我们使用的是不落数据库的 JWT 方式 + 非对称加密，需要通过本地公钥进行验证，因此在这里我们配置了公钥的路径。</li>
</ol>
<p>@Configuration<br>
@EnableResourceServer //启用资源服务器<br>
@EnableGlobalMethodSecurity(prePostEnabled = true) //启用方法注解方式来进行权限控制<br>
public class ResourceServerConfiguration extends ResourceServerConfigurerAdapter {</p>
<pre><code>/**  
 * 声明了资源服务器的 ID 是 userservice，声明了资源服务器的 TokenStore 是 JWT  
 * @param resources  
 * @throws Exception  
 */  
@Override  
public void configure(ResourceServerSecurityConfigurer resources) throws Exception {  
    resources.resourceId(&quot;userservice&quot;).tokenStore(tokenStore());  
}  

/**  
 * 配置 TokenStore  
 * @return  
 */  
@Bean  
public TokenStore tokenStore() {  
    return new JwtTokenStore(jwtAccessTokenConverter());  
}  

/**  
 * 配置公钥  
 * @return  
 */  
@Bean  
protected JwtAccessTokenConverter jwtAccessTokenConverter() {  
    JwtAccessTokenConverter converter = new JwtAccessTokenConverter();  
    Resource resource = new ClassPathResource(&quot;public.cert&quot;);  
    String publicKey = null;  
    try {  
        publicKey = new String(FileCopyUtils.copyToByteArray(resource.getInputStream()));  
    } catch (IOException e) {  
        e.printStackTrace();  
    }  
    converter.setVerifierKey(publicKey);  
    return converter;  
}  

/**  
 * 配置了除了/user 路径之外的请求可以匿名访问  
 * @param http  
 * @throws Exception  
 */  
@Override  
public void configure(HttpSecurity http) throws Exception {  
    http.authorizeRequests()  
            .antMatchers(&quot;/user/**&quot;).authenticated()  
            .anyRequest().permitAll();  
}  
</code></pre>
<p>}</p>
<p>到这里，我们来想一下，如果授权服务器产生 Token 的话，受保护资源服务器必须要有一种办法来验证 Token，那如果这里的 Token 不是 JWT 的方式，我们可以怎么办呢？</p>
<p>我来说下我的方法吧：</p>
<ol>
<li>首先，Token 可以保存在数据库或 Redis 中，资源服务器和授权服务器共享底层的 TokenStore 来验证；</li>
<li>然后，资源服务器可以使用 RemoteTokenServices，来从授权服务器的 /oauth/check_token 端点进行 Token 校验。</li>
</ol>
<p>到这里，资源服务器就配置完成了，我们还在资源服务器中分别创建了两个控制器 HelloController 和 UserController，用于分别测试可以匿名访问以及受到权限保护的资源。</p>
<h2 id="初始化数据配置">初始化数据配置</h2>
<p>在实现了授权服务器和受保护资源服务器代码后，我们再来初始化 oauth 数据库的数据就非常容易理解了。总结起来，我们需要配置用户、权限和客户端三部分。</p>
<ol>
<li>配置两个用户。其中，读用户 reader 具有读权限，密码为 reader；写用户 writer 具有读写权限，密码为 writer。还记得吗，密码我们使用的是 BCryptPasswordEncoder 加密（准确说是哈希）？</li>
</ol>
<p>INSERT INTO <code>users</code> VALUES (&lsquo;reader&rsquo;, &lsquo;$2a$04$C6pPJvC1v6.enW6ZZxX.luTdpSI/1gcgTVN7LhvQV6l/AfmzNU/3i&rsquo;, 1);<br>
INSERT INTO <code>users</code> VALUES (&lsquo;writer&rsquo;, &lsquo;$2a$04$M9t2oVs3/VIreBMocOujqOaB/oziWL0SnlWdt8hV4YnlhQrORA0fS&rsquo;, 1);</p>
<ol>
<li>配置两个权限，也就是配置 reader 用户具有读权限，writer 用户具有写权限：</li>
</ol>
<p>INSERT INTO <code>authorities</code> VALUES (&lsquo;reader&rsquo;, &lsquo;READ&rsquo;);<br>
INSERT INTO <code>authorities</code> VALUES (&lsquo;writer&rsquo;, &lsquo;READ,WRITE&rsquo;);</p>
<ol>
<li>配置三个客户端，其中客户端 userservice1 使用资源拥有者凭据许可类型，客户端 userservice2 使用客户端凭据许可类型，客户端 userservice3 使用授权码许可类型。</li>
</ol>
<p>INSERT INTO <code>oauth_client_details</code> VALUES (&lsquo;userservice1&rsquo;, &lsquo;userservice&rsquo;, &lsquo;1234&rsquo;, &lsquo;FOO&rsquo;, &lsquo;password,refresh_token&rsquo;, &lsquo;&rsquo;, &lsquo;READ,WRITE&rsquo;, 7200, NULL, NULL, &rsquo;true&rsquo;);<br>
INSERT INTO <code>oauth_client_details</code> VALUES (&lsquo;userservice2&rsquo;, &lsquo;userservice&rsquo;, &lsquo;1234&rsquo;, &lsquo;FOO&rsquo;, &lsquo;client_credentials,refresh_token&rsquo;, &lsquo;&rsquo;, &lsquo;READ,WRITE&rsquo;, 7200, NULL, NULL, &rsquo;true&rsquo;);<br>
INSERT INTO <code>oauth_client_details</code> VALUES (&lsquo;userservice3&rsquo;, &lsquo;userservice&rsquo;, &lsquo;1234&rsquo;, &lsquo;FOO&rsquo;, &lsquo;authorization_code,refresh_token&rsquo;, &lsquo;<a href="https://baidu.com">https://baidu.com</a>,http://localhost:8082/ui/login,http://localhost:8083/ui/login,http://localhost:8082/ui/remoteCall&rsquo;, &lsquo;READ,WRITE&rsquo;, 7200, NULL, NULL, &lsquo;false&rsquo;);</p>
<p>值得说明的是：</p>
<ol>
<li>三个客户端账号能使用的资源 ID 都是 userservice，对应我们受保护资源服务器刚才配置的资源 ID，也就是 userservice，这两者需要一致。</li>
<li>三个客户端账号的密码都是 1234。</li>
<li>三个客户端账号的授权范围都是 FOO（并不是关键信息），它们可以拿到的权限是读写。不过，对于和用户相关的授权许可类型（比如资源拥有者凭据许可、授权码许可），最终拿到的权限还取决于客户端权限和用户权限的交集。</li>
<li>通过 grant_types 字段配置支持不同的授权许可类型。这里为了便于测试观察，我们给三个客户端账号各自配置了一种授权许可类型；在实际业务场景中，你完全可以为同一个客户端配置支持 OAuth 2.0 的四种授权许可类型。</li>
<li>userservice1 和 userservice2 我们配置了用户自动批准授权（不会弹出一个页面要求用户进行授权）。</li>
</ol>
<h2 id="演示三种授权许可类型">演示三种授权许可类型</h2>
<p>到这里，授权服务器和受保护资源服务器程序都搭建完成了，数据库也配置了用于测试的用户、权限和客户端。接下来，我们就使用 Postman 来手工测试一下 OAuth 2.0 的授权码许可、资源拥有者凭据许可、客户端凭据许可这三种授权许可类型吧。</p>
<h3 id="资源拥有者凭据许可类型">资源拥有者凭据许可类型</h3>
<p>首先，我们测试的是资源拥有者凭据许可，POST 请求地址是：</p>
<p>http://localhost:8080/oauth/token?grant_type=password&amp;client_id=userservice1&amp;client_secret=1234&amp;username=writer&amp;password=writer</p>
<p>得到如下图所示结果：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/c464fed8294ae77b40853dc1b1aeb5ca.png" alt=""></p>
<p>再使用JWT 解析工具看下请求 Token 中的信息：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/62b0b153c8dadc17cb872409c78b4cd0.png" alt=""></p>
<p>可以看到，Token 中果然包含了 Token 增强器加入的 userDetails 自定义信息。如果我们把公钥粘贴到页面的话，可以看到这个 JWT 校验成功了：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/3074623c88375924085c3307a2abfbbc.png" alt=""></p>
<p>除了本地校验外，还可以访问授权服务器来校验 JWT：</p>
<p>http://localhost:8080/oauth/check_token?client_id=userservice1&amp;client_secret=1234&amp;token=&hellip;</p>
<p>得到如下结果：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/176fd6031a6185641fa6d6af31b6a4c0.png" alt=""></p>
<h3 id="客户端授权许可类型">客户端授权许可类型</h3>
<p>我们再来测试下客户端授权许可类型。POST 请求地址：</p>
<p>http://localhost:8080/oauth/token?grant_type=client_credentials&amp;client_id=userservice2&amp;client_secret=1234</p>
<p>如下图所示，可以直接拿到 Token：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/ce9f95779131b38c2eb0bdb91196fe8b.png" alt=""></p>
<p>这里需要注意的是，并没有提供刷新令牌。这是因为，刷新令牌用于避免访问令牌失效后需要用户再次登录的问题，而客户端授权许可类型没有用户的概念，因此没有刷新令牌，也无法注入额外的 userDetails 信息。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/d4c68440cd55741d9dbc40c3123d5ba9.png" alt=""></p>
<p>也可以试一下，如果我们的授权服务器没有开启 allowFormAuthenticationForClients 参数（允许表单提交认证）的话，客户端的凭证需要通过 Basic Auth 传过去而不是通过 Post：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/b655bce82cede25c446735a82d66372c.png" alt=""></p>
<h3 id="授权码许可类型">授权码许可类型</h3>
<p>最后，我们来测试下比较复杂的授权码许可。</p>
<p><strong>第一步</strong>，打开浏览器访问地址：</p>
<p>http://localhost:8080/oauth/authorize?response_type=code&amp;client_id=userservice3&amp;redirect_uri=https://baidu.com</p>
<p>注意，客户端跳转地址需要和数据库中配置的一致（百度的 URL <a href="https://baidu.com">https://baidu.com</a></p>
<p>我们之前已经在数据库中有配置了）。访问后页面会直接跳转到登录界面，我们使用用户名“reader”、密码“reader”来登录：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/539b9f65aee52672695a75bb46a59ad5.png" alt=""></p>
<p>由于我们在数据库中设置的是禁用自动批准授权的模式，所以登录后来到了批准界面：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/c1581050e1a83b7105ba124bd963c1d1.png" alt=""></p>
<p>点击同意后可以看到，数据库中也会产生授权通过记录：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/d1f3332cade2c8221a741614a8468fb8.png" alt=""></p>
<p>**第二步，**我们可以看到浏览器转到了百度并且提供给了我们授权码：</p>
<p><a href="https://www.baidu.com/?code=XKkHGY">https://www.baidu.com/?code=XKkHGY</a></p>
<p>数据库中也记录了授权码：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/67e92b6c5de07c5556625d68328fe421.png" alt=""></p>
<p>然后 POST 访问下面的地址（code 参数替换为刚才获得的授权码）：</p>
<p>http://localhost:8080/oauth/token?grant_type=authorization_code&amp;client_id=userservice3&amp;client_secret=1234&amp;code=XKkHGY&amp;redirect_uri=https://baidu.com</p>
<p>可以通过授权码换取访问令牌：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/6f1c72fca896da19d7767645023eb73b.png" alt=""></p>
<p>虽然 userservice3 客户端可以有读权限和写权限，但是因为我们登录的用户 reader 只有读权限，所以最后拿到也只有读权限。</p>
<h2 id="演示权限控制">演示权限控制</h2>
<p>现在我们来测试一下之前定义的两个账号，也就是读账号和写账号，看看它们的权限控制是否有效。</p>
<p>首先，测试一下我们的安全配置，访问 /hello 端点不需要认证可以匿名访问：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/64a63a32b2cfc980a79864e0444e3fb8.png" alt=""></p>
<p>访问 /user 需要身份认证：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/5e93cd1490e64fc787a111d1041ec99e.png" alt=""></p>
<p>不管以哪种模式拿到访问令牌，我们用具有读权限的访问令牌访问资源服务器的如下地址</p>
<p>（请求头加入 Authorization: Bearer XXXXXXXXXX，其中 XXXXXXXXXX 代表访问令牌）：</p>
<p>http://localhost:8081/user/</p>
<p>可以得到如下结果：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/28881cf6cd5371ea514af08b335c1be7.png" alt=""></p>
<p>以 POST 方式访问 http://localhost:8081/user/，显然是失败的：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/9a18b3ac8e3f7dd2156654ac34c9157d.png" alt=""></p>
<p>因为这个接口要求有写权限：</p>
<p>@PreAuthorize(&ldquo;hasAuthority(&lsquo;WRITE&rsquo;)&rdquo;)<br>
@PostMapping<br>
public Object write(OAuth2Authentication authentication) {</p>
<p>我们换一个具有读写权限的访问令牌来试试：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/c240616905db2056c00c4ae569d1f8a5.png" alt=""></p>
<p>可以发现，果然访问成功了。这里输出的内容是 Token 中的 userDetails 额外信息，说明资源服务器的权限控制有效。</p>
<h2 id="搭建客户端程序">搭建客户端程序</h2>
<p>在上面的演示中，我们使用的是 Postman，也就是手动 HTTP 请求的方式来申请和使用 Token。最后，我们来搭建一个 OAuth 客户端程序自动实现这个过程。</p>
<p><project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xmlns="http://maven.apache.org/POM/4.0.0"  
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"></p>
<pre><code>&lt;parent&gt;  
    &lt;artifactId&gt;springsecurity101&lt;/artifactId&gt;  
    &lt;groupId&gt;me.josephzhu&lt;/groupId&gt;  
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  
&lt;/parent&gt;  

&lt;artifactId&gt;springsecurity101-cloud-oauth2-client&lt;/artifactId&gt;  
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  

&lt;dependencies&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  
        &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;  
    &lt;/dependency&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  
    &lt;/dependency&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  
        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;  
    &lt;/dependency&gt;  

&lt;/dependencies&gt;  
</code></pre>
</project>
<p>配置文件如下：</p>
<p>server:<br>
port: 8083<br>
servlet:<br>
context-path: /ui<br>
security:<br>
oauth2:<br>
client:<br>
clientId: userservice3<br>
clientSecret: 1234<br>
accessTokenUri: http://localhost:8080/oauth/token<br>
userAuthorizationUri: http://localhost:8080/oauth/authorize<br>
scope: FOO<br>
resource:<br>
jwt:<br>
key-value: |<br>
&mdash;&ndash;BEGIN PUBLIC KEY&mdash;&ndash;<br>
***<br>
&mdash;&ndash;END PUBLIC KEY&mdash;&ndash;<br>
spring:<br>
thymeleaf:<br>
cache: false</p>
<p>#logging:</p>
<h1 id="level">level:</h1>
<h1 id="root-debug">ROOT: DEBUG</h1>
<p>客户端项目端口 8082，几个需要说明的地方：</p>
<ol>
<li>本地测试的时候有一个坑，也就是我们需要配置 context-path，否则可能会出现客户端和授权服务器服务端 Cookie 干扰，导致 CSRF 防御触发的问题。这个问题出现后程序没有任何错误日志输出，只有开启 DEBUG 模式后才能看到 DEBUG 日志里有提示，因此这个问题非常难以排查。说实话，我也不知道 Spring 为什么不把这个信息作为 WARN 级别的日志输出。</li>
<li>作为 OAuth 客户端，我们需要配置 OAuth 服务端获取 Token 的地址、授权（获取授权码）的地址，需要配置客户端的 ID、密码和授权范围。</li>
<li>因为使用的是 JWT Token，我们需要配置公钥（当然，如果不在这里直接配置公钥的话，也可以配置从授权服务器服务端获取公钥）。</li>
</ol>
<p>接下来，我们可以开始编码了。</p>
<p>第一步，实现 MVC 的配置：</p>
<p>@Configuration<br>
@EnableWebMvc<br>
public class WebMvcConfig implements WebMvcConfigurer {</p>
<pre><code>/**  
 * 配置 RequestContextListener 用于启用 session scope 的 Bean  
 * @return  
 */  
@Bean  
public RequestContextListener requestContextListener() {  
    return new RequestContextListener();  
}  

/**  
 * 配置 index 路径的首页 Controller  
 * @param registry  
 */  
@Override  
public void addViewControllers(ViewControllerRegistry registry) {  
    registry.addViewController(&quot;/&quot;)  
            .setViewName(&quot;forward:/index&quot;);  
    registry.addViewController(&quot;/index&quot;);  
}  
</code></pre>
<p>}</p>
<p>这里做了两件事情：</p>
<ol>
<li>配置 RequestContextListener，用于启用 session scope 的 Bean；</li>
<li>配置了 index 路径的首页 Controller。</li>
</ol>
<p>第二步，实现安全方面的配置：</p>
<p>@Configuration<br>
@Order(200)<br>
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {<br>
/**<br>
* /路径和/login 路径允许访问，其它路径需要身份认证后才能访问<br>
* @param http<br>
* @throws Exception<br>
<em>/<br>
@Override<br>
protected void configure(HttpSecurity http) throws Exception {<br>
http<br>
.authorizeRequests()<br>
.antMatchers(&quot;/&quot;, &ldquo;/login</em>*&rdquo;)<br>
.permitAll()<br>
.anyRequest()<br>
.authenticated();<br>
}<br>
}</p>
<p>这里我们实现的是 / 路径和 /login 路径允许访问，其它路径需要身份认证后才能访问。</p>
<p>第三步，我们来创建一个控制器：</p>
<p>@RestController<br>
public class DemoController {<br>
@Autowired<br>
OAuth2RestTemplate restTemplate;<br>
//演示登录后才能访问的安全页面<br>
@GetMapping(&quot;/securedPage&quot;)<br>
public ModelAndView securedPage(OAuth2Authentication authentication) {<br>
return new ModelAndView(&ldquo;securedPage&rdquo;).addObject(&ldquo;authentication&rdquo;, authentication);<br>
}<br>
//演示通过 OAuth2RestTemplate 调用受保护资源<br>
@GetMapping(&quot;/remoteCall&quot;)<br>
public String remoteCall() {<br>
ResponseEntity<String> responseEntity = restTemplate.getForEntity(&ldquo;http://localhost:8081/user/name&rdquo;, String.class);<br>
return responseEntity.getBody();<br>
}<br>
}</p>
<p>这里我们实现了两个功能：</p>
<ol>
<li>securedPage 页面，实现的功能是，把用户信息作为模型传入了视图，这样打开页面后就能显示用户名和权限。</li>
<li>remoteCall 接口，实现的功能是，通过引入 OAuth2RestTemplate，在登录后就可以使用凭据直接从受保护资源服务器拿资源，不需要繁琐地实现获得访问令牌、在请求头里加入访问令牌的过程。</li>
</ol>
<p>第四步，配置一下刚才用到的 OAuth2RestTemplate Bean，并启用 OAuth2Sso 功能：</p>
<p>@Configuration<br>
@EnableOAuth2Sso //这个注解包含了@EnableOAuth2Client<br>
public class OAuthClientConfig {<br>
/**<br>
* 定义了 OAuth2RestTemplate，网上一些比较老的资料给出的是手动读取配置文件来实现，最新版本已经可以自动注入 OAuth2ProtectedResourceDetails<br>
* @param oAuth2ClientContext<br>
* @param details<br>
* @return<br>
*/<br>
@Bean<br>
public OAuth2RestTemplate oauth2RestTemplate(OAuth2ClientContext oAuth2ClientContext,<br>
OAuth2ProtectedResourceDetails details) {<br>
return new OAuth2RestTemplate(details, oAuth2ClientContext);<br>
}<br>
}</p>
<p>第五步，实现首页：</p>
<body>  
<div class="container">  
    <div class="col-sm-12">  
        <h1>Spring Security SSO Client</h1>  
        <a class="btn btn-primary" href="securedPage">Login</a>  
    </div>  
</div>  
</body>
<p>以及登录后才能访问的 securedPage 页面：</p>
<body>  
<div class="container">  
    <div class="col-sm-12">  
        <h1>Secured Page</h1>  
        Welcome, <span th:text="${authentication.name}">Name</span>  
        <br/>  
        Your authorities are <span th:text="${authentication.authorities}">authorities</span>  
    </div>  
</div>  
</body>
<h2 id="演示单点登录">演示单点登录</h2>
<p>好，客户端程序搭建好之后，我们先来测试一下单点登录的功能。启动客户端项目，打开浏览器访问：</p>
<p>http://localhost:8082/ui/securedPage</p>
<p>可以看到，页面自动转到了授权服务器（8080 端口）的登录页面：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/00e5ca3792a65ff8b5f17aa9148bf549.png" alt=""></p>
<p>登录后显示了当前用户名和权限：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/1e97d1cd34139615fdf92aeaed3194e7.png" alt=""></p>
<p>我们再启动另一个客户端网站，端口改为 8083，然后访问同样的地址：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/8ff71377153e47ad6791713f883b1af8.png" alt=""></p>
<p>可以看到直接是登录状态，单点登录测试成功。是不是很方便？其实，为了达成单点登录的效果，程序在背后自动实现了多次 302 重定向，整个流程为：</p>
<p>http://localhost:8083/ui/securedPage -&gt;<br>
http://localhost:8083/ui/login -&gt;<br>
http://localhost:8080/oauth/authorize?client_id=userservice3&amp;redirect_uri=http://localhost:8083/ui/login&amp;response_type=code&amp;scope=FOO&amp;state=Sobjqe -&gt;<br>
http://localhost:8083/ui/login?code=CDdvHa&amp;state=Sobjqe -&gt;<br>
http://localhost:8083/ui/securedPage</p>
<h2 id="演示客户端请求资源服务器资源">演示客户端请求资源服务器资源</h2>
<p>还记得吗，在上一节“搭建客户端程序”中，我们还定义了一个 remoteCall 接口，直接使用 OAuth2RestTemplate 来访问远程资源服务器的资源。现在，我们来测试一下这个接口是否可以实现自动的 OAuth 流程。访问：</p>
<p>http://localhost:8082/ui/remoteCall</p>
<p>会先转到授权服务器登录，登录后自动跳转回来：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/2af275ce7e8d377c6ce95d1adb014e39.png" alt=""></p>
<p>可以看到输出了用户名，对应的资源服务器服务端接口是：</p>
<p>@PreAuthorize(&ldquo;hasAuthority(&lsquo;READ&rsquo;) or hasAuthority(&lsquo;WRITE&rsquo;)&rdquo;)<br>
@GetMapping(&ldquo;name&rdquo;)<br>
public String name(OAuth2Authentication authentication) {<br>
return authentication.getName();<br>
}</p>
<p>换一个 writer 用户登录试试，也能得到正确的输出：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/OAuth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/db773012ebaaced230400bb40b7ca386.png" alt=""></p>
<h2 id="总结">总结</h2>
<p>今天这一讲，我们完整演示了如何使用 Spring Cloud 的 OAuth 2.0 组件基于三个程序角色（授权服务器、受保护资源服务器和客户端）实现三种 OAuth 2.0 的授权许可类型（资源拥有者凭据许可、客户端凭据许可和授权码许可）。</p>
<p>我们先演示了三种授权许可类型的手动流程，然后也演示了如何实现权限控制和单点登录，以及如何使用客户端程序来实现自动的 OAuth 2.0 流程。</p>
<p>我把今天用到的所有代码都放到了 GitHub 上，你可以点击这个链接查看。</p>
<p>最后，我再提一下，将来 Spring 对于 OAuth 2.0 的支持可能会转移到由社区推进的 Spring Authorization Server 项目上来继续运作。如果你感兴趣的话，可以及时关注这个项目的进展。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/oauth2.0%E5%AE%9E%E6%88%98%E8%AF%BE/">OAuth2.0实战课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A6%82%E4%BD%95%E7%9C%8B%E6%87%82%E4%B8%80%E5%B9%85%E7%94%BB/11__%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%A8%A1%E4%BB%BF%E6%89%8D%E6%98%AF%E9%AB%98%E7%BA%A7%E7%9A%84%E6%A8%A1%E4%BB%BF/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">11__什么样的模仿才是高级的模仿？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/11__%E5%AE%9E%E6%88%98%E4%B8%80%E4%B8%8A%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9F%BA%E4%BA%8E%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84mvc%E6%9E%B6%E6%9E%84%E8%BF%9D%E8%83%8Coop%E5%90%97/">
            <span class="next-text nav-default">11__实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
