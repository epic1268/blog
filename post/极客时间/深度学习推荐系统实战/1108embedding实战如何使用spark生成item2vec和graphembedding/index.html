<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>1108｜Embedding实战如何使用Spark生成Item2vec和GraphEmbedding - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="08｜Embedding实战：如何使用Spark生成Item2vec和Graph Embedding？
你好，我是王喆。
前面两节课，我们一起学习了从 Item2vec 到 Graph Embedding 的几种经典 Embedding 方法。在打好了理论基础之后，这节课就让我们从理论走向实践，看看到底如何基于 Spark 训练得到物品的 Embedding 向量。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/1108embedding%E5%AE%9E%E6%88%98%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8spark%E7%94%9F%E6%88%90item2vec%E5%92%8Cgraphembedding/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/1108embedding%E5%AE%9E%E6%88%98%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8spark%E7%94%9F%E6%88%90item2vec%E5%92%8Cgraphembedding/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="1108｜Embedding实战如何使用Spark生成Item2vec和GraphEmbedding">
  <meta property="og:description" content="08｜Embedding实战：如何使用Spark生成Item2vec和Graph Embedding？
你好，我是王喆。
前面两节课，我们一起学习了从 Item2vec 到 Graph Embedding 的几种经典 Embedding 方法。在打好了理论基础之后，这节课就让我们从理论走向实践，看看到底如何基于 Spark 训练得到物品的 Embedding 向量。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="深度学习推荐系统实战">

  <meta itemprop="name" content="1108｜Embedding实战如何使用Spark生成Item2vec和GraphEmbedding">
  <meta itemprop="description" content="08｜Embedding实战：如何使用Spark生成Item2vec和Graph Embedding？
你好，我是王喆。
前面两节课，我们一起学习了从 Item2vec 到 Graph Embedding 的几种经典 Embedding 方法。在打好了理论基础之后，这节课就让我们从理论走向实践，看看到底如何基于 Spark 训练得到物品的 Embedding 向量。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="4647">
  <meta itemprop="keywords" content="深度学习推荐系统实战">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="1108｜Embedding实战如何使用Spark生成Item2vec和GraphEmbedding">
  <meta name="twitter:description" content="08｜Embedding实战：如何使用Spark生成Item2vec和Graph Embedding？
你好，我是王喆。
前面两节课，我们一起学习了从 Item2vec 到 Graph Embedding 的几种经典 Embedding 方法。在打好了理论基础之后，这节课就让我们从理论走向实践，看看到底如何基于 Spark 训练得到物品的 Embedding 向量。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">1108｜Embedding实战如何使用Spark生成Item2vec和GraphEmbedding</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 4647 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>08｜Embedding实战：如何使用Spark生成Item2vec和Graph Embedding？</p>
<p>你好，我是王喆。</p>
<p>前面两节课，我们一起学习了从 Item2vec 到 Graph Embedding 的几种经典 Embedding 方法。在打好了理论基础之后，这节课就让我们从理论走向实践，看看到底如何基于 Spark 训练得到物品的 Embedding 向量。</p>
<p>通过特征工程部分的实践，我想你已经对 Spark 这个分布式计算平台有了初步的认识。其实除了一些基本的特征处理方法，在 Spark 的机器学习包 Spark MLlib 中，还包含了大量成熟的机器学习模型，这其中就包括我们讲过的 Word2vec 模型。基于此，这节课我们会在 Spark 平台上，完成 Item2vec 和基于 Deep Walk 的 Graph Embedding 的训练。</p>
<p>对其他机器学习平台有所了解的同学可能会问，TensorFlow、PyTorch 都有很强大的深度学习工具包，我们能不能利用这些平台进行 Embedding 训练呢？当然是可以的，我们也会在之后的课程中介绍 TensorFlow 并用它实现很多深度学习推荐模型。但是 Spark 作为一个原生的分布式计算平台，在处理大数据方面还是比 TensorFlow 等深度学习平台更具有优势，而且业界的很多公司仍然在使用 Spark 训练一些结构比较简单的机器学习模型，再加上我们已经用 Spark 进行了特征工程的处理，所以，这节课我们继续使用 Spark 来完成 Embedding 的实践。</p>
<p>首先，我们来看看怎么完成 Item2vec 的训练。</p>
<p>Item2vec：序列数据的处理</p>
<p>我们知道，Item2vec 是基于自然语言处理模型 Word2vec 提出的，所以 Item2vec 要处理的是类似文本句子，观影序列之类的序列数据。那在真正开始 Item2vec 的训练之前，我们还要先为它准备好训练用的序列数据。在 movieLens 数据集中，有一张叫 rating（评分）的数据表，里面包含了用户对看过电影的评分和评分的时间。既然时间和评分历史都有了，我们要用的观影序列自然就可以通过处理 rating 表得到啦。</p>
<p>图1 movieLens数据集中的rating评分表</p>
<p>不过，在使用观影序列编码之前，我们还要再明确两个问题。一是 movieLens 这个 rating 表本质上只是一个评分的表，不是真正的“观影序列”。但对用户来说，当然只有看过这部电影才能够评价它，所以我们几乎可以把评分序列当作是观影序列。二是我们是应该把所有电影都放到序列中，还是只放那些打分比较高的呢？</p>
<p>这里，我是建议对评分做一个过滤，只放用户打分比较高的电影。为什么这么做呢？我们要思考一下 Item2vec 这个模型本质上是要学习什么。我们是希望 item2vec 能够学习到物品之间的近似性。既然这样，我们当然是希望评分好的电影靠近一些，评分差的电影和评分好的电影不要在序列中结对出现。</p>
<p>好，那到这里我们明确了样本处理的思路，就是对一个用户来说，我们先过滤掉他评分低的电影，再把他评论过的电影按照时间戳排序。这样，我们就得到了一个用户的观影序列，所有用户的观影序列就组成了 Item2vec 的训练样本集。</p>
<p>那这个过程究竟该怎么在 Spark 上实现呢？其实很简单，我们只需要明白这 5 个关键步骤就可以实现了：</p>
<p>读取 ratings 原始数据到 Spark 平台。</p>
<p>用 where 语句过滤评分低的评分记录。</p>
<p>用 groupBy userId 操作聚合每个用户的评分记录，DataFrame 中每条记录是一个用户的评分序列。</p>
<p>定义一个自定义操作 sortUdf，用它实现每个用户的评分记录按照时间戳进行排序。</p>
<p>把每个用户的评分记录处理成一个字符串的形式，供后续训练过程使用。</p>
<p>具体的实现过程，我还是建议你来参考我下面给出的代码，重要的地方我也都加上了注释，方便你来理解。</p>
<p><code>def processItemSequence(sparkSession: SparkSession): RDD\[Seq\[String\]\] ={  //设定rating数据的路径并用spark载入数据  val ratingsResourcesPath = this.getClass.getResource(&quot;/webroot/sampledata/ratings.csv&quot;)  val ratingSamples = sparkSession.read.format(&quot;csv&quot;).option(&quot;header&quot;, &quot;true&quot;).load(ratingsResourcesPath.getPath)  //实现一个用户定义的操作函数(UDF)，用于之后的排序  val sortUdf: UserDefinedFunction = udf((rows: Seq\[Row\]) =&gt; {    rows.map { case Row(movieId: String, timestamp: String) =&gt; (movieId, timestamp) }      .sortBy { case (movieId, timestamp) =&gt; timestamp }      .map { case (movieId, timestamp) =&gt; movieId }  })  //把原始的rating数据处理成序列数据  val userSeq = ratingSamples    .where(col(&quot;rating&quot;) &gt;= 3.5)  //过滤掉评分在3.5一下的评分记录    .groupBy(&quot;userId&quot;)            //按照用户id分组    .agg(sortUdf(collect\_list(struct(&quot;movieId&quot;, &quot;timestamp&quot;))) as &quot;movieIds&quot;)     //每个用户生成一个序列并用刚才定义好的udf函数按照timestamp排序    .withColumn(&quot;movieIdStr&quot;, array\_join(col(&quot;movieIds&quot;), &quot; &quot;))                //把所有id连接成一个String，方便后续word2vec模型处理  //把序列数据筛选出来，丢掉其他过程数据  userSeq.select(&quot;movieIdStr&quot;).rdd.map(r =&gt; r.getAs\[String\](&quot;movieIdStr&quot;).split(&quot; &quot;).toSeq)</code></p>
<p>通过这段代码生成用户的评分序列样本中，每条样本的形式非常简单，它就是电影 ID 组成的序列，比如下面就是 ID 为 11888 用户的观影序列：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Item2vec</span><span class="err">：模型训练</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">训练数据准备好了，就该进入我们这堂课的重头戏，模型训练了。手写</span> <span class="n">Item2vec</span> <span class="err">的整个训练过程肯定是一件让人比较“崩溃”的事情，好在</span> <span class="n">Spark</span> <span class="n">MLlib</span> <span class="err">已经为我们准备好了方便调用的</span> <span class="n">Word2vec</span> <span class="err">模型接口。我先把训练的代码贴在下面，然后再带你一步步分析每一行代码是在做什么。``````</span><span class="k">def</span> <span class="nf">trainItem2vec</span><span class="p">(</span><span class="n">samples</span> <span class="p">:</span> <span class="n">RDD</span>\<span class="p">[</span><span class="n">Seq</span>\<span class="p">[</span><span class="ne">String</span>\<span class="p">]</span>\<span class="p">]):</span> <span class="n">Unit</span> <span class="o">=</span><span class="p">{</span>    <span class="o">//</span><span class="err">设置模型参数</span>    <span class="n">val</span> <span class="n">word2vec</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Word2Vec</span><span class="p">()</span>    <span class="o">.</span><span class="n">setVectorSize</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>    <span class="o">.</span><span class="n">setWindowSize</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>    <span class="o">.</span><span class="n">setNumIterations</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="o">//</span><span class="err">训练模型</span>  <span class="n">val</span> <span class="n">model</span> <span class="o">=</span> <span class="n">word2vec</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>  <span class="o">//</span><span class="err">训练结束，用模型查找与</span><span class="n">item</span><span class="s2">&#34;592&#34;</span><span class="err">最相似的</span><span class="mi">20</span><span class="err">个</span><span class="n">item</span>  <span class="n">val</span> <span class="n">synonyms</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">findSynonyms</span><span class="p">(</span><span class="s2">&#34;592&#34;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>  <span class="k">for</span><span class="p">((</span><span class="n">synonym</span><span class="p">,</span> <span class="n">cosineSimilarity</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">synonyms</span><span class="p">)</span> <span class="p">{</span>    <span class="n">println</span><span class="p">(</span><span class="n">s</span><span class="s2">&#34;$synonym $cosineSimilarity&#34;</span><span class="p">)</span>  <span class="p">}</span>   <span class="o">//</span><span class="err">保存模型</span>  <span class="n">val</span> <span class="n">embFolderPath</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">getClass</span><span class="o">.</span><span class="n">getResource</span><span class="p">(</span><span class="s2">&#34;/webroot/sampledata/&#34;</span><span class="p">)</span>  <span class="n">val</span> <span class="n">file</span> <span class="o">=</span> <span class="n">new</span> <span class="ne">File</span><span class="p">(</span><span class="n">embFolderPath</span><span class="o">.</span><span class="n">getPath</span> <span class="o">+</span> <span class="s2">&#34;embedding.txt&#34;</span><span class="p">)</span>  <span class="n">val</span> <span class="n">bw</span> <span class="o">=</span> <span class="n">new</span> <span class="n">BufferedWriter</span><span class="p">(</span><span class="n">new</span> <span class="n">FileWriter</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>  <span class="k">var</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span>  <span class="o">//</span><span class="err">用</span><span class="n">model</span><span class="o">.</span><span class="n">getVectors获取所有Embedding向量</span>  <span class="k">for</span> <span class="p">(</span><span class="n">movieId</span> <span class="o">&lt;-</span> <span class="n">model</span><span class="o">.</span><span class="n">getVectors</span><span class="o">.</span><span class="n">keys</span><span class="p">){</span>    <span class="n">id</span><span class="o">+=</span><span class="mi">1</span>    <span class="n">bw</span><span class="o">.</span><span class="n">write</span><span class="p">(</span> <span class="n">movieId</span> <span class="o">+</span> <span class="s2">&#34;:&#34;</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">getVectors</span><span class="p">(</span><span class="n">movieId</span><span class="p">)</span><span class="o">.</span><span class="n">mkString</span><span class="p">(</span><span class="s2">&#34; &#34;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&#34;</span><span class="se">\\</span><span class="s2">n&#34;</span><span class="p">)</span>  <span class="p">}</span>  <span class="n">bw</span><span class="o">.</span><span class="n">close</span><span class="p">()</span><span class="err">```</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">从上面的代码中我们可以看出，</span><span class="n">Spark</span> <span class="err">的</span> <span class="n">Word2vec</span> <span class="err">模型训练过程非常简单，只需要四五行代码就可以完成。接下来，我就按照从上到下的顺序，依次给你解析其中</span> <span class="mi">3</span> <span class="err">个关键的步骤。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">首先是创建</span> <span class="n">Word2vec</span> <span class="err">模型并设定模型参数。我们要清楚</span> <span class="n">Word2vec</span> <span class="err">模型的关键参数有</span> <span class="mi">3</span> <span class="err">个，分别是</span> <span class="n">setVectorSize</span><span class="err">、</span><span class="n">setWindowSize</span> <span class="err">和</span> <span class="n">setNumIterations</span><span class="err">。其中，</span><span class="n">setVectorSize</span> <span class="err">用于设定生成的</span> <span class="n">Embedding</span> <span class="err">向量的维度，</span><span class="n">setWindowSize</span> <span class="err">用于设定在序列数据上采样的滑动窗口大小，</span><span class="n">setNumIterations</span> <span class="err">用于设定训练时的迭代次数。这些超参数的具体选择就要根据实际的训练效果来做调整了。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">其次，模型的训练过程非常简单，就是调用模型的</span> <span class="n">fit</span> <span class="err">接口。训练完成后，模型会返回一个包含了所有模型参数的对象。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">最后一步就是提取和保存</span> <span class="n">Embedding</span> <span class="err">向量，我们可以从最后的几行代码中看到，调用</span> <span class="n">getVectors</span> <span class="err">接口就可以提取出某个电影</span> <span class="n">ID</span> <span class="err">对应的</span> <span class="n">Embedding</span> <span class="err">向量，之后就可以把它们保存到文件或者其他数据库中，供其他模块使用了。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">在模型训练完成后，我们再来验证一下训练的结果是不是合理。我在代码中求取了</span> <span class="n">ID</span> <span class="err">为</span> <span class="mi">592</span> <span class="err">电影的相似电影。这部电影叫</span> <span class="n">Batman</span> <span class="err">蝙蝠侠，我把通过</span> <span class="n">item2vec</span> <span class="err">得到相似电影放到了下面，你可以从直观上判断一下这个结果是不是合理。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">图</span><span class="mi">2</span> <span class="err">通过</span><span class="n">Item2vec方法找出的电影Batman的相似电影</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">当然，因为</span> <span class="n">SparrowRecsys</span> <span class="err">在演示过程中仅使用了</span> <span class="mi">1000</span> <span class="err">部电影和部分用户评论集，所以我们得出的结果不一定非常准确，如果你有兴趣优化这个结果，可以去</span> <span class="n">movieLens</span> <span class="err">下载全部样本进行重新训练。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Graph</span> <span class="n">Embedding</span><span class="err">：数据准备</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">到这里，我相信你已经熟悉了</span> <span class="n">Item2vec</span> <span class="err">方法的实现。接下来，我们再来说说基于随机游走的</span> <span class="n">Graph</span> <span class="n">Embedding</span> <span class="err">方法，看看如何利用</span> <span class="n">Spark</span> <span class="err">来实现它。这里，我们选择</span> <span class="n">Deep</span> <span class="n">Walk</span> <span class="err">方法进行实现。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">图</span><span class="mi">3</span> <span class="n">Deep</span> <span class="n">Walk的算法流程</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">在</span> <span class="n">Deep</span> <span class="n">Walk</span> <span class="err">方法中，我们需要准备的最关键数据是物品之间的转移概率矩阵。图</span> <span class="mi">3</span> <span class="err">是</span> <span class="n">Deep</span> <span class="n">Walk</span> <span class="err">的算法流程图，转移概率矩阵表达了图</span> <span class="mi">3</span><span class="err">（</span><span class="n">b</span><span class="err">）中的物品关系图，它定义了随机游走过程中，从物品</span> <span class="n">A</span> <span class="err">到物品</span> <span class="n">B</span> <span class="err">的跳转概率。所以我们首先来看一下如何利用</span> <span class="n">Spark</span> <span class="err">生成这个转移概率矩阵。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">```</span><span class="o">//</span><span class="n">samples</span> <span class="err">输入的观影序列样本集</span><span class="k">def</span> <span class="nf">graphEmb</span><span class="p">(</span><span class="n">samples</span> <span class="p">:</span> <span class="n">RDD</span>\<span class="p">[</span><span class="n">Seq</span>\<span class="p">[</span><span class="ne">String</span>\<span class="p">]</span>\<span class="p">],</span> <span class="n">sparkSession</span><span class="p">:</span> <span class="n">SparkSession</span><span class="p">):</span> <span class="n">Unit</span> <span class="o">=</span><span class="p">{</span>  <span class="o">//</span><span class="err">通过</span><span class="n">flatMap操作把观影序列打碎成一个个影片对</span>  <span class="n">val</span> <span class="n">pairSamples</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">flatMap</span>\<span class="p">[</span><span class="ne">String</span>\<span class="p">](</span> <span class="n">sample</span> <span class="o">=&gt;</span> <span class="p">{</span>    <span class="k">var</span> <span class="n">pairSeq</span> <span class="o">=</span> <span class="n">Seq</span>\<span class="p">[</span><span class="ne">String</span>\<span class="p">]()</span>    <span class="k">var</span> <span class="n">previousItem</span><span class="p">:</span><span class="ne">String</span> <span class="o">=</span> <span class="n">null</span>    <span class="n">sample</span><span class="o">.</span><span class="n">foreach</span><span class="p">((</span><span class="n">element</span><span class="p">:</span><span class="ne">String</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>      <span class="k">if</span><span class="p">(</span><span class="n">previousItem</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span>        <span class="n">pairSeq</span> <span class="o">=</span> <span class="n">pairSeq</span> <span class="p">:</span><span class="o">+</span> <span class="p">(</span><span class="n">previousItem</span> <span class="o">+</span> <span class="s2">&#34;:&#34;</span> <span class="o">+</span> <span class="n">element</span><span class="p">)</span>      <span class="p">}</span>      <span class="n">previousItem</span> <span class="o">=</span> <span class="n">element</span>    <span class="p">})</span>    <span class="n">pairSeq</span>  <span class="p">})</span>  <span class="o">//</span><span class="err">统计影片对的数量</span>  <span class="n">val</span> <span class="n">pairCount</span> <span class="o">=</span> <span class="n">pairSamples</span><span class="o">.</span><span class="n">countByValue</span><span class="p">()</span>  <span class="o">//</span><span class="err">转移概率矩阵的双层</span><span class="n">Map数据结构</span>  <span class="n">val</span> <span class="n">transferMatrix</span> <span class="o">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="n">Map</span>\<span class="p">[</span><span class="ne">String</span><span class="p">,</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="n">Map</span>\<span class="p">[</span><span class="ne">String</span><span class="p">,</span> <span class="n">Long</span>\<span class="p">]</span>\<span class="p">]()</span>  <span class="n">val</span> <span class="n">itemCount</span> <span class="o">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="n">Map</span>\<span class="p">[</span><span class="ne">String</span><span class="p">,</span> <span class="n">Long</span>\<span class="p">]()</span>  <span class="o">//</span><span class="err">求取转移概率矩阵</span>  <span class="n">pairCount</span><span class="o">.</span><span class="n">foreach</span><span class="p">(</span> <span class="n">pair</span> <span class="o">=&gt;</span> <span class="p">{</span>    <span class="n">val</span> <span class="n">pairItems</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span>\<span class="n">_1</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&#34;:&#34;</span><span class="p">)</span>    <span class="n">val</span> <span class="n">count</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span>\<span class="n">_2</span>    <span class="n">lognumber</span> <span class="o">=</span> <span class="n">lognumber</span> <span class="o">+</span> <span class="mi">1</span>    <span class="n">println</span><span class="p">(</span><span class="n">lognumber</span><span class="p">,</span> <span class="n">pair</span><span class="o">.</span>\<span class="n">_1</span><span class="p">)</span>    <span class="k">if</span> <span class="p">(</span><span class="n">pairItems</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">2</span><span class="p">){</span>      <span class="n">val</span> <span class="n">item1</span> <span class="o">=</span> <span class="n">pairItems</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>      <span class="n">val</span> <span class="n">item2</span> <span class="o">=</span> <span class="n">pairItems</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">transferMatrix</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">pairItems</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="mi">0</span><span class="p">))){</span>        <span class="n">transferMatrix</span><span class="p">(</span><span class="n">item1</span><span class="p">)</span> <span class="o">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="n">Map</span>\<span class="p">[</span><span class="ne">String</span><span class="p">,</span> <span class="n">Long</span>\<span class="p">]()</span>      <span class="p">}</span>      <span class="n">transferMatrix</span><span class="p">(</span><span class="n">item1</span><span class="p">)(</span><span class="n">item2</span><span class="p">)</span> <span class="o">=</span> <span class="n">count</span>      <span class="n">itemCount</span><span class="p">(</span><span class="n">item1</span><span class="p">)</span> <span class="o">=</span> <span class="n">itemCount</span><span class="o">.</span><span class="n">getOrElse</span>\<span class="p">[</span><span class="n">Long</span>\<span class="p">](</span><span class="n">item1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">count</span>    <span class="p">}</span>  <span class="err">```</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">生成转移概率矩阵的函数输入是在训练</span> <span class="n">Item2vec</span> <span class="err">时处理好的观影序列数据。输出的是转移概率矩阵，由于转移概率矩阵比较稀疏，因此我没有采用比较浪费内存的二维数组的方法，而是采用了一个双层</span> <span class="n">map</span> <span class="err">的结构去实现它。比如说，我们要得到物品</span> <span class="n">A</span> <span class="err">到物品</span> <span class="n">B</span> <span class="err">的转移概率，那么</span> <span class="n">transferMatrix</span><span class="p">(</span><span class="n">itemA</span><span class="p">)(</span><span class="n">itemB</span><span class="p">)</span> <span class="err">就是这一转移概率。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">在求取转移概率矩阵的过程中，我先利用</span> <span class="n">Spark</span> <span class="err">的</span> <span class="n">flatMap</span> <span class="err">操作把观影序列“打碎”成一个个影片对，再利用</span> <span class="n">countByValue</span> <span class="err">操作统计这些影片对的数量，最后根据这些影片对的数量求取每两个影片之间的转移概率。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">在获得了物品之间的转移概率矩阵之后，我们就可以进入图</span> <span class="mi">3</span><span class="err">（</span><span class="n">c</span><span class="err">）的步骤，进行随机游走采样了。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Graph</span> <span class="n">Embedding</span><span class="err">：随机游走采样过程</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">随机游走采样的过程是利用转移概率矩阵生成新的序列样本的过程。这怎么理解呢？首先，我们要根据物品出现次数的分布随机选择一个起始物品，之后就进入随机游走的过程。在每次游走时，我们根据转移概率矩阵查找到两个物品之间的转移概率，然后根据这个概率进行跳转。比如当前的物品是</span> <span class="n">A</span><span class="err">，从转移概率矩阵中查找到</span> <span class="n">A</span> <span class="err">可能跳转到物品</span> <span class="n">B</span> <span class="err">或物品</span> <span class="n">C</span><span class="err">，转移概率分别是</span> <span class="mf">0.4</span> <span class="err">和</span> <span class="mf">0.6</span><span class="err">，那么我们就按照这个概率来随机游走到</span> <span class="n">B</span> <span class="err">或</span> <span class="n">C</span><span class="err">，依次进行下去，直到样本的长度达到了我们的要求。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">根据上面随机游走的过程，我用</span> <span class="n">Scala</span> <span class="err">进行了实现，你可以参考下面的代码，在关键的位置我也给出了注释：</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">```</span><span class="o">//</span><span class="err">随机游走采样函数</span><span class="o">//</span><span class="n">transferMatrix</span> <span class="err">转移概率矩阵</span><span class="o">//</span><span class="n">itemCount</span> <span class="err">物品出现次数的分布</span><span class="k">def</span> <span class="nf">randomWalk</span><span class="p">(</span><span class="n">transferMatrix</span> <span class="p">:</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="n">Map</span>\<span class="p">[</span><span class="ne">String</span><span class="p">,</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="n">Map</span>\<span class="p">[</span><span class="ne">String</span><span class="p">,</span> <span class="n">Long</span>\<span class="p">]</span>\<span class="p">],</span> <span class="n">itemCount</span> <span class="p">:</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="n">Map</span>\<span class="p">[</span><span class="ne">String</span><span class="p">,</span> <span class="n">Long</span>\<span class="p">]):</span> <span class="n">Seq</span>\<span class="p">[</span><span class="n">Seq</span>\<span class="p">[</span><span class="ne">String</span>\<span class="p">]</span>\<span class="p">]</span> <span class="o">=</span><span class="p">{</span>  <span class="o">//</span><span class="err">样本的数量</span>  <span class="n">val</span> <span class="n">sampleCount</span> <span class="o">=</span> <span class="mi">20000</span>  <span class="o">//</span><span class="err">每个样本的长度</span>  <span class="n">val</span> <span class="n">sampleLength</span> <span class="o">=</span> <span class="mi">10</span>  <span class="n">val</span> <span class="n">samples</span> <span class="o">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="n">ListBuffer</span>\<span class="p">[</span><span class="n">Seq</span>\<span class="p">[</span><span class="ne">String</span>\<span class="p">]</span>\<span class="p">]()</span>    <span class="o">//</span><span class="err">物品出现的总次数</span>  <span class="k">var</span> <span class="n">itemTotalCount</span><span class="p">:</span><span class="n">Long</span> <span class="o">=</span> <span class="mi">0</span>  <span class="k">for</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">itemCount</span><span class="p">)</span> <span class="n">itemTotalCount</span> <span class="o">+=</span> <span class="n">v</span>  <span class="o">//</span><span class="err">随机游走</span><span class="n">sampleCount次</span><span class="err">，生成</span><span class="n">sampleCount个序列样本</span>  <span class="k">for</span><span class="p">(</span> <span class="n">w</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">sampleCount</span><span class="p">)</span> <span class="p">{</span>    <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oneRandomWalk</span><span class="p">(</span><span class="n">transferMatrix</span><span class="p">,</span> <span class="n">itemCount</span><span class="p">,</span> <span class="n">itemTotalCount</span><span class="p">,</span> <span class="n">sampleLength</span><span class="p">))</span>  <span class="p">}</span>  <span class="n">Seq</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">toList</span> <span class="p">:</span> \<span class="n">_</span>\<span class="o">*</span><span class="p">)}</span><span class="o">//</span><span class="err">通过随机游走产生一个样本的过程</span><span class="o">//</span><span class="n">transferMatrix</span> <span class="err">转移概率矩阵</span><span class="o">//</span><span class="n">itemCount</span> <span class="err">物品出现次数的分布</span><span class="o">//</span><span class="n">itemTotalCount</span> <span class="err">物品出现总次数</span><span class="o">//</span><span class="n">sampleLength</span> <span class="err">每个样本的长度</span><span class="k">def</span> <span class="nf">oneRandomWalk</span><span class="p">(</span><span class="n">transferMatrix</span> <span class="p">:</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="n">Map</span>\<span class="p">[</span><span class="ne">String</span><span class="p">,</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="n">Map</span>\<span class="p">[</span><span class="ne">String</span><span class="p">,</span> <span class="n">Long</span>\<span class="p">]</span>\<span class="p">],</span> <span class="n">itemCount</span> <span class="p">:</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="n">Map</span>\<span class="p">[</span><span class="ne">String</span><span class="p">,</span> <span class="n">Long</span>\<span class="p">],</span> <span class="n">itemTotalCount</span><span class="p">:</span><span class="n">Long</span><span class="p">,</span> <span class="n">sampleLength</span><span class="p">:</span><span class="n">Int</span><span class="p">):</span> <span class="n">Seq</span>\<span class="p">[</span><span class="ne">String</span>\<span class="p">]</span> <span class="o">=</span><span class="p">{</span>  <span class="n">val</span> <span class="n">sample</span> <span class="o">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="n">ListBuffer</span>\<span class="p">[</span><span class="ne">String</span>\<span class="p">]()</span>  <span class="o">//</span><span class="err">决定起始点</span>  <span class="n">val</span> <span class="n">randomDouble</span> <span class="o">=</span> <span class="n">Random</span><span class="o">.</span><span class="n">nextDouble</span><span class="p">()</span>  <span class="k">var</span> <span class="n">firstElement</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span>  <span class="k">var</span> <span class="n">culCount</span><span class="p">:</span><span class="n">Long</span> <span class="o">=</span> <span class="mi">0</span>  <span class="o">//</span><span class="err">根据物品出现的概率，随机决定起始点</span>  <span class="n">breakable</span> <span class="p">{</span> <span class="k">for</span> <span class="p">((</span><span class="n">item</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">itemCount</span><span class="p">)</span> <span class="p">{</span>    <span class="n">culCount</span> <span class="o">+=</span> <span class="n">count</span>    <span class="k">if</span> <span class="p">(</span><span class="n">culCount</span> <span class="o">&gt;=</span> <span class="n">randomDouble</span> \<span class="o">*</span> <span class="n">itemTotalCount</span><span class="p">){</span>      <span class="n">firstElement</span> <span class="o">=</span> <span class="n">item</span>      <span class="k">break</span>    <span class="p">}</span>  <span class="p">}}</span>  <span class="n">sample</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">firstElement</span><span class="p">)</span>  <span class="k">var</span> <span class="n">curElement</span> <span class="o">=</span> <span class="n">firstElement</span>  <span class="o">//</span><span class="err">通过随机游走产生长度为</span><span class="n">sampleLength的样本</span>  <span class="n">breakable</span> <span class="p">{</span> <span class="k">for</span><span class="p">(</span> <span class="n">w</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">sampleLength</span><span class="p">)</span> <span class="p">{</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">itemCount</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">curElement</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">transferMatrix</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">curElement</span><span class="p">)){</span>      <span class="k">break</span>    <span class="p">}</span>    <span class="o">//</span><span class="err">从</span><span class="n">curElement到下一个跳的转移概率向量</span>    <span class="n">val</span> <span class="n">probDistribution</span> <span class="o">=</span> <span class="n">transferMatrix</span><span class="p">(</span><span class="n">curElement</span><span class="p">)</span>    <span class="n">val</span> <span class="n">curCount</span> <span class="o">=</span> <span class="n">itemCount</span><span class="p">(</span><span class="n">curElement</span><span class="p">)</span>    <span class="n">val</span> <span class="n">randomDouble</span> <span class="o">=</span> <span class="n">Random</span><span class="o">.</span><span class="n">nextDouble</span><span class="p">()</span>    <span class="k">var</span> <span class="n">culCount</span><span class="p">:</span><span class="n">Long</span> <span class="o">=</span> <span class="mi">0</span>    <span class="o">//</span><span class="err">根据转移概率向量随机决定下一跳的物品</span>    <span class="n">breakable</span> <span class="p">{</span> <span class="k">for</span> <span class="p">((</span><span class="n">item</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">probDistribution</span><span class="p">)</span> <span class="p">{</span>      <span class="n">culCount</span> <span class="o">+=</span> <span class="n">count</span>      <span class="k">if</span> <span class="p">(</span><span class="n">culCount</span> <span class="o">&gt;=</span> <span class="n">randomDouble</span> \<span class="o">*</span> <span class="n">curCount</span><span class="p">){</span>        <span class="n">curElement</span> <span class="o">=</span> <span class="n">item</span>        <span class="k">break</span>      <span class="p">}</span>    <span class="p">}}</span>    <span class="n">sample</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curElement</span><span class="p">)</span>  <span class="p">}}</span>  <span class="n">Seq</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">toList</span> <span class="p">:</span> \<span class="n">_</span><span class="err">```</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">通过随机游走产生了我们训练所需的</span> <span class="n">sampleCount</span> <span class="err">个样本之后，下面的过程就和</span> <span class="n">Item2vec</span> <span class="err">的过程完全一致了，就是把这些训练样本输入到</span> <span class="n">Word2vec</span> <span class="err">模型中，完成最终</span> <span class="n">Graph</span> <span class="n">Embedding</span> <span class="err">的生成。你也可以通过同样的方法去验证一下通过</span> <span class="n">Graph</span> <span class="n">Embedding</span> <span class="err">方法生成的</span> <span class="n">Embedding</span> <span class="err">的效果。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">小结</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">这节课，我们运用</span> <span class="n">Spark</span> <span class="err">实现了经典的</span> <span class="n">Embedding</span> <span class="err">方法</span> <span class="n">Item2vec</span> <span class="err">和</span> <span class="n">Deep</span> <span class="n">Walk</span><span class="err">。它们的理论知识你应该已经在前两节课的学习中掌握了，这里我就总结一下实践中应该注意的几个要点。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">关于</span> <span class="n">Item2vec</span> <span class="err">的</span> <span class="n">Spark</span> <span class="err">实现，你应该注意的是训练</span> <span class="n">Word2vec</span> <span class="err">模型的几个参数</span> <span class="n">VectorSize</span><span class="err">、</span><span class="n">WindowSize</span><span class="err">、</span><span class="n">NumIterations</span> <span class="err">等，知道它们各自的作用。它们分别是用来设置</span> <span class="n">Embedding</span> <span class="err">向量的维度，在序列数据上采样的滑动窗口大小，以及训练时的迭代次数。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">而在</span> <span class="n">Deep</span> <span class="n">Walk</span> <span class="err">的实现中，我们应该着重理解的是，生成物品间的转移概率矩阵的方法，以及通过随机游走生成训练样本过程。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">最后，我还是把这节课的重点知识总结在了一张表格中，希望能帮助你进一步巩固。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">这里，我还想再多说几句。这节课，我们终于看到了深度学习模型的产出，我们用</span> <span class="n">Embedding</span> <span class="err">方法计算出了相似电影！对于我们学习这门课来说，它完全可以看作是一个里程碑式的进步。接下来，我希望你能总结实战中的经验，跟我继续同行，一起迎接未来更多的挑战！</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">课后思考</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">上节课，我们在讲</span> <span class="n">Graph</span> <span class="n">Embedding</span> <span class="err">的时候，还介绍了</span> <span class="n">Node2vec</span> <span class="err">方法。你能尝试在</span> <span class="n">Deep</span> <span class="n">Walk</span> <span class="err">代码的基础上实现</span> <span class="n">Node2vec</span> <span class="err">吗？这其中，我们应该着重改变哪部分的代码呢？</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">欢迎把你的思考和答案写在留言区，如果你掌握了</span> <span class="n">Embedding</span> <span class="err">的实战方法，也不妨把它分享给你的朋友吧，我们下节课见！</span>
</span></span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/">深度学习推荐系统实战</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/spring%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/11webflux%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%9C%8D%E5%8A%A1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">11WebFlux（下）：如何使用函数式编程模型构建异步非阻塞服务？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%9845%E8%AE%B2/1110%E4%B8%A8python%E7%88%AC%E8%99%AB%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B8%8B%E8%BD%BD%E7%8E%8B%E7%A5%96%E8%B4%A4%E6%B5%B7%E6%8A%A5/">
            <span class="next-text nav-default">1110丨Python爬虫：如何自动化下载王祖贤海报？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
