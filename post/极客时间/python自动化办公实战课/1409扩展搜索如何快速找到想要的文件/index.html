<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>1409｜扩展搜索如何快速找到想要的文件 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="09｜扩展搜索：如何快速找到想要的文件？
你好，我是尹会生。
工作时间越久，你就会发现，自己电脑里存储的办公文件也越来越多。一旦需要紧急找到某个文件，你又恰巧忘记了文件被存放的具体位置，就只能通过 Windows 的搜索功能对文件名称进行搜索，不过你大概率需要长时间等 Windows 的搜索结果。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E5%AE%9E%E6%88%98%E8%AF%BE/1409%E6%89%A9%E5%B1%95%E6%90%9C%E7%B4%A2%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E6%96%87%E4%BB%B6/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E5%AE%9E%E6%88%98%E8%AF%BE/1409%E6%89%A9%E5%B1%95%E6%90%9C%E7%B4%A2%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E6%96%87%E4%BB%B6/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="1409｜扩展搜索如何快速找到想要的文件">
  <meta property="og:description" content="09｜扩展搜索：如何快速找到想要的文件？
你好，我是尹会生。
工作时间越久，你就会发现，自己电脑里存储的办公文件也越来越多。一旦需要紧急找到某个文件，你又恰巧忘记了文件被存放的具体位置，就只能通过 Windows 的搜索功能对文件名称进行搜索，不过你大概率需要长时间等 Windows 的搜索结果。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Python自动化办公实战课">

  <meta itemprop="name" content="1409｜扩展搜索如何快速找到想要的文件">
  <meta itemprop="description" content="09｜扩展搜索：如何快速找到想要的文件？
你好，我是尹会生。
工作时间越久，你就会发现，自己电脑里存储的办公文件也越来越多。一旦需要紧急找到某个文件，你又恰巧忘记了文件被存放的具体位置，就只能通过 Windows 的搜索功能对文件名称进行搜索，不过你大概率需要长时间等 Windows 的搜索结果。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5217">
  <meta itemprop="keywords" content="Python自动化办公实战课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="1409｜扩展搜索如何快速找到想要的文件">
  <meta name="twitter:description" content="09｜扩展搜索：如何快速找到想要的文件？
你好，我是尹会生。
工作时间越久，你就会发现，自己电脑里存储的办公文件也越来越多。一旦需要紧急找到某个文件，你又恰巧忘记了文件被存放的具体位置，就只能通过 Windows 的搜索功能对文件名称进行搜索，不过你大概率需要长时间等 Windows 的搜索结果。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">1409｜扩展搜索如何快速找到想要的文件</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5217 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>09｜扩展搜索：如何快速找到想要的文件？</p>
<p>你好，我是尹会生。</p>
<p>工作时间越久，你就会发现，自己电脑里存储的办公文件也越来越多。一旦需要紧急找到某个文件，你又恰巧忘记了文件被存放的具体位置，就只能通过 Windows 的搜索功能对文件名称进行搜索，不过你大概率需要长时间等 Windows 的搜索结果。</p>
<p>之所以查找文件的时间过长，主要有两个原因。</p>
<p>搜索范围太大。搜索过程中可能包含了大量的操作系统或应用软件的缓存文件等无效路径，导致搜索时间过长。</p>
<p>受到硬盘文件数量过多的影响。硬盘的文件数量越多，完整搜索一遍所有文件的时间就越长。</p>
<p>那有没有办法提高搜索的效率，快速找到你想要的文件呢？基于以上两种原因，相应的，我们可以在 Python 中采用指定搜索路径范围和提前建立文件索引的两种方案实现文件的搜索功能。</p>
<p>这两种方案都是基于 Python 的基本搜索方法实现的，因此我先来带你学习一下如何用 Python 的 pathlib 库实现基础文件的搜索。</p>
<p>基础搜索方法：用 pathlib 库搜索文件</p>
<p>用 Python 搜索文件时需要使用 pathlib 库的 glob() 函数和 rglob() 函数，glob() 函数可以实现基于文件名的搜索方法，rglob 函数可以实现基于扩展名的搜索方法。</p>
<p>我先来给你看一下 Python 实现基础搜索功能的代码，通过代码来为你讲解一下 Python 是如何搜索到一个文件的：</p>
<p><code>from pathlib import Pathbase\_dir = '/Users/edz/Desktop/'keywords = '\*\*/\*BBC\*'\# 遍历base\_dir指向的目录下所有的文件p = Path(base\_dir)\# 当前目录下包含BBC的所有文件名称files = p.glob(keywords)  \# files的类型是迭代器\# 通过list()函数转换为列表输出\# print(list(files))\# xlsx结尾的文件files2 = p.rglob('\*.xlsx')print(list(files2))\# 遍历子目录和所有文件files3 = p.glob('\*\*/\*')print(list(files3))</code></p>
<p>在这段代码中，我实现了 Python 的基础搜索功能。由于搜索的优化要基于 glob() 函数和 rglob() 函数进行，为了能更好的提升 Python 的搜索的效率，我来带你逐一分析一下 glob() 函数和 rglob() 函数的参数和返回值。</p>
<p>首先我来带你看一下 glob() 函数和它的参数, 由于 glob() 进行匹配的是文件的路径和文件名称方式，如: &ldquo;c:\somepath\to\filename_include_BBC_voice.exe&rdquo; , 而我们进行文件搜索的时候一般会使用关键字，如“BBC”，因此在搜索时我们需要为关键字加上通配符的形式，如“BBC” 。</p>
<p>通配符是类似正则表达式的元字符的一种特殊符号，它不能用在正则表达式中，只能用在 glob（全称 global）匹配模式中。</p>
<p>我将 glob() 和 rglob() 函数常用的通配符，以及它们的功能整理成一个表格，供你学习和参考。</p>
<p>通过表格我希望你能掌握如何将通配符和要搜索的关键字进行组合。比如说，通过使用“**/BBC”的方式，我就可以搜索到 Path() 函数指定目录下所有包含 BBC 关键字的文件名。</p>
<p>接下来我再来带你学习一下 rglob 函数和它的参数。rglob 函数是从文件路径末尾向前进行匹配的，这是它和 glob() 函数的主要区别, 基于 rglob() 函数的搜索顺序特点，经常被我们用于进行扩展名的搜索，比如说采用 rglob(&rsquo;*.xlsx&rsquo;) 就可以搜索所有的 xlsx 扩展名文件，要比使用 glob() 编写的模式匹配更简单，参数的含义也更清晰。</p>
<p>最后我再来带你看一下 glob() 和 rglob() 函数的返回值，有一点我需要提醒你：它们的执行结果是我们之前课程中没有接触过的一种新的数据类型，这种类型叫做“迭代器”。</p>
<p>顾名思义，迭代器的特点是这个数据类型可以支持迭代操作，执行一次 glob() 或 rglob() 函数只返回一个结果。要想得到迭代器所以的值可以使用两种方法。</p>
<p>一种是使用 list() 函数将迭代器转换为我们所熟知的列表数据类型，例如我在列表中就是用了“list(files3)”方式将迭代器转换为了列表。</p>
<p>还有一种方式是使用 for 循环的方式对迭代器的值进行逐一处理。</p>
<p>这两种用法不但可以获取 glob() 返回值，今后我们遇到的迭代器都可以使用 list() 函数和 for 循环取得它的全部值。</p>
<p>通过对 glob() 和 rglob() 函数的参数和返回值的学习，相信你已经掌握了使用功能 Python 搜索文件的基础方法，接下来我来带你通过指定搜索路径和建立索引文件提高搜索的效率。</p>
<p>提升搜索效率的两种方法</p>
<p>用 Python 的 pathlib 库实现文件搜索，只是在灵活性上比 Windows 默认的搜索更好，但是搜索效率上并不能带来任何提高。为了减少搜索的等待时间, 接下来，我就教你使用指定搜索路径和建立索引文件两个方法, 提高 pathlib 库的搜索效率。</p>
<p>指定搜索路径</p>
<p>我们先来看第一种，指定搜索路径。我们需要通过三个步骤实现：</p>
<p>先生成配置文件，把要搜索的路径写入到配置文件中；</p>
<p>再编写读取配置文件和搜索的自定义函数，把配置文件中的路径读取出来，逐个目录搜索；</p>
<p>最后，将多个目录的搜索结果合并输出，便于你通过结果快速找到自己想要的文件。</p>
<p>先说第一步，怎么使用 Python 读取配置文件。以往我们会把要搜索的路径写入到变量，并把定义路径的变量名称放在代码前几行的位置，便于下次修改搜索目录的时候找到这个变量。但是对于代码工程稍微复杂的程序来说，往往会有多个代码文件，仍然不利于每次搜索的时候进行搜索路径的修改。</p>
<p>现在我教你一个新的方法，就是把变量放入到一个单独的文件中，这个文件被称作该代码的配置文件。这种方法的好处是你修改搜索目录时不用打开代码文件。假设你的朋友也需要类似功能，那你就可以把代码和配置文件一起发给他，哪怕他完全不会 Python，也能使用你编写的程序实现高效搜索。</p>
<p>那怎么给 Python 脚本增加配置文件呢？</p>
<p>配置文件一般为文本文件。配置文件的格式，一般由软件作者基于软件的功能和自己的习惯来指定，不过也有通用的配置文件格式。比如在 Windows 系统中，最常见的配置文件是扩展名为.ini 的文件，在今天这节课，我们就把.ini 文件格式作为配置文件的标准格式。</p>
<p>.ini 文件格式包含三个部分，分别是节、参数和注释。格式如下：</p>
<p><code>节  \[section\]参数（键=值）  name=value注释 注释使用“;”分号表示。在分号后面的文字，直到该行结尾都全部为注解。;注释内容</code></p>
<p>基于.ini 文件的格式，我把配置搜索路径的配置文件修改为如下：</p>
<p><code>\[work\];工作文件保存路径searchpath=/Users/edz,/tmp\[game\];娱乐文件保存路径searchpath=/games,/movies,/music</code></p>
<p>在这段代码中，我设置了 work 和 game 两个“节”，分别代表工作和娱乐。这样设置的好处是，我可以根据不同的用途来搜索不同的目录。如果搜索时使用了更少的目录，也会相应减少搜索的等待时间。</p>
<p>另外，你会发现两个“节”中的参数我都指定成相同的名字 &ndash;searchpath，这样设置的好处是我将搜索范围从“工作”改为“娱乐”时，只需要在代码里修改搜索的“节”，不用修改搜索的参数。</p>
<p>除了“节”和“参数”，在配置文件中，你还应该关注我对参数 searchpath 设置值的方式，它的值是我想要进行搜索的路径范围，为了在程序中能够更方便得读取多个路径，我使用逗号来分隔多个路径。</p>
<p>在编写好配置文件之后，下一步就是取得.ini 文件的完整路径，我把.ini 文件和脚本放在了相同的目录，我在第七讲为你详细剖析过，怎样通过 __file__ 变量和 pathlib 库相结合，实现读取和脚本在同一目录的文件操作，我就不多说了，如果你不太记得了，可以回去复习下。</p>
<p>找到 search.ini 文件完整路径之后，接下来需要读取并分析.ini 文件格式，Python 有实现这个功能的的库，它叫做 configparser 库，通过这个库你可以直接读取.ini 文件中的 searchpath 参数，不用通过 read() 函数读取文件内容，手动编写分析.ini 文件的脚本了。</p>
<p>接下来，我来带你看一下 Python 读取.ini 文件的代码，帮你理解 Python 是怎样通过配置文件来实现在多个路径搜索文件功能的。</p>
<p><code>import configparserimport pathlib from pathlib import Pathdef read\_dirs(ini\_filename, section, arg):    &quot;&quot;&quot;    通过ini文件名,节和参数取得要操作的多个目录    &quot;&quot;&quot;    current\_path = pathlib.PurePath(\_\_file\_\_).parent    inifile = current\_path.joinpath(ini\_filename)    # cf是类ConfigParser的实例    cf = configparser.ConfigParser()    # 读取.ini文件    cf.read(inifile)    # 读取work节 和 searchpath参数     return cf.get(section, arg).split(&quot;,&quot;)def locate\_file(base\_dir, keywords):    p = Path(base\_dir)    files = p.glob(keywords)     return list(files)dirs = read\_dirs('search.ini', 'work', 'searchpath')\# \['/Users/edz', '/tmp'\]keywords = '\*\*/\*BBC\*'\# 定义存放查找结果的列表result = \[\]\# 从每个文件夹中搜索文件for dir in dirs:    files = locate\_file(dir, keywords)    result += files\# 将PosixPath转为字符串print( \[str(r) for r in result\] )</code></p>
<p>在这段代码中，读取配置文件和搜索这两个最主要的功能由两个自定义函数实现，它们分别是 read_dirs() 函数和 locate_file() 函数。</p>
<p>read_dirs() 函数实现了读取.ini 文件，并将返回的多个路径处理为列表类型。列表类型适合多组并列的数据，多个目录刚好可以使用列表这种数据类型来存放要搜索的目录名称。</p>
<p>locate_file() 函数通过代码的第 35 行循环功能，对每个目录进行了搜索，并将搜索的结果存入 result 变量。result 变量是一个列表数据类型，由于搜索到的文件可能包含多个匹配的文件路径，我需要将搜索到的结果依次存入 result 列表中，再继续搜索下一个目录，继续通过 append() 函数将结果放入列表，直到所有的目录搜索完成，整个搜索的程序才真正执行结束。</p>
<p>最后还有一点需要你注意，在进行路径处理的过程中，pathlib 库为了规避不同操作系统路径写法的差异，就把路径统一定义为 PosixPath() 对象。因此，你在使用这些路径的时候，需要先将 PosixPath 对象转换为字符串类型。我在代码最后一行通过 Python 内置函数 str() 函数把 PosixPath 对象逐个转换为字符串类型，并再次存入到列表当中。</p>
<p>通过限制在指定的目录搜索这个功能，我们就可以规避在搜索时错误匹配系统文件和软件缓存文件而导致的查找过慢问题。</p>
<p>不过如果我们指定的目录仍然有非常多文件的话，那用这个方法查找起来依然会很慢。别担心，接下来我就教你一种利用空间换时间的方法，提高对指定目录文件搜索效率的方法。</p>
<p>建立索引文件</p>
<p>什么是“空间换时间”呢？我来解释一下。</p>
<p>我们知道，文件越多，搜索的时间就越长，因为搜索的时间是随着文件数量呈线性增长的。就像一本书越厚，你从第一页读到最后一页的时间就越长一样。那怎样能快速搜索到书中的内容呢？你会想到图书都有目录功能，通过目录可以加快你找到你想看的图书内容的速度。</p>
<p>对于操作系统来说，一个文件也是由文件名称、大小、文件内容等多个部分组成的，搜索文件的功能只需要文件名称就行了，不需要其他的部分。因此，我们可以在硬盘中新开辟一块空间，将所有的文件名提前存储下来作为文件的索引，下次再查找的时候直接查找索引文件，就能得到搜索结果，而不必再通过硬盘查找真实的文件了。这就是“空间换时间”。</p>
<p>既然索引文件可以加快搜索速度，那我们去建立索引文件就可以了。</p>
<p>建立索引文件不需要你重新再写新的程序，我们可以基于指定搜索路径的程序进行改造：</p>
<p>先把配置文件目录下所有文件路径的保存方式由列表改为文件；</p>
<p>再把搜索功能改为从文件搜索。</p>
<p>我把改造后的代码写出来供你参考。</p>
<p><code>def locate\_file(base\_dir, keywords='\*\*/\*'):    &quot;&quot;&quot;    迭代目录下所有文件    &quot;&quot;&quot;    p = Path(base\_dir)    return p.glob(keywords)def write\_to\_db():    &quot;&quot;&quot;    写入索引文件    &quot;&quot;&quot;    current\_path = pathlib.PurePath(\_\_file\_\_).parent    dbfile = current\_path.joinpath(&quot;search.db&quot;)    with open(dbfile, 'w', encoding='utf-8') as f:        for r in result:            f.write(f&quot;{str(r)}\\n&quot;)\# 读取配置文件dirs = read\_dirs('search.ini', 'work', 'searchpath')\# 遍历目录result = \[\]for dir in dirs:    for files in locate\_file(dir):        result.append(files)\# 将目录写入索引文件write\_to\_db()</code></p>
<p>在代码中我增加了 write_to_db() 函数，它在代码的第 16-18 行，我通过写入文件方式替代了写入列表的功能。同时，为了能遍历所有的目录，我还修改了 locate_file() 函数的第二个参数，将它改为“keywords=&rsquo;/*&rsquo;”。通过这两处的修改，就把所有文件路径全部保存到 search.db 文件中了。**</p>
<p>search.db 的文件内容如下，这里记录了配置文件指定的所有目录下的所有文件路径：</p>
<p><code>/tmp/com.apple.launchd.kZENgZTtVz/tmp/com.google.Keystone/tmp/mysql.sock/tmp/com.adobe.AdobeIPCBroker.ctrl-edz/tmp/com.apple.launchd.kZENgZTtVz/Listeners/tmp/com.google.Keystone/.keystone\_install\_lock... ...</code></p>
<p>接下来，我再把搜索功能从列表搜索改造为从文件搜索，为了避免每次搜索要重新生成一次 search.db 文件，我要编写一个新的脚本，专门用于从文本中搜索关键字，并将搜索的结果显示出来。</p>
<p>相信你一定想到了我在上一讲为你讲解的正则表达式功能，通过 re.search() 函数刚好可以实现文本的搜索。下面的 locate.py 脚本文件就是我使用正则表达式实现的文本搜索功能：</p>
<p><code>import pathlib import rekeyword = &quot;apple&quot;\# 获取索引文件路径current\_path = pathlib.PurePath(\_\_file\_\_).parentdbfile = current\_path.joinpath(&quot;search.db&quot;)\# 在索引文件中搜索关键字with open(dbfile, encoding='utf-8') as f:    for line in f.readlines():        if re.search(keyword, line):            print(line.rstrip())</code></p>
<p>在代码中我利用正则表达式的 re.search() 搜索函数，以 keyword 变量作为搜索的关键字，对 search.db 索引文件的每一行进行了匹配，最后将符合关键字“apple”的文件路径和名称一起显示在屏幕上。</p>
<p>使用这种方式来搜索文件，要比使用操作系统自带的搜索工具快得多，因为我将原本 Windows 搜索硬盘上的文件所消耗的时间拆分成了两部分。</p>
<p>一部分是 updatedb.py 建立索引的时间；</p>
<p>一部分是从 search.db 索引文件查找关键字的时间。</p>
<p>当搜索等待的时间被提前转换为建立索引的时间后，搜索的效率自然就提高了。</p>
<p>但是请你注意，这种方式建立的索引文件会有时效性的问题，一旦硬盘中的文件被删除、移动或改名，你就得重新建立索引文件。而索引文件保存的文件路径和当前真实的文件并不能一一对应，所以你需要及时更新索引文件。</p>
<p>为了保证索引文件的时效性，你还可以把 updatedb.py 脚本加入到 Windows 的开机启动脚本中，每次打开计算机就会自动更新索引文件。通过这种方式就可以让索引文件里的文件路径更加准确。</p>
<p>总结</p>
<p>最后，我来为你总结一下。这节课，我为你讲解了如何使用 pathlib 库搜索文件，以及如何使用配置文件和索引文件加快搜索。</p>
<p>利用索引文件减少等待时间，实际上是将 Windows 的搜索进行了拆分，提前将搜索的路径保存到了索引文件中，从索引文件搜索时，就不用再进行真正的文件查找工作了，这就减少了搜索的等待的时间。</p>
<p>这种搜索方法在服务器领域已经被广泛使用，像 Linux 和 MacOS 操作系统中都存在着利用索引文件的搜索命令，对于服务器上变化频率较低的场景，利用索引文件搜索非常实用。</p>
<p>思考题</p>
<p>我给你留一道思考题。如何扩展 locate.py 的搜索功能，实现搜索.jpg 扩展名的文件呢?</p>
<p>欢迎把你的思考和想法分享在留言区，我们一起交流讨论。如果课程帮你解决了一些工作上的问题，也欢迎你把课程分享给你的朋友、同事。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E5%AE%9E%E6%88%98%E8%AF%BE/">Python自动化办公实战课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/14dp%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E6%B2%BB%E5%A5%BDdp-%E5%A4%B4%E7%97%9B%E7%97%87%E7%9A%84/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">14DP：我是怎么治好“DP 头痛症”的？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/1410%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9D%97%E5%A6%82%E4%BD%95%E7%94%A8redis%E8%A7%A3%E5%86%B3%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%89%B9%E5%BE%81%E7%9A%84%E5%AD%98%E5%82%A8%E9%97%AE%E9%A2%98/">
            <span class="next-text nav-default">1410｜存储模块如何用Redis解决推荐系统特征的存储问题</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
