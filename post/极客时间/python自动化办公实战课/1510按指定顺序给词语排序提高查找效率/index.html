<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>1510｜按指定顺序给词语排序提高查找效率 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="10｜按指定顺序给词语排序，提高查找效率
你好，我是尹会生。
之前我在游戏行业工作的时候，经常需要取得用户在线时长 TOP3、用户战斗力 TOP5、用户完成任务数量 TOP10 等数据，相信你在工作中也会有遇到从大量数据取得 TopN 这类需求。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E5%AE%9E%E6%88%98%E8%AF%BE/1510%E6%8C%89%E6%8C%87%E5%AE%9A%E9%A1%BA%E5%BA%8F%E7%BB%99%E8%AF%8D%E8%AF%AD%E6%8E%92%E5%BA%8F%E6%8F%90%E9%AB%98%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E5%AE%9E%E6%88%98%E8%AF%BE/1510%E6%8C%89%E6%8C%87%E5%AE%9A%E9%A1%BA%E5%BA%8F%E7%BB%99%E8%AF%8D%E8%AF%AD%E6%8E%92%E5%BA%8F%E6%8F%90%E9%AB%98%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="1510｜按指定顺序给词语排序提高查找效率">
  <meta property="og:description" content="10｜按指定顺序给词语排序，提高查找效率
你好，我是尹会生。
之前我在游戏行业工作的时候，经常需要取得用户在线时长 TOP3、用户战斗力 TOP5、用户完成任务数量 TOP10 等数据，相信你在工作中也会有遇到从大量数据取得 TopN 这类需求。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Python自动化办公实战课">

  <meta itemprop="name" content="1510｜按指定顺序给词语排序提高查找效率">
  <meta itemprop="description" content="10｜按指定顺序给词语排序，提高查找效率
你好，我是尹会生。
之前我在游戏行业工作的时候，经常需要取得用户在线时长 TOP3、用户战斗力 TOP5、用户完成任务数量 TOP10 等数据，相信你在工作中也会有遇到从大量数据取得 TopN 这类需求。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5379">
  <meta itemprop="keywords" content="Python自动化办公实战课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="1510｜按指定顺序给词语排序提高查找效率">
  <meta name="twitter:description" content="10｜按指定顺序给词语排序，提高查找效率
你好，我是尹会生。
之前我在游戏行业工作的时候，经常需要取得用户在线时长 TOP3、用户战斗力 TOP5、用户完成任务数量 TOP10 等数据，相信你在工作中也会有遇到从大量数据取得 TopN 这类需求。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">1510｜按指定顺序给词语排序提高查找效率</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5379 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>10｜按指定顺序给词语排序，提高查找效率</p>
<p>你好，我是尹会生。</p>
<p>之前我在游戏行业工作的时候，经常需要取得用户在线时长 TOP3、用户战斗力 TOP5、用户完成任务数量 TOP10 等数据，相信你在工作中也会有遇到从大量数据取得 TopN 这类需求。</p>
<p>提取 TopN 的操作，本质上是对大量数据先进行排序，然后根据排序的结果取出前 N 个值。而实现提取 TopN 的值，用 Python 来实现会非常高效，这节课，我就来讲一讲具体怎么操作。</p>
<p>使用 sorted() 函数实现排序</p>
<p>在 Python 中，已经内置了排序函数 sorted() 函数，它是 Python 中实现排序最简单且最直接的形式，可以解决 80% 的排序问题。那么，我们就来学习一下怎么用 sorted() 函数对常见的数据类型进行排序。</p>
<p>先看 sorted() 函数的定义。</p>
<p><code>sorted(iterable, cmp=None, key=None, reverse=False)</code></p>
<p>sorted 函数共有四个参数，第一个参数是要排序的对象，后面三个参数是排序的方式。</p>
<p>如果要为某个对象排序的话，你可以直接将它作为 sorted() 函数的第一个参数，返回结果会将对象的值进行从小到大的排序。</p>
<p>如果 sorted() 返回的排序结果不满足你的需要，比如你想要从大到小的排序，那你就可以利用后面三个参数来改变排序的方式，实现自定义排序。</p>
<p>所以今天这节课，我会带你学习怎么使用 sorted() 函数实现默认排序和自定义排序，来解决你实际工作中遇到的多种排序问题。我们先来看怎么使用 sorted() 实现默认排序。</p>
<p>默认排序</p>
<p>sorted() 函数的默认排序是按照从小到大的顺序进行排序的。例如一家公司即将上市，需要在职的前 1000 名员工的工号和姓名，工号越小的员工配股越多。这时候就需要给所有员工的工号进行排序，并取得工号排在前 1000 个员工的名字。具体怎么做呢？</p>
<p>我们来看 sorted() 函数的用法。我们从它的第一个参数开始学习。第一个参数是 sorted() 函数要排序的对象，我以列表为例，把员工的工号放到列表中，我们来看一下 sorted() 函数是怎么对列表中的工号进行从小到大的排序的。</p>
<p><code>sorted\_list = sorted(\[30, 50, 20, 10, 40\])print(sorted\_list)\# \[10, 20, 30, 40, 50\]</code></p>
<p>我在代码中给 sorted() 函数指定了一个列表类型的参数“[30, 50, 20, 10, 40]”。按照 sorted() 函数的定义，这个列表会被 sorted() 函数按照数字从小到大进行排序，并返回排序后的结果。并且，我把结果放入 sorted_list 对象中，你从代码中可以看到 sorted_list 已经把数据按照默认从小到大的顺序排列好，并把结果放在一个列表数据类型中。</p>
<p>这就是 sorted() 的基本用法，其实是比较简单的，不过这里有三点需要你注意。</p>
<p>首先，sorted() 函数的默认排序方式是从小到大进行排序，那么对于列表中的数字就会按照默认的算法进行大小比较。但是除了数字外，列表中还会出现字母或字母与数字混合的方式，你也需要掌握这两种方式的排序处理方法。</p>
<p>比如说英文字母，会按照列表中字符串的第一个字母从 A 到 Z、从 a 到 z 进行排序。如果字符串的第一个字母相同，就会比较第二个字母，以此类推，直到比较完字符串中的所有字符。</p>
<p>由于默认排序的时候不支持同时对英文字母和数字进行排序，那么如果列表中既包含了字母，又包含了数字，在默认排序时程序就会提示一个异常，那就是无法使用“&lt;”比较整数和字符串。</p>
<p><code>TypeError: '&lt;' not supported between instances of 'int' and 'str'</code></p>
<p>因此，当列表中出现类似“[&ldquo;a&rdquo;, 1, &ldquo;bb&rdquo;]”这种，既包含字符串又包含数字的列表，进行排序操作的时候，你需要先统一类型，把数字使用 str() 函数转换为字符串类型，再对列表进行排序。我把代码写出来，供你参考：</p>
<p><code>sorted\_list2 = sorted(\[&quot;a&quot;, str(1), &quot;bb&quot;\])print(sorted\_list2)</code></p>
<p>其次，你需要注意，sorted() 函数不会对原有的列表进行修改，它会把排序好的结果存入到一个新的列表当中。</p>
<p>很多人刚开始使用 Python 时，会把 sorted() 函数和列表自带的函数 sort() 函数混淆。</p>
<p>它们虽然名字很像，但支持的数据类型、调用的方式以及返回的结果都不同。</p>
<p>要记住，sort() 函数是列表数据类型自带的，所以只能对列表数据类型进行排序，不能对其他数据类型排序，但 sorted() 函数可以支持任何可迭代的对象。</p>
<p>在调用方式上，sort() 函数使用的方式是“列表.sort()”格式，这也是调用时和 sorted() 函数的差别。</p>
<p>还有一个最大的差别是，sort() 函数会直接修改当前列表（这种修改称作“原地修改”），并返回一个空值 None。而 sorted() 函数不会对原有的列表进行修改，它会把排序好的结果存入到一个新的列表当中。</p>
<p>为了让你更好地区分 sorted() 函数和 sort() 函数，我把 sort() 函数的执行结果也提供给你做参考。</p>
<p><code>list3 = \[&quot;a&quot;, &quot;c&quot;, &quot;bb&quot;\]no\_value = list3.sort()print(list3)\# \['a', 'bb', 'c'\]  执行结果print(no\_value)\# None  执行结果</code></p>
<p>在代码的第二行，是 sort() 函数的调用格式。在第三行，我输出了排序之后的列表，并对列表的值进行了重新排序。在第五行，我们可以看到 no_value 变量的返回值为 None，也就是 sort() 函数会对列表进行原地修改，并使用 None 作为返回。</p>
<p>最后，你需要注意 sorted() 函数能够支持的数据类型非常多，既能支持基础数据类型，又能支持 Python 自带的内置函数。根据它的函数定义，第一个参数是“iterable”对象，表示只要该对象可迭代，sorted() 函数就能对它进行排序。</p>
<p>在基本数据类型中，序列和映射都可以迭代，序列是指列表、元组、字符串这三种基本数据类型的总称，映射就是我们使用过的字典。除了基本数据类型之外，像是 range() 、map()、zip() 等内置函数都是可迭代对象，因此掌握 sorted() 函数，可以对以上多种类型和函数进行排序。</p>
<p>掌握了这三点注意事项，在使用 sorted() 为可迭代类型进行排序时，就不会出现什么问题了。那接下来，我来带你学习一下它的自定义排序功能，通过自定义排序，可以让 sorted() 基于不同的数据类型实现更加灵活的排序。</p>
<p>自定义排序</p>
<p>自定义排序是在基本排序基础上，能够支持更多的排序方式和更复杂的数据类型。比如说：</p>
<p>在排序方式上，我们通过参数，可以把默认的从小到大的排序改为从大到小。</p>
<p>在对数据类型的支持上，像列表中包含元组这种复杂数据类型，可以通过指定元组的任意一列进行排序。</p>
<p>我们先学习自定义排序是怎么支持更多的排序方式的，它的前提是要先更改默认的排序方式。</p>
<p>例如我想要实现列表的从大到小的排序，并提取 Top 3 这一需求，我首先需要使用函数的第四个参数 reverse 参数改变默认的排序方式，排序后我需要使用列表的切片方式提取前三个元素。</p>
<p>我先把代码写出来，然后再给你详细解释。可以看到，我在代码中使用了 sorted_list4 作为排序后的结果，并对 sorted_list4 进行切片，从而得到指定下标对应的值。</p>
<p><code>sorted\_list4 = sorted(\[30, 50, 20, 10, 40\], reverse=True)print(sorted\_list4\[:3\])\# \[50, 40, 30\]</code></p>
<p>在代码中，我为 sorted() 函数增加了参数 reverse。reverse 参数在定义的时候是 sorted() 函数的第四个参数，由于 sorted() 函数的第二、三个参数我希望保持默认，不需要在调用的时候传入，因此 reverse 参数在调用时就要作为第二个参数来使用。</p>
<p>由于在调用时它的位置和定义的位置不同，那么我必须使用关键字参数 “reverse=True”的形式，把 reverse 指定为 sorted() 函数的第二个参数。</p>
<p>增加 reverse 参数之后，sorted() 执行的结果也和默认结果不同，sorted 会将默认排序的结果进行反转。而当五个数字的排序结果反转后，也就以从大到小的方式进行了输出。</p>
<p>你看，利用 sorted() 函数的 reverse 参数就能实现 TopN 场景的排序工作，工作中往往需要只得到 TopN 的结果，不需要将全部的排序结果进行输出，这时候你可以将列表按照你的工作需要提取其中的某一部分，这种操作也被称作列表的切片。</p>
<p>假如你想取得 sorted_list4 列表的 Top3 元素，可以对列表排序后，使用 sorted_list4[0:3]的写法提取列表前三个值，这种写法的“0”“3”表示列表的下标，“:”表示获取下标的范围。因为列表的下标从 0 开始，因此要写作[0:3]的形式，也可以使用它的省略形式[:3]，这样列表切片操作就会从 0 开始取值。</p>
<p>总结来说，通过 reverse 参数和列表切片，我们可以在默认排序的基础上，实现基于列表的 TopN 场景下的排序，以及 TopN 结果的提取。</p>
<p>不过现实场景往往都是比较复杂的，要排序的数据类型除了列表中包含数字和字符串外，你最经常见到的还有对列表中包含元组这种复合类型进行排序，以及对字典的键或值进行排序。接下来我来带你学习一下两种主要类型，一种是列表 + 元祖的类型，一种是字典类型。</p>
<p>列表 + 元组的排序方式</p>
<p>列表 + 元组形成的组合数据类型，适合存放包含多个属性的对象。我给你看个例子，</p>
<p>“姓名、性别、身份证号”和“学校、姓名、学号”这两组数据就适合用元组存储。因为元组存储的值是不可变的，而这些数据填入之后一般不会修改，刚好和元组的特性吻合。</p>
<p>而且，这些用户信息在工作中往往会被大量存储在一起，为了便于对它们进行排序和查找。你还需要将多个元组再保存到列表当中，这样就形成了列表 + 元组这种组合类型。</p>
<p>对列表 + 元组的形式进行排序，就需要用自定义排序的字段来实现。那就是在默认排序的基础上，增加 key 参数，并通过 lambda 表达式取得元组第三个位置的学号。</p>
<p>lambda 表达式是简化自定义函数的定义和调用而使用的一种语法，使用 lambda 表达式取得学号的字符串之后，sortd() 就可以实现对元组按照学号进行排序了。</p>
<p>在这里，key 没法通过下标对元组排序，而必须通过函数取得参数具体的值。这是 sorted() 函数为了更灵活地实现排序功能，把设置排序关键字这一功能全部开放给用户造成的。事实上，这也是一种典型的通过牺牲易用性来增加灵活性的设计模式。</p>
<p>这一知识点比较难理解，不过不用担心，我在后续课程陆续为你讲解这类函数，直到你能熟练使用它们为止。</p>
<p>到这里，我们就了解了 sorted() 函数的 key 参数必须使用函数做参数的原因，那就继续来看 key 参数的 lambda 表达式是怎么简化自定义函数的。</p>
<p>比如我想取得元组中包含“Jerry”的学号“1003”，以及包含“Tom”的元组学号的“1005”，可以使用这样一段代码来实现函数定义和调用方式：</p>
<p><code>def s(my\_tuple):    return my\_tuple\[2\]sorted(students, key=s)sorted(students, key=lambda s: s\[2\])</code></p>
<p>在代码的 1-3 行、第 5 行，分别是通过自定义函数和 lambda 表达式实现的提取元组第三个参数的功能。对比来看，自定义函数的定义要比 lambda 表达式复杂。自定义函数的定义和调用部分在 Python 中要分开编写，这也是简单函数更适合用 lambda 表达式编写的原因。</p>
<p>lambda 表达式通常在函数只有一行语句，且不需要强调函数名称的时候使用，因此它还有一个名字叫做匿名函数。它的结构只包含四部分，即lambda 关键字、需要接收的参数、一个冒号和对接收参数的处理，并且它会把处理结果自动返回。</p>
<p>因此在 sorted() 函数中通过 lambda 表达式实现按关键字排序，会比使用自定义函数排序更加简洁，所以当你遇到只有一行语句的函数场景时，可以考虑使用 lambda 表达式替代自定义函数的定义和调用。</p>
<p>字典类型的排序方式</p>
<p>除了列表 + 元组的复合类型外，我们经常还需要对字典类型进行排序，字典类型包含键和值，所以排序的时候可以基于键来排序，也可以基于值来排序。</p>
<p>我们还是以学生信息为例。我把学生的姓名定义为字典的键，把学号定义为字典的值。接下来我们看看 sorted() 是怎么对字典的键和值进行排序的，实现排序的代码如下：</p>
<p><code>student\_dict1 = {'Jerry':'1003',                  'Tom':'1005',                  'Beta':'2001',                  'Shuke':'2003'}\# 输出字典的键和值print(student\_dict1.items())\# dict\_items(\[('Jerry', '1003'), ('Tom', '1005'), ('Beta', '2001'), ('Shuke', '2003')\])\# 按照字典的键排序print(sorted(student\_dict1.items(), key=lambda d: d\[0\]))\# \[('Beta', '2001'), ('Jerry', '1003'), ('Shuke', '2003'), ('Tom', '1005')\]\# 按照字典的值排序result = sorted(student\_dict1.items(), key=lambda d: d\[1\])print(result)\[('Jerry', '1003'), ('Tom', '1005'), ('Beta', '2001'), ('Shuke', '2003')\]\# 将结果转换为字典print(dict(result))\# {'Jerry': '1003', 'Tom': '1005', 'Beta': '2001', 'Shuke': '2003'}</code></p>
<p>在这段代码中，我实现了基于字典的键和字典的值进行排序的功能。由于字典是使用键值对的形式存储数据的，所以我先通过字典自带的函数 items()，把键值对的形式转换成列表 + 元组的形式。经过转换以后，字典的键就变成了元组的第一个参数，值就变成了元组的第二个参数。</p>
<p>因此在代码中，我把参数 key 的值设置为“lambda d: d[0]”，这样就取得了元组的第一个元素，排序之后就实现了按照字典的键进行排序的需求。相应的，使用“lambda d: d[1]”，可以取得元组第二个元素的值，就能实现按照字典的值进行排序的需求。</p>
<p>由于排序后的数据类型已经变成了列表 + 元组形式。所以我们在代码最后，可以通过 dict() 函数把排序的结果再转换为字典，和排序前的数据类型保持一致。</p>
<p>这就是通过 sorted() 函数对字典进行排序的解决方法，你在工作中或许还会遇到和这节课不一样的数据类型，但是它们的解决思路是相通的。</p>
<p>如果能转换成列表，可以采用更改 lambda 下标的方式，实现对指定字段的排序。</p>
<p>如果不能转换成列表，可以尝试将复杂的类型中，不需要进行排序的部分进行删减，简化成列表或字典类型，这样就也能使用 sorted 实现数据的排序功能了。</p>
<p>小结</p>
<p>最后，我来给你总结一下这节课的核心内容。我们通过 sorted() 函数实现了列表、列表 + 元组、字典类型的排序，通过排序后的结果，你可以快速提取 TopN，也可以利用你学习过的其他语言的算法实现更复杂的查找。</p>
<p>在 sorted() 函数中，我们通过编写 key 参数的值，使用了 lambda 表达式替代了简单的函数，让我们的程序更加简洁。当你在日后的工作场景中也出现了只有单个语句的函数时，也可以考虑采用 lambda 表达式替代自定义函数，增加代码的可读性。</p>
<p>正是因为 sorted() 功能的强大，我们在 python 中实现排序几乎不需要通过自行编写代码来实现排序，不过你在进行海量数据的时候，我还想给你提供两条有用的建议。</p>
<p>第一，如果对包含海量数据的列表进行排序时，建议将列表通过 tuple() 函数转换为元组，能够让查找效率有较大提升。</p>
<p>第二，在 Python 标准库 collections 库中提供了 OrderedDict 扩展数据类型，它的特点是对 OrderedDict 数据类型进行赋值时，会自动进行排序。当你需要一个有序字典时，可以考虑选择 OrderedDict 作为数据存储的类型，从而避免手工对数据排序。</p>
<p>我也把这节课的相关代码放在了GitHub上，你可以去学习查找。</p>
<p>思考题</p>
<p>在最后，我想给你留一道开放性的问题。为什么 Python 语言不将所有的数据类型都设计成默认有序的，即存入数据时自动进行排序？欢迎你说出自己的理由。</p>
<p>欢迎把你对问题的思考和想法分享在留言区，我们一起交流讨论。如果课程帮你解决了一些工作上的问题，也欢迎你把课程分享给你的朋友、同事。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E5%AE%9E%E6%88%98%E8%AF%BE/">Python自动化办公实战课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/kubernetes%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/15prometheukubernete%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">15Prometheu：Kubernete怎样实现自动化服务监控告警？</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/1511%E5%8F%AC%E5%9B%9E%E5%B1%82%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%8F%88%E5%87%86%E7%A1%AE%E5%9C%B0%E7%AD%9B%E9%80%89%E6%8E%89%E4%B8%8D%E7%9B%B8%E5%85%B3%E7%89%A9%E5%93%81/">
            <span class="next-text nav-default">1511｜召回层如何快速又准确地筛选掉不相关物品</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
