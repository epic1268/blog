<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>2116｜循环与文件目录管理如何实现文件的批量重命名 - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="16｜循环与文件目录管理：如何实现文件的批量重命名？
你好，我是尹会生。
作为产品经理 / 运营，你经常需要做竞品调研，来跟自家产品对比优劣。这时，你就需要下载大量与该类产品相关的图片，并进行整理归类。而归类操作中，必须要走的一步就是对这些图片进行重命名。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E5%AE%9E%E6%88%98%E8%AF%BE/2116%E5%BE%AA%E7%8E%AF%E4%B8%8E%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E5%AE%9E%E6%88%98%E8%AF%BE/2116%E5%BE%AA%E7%8E%AF%E4%B8%8E%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="2116｜循环与文件目录管理如何实现文件的批量重命名">
  <meta property="og:description" content="16｜循环与文件目录管理：如何实现文件的批量重命名？
你好，我是尹会生。
作为产品经理 / 运营，你经常需要做竞品调研，来跟自家产品对比优劣。这时，你就需要下载大量与该类产品相关的图片，并进行整理归类。而归类操作中，必须要走的一步就是对这些图片进行重命名。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="Python自动化办公实战课">

  <meta itemprop="name" content="2116｜循环与文件目录管理如何实现文件的批量重命名">
  <meta itemprop="description" content="16｜循环与文件目录管理：如何实现文件的批量重命名？
你好，我是尹会生。
作为产品经理 / 运营，你经常需要做竞品调研，来跟自家产品对比优劣。这时，你就需要下载大量与该类产品相关的图片，并进行整理归类。而归类操作中，必须要走的一步就是对这些图片进行重命名。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="5936">
  <meta itemprop="keywords" content="Python自动化办公实战课">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="2116｜循环与文件目录管理如何实现文件的批量重命名">
  <meta name="twitter:description" content="16｜循环与文件目录管理：如何实现文件的批量重命名？
你好，我是尹会生。
作为产品经理 / 运营，你经常需要做竞品调研，来跟自家产品对比优劣。这时，你就需要下载大量与该类产品相关的图片，并进行整理归类。而归类操作中，必须要走的一步就是对这些图片进行重命名。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">2116｜循环与文件目录管理如何实现文件的批量重命名</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 5936 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>16｜循环与文件目录管理：如何实现文件的批量重命名？</p>
<p>你好，我是尹会生。</p>
<p>作为产品经理 / 运营，你经常需要做竞品调研，来跟自家产品对比优劣。这时，你就需要下载大量与该类产品相关的图片，并进行整理归类。而归类操作中，必须要走的一步就是对这些图片进行重命名。</p>
<p>还有你在搜集资料时，往往会从网络中下载大量不同格式的文件，比如电子书、视频、音频等，为了方便归纳整理，你也需要对文件进行重命名。</p>
<p>通过我例举的这两个场景，你应该发现了，这些需求都是把批量改名和网络功能结合，而且还需要 Mac 和 Windows 系统支持重命名。那怎么来实现批量重命名的操作呢？</p>
<p>如果你还记得上节课的内容，肯定会说，使用 PowerShell 就可以了。不过你要是对 PowerShell 相关知识掌握得扎实的话，也会记得我说过，PowerShell 适合在 Windows 平台下独立运行的临时性任务。所以在非 Windows 系统，以及需要和网络下载功能结合的需求上，它就没有 Python 的兼容性好。</p>
<p>那么今天这节课，我会带你回到 Python，使用 Python 来实现文件的批量重命名。</p>
<p>如何使用 os 库实现文件批量重命名</p>
<p>还是老规矩，我们学习一个新的功能，首先要学习它所需要的 Python 库和函数。</p>
<p>例如，我把友商的产品介绍图片，通过网络批量下载后，存放在“/Users/user1/Desktop/pic”文件夹中，这些文件名称长短不一，那我希望能从数字 1 开始，为它们批量重命名。</p>
<p>在第 15 节课我就说了，重命名是一种贴近操作系统层面的操作。因此在 Python 标准库中，我把“文件”和“操作系统”作为关键字，从官方文档中找到了“os”库，os 库中包含了操作系统相关的操作。通过“os”库，你就可以轻松取得三个批量重命名必备操作，那就是目录中的文件名、文件名后缀处理以及文件改名。</p>
<p>那我先把批量重命名的代码提供给你，让你更直观地理解运行过程，然后再来帮你分析这三个操作是怎么通过 os 库实现的。</p>
<p><code>import os\# 保存图片的目录file\_path = &quot;/Users/user1/Desktop/pic&quot;\# 需要批量重命名的扩展名old\_ext = &quot;.jpg&quot;\# 取得指定文件夹下的文件列表old\_names = os.listdir(file\_path)\# 新文件名称从1开始new\_name = 1\# 取得所有的文件名for old\_name in old\_names:    # 根据扩展名，判断文件是否需要改名    if old\_name.endswith(old\_ext):        # 完整的文件路径        old\_path = os.path.join(file\_path, old\_name)        # 新的文件名        new\_path = os.path.join(file\_path, str(new\_name)+&quot;.JPG&quot;)               # 重命名        os.rename(old\_path, new\_path)        # 文件名数字加1        new\_name = int(new\_name)+1\# 显示改名后的结果print(os.listdir(file\_path))</code></p>
<p>这段代码会把&quot;/Users/user1/Desktop/pic&quot;目录中“jpg”扩展名的文件进行重命名，把它们分别命名为“1.jpg”，“2.jpg”，“3.jpg”，以此类推。</p>
<p>那批量改名的这三个操作具体是怎么实现的呢？其实是通过 os 库中的三个函数来实现的，分别是 listdir()、path.join() 、rename()。这是你在这节课要掌握的重点，我也会着重讲解。</p>
<p>第一个是 listdir() 函数，它的功能是打印指定目录下的文件名称。如果再给这个函数指定一个参数 file_path，那么它会把 file_path 中的所有文件名称以一个列表的类型返回。使用列表类型方便后续迭代，便于进行单个文件改名。</p>
<p>为了只对“.jpg”扩展名的文件改名，我使用了 endswith() 函数对列表进一步筛选，过滤掉不需要改名的文件。</p>
<p>第二个是 path.join() 函数，它可以连接路径和文件名，从而得到一个带有完整路径的文件名称格式。这里我要给你着重强调一下，改名操作必须要指定文件正确的路径，因此改名前必须要进行路径和文件名的连接。</p>
<p>最后是改名函数 rename() 函数，它的两个参数分别为改名前文件的路径 + 文件名和改名后文件的路径 + 文件名，均为 path.join() 函数处理过的完整文件名称。通过 rename() 函数改名后，文件名称会自动变为新的文件名称。</p>
<p>将上面三个操作放入 for 循环语句中，就能实现批量重命名的功能。</p>
<p>这一段代码虽然功能正常，但是继续增加新功能时，必然要再增加新的代码，如果只是按照执行的前后顺序把多个不同功能的代码写入一个文件，它的可读性会变差，别人阅读你写的代码就会有障碍。</p>
<p>就像我们从超市购买的各类商品一样，你一定会把调料放在厨房、把鸡蛋放在冰箱、把袜子放在衣柜，对商品分门别类放置，绝不会按照购买的时间顺序摆放在你的房间中。</p>
<p>同理，代码的摆放位置，也不应该按照执行顺序依次存放。正确的做法是，你要把每一组功能相同或相近的代码写入到一个函数中，并把该功能中经常变动的部分作为函数的参数，乃至整个脚本的参数，这样才能给有多个功能的脚本带来更好的阅读体验。代码的整洁程度高，也为你排除代码的故障带来更高的效率。</p>
<p>那么接下来，我就教你怎么重构批量改名脚本，提高代码的可读性。</p>
<p>重构程序</p>
<p>首先，我来带你学习一下什么是重构代码，以及怎么重构代码。</p>
<p>重构代码是指在代码可以正常实现的前提下，为了提高它的可维护性，需要对代码的结构进一步调整。就像你需要定期收拾房间一样，代码也需要进行维护。特别是经常修改和添加新的功能的代码，它的逻辑结构会像你炒菜之后的厨房一样，越来越混乱，为了代码和代码之间的逻辑关系更清晰，你需要掌握如何调整代码的结构。</p>
<p>我来给你举个例子，比如我在批量改名的程序中又增加了新的需求，要求将改名的路径和扩展名从变量赋值改为从命令行参数赋值。这样就不用进入到脚本中修改代码了。</p>
<p>根据这个新的需求，你会发现，当前的代码有 3 个地方需要调整。</p>
<p>第一个是代码的结构层次需要调整。当前的代码只包含了一个批量改名的功能，当你再为代码增加命令行参数处理功能时，新的代码和当前代码放在一起，会破坏改名功能的完整性，这时候，你就可以把每个功能单独放在一个函数中，通过函数来让一个功能和另一个功能代码相互独立。</p>
<p>第二个是代码开始执行的位置需要调整。由于函数定义的代码块会在函数调用以后才运行，但是根据 Python 的语法，你必须将函数定义写在函数调用的上方，这就导致了代码开始执行的位置出现在文件的中间和结尾。所以我需要一个更明显的标记，告诉阅读代码的人，从该位置开始阅读代码，该位置才是代码执行的第一条语句，而不是让阅读的人从代码文件开头一行以后的找程序的入口。</p>
<p>第三个是命令行参数的处理需要调整。由于 Python 默认是不去处理命令行的参数的，因此我们需要增加一个专门处理命令行参数的函数，来读取用户输入的正确参数，而对错误的参数，则需要提示用户。</p>
<p>这三个地方的调整，我会依次采用函数、内置变量和命令行参数来实现对代码的重构，我来依次带你看一下优化的具体代码。</p>
<p>封装到函数</p>
<p>为了让代码结构逻辑更加工整，我把每一个独立的功能都放入到单独的函数中。每个函数组成的语句块，就像自然段一样，将一整篇文章，按照功能进行了划分。由于当前的代码只有批量改名这一个功能，所以我就把改名功能的所有代码都放到一个函数当中。</p>
<p>封装函数的时候，一个是要考虑功能的完整性，另一个要考虑函数用到的其他变量如何与它进行交互。调用函数时使用参数，就是函数和其他变量交互最好的办法。</p>
<p>对于批量改名这一功能，主要交互的对象有两个，它们是批量改名的路径，以及要修改的文件扩展名。所以我就把这两个对象作为改名函数 rename() 函数的参数，rename() 函数得到这两个参数后，会按照函数的定义，把这两个参数传入 rename() 函数中实现改名的逻辑，对文件进行批量改名。封装之后的核心代码如下：</p>
<p><code>def rename(file\_path, old\_ext):  # 批量改名的代码  ... ...rename(&quot;/Users/user1/Desktop/pic&quot;, &quot;.jpg&quot;)</code></p>
<p>这段代码实现的功能和没有重构之前完全相同，都是对指定目录的指定扩展名文件进行批量重命名。但是在代码结构上，要比直接在文件实现的代码逻辑更清晰，可以看到，改名功能被放在函数定义中，执行的时候就可以直接调用 rename() 函数。</p>
<p>将改名功能封装为函数的好处就是，代码更工整了，新的功能也可以继续采用函数的形式添加到当前代码中。比起把所有代码按执行顺序都写在一个文件中，这样的格式会让你更容易区分开代码中的每一个功能。</p>
<p>明确执行位置</p>
<p>把批量改名的功能封装为函数之后，对程序的执行顺序也会带来一些变化。我把前后变化给你做个对比：</p>
<p>封装函数之前，程序的执行顺序是导入库之后依次执行。</p>
<p>封装为函数之后，执行顺序就变为导入库之后，就开始执行 rename() 函数的调用。</p>
<p>当这个脚本再陆续添加新的函数的话，那么找到哪一行是脚本第一个执行的命令，就非常麻烦了。因此在 Python 中有一个参考 C 语言设置代码入口的方法，让你能快速定位代码是从哪一行开始执行的。这个方法就是通过对内置变量“name”的值进行判断，判断它是不是和字符串“main” 相等。</p>
<p>在 Python 中，执行代码的方式有两种。</p>
<p>一种是单独运行，也就是用 Python 加脚本的名称方式运行。</p>
<p>另一种方式是把.py 结尾的脚本文件作为自定义的模块使用“import”关键字导入，导入后通过“模块. 函数 ()”的格式运行。</p>
<p>如果一个脚本文件独立运行，那么它的内置变量“name”的值就是“main”，通过“if name == &ldquo;main&rdquo;” 的判断，结果必然为 True，则该判断逻辑下的代码块就会执行。如果作为模块导入，那么“name”的值就是 False，则不被执行。</p>
<p>我们可以把函数的调用全部放入 “if name == &ldquo;main&rdquo;”语句块中，这样就可以指定这条 if 语句作为代码单独运行的入口，既方便你快速找到入口对程序进行修改，又方便你把它作为其他程序的模块进行导入。</p>
<p>我把实现对“name”变量判断的脚本写在下方，你可以对照代码学习。</p>
<p><code>def rename():   ... ...def func1():   ... ...def func2():   ... ...def func3():   ... ...\# func1() # 在\_\_name\_\_之外执行，不推荐if \_\_name\_\_ == &quot;\_\_main\_\_&quot;:    func3()    rename(&quot;/Users/edz/Desktop/pic&quot;, &quot;.jpg&quot;)    func1()    func2()</code></p>
<p>在代码中，我定义了 4 个函数，对于四个函数的调用，都放在了 “if name == &ldquo;main&rdquo;”语句块中。在使用这种方式设置程序入口时，有两点需要你特别注意。</p>
<p>一方面，这种设置方法是人为指定程序入口，因此你需要把代码中所有函数调用都放在 if 语句块下，这样才能实现作为入口的功能。虽然放在 if 语句块之外也可以运行，但函数调用写在 if 语句块之外，就很容易给代码阅读带来障碍。</p>
<p>另一方面，使用“name” 作为入口的判断变量，只能在单独运行的时候才为&quot;main&quot;，如果使用 Python 交互方式执行，就无法对“name” 变量进行判断。</p>
<p>我们通过指定代码的入口，让程序的逻辑更加清晰。那么接下来就是为这段代码添加命令行参数，在不修改代码的前提下，通过命令行参数来设置批量改名的目录和扩展名。</p>
<p>命令行参数处理</p>
<p>使用命令行参数的优点，就是在调用脚本的时候一并传入要操作的对象，这会比修改配置文件和变量更直接。那么在原有代码基础上，我们还需要增加两个参数，也就是要操作的目录和扩展名，并使用 argparse 库实现对这两个参数的处理。</p>
<p>参数处理是一个比较笼统的概念，它包括参数的接收、参数数量的判断和参数的解析三个部分。“argparse”库是命令行解析模块，它负责在脚本运行时，接收和处理脚本执行时的参数。</p>
<p>首先是参数的接收，在本讲之前，我们执行 Python 脚本的方式是：</p>
<p><code>python3 脚本名称.py</code></p>
<p>在脚本中使用“argparse”库后，脚本能够支持在该命令后面增加参数，并在脚本内获取参数的内容。哪些参数能够被脚本处理，需要使用 argparse 库的 add_argument() 函数指定。</p>
<p>接下来是参数的判断，add_argument() 函数可以接收两种参数格式，分别是“-”和“&ndash;”，后面再跟着英文。按照惯例，一个“-”一般后面会使用单个英文字母， 两个“&ndash;”后面是完整名称。</p>
<p>以对目录改名的参数为例，我需要接收“-p”或“&ndash;path”两种形式的参数指定的方法是：</p>
<p><code>add\_argument(&quot;-p&quot;, &quot;--path&quot;, required=True, help=&quot;path to rename&quot;)</code></p>
<p>同时，我还为“&ndash;path”参数所在的 add_argument() 增加了两个额外的参数，一个是要求用户执行程序，必须输入“-p”或“&ndash;path”，如果执行不指定会报错的 required 参数。</p>
<p>另一个“-p”或“&ndash;path”参数含义的帮助信息“help”参数。</p>
<p>增加参数处理后，如果你没有输入完整参数，argparse 库会自报错，并提示你如何正确使用该脚本的参数。你也可以直接使用“-h”得到执行帮助。</p>
<p>我把参数输入不完整和通过 -h 获取帮助的执行结果，贴在下面供你学习。</p>
<p><code>SHELL$ python3 rename\_v2.py -p /path/to/rename/files -eusage: rename\_v2.py \[-h\] -p PATH -e EXTrename\_v2.py: error: argument -e/--ext: expected one argumentSHELL$ python3 rename\_v2.py -husage: rename\_v2.py \[-h\] -p PATH -e EXToptional arguments:  -h, --help            show this help message and exit  -p PATH, --path PATH  path to rename  -e EXT, --ext EXT     files name extension, eg: jpg</code></p>
<p>最后是参数的解析，它是在参数数量正确的前提下自动完成的。完成解析后，会以“&ndash;path”参数后的英文字面“path”作为属性名称，以“&ndash;path”后面的参数，作为属性值。</p>
<p>比如我在取得用户参数后，就可以使用“args.path”来得到命令行“-p”参数后面参数的值，以及使用“args.ext”得到“-e”参数后面参数的值。此外，我还把这两个属性作为批量改名函数 rename() 函数的参数，这样就可以把命令行参数作为重命名函数的参数使用了。</p>
<p>获取命令行参数的核心代码我也为你整理了出来，放在下方供你参考：</p>
<p><code>import osimport argparsedef rename(file\_path, old\_ext):  &quot;&quot;&quot;批量改名函数&quot;&quot;&quot;  ... ...def args\_opt():  &quot;&quot;&quot;获取命令行参数函数&quot;&quot;&quot;      #定义参数对象    parser = argparse.ArgumentParser()        # 增加参数选项、是否必须、帮助信息    parser.add\_argument(&quot;-p&quot;, &quot;--path&quot;, required=True, help=&quot;path to rename&quot;)    parser.add\_argument(&quot;-e&quot;, &quot;--ext&quot;, required=True, help=&quot;files name extension, eg: jpg&quot;)        # 返回取得的所有参数    return  parser.parse\_args()if \_\_name\_\_ == &quot;\_\_main\_\_&quot;:    # args 对象包含所有参数，属性是命令行参数的完整名称    args = args\_opt()        # 调用重命名函数，将命令行参数作为重命名函数的参数    rename(args.path, &quot;.&quot;+args.ext)        # 输出改名之后的结果    print(os.listdir(args.path))</code></p>
<p>通过重构后，代码的整体结构就变成了导入库、函数定义、函数调用三个部分，对经常需要变动的替换路径和扩展名，也从修改变量改为命令行参数，无论从阅读代码还是后续继续扩展代码，整体结构都要比顺序执行代码逻辑更清晰。</p>
<p>小结</p>
<p>最后让我来为你总结一下，这一讲我为你讲解了使用 Python 如何实现批量改名，以及如何对越写越长的代码进行重构。</p>
<p>批量改名属于操作系统中的文件相关操作，这类功能在编程语言中往往会提供事先定义好的编程接口，无需自己实现从应用层到操作系统的全部代码，建议你在遇到这类需求时，先从标准库中搜索相关模块，再从第三方库搜索，尽量避免手工编写，提高工作效率。</p>
<p>为了让批量改名的脚本逻辑更清晰，也更方便执行，我对代码还进行了三个方面的重构：</p>
<p>通过使用函数增加代码的逻辑性。</p>
<p>通过“name”变量增加了程序入口，便于你直接找到程序开始执行的位置。</p>
<p>通过增加命令行参数，让你不用修改代码，就能实现函数的参数的修改。</p>
<p>增加程序的可读性、提高执行便利性也能为以后编写代码效率提升带来改进，这些改进会在后续章节代码越来越多的时候起到更明显的效果。</p>
<p>我把这节课的相关代码都放在了 GitHub 上，供你学习参考。</p>
<p>思考题</p>
<p>最后我来为你留一道比较有趣的思考题，你能否通过命令行为代码指定两个参数，当这两个参数为整数时，脚本自动计算这两个参数的“和”和“差”，并将执行结果打印到屏幕上。</p>
<p>欢迎把你的思考和想法写在评论区，我们一起交流讨论。此外，你还可以点击课程详情页的“戳我进群”，然后扫描二维码，加入我们的课程读者群，我也会在群里为你解疑答惑。我们下节课再见！</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E5%AE%9E%E6%88%98%E8%AF%BE/">Python自动化办公实战课</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%BA%E7%9A%84%E8%8B%B1%E8%AF%AD%E7%A7%81%E6%95%99%E8%AF%BE/21%E4%BD%A0%E5%92%8C%E6%89%80%E6%9C%89%E8%A7%81%E8%BF%87%E7%9A%84%E5%8D%95%E8%AF%8D%E6%88%96%E7%9F%AD%E8%AF%AD%E9%83%BD%E5%8F%AA%E6%98%AF%E5%8A%A0%E4%BA%86%E5%A5%BD%E5%8F%8B%E8%80%8C%E5%B7%B2/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">21｜你和所有见过的单词或短语都只是加了“好友”而已</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%9830%E8%AE%B2/2118%E4%B8%A8centos%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%A7%E7%9B%91%E6%8E%A7%E5%8F%8A%E5%B8%B8%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A3%E6%9E%90%E4%B8%8B/">
            <span class="next-text nav-default">2118丨CentOS操作系统级监控及常用计数器解析下</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
