<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>04｜跨越现实的障碍（上）：要性能还是要模型？ - Docs</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="你好，我是徐昊。今天我们来聊聊通过关联对象（Assocation Object）建模聚合（Aggregation）。
在前面三节课，我们学习了领域驱动设计中的“两关联一循环”：模型与软件实现关联；统一语言与模型关联；提炼知识的循环。其中，统一语言与提炼知识的循环作为一种更为平衡的权责关系，促进了业务方与技术方更好的协作。而这一切又是以模型与软件实现关联为基础。
" /><meta name="keywords" content="技术文档, docs, 极客时间" />






<meta name="generator" content="Hugo 0.140.2 with theme even" />


<link rel="canonical" href="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0%E4%B8%9A%E5%8A%A1%E5%BB%BA%E6%A8%A1/04%E8%B7%A8%E8%B6%8A%E7%8E%B0%E5%AE%9E%E7%9A%84%E9%9A%9C%E7%A2%8D%E4%B8%8A%E8%A6%81%E6%80%A7%E8%83%BD%E8%BF%98%E6%98%AF%E8%A6%81%E6%A8%A1%E5%9E%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://politcloud.org/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0%E4%B8%9A%E5%8A%A1%E5%BB%BA%E6%A8%A1/04%E8%B7%A8%E8%B6%8A%E7%8E%B0%E5%AE%9E%E7%9A%84%E9%9A%9C%E7%A2%8D%E4%B8%8A%E8%A6%81%E6%80%A7%E8%83%BD%E8%BF%98%E6%98%AF%E8%A6%81%E6%A8%A1%E5%9E%8B/">
  <meta property="og:site_name" content="Docs">
  <meta property="og:title" content="04｜跨越现实的障碍（上）：要性能还是要模型？">
  <meta property="og:description" content="你好，我是徐昊。今天我们来聊聊通过关联对象（Assocation Object）建模聚合（Aggregation）。
在前面三节课，我们学习了领域驱动设计中的“两关联一循环”：模型与软件实现关联；统一语言与模型关联；提炼知识的循环。其中，统一语言与提炼知识的循环作为一种更为平衡的权责关系，促进了业务方与技术方更好的协作。而这一切又是以模型与软件实现关联为基础。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-01-10T00:00:00+00:00">
    <meta property="article:tag" content="如何落地业务建模">

  <meta itemprop="name" content="04｜跨越现实的障碍（上）：要性能还是要模型？">
  <meta itemprop="description" content="你好，我是徐昊。今天我们来聊聊通过关联对象（Assocation Object）建模聚合（Aggregation）。
在前面三节课，我们学习了领域驱动设计中的“两关联一循环”：模型与软件实现关联；统一语言与模型关联；提炼知识的循环。其中，统一语言与提炼知识的循环作为一种更为平衡的权责关系，促进了业务方与技术方更好的协作。而这一切又是以模型与软件实现关联为基础。">
  <meta itemprop="datePublished" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-01-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="6661">
  <meta itemprop="keywords" content="如何落地业务建模">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="04｜跨越现实的障碍（上）：要性能还是要模型？">
  <meta name="twitter:description" content="你好，我是徐昊。今天我们来聊聊通过关联对象（Assocation Object）建模聚合（Aggregation）。
在前面三节课，我们学习了领域驱动设计中的“两关联一循环”：模型与软件实现关联；统一语言与模型关联；提炼知识的循环。其中，统一语言与提炼知识的循环作为一种更为平衡的权责关系，促进了业务方与技术方更好的协作。而这一切又是以模型与软件实现关联为基础。">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Docs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Docs</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">04｜跨越现实的障碍（上）：要性能还是要模型？</h1>

      <div class="post-meta">
        <span class="post-time"> 10100-01-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"> 极客时间 </a>
            </div>
          <span class="more-meta"> 约 6661 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#无法封装的数据库开销">无法封装的数据库开销</a>
          <ul>
            <li><a href="#集合遍历与-n1">集合遍历与 N+1</a></li>
            <li><a href="#smalltalk-中集合与数据库是等价的">Smalltalk 中集合与数据库是等价的</a></li>
            <li><a href="#多层架构彻底割裂了集合与数据库">多层架构彻底割裂了集合与数据库</a></li>
          </ul>
        </li>
        <li><a href="#关联对象">关联对象</a>
          <ul>
            <li><a href="#使用关联对象实现聚合关系">使用关联对象实现聚合关系</a></li>
            <li><a href="#隔离技术实现细节与领域逻辑">隔离技术实现细节与领域逻辑</a></li>
            <li><a href="#通过集体逻辑揭示意图">通过集体逻辑揭示意图</a></li>
          </ul>
        </li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#思考题">思考题</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>你好，我是徐昊。今天我们来聊聊通过关联对象（Assocation Object）建模聚合（Aggregation）。</p>
<p>在前面三节课，我们学习了领域驱动设计中的“两关联一循环”：模型与软件实现关联；统一语言与模型关联；提炼知识的循环。其中，统一语言与提炼知识的循环作为一种更为平衡的权责关系，促进了业务方与技术方更好的协作。而这一切又是以模型与软件实现关联为基础。</p>
<p>然而落地到实践中，关联模型与软件实现总有一些让人纠结与苦恼的地方。引起这些苦恼的主要原因是<strong>架构风格的变化</strong>。我们已经从单机时代过渡到了多层单体架构，以及云原生分布式架构，但我们所采用的建模思路与编程风格并没有彻底跟上时代的步伐，这种差异通常会以<strong>性能问题</strong>或是<strong>代码坏味道</strong>的形式出现。</p>
<p>如果我们想要真正发挥出领域驱动设计的作用，就需要<strong>在不同架构风格下，找到能够维持模型与软件实现统一的办法</strong>。这也是这个领域常看常新，总能产生新实践的原因。</p>
<p>因而接下来，我会用三节课来介绍一组实现模式，帮助我们应对从单机架构过渡到多层架构，保持模型与软件实现的关联。这些模式也是我们后面学习在微服务和云原生时代，实施领域驱动设计方法的基础。</p>
<p>今天这节课，我们就先从关联对象这一方法开始讲起。关联对象是一个古老的设计 / 分析模式，Martin Fowler 在《分析模式》中讨论过它。Peter Coad 将它视为一种常见的业务构成模式，并应用到业务分析中。而我大概从 2005 年开始，使用它建模领域驱动设计中的聚合与关联关系，以解决领域模型（Domain Model）中对技术组件的封装问题。</p>
<p>不过，在讲解到关联对象的具体做法之前，我们需要先看一下<strong>领域驱动设计中的聚合关系在具体实现中存在哪些问题</strong>。了解了问题所在，我们才能更有针对性地去寻找解决办法。</p>
<h2 id="无法封装的数据库开销">无法封装的数据库开销</h2>
<p>在应用领域驱动设计的时候，聚合与聚合根（Aggregation Root）是构成“富含知识的模型（Knowledge Rich Model）”的关键。通过聚合关系，我们可以将<strong>被聚合对象的集合逻辑放置于聚合 / 聚合根里，而不是散落在外，或是放在其他无关的服务中</strong>。这么做可以使得逻辑富集于模型中，避免“逻辑泄露”。</p>
<p>不过落到具体实现上，我们经常会遇到这样一个挑战，即：<strong>这些被聚合的对象，通常都是被数据库持久化</strong>（Persistent）<strong>的集合</strong>（Collection）。也就是说，数据库系统的引入，网络 I/O 与其他性能开销无法被接口抽象隔离。而将具体技术实现引入领域模型，则有悖领域驱动设计的理念。</p>
<p>接下来，我们就通过一个例子，在具体的上下文中看一看存在什么问题。然后，再看一下这个问题在建模思路上产生的根源，以及要如何修正我们的建模思路。</p>
<h3 id="集合遍历与-n1">集合遍历与 N+1</h3>
<p>让我们再回到在第二讲里展示的极客时间专栏的例子：</p>
<p>class User {</p>
<p>private List<Subscription> subscriptions;</p>
<p>// 获取用户订阅的所有专栏<br>
public List<Subscription> getSubscriptions() {<br>
&hellip;<br>
}</p>
<p>// 计算所订阅的专栏的总价<br>
public double getTotalSubscriptionFee() {<br>
&hellip;<br>
}<br>
}</p>
<p>class UserRepository {<br>
&hellip;<br>
public User findById(long id) {<br>
&hellip;<br>
}</p>
<p>按照面向对象和领域驱动设计提倡的做法，User 作为聚合根，需要管控其对应的 Subscription。现在我们有一个简单且常见的需求：在页面上，显示对用户已经订阅过的专栏进行分页处理。那么，我们大概会这么写：</p>
<p>user.getSubscriptions().subList(from, from + pageSize);</p>
<p>可以发现，在这段代码里，我们假设所有的 Subscription 都在内存里，因此所有的计算与逻辑都可以在内存中完成了。那么，我们就需要在读取 User 的时候，将它对应的所有订阅过的专栏信息都从数据库读取到内存中，以便后续使用。</p>
<p>如果是少量订阅的场景，比如几个或者几十个，那这段代码并没有什么问题。但如果有个特别好学的人，买了几万甚至几百万个专栏呢（先假设专栏有无限个）？此时将所有订阅过的专栏都读取到内存里，这就意味着会有巨大的网络 I/O 开销和内存占用。</p>
<p>当然，这里你可能会说，JPA/Hibernate 等 ORM 提供了延迟加载啊。是的，但这又会引入<strong>经典的性能瓶颈 N + 1 问题</strong>。因为随着延迟加载集合的遍历，其中的 Subscription 对象会被依次加载。</p>
<p>延迟加载的实现流程是这样的：</p>
<ol>
<li>先执行一条查询获取集合的概况。比如总共有多少条记录之类的信息。</li>
<li>然后根据概况信息，生成一个集合对象。这时候集合对象基本上是空的，不占用什么内存空间。</li>
<li>随后，当我们需要集合内的具体信息的时候，它再根据我们需要访问的对象，按需从数据库中读取。</li>
</ol>
<p>理论上讲，这是为了避免一次性读入大量数据带来的性能问题，而提出的解决办法。</p>
<p>然而，如果需要获取所有的数据，那么我们总共就会有 N+1 次数据库访问：1 次是指第一次获取概况的访问，N 次指而后集合中 N 个对象每个一次。而每一次加载，都伴随着对数据库的访问，自然就会带来 I/O 与数据库的开销。特别是频繁地对数据库访问，可能会阻塞其他人，从而造成性能瓶颈。</p>
<p>在这种情况下，我们其实没有什么好的选择：<strong>要么是一次性读入全部数据，避免 N + 1 问题；要么是引入 N+1 问题，变成钝刀子割肉</strong>。</p>
<p>为了避免这两种情况，很自然地，你会想起这样一种做法：通过查询语句一次性定位所需分页，这样只需要一次查询就能解决问题。不过这么做的困难在于，<strong>分页查询的逻辑要放在哪个对象上，才能保持模型与软件实现的关联</strong>。</p>
<p>一种做法是<strong>为订阅</strong>（Subscription）<strong>构造一个独立的 Repository 对象</strong>，将逻辑放在里面（也是 Spring 推荐的做法）：</p>
<p>interface SubscriptionRepository extends &hellip; {<br>
public Page<Subscription> findPaginated(int from, int size);<br>
}</p>
<p>这种做法的问题就是会导致<strong>逻辑泄露</strong>。Subscription 被 User 聚合，那么 User 所拥有的 Subscription 的集合逻辑应该被封装在 User 中，这样才能保证 User 是“逻辑丰富的模型”，因为<strong>非聚合根提供 Repository 是一种坏味道</strong>。</p>
<p>如果聚合到 User 上是可行的吗？其实也不行。因为这么做会将技术实现细节引入领域逻辑中，而无法保持领域逻辑的独立。代码如下：</p>
<p>public class User {<br>
public List<Subscription> getSubscriptions() {<br>
&hellip;.<br>
}</p>
<pre><code>public List&lt;Subscription&gt; getSubscriptions(int from, int size) {  
   return db.executeQuery(....);  
}  
</code></pre>
<p>}</p>
<p>造成这种两难局面的根源在于，<strong>我们希望在模型中使用集合接口，并借助它封装具体技术实现的细节</strong>。因为在我们的概念中，<strong>内存中的集合与数据库是等价的，都可以通过集合接口封装</strong>。但实际情况是，我们无法忽略数据库带来的额外作用与开销，内存中的集合与数据库并不是等价的，封装失败。</p>
<p>那么，为什么在我们的概念中，我们会认为内存中的集合与数据库是等价的，是可以通过集合接口封装的呢？这就要从面向对象技术的开端——Smalltalk 系统说起了。</p>
<h3 id="smalltalk-中集合与数据库是等价的">Smalltalk 中集合与数据库是等价的</h3>
<p>鲜少有人了解的一个事实是，<strong>集合与数据库的等价，在早期面向对象系统 Smalltalk 中是一个基础概念</strong>。</p>
<p>这其实不难理解，如果对象中包含的状态可以映射为数据库表中的一列，那么一组对象自然就可以映射成一张表了。有了一张表，自然也就可以看作是一个最小的数据库了。</p>
<p>Smalltalk 作为面向对象系统内置的一套<strong>面向对象数据库</strong>（Object Oriented Database）。于是在使用 Smalltalk 系统时，集合与数据库是无差别的。如下图所示，展示了 Smalltalk 系统的构成。</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0%E4%B8%9A%E5%8A%A1%E5%BB%BA%E6%A8%A1/d4050e59b3444566ff3f52a78c0f6e9c.png" alt=""></p>
<p>如上图所示，Smalltalk 中除了虚拟机（Virtual Machine）之外，还有虚拟镜像（Virtual Image，VI）。<strong>虚拟镜像相当于虚拟机内存的持久化保存</strong>。每次虚拟机启动的时候，都会把虚拟镜像中的信息读入到内存中以恢复状态，而 Java、.NET 虚拟机并不会保留之前内存中的信息。</p>
<p>打个比方。Smalltalk 虚拟机的启动过程，类似于 VMWare 虚拟机上的 Pause，内存中的所有状态都被持久化保存了，那么我们可以继续从之前暂停的地方开始。而其他语言的虚拟机则是彻底地重启（Restart），并不会保留之前的结果。</p>
<p>在 Smalltalk 的虚拟镜像中，存储着所有的代码和数据。我们称呼 Smalltalk 为一个面向对象系统，而不仅仅是面向对象语言。因为它既是一门面向对象语言，也是一个虚拟机的操作系统，还是一个面向对象数据库。</p>
<p>那么在这样的系统中，Smalltalk 中的集合（无论是 Array、List，还是什么）就等同于一个数据库。只要这个集合被创建出来，除非显示化地通过垃圾回收销毁，否则它就会被虚拟镜像持久化。<strong>垃圾收集和持久化一样，都可以被看作是对象生命周期</strong>（Object Lifecycle）<strong>的一个状态</strong>。</p>
<p>因此，数据库中的数据和非数据库中的数据，都可以通过 Collection 表达，我们不用再去区分它。而在 Smalltalk 中，这种等价关系深刻影响了我们的思路和建模习惯，毕竟我们所熟知的面向对象语言都从 Smalltalk 中借鉴了大量的概念。而早期的建模者也大都来自 Smalltalk 社区，比如 Peter Coad、Kent Beck、Martin Fowler 等（当然我也是）。所以我们学习建模方法的时候，或多或少有一些源自 Smalltalk 社区的习惯。</p>
<p>然而随着时代的发展，这种习惯在多层架构（Mulit-tier Architecture）下遇到了挑战。那么接下来我们就看看多层架构是怎么彻底割裂了集合与数据库的。</p>
<h3 id="多层架构彻底割裂了集合与数据库">多层架构彻底割裂了集合与数据库</h3>
<p>Smalltalk 在中国未曾真正地流行过，大多数人是从 C++ 甚至是 Java、.NET 开始接触面向对象编程的。而无论是 C++、Java，还是后来的面向对象编程语言，其实都不是完整的面向对象系统。</p>
<p>集合作为面向对象中的重要概念，被吸纳入这些语言后，就去掉了与数据库的强关联（毕竟这些语言默认不带有数据库模块）。因此，集合虽然在概念上仍然等同于数据库，但如此简单粗暴的建模，就会遇到我们前面提到的“是否 N+1”的两难选择。</p>
<p>那么 Java、.NET 这些语言为什么要这么做呢？它们为什么不能像 Smalltalk 一样，内涵完整地面对象数据库呢？这其实是架构风格演化的结果。</p>
<p>我们明显可以发现，<strong>Smalltalk 是典型的单机单体架构</strong>。从操作系统、数据库到应用程序，都在一个虚拟机上，就好像是一台小型机一样。这样的<strong>架构结构无法水平扩展</strong>（horizontal scaling）<strong>，只能垂直扩展</strong>（vertical scaling）。这就意味着我们需要<strong>不断提高单点的计算能力，才能提高整个的容量与吞吐</strong>。这并不符合架构的整体发展趋势。</p>
<p>进入 21 世纪后，随着对系统容量要求的增加，易于水平扩展的三层架构逐渐成为行业主流。而数据库作为一个独立组件，则不再与应用合体。示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0%E4%B8%9A%E5%8A%A1%E5%BB%BA%E6%A8%A1/aeaa227d21999e9c21c815bef0b501bf.png" alt=""></p>
<p>于是，Smalltalk 的面向对象系统在这种架构下分别变成了：应用程序中间件（对应 Smalltalk 虚拟机）和数据库（对应 Smalltalk 虚拟镜像的持久化数据部分）。</p>
<p>多层架构彻底割裂了对象集合与数据库，这对我们实现领域模型建模提出了挑战，对 Collection 逻辑的建模也就难以摆脱具体实现细节了。那就是我们<strong>必须明确哪些是持久化的数据，并对它的一些逻辑区别对待</strong>。这就是原味面向对象范型（Vanilla Object Oriented），在架构风格演化过程中遇到的挑战。</p>
<p>几乎所有实施过 DDD 的人，都在这个问题上挣扎过。如果对于如此常见且如此简单的分页功能，我们都无法将模型与软件实现关联的话。那么，面对更复杂的问题时我们要怎么办呢？这是大多数怀揣理想准备实施 DDD 的人，碰到的第一个阻碍。</p>
<p>关联对象就是一种解决这个问题的设计模式。</p>
<h2 id="关联对象">关联对象</h2>
<p><strong>关联对象</strong>，顾名思义，就是<strong>将对象间的关联关系直接建模出来，然后再通过接口与抽象的隔离，把具体技术实现细节封装到接口的实现中</strong>。这样既可以保证概念上的统一，又能够避免技术实现上的限制。</p>
<p>现在让我们再来看看极客时间专栏的例子，如果使用关联对象，如何帮我们避免 N+1 和逻辑泄露的问题。</p>
<h3 id="使用关联对象实现聚合关系">使用关联对象实现聚合关系</h3>
<p>首先我们需要定义关联对象，因为我们需要表达的是 User 与 Subscription 间的一对多的关系，那么最简单的命名方法是将两个对象名字组合，从而得到关联对象的名字 UserSubscriptions：</p>
<p>public interface UserSubscriptions extends Iterable<Subscription> {<br>
List<Subscription> subList(int from, int to); //分页<br>
double getTotalSubscriptionFee(); //获取总共花费<br>
int count(); //获取总订阅数<br>
Iterable<Subscription> sort(&hellip;);<br>
&hellip;.<br>
}</p>
<p>当然，我们最好是从业务上下文出发，寻找更具有业务含义的名字，毕竟我们是要形成统一语言的，源自业务的名字总是更容易被非技术角色所理解。</p>
<p>比如这里我们要表达的是用户已经订阅的专栏，或者是用户已经购买的专栏，那么 PaidColumn，甚至 MySubscriptions，都不错，看哪一个更容易被团队接受了。我这里选择 MySubscriptions，于是 User 对象就变成了这样：</p>
<p>public interface MySubscriptions extends Iterable<Subscription> {<br>
&hellip;<br>
}</p>
<p>public class User {<br>
private MySubscriptions mySubscriptions;</p>
<p>public MySubscriptions getMySubscriptions() {<br>
return mySubscriptions<br>
}<br>
}</p>
<p>那么之前对于分页和计算的调用也就相应地变为：</p>
<p>user.getMySubscriptions().subList(0, 10);<br>
user.getMySubscriptions().getTotalSubscriptionFee();</p>
<p>很明显，我们没有逻辑泄露，User 是 Subscription 的聚合根，那么与之相关的逻辑也仍然被封装在 User 的上下文中，当然是进一步被封装在关联对象中。</p>
<p>那么我们怎么解决持久化的问题呢？怎么从领域对象中，移除掉对技术实现的依赖呢？秘诀就在于<strong>接口与实现分离</strong>。代码如下：</p>
<p>package model.impl.db;</p>
<p>public class MySubscriptionsDB implements MySubscriptions {<br>
&hellip;<br>
private User user;</p>
<p>public List<Subscription> subList(int from, int to) {<br>
return db.executeQuery(&hellip;);<br>
}<br>
&hellip;</p>
<p>在这里，我们将与数据库访问相关的逻辑毫不避讳地封装到 MySubscriptionsDB 中。不过，作为领域对象的 User 类，并不会知道它使用了数据库，因为它仅仅通过 MySubscriptions 接口，访问它所需要的功能。此时我们可以通过简单的分包的策略：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0%E4%B8%9A%E5%8A%A1%E5%BB%BA%E6%A8%A1/c808fc07ab61b3744fe9cb47af181d35.png" alt=""></p>
<p>从上图中包的架构上看，模型的包中有 MySubscriptions、User、UserRepository。与数据库相关的代码的包里有 MySubscriptionsDB 和 UserRepositoryDB。于是，我们成功地将核心的领域逻辑与实现细节分开了。</p>
<p>当然最后还有一个问题：<strong>如何将 MySubscriptionsDB 与 User 结合在一起</strong>？最直接的做法就是这样：</p>
<p>public UserRepositoryDB implements UserRepository {<br>
&hellip;<br>
public User findBy(long id) {<br>
User user = &hellip;..;<br>
return setMySubscription(user);<br>
}</p>
<p>public List<User> findBy(&hellip;.) {<br>
List<User> user = &hellip;..;<br>
return user.map(user -&gt; setMySubscription(user));<br>
}</p>
<p>private User setMySubscription(User user) {<br>
user.setMySubscriptions(new MySubscriptionDB(db, user));<br>
return user;     <br>
}<br>
}</p>
<p>因为 User 是聚合根，从数据库中读取的 User 对象都需要从 UserRepository 中获取。那么，在 UserRepository 的具体实现中为 User 对象设置 MySubscription 对象，是再自然不过的选择了。</p>
<p>当然更简洁漂亮的做法，是通过 Java CDI API 或是框架提供的生命周期实践监听器，来完成关联对象的设置。</p>
<h3 id="隔离技术实现细节与领域逻辑">隔离技术实现细节与领域逻辑</h3>
<p>通过引入关联对象，我们可以更好地隔离领域逻辑与技术实现细节。在这里，我们还是用极客时间专栏的例子来解释。</p>
<p>如果这时候 Subscription 信息并不是存在数据库中，而是通过 RESTful API 从另一个系统中获取的。那么，我们只需提供另一个 MySubscriptions 的实现就可以了：</p>
<p>package model.impl.api;</p>
<p>public class MySubscriptionsAPI implements MySubscriptions {<br>
&hellip;<br>
private User user;</p>
<p>public List<Subscription> subList(int from, int to) {<br>
return client.findSubscriptions(&hellip;.);<br>
}<br>
&hellip;</p>
<p>这种改变并不会传递到领域逻辑层，对于分页和计算的调用仍然为：</p>
<p>user.getMySubscriptions().subList(0, 10);<br>
user.getMySubscriptions().getTotalSubscriptionFee();</p>
<p>RESTful API 的性能瓶颈和需要调整的地方与数据库不同，这种变化都被关联对象的接口封装隔离了。</p>
<p>从面向对象编程的角度来说，我们很容易理解为什么关联对象可以带来如此多的好处。在诸多面向对象的最佳实践中，有一条是说要尽可能避免使用原始类型（primitive type）。因为原始类型没有对概念进行提取，也缺乏封装，所以我们应该尽可能地使用自定义的类去替换它们。</p>
<p>不过如果我们把语言内提供的集合类型（List 等）也当作原始类型的话，关联对象就是对这一条建议自然的扩展：<strong>使用自定义关联对象，而不是集合类型来表示对象间的关联</strong>。</p>
<h3 id="通过集体逻辑揭示意图">通过集体逻辑揭示意图</h3>
<p>关联对象除了可以帮助聚拢逻辑、隔离实现细节之外，还能从概念上帮助我们获得更好的领域模型，因为关联对象是对集体逻辑的直接建模。</p>
<p>所谓<strong>集体逻辑，是指个体不具备，而成为一个集体之后才具备的能力。哪怕是同一群个体，组成了不同的集体，就会具有不同的逻辑</strong>。</p>
<p>我们仍然回到极客时间专栏的例子上，来帮助你理解。比如我们现在的模型是这样的：</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0%E4%B8%9A%E5%8A%A1%E5%BB%BA%E6%A8%A1/ca28af6fe43bc3ed117c1e588bd87ccb.png" alt=""></p>
<p>public class User {<br>
private List<Subscription> subscriptions;</p>
<p>&hellip;.<br>
}</p>
<p>public class Column {<br>
private List<Subscription> subscriptions;</p>
<pre><code>....  
</code></pre>
<p>}</p>
<p>在这段代码中，User 中的 List表示用户已订阅的所有专栏，而 Column 中的 List，则表示所有订阅了专栏的用户。虽然同为 Subscription 的集合，但是当它们组成集体时，在不同的上下文中则具有不同的含义。</p>
<p>那么如果显式地表达为关联对象，可以进一步澄清我们的意图，得到揭示意图的接口（Intention Revealing Interface）。代码如下：</p>
<p>public class User {</p>
<p>public static interface MySubscriptions extends Iterable<Subscription> {<br>
&hellip;<br>
}</p>
<p>private MySubscriptions mySubscriptions;</p>
<p>&hellip;<br>
}</p>
<p>public class Column {</p>
<pre><code>public static interface MyReaders extends Iterable&lt;Subscription&gt; {  
...  
}  
  
private MyReaders myReaders；  


..
</code></pre>
<p>在这段代码中，我们通过引入关联对象，可以将这两个不同的集体变更为 User.MySubscriptions 和 Column.MyReaders，然后在各自的上下文去定义不同的集体逻辑。</p>
<p>比如我订阅的专栏可以计算我一共付了多少钱，而在我的读者中，可以计算订阅者对专栏的平均打分情况，示意代码如下：</p>
<p>public static interface MySubscriptions extends Iterable<Subscription> {<br>
double getTotalFee();<br>
}</p>
<p>public static interface MyReaders extends Iterable<Subscription> {<br>
double getAverageRating();<br>
}</p>
<h2 id="小结">小结</h2>
<p>我们来简单地总结一下。随着架构风格的演化与改变，面向对象技术中的集合，从与数据库完全等价，变成了与数据库完全割裂的东西。</p>
<p>然而在概念上，我们仍留有<strong>通过集合封装内存中的对象与数据库中的数据</strong>的习惯。这使得我们在使用领域驱动设计的时候，特别是使用聚合关系的时候，变得左右为难：<strong>要么放弃性能，获得更好的模型；要么泄露逻辑，以得到可接受的性能</strong>。</p>
<p>但是关联对象，则可以让我们在更加明确揭示意图的同时，去解决性能与逻辑封装的问题。我个人从很早就开始将关联对象作为实现聚合关系的默认方法了，它从未让我失望（it never fails me）。我建议你也试一试，这样我就不用给你解释什么叫惊喜了。</p>
<h2 id="思考题">思考题</h2>
<p>关联对象实际上是通过将隐式的概念显式化建模来解决问题的，这是面向对象技术解决问题的通则：永远可以通过引入另一个对象解决问题。那么在领域模型中还有哪些隐式概念呢？这些概念会给我们带来什么麻烦呢？</p>
<p><img src="https://raw.githubusercontent.com/epic1268/images/master/%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0%E4%B8%9A%E5%8A%A1%E5%BB%BA%E6%A8%A1/32b72df9abfef1134359a49f7fe79d96.png" alt=""></p>
<p>欢迎把你的思考和想法分享在留言区，我会和你交流。同时呢，我也会把其中一些不错的回答置顶，供大家学习。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        10100-01-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0%E4%B8%9A%E5%8A%A1%E5%BB%BA%E6%A8%A1/">如何落地业务建模</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/vim%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/04%E5%88%9D%E6%AD%A5%E5%AE%9A%E5%88%B6%E8%AE%A9%E4%BD%A0%E7%9A%84_vim_%E6%9B%B4%E9%A1%BA%E6%89%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">04｜初步定制：让你的_Vim_更顺手</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/reacthooks%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/04%E5%86%85%E7%BD%AE_hooks2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E5%AE%9A%E4%B9%89%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/">
            <span class="next-text nav-default">04｜内置_Hooks（2）：为什么要避免重复定义回调函数？</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2024 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVZ07KBD4X"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-FVZ07KBD4X');
        }
      </script>






</body>
</html>
